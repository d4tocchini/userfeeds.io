/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/apps/links/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@userfeeds/core/index.js":
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
  ethereum: {
    claims: __webpack_require__("../../node_modules/@userfeeds/core/src/ethereumClaims.js"),
  },
  utils: __webpack_require__("../../node_modules/@userfeeds/core/src/utils/index.js"),
};


/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/ethereumClaims.js":
/***/ (function(module, exports, __webpack_require__) {

const { getCurrentNetworkName } = __webpack_require__("../../node_modules/@userfeeds/core/src/utils/index.js");
const {
  payableAbi,
  notpayableAbi,
  getContractAddress,
} = __webpack_require__("../../node_modules/@userfeeds/core/src/utils/contract.js");

function sendPayableClaim(address, claim, value) {
  const contract = web3.eth.contract(payableAbi)
    .at(getContractAddress(getCurrentNetworkName(), true));

  return new Promise((resolve, reject) => {
    contract.post(
      address,
      JSON.stringify(claim),
      { value: web3.toWei(value, 'ether') },
      (errror, result) => {
        if (errror) {
          return reject(errror);
        }
        return resolve(result);
      },
    );
  });
}

function sendNotpayableClaim(address, claim) {
  const contract = web3.eth.contract(notpayableAbi)
    .at(getContractAddress(getCurrentNetworkName(), false));

  return new Promise((resolve, reject) => {
    contract.post(
      JSON.stringify(claim),
      (errror, result) => {
        if (errror) {
          return reject(errror);
        }
        return resolve(result);
      },
    );
  });
}

function sendClaim(address, claim, value) {
  const payable = value !== undefined;

  return payable
    ? sendPayableClaim(address, claim, value)
    : sendNotpayableClaim(address, claim);
}

module.exports = {
  sendClaim,
  sendPayableClaim,
  sendNotpayableClaim,
};



/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/utils/contract.js":
/***/ (function(module, exports) {


const payableContractAddressMapping = {
  ropsten: '0xa845c686a696c3d33988917c387d8ab939c66226',
  rinkeby: '0x0a48ac8263d9d79768d10cf9d7e82a19c49f0002',
};

const notpayableContractAddressMapping = {
  ropsten: '0x5c3fe6b94b57c1e294000403340f12f083e71b83',
  rinkeby: '0x09dcdf34e0c28b106fdfe51009cb71ae92bf8bbc',
};

function getContractAddress(networkName, payable = true) {
  let contract;
  if (payable) {
    contract = payableContractAddressMapping[networkName];
  } else {
    contract = notpayableContractAddressMapping[networkName];
  }

  if (!contract) {
    throw new Error('Contract is not available');
  }

  return contract;
}

const payableAbi = [{
  constant: false,
  inputs: [
    { name: 'userfeed', type: 'address' },
    { name: 'data', type: 'string' },
  ],
  name: 'post',
  outputs: [],
  payable: true,
  type: 'function',
}, {
  anonymous: false,
  inputs: [
    { name: 'sender', type: 'address', indexed: false },
    { name: 'userfeed', type: 'address', indexed: false },
    { name: 'data', type: 'string', indexed: false },
  ],
  name: 'Claim',
  type: 'event',
}];

const notpayableAbi = [{
  constant: false,
  inputs: [
    { name: 'data', type: 'string' },
  ],
  name: 'post',
  outputs: [],
  payable: false,
  type: 'function',
}, {
  anonymous: false,
  inputs: [
    { name: 'sender', type: 'address', indexed: false },
    { name: 'data', type: 'string', indexed: false },
  ],
  name: 'Claim',
  type: 'event'
}];

module.exports = {
  payableAbi,
  notpayableAbi,
  getContractAddress,
};


/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/utils/index.js":
/***/ (function(module, exports) {


const networkMapping = {
  '1': 'ethereum',
  '3': 'ropsten',
  '4': 'rinkeby',
  '42': 'kovan',
};

function getCurrentNetworkName() {
  if (!web3) {
    throw new Error('web3 not available');
  }

  return networkMapping[web3.version.network];
}

module.exports = {
  getCurrentNetworkName,
};



/***/ }),

/***/ "../../node_modules/bignumber.js/bignumber.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! bignumber.js v4.0.4 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (globalObj) {
    'use strict';

    /*
      bignumber.js v4.0.4
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2017 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var BigNumber,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32


    /*
     * Create and return a BigNumber constructor.
     */
    function constructorFactory(config) {
        var div, parseNumeric,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 0,                       // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 && ( n > MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
                    raise( id, tooManyDigits, x.s * n );
                }

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = constructorFactory;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = BigNumber.set = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === true || v === false || v === 1 || v === 0 ) {
                    if (v) {
                        v = typeof crypto == 'undefined';
                        if ( !v && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                            CRYPTO = true;
                        } else if (ERRORS) {
                            raise( 2, 'crypto unavailable', v ? void 0 : crypto );
                        } else {
                            CRYPTO = false;
                        }
                    } else {
                        CRYPTO = false;
                    }
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {

                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = crypto.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {

                        // buffer
                        a = crypto.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                crypto.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else {
                        CRYPTO = false;
                        if (ERRORS) raise( 14, 'crypto unavailable', crypto );
                    }
                }

                // Use Math.random.
                if (!CRYPTO) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc = [1].concat(xc);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x = [carry].concat(x);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.splice(0, 1) );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz = [0].concat(yz);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod = [0].concat(prod);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.splice(0, 1);
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on ±Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ ( LOG_BASE - sd % LOG_BASE ) % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is ±Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.splice(0, 1), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return ±Infinity if either ±Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }

            if (a) {
                xc = [a].concat(xc);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be ±0 if k < 0, or ±Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, ±Infinity or ±0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return ±Infinity if either is ±Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return ±0 if either is ±0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.splice(0, 1);
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            return +this;
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If m is present, return the result modulo m.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using
         * ROUNDING_MODE.
         *
         * The modular power operation works efficiently when x, n, and m are positive integers,
         * otherwise it is equivalent to calculating x.toPower(n).modulo(m) (with POW_PRECISION 0).
         *
         * n {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         * [m] {number|string|BigNumber} The modulus.
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         *
         * Performs 54 loop iterations for n of 9007199254740991.
         */
        P.toPower = P.pow = function ( n, m ) {
            var k, y, z,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            if ( m != null ) {
                id = 23;
                m = new BigNumber(m);
            }

            // Pass ±Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) || n == 0 ) {
                k = Math.pow( +x, n );
                return new BigNumber( m ? k % m : k );
            }

            if (m) {
                if ( n > 1 && x.gt(ONE) && x.isInt() && m.gt(ONE) && m.isInt() ) {
                    x = x.mod(m);
                } else {
                    z = m;

                    // Nullify m so only a single mod operation is performed at the end.
                    m = null;
                }
            } else if (POW_PRECISION) {

                // Truncating each coefficient array to a length of k after each multiplication
                // equates to truncating significant digits to POW_PRECISION + [28, 41],
                // i.e. there will be a minimum of 28 guard digits retained.
                // (Using + 1.5 would give [9, 21] guard digits.)
                k = mathceil( POW_PRECISION / LOG_BASE + 2 );
            }

            y = new BigNumber(ONE);

            for ( ; ; ) {
                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if (k) {
                        if ( y.c.length > k ) y.c.length = k;
                    } else if (m) {
                        y = y.mod(m);
                    }
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;
                x = x.times(x);
                if (k) {
                    if ( x.c && x.c.length > k ) x.c.length = k;
                } else if (m) {
                    x = x.mod(m);
                }
            }

            if (m) return y;
            if ( n < 0 ) y = ONE.div(y);

            return z ? y.mod(z) : k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };


        /*
         * Return as toString, but do not accept a base argument, and include the minus sign for
         * negative zero.
         */
        P.valueOf = P.toJSON = function () {
            var str,
                n = this,
                e = n.e;

            if ( e === null ) return n.toString();

            str = coeffToString( n.c );

            str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                ? toExponential( str, e )
                : toFixedPoint( str, e );

            return n.s < 0 ? '-' + str : str;
        };


        P.isBigNumber = true;

        if ( config != null ) BigNumber.config(config);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


    BigNumber = constructorFactory();
    BigNumber['default'] = BigNumber.BigNumber = BigNumber;


    // AMD.
    if ( true ) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return BigNumber; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

    // Node.js and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = BigNumber;

    // Browser.
    } else {
        if ( !globalObj ) globalObj = typeof self != 'undefined' ? self : Function('return this')();
        globalObj.BigNumber = BigNumber;
    }
})(this);


/***/ }),

/***/ "../../node_modules/classnames/bind.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(this && this[arg] || arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(this, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(this && this[key] || key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),

/***/ "../../node_modules/classnames/index.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),

/***/ "../../node_modules/crypto-js/aes.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/cipher-core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;

	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }
	            this._mode = modeCreator.call(mode, this, iv && iv.words);
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ "../../node_modules/crypto-js/core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/enc-base64.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/enc-utf16.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/evpkdf.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/format-hex.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/hmac.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ "../../node_modules/crypto-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"), __webpack_require__("../../node_modules/crypto-js/lib-typedarrays.js"), __webpack_require__("../../node_modules/crypto-js/enc-utf16.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/sha256.js"), __webpack_require__("../../node_modules/crypto-js/sha224.js"), __webpack_require__("../../node_modules/crypto-js/sha512.js"), __webpack_require__("../../node_modules/crypto-js/sha384.js"), __webpack_require__("../../node_modules/crypto-js/sha3.js"), __webpack_require__("../../node_modules/crypto-js/ripemd160.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"), __webpack_require__("../../node_modules/crypto-js/pbkdf2.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"), __webpack_require__("../../node_modules/crypto-js/mode-cfb.js"), __webpack_require__("../../node_modules/crypto-js/mode-ctr.js"), __webpack_require__("../../node_modules/crypto-js/mode-ctr-gladman.js"), __webpack_require__("../../node_modules/crypto-js/mode-ofb.js"), __webpack_require__("../../node_modules/crypto-js/mode-ecb.js"), __webpack_require__("../../node_modules/crypto-js/pad-ansix923.js"), __webpack_require__("../../node_modules/crypto-js/pad-iso10126.js"), __webpack_require__("../../node_modules/crypto-js/pad-iso97971.js"), __webpack_require__("../../node_modules/crypto-js/pad-zeropadding.js"), __webpack_require__("../../node_modules/crypto-js/pad-nopadding.js"), __webpack_require__("../../node_modules/crypto-js/format-hex.js"), __webpack_require__("../../node_modules/crypto-js/aes.js"), __webpack_require__("../../node_modules/crypto-js/tripledes.js"), __webpack_require__("../../node_modules/crypto-js/rc4.js"), __webpack_require__("../../node_modules/crypto-js/rabbit.js"), __webpack_require__("../../node_modules/crypto-js/rabbit-legacy.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/lib-typedarrays.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/md5.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-cfb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ctr-gladman.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ctr.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ecb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ofb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-ansix923.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-iso10126.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-iso97971.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-nopadding.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-zeropadding.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pbkdf2.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rabbit-legacy.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rabbit.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rc4.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/ripemd160.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha1.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha224.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha256.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha256.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha3.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha384.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"), __webpack_require__("../../node_modules/crypto-js/sha512.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha512.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/tripledes.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/x64-core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/normalize.css/normalize.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}[hidden],template{display:none}", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/open-iconic/font/css/open-iconic.min.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, "@font-face{font-family:Icons;src:url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.eot") + ");src:url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.eot") + "?#iconic-sm) format(\"embedded-opentype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.woff") + ") format(\"woff\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.ttf") + ") format(\"truetype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.otf") + ") format(\"opentype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.svg") + "#iconic-sm) format(\"svg\");font-weight:400;font-style:normal}.oi[data-glyph].oi-text-replace{font-size:0;line-height:0}.oi[data-glyph].oi-text-replace:before{width:1em;text-align:center}.oi[data-glyph]:before{font-family:Icons;display:inline-block;speak:none;line-height:1;vertical-align:baseline;font-weight:400;font-style:normal;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.oi[data-glyph]:empty:before{width:1em;text-align:center;box-sizing:content-box}.oi[data-glyph].oi-align-left:before{text-align:left}.oi[data-glyph].oi-align-right:before{text-align:right}.oi[data-glyph].oi-align-center:before{text-align:center}.oi[data-glyph].oi-flip-horizontal:before{-webkit-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1)}.oi[data-glyph].oi-flip-vertical:before{-webkit-transform:scaleY(-1);-ms-transform:scaleX(-1);transform:scaleY(-1)}.oi[data-glyph].oi-flip-horizontal-vertical:before{-webkit-transform:scale(-1);-ms-transform:scaleX(-1);transform:scale(-1)}.oi[data-glyph=account-login]:before{content:\"\\E000\"}.oi[data-glyph=account-logout]:before{content:\"\\E001\"}.oi[data-glyph=action-redo]:before{content:\"\\E002\"}.oi[data-glyph=action-undo]:before{content:\"\\E003\"}.oi[data-glyph=align-center]:before{content:\"\\E004\"}.oi[data-glyph=align-left]:before{content:\"\\E005\"}.oi[data-glyph=align-right]:before{content:\"\\E006\"}.oi[data-glyph=aperture]:before{content:\"\\E007\"}.oi[data-glyph=arrow-bottom]:before{content:\"\\E008\"}.oi[data-glyph=arrow-circle-bottom]:before{content:\"\\E009\"}.oi[data-glyph=arrow-circle-left]:before{content:\"\\E00A\"}.oi[data-glyph=arrow-circle-right]:before{content:\"\\E00B\"}.oi[data-glyph=arrow-circle-top]:before{content:\"\\E00C\"}.oi[data-glyph=arrow-left]:before{content:\"\\E00D\"}.oi[data-glyph=arrow-right]:before{content:\"\\E00E\"}.oi[data-glyph=arrow-thick-bottom]:before{content:\"\\E00F\"}.oi[data-glyph=arrow-thick-left]:before{content:\"\\E010\"}.oi[data-glyph=arrow-thick-right]:before{content:\"\\E011\"}.oi[data-glyph=arrow-thick-top]:before{content:\"\\E012\"}.oi[data-glyph=arrow-top]:before{content:\"\\E013\"}.oi[data-glyph=audio-spectrum]:before{content:\"\\E014\"}.oi[data-glyph=audio]:before{content:\"\\E015\"}.oi[data-glyph=badge]:before{content:\"\\E016\"}.oi[data-glyph=ban]:before{content:\"\\E017\"}.oi[data-glyph=bar-chart]:before{content:\"\\E018\"}.oi[data-glyph=basket]:before{content:\"\\E019\"}.oi[data-glyph=battery-empty]:before{content:\"\\E01A\"}.oi[data-glyph=battery-full]:before{content:\"\\E01B\"}.oi[data-glyph=beaker]:before{content:\"\\E01C\"}.oi[data-glyph=bell]:before{content:\"\\E01D\"}.oi[data-glyph=bluetooth]:before{content:\"\\E01E\"}.oi[data-glyph=bold]:before{content:\"\\E01F\"}.oi[data-glyph=bolt]:before{content:\"\\E020\"}.oi[data-glyph=book]:before{content:\"\\E021\"}.oi[data-glyph=bookmark]:before{content:\"\\E022\"}.oi[data-glyph=box]:before{content:\"\\E023\"}.oi[data-glyph=briefcase]:before{content:\"\\E024\"}.oi[data-glyph=british-pound]:before{content:\"\\E025\"}.oi[data-glyph=browser]:before{content:\"\\E026\"}.oi[data-glyph=brush]:before{content:\"\\E027\"}.oi[data-glyph=bug]:before{content:\"\\E028\"}.oi[data-glyph=bullhorn]:before{content:\"\\E029\"}.oi[data-glyph=calculator]:before{content:\"\\E02A\"}.oi[data-glyph=calendar]:before{content:\"\\E02B\"}.oi[data-glyph=camera-slr]:before{content:\"\\E02C\"}.oi[data-glyph=caret-bottom]:before{content:\"\\E02D\"}.oi[data-glyph=caret-left]:before{content:\"\\E02E\"}.oi[data-glyph=caret-right]:before{content:\"\\E02F\"}.oi[data-glyph=caret-top]:before{content:\"\\E030\"}.oi[data-glyph=cart]:before{content:\"\\E031\"}.oi[data-glyph=chat]:before{content:\"\\E032\"}.oi[data-glyph=check]:before{content:\"\\E033\"}.oi[data-glyph=chevron-bottom]:before{content:\"\\E034\"}.oi[data-glyph=chevron-left]:before{content:\"\\E035\"}.oi[data-glyph=chevron-right]:before{content:\"\\E036\"}.oi[data-glyph=chevron-top]:before{content:\"\\E037\"}.oi[data-glyph=circle-check]:before{content:\"\\E038\"}.oi[data-glyph=circle-x]:before{content:\"\\E039\"}.oi[data-glyph=clipboard]:before{content:\"\\E03A\"}.oi[data-glyph=clock]:before{content:\"\\E03B\"}.oi[data-glyph=cloud-download]:before{content:\"\\E03C\"}.oi[data-glyph=cloud-upload]:before{content:\"\\E03D\"}.oi[data-glyph=cloud]:before{content:\"\\E03E\"}.oi[data-glyph=cloudy]:before{content:\"\\E03F\"}.oi[data-glyph=code]:before{content:\"\\E040\"}.oi[data-glyph=cog]:before{content:\"\\E041\"}.oi[data-glyph=collapse-down]:before{content:\"\\E042\"}.oi[data-glyph=collapse-left]:before{content:\"\\E043\"}.oi[data-glyph=collapse-right]:before{content:\"\\E044\"}.oi[data-glyph=collapse-up]:before{content:\"\\E045\"}.oi[data-glyph=command]:before{content:\"\\E046\"}.oi[data-glyph=comment-square]:before{content:\"\\E047\"}.oi[data-glyph=compass]:before{content:\"\\E048\"}.oi[data-glyph=contrast]:before{content:\"\\E049\"}.oi[data-glyph=copywriting]:before{content:\"\\E04A\"}.oi[data-glyph=credit-card]:before{content:\"\\E04B\"}.oi[data-glyph=crop]:before{content:\"\\E04C\"}.oi[data-glyph=dashboard]:before{content:\"\\E04D\"}.oi[data-glyph=data-transfer-download]:before{content:\"\\E04E\"}.oi[data-glyph=data-transfer-upload]:before{content:\"\\E04F\"}.oi[data-glyph=delete]:before{content:\"\\E050\"}.oi[data-glyph=dial]:before{content:\"\\E051\"}.oi[data-glyph=document]:before{content:\"\\E052\"}.oi[data-glyph=dollar]:before{content:\"\\E053\"}.oi[data-glyph=double-quote-sans-left]:before{content:\"\\E054\"}.oi[data-glyph=double-quote-sans-right]:before{content:\"\\E055\"}.oi[data-glyph=double-quote-serif-left]:before{content:\"\\E056\"}.oi[data-glyph=double-quote-serif-right]:before{content:\"\\E057\"}.oi[data-glyph=droplet]:before{content:\"\\E058\"}.oi[data-glyph=eject]:before{content:\"\\E059\"}.oi[data-glyph=elevator]:before{content:\"\\E05A\"}.oi[data-glyph=ellipses]:before{content:\"\\E05B\"}.oi[data-glyph=envelope-closed]:before{content:\"\\E05C\"}.oi[data-glyph=envelope-open]:before{content:\"\\E05D\"}.oi[data-glyph=euro]:before{content:\"\\E05E\"}.oi[data-glyph=excerpt]:before{content:\"\\E05F\"}.oi[data-glyph=expand-down]:before{content:\"\\E060\"}.oi[data-glyph=expand-left]:before{content:\"\\E061\"}.oi[data-glyph=expand-right]:before{content:\"\\E062\"}.oi[data-glyph=expand-up]:before{content:\"\\E063\"}.oi[data-glyph=external-link]:before{content:\"\\E064\"}.oi[data-glyph=eye]:before{content:\"\\E065\"}.oi[data-glyph=eyedropper]:before{content:\"\\E066\"}.oi[data-glyph=file]:before{content:\"\\E067\"}.oi[data-glyph=fire]:before{content:\"\\E068\"}.oi[data-glyph=flag]:before{content:\"\\E069\"}.oi[data-glyph=flash]:before{content:\"\\E06A\"}.oi[data-glyph=folder]:before{content:\"\\E06B\"}.oi[data-glyph=fork]:before{content:\"\\E06C\"}.oi[data-glyph=fullscreen-enter]:before{content:\"\\E06D\"}.oi[data-glyph=fullscreen-exit]:before{content:\"\\E06E\"}.oi[data-glyph=globe]:before{content:\"\\E06F\"}.oi[data-glyph=graph]:before{content:\"\\E070\"}.oi[data-glyph=grid-four-up]:before{content:\"\\E071\"}.oi[data-glyph=grid-three-up]:before{content:\"\\E072\"}.oi[data-glyph=grid-two-up]:before{content:\"\\E073\"}.oi[data-glyph=hard-drive]:before{content:\"\\E074\"}.oi[data-glyph=header]:before{content:\"\\E075\"}.oi[data-glyph=headphones]:before{content:\"\\E076\"}.oi[data-glyph=heart]:before{content:\"\\E077\"}.oi[data-glyph=home]:before{content:\"\\E078\"}.oi[data-glyph=image]:before{content:\"\\E079\"}.oi[data-glyph=inbox]:before{content:\"\\E07A\"}.oi[data-glyph=infinity]:before{content:\"\\E07B\"}.oi[data-glyph=info]:before{content:\"\\E07C\"}.oi[data-glyph=italic]:before{content:\"\\E07D\"}.oi[data-glyph=justify-center]:before{content:\"\\E07E\"}.oi[data-glyph=justify-left]:before{content:\"\\E07F\"}.oi[data-glyph=justify-right]:before{content:\"\\E080\"}.oi[data-glyph=key]:before{content:\"\\E081\"}.oi[data-glyph=laptop]:before{content:\"\\E082\"}.oi[data-glyph=layers]:before{content:\"\\E083\"}.oi[data-glyph=lightbulb]:before{content:\"\\E084\"}.oi[data-glyph=link-broken]:before{content:\"\\E085\"}.oi[data-glyph=link-intact]:before{content:\"\\E086\"}.oi[data-glyph=list-rich]:before{content:\"\\E087\"}.oi[data-glyph=list]:before{content:\"\\E088\"}.oi[data-glyph=location]:before{content:\"\\E089\"}.oi[data-glyph=lock-locked]:before{content:\"\\E08A\"}.oi[data-glyph=lock-unlocked]:before{content:\"\\E08B\"}.oi[data-glyph=loop-circular]:before{content:\"\\E08C\"}.oi[data-glyph=loop-square]:before{content:\"\\E08D\"}.oi[data-glyph=loop]:before{content:\"\\E08E\"}.oi[data-glyph=magnifying-glass]:before{content:\"\\E08F\"}.oi[data-glyph=map-marker]:before{content:\"\\E090\"}.oi[data-glyph=map]:before{content:\"\\E091\"}.oi[data-glyph=media-pause]:before{content:\"\\E092\"}.oi[data-glyph=media-play]:before{content:\"\\E093\"}.oi[data-glyph=media-record]:before{content:\"\\E094\"}.oi[data-glyph=media-skip-backward]:before{content:\"\\E095\"}.oi[data-glyph=media-skip-forward]:before{content:\"\\E096\"}.oi[data-glyph=media-step-backward]:before{content:\"\\E097\"}.oi[data-glyph=media-step-forward]:before{content:\"\\E098\"}.oi[data-glyph=media-stop]:before{content:\"\\E099\"}.oi[data-glyph=medical-cross]:before{content:\"\\E09A\"}.oi[data-glyph=menu]:before{content:\"\\E09B\"}.oi[data-glyph=microphone]:before{content:\"\\E09C\"}.oi[data-glyph=minus]:before{content:\"\\E09D\"}.oi[data-glyph=monitor]:before{content:\"\\E09E\"}.oi[data-glyph=moon]:before{content:\"\\E09F\"}.oi[data-glyph=move]:before{content:\"\\E0A0\"}.oi[data-glyph=musical-note]:before{content:\"\\E0A1\"}.oi[data-glyph=paperclip]:before{content:\"\\E0A2\"}.oi[data-glyph=pencil]:before{content:\"\\E0A3\"}.oi[data-glyph=people]:before{content:\"\\E0A4\"}.oi[data-glyph=person]:before{content:\"\\E0A5\"}.oi[data-glyph=phone]:before{content:\"\\E0A6\"}.oi[data-glyph=pie-chart]:before{content:\"\\E0A7\"}.oi[data-glyph=pin]:before{content:\"\\E0A8\"}.oi[data-glyph=play-circle]:before{content:\"\\E0A9\"}.oi[data-glyph=plus]:before{content:\"\\E0AA\"}.oi[data-glyph=power-standby]:before{content:\"\\E0AB\"}.oi[data-glyph=print]:before{content:\"\\E0AC\"}.oi[data-glyph=project]:before{content:\"\\E0AD\"}.oi[data-glyph=pulse]:before{content:\"\\E0AE\"}.oi[data-glyph=puzzle-piece]:before{content:\"\\E0AF\"}.oi[data-glyph=question-mark]:before{content:\"\\E0B0\"}.oi[data-glyph=rain]:before{content:\"\\E0B1\"}.oi[data-glyph=random]:before{content:\"\\E0B2\"}.oi[data-glyph=reload]:before{content:\"\\E0B3\"}.oi[data-glyph=resize-both]:before{content:\"\\E0B4\"}.oi[data-glyph=resize-height]:before{content:\"\\E0B5\"}.oi[data-glyph=resize-width]:before{content:\"\\E0B6\"}.oi[data-glyph=rss-alt]:before{content:\"\\E0B7\"}.oi[data-glyph=rss]:before{content:\"\\E0B8\"}.oi[data-glyph=script]:before{content:\"\\E0B9\"}.oi[data-glyph=share-boxed]:before{content:\"\\E0BA\"}.oi[data-glyph=share]:before{content:\"\\E0BB\"}.oi[data-glyph=shield]:before{content:\"\\E0BC\"}.oi[data-glyph=signal]:before{content:\"\\E0BD\"}.oi[data-glyph=signpost]:before{content:\"\\E0BE\"}.oi[data-glyph=sort-ascending]:before{content:\"\\E0BF\"}.oi[data-glyph=sort-descending]:before{content:\"\\E0C0\"}.oi[data-glyph=spreadsheet]:before{content:\"\\E0C1\"}.oi[data-glyph=star]:before{content:\"\\E0C2\"}.oi[data-glyph=sun]:before{content:\"\\E0C3\"}.oi[data-glyph=tablet]:before{content:\"\\E0C4\"}.oi[data-glyph=tag]:before{content:\"\\E0C5\"}.oi[data-glyph=tags]:before{content:\"\\E0C6\"}.oi[data-glyph=target]:before{content:\"\\E0C7\"}.oi[data-glyph=task]:before{content:\"\\E0C8\"}.oi[data-glyph=terminal]:before{content:\"\\E0C9\"}.oi[data-glyph=text]:before{content:\"\\E0CA\"}.oi[data-glyph=thumb-down]:before{content:\"\\E0CB\"}.oi[data-glyph=thumb-up]:before{content:\"\\E0CC\"}.oi[data-glyph=timer]:before{content:\"\\E0CD\"}.oi[data-glyph=transfer]:before{content:\"\\E0CE\"}.oi[data-glyph=trash]:before{content:\"\\E0CF\"}.oi[data-glyph=underline]:before{content:\"\\E0D0\"}.oi[data-glyph=vertical-align-bottom]:before{content:\"\\E0D1\"}.oi[data-glyph=vertical-align-center]:before{content:\"\\E0D2\"}.oi[data-glyph=vertical-align-top]:before{content:\"\\E0D3\"}.oi[data-glyph=video]:before{content:\"\\E0D4\"}.oi[data-glyph=volume-high]:before{content:\"\\E0D5\"}.oi[data-glyph=volume-low]:before{content:\"\\E0D6\"}.oi[data-glyph=volume-off]:before{content:\"\\E0D7\"}.oi[data-glyph=warning]:before{content:\"\\E0D8\"}.oi[data-glyph=wifi]:before{content:\"\\E0D9\"}.oi[data-glyph=wrench]:before{content:\"\\E0DA\"}.oi[data-glyph=x]:before{content:\"\\E0DB\"}.oi[data-glyph=yen]:before{content:\"\\E0DC\"}.oi[data-glyph=zoom-in]:before{content:\"\\E0DD\"}.oi[data-glyph=zoom-out]:before{content:\"\\E0DE\"}", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "../../node_modules/fbjs/lib/emptyFunction.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "../../node_modules/fbjs/lib/invariant.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "../../node_modules/history/DOMUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),

/***/ "../../node_modules/history/LocationUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _resolvePathname = __webpack_require__("../../node_modules/resolve-pathname/index.js");

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__("../../node_modules/value-equal/index.js");

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),

/***/ "../../node_modules/history/PathUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),

/***/ "../../node_modules/history/createBrowserHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__("../../node_modules/invariant/browser.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__("../../node_modules/history/DOMUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),

/***/ "../../node_modules/history/createHashHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__("../../node_modules/invariant/browser.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__("../../node_modules/history/DOMUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),

/***/ "../../node_modules/history/createMemoryHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),

/***/ "../../node_modules/history/createTransitionManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};


/***/ }),

/***/ "../../node_modules/invariant/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "../../node_modules/lodash.debounce/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/normalize.css/normalize.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/normalize.css/normalize.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css", function() {
			var newContent = require("!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../node_modules/open-iconic/font/css/open-iconic.min.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/open-iconic/font/css/open-iconic.min.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./open-iconic.min.css", function() {
			var newContent = require("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./open-iconic.min.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.eot":
/***/ (function(module, exports) {

module.exports = "data:application/vnd.ms-fontobject;base64,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KyNhOC2wOSywABawAyWwAiVHI0cjYbAAVFguIDwjIRuwAiWwAiVHI0cjYSCwBSWwBCVHI0cjYbAGJbAFJUmwAiVhuQgACABjYyMgWGIbIVljuAQAYiCwAFBYsEBgWWawAWNgIy4jICA8ijgjIVktsDossAAWILAIQyAuRyNHI2EgYLAgYGawAmIgsABQWLBAYFlmsAFjIyAgPIo4LbA7LCMgLkawAiVGUlggPFkusSsBFCstsDwsIyAuRrACJUZQWCA8WS6xKwEUKy2wPSwjIC5GsAIlRlJYIDxZIyAuRrACJUZQWCA8WS6xKwEUKy2wPiywNSsjIC5GsAIlRlJYIDxZLrErARQrLbA/LLA2K4ogIDywBCNCijgjIC5GsAIlRlJYIDxZLrErARQrsARDLrArKy2wQCywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixKwEUKy2wQSyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbErARQrLbBCLLA1Ky6xKwEUKy2wQyywNishIyAgPLAEI0IjOLErARQrsARDLrArKy2wRCywABUgR7AAI0KyAAEBFRQTLrAxKi2wRSywABUgR7AAI0KyAAEBFRQTLrAxKi2wRiyxAAEUE7AyKi2wRyywNCotsEgssAAWRSMgLiBGiiNhOLErARQrLbBJLLAII0KwSCstsEossgAAQSstsEsssgABQSstsEwssgEAQSstsE0ssgEBQSstsE4ssgAAQistsE8ssgABQistsFAssgEAQistsFEssgEBQistsFIssgAAPistsFMssgABPistsFQssgEAPistsFUssgEBPistsFYssgAAQCstsFcssgABQCstsFgssgEAQCstsFkssgEBQCstsFossgAAQystsFsssgABQystsFwssgEAQystsF0ssgEBQystsF4ssgAAPystsF8ssgABPystsGAssgEAPystsGEssgEBPystsGIssDcrLrErARQrLbBjLLA3K7A7Ky2wZCywNyuwPCstsGUssAAWsDcrsD0rLbBmLLA4Ky6xKwEUKy2wZyywOCuwOystsGgssDgrsDwrLbBpLLA4K7A9Ky2waiywOSsusSsBFCstsGsssDkrsDsrLbBsLLA5K7A8Ky2wbSywOSuwPSstsG4ssDorLrErARQrLbBvLLA6K7A7Ky2wcCywOiuwPCstsHEssDorsD0rLbByLLMJBAIDRVghGyMhWUIrsAhlsAMkUHiwARUwLQBLuADIUlixAQGOWbABuQgACABjcLEABUKxAAAqsQAFQrEACCqxAAVCsQAIKrEABUK5AAAACSqxAAVCuQAAAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWbEADCq4Af+FsASNsQIARAA="

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.otf":
/***/ (function(module, exports) {

module.exports = "data:font/opentype;base64,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VgFYAVoBXAFeAWABYgFkAWYBaAFqAWwBbgFwAXIBdAF2AXgBegF8AX4BgAGCAYQBhgGIAYoBjAGOAZABkgGUAZYBmAGaAZwBngGgAaIBpAGmAasB7QH2AfsxMjM0NTY3ODkxMDExMTIxMzE0MTUxNjE3MTgxOTFhMWIxYzFkMWUxZjIwMjEyMjIzMjQyNTI2MjcyODI5MmEyYjJjMmQyZTJmMzAzMTMyMzMzNDM1MzYzNzM4MzkzYTNiM2MzZDNlM2Y0MDQxNDI0MzQ0NDU0NjQ3NDg0OTRhNGI0YzRkNGU0ZjUwNTE1MjUzNTQ1NTU2NTc1ODU5NWE1YjVjNWQ1ZTVmNjA2MTYyNjM2NDY1NjY2NzY4Njk2YTZiNmM2ZDZlNmY3MDcxNzI3Mzc0NzU3Njc3Nzg3OTdhN2I3YzdkN2U3ZjgwODE4MjgzODQ4NTg2ODc4ODg5OGE4YjhjOGQ4ZThmOTA5MTkyOTM5NDk1OTY5Nzk4OTk5YTliOWM5ZDllOWZhMGExYTJhM2E0YTVhNmE3YThhOWFhYWJhY2FkYWZiMGIxYjJiM2I0YjViNmI3YjhiOWJhYmJiY2JkYmViZmMwYzFjMmMzYzRjNWM2YzdjOGM5Y2FjYmNjY2RjZWNmZDBkMWQyZDNkNGQ1ZDZkN2Q4ZDlkYWRiZGNkZGRlMS4xLjFDcmVhdGVkIGJ5IFAuSi4gT25vcmkgd2l0aCBGb250Rm9yZ2UgMi4wIChodHRwOi8vZm9udGZvcmdlLnNmLm5ldClVbnRpdGxlZDFJY29ucwAAAAGHAYgBiQGKAYsBjAGNAY4BjwGQAEIAQwBEAEUARgBHAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIX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"

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.svg":
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiID4KPCEtLQoyMDE0LTctMTogQ3JlYXRlZC4KLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPG1ldGFkYXRhPgpDcmVhdGVkIGJ5IEZvbnRGb3JnZSAyMDEyMDczMSBhdCBUdWUgSnVsICAxIDIwOjM5OjIyIDIwMTQKIEJ5IFAuSi4gT25vcmkKQ3JlYXRlZCBieSBQLkouIE9ub3JpIHdpdGggRm9udEZvcmdlIDIuMCAoaHR0cDovL2ZvbnRmb3JnZS5zZi5uZXQpCjwvbWV0YWRhdGE+CjxkZWZzPgo8Zm9udCBpZD0ib3Blbi1pY29uaWMiIGhvcml6LWFkdi14PSI4MDAiID4KICA8Zm9udC1mYWNlIAogICAgZm9udC1mYW1pbHk9Ikljb25zIgogICAgZm9udC13ZWlnaHQ9IjQwMCIKICAgIGZvbnQtc3RyZXRjaD0ibm9ybWFsIgogICAgdW5pdHMtcGVyLWVtPSI4MDAiCiAgICBwYW5vc2UtMT0iMiAwIDUgMyAwIDAgMCAwIDAgMCIKICAgIGFzY2VudD0iODAwIgogICAgZGVzY2VudD0iMCIKICAgIGJib3g9Ii0wLjUgLTEwMSA4MDIgODAwLjEyNiIKICAgIHVuZGVybGluZS10aGlja25lc3M9IjUwIgogICAgdW5kZXJsaW5lLXBvc2l0aW9uPSItMTAwIgogICAgdW5pY29kZS1yYW5nZT0iVStFMDAwLUUwREUiCiAgLz4KICAgIDxtaXNzaW5nLWdseXBoIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iIiB1bmljb2RlPSImI3hlMDAwOyIgCmQ9Ik0zMDAgNzAwaDUwMHYtNzAwaC01MDB2MTAwaDQwMHY1MDBoLTQwMHYxMDB6TTQwMCA1MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNDAwdjEwMGg0MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxIiB1bmljb2RlPSImI3hlMDAxOyIgCmQ9Ik0zMDAgNzAwaDUwMHYtNzAwaC01MDB2MTAwaDQwMHY1MDBoLTQwMHYxMDB6TTIwMCA1MDB2LTEwMGg0MDB2LTEwMGgtNDAwdi0xMDBsLTIwMCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIiIHVuaWNvZGU9IiYjeGUwMDI7IiAKZD0iTTM1MCA3MDBjMTkzIDAgMzUwIC0xNTcgMzUwIC0zNTB2LTUwaDEwMGwtMjAwIC0yMDBsLTIwMCAyMDBoMTAwdjUwYzAgMTM4IC0xMTIgMjUwIC0yNTAgMjUwcy0yNTAgLTExMiAtMjUwIC0yNTBjMCAxOTMgMTU3IDM1MCAzNTAgMzUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzIiB1bmljb2RlPSImI3hlMDAzOyIgCmQ9Ik00NTAgNzAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgMTM4IC0xMTIgMjUwIC0yNTAgMjUwcy0yNTAgLTExMiAtMjUwIC0yNTB2LTUwaDEwMGwtMjAwIC0yMDBsLTIwMCAyMDBoMTAwdjUwYzAgMTkzIDE1NyAzNTAgMzUwIDM1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNCIgdW5pY29kZT0iJiN4ZTAwNDsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTEwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0xMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1IiB1bmljb2RlPSImI3hlMDA1OyIgCmQ9Ik0wIDcwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNiIgdW5pY29kZT0iJiN4ZTAwNjsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTIwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0yMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3IiB1bmljb2RlPSImI3hlMDA3OyIgCmQ9Ik00MDAgNzAwYzc1IDAgMTQ2IC0yMyAyMDYgLTU5bC03NSAtMjI1bC0zMjIgMjM0YzU3IDMxIDEyMiA1MCAxOTEgNTB6TTEyNSA1ODhsMTkxIC0xMzhsLTMxMCAtMjIyYy00IDI0IC02IDQ3IC02IDcyYzAgMTE0IDQ5IDIxNSAxMjUgMjg4ek02ODggNTc1YzY5IC03MiAxMTIgLTE2OCAxMTIgLTI3NWMwIC0zNSAtOCAtNjggLTE2IC0xMDBoLTIxOHpNMjE2IDI1M2wxMTIgLTM0N2MtMTI4IDIzIC0yMzIgMTA5IC0yODcgMjIyek0zNzIgMTAwCmgzNzJjLTY0IC0xMDkgLTE3NyAtMTg1IC0zMTAgLTE5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOCIgdW5pY29kZT0iJiN4ZTAwODsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjAwIDgwMGgxMDB2LTUwMGgyMDBsLTI0NyAtMzAwbC0yNTMgMzAwaDIwMHY1MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjkiIHVuaWNvZGU9IiYjeGUwMDk7IiAKZD0iTTQwMCA4MDBjMjIxIDAgNDAwIC0xNzkgNDAwIC00MDBzLTE3OSAtNDAwIC00MDAgLTQwMHMtNDAwIDE3OSAtNDAwIDQwMHMxNzkgNDAwIDQwMCA0MDB6TTMwMCA3MDB2LTMwMGgtMjAwbDMwMCAtMzAwbDMwMCAzMDBoLTIwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYSIgdW5pY29kZT0iJiN4ZTAwYTsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGwtMzAwIC0zMDBsMzAwIC0zMDB2MjAwaDMwMHYyMDBoLTMwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImIiIHVuaWNvZGU9IiYjeGUwMGI7IiAKZD0iTTQwMCA4MDBjMjIxIDAgNDAwIC0xNzkgNDAwIC00MDBzLTE3OSAtNDAwIC00MDAgLTQwMHMtNDAwIDE3OSAtNDAwIDQwMHMxNzkgNDAwIDQwMCA0MDB6TTQwMCA3MDB2LTIwMGgtMzAwdi0yMDBoMzAwdi0yMDBsMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYyIgdW5pY29kZT0iJiN4ZTAwYzsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGwtMzAwIC0zMDBoMjAwdi0zMDBoMjAwdjMwMGgyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQiIHVuaWNvZGU9IiYjeGUwMGQ7IiAKZD0iTTMwMCA2MDB2LTIwMGg1MDB2LTEwMGgtNTAwdi0yMDBsLTMwMCAyNDd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImUiIHVuaWNvZGU9IiYjeGUwMGU7IiAKZD0iTTUwMCA2MDBsMzAwIC0yNDdsLTMwMCAtMjUzdjIwMGgtNTAwdjEwMGg1MDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmIiB1bmljb2RlPSImI3hlMDBmOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yMDAgODAwaDIwMHYtNTAwaDIwMGwtMjk3IC0zMDBsLTMwMyAzMDBoMjAwdjUwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTAiIHVuaWNvZGU9IiYjeGUwMTA7IiAKZD0iTTMwMCA3MDB2LTIwMGg1MDB2LTIwMGgtNTAwdi0yMDBsLTMwMCAyOTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjExIiB1bmljb2RlPSImI3hlMDExOyIgCmQ9Ik01MDAgNzAwbDMwMCAtMjk3bC0zMDAgLTMwM3YyMDBoLTUwMHYyMDBoNTAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTIiIHVuaWNvZGU9IiYjeGUwMTI7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTI5NyA4MDBsMzAzIC0zMDBoLTIwMHYtNTAwaC0yMDB2NTAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjEzIiB1bmljb2RlPSImI3hlMDEzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yNDcgODAwbDI1MyAtMzAwaC0yMDB2LTUwMGgtMTAwdjUwMGgtMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxNCIgdW5pY29kZT0iJiN4ZTAxNDsiIApkPSJNNDAwIDgwMGgxMDB2LTgwMGgtMTAwdjgwMHpNMjAwIDcwMGgxMDB2LTYwMGgtMTAwdjYwMHpNNjAwIDYwMGgxMDB2LTQwMGgtMTAwdjQwMHpNMCA1MDBoMTAwdi0yMDBoLTEwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE1IiB1bmljb2RlPSImI3hlMDE1OyIgCmQ9Ik0xMTYgNjAwbDcyIC03MmMtNTQgLTU0IC04OCAtMTI2IC04OCAtMjA5czM0IC0xNTkgODggLTIxM2wtNzIgLTcyYy03MiA3MiAtMTE2IDE3NSAtMTE2IDI4NXM0NCAyMDkgMTE2IDI4MXpNNjg0IDYwMGM3MiAtNzIgMTE2IC0xNzEgMTE2IC0yODFzLTQ0IC0yMTMgLTExNiAtMjg1bC03MiA3MmM1NCA1NCA4OCAxMzAgODggMjEzcy0zNCAxNTUgLTg4IDIwOXpNMjU5IDQ2MGw2OSAtNzJjLTE4IC0xOCAtMjggLTQxIC0yOCAtNjkKczEwIC01NCAyOCAtNzJsLTY5IC03MmMtMzYgMzYgLTU5IDg5IC01OSAxNDRzMjMgMTA1IDU5IDE0MXpNNTQxIDQ1OWMzNiAtMzYgNTkgLTg1IDU5IC0xNDBzLTIzIC0xMDggLTU5IC0xNDRsLTY5IDcyYzE4IDE4IDI4IDQ0IDI4IDcycy0xMCA1MSAtMjggNjl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE2IiB1bmljb2RlPSImI3hlMDE2OyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0yMDAgODAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDBzOTAgMjAwIDIwMCAyMDB6TTEwMCAzMTljMzEgLTExIDY1IC0xOSAxMDAgLTE5czY4IDggMTAwIDE5di0zMTlsLTEwMCAxMDBsLTEwMCAtMTAwdjMxOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTciIHVuaWNvZGU9IiYjeGUwMTc7IiAKZD0iTTQwMCA4MDBjMjIwIDAgNDAwIC0xODAgNDAwIC00MDBzLTE4MCAtNDAwIC00MDAgLTQwMHMtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6TTQwMCA3MDBjLTE2NiAwIC0zMDAgLTEzNCAtMzAwIC0zMDBjMCAtNjYgMjEgLTEyNiA1NiAtMTc1bDQxOSA0MTljLTQ5IDM1IC0xMDkgNTYgLTE3NSA1NnpNNjQ0IDU3NWwtNDE5IC00MTljNDkgLTM1IDEwOSAtNTYgMTc1IC01NmMxNjYgMCAzMDAgMTM0IDMwMCAzMDAKYzAgNjYgLTIxIDEyNiAtNTYgMTc1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxOCIgdW5pY29kZT0iJiN4ZTAxODsiIApkPSJNMCA3MDBoMTAwdi02MDBoNzAwdi0xMDBoLTgwMHY3MDB6TTUwMCA3MDBoMjAwdi01MDBoLTIwMHY1MDB6TTIwMCA1MDBoMjAwdi0zMDBoLTIwMHYzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE5IiB1bmljb2RlPSImI3hlMDE5OyIgCmQ9Ik0zOTcgODAwYzEzIDEgMjMgLTQgMzQgLTEzYzIgLTIgMjE0IC0yNTQgMjQxIC0yODdoMTI4di0xMDBoLTEwMHYtMzY2YzAgLTE4IC0xNiAtMzQgLTM0IC0zNGgtNTMyYy0xOCAwIC0zNCAxNiAtMzQgMzR2MzY2aC0xMDB2MTAwaDEyOGwyMzQgMjgxYzkgMTEgMjIgMTggMzUgMTl6TTQwMCA2NzJsLTE0NCAtMTcyaDI4OHpNMjUwIDMwMGMtMjggMCAtNTAgLTIyIC01MCAtNTB2LTEwMGMwIC0yOCAyMiAtNTAgNTAgLTUwczUwIDIyIDUwIDUwCnYxMDBjMCAyOCAtMjIgNTAgLTUwIDUwek01NTAgMzAwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtMTAwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MTAwYzAgMjggLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWEiIHVuaWNvZGU9IiYjeGUwMWE7IiAKZD0iTTkgNzAwaDY4MmM2IDAgOSAtNCA5IC0xMHYtMTkwaDEwMHYtMjAwaC0xMDB2LTE5MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2NTgyYzAgNiAzIDkgOSA5ek0xMDAgNjAwdi00MDBoNTAwdjQwMGgtNTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxYiIgdW5pY29kZT0iJiN4ZTAxYjsiIApkPSJNOSA3MDBoNjgyYzYgMCA5IC00IDkgLTEwdi0xOTBoMTAwdi0yMDBoLTEwMHYtMTkxYzAgLTYgLTMgLTkgLTkgLTloLTY4MmMtNiAwIC05IDMgLTkgOXY1ODJjMCA2IDMgOSA5IDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjFjIiB1bmljb2RlPSImI3hlMDFjOyIgCmQ9Ik05MiA2NTBjMCAyMyAxOSA1MCA0NSA1MGgzaDVoNWg1MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTB2LTE0MWM5IC0xNyAxMjAgLTIzMSAxNjYgLTMwOWMxNiAtMjYgMzQgLTYxIDM0IC0xMDZjMCAtMzkgLTE1IC03NyAtNDEgLTEwM2gtM2MtMjYgLTI1IC02MiAtNDEgLTEwMCAtNDFoLTUxMmMtMzkgMCAtNzcgMTUgLTEwMyA0MXMtNDEgNjQgLTQxIDEwM2MwIDQ2IDE4IDgwIDM0IDEwNgpjNDYgNzggMTU3IDI5MiAxNjYgMzA5djE0MWgtNTBjLTIgMCAtNiAtMSAtOCAtMWMtMjggMCAtNTAgMjMgLTUwIDUxek01MDAgNjAwaC0yMDB2LTE2MmwtNiAtMTBzLTYzIC0xMjMgLTExOSAtMjI4aDQ1MGMtNTYgMTA1IC0xMTkgMjI4IC0xMTkgMjI4bC02IDEwdjE2MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWQiIHVuaWNvZGU9IiYjeGUwMWQ7IiAKZD0iTTQwMCA4MDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMGMwIC0xMDQgNTIgLTE5OCAxMzQgLTI2NmM0MSAtMzQgNjYgLTgyIDY2IC0xMzRoLTgwMGMwIDUyIDI1IDEwMCA2NiAxMzRjODIgNjggMTM0IDE2MiAxMzQgMjY2YzAgMTEwIDkwIDIwMCAyMDAgMjAwek0zMDAgMTAwaDIwMGMwIC01NSAtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWUiIHVuaWNvZGU9IiYjeGUwMWU7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTE1MCA4MDBoNTBsMzUwIC0yNTBsLTIyNSAtMTQ3bDIyNSAtMTUzbC0zNTAgLTI1MGgtNTB2MjUwbC03NSAtNzVsLTc1IDc1bDE1MCAxNTBsLTE1MCAxNTBsNzUgNzVsNzUgLTc1djI1MHpNMjUwIDY1MHYtMjAwbDE1MCAxMDB6TTI1MCAzNTB2LTIwMGwxNTAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxZiIgdW5pY29kZT0iJiN4ZTAxZjsiIApkPSJNMCA4MDBoNTAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBjMCAtNDcgLTE3IC05MSAtNDQgLTEyNWM4NSAtNDAgMTQ0IC0xMjUgMTQ0IC0yMjVjMCAtMTM4IC0xMTIgLTI1MCAtMjUwIC0yNTBoLTU1MHYxMDBjNTUgMCAxMDAgNDUgMTAwIDEwMHY0MDBjMCA1NSAtNDUgMTAwIC0xMDAgMTAwdjEwMHpNMzAwIDcwMHYtMjAwaDEwMGM1NSAwIDEwMCA0NSAxMDAgMTAwcy00NSAxMDAgLTEwMCAxMDBoLTEwMHpNMzAwIDQwMHYtMzAwaDE1MApjODMgMCAxNTAgNjcgMTUwIDE1MHMtNjcgMTUwIC0xNTAgMTUwaC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIwIiB1bmljb2RlPSImI3hlMDIwOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0zMDAgODAwdi0zMDBoMjAwbC0zMDAgLTUwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjEiIHVuaWNvZGU9IiYjeGUwMjE7IiAKZD0iTTEwMCA4MDBoMzAwdi0zMDBsMTAwIDEwMGwxMDAgLTEwMHYzMDBoNTBjMjggMCA1MCAtMjIgNTAgLTUwdi01NTBoLTU1MGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGg1NTB2LTEwMGgtNTUwYy04MyAwIC0xNTAgNjcgLTE1MCAxNTB2NTUwbDMgMTljOCAzOSAzOSA3MCA3OCA3OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjIiIHVuaWNvZGU9IiYjeGUwMjI7IiBob3Jpei1hZHYteD0iNDAwIiAKZD0iTTAgODAwaDQwMHYtODAwbC0yMDAgMjAwbC0yMDAgLTIwMHY4MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIzIiB1bmljb2RlPSImI3hlMDIzOyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA2MDBoMzAwdi0xMDNoMjAzdjEwM2gyOTd2LTU5MWMwIC02IC0zIC05IC05IC05aC03ODJjLTYgMCAtOSAzIC05IDl2NTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNCIgdW5pY29kZT0iJiN4ZTAyNDsiIApkPSJNMzAwIDgwMGgyMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwdi0xMDBoMTkxYzYgMCA5IC0zIDkgLTl2LTI0MWMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjI0MWMwIDYgMyA5IDkgOWgxOTF2MTAwYzAgNTUgNDUgMTAwIDEwMCAxMDB6TTMwMCA3MDB2LTEwMGgyMDB2MTAwaC0yMDB6TTAgMjA5YzE2IC02IDMyIC05IDUwIC05aDcwMGMxOCAwIDM0IDMgNTAgOXYtMjAwYzAgLTYgLTMgLTkgLTkgLTloLTc4MgpjLTYgMCAtOSAzIC05IDl2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNSIgdW5pY29kZT0iJiN4ZTAyNTsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGM1OCAwIDExMCAtMTYgMTQ3IC01M3M1MyAtODkgNTMgLTE0N2gtMTAwYzAgMzkgLTExIDYxIC0yNSA3NXMtMzYgMjUgLTc1IDI1Yy0zNSAwIC01NSAtMTAgLTcyIC0zMXMtMjggLTU1IC0yOCAtOTRjMCAtNTEgMjAgLTEwNyAyOCAtMTc1aDE3MnYtMTAwaC0xNzhjLTE0IC02MCAtNDkgLTEyNyAtMTEzIC0yMDBoNDkxdi0xMDBoLTYwMHYxMjJsMTYgMTJjNjkgNjkgOTUgMTIxIDEwNiAxNjZoLTEyMnYxMDBoMTI1CmMtOCA1MCAtMjUgMTA2IC0yNSAxNzVjMCA1OCAxNiAxMTQgNTAgMTU2YzM0IDQzIDg4IDY5IDE1MCA2OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjYiIHVuaWNvZGU9IiYjeGUwMjY7IiAKZD0iTTM0IDcwMGg0aDNoNGg1aDcwMGMyOCAwIDUwIC0yMiA1MCAtNTB2LTcwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjcwMHYyYzAgMjAgMTUgNDIgMzQgNDh6TTE1MCA2MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHpNMzUwIDYwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGgzMDBjMjggMCA1MCAyMiA1MCA1MApzLTIyIDUwIC01MCA1MGgtMzAwek0xMDAgNDAwdi00MDBoNjAwdjQwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNyIgdW5pY29kZT0iJiN4ZTAyNzsiIApkPSJNNzQ0IDc5N2w2IC0zbDQ0IC00NGM0IC00IDMgLTggMCAtMTJsLTI2NiAtMzc1bC0xNSAtMTNsLTI1IC0xMmMtMjMgNzIgLTc4IDEyNyAtMTUwIDE1MGwxMiAyNWwxMyAxNWwzNzUgMjY2ek0yNjYgNDAwYzc0IDAgMTM0IC02MCAxMzQgLTEzNGMwIC0xNDcgLTExOSAtMjY2IC0yNjYgLTI2NmMtNDggMCAtOTUgMTIgLTEzNCAzNGM4MCA0NiAxMzQgMTMzIDEzNCAyMzJjMCA3NCA1OCAxMzQgMTMyIDEzNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjgiIHVuaWNvZGU9IiYjeGUwMjg7IiAKZD0iTTkgNDUxYzAgMjMgMTkgNTAgNDYgNTBjOCAwIDE5IC0zIDI2IC03bDEzMSAtNjZsMjkgMjJjLTc5IDgxIC0xIDI1MCAxMTggMjUwczE5NyAtMTY3IDExOSAtMjUwbDI4IC0yMmwxMzEgNjZjNiA0IDEyIDcgMjEgN2MyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTcgLTEyIC0zNyAtMjcgLTQ1bC0xMTUgLTU2YzkgLTE2IDE5IC0zMyAyNSAtNTBoNjhjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTAKYzAgLTIzIC0yIC00NSAtNiAtNjZsNzggLTQwYzIxIC01IDM3IC0yOCAzNyAtNDljMCAtMjggLTIyIC01MCAtNTAgLTUwYy0xMCAwIC0yMyA1IC0zMSAxMWwtNjUgMzVjLTI0IC00NiAtNjIgLTg2IC0xMDMgLTExMGMtMzUgMTkgLTYwIDQ1IC02MCA3MnYxMzV2NHY1djZ2NXY1djg3YzAgMjggLTIyIDUwIC01MCA1MGMtMjQgMCAtNDUgLTE3IC01MCAtNDBjMSAtMyAxIC04IDEgLTExczAgLTggLTEgLTExdi04MnYtNHYtNXYtMTQ0CmMwIC0yOCAtMjQgLTUzIC01OSAtNzJjLTQxIDI1IC03OSA2NCAtMTAzIDExMGwtNjYgLTM1Yy04IC02IC0yMSAtMTEgLTMxIC0xMWMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMjEgMTYgNDQgMzcgNDlsNzggNDBjLTQgMjEgLTYgNDMgLTYgNjZoLTUwaC01Yy0yOCAwIC01MCAyMiAtNTAgNTBjMCAyNiAyMiA1MCA1MCA1MGg1aDY5YzYgMTcgMTYgMzQgMjUgNTBsLTExNiA1NmMtMTYgNyAtMjggMjcgLTI4IDQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyOSIgdW5pY29kZT0iJiN4ZTAyOTsiIApkPSJNNjAwIDcwMGg5MWM2IDAgOSAtMyA5IC05di01ODJjMCAtNiAtMyAtOSAtOSAtOWgtOTF2NjAwek0yMTAgNTAzbDI5MCAxNDd2LTUwMGwtMjUwIDEyNXYtM2MtMTUgMCAtMjUgLTggLTI4IC0yMmw3NSAtMTc4YzExIC0yNSAwIC01OCAtMjUgLTY5cy01OCAwIC02OSAyNWwtMTAzIDI3MmgtOTFjLTYgMCAtOSAzIC05IDl2MTgyYzAgNiAzIDkgOSA5aDE4MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMmEiIHVuaWNvZGU9IiYjeGUwMmE7IiAKZD0iTTkgODAwaDY4MmM2IDAgOSAtMyA5IC05di03ODJjMCAtNiAtMyAtOSAtOSAtOWgtNjgyYy02IDAgLTkgMyAtOSA5djc4MmMwIDYgMyA5IDkgOXpNMTAwIDcwMHYtMjAwaDUwMHYyMDBoLTUwMHpNMTAwIDQwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMzAwIDQwMHYtMTAwaDEwMHYxMDBoLTEwMHpNNTAwIDQwMHYtMzAwaDEwMHYzMDBoLTEwMHpNMTAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMzAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMmIiIHVuaWNvZGU9IiYjeGUwMmI7IiAKZD0iTTAgODAwaDcwMHYtMjAwaC03MDB2MjAwek0wIDUwMGg3MDB2LTQ5MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2NDkxek0xMDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek01MDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek0xMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyYyIgdW5pY29kZT0iJiN4ZTAyYzsiIApkPSJNNDA5IDgwMGgxODJjNiAwIDEwIC00IDEyIC05bDk0IC0xODJjMiAtNSA2IC05IDEyIC05aDgyYzYgMCA5IC0zIDkgLTl2LTU4MmMwIC02IC0zIC05IC05IC05aC03ODJjLTYgMCAtOSAzIC05IDl2NDQxYzAgODMgNjcgMTUwIDE1MCAxNTBoMTQxYzYgMCAxMCA0IDEyIDlsOTQgMTgyYzIgNSA2IDkgMTIgOXpNMTUwIDUwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwegpNNTAwIDUwMGMtMTEwIDAgLTIwMCAtOTAgLTIwMCAtMjAwczkwIC0yMDAgMjAwIC0yMDBzMjAwIDkwIDIwMCAyMDBzLTkwIDIwMCAtMjAwIDIwMHpNNTAwIDQwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBzLTQ1IC0xMDAgLTEwMCAtMTAwcy0xMDAgNDUgLTEwMCAxMDBzNDUgMTAwIDEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjJkIiB1bmljb2RlPSImI3hlMDJkOyIgCmQ9Ik0wIDYwMGg4MDBsLTQwMCAtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyZSIgdW5pY29kZT0iJiN4ZTAyZTsiIGhvcml6LWFkdi14PSI0MDAiIApkPSJNNDAwIDgwMHYtODAwbC00MDAgNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyZiIgdW5pY29kZT0iJiN4ZTAyZjsiIGhvcml6LWFkdi14PSI0MDAiIApkPSJNMCA4MDBsNDAwIC00MDBsLTQwMCAtNDAwdjgwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzAiIHVuaWNvZGU9IiYjeGUwMzA7IiAKZD0iTTQwMCA2MDBsNDAwIC00MDBoLTgwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzEiIHVuaWNvZGU9IiYjeGUwMzE7IiAKZD0iTTAgNTUwYzAgMjMgMjAgNTAgNDYgNTBoM2g1aDRoMjAwYzE3IDAgMzcgLTEzIDQ0IC0yOGwzOCAtNzJoNDQ0YzE0IDAgMTkgLTEyIDE1IC0yNWwtODEgLTI1MGMtNCAtMTMgLTIxIC0yNSAtMzUgLTI1aC0zNTBjLTE0IDAgLTMwIDEyIC0zNCAyNWMtMjcgODMgLTU0IDE2NyAtODEgMjUwbC0xMCAyNWgtMTUwYy0yIDAgLTUgLTEgLTcgLTFjLTI4IDAgLTUxIDIzIC01MSA1MXpNMzU4IDEwMGMyOCAwIDUwIC0yMiA1MCAtNTAKcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek02NTggMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzIiIHVuaWNvZGU9IiYjeGUwMzI7IiAKZD0iTTAgNzAwaDUwMHYtMTAwaC0zMDB2LTMwMGgtMTAwbC0xMDAgLTEwMHY1MDB6TTMwMCA1MDBoNTAwdi01MDBsLTEwMCAxMDBoLTQwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjMzIiB1bmljb2RlPSImI3hlMDMzOyIgCmQ9Ik02NDEgNzAwbDE0MyAtMTQxbC00OTMgLTQ5M2MtNzEgNzYgLTE0NiAxNDggLTIxOSAyMjJsLTcyIDcxbDE0MSAxNDFjNTAgLTUxIDEwMSAtMTAxIDE1MyAtMTUwYzExNiAxMTcgMjM0IDIzMSAzNDcgMzUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzNCIgdW5pY29kZT0iJiN4ZTAzNDsiIApkPSJNMTUwIDYwMGwyNTAgLTI1MGwyNTAgMjUwbDE1MCAtMTUwbC00MDAgLTQwMGwtNDAwIDQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzUiIHVuaWNvZGU9IiYjeGUwMzU7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTQwMCA4MDBsMTUwIC0xNTBsLTI1MCAtMjUwbDI1MCAtMjUwbC0xNTAgLTE1MGwtNDAwIDQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzYiIHVuaWNvZGU9IiYjeGUwMzY7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTE1MCA4MDBsNDAwIC00MDBsLTQwMCAtNDAwbC0xNTAgMTUwbDI1MCAyNTBsLTI1MCAyNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM3IiB1bmljb2RlPSImI3hlMDM3OyIgCmQ9Ik00MDAgNjAwbDQwMCAtNDAwbC0xNTAgLTE1MGwtMjUwIDI1MGwtMjUwIC0yNTBsLTE1MCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM4IiB1bmljb2RlPSImI3hlMDM4OyIgCmQ9Ik00MDAgODAwYzIyMSAwIDQwMCAtMTc5IDQwMCAtNDAwcy0xNzkgLTQwMCAtNDAwIC00MDBzLTQwMCAxNzkgLTQwMCA0MDBzMTc5IDQwMCA0MDAgNDAwek02MDAgNjIybC0yNTAgLTI1MGwtMTAwIDEwMGwtNzIgLTcybDE3MiAtMTcybDMyMiAzMjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM5IiB1bmljb2RlPSImI3hlMDM5OyIgCmQ9Ik00MDAgODAwYzIyMSAwIDQwMCAtMTc5IDQwMCAtNDAwcy0xNzkgLTQwMCAtNDAwIC00MDBzLTQwMCAxNzkgLTQwMCA0MDBzMTc5IDQwMCA0MDAgNDAwek0yNTAgNjIybC03MiAtNzJsMTUwIC0xNTBsLTE1MCAtMTUwbDcyIC03MmwxNTAgMTUwbDE1MCAtMTUwbDcyIDcybC0xNTAgMTUwbDE1MCAxNTBsLTcyIDcybC0xNTAgLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iM2EiIHVuaWNvZGU9IiYjeGUwM2E7IiAKZD0iTTM1MCA4MDBjMjggMCA1MCAtMjIgNTAgLTUwdi01MGg3NWMxNCAwIDI1IC0xMSAyNSAtMjV2LTc1aC0zMDB2NzVjMCAxNCAxMSAyNSAyNSAyNWg3NXY1MGMwIDI4IDIyIDUwIDUwIDUwek0yNSA3MDBoNzV2LTIwMGg1MDB2MjAwaDc1YzE0IDAgMjUgLTExIDI1IC0yNXYtNjUwYzAgLTE0IC0xMSAtMjUgLTI1IC0yNWgtNjUwYy0xNCAwIC0yNSAxMSAtMjUgMjV2NjUwYzAgMTQgMTEgMjUgMjUgMjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjNiIiB1bmljb2RlPSImI3hlMDNiOyIgCmQ9Ik00MDAgODAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwcy0xODAgLTQwMCAtNDAwIC00MDBzLTQwMCAxODAgLTQwMCA0MDBzMTgwIDQwMCA0MDAgNDAwek00MDAgNzAwYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwczMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHpNMzUwIDYwMGgxMDB2LTE4MWMyMyAtMjQgNDcgLTQ3IDcyIC02OWwtNzIgLTcyYy0yNyAzMCAtNTUgNTkgLTg0IDg4bC0xNiAxMgp2MjIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzYyIgdW5pY29kZT0iJiN4ZTAzYzsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtMTggLTMgLTM0IC05IC01MGgtMTkxdjUwYzAgODMgLTY3IDE1MCAtMTUwIDE1MHMtMTUwIC02NyAtMTUwIC0xNTB2LTUwaC0yNzJjLTE3IDMwIC0yOCA2MyAtMjggMTAwYzAgMTEwIDkwIDIwMCAyMDAgMjAwYzIzIDExNCAxMjkgMjAwIDI1MCAyMDB6TTQzNCA0MDBoM2g0YzMgMCA2IDEgOSAxYzI4IDAgNTAgLTIyIDUwIC01MHYtMQp2LTE1MGgxNTBsLTIwMCAtMjAwbC0yMDAgMjAwaDE1MHYxNTB2MmMwIDIwIDE1IDQyIDM0IDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzZCIgdW5pY29kZT0iJiN4ZTAzZDsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtMTggLTMgLTM0IC05IC01MGgtMTQxbC0yMDAgMjAwbC0yMDAgLTIwMGgtMjIyYy0xNyAzMCAtMjggNjMgLTI4IDEwMGMwIDExMCA5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAwek00NTAgMzUwbDI1MCAtMjUwaC0yMDB2LTUwYzAgLTI4IC0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwdjUwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjNlIiB1bmljb2RlPSImI3hlMDNlOyIgCmQ9Ik00NTAgNzAwYzEzOCAwIDI1MCAtMTEyIDI1MCAtMjUwdi01MGM1OCAtMjEgMTAwIC04NSAxMDAgLTE1MGMwIC04MyAtNjcgLTE1MCAtMTUwIC0xNTBoLTQ1MGMtMTEwIDAgLTIwMCA5MCAtMjAwIDIwMHM5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzZiIgdW5pY29kZT0iJiN4ZTAzZjsiIApkPSJNMjUwIDgwMGM4MiAwIDE1NCAtNDAgMjAwIC0xMDBjLTE0MyAwIC0yNzAgLTg1IC0zMjUgLTIwOWMtMzYgLTEwIC03MCAtMjUgLTEwMCAtNDdjLTE2IDMzIC0yNSA2NyAtMjUgMTA2YzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNNDUwIDYwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwaC00NTBjLTExMCAwIC0yMDAgOTAgLTIwMCAyMDAKczkwIDIwMCAyMDAgMjAwYzIzIDExNCAxMjkgMjAwIDI1MCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQwIiB1bmljb2RlPSImI3hlMDQwOyIgCmQ9Ik01MDAgNzAwaDEwMGwtMzAwIC02MDBoLTEwMHpNMTAwIDYwMGgxMDBsLTEwMCAtMjAwbDEwMCAtMjAwaC0xMDBsLTEwMCAyMDB6TTYwMCA2MDBoMTAwbDEwMCAtMjAwbC0xMDAgLTIwMGgtMTAwbDEwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQxIiB1bmljb2RlPSImI3hlMDQxOyIgCmQ9Ik0zNTAgODAwaDEwMGw1MCAtMTE5bDI4IC0xMmwxMTkgNTBsNzIgLTcybC01MCAtMTE5bDEyIC0yOGwxMTkgLTUwdi0xMDBsLTExOSAtNTBsLTEyIC0yOGw1MCAtMTE5bC03MiAtNzJsLTExOSA1MGwtMjggLTEybC01MCAtMTE5aC0xMDBsLTUwIDExOWwtMjggMTJsLTExOSAtNTBsLTcyIDcybDUwIDExOWwtMTIgMjhsLTExOSA1MHYxMDBsMTE5IDUwbDEyIDI4bC01MCAxMTlsNzIgNzJsMTE5IC01MGwyOCAxMnpNNDAwIDU1MApjLTgzIDAgLTE1MCAtNjcgLTE1MCAtMTUwczY3IC0xNTAgMTUwIC0xNTBzMTUwIDY3IDE1MCAxNTBzLTY3IDE1MCAtMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDIiIHVuaWNvZGU9IiYjeGUwNDI7IiAKZD0iTTAgODAwaDgwMHYtMjAwaC04MDB2MjAwek0yMDAgNTAwaDQwMGwtMjAwIC0yMDB6TTAgMTAwaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0MyIgdW5pY29kZT0iJiN4ZTA0MzsiIApkPSJNMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTYwMCA4MDBoMjAwdi04MDBoLTIwMHY4MDB6TTUwMCA2MDB2LTQwMGwtMjAwIDIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDQiIHVuaWNvZGU9IiYjeGUwNDQ7IiAKZD0iTTAgODAwaDIwMHYtODAwaC0yMDB2ODAwek03MDAgODAwaDEwMHYtODAwaC0xMDB2ODAwek0zMDAgNjAwbDIwMCAtMjAwbC0yMDAgLTIwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQ1IiB1bmljb2RlPSImI3hlMDQ1OyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNNDAwIDUwMGwyMDAgLTIwMGgtNDAwek0wIDIwMGg4MDB2LTIwMGgtODAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDYiIHVuaWNvZGU9IiYjeGUwNDY7IiAKZD0iTTE1MCA3MDBjODMgMCAxNTAgLTY3IDE1MCAtMTUwdi01MGgxMDB2NTBjMCA4MyA2NyAxNTAgMTUwIDE1MHMxNTAgLTY3IDE1MCAtMTUwcy02NyAtMTUwIC0xNTAgLTE1MGgtNTB2LTEwMGg1MGM4MyAwIDE1MCAtNjcgMTUwIC0xNTBzLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTB2NTBoLTEwMHYtNTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBzNjcgMTUwIDE1MCAxNTBoNTB2MTAwaC01MApjLTgzIDAgLTE1MCA2NyAtMTUwIDE1MHM2NyAxNTAgMTUwIDE1MHpNMTUwIDYwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGg1MHY1MGMwIDI4IC0yMiA1MCAtNTAgNTB6TTU1MCA2MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwdi01MGg1MGMyOCAwIDUwIDIyIDUwIDUwcy0yMiA1MCAtNTAgNTB6TTMwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTE1MCAyMDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTAKczUwIDIyIDUwIDUwdjUwaC01MHpNNTAwIDIwMHYtNTBjMCAtMjggMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwaC01MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDciIHVuaWNvZGU9IiYjeGUwNDc7IiAKZD0iTTAgNzkxYzAgNSA0IDkgOSA5aDc4MmM2IDAgOSAtNCA5IC0xMHYtNzkwbC0yMDAgMjAwaC01OTFjLTYgMCAtOSAzIC05IDl2NTgyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0OCIgdW5pY29kZT0iJiN4ZTA0ODsiIApkPSJNNDAwIDgwMGMyMjAgMCA0MDAgLTE4MCA0MDAgLTQwMHMtMTgwIC00MDAgLTQwMCAtNDAwcy00MDAgMTgwIC00MDAgNDAwczE4MCA0MDAgNDAwIDQwMHpNNDAwIDcwMGMtMTY2IDAgLTMwMCAtMTM0IC0zMDAgLTMwMHMxMzQgLTMwMCAzMDAgLTMwMHMzMDAgMTM0IDMwMCAzMDBzLTEzNCAzMDAgLTMwMCAzMDB6TTYwMCA2MDBsLTEwMCAtMzAwbC0zMDAgLTEwMGwxMDAgMzAwek00MDAgNDUwYy0yOCAwIC01MCAtMjIgLTUwIC01MApzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0OSIgdW5pY29kZT0iJiN4ZTA0OTsiIApkPSJNNDAwIDgwMGMyMjAgMCA0MDAgLTE4MCA0MDAgLTQwMHMtMTgwIC00MDAgLTQwMCAtNDAwcy00MDAgMTgwIC00MDAgNDAwczE4MCA0MDAgNDAwIDQwMHpNNDAwIDcwMHYtNjAwYzE2NiAwIDMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNGEiIHVuaWNvZGU9IiYjeGUwNGE7IiAKZD0iTTAgODAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDYwMGg1MDB2LTEwMGgtNTAwdjEwMHpNMCAzMDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAwaDYwMHYtMTAwaC02MDB2MTAwek03NTAgMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNGIiIHVuaWNvZGU9IiYjeGUwNGI7IiAKZD0iTTI1IDcwMGg3NTBjMTQgMCAyNSAtMTEgMjUgLTI1di03NWgtODAwdjc1YzAgMTQgMTEgMjUgMjUgMjV6TTAgNTAwaDgwMHYtMzc1YzAgLTE0IC0xMSAtMjUgLTI1IC0yNWgtNzUwYy0xNCAwIC0yNSAxMSAtMjUgMjV2Mzc1ek0xMDAgMzAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgMzAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0YyIgdW5pY29kZT0iJiN4ZTA0YzsiIApkPSJNMTAwIDgwMGgxMDB2LTEwMGg0NTBsMTAwIDEwMGw1MCAtNTBsLTEwMCAtMTAwdi00NTBoMTAwdi0xMDBoLTEwMHYtMTAwaC0xMDB2MTAwaC01MDB2NTAwaC0xMDB2MTAwaDEwMHYxMDB6TTIwMCA2MDB2LTM1MGwzNTAgMzUwaC0zNTB6TTYwMCA1NTBsLTM1MCAtMzUwaDM1MHYzNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRkIiB1bmljb2RlPSImI3hlMDRkOyIgCmQ9Ik00MDAgODAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwcy0xODAgLTQwMCAtNDAwIC00MDBzLTQwMCAxODAgLTQwMCA0MDBzMTgwIDQwMCA0MDAgNDAwek00MDAgNzAwYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwczMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHpNNDAwIDYwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6Ck0yMDAgNDUyYzAgMjAgMTUgNDIgMzQgNDhoM2gzaDhjMTIgMCAyOCAtNyAzNiAtMTZsOTEgLTkwbDI1IDZjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwcy00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwbDYgMjVsLTkwIDkxYy05IDggLTE2IDI0IC0xNiAzNnpNNTUwIDUwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRlIiB1bmljb2RlPSImI3hlMDRlOyIgCmQ9Ik0zMDAgODAwaDIwMHYtMzAwaDIwMGwtMzAwIC0zMDBsLTMwMCAzMDBoMjAwdjMwMHpNMCAxMDBoODAwdi0xMDBoLTgwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRmIiB1bmljb2RlPSImI3hlMDRmOyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNNDAwIDYwMGwzMDAgLTMwMGgtMjAwdi0zMDBoLTIwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTAiIHVuaWNvZGU9IiYjeGUwNTA7IiAKZD0iTTIwMCA3MDBoNjAwdi02MDBoLTYwMGwtMjAwIDMwMHpNMzUwIDYyMmwtNzIgLTcybDE1MCAtMTUwbC0xNTAgLTE1MGw3MiAtNzJsMTUwIDE1MGwxNTAgLTE1MGw3MiA3MmwtMTUwIDE1MGwxNTAgMTUwbC03MiA3MmwtMTUwIC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjUxIiB1bmljb2RlPSImI3hlMDUxOyIgCmQ9Ik00MDAgNzAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwaC0xMDBjMCAxNjYgLTEzNCAzMDAgLTMwMCAzMDBzLTMwMCAtMTM0IC0zMDAgLTMwMGgtMTAwYzAgMjIwIDE4MCA0MDAgNDAwIDQwMHpNMzQxIDQ5MWw1OSAtODhsNTkgODhjODEgLTI1IDE0MSAtMTAxIDE0MSAtMTkxYzAgLTExMCAtOTAgLTIwMCAtMjAwIC0yMDBzLTIwMCA5MCAtMjAwIDIwMGMwIDkwIDYwIDE2NiAxNDEgMTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1MiIgdW5pY29kZT0iJiN4ZTA1MjsiIApkPSJNMCA4MDBoMzAwdi00MDBoNDAwdi00MDBoLTcwMHY4MDB6TTQwMCA4MDBsMzAwIC0zMDBoLTMwMHYzMDB6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCAyMDB2LTEwMGg0MDB2MTAwaC00MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjUzIiB1bmljb2RlPSImI3hlMDUzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yMDAgNzAwaDEwMHYtMTAwaDc1YzMwIDAgNTggLTYgODEgLTIyczQ0IC00NCA0NCAtNzh2LTEwMGgtMTAwdjk0Yy00IDMgLTEzIDYgLTI1IDZoLTI1MGMtMTQgMCAtMjUgLTExIC0yNSAtMjV2LTUwYzAgLTE1IDIwIC00MCAzNCAtNDRsMjU3IC02NWM2NiAtMTYgMTA5IC03MyAxMDkgLTE0MXYtNTBjMCAtNjggLTU3IC0xMjUgLTEyNSAtMTI1aC03NXYtMTAwaC0xMDB2MTAwaC03NWMtMzAgMCAtNTggNiAtODEgMjJzLTQ0IDQ0IC00NCA3OAp2MTAwaDEwMHYtOTRjNCAtMyAxMyAtNiAyNSAtNmgyNTBjMTQgMCAyNSAxMSAyNSAyNXY1MGMwIDE1IC0yMCA0MCAtMzQgNDRsLTI1NyA2NWMtNjYgMTYgLTEwOSA3MyAtMTA5IDE0MXY1MGMwIDY4IDU3IDEyNSAxMjUgMTI1aDc1djEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTQiIHVuaWNvZGU9IiYjeGUwNTQ7IiAKZD0iTTAgNzAwaDMwMHYtMzAwbC0zMDAgLTMwMHY2MDB6TTUwMCA3MDBoMzAwdi0zMDBsLTMwMCAtMzAwdjYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTUiIHVuaWNvZGU9IiYjeGUwNTU7IiAKZD0iTTMwMCA3MDB2LTYwMGgtMzAwdjMwMHpNODAwIDcwMHYtNjAwaC0zMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1NiIgdW5pY29kZT0iJiN4ZTA1NjsiIApkPSJNMzAwIDcwMHYtMTAwYy0xMTEgMCAtMjAwIC04OSAtMjAwIC0yMDBoMjAwdi0zMDBoLTMwMHYzMDBjMCAxNjUgMTM1IDMwMCAzMDAgMzAwek04MDAgNzAwdi0xMDBjLTExMSAwIC0yMDAgLTg5IC0yMDAgLTIwMGgyMDB2LTMwMGgtMzAwdjMwMGMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjU3IiB1bmljb2RlPSImI3hlMDU3OyIgCmQ9Ik0wIDcwMGgzMDB2LTMwMGMwIC0xNjUgLTEzNSAtMzAwIC0zMDAgLTMwMHYxMDBjMTExIDAgMjAwIDg5IDIwMCAyMDBoLTIwMHYzMDB6TTUwMCA3MDBoMzAwdi0zMDBjMCAtMTY1IC0xMzUgLTMwMCAtMzAwIC0zMDB2MTAwYzExMSAwIDIwMCA4OSAyMDAgMjAwaC0yMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1OCIgdW5pY29kZT0iJiN4ZTA1ODsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGwzNCAtMzRjMTEgLTExIDI2NiAtMjcwIDI2NiAtNDg4YzAgLTE2NSAtMTM1IC0zMDAgLTMwMCAtMzAwcy0zMDAgMTM1IC0zMDAgMzAwYzAgMjE4IDI1NSA0NzcgMjY2IDQ4OHpNMTUwIDMyOGMtMjggMCAtNTAgLTIyIC01MCAtNTBjMCAtMTEwIDkwIC0yMDAgMjAwIC0yMDBjMjggMCA1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwYy01NSAwIC0xMDAgNDUgLTEwMCAxMDBjMCAyOCAtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1OSIgdW5pY29kZT0iJiN4ZTA1OTsiIApkPSJNNDAwIDgwMGw0MDAgLTUwMGgtODAwek0wIDIwMGg4MDB2LTIwMGgtODAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNWEiIHVuaWNvZGU9IiYjeGUwNWE7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTMwMCA4MDBsMzAwIC0zMDBoLTYwMHpNMCAzMDBoNjAwbC0zMDAgLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNWIiIHVuaWNvZGU9IiYjeGUwNWI7IiAKZD0iTTAgNTAwaDIwMHYtMjAwaC0yMDB2MjAwek0zMDAgNTAwaDIwMHYtMjAwaC0yMDB2MjAwek02MDAgNTAwaDIwMHYtMjAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1YyIgdW5pY29kZT0iJiN4ZTA1YzsiIApkPSJNMCA3MDBoODAwdi0xMDBsLTQwMCAtMjAwbC00MDAgMjAwdjEwMHpNMCA1MDBsNDAwIC0yMDBsNDAwIDIwMHYtNDAwaC04MDB2NDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1ZCIgdW5pY29kZT0iJiN4ZTA1ZDsiIApkPSJNNDAwIDgwMGw0MDAgLTIwMHYtNjAwaC04MDB2NjAwek00MDAgNjg4bC0zMDAgLTE1MHYtMTg4bDMwMCAtMTUwbDMwMCAxNTB2MTg4ek0yMDAgNTAwaDQwMHYtMTAwbC0yMDAgLTEwMGwtMjAwIDEwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjVlIiB1bmljb2RlPSImI3hlMDVlOyIgCmQ9Ik02MDAgNzAwYzY5IDAgMTM0IC0xOSAxOTEgLTUwbC0xNiAtMTA2Yy00OSAzNSAtMTA5IDU2IC0xNzUgNTZjLTEzMSAwIC0yNDAgLTg0IC0yODEgLTIwMGgzMzFsLTE2IC0xMDBoLTMzNGMwIC0zNiA4IC02OCAxOSAtMTAwaDI5N2wtMTYgLTEwMGgtMjIyYzU1IC02MSAxMzMgLTEwMCAyMjIgLTEwMGM3OCAwIDE0NyAzMCAyMDAgNzh2LTEyMmMtNTkgLTM1IC0xMjcgLTU2IC0yMDAgLTU2Yy0xNDcgMCAtMjc0IDgyIC0zNDQgMjAwaC0yNTYKbDE5IDEwMGgxOTdjLTggMzIgLTE2IDY2IC0xNiAxMDBoLTIwMGwyNSAxMDBoMTkxYzQ1IDE3MiAxOTggMzAwIDM4NCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjVmIiB1bmljb2RlPSImI3hlMDVmOyIgCmQ9Ik0wIDcwMGg3MDB2LTEwMGgtNzAwdjEwMHpNMCA1MDBoNTAwdi0xMDBoLTUwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMjAwIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNDAwIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjAiIHVuaWNvZGU9IiYjeGUwNjA7IiAKZD0iTTAgODAwaDgwMHYtMTAwaC04MDB2MTAwek0yMDAgNjAwaDQwMGwtMjAwIC0yMDB6TTAgMjAwaDgwMHYtMjAwaC04MDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2MSIgdW5pY29kZT0iJiN4ZTA2MTsiIApkPSJNMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTYwMCA4MDBoMjAwdi04MDBoLTIwMHY4MDB6TTIwMCA2MDBsMjAwIC0yMDBsLTIwMCAtMjAwdjQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjIiIHVuaWNvZGU9IiYjeGUwNjI7IiAKZD0iTTAgODAwaDIwMHYtODAwaC0yMDB2ODAwek03MDAgODAwaDEwMHYtODAwaC0xMDB2ODAwek02MDAgNjAwdi00MDBsLTIwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjYzIiB1bmljb2RlPSImI3hlMDYzOyIgCmQ9Ik0wIDgwMGg4MDB2LTIwMGgtODAwdjIwMHpNNDAwIDQwMGwyMDAgLTIwMGgtNDAwek0wIDEwMGg4MDB2LTEwMGgtODAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjQiIHVuaWNvZGU9IiYjeGUwNjQ7IiAKZD0iTTAgODAwaDIwMHYtMTAwaC0xMDB2LTYwMGg2MDB2MTAwaDEwMHYtMjAwaC04MDB2ODAwek00MDAgODAwaDQwMHYtNDAwbC0xNTAgMTUwbC0yNTAgLTI1MGwtMTAwIDEwMGwyNTAgMjUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2NSIgdW5pY29kZT0iJiN4ZTA2NTsiIApkPSJNNDAzIDcwMGMyNDcgMCAzOTcgLTMwMCAzOTcgLTMwMHMtMTUwIC0zMDAgLTM5NyAtMzAwYy0yNTMgMCAtNDAzIDMwMCAtNDAzIDMwMHMxNTAgMzAwIDQwMyAzMDB6TTQwMCA2MDBjLTExMCAwIC0yMDAgLTkwIC0yMDAgLTIwMHM5MCAtMjAwIDIwMCAtMjAwczIwMCA5MCAyMDAgMjAwcy05MCAyMDAgLTIwMCAyMDB6TTQwMCA1MDBjMTAgMCAxOSAtMyAyOCAtNmMtMTYgLTggLTI4IC0yNCAtMjggLTQ0YzAgLTI4IDIyIC01MCA1MCAtNTAKYzIwIDAgMzYgMTIgNDQgMjhjMyAtOSA2IC0xOCA2IC0yOGMwIC01NSAtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHM0NSAxMDAgMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjYiIHVuaWNvZGU9IiYjeGUwNjY7IiBob3Jpei1hZHYteD0iOTAwIiAKZD0iTTMzMSA3MDBoM2gzYzMgMSA3IDEgMTAgMWMxMiAwIDI5IC04IDM3IC0xN2w5NCAtOTNsNjYgNjVjNTcgNTcgMTU1IDU3IDIxMiAwYzU4IC01OCA1OCAtMTU0IDAgLTIxMmwtNjUgLTY2bDkzIC05NGMxMCAtOCAxOCAtMjUgMTggLTM4YzAgLTI4IC0yMiAtNTAgLTUwIC01MGMtMTMgMCAtMzIgOSAtNDAgMjBsLTYyIDY1bC0zODEgLTM4MWgtMjY5djI3MmwzNzUgMzgxbC02MyA2M2MtOSA4IC0xNiAyNCAtMTYgMzZjMCAyMCAxNiA0MiAzNSA0OHoKTTQ0NyA0ODFsLTMxMyAtMzE1bDEyOCAtMTMybDMxNiAzMTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjY3IiB1bmljb2RlPSImI3hlMDY3OyIgCmQ9Ik0wIDgwMGgzMDB2LTQwMGg0MDB2LTQwMGgtNzAwdjgwMHpNNDAwIDgwMGwzMDAgLTMwMGgtMzAwdjMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjgiIHVuaWNvZGU9IiYjeGUwNjg7IiAKZD0iTTIwMCA4MDBjMCAwIDIwMCAtMTAwIDIwMCAtMzAwcy0yOTggLTMwMiAtMjAwIC01MDBjMCAwIC0yMDAgMTAwIC0yMDAgMzAwczMwMCAzMDAgMjAwIDUwMHpNNTAwIDUwMGMwIDAgMjAwIC0xMDAgMjAwIC0zMDBjMCAtMTUwIC02MCAtMjAwIC0xMDAgLTIwMGgtMzAwYzAgMjAwIDMwMCAzMDAgMjAwIDUwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjkiIHVuaWNvZGU9IiYjeGUwNjk7IiAKZD0iTTAgODAwaDEwMHYtODAwaC0xMDB2ODAwek0yMDAgODAwaDMwMHYtMTAwaDMwMGwtMjAwIC0yMDNsMjAwIC0xOTdoLTQwMHYxMDBoLTIwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjZhIiB1bmljb2RlPSImI3hlMDZhOyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0xNTAgODAwaDE1MGwtMTAwIC0yMDBoMjAwbC0xNTAgLTMwMGgxNTBsLTMwMCAtMzAwbC0xMDAgMzAwaDEzNGw2NiAyMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmIiIHVuaWNvZGU9IiYjeGUwNmI7IiAKZD0iTTAgODAwaDMwMHYtMTAwaDUwMHYtMTAwaC04MDB2MjAwek0wIDUwMGg4MDB2LTQ1MGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjQ1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmMiIHVuaWNvZGU9IiYjeGUwNmM7IiAKZD0iTTE1MCA4MDBjODMgMCAxNTAgLTY3IDE1MCAtMTUwYzAgLTY2IC00MSAtMTIxIC0xMDAgLTE0MXYtMTE4YzE1IDUgMzMgOSA1MCA5aDIwMGMyOCAwIDUwIDIyIDUwIDUwdjU5Yy01OSAyMCAtMTAwIDc1IC0xMDAgMTQxYzAgODMgNjcgMTUwIDE1MCAxNTBzMTUwIC02NyAxNTAgLTE1MGMwIC02NiAtNDEgLTEyMSAtMTAwIC0xNDF2LTU5YzAgLTgyIC02OCAtMTUwIC0xNTAgLTE1MGgtMjAwYy0xNCAwIC0yNSAtNyAtMzQgLTE2CmM1MCAtMjQgODQgLTc0IDg0IC0xMzRjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBjMCA2NiA0MSAxMjEgMTAwIDE0MXYyMThjLTU5IDIwIC0xMDAgNzUgLTEwMCAxNDFjMCA4MyA2NyAxNTAgMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmQiIHVuaWNvZGU9IiYjeGUwNmQ7IiAKZD0iTTAgODAwaDQwMGwtMTUwIC0xNTBsMTUwIC0xNTBsLTEwMCAtMTAwbC0xNTAgMTUwbC0xNTAgLTE1MHY0MDB6TTUwMCA0MDBsMTUwIC0xNTBsMTUwIDE1MHYtNDAwaC00MDBsMTUwIDE1MGwtMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmUiIHVuaWNvZGU9IiYjeGUwNmU7IiAKZD0iTTEwMCA4MDBsMTUwIC0xNTBsMTUwIDE1MHYtNDAwaC00MDBsMTUwIDE1MGwtMTUwIDE1MHpNNDAwIDQwMGg0MDBsLTE1MCAtMTUwbDE1MCAtMTUwbC0xMDAgLTEwMGwtMTUwIDE1MGwtMTUwIC0xNTB2NDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2ZiIgdW5pY29kZT0iJiN4ZTA2ZjsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGMtNTYgMCAtMTA4IC0xNyAtMTUzIC00NGwyMiAtMTljMzMgLTE4IDEzIC00OCAtMTMgLTU5Yy0zMCAtMTMgLTc3IDEwIC02NSAtNDFjMTMgLTU1IC0yNyAtMyAtNDcgLTE1Yy00MiAtMjYgNDkgLTE1MiAzMSAtMTU2bC01OSAzNGMtOCAwIC0xMyAtNSAtMTYgLTEwCmMxIC0zMCAxMCAtNTcgMTkgLTg0YzI4IC0xMSA3NyAtMiAxMDAgLTI1YzQ3IC0yOCA5NyAtMTE1IDc1IC0xNTljMzQgLTEzIDY4IC0yMiAxMDYgLTIyYzEwMSAwIDE5MyA0OCAyNDcgMTI1YzMgMjQgLTggNDQgLTUwIDQ0Yy02OSAwIC0xNTYgMTMgLTE1MyA5N2MyIDQ2IDEwMSAxMDggNjYgMTQzYy0zMCAzMCAxMiAzOSAxMiA2NmMwIDM3IC02NSAzMiAtNjkgNTBzMjAgMzYgNDEgNTZjLTMwIDEwIC02MCAxOSAtOTQgMTl6TTYzMSA1OTEKYy0zOCAtMTEgLTk0IC0zNSAtODcgLTUzYzYgLTE1IDUyIC0xIDY1IC0xM2MxMSAtMTAgMTYgLTU5IDQ0IC0zMWwyMiAyMnYzYy0xMSAyNiAtMjYgNTAgLTQ0IDcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3MCIgdW5pY29kZT0iJiN4ZTA3MDsiIApkPSJNNzAzIDgwMGw5NyAtMTAwbC00MDAgLTQwMGwtMTAwIDEwMGwtMjAwIC0yMDNsLTEwMCAxMDBsMzAwIDMwM2wxMDAgLTEwMHpNMCAxMDBoODAwdi0xMDBoLTgwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjcxIiB1bmljb2RlPSImI3hlMDcxOyIgCmQ9Ik0wIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMjAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNDAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNjAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTIwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTQwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTYwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTAgMzAwaDEwMHYtMTAwaC0xMDB2MTAwek0yMDAgMzAwaDEwMAp2LTEwMGgtMTAwdjEwMHpNNDAwIDMwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNjAwIDMwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTIwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTQwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTYwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjcyIiB1bmljb2RlPSImI3hlMDcyOyIgCmQ9Ik0wIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNMzAwIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNNjAwIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTMwMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTYwMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTAgMjAwaDIwMHYtMjAwaC0yMDB2MjAwek0zMDAgMjAwaDIwMHYtMjAwaC0yMDB2MjAwek02MDAgMjAwaDIwMHYtMjAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3MyIgdW5pY29kZT0iJiN4ZTA3MzsiIApkPSJNMCA4MDBoMzAwdi0zMDBoLTMwMHYzMDB6TTUwMCA4MDBoMzAwdi0zMDBoLTMwMHYzMDB6TTAgMzAwaDMwMHYtMzAwaC0zMDB2MzAwek01MDAgMzAwaDMwMHYtMzAwaC0zMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3NCIgdW5pY29kZT0iJiN4ZTA3NDsiIApkPSJNMTkgODAwaDY2MmMxMSAwIDE5IC04IDE5IC0xOXYtMzMxYzAgLTI4IC0yMiAtNTAgLTUwIC01MGgtNjAwYy0yOCAwIC01MCAyMiAtNTAgNTB2MzMxYzAgMTEgOCAxOSAxOSAxOXpNMCAzMDljMTYgLTYgMzIgLTkgNTAgLTloNjAwYzE4IDAgMzQgMyA1MCA5di0yOTBjMCAtMTEgLTggLTE5IC0xOSAtMTloLTY2MmMtMTEgMCAtMTkgOCAtMTkgMTl2Mjkwek01NTAgMjAwYy0yOCAwIC01MCAtMjIgLTUwIC01MHMyMiAtNTAgNTAgLTUwCnM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3NSIgdW5pY29kZT0iJiN4ZTA3NTsiIApkPSJNMCA3MDBoMzAwdi0xMDBoLTUwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtMTUwaDMwMHYxNTBjMCAyOCAtMjIgNTAgLTUwIDUwaC01MHYxMDBoMzAwdi0xMDBoLTUwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtNDAwYzAgLTI4IDIyIC01MCA1MCAtNTBoNTB2LTEwMGgtMzAwdjEwMGg1MGMyOCAwIDUwIDIyIDUwIDUwdjE1MGgtMzAwdi0xNTBjMCAtMjggMjIgLTUwIDUwIC01MGg1MHYtMTAwaC0zMDB2MTAwaDUwYzI4IDAgNTAgMjIgNTAgNTAKdjQwMGMwIDI4IC0yMiA1MCAtNTAgNTBoLTUwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNzYiIHVuaWNvZGU9IiYjeGUwNzY7IiAKZD0iTTQwMCA3MDBjMTY1IDAgMzAwIC0xMzUgMzAwIC0zMDB2LTEwMGg1MGMyOCAwIDUwIC0yMiA1MCAtNTB2LTIwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTEwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjM1MGMwIDExMSAtODkgMjAwIC0yMDAgMjAwcy0yMDAgLTg5IC0yMDAgLTIwMHYtMzUwYzAgLTI4IC0yMiAtNTAgLTUwIC01MGgtMTAwYy0yOCAwIC01MCAyMiAtNTAgNTB2MjAwYzAgMjggMjIgNTAgNTAgNTBoNTB2MTAwCmMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijc3IiB1bmljb2RlPSImI3hlMDc3OyIgCmQ9Ik0wIDUwMGMwIDEwOSA5MSAyMDAgMjAwIDIwMHMyMDAgLTkxIDIwMCAtMjAwYzAgMTA5IDkxIDIwMCAyMDAgMjAwczIwMCAtOTEgMjAwIC0yMDBjMCAtNTUgLTIzIC0xMDUgLTU5IC0xNDFsLTM0MSAtMzQwbC0zNDEgMzQwYy0zNiAzNiAtNTkgODYgLTU5IDE0MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNzgiIHVuaWNvZGU9IiYjeGUwNzg7IiAKZD0iTTQwMCA3MDBsNDAwIC0zMDBsLTEwMCAzdi00MDNoLTIwMHYyMDBoLTIwMHYtMjAwaC0yMDB2NDAwaC0xMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijc5IiB1bmljb2RlPSImI3hlMDc5OyIgCmQ9Ik0wIDgwMGg4MDB2LTgwMGgtODAwdjgwMHpNMTAwIDcwMHYtMzAwbDEwMCAxMDBsNDAwIC00MDBoMTAwdjEwMGwtMjAwIDIwMGwxMDAgMTAwbDEwMCAtMTAwdjMwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3YSIgdW5pY29kZT0iJiN4ZTA3YTsiIApkPSJNMTkgODAwaDc2MmMxMSAwIDE5IC04IDE5IC0xOXYtNzYyYzAgLTExIC04IC0xOSAtMTkgLTE5aC03NjJjLTExIDAgLTE5IDggLTE5IDE5djc2MmMwIDExIDggMTkgMTkgMTl6TTEwMCA2MDB2LTMwMGgxMDBsMTAwIC0xMDBoMjAwbDEwMCAxMDBoMTAwdjMwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3YiIgdW5pY29kZT0iJiN4ZTA3YjsiIApkPSJNMjAwIDYwMGM4MCAwIDE0MiAtNTYgMjAwIC0xMjJjNTggNjYgMTE5IDEyMiAyMDAgMTIyYzEzMSAwIDIwMCAtMTAxIDIwMCAtMjAwcy02OSAtMjAwIC0yMDAgLTIwMGMtODEgMCAtMTQyIDU2IC0yMDAgMTIyYy01OCAtNjYgLTEyMSAtMTIyIC0yMDAgLTEyMmMtMTMxIDAgLTIwMCAxMDEgLTIwMCAyMDBzNjkgMjAwIDIwMCAyMDB6TTIwMCA1MDBjLTc0IDAgLTEwMCAtNTQgLTEwMCAtMTAwczI2IC0xMDAgMTAwIC0xMDAKYzQyIDAgODggNDcgMTM0IDEwMGMtNDYgNTMgLTkyIDEwMCAtMTM0IDEwMHpNNjAwIDUwMGMtNDMgMCAtODggLTQ3IC0xMzQgLTEwMGM0NiAtNTMgOTEgLTEwMCAxMzQgLTEwMGM3NCAwIDEwMCA1NCAxMDAgMTAwcy0yNiAxMDAgLTEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjdjIiB1bmljb2RlPSImI3hlMDdjOyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0zMDAgODAwYzU1IDAgMTAwIC00NSAxMDAgLTEwMHMtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHM0NSAxMDAgMTAwIDEwMHpNMTUwIDU1MGM4MyAwIDE1MCAtNjkgMTUwIC0xNTBjMCAtNjYgLTEwMCAtMjE0IC0xMDAgLTI1MGMwIC0yOCAyMiAtNTAgNTAgLTUwczUwIDIyIDUwIDUwaDEwMGMwIC04MyAtNjcgLTE1MCAtMTUwIC0xNTBzLTE1MCA2NCAtMTUwIDE1MHMxMDAgMjIyIDEwMCAyNTBzLTIyIDUwIC01MCA1MApzLTUwIC0yMiAtNTAgLTUwaC0xMDBjMCA4MyA2NyAxNTAgMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iN2QiIHVuaWNvZGU9IiYjeGUwN2Q7IiAKZD0iTTIwMCA4MDBoNTAwdi0xMDBoLTEyMmMtNzcgLTE5NyAtMTU2IC0zOTIgLTIzNCAtNTg4bC02IC0xMmgxNjJ2LTEwMGgtNTAwdjEwMGgxMjJjNzcgMTk3IDE1NiAzOTIgMjM0IDU4OGw3IDEyaC0xNjN2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3ZSIgdW5pY29kZT0iJiN4ZTA3ZTsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgNTAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDMwMGg4MDB2LTEwMGgtODAwdjEwMHpNMTAwIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iN2YiIHVuaWNvZGU9IiYjeGUwN2Y7IiAKZD0iTTAgNzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDUwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCAzMDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MCIgdW5pY29kZT0iJiN4ZTA4MDsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgNTAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDMwMGg4MDB2LTEwMGgtODAwdjEwMHpNMjAwIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODEiIHVuaWNvZGU9IiYjeGUwODE7IiAKZD0iTTU1MCA4MDBjMTM4IDAgMjUwIC0xMTIgMjUwIC0yNTBzLTExMiAtMjUwIC0yNTAgLTI1MGMtMTYgMCAtMzIgMCAtNDcgM2wtMyAtM3YtMTAwaC0yMDB2LTIwMGgtMzAwdjIwMGwzMDMgMzAzYy0zIDE1IC0zIDMxIC0zIDQ3YzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNNjAwIDcwMGMtNTUgMCAtMTAwIC00NSAtMTAwIC0xMDBzNDUgLTEwMCAxMDAgLTEwMHMxMDAgNDUgMTAwIDEwMHMtNDUgMTAwIC0xMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MiIgdW5pY29kZT0iJiN4ZTA4MjsiIApkPSJNMTM0IDYwMGgzaDRoNGg1aDUwMGMyOCAwIDUwIC0yMiA1MCAtNTB2LTM1MGgxMDB2LTE1MGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjE1MGgxMDB2MzUwdjJjMCAyMCAxNSA0MiAzNCA0OHpNMjAwIDUwMHYtMzAwaDEwMHYtMTAwaDIwMHYxMDBoMTAwdjMwMGgtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MyIgdW5pY29kZT0iJiN4ZTA4MzsiIApkPSJNMCA4MDBoNDAwdi00MDBoLTQwMHY0MDB6TTUwMCA2MDBoMTAwdi00MDBoLTQwMHYxMDBoMzAwdjMwMHpNNzAwIDQwMGgxMDB2LTQwMGgtNDAwdjEwMGgzMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4NCIgdW5pY29kZT0iJiN4ZTA4NDsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzM3IDY5NGM2IDQgMTIgNyAyMSA3YzI4IDAgNTAgLTIyIDUwIC01MGMwIC0xNyAtMTIgLTM3IC0yNyAtNDVsLTMwMCAtMTUwYy04IC02IC0yMSAtMTEgLTMxIC0xMWMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMjEgMTYgNDQgMzcgNDl6TTQzNyA1NDRjNiA0IDEyIDcgMjEgN2MyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTcgLTEyIC0zNyAtMjcgLTQ1bC00MDAgLTIwMGMtOCAtNiAtMjEgLTExIC0zMSAtMTFjLTI4IDAgLTUwIDIyIC01MCA1MApjMCAyMSAxNiA0NCAzNyA0OXpNNDM3IDM0NGM2IDQgMTIgNyAyMSA3YzI4IDAgNTAgLTIyIDUwIC01MGMwIC0xNyAtMTIgLTM3IC0yNyAtNDVsLTEwNiAtNTZjMjQgLTQgNDMgLTI2IDQzIC01MGMwIC0yOCAtMjMgLTUxIC01MSAtNTFjLTIgMCAtNiAxIC04IDFoLTIwMGMtMjYgMSAtNDggMjQgLTQ4IDUwYzAgMTYgMTIgMzYgMjYgNDR6TTE1MSAtNTBjMCAyMyAyMCA1MCA0NiA1MGgzaDRoNWgxMDBjMjggMCA1MCAtMjIgNTAgLTUwCnMtMjIgLTUwIC01MCAtNTBoLTEwMGMtMiAwIC02IC0xIC04IC0xYy0yOCAwIC01MCAyMyAtNTAgNTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijg1IiB1bmljb2RlPSImI3hlMDg1OyIgCmQ9Ik0xOTkgODAwaDEwMHYtMjAwaC0yMDB2MTAwaDEwMHYxMDB6TTU4NiA3OTdoMWMxOCAxIDM4IDEgNTYgLTNjMzYgLTggNjkgLTI2IDk3IC01NGM3OCAtNzggNzggLTIwMyAwIC0yODFsLTE1MCAtMTUwYy04IC0xMyAtMjggLTI0IC00MyAtMjRjLTI4IDAgLTUwIDIyIC01MCA1MGMwIDE1IDExIDM1IDI0IDQzbDE1MCAxNTBjNDAgNDAgMzkgMTA1IDAgMTQ0Yy00MSA0MSAtMTEwIDM0IC0xNDQgMGwtNDQgLTQ0CmMtOCAtMTMgLTI3IC0yNCAtNDIgLTI0Yy0yOCAwIC01MCAyMiAtNTAgNTBjMCAxNSAxMSAzNSAyNCA0M2w0MyA0NGMzMiAzMyA3MiA1MyAxMjggNTZ6TTIwOCA0OTBjNCA1IDE0IDE2IDIyIDE2aDNjMiAwIDYgMSA4IDFjMjggMCA1MCAtMjIgNTAgLTUwYzAgLTExIC02IC0yNyAtMTQgLTM1bC0xNTAgLTE1MGMtNDAgLTQwIC0zOSAtMTA1IDAgLTE0NGM0MSAtNDEgMTEwIC0zNCAxNDQgMGw0NCA0NGM4IDEzIDI3IDI0IDQyIDI0CmMyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTUgLTExIC0zNSAtMjQgLTQzbC00MyAtNDRjLTIyIC0yMiAtNDggLTM3IC03NSAtNDdjLTcwIC0yNSAtMTUxIC05IC0yMDcgNDdjLTc4IDc4IC03OCAyMDMgMCAyODF6TTQ5OSAyMDBoMjAwdi0xMDBoLTEwMHYtMTAwaC0xMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4NiIgdW5pY29kZT0iJiN4ZTA4NjsiIApkPSJNNTg2IDc5N2MxOCAxIDM5IDEgNTcgLTNjMzYgLTggNjkgLTI2IDk3IC01NGM3OCAtNzggNzggLTIwMyAwIC0yODFsLTE1MCAtMTUwYy02MiAtNjIgLTEzMiAtODEgLTE4MiAtNzhzLTY5IDE3IC04NCAyNXMtMjYgMjcgLTI2IDQ0YzAgMjggMjIgNTEgNTAgNTFjOCAwIDE5IC0zIDI2IC03YzAgMCAxNSAtMTEgNDEgLTEzczYyIDMgMTA2IDQ3bDE1MCAxNTBjNDAgNDAgMzkgMTA1IDAgMTQ0Yy00MSA0MSAtMTEwIDM0IC0xNDQgMApjLTggLTEzIC0yOCAtMjQgLTQzIC0yNGMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMTUgMTEgMzUgMjQgNDNjMzIgMzMgNzIgNTMgMTI4IDU2ek0zODYgNTY2YzUwIC0yIDY0IC0xNyA4NSAtMjJzMzcgLTI4IDM3IC00OWMwIC0yOCAtMjIgLTUwIC01MCAtNTBjLTEwIDAgLTIzIDUgLTMxIDExYzAgMCAtMTkgOSAtNDcgMTBzLTYzIC00IC0xMDMgLTQ0bC0xNTAgLTE1MGMtNDAgLTQwIC0zOSAtMTA1IDAgLTE0NGM0MSAtNDEgMTEwIC0zNCAxNDQgMApjOCAxMyAyNyAyNCA0MiAyNGMyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTUgLTEwIC0zNSAtMjMgLTQzYy0yMiAtMjIgLTQ4IC0zNyAtNzUgLTQ3Yy03MCAtMjUgLTE1MSAtOSAtMjA3IDQ3Yy03OCA3OCAtNzggMjAzIDAgMjgxbDE1MCAxNTBjNjAgNjAgMTI4IDc4IDE3OCA3NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODciIHVuaWNvZGU9IiYjeGUwODc7IiAKZD0iTTAgNzAwaDMwMHYtMzAwaC0zMDB2MzAwek00MDAgNzAwaDQwMHYtMTAwaC00MDB2MTAwek00MDAgNTAwaDMwMHYtMTAwaC0zMDB2MTAwek0wIDMwMGgzMDB2LTMwMGgtMzAwdjMwMHpNNDAwIDMwMGg0MDB2LTEwMGgtNDAwdjEwMHpNNDAwIDEwMGgzMDB2LTEwMGgtMzAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODgiIHVuaWNvZGU9IiYjeGUwODg7IiAKZD0iTTUwIDcwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTIwMCA3MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTUwIDUwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTIwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTUwIDMwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTAKczIyIDUwIDUwIDUwek0yMDAgMzAwaDYwMHYtMTAwaC02MDB2MTAwek01MCAxMDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0yMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4OSIgdW5pY29kZT0iJiN4ZTA4OTsiIApkPSJNODAwIDgwMGwtNDAwIC04MDBsLTEwMCAzMDBsLTMwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhhIiB1bmljb2RlPSImI3hlMDhhOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0zMDAgNzAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDB2LTEwMGgxMDB2LTQwMGgtNjAwdjQwMGgxMDB2MTAwYzAgMTEwIDkwIDIwMCAyMDAgMjAwek0zMDAgNjAwYy01NiAwIC0xMDAgLTQ0IC0xMDAgLTEwMHYtMTAwaDIwMHYxMDBjMCA1NiAtNDQgMTAwIC0xMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4YiIgdW5pY29kZT0iJiN4ZTA4YjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGMxMTAgMCAyMDAgLTkwIDIwMCAtMjAwdi0yMDBoMTAwdi00MDBoLTYwMHY0MDBoNDAwdjIwMGMwIDU2IC00NCAxMDAgLTEwMCAxMDBzLTEwMCAtNDQgLTEwMCAtMTAwaC0xMDBjMCAxMTAgOTAgMjAwIDIwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhjIiB1bmljb2RlPSImI3hlMDhjOyIgCmQ9Ik00MDAgNzAwdi0xMDBjLTExMSAwIC0yMDAgLTg5IC0yMDAgLTIwMGgxMDBsLTE1MCAtMjAwbC0xNTAgMjAwaDEwMGMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6TTY1MCA2MDBsMTUwIC0yMDBoLTEwMGMwIC0xNjUgLTEzNSAtMzAwIC0zMDAgLTMwMHYxMDBjMTExIDAgMjAwIDg5IDIwMCAyMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOGQiIHVuaWNvZGU9IiYjeGUwOGQ7IiAKZD0iTTEwMCA4MDBoNjAwdi0zMDBoMTAwbC0xNTAgLTI1MGwtMTUwIDI1MGgxMDB2MjAwaC00MDB2LTEwMGgtMTAwdjIwMHpNMTUwIDU1MGwxNTAgLTI1MGgtMTAwdi0yMDBoNDAwdjEwMGgxMDB2LTIwMGgtNjAwdjMwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4ZSIgdW5pY29kZT0iJiN4ZTA4ZTsiIApkPSJNNjAwIDcwMGwyMDAgLTE1MGwtMjAwIC0xNTB2MTAwaC01MDB2LTEwMGgtMTAwdjEwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwaDUwMHYxMDB6TTIwMCAzMDB2LTEwMGg1MDB2MTAwaDEwMHYtMTAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMGgtNTAwdi0xMDBsLTIwMCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhmIiB1bmljb2RlPSImI3hlMDhmOyIgaG9yaXotYWR2LXg9IjkwMCIgCmQ9Ik0zNTAgODAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgLTYwIC0xNyAtMTE3IC00NCAtMTY2YzUgLTMgMTIgLTggMTYgLTEybDEwMCAtMTAwYzE2IC0xNiAzMCAtNDkgMzAgLTcyYzAgLTU2IC00NiAtMTAyIC0xMDIgLTEwMmMtMjMgMCAtNTYgMTQgLTcyIDMwbC0xMDAgMTAwYy00IDMgLTkgOSAtMTIgMTNjLTQ5IC0yNiAtMTA3IC00MSAtMTY2IC00MWMtMTkzIDAgLTM1MCAxNTcgLTM1MCAzNTBzMTU3IDM1MCAzNTAgMzUwek0zNTAgMjAwCmMxNDIgMCAyNTAgMTA4IDI1MCAyNTBjMCAxMzkgLTExMSAyNTAgLTI1MCAyNTBzLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTAiIHVuaWNvZGU9IiYjeGUwOTA7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTMwMCA4MDBjMTY2IDAgMzAwIC0xMzQgMzAwIC0zMDBjMCAtMjAwIC0zMDAgLTUwMCAtMzAwIC01MDBzLTMwMCAzMDAgLTMwMCA1MDBjMCAxNjYgMTM0IDMwMCAzMDAgMzAwek0zMDAgNzAwYy0xMTAgMCAtMjAwIC05MCAtMjAwIC0yMDBzOTAgLTIwMCAyMDAgLTIwMHMyMDAgOTAgMjAwIDIwMHMtOTAgMjAwIC0yMDAgMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5MSIgdW5pY29kZT0iJiN4ZTA5MTsiIGhvcml6LWFkdi14PSI5MDAiIApkPSJNMCA4MDBoODAwdi01NDFjMSAtMyAxIC04IDEgLTExczAgLTcgLTEgLTEwdi0yMzhoLTgwMHY4MDB6TTQ5NSAyNTBjMCAyNiAyMiA1MCA1MCA1MGg1aDE1MHY0MDBoLTYwMHYtNjAwaDYwMHYxMDBoLTE1MGgtNWMtMjggMCAtNTAgMjIgLTUwIDUwek0zNTAgNjAwYzgzIDAgMTUwIC02NyAxNTAgLTE1MGMwIC0xMDAgLTE1MCAtMjUwIC0xNTAgLTI1MHMtMTUwIDE1MCAtMTUwIDI1MGMwIDgzIDY3IDE1MCAxNTAgMTUwek0zNTAgNTAwCmMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5MiIgdW5pY29kZT0iJiN4ZTA5MjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMCA3MDBoMjAwdi02MDBoLTIwMHY2MDB6TTQwMCA3MDBoMjAwdi02MDBoLTIwMHY2MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjkzIiB1bmljb2RlPSImI3hlMDkzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0wIDcwMGw2MDAgLTMwMGwtNjAwIC0zMDB2NjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5NCIgdW5pY29kZT0iJiN4ZTA5NDsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDcwMGMxNjYgMCAzMDAgLTEzNCAzMDAgLTMwMHMtMTM0IC0zMDAgLTMwMCAtMzAwcy0zMDAgMTM0IC0zMDAgMzAwczEzNCAzMDAgMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTUiIHVuaWNvZGU9IiYjeGUwOTU7IiAKZD0iTTQwMCA3MDB2LTYwMGwtNDAwIDMwMHpNNDAwIDQwMGw0MDAgMzAwdi02MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijk2IiB1bmljb2RlPSImI3hlMDk2OyIgCmQ9Ik0wIDcwMGw0MDAgLTMwMGwtNDAwIC0zMDB2NjAwek00MDAgMTAwdjYwMGw0MDAgLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTciIHVuaWNvZGU9IiYjeGUwOTc7IiAKZD0iTTAgNzAwaDIwMHYtNjAwaC0yMDB2NjAwek0yMDAgNDAwbDUwMCAzMDB2LTYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTgiIHVuaWNvZGU9IiYjeGUwOTg7IiAKZD0iTTAgNzAwbDUwMCAtMzAwbC01MDAgLTMwMHY2MDB6TTUwMCAxMDB2NjAwaDIwMHYtNjAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijk5IiB1bmljb2RlPSImI3hlMDk5OyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0wIDcwMGg2MDB2LTYwMGgtNjAwdjYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOWEiIHVuaWNvZGU9IiYjeGUwOWE7IiAKZD0iTTIwMCA4MDBoNDAwdi0yMDBoMjAwdi00MDBoLTIwMHYtMjAwaC00MDB2MjAwaC0yMDB2NDAwaDIwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjliIiB1bmljb2RlPSImI3hlMDliOyIgCmQ9Ik0wIDcwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA0MDNoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAzaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5YyIgdW5pY29kZT0iJiN4ZTA5YzsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjc4IDcwMGM3IDIgMTMgNCAyMiA0YzU1IDAgMTAwIC00NSAxMDAgLTEwMHYtNHYtMjAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwdjIwMHYyYzAgNDQgMzUgODggNzggOTh6TTM0IDUwMGg0aDNjMyAwIDYgMSA5IDFjMjggMCA1MCAtMjIgNTAgLTUwdi0xdi01MGMwIC0xMTEgODkgLTIwMCAyMDAgLTIwMHMyMDAgODkgMjAwIDIwMHY1MGMwIDI4IDIyIDUwIDUwIDUwczUwIC0yMiA1MCAtNTB2LTUwCmMwIC0xNDggLTEwOSAtMjcwIC0yNTAgLTI5NHYtMTA2aDUwYzU1IDAgMTAwIC00NSAxMDAgLTEwMGgtNDAwYzAgNTUgNDUgMTAwIDEwMCAxMDBoNTB2MTA2Yy0xNDEgMjQgLTI1MCAxNDYgLTI1MCAyOTR2NTB2MmMwIDIwIDE1IDQyIDM0IDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5ZCIgdW5pY29kZT0iJiN4ZTA5ZDsiIApkPSJNMCA1MDBoODAwdi0yMDBoLTgwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjllIiB1bmljb2RlPSImI3hlMDllOyIgCmQ9Ik0zNCA3MDBoNGgzaDRoNWg3MDBjMjggMCA1MCAtMjIgNTAgLTUwdi01MDBjMCAtMjggLTIyIC01MCAtNTAgLTUwaC0yNTB2LTEwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaC02MDBjMCA1NSA0NSAxMDAgMTAwIDEwMGgxMDB2MTAwaC0yNTBjLTI4IDAgLTUwIDIyIC01MCA1MHY1MDB2MmMwIDIwIDE1IDQyIDM0IDQ4ek0xMDAgNjAwdi00MDBoNjAwdjQwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5ZiIgdW5pY29kZT0iJiN4ZTA5ZjsiIApkPSJNMjcyIDcwMGMtMTQgLTQwIC0yMiAtODMgLTIyIC0xMjhjMCAtMjIxIDE3OSAtNDAwIDQwMCAtNDAwYzQ1IDAgODggOCAxMjggMjJjLTUzIC0xNTggLTIwMiAtMjcyIC0zNzggLTI3MmMtMjIxIDAgLTQwMCAxNzkgLTQwMCA0MDBjMCAxNzYgMTE0IDMyNSAyNzIgMzc4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhMCIgdW5pY29kZT0iJiN4ZTBhMDsiIApkPSJNMzUwIDcwMGwxNTAgLTE1MGgtMTAwdi0xNTBoMTUwdjEwMGwxNTAgLTE1MGwtMTUwIC0xNTB2MTAwaC0xNTB2LTE1MGgxMDBsLTE1MCAtMTUwbC0xNTAgMTUwaDEwMHYxNTBoLTE1MHYtMTAwbC0xNTAgMTUwbDE1MCAxNTB2LTEwMGgxNTB2MTUwaC0xMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImExIiB1bmljb2RlPSImI3hlMGExOyIgCmQ9Ik04MDAgODAwdi01NTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBzNjcgMTUwIDE1MCAxNTBjMTcgMCAzNSAtNCA1MCAtOXYyMDZjLTIwMSAtNiAtMzI3IC0yNyAtNDAwIC01MHYtMzk3YzAgLTgzIC02NyAtMTUwIC0xNTAgLTE1MHMtMTUwIDY3IC0xNTAgMTUwczY3IDE1MCAxNTAgMTUwYzE3IDAgMzUgLTQgNTAgLTl2NDA5czEwMCAxMDAgNjAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYTIiIHVuaWNvZGU9IiYjeGUwYTI7IiBob3Jpei1hZHYteD0iNzAwIiAKZD0iTTQ5OSA3MDBjNTEgMCAxMDIgLTIwIDE0MSAtNTljNzggLTc4IDc4IC0yMDMgMCAtMjgxbC0yNTAgLTI0NGMtNDggLTQ4IC0xMjcgLTQ4IC0xNzUgMHMtNDggMTI3IDAgMTc1bDk2IDk3bDY5IC02OWwtOTAgLTk0bC03IC0zYy0xMCAtMTAgLTEwIC0yOCAwIC0zOHMyOCAtMTAgMzggMGwyNTAgMjQ3YzM3IDQwIDM5IDEwMiAwIDE0MXMtMTA0IDQwIC0xNDQgMGwtMjc4IC0yNzVjLTY2IC02OSAtNjggLTE3OSAwIC0yNDcKYzY5IC02OSAxODEgLTY5IDI1MCAwbDkgMTJsMTE2IDExM2w2OSAtNjlsLTEyNSAtMTI1Yy0xMDcgLTEwNyAtMjgxIC0xMDcgLTM4OCAwcy0xMDcgMjgxIDAgMzg4bDI3OCAyNzJjMzkgMzkgOTAgNTkgMTQxIDU5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhMyIgdW5pY29kZT0iJiN4ZTBhMzsiIApkPSJNNjAwIDgwMGwyMDAgLTIwMGwtMTAwIC0xMDBsLTIwMCAyMDB6TTQwMCA2MDBsMjAwIC0yMDBsLTQwMCAtNDAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNCIgdW5pY29kZT0iJiN4ZTBhNDsiIApkPSJNNTUwIDgwMGM4MyAwIDE1MCAtOTAgMTUwIC0yMDBzLTY3IC0yMDAgLTE1MCAtMjAwYy0yMiAwIC00MCA4IC01OSAxOWM2IDI2IDkgNTIgOSA4MWMwIDg0IC0yNyAxNTggLTcyIDIxMmMyNyA1MiA3MSA4OCAxMjIgODh6TTI1MCA3MDBjODMgMCAxNTAgLTkwIDE1MCAtMjAwcy02NyAtMjAwIC0xNTAgLTIwMHMtMTUwIDkwIC0xNTAgMjAwczY3IDIwMCAxNTAgMjAwek03MjUgMzg0YzQ0IC0yMiA3NSAtNjYgNzUgLTExOHYtMTY2aC0yMDB2NjYKYzAgNTAgLTE3IDk2IC00NCAxMzRjNjYgMiAxMjYgMzMgMTY5IDg0ek03NSAyODRjNDUgLTUzIDEwNiAtODQgMTc1IC04NHMxMzAgMzEgMTc1IDg0YzQ0IC0yMiA3NSAtNjYgNzUgLTExOHYtMTY2aC01MDB2MTY2YzAgNTIgMzEgOTYgNzUgMTE4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNSIgdW5pY29kZT0iJiN4ZTBhNTsiIApkPSJNNDAwIDgwMGMxMTAgMCAyMDAgLTExMiAyMDAgLTI1MHMtOTAgLTI1MCAtMjAwIC0yNTBzLTIwMCAxMTIgLTIwMCAyNTBzOTAgMjUwIDIwMCAyNTB6TTE5MSAzMDBjNTQgLTYxIDEyOCAtMTAwIDIwOSAtMTAwczE1NSAzOSAyMDkgMTAwYzEwNiAtNSAxOTEgLTkyIDE5MSAtMjAwdi0xMDBoLTgwMHYxMDBjMCAxMDggODUgMTk1IDE5MSAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImE2IiB1bmljb2RlPSImI3hlMGE2OyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0xOSA4MDBoNDYyYzExIDAgMTkgLTggMTkgLTE5di03NjJjMCAtMTEgLTggLTE5IC0xOSAtMTloLTQ2MmMtMTEgMCAtMTkgOCAtMTkgMTl2NzYyYzAgMTEgOCAxOSAxOSAxOXpNMTAwIDcwMHYtNTAwaDMwMHY1MDBoLTMwMHpNMjUwIDE1MGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNyIgdW5pY29kZT0iJiN4ZTBhNzsiIApkPSJNMzUwIDgwMGMxNyAwIDM0IC0xIDUwIC0zdi0zOTdsLTI5NyAyOTdjNjMgNjQgMTUwIDEwMyAyNDcgMTAzek01MDAgNjk0YzE2OSAtMjUgMzAwIC0xNjggMzAwIC0zNDRjMCAtMTkzIC0xNTcgLTM1MCAtMzUwIC0zNTBjLTg1IDAgLTE2MSAzMSAtMjIyIDgxbDI3MiAyNzJ2MzQxek05MSA1NjJsMjM3IC0yMzRsLTIxMiAtMjEyYy03MCA1NSAtMTE2IDEzOCAtMTE2IDIzNGMwIDg0IDM1IDE1OCA5MSAyMTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImE4IiB1bmljb2RlPSImI3hlMGE4OyIgCmQ9Ik05MiA2NTBjMCAyMyAyMCA1MCA0NiA1MGgzaDRoNWg0MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTB2LTIwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaC0zMDB2LTMwMGwtNTYgLTEwMGwtNDQgMTAwdjMwMGgtMzAwYzAgNTUgNDUgMTAwIDEwMCAxMDBoMTAwdjIwMGgtNTBjLTIgMCAtNiAtMSAtOCAtMWMtMjggMCAtNTAgMjMgLTUwIDUxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhOSIgdW5pY29kZT0iJiN4ZTBhOTsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNMzAwIDYwMHYtNDAwbDMwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFhIiB1bmljb2RlPSImI3hlMGFhOyIgCmQ9Ik0zMDAgODAwaDIwMHYtMzAwaDMwMHYtMjAwaC0zMDB2LTMwMGgtMjAwdjMwMGgtMzAwdjIwMGgzMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYiIgdW5pY29kZT0iJiN4ZTBhYjsiIApkPSJNMzAwIDgwMGgxMDB2LTQwMGgtMTAwdjQwMHpNMTcyIDY1Nmw2MiAtNzhsLTQwIC0zMWMtNTggLTQ2IC05NCAtMTE3IC05NCAtMTk3YzAgLTEzOSAxMTEgLTI1MCAyNTAgLTI1MHMyNTAgMTExIDI1MCAyNTBjMCA4MCAtMzkgMTUxIC05NyAxOTdsLTM3IDMxbDYyIDc4bDM4IC0zMWM4MiAtNjQgMTM0IC0xNjQgMTM0IC0yNzVjMCAtMTkzIC0xNTcgLTM1MCAtMzUwIC0zNTBzLTM1MCAxNTcgLTM1MCAzNTBjMCAxMTEgNTMgMjExIDEzNCAyNzV6CiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYyIgdW5pY29kZT0iJiN4ZTBhYzsiIApkPSJNMjAwIDgwMGg0MDB2LTIwMGgtNDAwdjIwMHpNOSA1MDBoNzgyYzYgMCA5IC0zIDkgLTl2LTI4MmMwIC02IC0zIC05IC05IC05aC05MXYyMDBoLTYwMHYtMjAwaC05MWMtNiAwIC05IDMgLTkgOXYyODJjMCA2IDMgOSA5IDl6TTIwMCAzMDBoNDAwdi0zMDBoLTQwMHYzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFkIiB1bmljb2RlPSImI3hlMGFkOyIgCmQ9Ik0wIDcwMGgxMDB2LTcwMGgtMTAwdjcwMHpNNzAwIDcwMGgxMDB2LTcwMGgtMTAwdjcwMHpNMjAwIDYwMGgyMDB2LTEwMGgtMjAwdjEwMHpNMzAwIDQwMGgyMDB2LTEwMGgtMjAwdjEwMHpNNDAwIDIwMGgyMDB2LTEwMGgtMjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWUiIHVuaWNvZGU9IiYjeGUwYWU7IiAKZD0iTTMyNSA3MDBjNDIgLTE0MSA4NyAtMjgwIDEzMSAtNDE5YzI5IDc0IDU5IDE0OCA4OCAyMjJjMzAgLTU3IDU4IC0xMTQgODcgLTE3MmgxNjl2LTEwMGgtMjMxbC0xMyAyOGMtMzcgLTkyIC03NCAtMTg0IC0xMTIgLTI3NWMtMzggMTI5IC03OSAyNTcgLTExOSAzODVjLTQyIC0xMzMgLTgzIC0yNjcgLTEyNSAtNDAwYy0yOCA4OCAtNTYgMTc1IC04NCAyNjJoLTExNnYxMDBoMTg4bDkgLTM0bDMgLTZjNDIgMTM3IDgzIDI3MyAxMjUgNDA5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhZiIgdW5pY29kZT0iJiN4ZTBhZjsiIApkPSJNMjAwIDYwMGMwIDU3IDQzIDEwMCAxMDAgMTAwczEwMCAtNDMgMTAwIC0xMDBjMCAtMjggLTE4IC00OCAtMjggLTcyYy0zIC02IC0zIC0xNiAtMyAtMjhoMjMxdi0yMzFjMTIgMCAyMiAwIDI4IDNjMjQgMTAgNDQgMjggNzIgMjhjNTcgMCAxMDAgLTQzIDEwMCAtMTAwcy00MyAtMTAwIC0xMDAgLTEwMGMtMjggMCAtNDggMTggLTcyIDI4Yy02IDMgLTE2IDMgLTI4IDN2LTIzMWgtMjMxYzAgMTIgMCAyMiAzIDI4YzEwIDI0IDI4IDQ0IDI4IDcyCmMwIDU3IC00MyAxMDAgLTEwMCAxMDBzLTEwMCAtNDMgLTEwMCAtMTAwYzAgLTI4IDE4IC00OCAyOCAtNzJjMyAtNiAzIC0xNiAzIC0yOGgtMjMxdjYwMGgyMzFjMCAxMiAwIDIyIC0zIDI4Yy0xMCAyNCAtMjggNDQgLTI4IDcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiMCIgdW5pY29kZT0iJiN4ZTBiMDsiIGhvcml6LWFkdi14PSI1MDAiIApkPSJNMjQ3IDcwMGM4NCAwIDE0OCAtMjAgMTkxIC01OXM1OSAtOTMgNTkgLTE0MWMwIC0xMTcgLTY5IC0xODEgLTExOSAtMjI1cy04MSAtNjcgLTgxIC0xNTB2LTI1aC0xMDB2MjVjMCAxMTcgNjUgMTgxIDExNSAyMjVzODUgNjcgODUgMTUwYzAgMjUgLTggNDggLTI4IDY2cy01NiAzNCAtMTIyIDM0cy05NyAtMTggLTExNiAtMzdzLTI3IC00MyAtMzEgLTY5bC0xMDAgMTJjNSAzOCAxOSA4OCA1OSAxMjhzMTAzIDY2IDE4OCA2NnpNMTk3IDBoMTAwCnYtMTAwaC0xMDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiMSIgdW5pY29kZT0iJiN4ZTBiMTsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtNjkgLTQ4IC0xMjcgLTExMiAtMTQ0Yy0yMiA1NSAtNzUgOTQgLTEzOCA5NGMtMjAgMCAtMzkgLTUgLTU2IC0xMmMtMTcgNjQgLTc1IDExMiAtMTQ0IDExMnMtMTI3IC00OCAtMTQ0IC0xMTJjLTE3IDcgLTM2IDEyIC01NiAxMmMtMzcgMCAtNzEgLTEyIC05NyAtMzRjLTMzIDM2IC01MyA4MiAtNTMgMTM0CmMwIDExMCA5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAwek0zMzQgMzAwaDRoM2MzIDAgNiAxIDkgMWMyOCAwIDUwIC0yMiA1MCAtNTB2LTF2LTIwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHYyMDB2MmMwIDIwIDE1IDQyIDM0IDQ4ek0xMzQgMjAwaDRoM2MzIDAgNiAxIDkgMWMyOCAwIDUwIC0yMiA1MCAtNTB2LTF2LTEwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHYxMDB2MgpjMCAyMCAxNSA0MiAzNCA0OHpNNTM0IDIwMGgzaDRjMyAwIDYgMSA5IDFjMjggMCA1MCAtMjIgNTAgLTUwdi0xdi0xMDBjMCAtMjggLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTB2MTAwdjJjMCAyMCAxNSA0MiAzNCA0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjIiIHVuaWNvZGU9IiYjeGUwYjI7IiAKZD0iTTYwMCA4MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNTBsLTE1MyAtMTkxbDE3NSAtMjA2bDYgLTNoMjJ2MTAwbDIwMCAtMTUwbC0yMDAgLTE1MHYxMDBoLTI1Yy0zNSAwIC01NiAxMiAtNzggMzhsLTE2NiAxOTBsLTE1MyAtMTkwYy0yMiAtMjcgLTQzIC0zOCAtNzggLTM4aC0xMDB2MTAwaDEwMGwxNjYgMjA2bC0xNjMgMTkxbC0zIDNoLTEwMHYxMDBoMTAwYzM0IDAgNTYgLTEyIDc4IC0zOGwxNTMgLTE3OGwxNDEgMTc4CmMyMiAyNyA0MyAzOCA3OCAzOGg1MHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImIzIiB1bmljb2RlPSImI3hlMGIzOyIgCmQ9Ik00MDAgODAwYzExMCAwIDIwOSAtNDcgMjgxIC0xMTlsMTE5IDExOXYtMzAwaC0zMDBsMTA5IDEwOWMtNTQgNTUgLTEyNiA5MSAtMjA5IDkxYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwYzgzIDAgMTU4IDM0IDIxMiA4OGw3MiAtNzJjLTcyIC03MiAtMTc0IC0xMTYgLTI4NCAtMTE2Yy0yMjAgMCAtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImI0IiB1bmljb2RlPSImI3hlMGI0OyIgCmQ9Ik00MDAgODAwaDQwMHYtNDAwbC0xNjYgMTY2bC00MDAgLTQwMGwxNjYgLTE2NmgtNDAwdjQwMGwxNjYgLTE2Nmw0MDAgNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiNSIgdW5pY29kZT0iJiN4ZTBiNTsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjUwIDgwMGwyNTAgLTMwMGgtMjAwdi0yMDBoMjAwbC0yNTAgLTMwMGwtMjUwIDMwMGgyMDB2MjAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImI2IiB1bmljb2RlPSImI3hlMGI2OyIgCmQ9Ik0zMDAgNjAwdi0yMDBoMjAwdjIwMGwzMDAgLTI1MGwtMzAwIC0yNTB2MjAwaC0yMDB2LTIwMGwtMzAwIDI1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjciIHVuaWNvZGU9IiYjeGUwYjc7IiAKZD0iTTAgODAwYzQ0MSAwIDgwMCAtMzU5IDgwMCAtODAwaC0yMDBjMCAzMzMgLTI2NyA2MDAgLTYwMCA2MDB2MjAwek0wIDUwMGMyNzUgMCA1MDAgLTIyNSA1MDAgLTUwMGgtMjAwYzAgMTY3IC0xMzMgMzAwIC0zMDAgMzAwdjIwMHpNMCAyMDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMGgtMjAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjgiIHVuaWNvZGU9IiYjeGUwYjg7IiAKZD0iTTEwMCA4MDBjMzg2IDAgNzAwIC0zMTQgNzAwIC03MDBoLTEwMGMwIDMzMiAtMjY4IDYwMCAtNjAwIDYwMHYxMDB6TTEwMCA2MDBjMjc2IDAgNTAwIC0yMjQgNTAwIC01MDBoLTEwMGMwIDIyMiAtMTc4IDQwMCAtNDAwIDQwMHYxMDB6TTEwMCA0MDBjMTY1IDAgMzAwIC0xMzUgMzAwIC0zMDBoLTEwMGMwIDExMSAtODkgMjAwIC0yMDAgMjAwdjEwMHpNMTAwIDIwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBzLTQ1IC0xMDAgLTEwMCAtMTAwCnMtMTAwIDQ1IC0xMDAgMTAwczQ1IDEwMCAxMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiOSIgdW5pY29kZT0iJiN4ZTBiOTsiIApkPSJNMzAwIDgwMGg0MDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwdi0yMDBoLTQwMHYxNTBjMCAyOCAtMjIgNTAgLTUwIDUwcy01MCAtMjIgLTUwIC01MHYtMjUwaDQwMHYtMzAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMGgtNTAwYy01NSAwIC0xMDAgNDUgLTEwMCAxMDB2MjAwaDEwMHYtMTUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2NTUwYzAgNTUgNDUgMTAwIDEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJhIiB1bmljb2RlPSImI3hlMGJhOyIgCmQ9Ik03NSA3MDBoMjI1di0xMDBoLTIwMHYtNTAwaDQwMHYxMDBoMTAwdi0xMjVjMCAtNDEgLTM0IC03NSAtNzUgLTc1aC00NTBjLTQxIDAgLTc1IDM0IC03NSA3NXY1NTBjMCA0MSAzNCA3NSA3NSA3NXpNNjAwIDcwMGwyMDAgLTIwMGwtMjAwIC0yMDB2MTAwaC0yMDBjLTk0IDAgLTE3MyAtNjUgLTE5NCAtMTUzYzIzIDE5OSAxODkgMzUzIDM5NCAzNTN2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiYiIgdW5pY29kZT0iJiN4ZTBiYjsiIApkPSJNNTAwIDcwMGwzMDAgLTI4NGwtMzAwIC0zMTZ2MjAwaC0xMDBjLTIwMCAwIC0zNDggLTEwMiAtNDAwIC0zMDBjMCAyOTUgMTAwIDUwMCA1MDAgNTAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmMiIHVuaWNvZGU9IiYjeGUwYmM7IiAKZD0iTTM4MSA3OTFsMTkgOWwxOSAtOWMxMjcgLTUzIDI1MyAtMTA4IDM4MSAtMTYwdi0zMWMwIC0xNjYgLTY3IC0zMTMgLTE0NyAtNDE5Yy00MCAtNTMgLTgzIC05NyAtMTI1IC0xMjhzLTgyIC01MyAtMTI4IC01M3MtODYgMjIgLTEyOCA1M3MtODUgNzUgLTEyNSAxMjhjLTgwIDEwNyAtMTQ3IDI1MyAtMTQ3IDQxOXYzMWMxMjggNTIgMjU0IDEwNyAzODEgMTYwek00MDAgMTAwdjU5MWwtMjk0IC0xMjJjOCAtMTI2IDU4IC0yNDMgMTIyIC0zMjgKYzM1IC00NiA3MyAtODYgMTA2IC0xMTBzNjIgLTMxIDY2IC0zMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmQiIHVuaWNvZGU9IiYjeGUwYmQ7IiAKZD0iTTYwMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTQwMCA3MDBoMTAwdi03MDBoLTEwMHY3MDB6TTIwMCA1MDBoMTAwdi01MDBoLTEwMHY1MDB6TTAgMzAwaDEwMHYtMzAwaC0xMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiZSIgdW5pY29kZT0iJiN4ZTBiZTsiIApkPSJNMzAwIDgwMGgxMDB2LTIwMGgyMDBsMTAwIC0xMDBsLTEwMCAtMTAwaC0yMDB2LTQwMGgtMTAwdjUwMGgtMjAwbC0xMDAgMTAwbDEwMCAxMDBoMjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmYiIHVuaWNvZGU9IiYjeGUwYmY7IiAKZD0iTTIwMCA4MDBoMTAwdi02MDBoMjAwbC0yNTAgLTIwMGwtMjUwIDIwMGgyMDB2NjAwek00MDAgODAwaDIwMHYtMTAwaC0yMDB2MTAwek00MDAgNjAwaDMwMHYtMTAwaC0zMDB2MTAwek00MDAgNDAwaDQwMHYtMTAwaC00MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjMCIgdW5pY29kZT0iJiN4ZTBjMDsiIApkPSJNMjAwIDgwMGgxMDB2LTYwMGgyMDBsLTI1MCAtMjAwbC0yNTAgMjAwaDIwMHY2MDB6TTQwMCA4MDBoNDAwdi0xMDBoLTQwMHYxMDB6TTQwMCA2MDBoMzAwdi0xMDBoLTMwMHYxMDB6TTQwMCA0MDBoMjAwdi0xMDBoLTIwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImMxIiB1bmljb2RlPSImI3hlMGMxOyIgCmQ9Ik03NSA3MDBoNjUwYzQxIDAgNzUgLTM0IDc1IC03NXYtNTUwYzAgLTQxIC0zNCAtNzUgLTc1IC03NWgtNjUwYy00MSAwIC03NSAzNCAtNzUgNzV2NTUwYzAgNDEgMzQgNzUgNzUgNzV6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA2MDB2LTEwMGg0MDB2MTAwaC00MDB6TTEwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA0MDB2LTEwMGg0MDB2MTAwaC00MDB6TTEwMCAyMDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCAyMDAKdi0xMDBoNDAwdjEwMGgtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjMiIgdW5pY29kZT0iJiN4ZTBjMjsiIApkPSJNNDAwIDgwMGwxMDAgLTMwMGgzMDBsLTI1MCAtMjAwbDEwMCAtMzAwbC0yNTAgMjAwbC0yNTAgLTIwMGwxMDAgMzAwbC0yNTAgMjAwaDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzMiIHVuaWNvZGU9IiYjeGUwYzM7IiAKZD0iTTQwMCA4MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0xNTAgNzAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHpNNjUwIDcwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTQwMCA2MDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMApzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDBzOTAgMjAwIDIwMCAyMDB6TTUwIDQ1MGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTc1MCA0NTBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0xNTAgMjAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MApzMjIgNTAgNTAgNTB6TTY1MCAyMDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek00MDAgMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzQiIHVuaWNvZGU9IiYjeGUwYzQ7IiAKZD0iTTM0IDgwMGg2MzJjMTggMCAzNCAtMTYgMzQgLTM0di03MzJjMCAtMTggLTE2IC0zNCAtMzQgLTM0aC02MzJjLTE4IDAgLTM0IDE2IC0zNCAzNHY3MzJjMCAxOCAxNiAzNCAzNCAzNHpNMTAwIDcwMHYtNTAwaDUwMHY1MDBoLTUwMHpNMzUwIDE1MGMtMzggMCAtNjMgLTQyIC00NCAtNzVzNjkgLTMzIDg4IDBzLTYgNzUgLTQ0IDc1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjNSIgdW5pY29kZT0iJiN4ZTBjNTsiIApkPSJNMCA4MDBoMzAwbDUwMCAtNTAwbC0zMDAgLTMwMGwtNTAwIDUwMHYzMDB6TTIwMCA3MDBjLTU1IDAgLTEwMCAtNDUgLTEwMCAtMTAwczQ1IC0xMDAgMTAwIC0xMDBzMTAwIDQ1IDEwMCAxMDBzLTQ1IDEwMCAtMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzYiIHVuaWNvZGU9IiYjeGUwYzY7IiAKZD0iTTAgNjAwaDIwMGwzMDAgLTMwMGwtMjAwIC0yMDBsLTMwMCAzMDB2MjAwek0zNDAgNjAwaDE2MGwzMDAgLTMwMGwtMjAwIC0yMDBsLTc4IDc4bDExOSAxMjJ6TTE1MCA1MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzciIHVuaWNvZGU9IiYjeGUwYzc7IiAKZD0iTTQwMCA4MDBjMjIwIDAgNDAwIC0xODAgNDAwIC00MDBzLTE4MCAtNDAwIC00MDAgLTQwMHMtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6TTQwMCA3MDBjLTE2NiAwIC0zMDAgLTEzNCAtMzAwIC0zMDBzMTM0IC0zMDAgMzAwIC0zMDBzMzAwIDEzNCAzMDAgMzAwcy0xMzQgMzAwIC0zMDAgMzAwek00MDAgNjAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDAKczkwIDIwMCAyMDAgMjAwek00MDAgNTAwYy01NiAwIC0xMDAgLTQ0IC0xMDAgLTEwMHM0NCAtMTAwIDEwMCAtMTAwczEwMCA0NCAxMDAgMTAwcy00NCAxMDAgLTEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImM4IiB1bmljb2RlPSImI3hlMGM4OyIgCmQ9Ik0wIDcwMGg1NTlsLTEwMCAtMTAwaC0zNTl2LTUwMGg1MDB2MTU5bDEwMCAxMDB2LTM1OWgtNzAwdjcwMHpNNzAwIDcwMGwxMDAgLTEwMGwtNDAwIC00MDBsLTIwMCAyMDBsMTAwIDEwMGwxMDAgLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzkiIHVuaWNvZGU9IiYjeGUwYzk7IiAKZD0iTTkgODAwaDc4MmM2IDAgOSAtMyA5IC05di03ODJjMCAtNiAtMyAtOSAtOSAtOWgtNzgyYy02IDAgLTkgMyAtOSA5djc4MmMwIDYgMyA5IDkgOXpNMTUwIDcyMmwtNzIgLTcybDEwMCAtMTAwbC0xMDAgLTEwMGw3MiAtNzJsMTcyIDE3MnpNNDAwIDUwMHYtMTAwaDMwMHYxMDBoLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2EiIHVuaWNvZGU9IiYjeGUwY2E7IiAKZD0iTTAgODAwaDgwMHYtMjAwaC01MGMwIDU1IC00NSAxMDAgLTEwMCAxMDBoLTE1MHYtNTUwYzAgLTI4IDIyIC01MCA1MCAtNTBoNTB2LTEwMGgtNDAwdjEwMGg1MGMyOCAwIDUwIDIyIDUwIDUwdjU1MGgtMTUwYy01NSAwIC0xMDAgLTQ1IC0xMDAgLTEwMGgtNTB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYiIgdW5pY29kZT0iJiN4ZTBjYjsiIApkPSJNMCA3MDBoMTAwdi00MDBoLTEwMHY0MDB6TTIwMCA3MDBoMzUwYzIxIDAgMzkgLTEzIDQ3IC0zMWMwIDAgMTAzIC0yOTEgMTAzIC0zMTlzLTIyIC01MCAtNTAgLTUwaC0xNTBjLTI4IDAgLTUwIC0yNSAtNTAgLTUwczM5IC0xNTggNDcgLTE4NHMtNSAtNTUgLTMxIC02M3MtNTIgNSAtNjYgMzFzLTEwOSAyMTkgLTEyOCAyMzhzLTQ0IDI4IC03MiAyOHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNjIiB1bmljb2RlPSImI3hlMGNjOyIgCmQ9Ik00MDAgNjY2YzEwIDE5IDI4IDMyIDQ3IDM0bDE5IC0zYzI2IC04IDM5IC0zNyAzMSAtNjNzLTQ3IC0xNTkgLTQ3IC0xODRzMjIgLTUwIDUwIC01MGgxNTBjMjggMCA1MCAtMjIgNTAgLTUwcy0xMDMgLTMxOSAtMTAzIC0zMTljLTggLTE4IC0yNiAtMzEgLTQ3IC0zMWgtMzUwdjQwMGMyOCAwIDUzIDkgNzIgMjhzMTE0IDIxMiAxMjggMjM4ek0wIDQwMGgxMDB2LTQwMGgtMTAwdjQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2QiIHVuaWNvZGU9IiYjeGUwY2Q7IiAKZD0iTTIwMCA3MDBoMzAwdi0xMDBoLTEwMHYtNmMyNSAtNCA1MCAtOCA3MiAtMTZsLTM0IC05NGMtMjggMTEgLTU4IDE2IC04OCAxNmMtMTM5IDAgLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MHMyNTAgMTExIDI1MCAyNTBjMCAzMSAtNSA2MCAtMTYgODhsOTEgMzdjMTQgLTM4IDI1IC04MSAyNSAtMTI1YzAgLTE5MyAtMTU3IC0zNTAgLTM1MCAtMzUwcy0zNTAgMTU3IC0zNTAgMzUwYzAgMTc2IDEzMCAzMjMgMzAwIDM0N3YzCmgtMTAwdjEwMHpNNzAwIDU4NGMwIDAgLTI5NiAtMzQ4IC0zMTYgLTM2OHMtNDggLTIwIC02OCAwcy0yMCA0OCAwIDY4czM4NCAzMDAgMzg0IDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2UiIHVuaWNvZGU9IiYjeGUwY2U7IiAKZD0iTTYwMCA3MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNjAwdjEwMGg2MDB2MTAwek0yMDAgMzAwdi0xMDBoNjAwdi0xMDBoLTYwMHYtMTAwbC0yMDAgMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjZiIgdW5pY29kZT0iJiN4ZTBjZjsiIApkPSJNMzAwIDgwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaDEwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBoLTcwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwaDEwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwek0xMDAgNTAwaDEwMHYtMzUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MzUwaDEwMHYtMzUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MzUwaDEwMHYtNDgxYzAgLTExIC04IC0xOSAtMTkgLTE5aC00NjIKYy0xMSAwIC0xOSA4IC0xOSAxOXY0ODF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQwIiB1bmljb2RlPSImI3hlMGQwOyIgCmQ9Ik0xMDAgODAwaDIwMHYtNDAwYzAgLTU1IDQ1IC0xMDAgMTAwIC0xMDBzMTAwIDQ1IDEwMCAxMDB2NDAwaDEwMHYtNDAwYzAgLTExMCAtOTAgLTIwMCAtMjAwIC0yMDBoLTUwYy0xMzggMCAtMjUwIDkwIC0yNTAgMjAwdjQwMHpNMCAxMDBoNzAwdi0xMDBoLTcwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQxIiB1bmljb2RlPSImI3hlMGQxOyIgCmQ9Ik05IDcwMGgxODJjNiAwIDkgLTMgOSAtOXYtNDgyYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXY0ODJjMCA2IDMgOSA5IDl6TTYwOSA3MDBoMTgyYzYgMCA5IC0zIDkgLTl2LTQ4MmMwIC02IC0zIC05IC05IC05aC0xODJjLTYgMCAtOSAzIC05IDl2NDgyYzAgNiAzIDkgOSA5ek0zMDkgNTAwaDE4MmM2IDAgOSAtMyA5IC05di0yODJjMCAtNiAtMyAtOSAtOSAtOWgtMTgyYy02IDAgLTkgMyAtOSA5djI4MgpjMCA2IDMgOSA5IDl6TTAgMTAwaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkMiIgdW5pY29kZT0iJiN4ZTBkMjsiIApkPSJNMTAgNzAwaDE4MWM2IDAgOSAtMyA5IC05di0xOTFoLTIwMHYxOTFjMCA2IDQgOSAxMCA5ek02MTAgNzAwaDE4MWM2IDAgOSAtMyA5IC05di0xOTFoLTIwMHYxOTFjMCA2IDUgOSAxMCA5ek0zMTAgNjAwaDE4MWM2IDAgOSAtMyA5IC05di05MWgtMjAwdjkxYzAgNiA0IDkgMTAgOXpNMCA0MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMjAwaDIwMHYtMTkxYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXYxOTF6TTMwMCAyMDAKaDIwMHYtOTFjMCAtNiAtMyAtOSAtOSAtOWgtMTgxYy02IDAgLTEwIDMgLTEwIDl2OTF6TTYwMCAyMDBoMjAwdi0xOTFjMCAtNiAtMyAtOSAtOSAtOWgtMTgxYy02IDAgLTEwIDMgLTEwIDl2MTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkMyIgdW5pY29kZT0iJiN4ZTBkMzsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTkgNTAwaDE4MmM2IDAgOSAtMyA5IC05di00ODJjMCAtNiAtMyAtOSAtOSAtOWgtMTgyYy02IDAgLTkgMyAtOSA5djQ4MmMwIDYgMyA5IDkgOXpNMzA5IDUwMGgxODJjNiAwIDkgLTMgOSAtOXYtMjgyYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXYyODJjMCA2IDMgOSA5IDl6TTYwOSA1MDBoMTgyYzYgMCA5IC0zIDkgLTl2LTQ4MmMwIC02IC0zIC05IC05IC05aC0xODIKYy02IDAgLTkgMyAtOSA5djQ4MmMwIDYgMyA5IDkgOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDQiIHVuaWNvZGU9IiYjeGUwZDQ7IiAKZD0iTTUwIDYwMGg1MDBjMjggMCA1MCAtMjIgNTAgLTUwdi0xNTBsMTAwIDEwMGgxMDB2LTMwMGgtMTAwbC0xMDAgMTAwdi0xNTBjMCAtMjggLTIyIC01MCAtNTAgLTUwaC01MDBjLTI4IDAgLTUwIDIyIC01MCA1MHY0MDBjMCAyOCAyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDUiIHVuaWNvZGU9IiYjeGUwZDU7IiAKZD0iTTMzNCA4MDBoNjZ2LTgwMGgtNjZsLTEzNCAyMDBoLTIwMHY0MDBoMjAwek01MDAgNjAwdjEwMGMyNiAwIDUyIC00IDc1IC0xMGMxMzAgLTMzIDIyNSAtMTUwIDIyNSAtMjkwcy05NSAtMjU4IC0yMjUgLTI5MWgtM2MtMjMgLTYgLTQ3IC05IC03MiAtOXYxMDBjMTcgMCAzNCAyIDUwIDZjODYgMjIgMTUwIDEwMCAxNTAgMTk0cy02NCAxNzIgLTE1MCAxOTRjLTE2IDQgLTMzIDYgLTUwIDZ6TTUwMCA1MDBsMjUgLTMKYzQ0IC0xMSA3NSAtNTEgNzUgLTk3cy0zMiAtODYgLTc1IC05N2wtMjUgLTN2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkNiIgdW5pY29kZT0iJiN4ZTBkNjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzM0IDgwMGg2NnYtODAwaC02NmwtMTM0IDIwMGgtMjAwdjQwMGgyMDB6TTUwMCA1MDBsMjUgLTNjNDQgLTExIDc1IC01MSA3NSAtOTdzLTMyIC04NiAtNzUgLTk3bC0yNSAtM3YyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQ3IiB1bmljb2RlPSImI3hlMGQ3OyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0zMzQgODAwaDY2di04MDBoLTY2bC0xMzQgMjAwaC0yMDB2NDAwaDIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDgiIHVuaWNvZGU9IiYjeGUwZDg7IiAKZD0iTTMwOSA4MDBoODJjNiAwIDEwIC00IDEyIC05bDI5NCAtNjgybDMgLTE5di04MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2ODFsMyAxOWwyOTQgNjgyYzIgNSA2IDkgMTIgOXpNMzAwIDUwMHYtMjAwaDEwMHYyMDBoLTEwMHpNMzAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDkiIHVuaWNvZGU9IiYjeGUwZDk7IiAKZD0iTTM3NSA4MDBjMTM4IDAgMjY5IC0zOSAzNzggLTEwOWwtNTMgLTgyYy05MyA2MCAtMjA1IDkxIC0zMjUgOTFjLTExOSAwIC0yMjkgLTMyIC0zMjIgLTkxbC01MyA4MmMxMDkgNzAgMjM3IDEwOSAzNzUgMTA5ek0zNzUgNTAwYzc4IDAgMTU0IC0yMyAyMTYgLTYybC01MyAtODVjLTQ2IDMwIC0xMDQgNDcgLTE2MyA0N2MtNjAgMCAtMTEyIC0xNyAtMTU5IC00N2wtNTQgODVjNjIgNDAgMTM0IDYyIDIxMyA2MnpNMzc1IDIwMApjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwcy00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwczQ1IDEwMCAxMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYSIgdW5pY29kZT0iJiN4ZTBkYTsiIGhvcml6LWFkdi14PSI5MDAiIApkPSJNNTUxIDgwMGMxNiAwIDMyIDAgNDcgLTNsLTk3IC05N3YtMjAwaDIwMGw5NyA5N2MzIC0xNSAzIC0zMSAzIC00N2MwIC0xMzggLTExMiAtMjUwIC0yNTAgLTI1MGMtMzIgMCAtNjIgOCAtOTAgMTlsLTI4OCAtMjkxYy0yMCAtMjAgLTQ2IC0yOCAtNzIgLTI4cy01MiA4IC03MiAyOGMtMzkgMzkgLTM5IDEwNSAwIDE0NGwyOTEgMjg3Yy0xMSAyOCAtMTkgNTkgLTE5IDkxYzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNMTAxIDE1MApjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGIiIHVuaWNvZGU9IiYjeGUwZGI7IiAKZD0iTTE0MSA3MDBjODQgLTg0IDE2OSAtMTY3IDI1MyAtMjUwYzgyIDgzIDE2NyAxNjUgMjQ3IDI1MGwxNDMgLTE0MWwtMjUzIC0yNTNjODQgLTgyIDE2NyAtMTY2IDI1MyAtMjQ3bC0xNDMgLTE0M2MtODEgODYgLTE2NSAxNjkgLTI0NyAyNTNsLTI1MyAtMjUzbC0xNDEgMTQzYzg1IDgwIDE2NyAxNjQgMjUwIDI0N2MtODMgODQgLTE2NiAxNjkgLTI1MCAyNTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRjIiB1bmljb2RlPSImI3hlMGRjOyIgCmQ9Ik0wIDgwMGgxMDBsMjMxIC0zMDBoMzhsMjMxIDMwMGgxMDBsLTIyNSAtMzAwaDIyNXYtMTAwaC0zMDB2LTEwMGgzMDB2LTEwMGgtMzAwdi0yMDBoLTEwMHYyMDBoLTMwMHYxMDBoMzAwdjEwMGgtMzAwdjEwMGgyMjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRkIiB1bmljb2RlPSImI3hlMGRkOyIgaG9yaXotYWR2LXg9IjkwMCIgCmQ9Ik0zNTAgODAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgLTYxIC0xNyAtMTE5IC00NCAtMTY5YzQgLTIgMTAgLTYgMTMgLTlsMTAzIC0xMDBjMTYgLTE2IDMwIC00OSAzMCAtNzJjMCAtNTYgLTQ2IC0xMDIgLTEwMiAtMTAyYy0yMyAwIC01NiAxNCAtNzIgMzBsLTEwMCAxMDNjLTMgMyAtNyA5IC05IDEzYy01MCAtMjggLTEwOCAtNDQgLTE2OSAtNDRjLTE5MyAwIC0zNTAgMTU3IC0zNTAgMzUwczE1NyAzNTAgMzUwIDM1MHpNMzUwIDcwMApjLTEzOSAwIC0yNTAgLTExMSAtMjUwIC0yNTBzMTExIC0yNTAgMjUwIC0yNTBjNjIgMCAxMTkgMjMgMTYzIDYwYzcgMTEgMTkgMjUgMzEgMzFsMyAzYzM0IDQzIDUzIDk3IDUzIDE1NmMwIDEzOSAtMTExIDI1MCAtMjUwIDI1MHpNMzAwIDYwMGgxMDB2LTEwMGgxMDB2LTEwMGgtMTAwdi0xMDBoLTEwMHYxMDBoLTEwMHYxMDBoMTAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGUiIHVuaWNvZGU9IiYjeGUwZGU7IiBob3Jpei1hZHYteD0iOTAwIiAKZD0iTTM1MCA4MDBjMTkzIDAgMzUwIC0xNTcgMzUwIC0zNTBjMCAtNjEgLTE3IC0xMTkgLTQ0IC0xNjljNCAtMiAxMCAtNiAxMyAtOWwxMDMgLTEwMGMxNiAtMTYgMzAgLTQ5IDMwIC03MmMwIC01NiAtNDYgLTEwMiAtMTAyIC0xMDJjLTIzIDAgLTU2IDE0IC03MiAzMGwtMTAwIDEwM2MtMyAzIC03IDkgLTkgMTNjLTUwIC0yOCAtMTA4IC00NCAtMTY5IC00NGMtMTkzIDAgLTM1MCAxNTcgLTM1MCAzNTBzMTU3IDM1MCAzNTAgMzUwek0zNTAgNzAwCmMtMTM5IDAgLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MGM2MiAwIDExOSAyMyAxNjMgNjBjNyAxMSAxOSAyNSAzMSAzMWwzIDNjMzQgNDMgNTMgOTcgNTMgMTU2YzAgMTM5IC0xMTEgMjUwIC0yNTAgMjUwek0yMDAgNTAwaDMwMHYtMTAwaC0zMDB2MTAweiIgLz4KICA8L2ZvbnQ+CjwvZGVmcz48L3N2Zz4K"

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.ttf":
/***/ (function(module, exports) {

module.exports = "data:application/x-font-ttf;base64,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AEoALgAgAE8AbgBvAHIAaQAgAHcAaQB0AGgAIABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAKABoAHQAdABwADoALwAvAGYAbwBuAHQAZgBvAHIAZwBlAC4AcwBmAC4AbgBlAHQAKQAAQ3JlYXRlZCBieSBQLkouIE9ub3JpIHdpdGggRm9udEZvcmdlIDIuMCAoaHR0cDovL2ZvbnRmb3JnZS5zZi5uZXQpAABJAGMAbwBuAHMAAEljb25zAABpAGMAbwBuAGkAYwAAaWNvbmljAABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAFUAbgB0AGkAdABsAGUAZAAxACAAOgAgADEALQA3AC0AMgAwADEANAAARm9udEZvcmdlIDIuMCA6IFVudGl0bGVkMSA6IDEtNy0yMDE0AABVAG4AdABpAHQAbABlAGQAMQAAVW50aXRsZWQxAABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAxACAAAFZlcnNpb24gMS4xLjEgAABvAHAAZQBuAC0AaQBjAG8AbgBpAGMAAG9wZW4taWNvbmljAAACAAAAAAAA/4MAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAOIAAAABAAIBAgEDAQQBBQEGAQcBCAEJAQoBCwBEAEUARgBHAEgASQEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakAoAGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHO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UlggPFkusSsBFCstsDwsIyAuRrACJUZQWCA8WS6xKwEUKy2wPSwjIC5GsAIlRlJYIDxZIyAuRrACJUZQWCA8WS6xKwEUKy2wPiywNSsjIC5GsAIlRlJYIDxZLrErARQrLbA/LLA2K4ogIDywBCNCijgjIC5GsAIlRlJYIDxZLrErARQrsARDLrArKy2wQCywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixKwEUKy2wQSyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbErARQrLbBCLLA1Ky6xKwEUKy2wQyywNishIyAgPLAEI0IjOLErARQrsARDLrArKy2wRCywABUgR7AAI0KyAAEBFRQTLrAxKi2wRSywABUgR7AAI0KyAAEBFRQTLrAxKi2wRiyxAAEUE7AyKi2wRyywNCotsEgssAAWRSMgLiBGiiNhOLErARQrLbBJLLAII0KwSCstsEossgAAQSstsEsssgABQSstsEwssgEAQSstsE0ssgEBQSstsE4ssgAAQistsE8ssgABQistsFAssgEAQistsFEssgEBQistsFIssgAAPistsFMssgABPistsFQssgEAPistsFUssgEBPistsFYssgAAQCstsFcssgABQCstsFgssgEAQCstsFkssgEBQCstsFossgAAQystsFsssgABQystsFwssgEAQystsF0ssgEBQystsF4ssgAAPystsF8ssgABPystsGAssgEAPystsGEssgEBPystsGIssDcrLrErARQrLbBjLLA3K7A7Ky2wZCywNyuwPCstsGUssAAWsDcrsD0rLbBmLLA4Ky6xKwEUKy2wZyywOCuwOystsGgssDgrsDwrLbBpLLA4K7A9Ky2waiywOSsusSsBFCstsGsssDkrsDsrLbBsLLA5K7A8Ky2wbSywOSuwPSstsG4ssDorLrErARQrLbBvLLA6K7A7Ky2wcCywOiuwPCstsHEssDorsD0rLbByLLMJBAIDRVghGyMhWUIrsAhlsAMkUHiwARUwLQBLuADIUlixAQGOWbABuQgACABjcLEABUKxAAAqsQAFQrEACCqxAAVCsQAIKrEABUK5AAAACSqxAAVCuQAAAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWbEADCq4Af+FsASNsQIARAA="

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.woff":
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,d09GRgABAAAAADqIAA8AAAAAbXwAARmZAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABWAAAABoAAAAca/ABpE9TLzIAAAF0AAAARgAAAGA0BlFiY21hcAAAAbwAAABCAAABQgAP5IljdnQgAAACAAAAAAoAAAAKAAAAAGZwZ20AAAIMAAAFkgAAC2y+b+Y5Z2FzcAAAB6AAAAAIAAAACAAAABBnbHlmAAAHqAAAK4MAAFIYSOXurmhlYWQAADMsAAAAMAAAADYB87tFaGhlYQAAM1wAAAAeAAAAJAaMBAFobXR4AAAzfAAAAGMAAAOGmp4AGmxvY2EAADPgAAABxgAAAcajuo9EbWF4cAAANagAAAAeAAAAIAGcC9ZuYW1lAAA1yAAAAWkAAAJ8jvYQxXBvc3QAADc0AAAC7AAABGPtEDP+cHJlcAAAOiAAAABlAAAAe91rA4V4nGNgYGBkAIIztovOg+jzN/WzYDQATPUG/gAAeJxjYGH6xziBgZWBgYmDyYCBgaEAQjM2MKgznAeKMrAyM8CBAILJEJDmmsJw4AHDg3vMCkCuB5BMBdKMSEoUGBgB9SQJ5gAAeJxjYGBgZoBgGQZGBhCwAfIYwXwWBgUgzQKEQP6De///A0mG//8VmKEqGRjZGGBMBkYmIMHEgAoYGYY9AAAbeQd5AAAAAAAAAAAAAAAAAAB4nK1WaXPURhAd7eETH8EHCUpgxHgdsxot5jIGFmOkXS/gHOsrkSCH5F0798UnfoN+TWtJqsg3flpezx7YYCdVVChq+03raab7dU/LJLQksRfWIyk3X4rJrU0a2nkS0g2blqL4UKZ7IeVKyd8jYkS0WmrfdhwSEYlA1TrCEkHse2RpkvGhRzkt25JeNamw+KSzZI0F9VZ9+2noKMdOQ0nNZujQemRLWmW0GkUy65KSNi3B1VtJWubny8x81QwlgkgTSWPNMIZH8rMxRiuMVmI7jqLIJsuNIkWiGR5EkUd5LbFPoZQgoGLQDKmofBpSPsKPyIo9KmiFuGQ7K+77kp90D6exgERcp3zZgTeQqUyxc7ZcLKVbYdy0k+0oVBGere+EeGBzQr1TPSpqGg7cjsh1ZRnCUvkK8io/odz+IVktnE3FskfDWnKA40HrZUHsS96B1uOIKXHNBDiiO8PjIqj7ZWcg9Kg+LvxYdxfLRQgBso1lPVUJF8GoJGxWkqSNIPtRUr6kklr3iPFTXqcFvCXs16kdfemMNgl1xsfy9dCxlROVHY8mdJbL1amd1Dya1CBKSWeCx/w6gPIjmuDVNlYTWHk0hW2mjSQSCrRwLk0GsUxjSZMQzaNpvbkbZoV2LVqgiQP13KP39OZWuLnTddoO/DPGf1ZnYirYC7OpqYCsxKcplxsUbetnZ/hnAj9kzaMS+VIzzFg8ZOunKC4fW3YUXutju/ucX0HfsydCJg3E34D3eKlOKWAmxIyCWmiltY5lWaZWM1pkIlffDWlK+bJO42jIMegb+zLG8X9NT1tiUvh+Gmdnh1x65tqXINMscptxPZrTmcV2HjqzPaezPNv3dVZg+4HOimzP62yIra2zYbYf6myE7Uc6G2V7QQuacN8hkIsI5AI2kAiErYNA2F5CIGwVAmG7gEDYlhAI20UEwvZjBMJ2CYGwvaxl1fRTWePY6VgGKEIcGM1xRy5zU7mayi6VcV00OrUhT5FbJauK59S/MtAvHnmDGljzpMtkzS2b5CpHVTn+6IqWN02cy+BY9bc3x/U58VD2i/k/Bf+rranV7Io1h0yuIm8EenKc6Npk1aNrunKu6tH1/6Kiw1qg30ApxHxJVmSDbyYkfJSmDdXAVQ4xrzHvcF2vW9bcLM6/iREyj+7Hf0Oh0cA9SCtKymqKvVZeP5aV7h5UwJ5gSYr5Mq9vhS9yMi/tF7nF/PnI5wE3gkGpDFtt4GoFb96TmIdMd4rngritKB8kbTzOBYkNHPOAefOdBCHhQ6I2UDuFEzaQF4w5BfudcIjqjrICbi+0L6KRim/tih05o5IJAr/N7gh7fRZKfos1kPAUF3saqCqkWTVuGsGlkXJDNfgwrtZtIxkn0FNU7IYVWcVHjyPuOSXH0pd8qITVo6Of1W6hTurcXmUUt++dXgRBvzQxf3ffTLFfyrtayQqrtoGpW40qmWvN4uJVB+7mUfe94+wTOWuabronbnpf04qb4mBuFkT7NgdlqZAL6vqgw/rqcnMptHoFl6S73QMMCwzod2jFxv/VfRw+z5Wqwug4Um8n6sXosxj9/APO31E9AXp5DFKuIeW57uXEpxv3cKZCV3EX66f4NzBrrdkZugbc0HQD5iGrVoeucgPfqb5OjzS3Iz0EfKw7QjwA2ASwGHyiO5bxfApgPJ8xxwf4nDkMmsxhsMUcBtvMWQPYYQ6DXeYw2GMOgy+Ysw7wJXMYhMxhEDGHwRPmBABPmcPgK+Yw+Jo5DL5hzn2Ab5nDIGYOg4Q5DPY13RrI3OIF3QVqG1QFOjD9hMU9LA41rQ7Y3/HCsL83iNk/GMTUHzXdHlB/4oWh/mwQU38xiKm/arozoP7GC0P93SCm/mEQU5/pF6OFXP8vI9+lkQPKLzSf8/fE+wckfEABAAAAAQAB//8AD3icnXwLlBvllWb9VZJKpferVP3QW91Sq1vudkstqd2y1bbBuLHBj8Y2AkMnkEpsTIAOD5sYOyFhlmSy49C0s5owySaMAz5M4Gw8TEwybC+eYYahzuaYJXN8Jrs+CwMzOckek8ck450kPnSx9/5/lVRqmw2M3VK9//of97/3u/d+vzie6+M47me8zAmcyDlPO2yE41eNlIPlYL4czPb9/fe/8Q1eXn6nj7zN8XAnJ6T4JbjTB/e6nDzeS9LBdAU+SSJWYIcUyUXdQxb0eVXT9HmywC8tX62Si2qrpaqXleHtLkOU0/A/bykDvzSzCPjX4jgCRai0DD/n+AsHR1aNhFLROCmL+XJlIpdxyBNnSeYsvF5dfH2RXzr7eEnTSvsXF/c/vuJZNz7LpaIyPmUWQMbhYXgQn8eH8UEs4HGsuq1df+wvN5TiXe/yeVxOh43nbKtGglB/BT6isRVS776l8s3lZ9T2Hr+ksn8ftDzrfywFCzG31sL+PXXTsBCtvddVNzvHvfdNWp4dSgtyUa6f86/39CvhUMDjdAicHQaupIiDVVGx5yoTg1E5ImYHw6Mkb0/7iEgWPnn7Vv2lW06d0f+7gz81Hzivn5if++NhspXcP/6t2/ml+tsXSvNfenNg4Jk7H/jGwPqK/nTw0J7YDXdIbIw5clFIcQ4YJxuOUxiE0k3Kmqr9ZhlqrHv0c6SItxkyBfcymXI7bShTIBMBRyoXGAxmJZINXiDXXbigf/cCKWogXkUoAY/g7KP6OSzpymW5VpQlEZTxdlkL7En9XHdpmnalsrwryqIjSlaW1SlJ0zRaqd/XPoKztWwtB55c2TyuM2+atE/t2KeE1mGQzTf9HN/E3uUuu5en93pp28lFbC/Mzot8EwZCNcaKb64cKwnGCjTAj/QfWkarM/9W1IG067CE7S5wK++ldZD4FVVYouVrK+og0Hth0OE/KZAx2h/sCW6lbNF7+9m92J7OnXQ+8Utw35XnE/R7VoAPoR85SxZUVVNV3MB8pxMeFNcz0Kx5kDc2PzO0T12czCW5ApY3kIpFA24HlhdWHHJEEUcJm0oOMV+tTOTt7Kw5v+i5+2eazZnaOv65+9fVYFf/5qZYbFOd7K7XYYdvzjQ/fRSuf2X26fvvf3r2K3DL0U83r56JFYqxmfru2an6zt31mVixEDNkiyxQ2fJbZLQUjTgyuYlwtFyqBfPiwacOwp9aHV1Vw4bRQ/0/hcP6X4OqECzy6ecUzvW9UADLESwymsFGkJxCoEBowTtkyzvv6C+8QxaOnJok39p2XL91221HTgkpPAkXv3DqyG3byLcmj+q3TsIuZ76D6iKJ88I76DjgO0D4QYCIMRCgst99i1wEwYNZgN0PJ2A0QV5M/Qj1VMDq5bgS9v+qfLq/t8dDcDyrSoJXYCCDEUc2nclVgtlKOVxVxLQNrUMkWqquIxMDln1yLBgkn3zQ87Aa8S3/zBdRH77g61kgKf2Xw/H4cJz46UZIER/53Jf9qr7oi0R85G6V9AY/85wWl1U53v1Fx8O0T2EYj2BAwvEIp0txFDE5AhWrBCeUYDoo8d+WVFVa3iOpOBFcL2lnJIm/RlLR6HLcSjsp0Xm5opxOGZYCDN313tfpszluDOpRzEd5rMdEtS6kUThg2oYUqvBZX03UquFKNuPIZnL2rCw6xPQYuaUvLNjt5CK2rfTlnkxBGFmjc43ZTM+XS8RB5Dj5quaYniQvH3LwXwqloKuO6f86VCs3CoXZRrk2RLzHSCJ+wvXQHT92delBL+sbn4h9w5WgGlCVNFShMhEuo+CSxlMHH9347lsbH1W1+mwdJHb2a/fUtm+v3fO12eUXC/U6LYo2NEfLC0CJILdBv8+OMhUu28GmZStivpavKTW5Jsq1VonMvf22fqK0dWurtXUr4JmWkLp0/IlLl4wTGiIGjrPMB5mLc4NQbjKhRN1UVtNYWTFBZBSxCkyF4EQum5ZhUsBWCLItuTh7sLhh++L+5fNQ1QIpqrhRW41ms4FNuaaWfHDL/kUVLi0U6thA1PHNI02rbrObuo0EywTmRhFnhKHbioa+RN3WD/eFmGwEawrUICoH0xlHJFqGWYWToNYgNRXqoJbk+PJ5HEs+t3y+0RQcI3EsDzReMS4vn4fhU5sNPheOjziMeqBesZm6G0Q2D5hAY2hDs46nQHWP20axoAF5yoAHqZTi7aT4A1KQ3v21JKRUdd++5T+XJGs/K9CKPPRzNtbbQ/uZQDNA0EHY2VSGuVoHtVpVoFhQQelSjc0A6JVC/YwE1b9ajktn6gVN9/T08Ut9Pexl0OvSr7DJv5JgDAAX6bIkafDyjr0ZgPbJtJ+h57IwehkRdF0U9YgDkValVq2BHhnlcYqQ4twBtVQa6431Cs89r9xM3ll+JnBj+PBR3u8s1YTUgblSKZmtxw7F1Nv2qYc9N25XvZvXJucamxi+M+ZkhItxQ1wR9ddwIR3vld3UftCpKbe1F7Q3igMJMlVjA0qlyw4DkbEJNju/hC3Dlkf+mCqqFh6TIj17nm/yS+wqDPgS749/NE5vYn+aoWTYGPYJcZhD/TCGYTYnSZJEReInAAWniYQ9A5XK5Bs4Bvz/cRTtdv3f/L3B7VWPlxzShya3ff3uLWvXXXu9EBeKdlH/Q6+nuj3Y6ycu/eC2ybu/nskeuXZym6HT3vuv/GvQB/ug30tuQnVSuZQktVHSIKUEcYhKrVqmb/QTGAamrCKiwiZdZgzuyK0TcaAcYjQixoWImMuLqLigctMkVxkhdLfOV2v5USL1h32eR+Ixx8C1e64dsMdij7hdcjzgvi9ip31TcmzzR+NywL9hcOPauByK2QipXzWw0R+Q41H/NkfJjnfZN9kj93sC5G9CKXFjNN68frJ2fTMR3SjGZW+fYzLrhz7NpIZscXjKnZ3JpfNfsNkddvuNclwJCgFh1mZfGEoVNmXd8Kq4bSiVicuRhD87ae+jY8DDEKFPFYMxCEl2OgblEsjCCCGDwbycEZWoj+TyQjZD5wLf3CtJe/XDJHNJsW91+nLDzn1w5gV+SVp+USLHj+ueo0L0+fBwwBcmAekFNApiW2e4qXXCWZfkslx4fSCdisPUkyPBgNdj50RqaOSgaaxgEhCYeGX8gLW2G/tofAzzpXuo10E3QgrnniT4JHQgz9HzgB016pZ06iB01QLq0KmBCIpENBUJq0XYfD98zPejV4nthRpY367RSU6+wE6y11qwQw+Xgrm3mmKHwiBMPjfDgiCC0TrptLoKB9OkyhszcMDY5gxkRZ54wWmbszlnJWxts3EMj37CYMNnKNr61Wydmi7ofBwTifxlown7+jk2AykGC9XxJsPWaxRb8h19S0A9z/NNfZ6z6GO8TphdIOhcU/Xaxgude1gZknGPPo+lrHwPYTg7TRbIAvqj7B6ml5NwTxow7jjo5dHhXCbEo/2DbrGVokkCisoPqAgVFcyxMcKQA2d0zoCx7Qf8YNO8ffYcWXI5hZ2C7NZPuGTBV/W6WsRO5ATZybrsWrrhc6FU0D3jd11y+f2uwjOFXpLQb7DoLUv8wQHy4zwtiQ7T5gSzIgETBd4Fs2nkIiApcIjhCOCjR6Vt3ygE4Flv2ydSyCg/RmpRpcHzn3tMD6euvbln5tjWbfkv388vHdPDmS039W4+dt0WOKbPl2jf2dt+klJTJNK6dKmFHcw36Q6OBmljk/a9RBEVEYaD3S2kcEsHrvteWq+wRAC5tHDs4DY2fLDDragD86mImBfzOIRYIg4iblf4nV7oK88KvxMeU9ruK9RdnXmObGz7nZPseEU54cvLqUGzoBsAaOVFs7RLM62W+dcp0XKy7V9TXRAElOU8HQ9JBh6MM/ufRi0OJsdeBg1UtprGiSpKzFa3Tz/nc2/Vf76VXIQDn3v5IHwLKdDqcBrOlOTNmmacdvNfcvs68m36Oz0g33LA0+3vmLN9sCxHwXcbI6bDw3t+e+rUb0/pJ9RMbmZgdcDi8eCF604PpGeGVnssfdYLdt55OpegbSPYLDRkYrbCYlZpNFXlBgmDukGzF+cxigU6vkpe3r84skY6A7hQ/5fYwdngY1sEG3Hwcrylaa2IkFrcXwrsHu/rKSGuLI2XZw/uuRekDyAA3gAWv2vsIqBlnaf75JX1yItZswoK+BUOBFtZ493HNO1N+uabL2kIGjrv1DTjfY1LJWpFu/yVkOmvtN9Dx42+hRXdbOiN2YNYNL/Eymw0QSPuuberzm4uAXWWPRSThEsKWHwHetJV++XlXnro+gN/Pjw13LtIVne/ATDnfXOB5ER1/6K28l1Cu84C+KV+kAWvC80PxaAkK5RFJZsfLCtitob65JwRXuObbEPDAxr7Z6l3EtCs8/RAKsDsOIAbRUwS2Q8qIO8n2TGYsbUxUpkm6JyYGI/MqaXYoZmS59AhT2nmUKzUfXjiSBMkQUhd8aJ5+EgT7+qScQE0pQvaBZqStYuFEUW7GUEESM+sCJpO9ICsz4rsWaf5rOGlC8E8doJGwy34JLMe2hWeda18FjoBPXuw1/Oa5WkWc7tSve2detsVGv1kNg+qbTyP1dbgfqpPYCzzYN/XcOu4a7jtXHC9b8vmjY36VGW8OBThHDQ4AgoGpMjwg8vMWoHYU/GnOgeM2QQdGNQ/NGSArh0iD5EN1zqSlhkgyEKfq9jvjRLOROvBs8M4Nch9w3GYJCA8l2Rq7IpoywCUX+EJduCJ0yfg2fjws4Bh6P2lEn3asBe0j1wYPydo5yfKCNjygFwQeGngYAmK5Hr3giZZsY9IEVc/Yp+eSIgqPdvlSi8v2MOmUK7Qewjl1E8bUZFuzUfNbIlZ6cttj7Qypos9Z40iWWJHy89AiRyNX1tkyU1jU/71nkjAjOHZL4+vm8iDSgjA0nac/X8ZlTYhoVFRW3v+SwYWhb5BHOpz2alPljYNkZg2rU/NwJ+9/C/cvnffQoMDJibk9jGVwCyPpv8h2pzvGMH4jlyHOJnaHCUaCbtZrEJOg34IYlgnC04zOJtKEIBJGkDMy2qpjWzJXEk/QeawCSVVb+CZi3DpBD3PdfUXi+MVuQnsr/FVuf4IHWv75WNt9pc4Ua3VeXTD2IlKLZ8zr620fWeYsxnxCYIz6tvbW0Cc67g5YIC4lYJBe/qQP24L3OxAuFvo3eu75nI5wdmOeM7GdCaNPxMMDBbRi9DPaRikx8nO4uH6vMpx3TEIfF7sxCDsLCbMdAWWomHXGdH0TpzOxgXwvXaexemCaWHQAmhYfoXMWaALVfrFN7vBTKc8N4wu+NEewZB3jClkHPA9qNSoxaLOKfapihMKg76N7WCOtvNL7zwN8+DI033NZviOq9B2XXVHe1wpTrJzTs4D9Y3guIaCPq8LtTqbB/gfoPwgqij6AaetSBaWr8bGY6tRkNA7QCzJ4j44EzSWK0K//OsYhuTqoFMSLAcAmlEB6c9WcuBS06ipYk8QjMmA1syCjsyD0gSEhNAFEEsuPzhKELnUiaZuHU8VVWfwktunuAkZX7ulvLXrnP4ePQd2IJocU+ccPnfJnRA2eLaVS+Ut6pVOWvqY5TpFm8DGGrycNDhD0EqWWeCXsL1gkOC7a2zYc3aWIyXwIP3Q9A8+heNKivhteQZj/c7TQTf1M4gMQ1mGhyaq6c4uKd7wAIjnKX7e2C6pD9yAYnbkVHunqx6sTL/bZtQfFAvGErPEsls8dQRKwwbRHWwTLQ6rS3dojPcCjWGFuAyU1xNm2E5J2Awxawg1HiP3URaXxFOkmPEO3bSpBrJX23TTkPcj4InOoqkpgKua8Y7ce8/iOpTCdYv33Dvi1bfE5dmDMFnrBdky18B3xH4UaD9KhGpe5kMaU9SjmvFBWj8eJbfrfsJ6GscI+17DgQIdiekzctHQ913YQc4OGh/MqhkfBr24rr61gSZ3nnbaDdmQ7YPwB7Oayr3h6C5RwAD4waKXbTAqiP98bqed4T8MtA3a4ekKYCXmYaEqMVKGHhYK1bARzdZSq7WUUy1zidYl24ktghcB6BXQSwQgTBbTMjJ6zPl0rZyrZGsAYPnmx24JbHv5iSTZGtCfD5NC4M2b/+DePXMHPvlC9T0u/EpA6z2TASktHZi85yYVEznbDk/etVddP6A+8mf4XkfbNzbtJVo0wD9RsPWmzXSssJnQoTXjg/EU02aauqGdUL7Mjn0YXAlFaR8UGzJc+fuw4fvjUoYt/3+49IPjSqh1h/MAz0rUVvhcTipbmGkCvxSEGSPj+ZqGbgE1NuCJq+C1YxoRQ/bzeGj1NfpBMipQh/GBVMxLZa2UsCWJz5bNYDii4TDhV76ksOlbixrYlBwvfey6TeMDkuRQtu95dNPmL9yyORgUPIXRmevVR2jgSXOFYnE54aPWll9KV9avrwQDnsK+7RsAYCaTjmhjzaZSRmURKIcvIcdjIRe14kbeKMP/Ny5NffKBTK+AOqVOWJC2ChYhAn5M1IjFouLNo0FTALGQrYIgiFH/3MaRz4wUixtuDcXlXn9Df0T/V3JoOiB/Xn/1YbKWXyLBWzeMjBSPFDfO+XrkeGSD/ggJkKPTvqg//iP9lT8gay2xAbR5oOsdpq5kZs5q2jomzRpT6KN+d7bfS+06qkSfTRm1gVK0TRCqIbNp3Nec/ZsqIyPrNqxy99Ld9Pia8RTpofvTg/o5eiykbIHJ9fsnR2/dPHvNLaPsYGjH+o0bNm7Tl9nhJ243TqzAJR7EFwYuARkNI4VDSVeyIKSUyWDxY37wimqN47lMfky4LJaFMhHKtWyrpWqtFpjvRzei+mF4ZgVfwU7zMS6zz2QjkMrgK0bG8GUsOUARsd5AC8C1Y1HYf6vh3YOUm0Nj8aJcZWYe09tV4xQCgYzYQTW1Cl4FH6a2ql/R5PiqGt1vNrRQIDdK91fVhFSzMX69/6AUl+v+68cxeAGH9UYzEJopGkfn8UJ3mxzUj3CJRpsAo+XFtFILpmugmaFTWi1yEfplHrN69JAdXKEMt0htQ9h4mBWlstvp5MWnsRA8oZ+jhyvjRtdwu2H+7tycX5knF5WoQ3RkHLAZJaIjAa5+RowqCbDKREQ7XKvmcJbXGkI+h/mUHGyEWk7xwaSqKglhmlRyHS7IjmujUW/UNRK0O1w+xRHuTYl1l4OEpG3ewWpgavXWRwq8Ek+sHu8nJJkIer32yNWECG5HWFjzcnaNXag6BUkMSNFAh1BSDPuzks2nRJzglYWuuoZkXImqIHmjd6SiV01FesRwIeEvpofcIW+vS1YcdrdXDPHhu1xJj5M4hIjX4Y4KuW4fz93h2oAiwHikgmaeP3Mb8sgw/di2BXDiByoZUymCD7R9dqvNYnmJPDfCjXFlrgaYdJobXJ9prJ2arE6UVo8Wh4dyA5lUItbXY7VtAaaUa5aP/UMem3ZPYxyQD3DQZSGv9I+TLvNjO21U1kcub4fUDXjs77PfAULgolxxn1owCnXa35w1HvB+PLMgmrS03dh2gDUjYrB91Le41djGnB9Ud3i5XrAfru8l+mSfg/q4NJ1kBm+DNIPLEi2mIxrmW2HQSM/I8Z4+vtnXE14+EObrhkMZ1k/T1ObWMKZ29DfD4dOGA0na8lMGfdXH8iZylkZWYW6NkAo9gpeDl0KjyEbkxjzCBP4IoNGSjHEZuUT3YKufoyEbcw+2MNBxudWS4yps9Xm2NY/Jghxv609q4wfb/MR2PJuqS+yAHK0RPWL+EuDyyG9PlQwmyQMnHzAYJfDSU0egeI02f+6GB8CdOIH7cEI9YrwvTN+HOQ0PD+8LUPVMo1uiRBjzp64/qz9LTsD+LPiVT9X158guS11dHc5VPgiOnYy8K9CEKDLIvzkn6HeBRC102zWv1d8OpsPBGilX8jUlyAAkPm6yqMBcUT2gIofMGt/FfILfYzc4Mp2UY7CslGvlYJi/FA4vO8LMVwVBgH08p7EUD5M5ls+SuRToC9f3cum+qIvKXCmqNAgN7iHQ9hGM6VUVmkkHNTxK0gDIEzSul9Nqc+XyXO3WO++8Ffc+UsW98vh4OT49PDxN7qObOJzgm+unptY/+OSDxkZdu2PtxOrVE/iBXc7Kx0L8FGU60UyMOajhpIHDSjnCctbUCNAIARFoynD+SFNlZIzpG0sYUYOG0zzhmZvWDb7qw+FvNPesH/zUzS663223AzCWIuODyFlBpKmTBj9NsuAuHb7gOKF7Dme2fbRP/Bbi0+96VLX5t7/c4OG4D8dlNfmn5mclM/bfw4vtIPYPz4t9v3qtZMV2ZC8IOgrGJ+Ruj082kxflLMZNcpV2vpe89Pri4v6UX0A9NyaQ3UZWd/H1RUGA+UHG/Kn9o2Ya1ywf5BHzzM7TsV6GPw1qR1k2+SxlpHeAmNOc+qOCzUZ5VioDZWpkh4reBOiZE5TU0SJzyOAwpb7bF2J5C4+r7YcF04Nl5GPX6DcmEWkuFHPw+I14GTCnqhoxNOSlfI28C5g/CBZpHbcD+/f69aXBWNjFeHWMjiHaDZJFLf2+Z/xGViYDSpUixZrCUsZU2+F5stPlRv6Ffo4xLMgC42Po893HB0K9CZk4iBaO+92+/rBgszOSHWWe8S8w5kWL8SnYgWY9mBTiITlBSDzi6XNcpOw0kjBkKUExcp7bwtq6feumVQEnlaUw2NVKebBcVaLU0WHtmyZVgGkOyyGpGvk6vAdurU4bvQSHogNunqjZaUD3VUQ/j5BMtDY8NdXyx8C+tRIkntrdX/T3w8EI2BevJNBG+bqvJIsT9xampshfaozWcBtv9wxPPVVv9cTlmL+V2B1PCP1FelCc0H8YIPFhX/fZZCDcW6g/NfVHdB6hbNqh7XHQk7tANnddLxGe0iaNtuZH7SwXWMIzRqMNZk2tKiZ4k4OThwtGuw2ujmi0GhkTW7Kssbtu90S9QbuP9MVln8ffVysb7aO9UDocTfWIjHoTjq0ZNa9B0xWj5a0dQtxs8y4HAd9ScIK3mhDdvK1stJQ2dOKfiRPOUfINtGm0cy3uM/ugtePDxUgQ+zCdYrfsU/yzQKcU4qH57mM0dMi0Y4wXVDjO9vtEau0UivoQ18rrQ6PFIUCxMcB+AQ+CZ2eHuFuDdzk+wL7B5kIt9+zv2+WX2N1G8uPyLWfNLQkdfogwiCpDZQF4aBfXju3ReDfa8IDHYfCOAetA52F6jWbNKhPnnzqIiPnXu6Y0fungLKW3qrOhqWFVHbbw8ILttSBmGWnTLrISyMLUrikkL89S8poGIjbc1rndcVVLrFbMlyeqdiXbjqsu3PAALmU5RQ7C1xE4oNFaTTtyStXacdV2fg3LC7E4bRhahQtMwKwmCZqJMnJOMOYDxUH3lFoIeehKEf3cpUuaWoKPZsSSOSM3oKDN8bA1M4qIZeF8S1MwSm2DnKfhLw+SQy9SxV0v6B7oOVx+oxbqNG5fqOM6GozV6EKGcgyyUG6yz2vmHCJiNNnWxGMkl8dtgCB1O4eGDdfXFF0O1RNaOxwc8ah28fqbHj9L5g4sgF1bFFJnH9+zwwGXR4LDa0Me1SYV4An9gYUD+xfhBs4a2w3QfIcclIzxlyM+3k8w0GKa0FO/PUXjTjQCZZCjhNSpI5MLn7k7lfKMHH3g+OSR6yhQNfQzmHCYOQqX40ZRP4/kkz1Bv2j4Jtg6OT2IBD8qJIiiecP44GvN2JmQIgTE9Zdx2d7CIG3LLsf/x5Hm1sGcIzIxlHrW8C2W/1lwisIvLkUSZAEGL07uazaKRwtDjmhjakus4enwjlQq7+Y6q3Y8B+OOCI4ZXR0nmjGP2P1WLhabhUZawnKPaHKEzOlPM2enAPzjtlvGjVi6mcMgafgssMh2J4Nx2f02gdWXZUra95t5EqN9zA/H2L7D3olXkSCu6LhoKZ2z3M9yAdbyy0G6+uuiZpYPTxBL/3X4xGnWIcZ10ycwY15pGd4OEyMbLNPuZTFhuqG8KcRAgkWXW+PJ7wctl9RXVE01+PFQn78C+V0L9R+TDVtIKTiUDsBPVMU2KcdYMFBlbpyInAE5TT23UYJ3kqjPSSOoo+dsAiXpoBM3HH/szhLM2fl6oXTnYxF+yVYv2DQkg2t8euqvkapTQp+OOZh3nwwdqBcK9QOhk3eXGH0H+6WdE2n3mxGovqhZef7IZHaezqRDVrxp8huMumYNWrHSTSG+BApl+Zl6AfkJkR2MOKx7AIZibdC5vUjBJxLbMLfxvOCyrkkgRoSaOlhQOAlEL5zcMD30+udPXvgqvzS94eSF6INfvXDy869zVn9dQX+V8eKyAIJBGWaptoZNHjPsWTLHoniqEc1TqQ5sWU522as4lBdgvEgWKQcUU7GJnYNgwyakKNFC6df/738w9myR5oM/Bi1wnnIvpNecw/p9bJc8YfNl+qIsn/Of+RehzkV4R5759AwxZRDxKLAD8jFNGiQ/SkSCkbzSNK+I1EgT8qdP1aemLg3smxn46KabRdHXI16KkXh8d0K/UCLlicUJ6f5NR3f8+MkdJMov1QGqXByY2Tdw26Y5wRkNOH+T2JkA5Kr/fGKhPDHh+RTc+uSPd5BAty/u7OgkJBmJCslW6GowlUWXzT2LnwfPebgIl+CGUcfmkr1y0Ev5IMRwhnClUtVmaCSa+M3iGXu0VMMDJEXwOQzY9qWlmVH9nyhBif9UpqAVP7784ubXN2fAchWEFMyEcH74M3uaKuw9cPLV4HTu5MaZhhDetQt3T+amL+cY+rv9ZsHyTrIOS3lAuulfbtpxz7tv3SOkjr92/Phr+jdV1XbfTlXdeZ/pH9F1FG5jTVOEUpuFlXGGdNBk+IbJa+GwXgqDh/U5M+5khBtUVGd0hQTGnDq+F8bZo3S9lNshsDyOEiRVuwmTySBbDkbm+nr0H32cDD383NnHH/oYCej7fn6u2oAy9PtIYd+B8MuPPH52Jwn88MK54cPXGHEd0E9LZg6RJyvW7tA5HRTzQXNio4G/hXpJGIoCbUKxwiSAUpjXbLWOsUZHA0BB/chCXQOPqLvvXVfi6gx21l5a1jdmUJyuoLdJmbFxqe+JizWNGKGR52XJik6eRqAcvx5DdjGHp4hGhGQCoEuN+Rwp6mUipn64MTQHGGRi1WAj15g5q795FkQJ4CnhtiW3HsbFvvV92eS25PjC7ONnzz4+uzC+0l8OU3mIRiRmK2g+Js249jRaiHIBtklDM3lG8EnS3uVn9koaI1JrqqT/RNI0ifRJGrPj9iv4FMjP6OIpWdYZKsaHxY4B3GksHc347PBh5EIqA28b+UJjjQ+JhhvIVoan8w4xJzh4MZcHhzVJqiGyqe8O/5Q/ctWf/dS7JRe9Tb5Bjk3evyQJ/j380o36dwe/Mph7VI19f++1ZPIq/d+uav4XNeMYJ/2WfPUaeE/SkDWK5AgMRVku1Rq8EUcbJfkceLUTcIahc4BNSlQGEz2RH+W1NXvWSAFB+GnUIcYV78iaNSNeJS46oj8VhIBkXqQHfPN9rq58lG/SM5xh68ivoJ4jdE3baNFv8EJZVX02qqGggxpOUFR0JY+YBw8VnfrffGZDfWQ4o7gTTkkdGk7z/TbZ5hdEPpbbtX2wR1Rd4xtncETq1RurHxlNRNzp6FBPb291bnWcV+wRZ9gXVXyF3sxgzyrP9vGNy1er3bo0yZW5zdxe1KW7rls/WRxwGbrUIKqCIoAKjZIMjBvsGJxboYMwLsccxpnBy84wDu30eHDraH/cu+MTO7zx/jVDFSS79hnwAyZ65EXLPvmGQR7GA5PHW97hHZ7wjE9Pj3syU9dRPq8HQQkNN2to9PGIhV3gyNZ1ZJn7WTPWjT5NVkwSZs8zYyA/MKnKtTEYGJY/xqUrmlZ64juOqKb1jqZOPpEcU9WT3xJUdTT1xLHkWImm7868JqCJz730Uk597Yyg5p5/PteOcxpr80x7X6KJPFwPBFqjplBXp0oWThw6pJ+766YHjwCEbs7c/8zT77wjpOi5vQCr4QxysLrLlNprmtPBPAEloBDEySf1efxj5Cm2d5JhIcPGtJ/rB8cQF7lXsuAAavixaL3OmuzOewDoeEF94xJuU1Ni/9Cnu/WWiwsxvRX2uakdC5Zs0RBMRX4gK5c4unRNxiVsJ0jhHz6rPan/7KnXSE77ztHZg1CJz/6D/qMTT5HIk6p+/rWj31EPzlpl10VZoVmU3VRMiSAxCWNhJRuWP8pDuSDC7RfA1gxBqC+RjUvqR578x8Nf/Mmj6oWT1IEuGCHSJf2llw7/45MfUR/9yRdPXmDOtnW9C3t3GvoiyPrcoFoyXnywHSllxoDyrHC9pD6PobwFdIsRnQ7H67jOT6Nx0kv6OYquW2yZY6FujckiLz2OHPiwi+oNk7/RWVSQplLrEBukvPVtUPhqMak3ksUij+zBaz4ZCL71BC4o8ahH4WSSzyXhvLrnqtYPLLkUjxl/l3ha1gToTpYxU7/697lVd2mL4Bb9WP9b7U8WDz73Hzd32d8IXf8Vld3UF6kpUZvCQms04raOVAfCQXsUg3PkaDg8SHxbjq9bPzM/s37d8S3EN6mf99w9WRoRFEny35dIvvU3O8cqlbGdr7yZTNy3fAu//fDp41sGkh94Xbz5QXvUTncaq+IpUcjI+3VyD16z7TBoyJlH/mW+VgazTR/WKC1Hw8AzUle79SeycnwwQlCXoN/rRiKojf0QATgFOFamPwfl4PTQNBZ7Q6OMOU/Tan7wMi0UKKNMM46H07a7TLE9vt0Z6vD6wOBAZ/WcaKyd61qqolC+cNpYt9bZbuW/hGK0fBC+JzFfhnll85tfgivnTTHrLGUz1rN16yy2viicFsN5+EuD4JLiJfUS/LVhF00Ic5ZcNOMI40qFMa7GTYPtUtZHrl6/dnJidXFoIBXrYZxhqSt51bW6y/Z7zg+suE4eorD6DbbUK0g3+k9oOIgFYwyS9vIr1jveMLA4Bd+bLWvBNtOIUcpy5g3rVQbWOzlpHLde5F3TYRKuMEzMFwBdk+EfxIX+y1+E7x3k4htT8djamJCCMwN4nv/fvojhEZRKJev8tTGuj8k9lPiqmUXCH8c4p3vMNYH05zQuakwbmrywJuUghqCOfjfyFymvDfzJwTKuFzGjaRpdCU52PQnbbYf0YdZXTRhhtkR822HNwm3vHmuYB+a4XoH3b45X9crcf/3zdKh+vWtqatfUSpI345JN4TWLvpUoD8lj8OUAZYO+BVuNDJGawo+p+hOgBxD04loQCod1zzfhrHnCav/wF2xk6Bv88ZrL/ThG2YZJhcsfcEVmC8DczHPbUP7N5ajb6KmS2h3n7oX54zV5A8gFCFrJAcgdyAqpUr3QQirAfEmOtwp1wChaoY6L6TH3z+fqBdPOCEYMDe2MbOV8lZQQo0vhD2nQpbyjPEBU5IDNpX374nIrkhhzhHIDbr4x6YwVwUjMk4Wk/kZMjifDyScig55gRHhovzNm+k7wnhjNMSbjEZ7GrtBXor5TnRjxUBDuIKJ36nosBJLhcMgxloiAeZzo6/Wl9RPFmHOyod8Lff8nSUFwDEaegJfFZc+TW65NkoWYc/9D+u9wVSjf9keT3DDy6lIKi4mDXsYVcgx8YcSAMhWZu1bJ2jkWBAFMDuKplqKZwhgNIQf29qLr9tzDuHj4f0b8uYRf+qu9MO4Op3MugEHo/WOFwavXoAv3yN+FhID+VMSfyPml1maLfDE+l0fsxNMrafZzNDSKTvnF85TBz+LnNHi+Yu2hn67VygacxprraCdeNlEF88fAh2XLfncAY/AgAleDd13/Jk3X4wfjB4hGMHCG/jcja5C59hZGwPLuIM0vREIehkc672BEEQFaQn//AuBaad9xXG52NUJQ+qMSYKpmDyK7fMXvUGGOAS0TxnQG4j1BD1vHYiwmx8mStuzbLfuY48LFyi9I/G10o7/BNueY0Zf0hCSRf5LMrYaeMPrBRh65YyOZvumnma4y2sixYn4gGeszdI9I60OdtbSxtZtbZpBpjQZXbF2nJY2/Hb70N/GL1kqD+oHek0672DfU8swZCT+qtBecdlXFI1wrfwZ/cqKLS+CnvzoB/ZSOyQHJ8htb79NX1n18N+srUrFu0KPv9BPrHvPY9DVUg69i6B22xKgGMzRvgaIlSgdQKdfIA8KDZIAWCjD7kQekG1n5iDFuAHTjQDwkGWsXoTRwytOVEugEcD6zmP6CaYh0Q5Ge8hOybePGRxEXDOZu/+xnbxcyub6eDbt3b+jp600Pj6R6DRa36ur909dP9EqqI3jnH90ZdKiCs3Z1zSlYckDst4f8znYMB99tX/ma7lLNUqx8V7G9Ltsow3jWeMb0h9r2HP0h2bTnMHcVotDfBVlHaqQqAMzCD6nMOm0kJ+APBQgkZyPsNwqW94R3StLOMP9tCdERqoZ2+b+iuCrE9SFeCHtdZmyPeu75asjci5rI5tDr364c+/5fPFb5dvPCxyoze3dvqT5nmPq7Zvfunb1LP9fYPTa2+xem/8N0WJranzT0XaLPz9blKqJcrhk/t0EQ90/UkI5S5QyjzOdT/tu024Tj+4ZX62/FmrE4zJvwcf1FAyYJcNGf2r8YBssRi++Jk+Tqkf2Lywc7fLn3nqNr4JW2/OHi95qC6X0RbBJGTHL5Y+Td/k/MDjy2HPvE7txjAzd8vH/5WPnV3xF+ifwu9vEbcseW+z9+w8Bjud2fiC0/tvrVd0mXH4Bl+6hNBeQeLgtlA2lnUUHD/7L609xP1bffZtRBlW3eNhmFiHI1Yy2FYMlx5kGXuL43OpTo8xqc2/fJcw4wjlcNSRkVXMPNltZlK2Wa93Ta97XznrbtNz9+lvwd2ptbNvuCQsVc4os50OZOm93Mge6zO4vw9B1gmtYqTuGqm/aPWtZEWOqIHLThD1tHVHsfoG7zjHj5+2pWVf8fLCLaMgB4nGNgZGBgYJScqc3dIxnPb/OVgZtZASjCcP6mfhaC/j+bWQkszsHABBIFABtqCct4nGNgZGBgVvg/m8GDuYUBCJiVGBgZUMFDAEx2A5UAAHicY1RgkGIAAkYuBgZmBfyYKYI4ORAbmc84gThzYTSyenx2IpuPyw50t9ALY7MT3Z9E4xZM/1LDjcTGC1Fh2gIVa0HI4wsDvObvIc4dGP75Qrwf6J0WUMK6BZXNwAAAOA8qLAAAAAAWABYAFgA4AFoAeACYAMAA5gEOAUwBYgGIAa4B0gH2AgwCIgI4Ak4CZAJ6Ao4CtgMAAyIDVAN2A8gD7gQMBFYEfgSqBOgE/AUsBT4FXgWcBdYGIAZYBuIHFgdYB5QH5Af0CAYIGAgqCHgIlgi2CMwI4gj4CQ4JMgleCZoJzAoQCkYKagqgCsYLDAsqC0gLaAuGC/oMEgxMDG4MoAzUDQYNYA2ADZwNxA3yDiQOdg6SDqwO1g7+DzYPTg9mD4QPoA/KEAYQOBBWEHYQlBCyENYRKBFsEYgRzBHqEgYSKBJwEpISthM+E2AT0hQaFEYUgBTIFQAVHhU4FVoVgBXIFgQWJhZMFnIWmBbIFvwXIheYGBYYmBjQGSgZPBlgGYIZqhnSGf4aPBpoGrQazBreGvQbDBskGzwbVBtkG34bnBvwHAAcOBxYHIAcshz+HRodZB2MHbod7B4iHkAeXB6UHsIe7h8iH3YfwCA+IHggoiC+INYg8CEeIVwhkiHEIeIiGiJCImAiiiK0IvwjGCOQI8Ij4iQOJEokcCScJMYk+iU0JXolnCXaJgQmRiaYJtgm/ic+J2IneCeoJ9woGChGKHAowikMAAB4nGNgZGBgeMSQwSDAAAJMYLIYiM24c0BMACyYAn4AAHicfZC/SkMxGMVP+g+q0sHBySGDQx1u2nsRCne0ULRLu9RV+ie3DZTccm+gdHATX8I3cPAh3HwAJ5/AzUfw3GsoFMGEL98vJyfJlwBo4RUCv+0aT54F6vjwXEEDX56ruBCx5xqaIvdcR0s8e27gWLzRKWpNzh7LXQULHOHdcwUn+PRcxQ2+PddwKu4913EuHjw3cCZe0EcGjSkcxwUkZthxHENhyJAYwSKlx5C3HB1WpAE1Sx6Ua0vulYjo7zK36XDsG8TosCfem+y9Cjlniqqmfgn0Mz11eiFnOzlWQyVHNs2M3Bq3koPUukGaLbWMVFe2V85t4k4noZoUqsoTZbXjGbeYlxflxHlqmYxXigxDzTD/V3nMmJSrxTvX5Y+EXg8RoMeI6AxxxYMOCovlxDrj1noRksOgF0TdkK6/x2FvBO6oZazYlEUVlygfkos6y01qZajYOU/5o5q24PBh6UbbwL/uB6jvbQEAAAB4nG2QQxdlRwAGX32xbdvJbXfHGMa2bvd9L7Y5SSa2jYlt27aTbf5IMifbpM6pVe1qpNG//D17ZEf/x19zZSTEPMzLfMzPAizIQizMIqMpo6mjaaPpoxmjmSzKYizOEizJUizNMizLcizPCqzISqzMKqzKaqzOGqzJWqzNOqzLeqzPBmzIRmzMJmzKZmzOFnQYLA5PIJLIFLZkK7ZmG7ZlO7ZnB3ZkJ6YwlWlMZwYz2Zld2JXd2J092JO92Jt92Jf92J8DOJCDOJhDOJTDOJwjOJKeSmNgzISjOJpjOJbjOJ4TOJGTOJlTOJXTOJ0zOJOzOJtzOJfzOJ8LuJBZXMTFXMJsLuUyLucKruQqruYaruU6rucGbuQmbuYWbuU2bucO7uQu7uYe7uU+7ucB5vAgD/Ewj/Aoj/E4T/DkaA5P8TTP8CzP8Twv8CIv8TKv8Cqv8Tpv8CZv8Tbv8C7v8T4f8CEf8TGf8Cmf8Tlf8CVf8TXf8C3f8T0/8CM/8TO/8Cu/8Tt/8Ofov1NlOhkjY2WcjJcJMlEmyWSZubWXqTJNZpAZy0xkO1kja2WdrJcNslE2yWbZItvLVtkmO8iOZSdynZyRs3JOzssFuSiX5LJckevlqlyTG+TGchP5Tt7IW3kn7+WDfJRP8lm+yPfyVb7JD/Jj+YlCp2AUrIJT8ApBISokhaxQFHqFqtAUBoWxwkSxUzSKVtEpesWgGBWTYlYsir1iVWyKg+JYcaLUKRklq+SUvFJQikpJKSsVpV6pKjWlQWmsNFHulI2yVXbKXjkoR+WknJWLcq9clZvyoDxWnqh0KkbFqjgVrxJUokpSySpFpVepKk1lUBmrTNR36o16q96p9+qD+qg+qc/qi/pefVXf1A/qJ6qdqlG1qk7VqwbVqJpUs2pR7VWralMdVMeqE7VOzahZNafm1YJaVEtqWa2o9WpVrakNamO1iYZOg9FgNTgNXkPQEDUkDVlD0dBrqBqahkHD+B/x69N7eJxj8N7BcCIoYiMjY1/kBsadHAwcDMkFGxlYnTYyMGhBaA4UeicDAwMnMouZwWWjCmNHYMQGh46IjcwpLhvVQLxdHA0MjCwOHckhESAlkUCwkYFHawfj/9YNLL0bmRhcAAfTIrgAAAA="

/***/ }),

/***/ "../../node_modules/preact-compat/dist/preact-compat.es.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export version */
/* unused harmony export DOM */
/* unused harmony export Children */
/* unused harmony export render */
/* unused harmony export createClass */
/* unused harmony export createFactory */
/* unused harmony export createElement */
/* unused harmony export cloneElement */
/* unused harmony export isValidElement */
/* unused harmony export findDOMNode */
/* unused harmony export unmountComponentAtNode */
/* unused harmony export Component */
/* unused harmony export PureComponent */
/* unused harmony export unstable_renderSubtreeIntoContainer */
/* unused harmony export __spread */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__("../../node_modules/prop-types/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact__ = __webpack_require__("../../node_modules/preact/dist/preact.esm.js");
/* unused harmony reexport PropTypes */



var version = '15.1.0'; // trick libraries to think we are react

var ELEMENTS = 'a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr circle clipPath defs ellipse g image line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan'.split(' ');

var REACT_ELEMENT_TYPE = (typeof Symbol!=='undefined' && Symbol.for && Symbol.for('react.element')) || 0xeac7;

var COMPONENT_WRAPPER_KEY = typeof Symbol!=='undefined' ? Symbol.for('__preactCompatWrapper') : '__preactCompatWrapper';

// don't autobind these methods since they already have guaranteed context.
var AUTOBIND_BLACKLIST = {
	constructor: 1,
	render: 1,
	shouldComponentUpdate: 1,
	componentWillReceiveProps: 1,
	componentWillUpdate: 1,
	componentDidUpdate: 1,
	componentWillMount: 1,
	componentDidMount: 1,
	componentWillUnmount: 1,
	componentDidUnmount: 1
};


var CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip|color|fill|flood|font|glyph|horiz|marker|overline|paint|stop|strikethrough|stroke|text|underline|unicode|units|v|vector|vert|word|writing|x)[A-Z]/;


var BYPASS_HOOK = {};

/*global process*/
var DEV = typeof process==='undefined' || !process.env || "production"!=='production';

// a component that renders nothing. Used to replace components for unmountComponentAtNode.
function EmptyComponent() { return null; }



// make react think we're react.
var VNode = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])('a', null).constructor;
VNode.prototype.$$typeof = REACT_ELEMENT_TYPE;
VNode.prototype.preactCompatUpgraded = false;
VNode.prototype.preactCompatNormalized = false;

Object.defineProperty(VNode.prototype, 'type', {
	get: function() { return this.nodeName; },
	set: function(v) { this.nodeName = v; },
	configurable:true
});

Object.defineProperty(VNode.prototype, 'props', {
	get: function() { return this.attributes; },
	set: function(v) { this.attributes = v; },
	configurable:true
});



var oldEventHook = __WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].event;
__WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].event = function (e) {
	if (oldEventHook) { e = oldEventHook(e); }
	e.persist = Object;
	e.nativeEvent = e;
	return e;
};


var oldVnodeHook = __WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].vnode;
__WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].vnode = function (vnode) {
	if (!vnode.preactCompatUpgraded) {
		vnode.preactCompatUpgraded = true;

		var tag = vnode.nodeName,
			attrs = vnode.attributes = extend({}, vnode.attributes);

		if (typeof tag==='function') {
			if (tag[COMPONENT_WRAPPER_KEY]===true || (tag.prototype && 'isReactComponent' in tag.prototype)) {
				if (vnode.children && String(vnode.children)==='') { vnode.children = undefined; }
				if (vnode.children) { attrs.children = vnode.children; }

				if (!vnode.preactCompatNormalized) {
					normalizeVNode(vnode);
				}
				handleComponentVNode(vnode);
			}
		}
		else {
			if (vnode.children && String(vnode.children)==='') { vnode.children = undefined; }
			if (vnode.children) { attrs.children = vnode.children; }

			if (attrs.defaultValue) {
				if (!attrs.value && attrs.value!==0) {
					attrs.value = attrs.defaultValue;
				}
				delete attrs.defaultValue;
			}

			handleElementVNode(vnode, attrs);
		}
	}

	if (oldVnodeHook) { oldVnodeHook(vnode); }
};

function handleComponentVNode(vnode) {
	var tag = vnode.nodeName,
		a = vnode.attributes;

	vnode.attributes = {};
	if (tag.defaultProps) { extend(vnode.attributes, tag.defaultProps); }
	if (a) { extend(vnode.attributes, a); }
}

function handleElementVNode(vnode, a) {
	var shouldSanitize, attrs, i;
	if (a) {
		for (i in a) { if ((shouldSanitize = CAMEL_PROPS.test(i))) { break; } }
		if (shouldSanitize) {
			attrs = vnode.attributes = {};
			for (i in a) {
				if (a.hasOwnProperty(i)) {
					attrs[ CAMEL_PROPS.test(i) ? i.replace(/([A-Z0-9])/, '-$1').toLowerCase() : i ] = a[i];
				}
			}
		}
	}
}



// proxy render() since React returns a Component reference.
function render$1(vnode, parent, callback) {
	var prev = parent && parent._preactCompatRendered && parent._preactCompatRendered.base;

	// ignore impossible previous renders
	if (prev && prev.parentNode!==parent) { prev = null; }

	// default to first Element child
	if (!prev && parent) { prev = parent.firstElementChild; }

	// remove unaffected siblings
	for (var i=parent.childNodes.length; i--; ) {
		if (parent.childNodes[i]!==prev) {
			parent.removeChild(parent.childNodes[i]);
		}
	}

	var out = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["e" /* render */])(vnode, parent, prev);
	if (parent) { parent._preactCompatRendered = out && (out._component || { base: out }); }
	if (typeof callback==='function') { callback(); }
	return out && out._component || out;
}


var ContextProvider = function () {};

ContextProvider.prototype.getChildContext = function () {
	return this.props.context;
};
ContextProvider.prototype.render = function (props) {
	return props.children[0];
};

function renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {
	var wrap = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(ContextProvider, { context: parentComponent.context }, vnode);
	var renderContainer = render$1(wrap, container);
	var component = renderContainer._component || renderContainer.base;
	if (callback) { callback.call(component, renderContainer); }
	return component;
}


function unmountComponentAtNode(container) {
	var existing = container._preactCompatRendered && container._preactCompatRendered.base;
	if (existing && existing.parentNode===container) {
		Object(__WEBPACK_IMPORTED_MODULE_1_preact__["e" /* render */])(Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(EmptyComponent), container, existing);
		return true;
	}
	return false;
}



var ARR = [];

// This API is completely unnecessary for Preact, so it's basically passthrough.
var Children = {
	map: function(children, fn, ctx) {
		if (children == null) { return null; }
		children = Children.toArray(children);
		if (ctx && ctx!==children) { fn = fn.bind(ctx); }
		return children.map(fn);
	},
	forEach: function(children, fn, ctx) {
		if (children == null) { return null; }
		children = Children.toArray(children);
		if (ctx && ctx!==children) { fn = fn.bind(ctx); }
		children.forEach(fn);
	},
	count: function(children) {
		return children && children.length || 0;
	},
	only: function(children) {
		children = Children.toArray(children);
		if (children.length!==1) { throw new Error('Children.only() expects only one child.'); }
		return children[0];
	},
	toArray: function(children) {
		if (children == null) { return []; }
		return ARR.concat(children);
	}
};


/** Track current render() component for ref assignment */
var currentComponent;


function createFactory(type) {
	return createElement.bind(null, type);
}


var DOM = {};
for (var i=ELEMENTS.length; i--; ) {
	DOM[ELEMENTS[i]] = createFactory(ELEMENTS[i]);
}

function upgradeToVNodes(arr, offset) {
	for (var i=offset || 0; i<arr.length; i++) {
		var obj = arr[i];
		if (Array.isArray(obj)) {
			upgradeToVNodes(obj);
		}
		else if (obj && typeof obj==='object' && !isValidElement(obj) && ((obj.props && obj.type) || (obj.attributes && obj.nodeName) || obj.children)) {
			arr[i] = createElement(obj.type || obj.nodeName, obj.props || obj.attributes, obj.children);
		}
	}
}

function isStatelessComponent(c) {
	return typeof c==='function' && !(c.prototype && c.prototype.render);
}


// wraps stateless functional components in a PropTypes validator
function wrapStatelessComponent(WrappedComponent) {
	return createClass({
		displayName: WrappedComponent.displayName || WrappedComponent.name,
		render: function() {
			return WrappedComponent(this.props, this.context);
		}
	});
}


function statelessComponentHook(Ctor) {
	var Wrapped = Ctor[COMPONENT_WRAPPER_KEY];
	if (Wrapped) { return Wrapped===true ? Ctor : Wrapped; }

	Wrapped = wrapStatelessComponent(Ctor);

	Object.defineProperty(Wrapped, COMPONENT_WRAPPER_KEY, { configurable:true, value:true });
	Wrapped.displayName = Ctor.displayName;
	Wrapped.propTypes = Ctor.propTypes;
	Wrapped.defaultProps = Ctor.defaultProps;

	Object.defineProperty(Ctor, COMPONENT_WRAPPER_KEY, { configurable:true, value:Wrapped });

	return Wrapped;
}


function createElement() {
	var args = [], len = arguments.length;
	while ( len-- ) args[ len ] = arguments[ len ];

	upgradeToVNodes(args, 2);
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */].apply(void 0, args));
}


function normalizeVNode(vnode) {
	vnode.preactCompatNormalized = true;

	applyClassName(vnode);

	if (isStatelessComponent(vnode.nodeName)) {
		vnode.nodeName = statelessComponentHook(vnode.nodeName);
	}

	var ref = vnode.attributes.ref,
		type = ref && typeof ref;
	if (currentComponent && (type==='string' || type==='number')) {
		vnode.attributes.ref = createStringRefProxy(ref, currentComponent);
	}

	applyEventNormalization(vnode);

	return vnode;
}


function cloneElement$1(element, props) {
	var children = [], len = arguments.length - 2;
	while ( len-- > 0 ) children[ len ] = arguments[ len + 2 ];

	if (!isValidElement(element)) { return element; }
	var elementProps = element.attributes || element.props;
	var node = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(
		element.nodeName || element.type,
		elementProps,
		element.children || elementProps && elementProps.children
	);
	// Only provide the 3rd argument if needed.
	// Arguments 3+ overwrite element.children in preactCloneElement
	var cloneArgs = [node, props];
	if (children && children.length) {
		cloneArgs.push(children);
	}
	else if (props && props.children) {
		cloneArgs.push(props.children);
	}
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["b" /* cloneElement */].apply(void 0, cloneArgs));
}


function isValidElement(element) {
	return element && ((element instanceof VNode) || element.$$typeof===REACT_ELEMENT_TYPE);
}


function createStringRefProxy(name, component) {
	return component._refProxies[name] || (component._refProxies[name] = function (resolved) {
		if (component && component.refs) {
			component.refs[name] = resolved;
			if (resolved===null) {
				delete component._refProxies[name];
				component = null;
			}
		}
	});
}


function applyEventNormalization(ref) {
	var nodeName = ref.nodeName;
	var attributes = ref.attributes;

	if (!attributes || typeof nodeName!=='string') { return; }
	var props = {};
	for (var i in attributes) {
		props[i.toLowerCase()] = i;
	}
	if (props.ondoubleclick) {
		attributes.ondblclick = attributes[props.ondoubleclick];
		delete attributes[props.ondoubleclick];
	}
	// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:
	if (props.onchange && (nodeName==='textarea' || (nodeName.toLowerCase()==='input' && !/^fil|che|rad/i.test(attributes.type)))) {
		var normalized = props.oninput || 'oninput';
		if (!attributes[normalized]) {
			attributes[normalized] = multihook([attributes[normalized], attributes[props.onchange]]);
			delete attributes[props.onchange];
		}
	}
}


function applyClassName(vnode) {
	var a = vnode.attributes || (vnode.attributes = {});
	classNameDescriptor.enumerable = 'className' in a;
	if (a.className) { a.class = a.className; }
	Object.defineProperty(a, 'className', classNameDescriptor);
}


var classNameDescriptor = {
	configurable: true,
	get: function() { return this.class; },
	set: function(v) { this.class = v; }
};

function extend(base, props) {
	var arguments$1 = arguments;

	for (var i=1, obj = (void 0); i<arguments.length; i++) {
		if ((obj = arguments$1[i])) {
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					base[key] = obj[key];
				}
			}
		}
	}
	return base;
}


function shallowDiffers(a, b) {
	for (var i in a) { if (!(i in b)) { return true; } }
	for (var i$1 in b) { if (a[i$1]!==b[i$1]) { return true; } }
	return false;
}


function findDOMNode(component) {
	return component && component.base || component;
}


function F(){}

function createClass(obj) {
	function cl(props, context) {
		bindAll(this);
		Component$1.call(this, props, context, BYPASS_HOOK);
		newComponentHook.call(this, props, context);
	}

	obj = extend({ constructor: cl }, obj);

	// We need to apply mixins here so that getDefaultProps is correctly mixed
	if (obj.mixins) {
		applyMixins(obj, collateMixins(obj.mixins));
	}
	if (obj.statics) {
		extend(cl, obj.statics);
	}
	if (obj.propTypes) {
		cl.propTypes = obj.propTypes;
	}
	if (obj.defaultProps) {
		cl.defaultProps = obj.defaultProps;
	}
	if (obj.getDefaultProps) {
		cl.defaultProps = obj.getDefaultProps();
	}

	F.prototype = Component$1.prototype;
	cl.prototype = extend(new F(), obj);

	cl.displayName = obj.displayName || 'Component';

	return cl;
}


// Flatten an Array of mixins to a map of method name to mixin implementations
function collateMixins(mixins) {
	var keyed = {};
	for (var i=0; i<mixins.length; i++) {
		var mixin = mixins[i];
		for (var key in mixin) {
			if (mixin.hasOwnProperty(key) && typeof mixin[key]==='function') {
				(keyed[key] || (keyed[key]=[])).push(mixin[key]);
			}
		}
	}
	return keyed;
}


// apply a mapping of Arrays of mixin methods to a component prototype
function applyMixins(proto, mixins) {
	for (var key in mixins) { if (mixins.hasOwnProperty(key)) {
		proto[key] = multihook(
			mixins[key].concat(proto[key] || ARR),
			key==='getDefaultProps' || key==='getInitialState' || key==='getChildContext'
		);
	} }
}


function bindAll(ctx) {
	for (var i in ctx) {
		var v = ctx[i];
		if (typeof v==='function' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {
			(ctx[i] = v.bind(ctx)).__bound = true;
		}
	}
}


function callMethod(ctx, m, args) {
	if (typeof m==='string') {
		m = ctx.constructor.prototype[m];
	}
	if (typeof m==='function') {
		return m.apply(ctx, args);
	}
}

function multihook(hooks, skipDuplicates) {
	return function() {
		var arguments$1 = arguments;
		var this$1 = this;

		var ret;
		for (var i=0; i<hooks.length; i++) {
			var r = callMethod(this$1, hooks[i], arguments$1);

			if (skipDuplicates && r!=null) {
				if (!ret) { ret = {}; }
				for (var key in r) { if (r.hasOwnProperty(key)) {
					ret[key] = r[key];
				} }
			}
			else if (typeof r!=='undefined') { ret = r; }
		}
		return ret;
	};
}


function newComponentHook(props, context) {
	propsHook.call(this, props, context);
	this.componentWillReceiveProps = multihook([propsHook, this.componentWillReceiveProps || 'componentWillReceiveProps']);
	this.render = multihook([propsHook, beforeRender, this.render || 'render', afterRender]);
}


function propsHook(props, context) {
	if (!props) { return; }

	// React annoyingly special-cases single children, and some react components are ridiculously strict about this.
	var c = props.children;
	if (c && Array.isArray(c) && c.length===1 && (typeof c[0]==='string' || typeof c[0]==='function' || c[0] instanceof VNode)) {
		props.children = c[0];

		// but its totally still going to be an Array.
		if (props.children && typeof props.children==='object') {
			props.children.length = 1;
			props.children[0] = props.children;
		}
	}

	// add proptype checking
	if (DEV) {
		var ctor = typeof this==='function' ? this : this.constructor,
			propTypes = this.propTypes || ctor.propTypes;
		var displayName = this.displayName || ctor.name;

		if (propTypes) {
			__WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.checkPropTypes(propTypes, props, 'prop', displayName);
		}
	}
}


function beforeRender(props) {
	currentComponent = this;
}

function afterRender() {
	if (currentComponent===this) {
		currentComponent = null;
	}
}



function Component$1(props, context, opts) {
	__WEBPACK_IMPORTED_MODULE_1_preact__["a" /* Component */].call(this, props, context);
	this.state = this.getInitialState ? this.getInitialState() : {};
	this.refs = {};
	this._refProxies = {};
	if (opts!==BYPASS_HOOK) {
		newComponentHook.call(this, props, context);
	}
}
extend(Component$1.prototype = new __WEBPACK_IMPORTED_MODULE_1_preact__["a" /* Component */](), {
	constructor: Component$1,

	isReactComponent: {},

	replaceState: function(state, callback) {
		var this$1 = this;

		this.setState(state, callback);
		for (var i in this$1.state) {
			if (!(i in state)) {
				delete this$1.state[i];
			}
		}
	},

	getDOMNode: function() {
		return this.base;
	},

	isMounted: function() {
		return !!this.base;
	}
});



function PureComponent(props, context) {
	Component$1.call(this, props, context);
}
F.prototype = Component$1.prototype;
PureComponent.prototype = new F();
PureComponent.prototype.isPureReactComponent = true;
PureComponent.prototype.shouldComponentUpdate = function(props, state) {
	return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);
};

var index = {
	version: version,
	DOM: DOM,
	PropTypes: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a,
	Children: Children,
	render: render$1,
	createClass: createClass,
	createFactory: createFactory,
	createElement: createElement,
	cloneElement: cloneElement$1,
	isValidElement: isValidElement,
	findDOMNode: findDOMNode,
	unmountComponentAtNode: unmountComponentAtNode,
	Component: Component$1,
	PureComponent: PureComponent,
	unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer,
	__spread: extend
};

/* harmony default export */ __webpack_exports__["a"] = (index);
//# sourceMappingURL=preact-compat.es.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/preact/dist/preact.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return h; });
/* unused harmony export createElement */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cloneElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return render; });
/* unused harmony export rerender */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return options; });
/** Virtual DOM Node */
function VNode() {}

/** Global options
 *	@public
 *	@namespace options {Object}
 */
var options = {

	/** If `true`, `prop` changes trigger synchronous component updates.
  *	@name syncComponentUpdates
  *	@type Boolean
  *	@default true
  */
	//syncComponentUpdates: true,

	/** Processes all created VNodes.
  *	@param {VNode} vnode	A newly-created VNode to normalize/process
  */
	//vnode(vnode) { }

	/** Hook invoked after a component is mounted. */
	// afterMount(component) { }

	/** Hook invoked after the DOM is updated with a component's latest render. */
	// afterUpdate(component) { }

	/** Hook invoked immediately before a component is unmounted. */
	// beforeUnmount(component) { }
};

var stack = [];

var EMPTY_CHILDREN = [];

/** JSX/hyperscript reviver
*	Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0
 *	@see http://jasonformat.com/wtf-is-jsx
 *	@public
 */
function h(nodeName, attributes) {
	var children = EMPTY_CHILDREN,
	    lastSimple,
	    child,
	    simple,
	    i;
	for (i = arguments.length; i-- > 2;) {
		stack.push(arguments[i]);
	}
	if (attributes && attributes.children != null) {
		if (!stack.length) stack.push(attributes.children);
		delete attributes.children;
	}
	while (stack.length) {
		if ((child = stack.pop()) && child.pop !== undefined) {
			for (i = child.length; i--;) {
				stack.push(child[i]);
			}
		} else {
			if (typeof child === 'boolean') child = null;

			if (simple = typeof nodeName !== 'function') {
				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
			}

			if (simple && lastSimple) {
				children[children.length - 1] += child;
			} else if (children === EMPTY_CHILDREN) {
				children = [child];
			} else {
				children.push(child);
			}

			lastSimple = simple;
		}
	}

	var p = new VNode();
	p.nodeName = nodeName;
	p.children = children;
	p.attributes = attributes == null ? undefined : attributes;
	p.key = attributes == null ? undefined : attributes.key;

	// if a "vnode hook" is defined, pass every created VNode to it
	if (options.vnode !== undefined) options.vnode(p);

	return p;
}

/** Copy own-properties from `props` onto `obj`.
 *	@returns obj
 *	@private
 */
function extend(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }return obj;
}

/** Call a function asynchronously, as soon as possible.
 *	@param {Function} callback
 */
var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

function cloneElement(vnode, props) {
	return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
}

// DOM properties that should NOT have "px" added when numeric
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

/** Managed queue of dirty components to be re-rendered */

var items = [];

function enqueueRender(component) {
	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
		(options.debounceRendering || defer)(rerender);
	}
}

function rerender() {
	var p,
	    list = items;
	items = [];
	while (p = list.pop()) {
		if (p._dirty) renderComponent(p);
	}
}

/** Check if two nodes are equivalent.
 *	@param {Element} node
 *	@param {VNode} vnode
 *	@private
 */
function isSameNodeType(node, vnode, hydrating) {
	if (typeof vnode === 'string' || typeof vnode === 'number') {
		return node.splitText !== undefined;
	}
	if (typeof vnode.nodeName === 'string') {
		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
	}
	return hydrating || node._componentConstructor === vnode.nodeName;
}

/** Check if an Element has a given normalized name.
*	@param {Element} node
*	@param {String} nodeName
 */
function isNamedNode(node, nodeName) {
	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}

/**
 * Reconstruct Component-style `props` from a VNode.
 * Ensures default/fallback values from `defaultProps`:
 * Own-properties of `defaultProps` not present in `vnode.attributes` are added.
 * @param {VNode} vnode
 * @returns {Object} props
 */
function getNodeProps(vnode) {
	var props = extend({}, vnode.attributes);
	props.children = vnode.children;

	var defaultProps = vnode.nodeName.defaultProps;
	if (defaultProps !== undefined) {
		for (var i in defaultProps) {
			if (props[i] === undefined) {
				props[i] = defaultProps[i];
			}
		}
	}

	return props;
}

/** Create an element with the given nodeName.
 *	@param {String} nodeName
 *	@param {Boolean} [isSvg=false]	If `true`, creates an element within the SVG namespace.
 *	@returns {Element} node
 */
function createNode(nodeName, isSvg) {
	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
	node.normalizedNodeName = nodeName;
	return node;
}

/** Remove a child node from its parent if attached.
 *	@param {Element} node		The node to remove
 */
function removeNode(node) {
	var parentNode = node.parentNode;
	if (parentNode) parentNode.removeChild(node);
}

/** Set a named attribute on the given Node, with special behavior for some names and event handlers.
 *	If `value` is `null`, the attribute/handler will be removed.
 *	@param {Element} node	An element to mutate
 *	@param {string} name	The name/key to set, such as an event or attribute name
 *	@param {any} old	The last value that was set for this name/node pair
 *	@param {any} value	An attribute value, such as a function to be used as an event handler
 *	@param {Boolean} isSvg	Are we currently diffing inside an svg?
 *	@private
 */
function setAccessor(node, name, old, value, isSvg) {
	if (name === 'className') name = 'class';

	if (name === 'key') {
		// ignore
	} else if (name === 'ref') {
		if (old) old(null);
		if (value) value(node);
	} else if (name === 'class' && !isSvg) {
		node.className = value || '';
	} else if (name === 'style') {
		if (!value || typeof value === 'string' || typeof old === 'string') {
			node.style.cssText = value || '';
		}
		if (value && typeof value === 'object') {
			if (typeof old !== 'string') {
				for (var i in old) {
					if (!(i in value)) node.style[i] = '';
				}
			}
			for (var i in value) {
				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
			}
		}
	} else if (name === 'dangerouslySetInnerHTML') {
		if (value) node.innerHTML = value.__html || '';
	} else if (name[0] == 'o' && name[1] == 'n') {
		var useCapture = name !== (name = name.replace(/Capture$/, ''));
		name = name.toLowerCase().substring(2);
		if (value) {
			if (!old) node.addEventListener(name, eventProxy, useCapture);
		} else {
			node.removeEventListener(name, eventProxy, useCapture);
		}
		(node._listeners || (node._listeners = {}))[name] = value;
	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
		setProperty(node, name, value == null ? '' : value);
		if (value == null || value === false) node.removeAttribute(name);
	} else {
		var ns = isSvg && name !== (name = name.replace(/^xlink\:?/, ''));
		if (value == null || value === false) {
			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
		} else if (typeof value !== 'function') {
			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
		}
	}
}

/** Attempt to set a DOM property to the given value.
 *	IE & FF throw for certain property-value combinations.
 */
function setProperty(node, name, value) {
	try {
		node[name] = value;
	} catch (e) {}
}

/** Proxy an event to hooked event handlers
 *	@private
 */
function eventProxy(e) {
	return this._listeners[e.type](options.event && options.event(e) || e);
}

/** Queue of components that have been mounted and are awaiting componentDidMount */
var mounts = [];

/** Diff recursion count, used to track the end of the diff cycle. */
var diffLevel = 0;

/** Global flag indicating if the diff is currently within an SVG */
var isSvgMode = false;

/** Global flag indicating if the diff is performing hydration */
var hydrating = false;

/** Invoke queued componentDidMount lifecycle methods */
function flushMounts() {
	var c;
	while (c = mounts.pop()) {
		if (options.afterMount) options.afterMount(c);
		if (c.componentDidMount) c.componentDidMount();
	}
}

/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.
 *	@param {Element} [dom=null]		A DOM node to mutate into the shape of the `vnode`
 *	@param {VNode} vnode			A VNode (with descendants forming a tree) representing the desired DOM structure
 *	@returns {Element} dom			The created/mutated element
 *	@private
 */
function diff(dom, vnode, context, mountAll, parent, componentRoot) {
	// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)
	if (!diffLevel++) {
		// when first starting the diff, check if we're diffing an SVG or within an SVG
		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

		// hydration is indicated by the existing element to be diffed not having a prop cache
		hydrating = dom != null && !('__preactattr_' in dom);
	}

	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

	// append the element if its a new parent
	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

	// diffLevel being reduced to 0 means we're exiting the diff
	if (! --diffLevel) {
		hydrating = false;
		// invoke queued componentDidMount lifecycle methods
		if (!componentRoot) flushMounts();
	}

	return ret;
}

/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */
function idiff(dom, vnode, context, mountAll, componentRoot) {
	var out = dom,
	    prevSvgMode = isSvgMode;

	// empty values (null, undefined, booleans) render as empty Text nodes
	if (vnode == null || typeof vnode === 'boolean') vnode = '';

	// Fast case: Strings & Numbers create/update Text nodes.
	if (typeof vnode === 'string' || typeof vnode === 'number') {

		// update if it's already a Text node:
		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
			/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */
			if (dom.nodeValue != vnode) {
				dom.nodeValue = vnode;
			}
		} else {
			// it wasn't a Text node: replace it with one and recycle the old Element
			out = document.createTextNode(vnode);
			if (dom) {
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
				recollectNodeTree(dom, true);
			}
		}

		out['__preactattr_'] = true;

		return out;
	}

	// If the VNode represents a Component, perform a component diff:
	var vnodeName = vnode.nodeName;
	if (typeof vnodeName === 'function') {
		return buildComponentFromVNode(dom, vnode, context, mountAll);
	}

	// Tracks entering and exiting SVG namespace when descending through the tree.
	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

	// If there's no existing element or it's the wrong type, create a new one:
	vnodeName = String(vnodeName);
	if (!dom || !isNamedNode(dom, vnodeName)) {
		out = createNode(vnodeName, isSvgMode);

		if (dom) {
			// move children into the replacement node
			while (dom.firstChild) {
				out.appendChild(dom.firstChild);
			} // if the previous Element was mounted into the DOM, replace it inline
			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

			// recycle the old element (skips non-Element node types)
			recollectNodeTree(dom, true);
		}
	}

	var fc = out.firstChild,
	    props = out['__preactattr_'],
	    vchildren = vnode.children;

	if (props == null) {
		props = out['__preactattr_'] = {};
		for (var a = out.attributes, i = a.length; i--;) {
			props[a[i].name] = a[i].value;
		}
	}

	// Optimization: fast-path for elements containing a single TextNode:
	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
		if (fc.nodeValue != vchildren[0]) {
			fc.nodeValue = vchildren[0];
		}
	}
	// otherwise, if there are existing or new children, diff them:
	else if (vchildren && vchildren.length || fc != null) {
			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
		}

	// Apply attributes/props from VNode to the DOM Element:
	diffAttributes(out, vnode.attributes, props);

	// restore previous SVG mode: (in case we're exiting an SVG namespace)
	isSvgMode = prevSvgMode;

	return out;
}

/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.
 *	@param {Element} dom			Element whose children should be compared & mutated
 *	@param {Array} vchildren		Array of VNodes to compare to `dom.childNodes`
 *	@param {Object} context			Implicitly descendant context object (from most recent `getChildContext()`)
 *	@param {Boolean} mountAll
 *	@param {Boolean} isHydrating	If `true`, consumes externally created elements similar to hydration
 */
function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
	var originalChildren = dom.childNodes,
	    children = [],
	    keyed = {},
	    keyedLen = 0,
	    min = 0,
	    len = originalChildren.length,
	    childrenLen = 0,
	    vlen = vchildren ? vchildren.length : 0,
	    j,
	    c,
	    f,
	    vchild,
	    child;

	// Build up a map of keyed children and an Array of unkeyed children:
	if (len !== 0) {
		for (var i = 0; i < len; i++) {
			var _child = originalChildren[i],
			    props = _child['__preactattr_'],
			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
			if (key != null) {
				keyedLen++;
				keyed[key] = _child;
			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
				children[childrenLen++] = _child;
			}
		}
	}

	if (vlen !== 0) {
		for (var i = 0; i < vlen; i++) {
			vchild = vchildren[i];
			child = null;

			// attempt to find a node based on key matching
			var key = vchild.key;
			if (key != null) {
				if (keyedLen && keyed[key] !== undefined) {
					child = keyed[key];
					keyed[key] = undefined;
					keyedLen--;
				}
			}
			// attempt to pluck a node of the same type from the existing children
			else if (!child && min < childrenLen) {
					for (j = min; j < childrenLen; j++) {
						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
							child = c;
							children[j] = undefined;
							if (j === childrenLen - 1) childrenLen--;
							if (j === min) min++;
							break;
						}
					}
				}

			// morph the matched/found/created DOM child to match vchild (deep)
			child = idiff(child, vchild, context, mountAll);

			f = originalChildren[i];
			if (child && child !== dom && child !== f) {
				if (f == null) {
					dom.appendChild(child);
				} else if (child === f.nextSibling) {
					removeNode(f);
				} else {
					dom.insertBefore(child, f);
				}
			}
		}
	}

	// remove unused keyed children:
	if (keyedLen) {
		for (var i in keyed) {
			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
		}
	}

	// remove orphaned unkeyed children:
	while (min <= childrenLen) {
		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
	}
}

/** Recursively recycle (or just unmount) a node and its descendants.
 *	@param {Node} node						DOM node to start unmount/removal from
 *	@param {Boolean} [unmountOnly=false]	If `true`, only triggers unmount lifecycle, skips removal
 */
function recollectNodeTree(node, unmountOnly) {
	var component = node._component;
	if (component) {
		// if node is owned by a Component, unmount that component (ends up recursing back here)
		unmountComponent(component);
	} else {
		// If the node's VNode had a ref function, invoke it with null here.
		// (this is part of the React spec, and smart for unsetting references)
		if (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);

		if (unmountOnly === false || node['__preactattr_'] == null) {
			removeNode(node);
		}

		removeChildren(node);
	}
}

/** Recollect/unmount all children.
 *	- we use .lastChild here because it causes less reflow than .firstChild
 *	- it's also cheaper than accessing the .childNodes Live NodeList
 */
function removeChildren(node) {
	node = node.lastChild;
	while (node) {
		var next = node.previousSibling;
		recollectNodeTree(node, true);
		node = next;
	}
}

/** Apply differences in attributes from a VNode to the given DOM Element.
 *	@param {Element} dom		Element with attributes to diff `attrs` against
 *	@param {Object} attrs		The desired end-state key-value attribute pairs
 *	@param {Object} old			Current/previous attributes (from previous VNode or element's prop cache)
 */
function diffAttributes(dom, attrs, old) {
	var name;

	// remove attributes no longer present on the vnode by setting them to undefined
	for (name in old) {
		if (!(attrs && attrs[name] != null) && old[name] != null) {
			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
		}
	}

	// add new & update changed attributes
	for (name in attrs) {
		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
		}
	}
}

/** Retains a pool of Components for re-use, keyed on component name.
 *	Note: since component names are not unique or even necessarily available, these are primarily a form of sharding.
 *	@private
 */
var components = {};

/** Reclaim a component for later re-use by the recycler. */
function collectComponent(component) {
	var name = component.constructor.name;
	(components[name] || (components[name] = [])).push(component);
}

/** Create a component. Normalizes differences between PFC's and classful Components. */
function createComponent(Ctor, props, context) {
	var list = components[Ctor.name],
	    inst;

	if (Ctor.prototype && Ctor.prototype.render) {
		inst = new Ctor(props, context);
		Component.call(inst, props, context);
	} else {
		inst = new Component(props, context);
		inst.constructor = Ctor;
		inst.render = doRender;
	}

	if (list) {
		for (var i = list.length; i--;) {
			if (list[i].constructor === Ctor) {
				inst.nextBase = list[i].nextBase;
				list.splice(i, 1);
				break;
			}
		}
	}
	return inst;
}

/** The `.render()` method for a PFC backing instance. */
function doRender(props, state, context) {
	return this.constructor(props, context);
}

/** Set a component's `props` (generally derived from JSX attributes).
 *	@param {Object} props
 *	@param {Object} [opts]
 *	@param {boolean} [opts.renderSync=false]	If `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.
 *	@param {boolean} [opts.render=true]			If `false`, no render will be triggered.
 */
function setComponentProps(component, props, opts, context, mountAll) {
	if (component._disable) return;
	component._disable = true;

	if (component.__ref = props.ref) delete props.ref;
	if (component.__key = props.key) delete props.key;

	if (!component.base || mountAll) {
		if (component.componentWillMount) component.componentWillMount();
	} else if (component.componentWillReceiveProps) {
		component.componentWillReceiveProps(props, context);
	}

	if (context && context !== component.context) {
		if (!component.prevContext) component.prevContext = component.context;
		component.context = context;
	}

	if (!component.prevProps) component.prevProps = component.props;
	component.props = props;

	component._disable = false;

	if (opts !== 0) {
		if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
			renderComponent(component, 1, mountAll);
		} else {
			enqueueRender(component);
		}
	}

	if (component.__ref) component.__ref(component);
}

/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.
 *	@param {Component} component
 *	@param {Object} [opts]
 *	@param {boolean} [opts.build=false]		If `true`, component will build and store a DOM node if not already associated with one.
 *	@private
 */
function renderComponent(component, opts, mountAll, isChild) {
	if (component._disable) return;

	var props = component.props,
	    state = component.state,
	    context = component.context,
	    previousProps = component.prevProps || props,
	    previousState = component.prevState || state,
	    previousContext = component.prevContext || context,
	    isUpdate = component.base,
	    nextBase = component.nextBase,
	    initialBase = isUpdate || nextBase,
	    initialChildComponent = component._component,
	    skip = false,
	    rendered,
	    inst,
	    cbase;

	// if updating
	if (isUpdate) {
		component.props = previousProps;
		component.state = previousState;
		component.context = previousContext;
		if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
			skip = true;
		} else if (component.componentWillUpdate) {
			component.componentWillUpdate(props, state, context);
		}
		component.props = props;
		component.state = state;
		component.context = context;
	}

	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
	component._dirty = false;

	if (!skip) {
		rendered = component.render(props, state, context);

		// context to pass to the child, can be updated via (grand-)parent component
		if (component.getChildContext) {
			context = extend(extend({}, context), component.getChildContext());
		}

		var childComponent = rendered && rendered.nodeName,
		    toUnmount,
		    base;

		if (typeof childComponent === 'function') {
			// set up high order component link

			var childProps = getNodeProps(rendered);
			inst = initialChildComponent;

			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
				setComponentProps(inst, childProps, 1, context, false);
			} else {
				toUnmount = inst;

				component._component = inst = createComponent(childComponent, childProps, context);
				inst.nextBase = inst.nextBase || nextBase;
				inst._parentComponent = component;
				setComponentProps(inst, childProps, 0, context, false);
				renderComponent(inst, 1, mountAll, true);
			}

			base = inst.base;
		} else {
			cbase = initialBase;

			// destroy high order component link
			toUnmount = initialChildComponent;
			if (toUnmount) {
				cbase = component._component = null;
			}

			if (initialBase || opts === 1) {
				if (cbase) cbase._component = null;
				base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
			}
		}

		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
			var baseParent = initialBase.parentNode;
			if (baseParent && base !== baseParent) {
				baseParent.replaceChild(base, initialBase);

				if (!toUnmount) {
					initialBase._component = null;
					recollectNodeTree(initialBase, false);
				}
			}
		}

		if (toUnmount) {
			unmountComponent(toUnmount);
		}

		component.base = base;
		if (base && !isChild) {
			var componentRef = component,
			    t = component;
			while (t = t._parentComponent) {
				(componentRef = t).base = base;
			}
			base._component = componentRef;
			base._componentConstructor = componentRef.constructor;
		}
	}

	if (!isUpdate || mountAll) {
		mounts.unshift(component);
	} else if (!skip) {
		// Ensure that pending componentDidMount() hooks of child components
		// are called before the componentDidUpdate() hook in the parent.
		// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750
		// flushMounts();

		if (component.componentDidUpdate) {
			component.componentDidUpdate(previousProps, previousState, previousContext);
		}
		if (options.afterUpdate) options.afterUpdate(component);
	}

	if (component._renderCallbacks != null) {
		while (component._renderCallbacks.length) {
			component._renderCallbacks.pop().call(component);
		}
	}

	if (!diffLevel && !isChild) flushMounts();
}

/** Apply the Component referenced by a VNode to the DOM.
 *	@param {Element} dom	The DOM node to mutate
 *	@param {VNode} vnode	A Component-referencing VNode
 *	@returns {Element} dom	The created/mutated element
 *	@private
 */
function buildComponentFromVNode(dom, vnode, context, mountAll) {
	var c = dom && dom._component,
	    originalComponent = c,
	    oldDom = dom,
	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
	    isOwner = isDirectOwner,
	    props = getNodeProps(vnode);
	while (c && !isOwner && (c = c._parentComponent)) {
		isOwner = c.constructor === vnode.nodeName;
	}

	if (c && isOwner && (!mountAll || c._component)) {
		setComponentProps(c, props, 3, context, mountAll);
		dom = c.base;
	} else {
		if (originalComponent && !isDirectOwner) {
			unmountComponent(originalComponent);
			dom = oldDom = null;
		}

		c = createComponent(vnode.nodeName, props, context);
		if (dom && !c.nextBase) {
			c.nextBase = dom;
			// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:
			oldDom = null;
		}
		setComponentProps(c, props, 1, context, mountAll);
		dom = c.base;

		if (oldDom && dom !== oldDom) {
			oldDom._component = null;
			recollectNodeTree(oldDom, false);
		}
	}

	return dom;
}

/** Remove a component from the DOM and recycle it.
 *	@param {Component} component	The Component instance to unmount
 *	@private
 */
function unmountComponent(component) {
	if (options.beforeUnmount) options.beforeUnmount(component);

	var base = component.base;

	component._disable = true;

	if (component.componentWillUnmount) component.componentWillUnmount();

	component.base = null;

	// recursively tear down & recollect high-order component children:
	var inner = component._component;
	if (inner) {
		unmountComponent(inner);
	} else if (base) {
		if (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);

		component.nextBase = base;

		removeNode(base);
		collectComponent(component);

		removeChildren(base);
	}

	if (component.__ref) component.__ref(null);
}

/** Base Component class.
 *	Provides `setState()` and `forceUpdate()`, which trigger rendering.
 *	@public
 *
 *	@example
 *	class MyFoo extends Component {
 *		render(props, state) {
 *			return <div />;
 *		}
 *	}
 */
function Component(props, context) {
	this._dirty = true;

	/** @public
  *	@type {object}
  */
	this.context = context;

	/** @public
  *	@type {object}
  */
	this.props = props;

	/** @public
  *	@type {object}
  */
	this.state = this.state || {};
}

extend(Component.prototype, {

	/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.
  *	@param {object} nextProps
  *	@param {object} nextState
  *	@param {object} nextContext
  *	@returns {Boolean} should the component re-render
  *	@name shouldComponentUpdate
  *	@function
  */

	/** Update component state by copying properties from `state` to `this.state`.
  *	@param {object} state		A hash of state properties to update with new values
  *	@param {function} callback	A function to be called once component state is updated
  */
	setState: function setState(state, callback) {
		var s = this.state;
		if (!this.prevState) this.prevState = extend({}, s);
		extend(s, typeof state === 'function' ? state(s, this.props) : state);
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		enqueueRender(this);
	},


	/** Immediately perform a synchronous re-render of the component.
  *	@param {function} callback		A function to be called after component is re-rendered.
  *	@private
  */
	forceUpdate: function forceUpdate(callback) {
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		renderComponent(this, 2);
	},


	/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
  *	Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
  *	@param {object} props		Props (eg: JSX attributes) received from parent element/component
  *	@param {object} state		The component's current state
  *	@param {object} context		Context object (if a parent component has provided context)
  *	@returns VNode
  */
	render: function render() {}
});

/** Render JSX into a `parent` Element.
 *	@param {VNode} vnode		A (JSX) VNode to render
 *	@param {Element} parent		DOM element to render into
 *	@param {Element} [merge]	Attempt to re-use an existing DOM tree rooted at `merge`
 *	@public
 *
 *	@example
 *	// render a div into <body>:
 *	render(<div id="hello">hello!</div>, document.body);
 *
 *	@example
 *	// render a "Thing" component into #foo:
 *	const Thing = ({ name }) => <span>{ name }</span>;
 *	render(<Thing name="one" />, document.querySelector('#foo'));
 */
function render(vnode, parent, merge) {
  return diff(merge, vnode, {}, false, parent, false);
}

var preact = {
	h: h,
	createElement: h,
	cloneElement: cloneElement,
	Component: Component,
	render: render,
	rerender: rerender,
	options: options
};

/* unused harmony default export */ var _unused_webpack_default_export = (preact);
//# sourceMappingURL=preact.esm.js.map


/***/ }),

/***/ "../../node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/prop-types/factoryWithThrowingShims.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__("../../node_modules/fbjs/lib/emptyFunction.js");
var invariant = __webpack_require__("../../node_modules/fbjs/lib/invariant.js");
var ReactPropTypesSecret = __webpack_require__("../../node_modules/prop-types/lib/ReactPropTypesSecret.js");

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("../../node_modules/prop-types/factoryWithThrowingShims.js")();
}


/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../../node_modules/react-router/node_modules/isarray/index.js":
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../../node_modules/react-router/node_modules/path-to-regexp/index.js":
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__("../../node_modules/react-router/node_modules/isarray/index.js")

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),

/***/ "../../node_modules/resolve-pathname/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);

/***/ }),

/***/ "../../node_modules/style-loader/lib/addStyles.js":
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__("../../node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "../../node_modules/style-loader/lib/urls.js":
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "../../node_modules/svg-inline-loader/index.js?removeTags=true&removeSVGTagAttrs=true!./images/cube.svg":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 23 27\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"MVP\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"><g id=\"linkStatus2\" transform=\"translate(-899.000000, -638.000000)\" fill=\"#1B2437\"><g id=\"Group-6\" transform=\"translate(655.000000, 631.000000)\"><path d=\"M255.452,6.9992 L244,15.8152 L244,24.4682 L255.452,33.2842 L266.904,24.4682 L266.904,15.8152 L255.452,6.9992 Z M259.874,18.1372 L256.224,15.3282 L256.224,9.7032 L264.761,16.2742 L261.261,18.9702 L258.965,20.7392 L258.963,20.7372 L255.452,23.4412 L252.4,21.0922 L251.031,22.1462 L254.679,24.9562 L254.679,30.5812 L246.142,24.0092 L249.796,21.1962 L251.941,19.5442 L251.941,19.5452 L255.452,16.8422 L258.504,19.1912 L259.874,18.1372 Z M248.562,18.1372 L246.142,16.2742 L254.679,9.7032 L254.679,15.3282 L249.796,19.0872 L248.427,20.1412 L248.381,20.1772 L247.652,20.7382 L245.546,22.3592 L245.546,17.9232 L247.193,19.1902 L248.562,18.1372 Z M256.224,24.9562 L261.108,21.1962 L263.081,19.6762 L265.358,17.9232 L265.358,22.3592 L263.711,21.0922 L262.342,22.1462 L264.761,24.0092 L256.224,30.5812 L256.224,24.9562 Z\" id=\"Page-1\"></path></g></g></g></svg>"

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/adsList.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".adsList__self--1COj9 .adsList__row--2eM5f{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.adsList__self--1COj9 .adsList__button--o-Cn8{margin-left:auto}", "", {"version":3,"sources":["/apps/packages/components/src/adsList.scss"],"names":[],"mappings":"AAAA,2CAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,YAAY,CAAC,8CAAc,gBAAgB,CAAC","file":"adsList.scss","sourcesContent":[".self .row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.self .button{margin-left:auto}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "adsList__self--1COj9",
	"row": "adsList__row--2eM5f",
	"button": "adsList__button--o-Cn8"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/button.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".button__self--1HBVs{border:none;outline:none;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#263fff;letter-spacing:.01em}.button__self--1HBVs.button__primary--2mrKv{font-weight:300;color:#fff;font-size:15px;border-radius:3px;padding:13px 25px!important}.button__self--1HBVs.button__secondary--2Imox{float:right;background-color:#cfd9fa;border-radius:50px;color:#263fff;height:20px;text-align:center;font-size:12px;font-weight:700;-webkit-box-shadow:0 5px 12px rgba(184,188,206,.5);box-shadow:0 5px 12px rgba(184,188,206,.5)}.button__self--1HBVs.button__secondary--2Imox:disabled{background-color:#89939f;opacity:.4;cursor:not-allowed;color:#fff}.button__self--1HBVs.button__secondary--2Imox:not([disabled]):hover{-webkit-transform:translateY(-2px);transform:translateY(-2px)}.button__self--1HBVs:disabled{background-color:#89939f;opacity:.4;cursor:not-allowed;color:#fff}.button__self--1HBVs:not([disabled]):hover{cursor:pointer;color:#fff;background-color:#263fff;-webkit-box-shadow:0 5px 15px rgba(50,93,255,.45);box-shadow:0 5px 15px rgba(50,93,255,.45);-webkit-transform:translateY(-1px);transform:translateY(-1px)}.button__self--1HBVs:active{background-color:#263fff}", "", {"version":3,"sources":["/apps/packages/components/src/button.scss"],"names":[],"mappings":"AAAA,qBAAM,YAAY,aAAa,oBAAsB,mCAAmC,kCAAkC,yBAAyB,oBAAqB,CAAC,4CAAc,gBAAgB,WAAW,eAAe,kBAAkB,2BAA4B,CAAC,8CAAgB,YAAY,yBAAyB,mBAAmB,cAAc,YAAY,kBAAkB,eAAe,gBAAgB,mDAAsD,0CAA6C,CAAC,uDAAyB,yBAAyB,WAAY,mBAAmB,UAAU,CAAC,oEAAsC,mCAAmC,0BAA0B,CAAC,8BAAe,yBAAyB,WAAY,mBAAmB,UAAU,CAAC,2CAA4B,eAAe,WAAW,yBAAyB,kDAAqD,0CAA6C,mCAAmC,0BAA0B,CAAC,4BAAa,wBAAwB,CAAC","file":"button.scss","sourcesContent":[".self{border:none;outline:none;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#263fff;letter-spacing:0.01em}.self.primary{font-weight:300;color:#fff;font-size:15px;border-radius:3px;padding:13px 25px !important}.self.secondary{float:right;background-color:#cfd9fa;border-radius:50px;color:#263fff;height:20px;text-align:center;font-size:12px;font-weight:700;-webkit-box-shadow:0px 5px 12px rgba(184,188,206,0.5);box-shadow:0px 5px 12px rgba(184,188,206,0.5)}.self.secondary:disabled{background-color:#89939f;opacity:0.4;cursor:not-allowed;color:#fff}.self.secondary:not([disabled]):hover{-webkit-transform:translateY(-2px);transform:translateY(-2px)}.self:disabled{background-color:#89939f;opacity:0.4;cursor:not-allowed;color:#fff}.self:not([disabled]):hover{cursor:pointer;color:#fff;background-color:#263fff;-webkit-box-shadow:0px 5px 15px rgba(50,93,255,0.45);box-shadow:0px 5px 15px rgba(50,93,255,0.45);-webkit-transform:translateY(-1px);transform:translateY(-1px)}.self:active{background-color:#263fff}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "button__self--1HBVs",
	"primary": "button__primary--2mrKv",
	"secondary": "button__secondary--2Imox"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/icon.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".icon__self--1htNH{font-size:.8em}", "", {"version":3,"sources":["/apps/packages/components/src/icon.scss"],"names":[],"mappings":"AAAA,mBAAM,cAAe,CAAC","file":"icon.scss","sourcesContent":[".self{font-size:0.8em}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "icon__self--1htNH"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/input.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".input__self--Sta6U{position:relative;margin-bottom:20px;margin-top:20px;width:100%;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-transition:none!important;transition:none!important}.input__self--Sta6U .input__input--1h6KM{font-size:14px;padding:15px;width:calc(100% - 30px);background-color:#f5f7fa;border:1px solid #eef1f2;border-radius:3px;-webkit-box-shadow:none;box-shadow:none}.input__self--Sta6U .input__input--1h6KM:focus{outline:none;border:1px solid #263fff;background-color:#fff}.input__self--Sta6U .input__input--1h6KM:-moz-placeholder{box-shadow:none!important}.input__self--Sta6U.input__invalid--3Vmho{margin-bottom:calc(30px - 1em)}.input__self--Sta6U.input__invalid--3Vmho>.input__input--1h6KM{-webkit-box-shadow:0 0 5px 1px red;box-shadow:0 0 5px 1px red}.input__self--Sta6U .input__placeholder--26K8y{position:absolute;top:20px;left:14px;color:#89939f;font-size:14px;-webkit-transition:.2s;transition:.2s}.input__self--Sta6U .input__input--1h6KM:disabled~.input__placeholder--26K8y,.input__self--Sta6U .input__input--1h6KM:focus~.input__placeholder--26K8y,.input__self--Sta6U .input__input--1h6KM:valid~.input__placeholder--26K8y{color:#1b2437;font-size:11px;top:-16px;left:0}.input__self--Sta6U .input__error--3mUo8{display:block;color:red;height:1em;font-size:.8em;font-weight:600}", "", {"version":3,"sources":["/apps/packages/components/src/input.scss"],"names":[],"mappings":"AAAA,oBAAM,kBAAkB,mBAAmB,gBAAgB,WAAW,oBAAsB,mCAAmC,kCAAkC,kCAAmC,yBAA0B,CAAC,yCAAa,eAAe,aAAa,wBAAwB,yBAAyB,yBAAyB,kBAAkB,wBAAwB,eAAe,CAAC,+CAAmB,aAAa,yBAAyB,qBAAqB,CAAC,0DAA8B,yBAA0B,CAAC,0CAAc,8BAA8B,CAAC,+DAAqB,mCAAmC,0BAA0B,CAAC,+CAAmB,kBAAkB,SAAS,UAAU,cAAc,eAAe,uBAAwB,cAAe,CAAC,iOAAyG,cAAc,eAAe,UAAU,MAAQ,CAAC,yCAAa,cAAc,UAAU,WAAW,eAAgB,eAAe,CAAC","file":"input.scss","sourcesContent":[".self{position:relative;margin-bottom:20px;margin-top:20px;width:100%;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-transition:none !important;transition:none !important}.self .input{font-size:14px;padding:15px;width:calc(100% - 30px);background-color:#f5f7fa;border:1px solid #eef1f2;border-radius:3px;-webkit-box-shadow:none;box-shadow:none}.self .input:focus{outline:none;border:1px solid #263fff;background-color:#fff}.self .input:-moz-placeholder{box-shadow:none !important}.self.invalid{margin-bottom:calc(30px - 1em)}.self.invalid>.input{-webkit-box-shadow:0 0 5px 1px red;box-shadow:0 0 5px 1px red}.self .placeholder{position:absolute;top:20px;left:14px;color:#89939f;font-size:14px;-webkit-transition:0.2s;transition:0.2s}.self .input:focus ~ .placeholder,.self .input:valid ~ .placeholder,.self .input:disabled ~ .placeholder{color:#1b2437;font-size:11px;top:-16px;left:0px}.self .error{display:block;color:red;height:1em;font-size:0.8em;font-weight:600}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "input__self--Sta6U",
	"input": "input__input--1h6KM",
	"invalid": "input__invalid--3Vmho",
	"placeholder": "input__placeholder--26K8y",
	"error": "input__error--3mUo8"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/label.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".label__self--33pBu{font-size:15px;text-align:left;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#89939f}", "", {"version":3,"sources":["/apps/packages/components/src/label.scss"],"names":[],"mappings":"AAAA,oBAAM,eAAe,gBAAgB,oBAAsB,mCAAmC,kCAAkC,aAAa,CAAC","file":"label.scss","sourcesContent":[".self{font-size:15px;text-align:left;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#89939f}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "label__self--33pBu"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/link.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".link__self--2lLaL{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:75%;font-weight:300}.link__self--2lLaL .link__title--3Whqu{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#263fff;font-weight:700;font-size:1.2em;-ms-flex-negative:0;flex-shrink:0}.link__self--2lLaL .link__header--DbUQP{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.link__self--2lLaL .link__summary--3-V2C{color:#545454}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ{overflow:hidden;position:relative;line-height:1.2em;max-height:2.4em;text-align:justify}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ:before{content:\"...\";position:absolute;right:0;bottom:0;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ:after{content:\"\";position:absolute;right:0;width:1em;height:1em;margin-top:.2em;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8{overflow:hidden;position:relative;line-height:1.2em;max-height:9.6em;text-align:justify}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8:before{content:\"...\";position:absolute;right:0;bottom:0;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8:after{content:\"\";position:absolute;right:0;width:1em;height:1em;margin-top:.2em;background-color:#fff}.link__self--2lLaL .link__footer--3lI90{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.link__self--2lLaL .link__link--2-AZ1{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#006621;font-size:.8em;-ms-flex-negative:0;flex-shrink:0;outline:none}.link__self--2lLaL .link__link--2-AZ1:link,.link__self--2lLaL .link__link--2-AZ1:visited{text-decoration:none}", "", {"version":3,"sources":["/apps/packages/components/src/link.scss"],"names":[],"mappings":"AAAA,mBAAM,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,cAAc,eAAe,CAAC,uCAAa,mBAAmB,gBAAgB,uBAAuB,cAAc,gBAAgB,gBAAgB,oBAAoB,aAAa,CAAC,wCAAc,yBAAyB,sBAAsB,6BAA6B,CAAC,yCAAe,aAAa,CAAC,6DAAsB,gBAAgB,kBAAkB,kBAAkB,iBAAiB,kBAAkB,CAAC,oEAA6B,cAAc,kBAAkB,QAAQ,SAAS,qBAAqB,CAAC,mEAA4B,WAAW,kBAAkB,QAAQ,UAAU,WAAW,gBAAiB,qBAAqB,CAAC,6DAAsB,gBAAgB,kBAAkB,kBAAkB,iBAAiB,kBAAkB,CAAC,oEAA6B,cAAc,kBAAkB,QAAQ,SAAS,qBAAqB,CAAC,mEAA4B,WAAW,kBAAkB,QAAQ,UAAU,WAAW,gBAAiB,qBAAqB,CAAC,wCAAc,sBAAsB,mBAAmB,qBAAqB,yBAAyB,sBAAsB,6BAA6B,CAAC,sCAAY,cAAc,mBAAmB,gBAAgB,uBAAuB,cAAc,eAAgB,oBAAoB,cAAc,YAAY,CAAC,AAAsC,yFAAoB,oBAAoB,CAAC","file":"link.scss","sourcesContent":[".self{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:75%;font-weight:300}.self .title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#263fff;font-weight:700;font-size:1.2em;-ms-flex-negative:0;flex-shrink:0}.self .header{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.self .summary{color:#545454}.self .summary.lines2{overflow:hidden;position:relative;line-height:1.2em;max-height:2.4em;text-align:justify}.self .summary.lines2:before{content:'...';position:absolute;right:0;bottom:0;background-color:#fff}.self .summary.lines2:after{content:'';position:absolute;right:0;width:1em;height:1em;margin-top:0.2em;background-color:#fff}.self .summary.lines8{overflow:hidden;position:relative;line-height:1.2em;max-height:9.6em;text-align:justify}.self .summary.lines8:before{content:'...';position:absolute;right:0;bottom:0;background-color:#fff}.self .summary.lines8:after{content:'';position:absolute;right:0;width:1em;height:1em;margin-top:0.2em;background-color:#fff}.self .footer{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.self .link{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#006621;font-size:0.8em;-ms-flex-negative:0;flex-shrink:0;outline:none}.self .link:link{text-decoration:none}.self .link:visited{text-decoration:none}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "link__self--2lLaL",
	"title": "link__title--3Whqu",
	"header": "link__header--DbUQP",
	"summary": "link__summary--3-V2C",
	"lines2": "link__lines2--IX2SJ",
	"lines8": "link__lines8--3BXj8",
	"footer": "link__footer--3lI90",
	"link": "link__link--2-AZ1"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/linkList.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".linkList__self--Y8QOq .linkList__row--LxprX{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.linkList__self--Y8QOq .linkList__button--elz1X{margin-left:auto}", "", {"version":3,"sources":["/apps/packages/components/src/linkList.scss"],"names":[],"mappings":"AAAA,6CAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,YAAY,CAAC,gDAAc,gBAAgB,CAAC","file":"linkList.scss","sourcesContent":[".self .row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.self .button{margin-left:auto}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "linkList__self--Y8QOq",
	"row": "linkList__row--LxprX",
	"button": "linkList__button--elz1X"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/loader.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".loader__self--2U9as{border:1px solid #eef1f2;border-top:1px solid #263fff;border-radius:50%;width:40px;height:40px;-webkit-animation:loader__spin--1Wsm2 2s linear infinite;animation:loader__spin--1Wsm2 2s linear infinite}@-webkit-keyframes loader__spin--1Wsm2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes loader__spin--1Wsm2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}", "", {"version":3,"sources":["/apps/packages/components/src/loader.scss"],"names":[],"mappings":"AAAA,qBAAM,yBAAyB,6BAA6B,kBAAkB,WAAW,YAAY,yDAA0C,gDAAiC,CAAC,uCAAwB,GAAG,+BAA+B,sBAAsB,CAAC,GAAK,gCAAiC,uBAAwB,CAAC,CAAC,+BAAgB,GAAG,+BAA+B,sBAAsB,CAAC,GAAK,gCAAiC,uBAAwB,CAAC,CAAC","file":"loader.scss","sourcesContent":[".self{border:1px solid #eef1f2;border-top:1px solid #263fff;border-radius:50%;width:40px;height:40px;-webkit-animation:spin 2s linear infinite;animation:spin 2s linear infinite}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "loader__self--2U9as",
	"spin": "loader__spin--1Wsm2"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/paper.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".paper__self--1qtNi{-webkit-box-flex:1;-ms-flex:1;flex:1;background-color:#fff;-webkit-box-shadow:0 5px 20px 0 rgba(19,38,110,.08);box-shadow:0 5px 20px 0 rgba(19,38,110,.08);margin-top:20px;border-radius:3px}", "", {"version":3,"sources":["/apps/packages/components/src/paper.scss"],"names":[],"mappings":"AAAA,oBAAM,mBAAmB,WAAW,OAAO,sBAAsB,oDAAyD,4CAAiD,gBAAgB,iBAAiB,CAAC","file":"paper.scss","sourcesContent":[".self{-webkit-box-flex:1;-ms-flex:1;flex:1;background-color:#fff;-webkit-box-shadow:0px 5px 20px 0px rgba(19,38,110,0.08);box-shadow:0px 5px 20px 0px rgba(19,38,110,0.08);margin-top:20px;border-radius:3px}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "paper__self--1qtNi"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/textWithLabel.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".textWithLabel__self--3SeBK{padding:1em}.textWithLabel__self--3SeBK .textWithLabel__text--2lMFz{margin-top:5px;font-size:15px;color:#1b2437;text-align:left;overflow:hidden;word-wrap:nowrap;text-overflow:ellipsis}", "", {"version":3,"sources":["/apps/packages/components/src/textWithLabel.scss"],"names":[],"mappings":"AAAA,4BAAM,WAAW,CAAC,wDAAY,eAAe,eAAe,cAAc,gBAAgB,gBAAgB,iBAAiB,sBAAsB,CAAC","file":"textWithLabel.scss","sourcesContent":[".self{padding:1em}.self .text{margin-top:5px;font-size:15px;color:#1b2437;text-align:left;overflow:hidden;word-wrap:nowrap;text-overflow:ellipsis}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "textWithLabel__self--3SeBK",
	"text": "textWithLabel__text--2lMFz"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/tooltip.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".tooltip__self--2h8p3{position:relative}.tooltip__self--2h8p3 .tooltip__text--1cz4e{visibility:hidden;width:120px;background-color:#1b2437;color:#fff;text-align:center;padding:5px 0;border-radius:6px;position:absolute;-webkit-transition-delay:0s;transition-delay:0s}.tooltip__self--2h8p3:hover .tooltip__text--1cz4e{visibility:visible;-webkit-transition-delay:.5s;transition-delay:.5s}", "", {"version":3,"sources":["/apps/packages/components/src/tooltip.scss"],"names":[],"mappings":"AAAA,sBAAM,iBAAiB,CAAC,4CAAY,kBAAkB,YAAY,yBAAyB,WAAW,kBAAkB,cAAc,kBAAkB,kBAAkB,4BAA4B,mBAAmB,CAAC,kDAAkB,mBAAmB,6BAA8B,oBAAqB,CAAC","file":"tooltip.scss","sourcesContent":[".self{position:relative}.self .text{visibility:hidden;width:120px;background-color:#1b2437;color:#fff;text-align:center;padding:5px 0;border-radius:6px;position:absolute;-webkit-transition-delay:0s;transition-delay:0s}.self:hover .text{visibility:visible;-webkit-transition-delay:0.5s;transition-delay:0.5s}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "tooltip__self--2h8p3",
	"text": "tooltip__text--1cz4e"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/Status.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".Status__self--2jtwo{width:100vw;height:100vh;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;background-color:#f5f7fa}.Status__self--2jtwo .Status__introduction--1RysH{padding-bottom:30px;border-bottom:1px solid #eef1f2}.Status__self--2jtwo .Status__introduction--1RysH h2{font-size:15px;font-weight:300}.Status__self--2jtwo .Status__introduction--1RysH p{font-size:15px;color:#89939f;-webkit-font-smoothing:antialiased}.Status__self--2jtwo .Status__info--2Ax2h{padding-top:30px}@media screen and (max-width:1200px){.Status__self--2jtwo{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center}}.Status__self--2jtwo .Status__preview--1IUV0{width:300px;height:250px;margin-right:30px;margin-top:0;padding:10px;-webkit-box-flex:1;-ms-flex:auto;flex:auto;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:1200px){.Status__self--2jtwo .Status__preview--1IUV0{width:calc(100vw - 20px);height:unset;margin:0;margin-bottom:20px}}.Status__self--2jtwo .Status__preview-title--2MSaj{color:#89939f;margin-bottom:20px;margin-top:150px}@media screen and (max-width:1200px){.Status__self--2jtwo .Status__preview-title--2MSaj{margin-top:10px}}.Status__self--2jtwo .Status__loader--2FksP{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.Status__self--2jtwo .Status__content--1RuY7{text-align:center;max-width:35vw;padding:30px}@media screen and (max-width:1200px){.Status__self--2jtwo .Status__content--1RuY7{max-width:calc(100vw - 20px);margin:0}}.Status__self--2jtwo .Status__label--lGQpY{width:100%;padding:0;margin-top:-1em}.Status__self--2jtwo .Status__label--lGQpY:nth-child(2){padding-top:15px;padding-bottom:10px;border-bottom:1px solid #eef1f2}.Status__self--2jtwo .Status__link-label--2cc5d{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.Status__self--2jtwo .Status__link--2WauU{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#263fff;text-decoration:none}.Status__self--2jtwo .Status__add-bookmark--H6_JK{-webkit-box-flex:1;-ms-flex:auto;flex:auto;-ms-flex-negative:0;flex-shrink:0}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Status/Status.scss"],"names":[],"mappings":"AAAA,qBAAM,YAAY,aAAa,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,wBAAwB,qBAAqB,uBAAuB,wBAAwB,qBAAqB,uBAAuB,wBAAwB,CAAC,kDAAoB,oBAAoB,+BAA+B,CAAC,qDAAuB,eAAe,eAAe,CAAC,oDAAsB,eAAe,cAAc,kCAAkC,CAAC,0CAAY,gBAAgB,CAAC,qCAAsC,qBAAM,4BAA4B,6BAA6B,0BAA0B,sBAAsB,uBAAuB,oBAAoB,2BAA2B,yBAAyB,sBAAsB,kBAAkB,CAAC,CAAC,6CAAe,YAAY,aAAa,kBAAkB,aAAa,aAAa,mBAAmB,cAAc,UAAU,mBAAmB,oBAAoB,YAAY,oBAAoB,cAAc,oBAAoB,oBAAoB,aAAa,yBAAyB,sBAAsB,kBAAkB,CAAC,qCAAsC,6CAAe,yBAAyB,aAAa,SAAS,kBAAkB,CAAC,CAAC,mDAAqB,cAAc,mBAAmB,gBAAgB,CAAC,qCAAsC,mDAAqB,eAAe,CAAC,CAAC,4CAAc,WAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,6CAAe,kBAAkB,eAAe,YAAY,CAAC,qCAAsC,6CAAe,6BAA6B,QAAQ,CAAC,CAAC,2CAAa,WAAW,UAAU,eAAe,CAAC,wDAA0B,iBAAiB,oBAAoB,+BAA+B,CAAC,gDAAkB,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,kBAAkB,CAAC,0CAAY,gBAAgB,uBAAuB,mBAAmB,cAAc,oBAAoB,CAAC,kDAAoB,mBAAmB,cAAc,UAAU,oBAAoB,aAAa,CAAC","file":"Status.scss","sourcesContent":[".self{width:100vw;height:100vh;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;background-color:#f5f7fa}.self .introduction{padding-bottom:30px;border-bottom:1px solid #eef1f2}.self .introduction h2{font-size:15px;font-weight:300}.self .introduction p{font-size:15px;color:#89939f;-webkit-font-smoothing:antialiased}.self .info{padding-top:30px}@media screen and (max-width: 1200px){.self{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center}}.self .preview{width:300px;height:250px;margin-right:30px;margin-top:0;padding:10px;-webkit-box-flex:1;-ms-flex:auto;flex:auto;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width: 1200px){.self .preview{width:calc(100vw - 20px);height:unset;margin:0;margin-bottom:20px}}.self .preview-title{color:#89939f;margin-bottom:20px;margin-top:150px}@media screen and (max-width: 1200px){.self .preview-title{margin-top:10px}}.self .loader{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .content{text-align:center;max-width:35vw;padding:30px}@media screen and (max-width: 1200px){.self .content{max-width:calc(100vw - 20px);margin:0}}.self .label{width:100%;padding:0;margin-top:-1em}.self .label:nth-child(2){padding-top:15px;padding-bottom:10px;border-bottom:1px solid #eef1f2}.self .link-label{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.self .link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#263fff;text-decoration:none}.self .add-bookmark{-webkit-box-flex:1;-ms-flex:auto;flex:auto;-ms-flex-negative:0;flex-shrink:0}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "Status__self--2jtwo",
	"introduction": "Status__introduction--1RysH",
	"info": "Status__info--2Ax2h",
	"preview": "Status__preview--1IUV0",
	"preview-title": "Status__preview-title--2MSaj",
	"previewTitle": "Status__preview-title--2MSaj",
	"loader": "Status__loader--2FksP",
	"content": "Status__content--1RuY7",
	"label": "Status__label--lGQpY",
	"link-label": "Status__link-label--2cc5d",
	"linkLabel": "Status__link-label--2cc5d",
	"link": "Status__link--2WauU",
	"add-bookmark": "Status__add-bookmark--H6_JK",
	"addBookmark": "Status__add-bookmark--H6_JK"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/components/steps.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, "@-webkit-keyframes steps__waiting--ZH46m{0%{opacity:.5}50%{opacity:1}to{opacity:.5}}.steps__self--3KyHm{position:relative;width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-top:30px}@media screen and (max-width:1200px){.steps__self--3KyHm{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}}.steps__self--3KyHm .steps__progress-cotainer--1m2lP{position:relative}.steps__self--3KyHm .steps__progress--32faB{position:absolute;overflow:hidden;left:0;top:20px;z-index:1;width:100%;height:12px;border-radius:1em;background-color:#eef1f2}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__progress--32faB{width:1em;height:100%;top:0;left:20px}}.steps__self--3KyHm .steps__progress--32faB .steps__progressFill--W7Rk5{-webkit-transition:max-width 1s ease-in;transition:max-width 1s ease-in;background-color:#09d57c}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__progress--32faB .steps__progressFill--W7Rk5{-webkit-transition:max-height 1s ease-in;transition:max-height 1s ease-in}}.steps__self--3KyHm .steps__steps-container--1FxNW{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__steps-container--1FxNW{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}}.steps__self--3KyHm .steps__step--3BEfR{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:2;margin-top:calc(20px + .5em - 1.5em)}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__step--3BEfR{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-top:0;margin-left:calc(20px + .5em - 1.5em)}}.steps__self--3KyHm .steps__step--3BEfR.steps__disabled--gVRIq{opacity:1;cursor:not-allowed}.steps__self--3KyHm .steps__step--3BEfR.steps__notstarted--3EhQ-{opacity:.5}.steps__self--3KyHm .steps__step--3BEfR.steps__waiting--ZH46m{opacity:.5;-webkit-animation:steps__waiting--ZH46m 1s ease-in-out infinite;animation:steps__waiting--ZH46m 1s ease-in-out infinite}.steps__self--3KyHm .steps__step--3BEfR.steps__done--2CvMD .steps__icon--2bo5s,.steps__self--3KyHm .steps__step--3BEfR.steps__done--2CvMD path{color:#fff;fill:#fff;background-color:#09d57c}.steps__self--3KyHm .steps__step--3BEfR .steps__icon--2bo5s{-ms-flex-item-align:center;align-self:center;width:3em;height:3em;background-color:#eef1f2;border-radius:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.steps__self--3KyHm .steps__step--3BEfR .steps__content--1aKlz{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__step--3BEfR .steps__content--1aKlz{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding-left:20px}}.steps__self--3KyHm .steps__icon--2bo5s{font-size:1em}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Status/components/steps.scss"],"names":[],"mappings":"AAAA,yCAA2B,GAAG,UAAW,CAAC,IAAI,SAAS,CAAC,GAAK,UAAW,CAAC,CAAC,oBAAM,kBAAkB,WAAW,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,eAAe,CAAC,qCAAsC,oBAAM,8BAA8B,6BAA6B,uBAAuB,kBAAkB,CAAC,CAAC,qDAAyB,iBAAiB,CAAC,4CAAgB,kBAAkB,gBAAgB,OAAO,SAAS,UAAU,WAAW,YAAY,kBAAkB,wBAAwB,CAAC,qCAAsC,4CAAgB,UAAU,YAAY,MAAM,SAAS,CAAC,CAAC,wEAA8B,wCAAwC,gCAAgC,wBAAwB,CAAC,qCAAsC,wEAA8B,yCAAyC,gCAAgC,CAAC,CAAC,mDAAuB,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,yBAAyB,sBAAsB,6BAA6B,CAAC,qCAAsC,mDAAuB,4BAA4B,6BAA6B,0BAA0B,qBAAqB,CAAC,CAAC,wCAAY,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,UAAU,oCAAqC,CAAC,qCAAsC,wCAAY,8BAA8B,6BAA6B,uBAAuB,mBAAmB,aAAa,qCAAsC,CAAC,CAAC,+DAAqB,UAAU,kBAAkB,CAAC,iEAAuB,UAAW,CAAC,8DAAoB,WAAY,gEAAkD,uDAAyC,CAAC,+IAA6C,WAAW,UAAW,wBAAwB,CAAC,4DAAkB,2BAA2B,kBAAkB,UAAU,WAAW,yBAAyB,kBAAkB,oBAAoB,oBAAoB,aAAa,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,+DAAqB,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,yBAAyB,sBAAsB,kBAAkB,CAAC,qCAAsC,+DAAqB,wBAAwB,qBAAqB,uBAAuB,iBAAiB,CAAC,CAAC,wCAAY,aAAa,CAAC","file":"steps.scss","sourcesContent":["@-webkit-keyframes waiting{0%{opacity:0.5}50%{opacity:1}100%{opacity:0.5}}.self{position:relative;width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-top:30px}@media screen and (max-width: 1200px){.self{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}}.self .progress-cotainer{position:relative}.self .progress{position:absolute;overflow:hidden;left:0;top:20px;z-index:1;width:100%;height:12px;border-radius:1em;background-color:#eef1f2}@media screen and (max-width: 1200px){.self .progress{width:1em;height:100%;top:0;left:20px}}.self .progress .progressFill{-webkit-transition:max-width 1s ease-in;transition:max-width 1s ease-in;background-color:#09d57c}@media screen and (max-width: 1200px){.self .progress .progressFill{-webkit-transition:max-height 1s ease-in;transition:max-height 1s ease-in}}.self .steps-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}@media screen and (max-width: 1200px){.self .steps-container{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}}.self .step{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:2;margin-top:calc(20px + 0.5em - 1.5em)}@media screen and (max-width: 1200px){.self .step{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-top:0;margin-left:calc(20px + 0.5em - 1.5em)}}.self .step.disabled{opacity:1;cursor:not-allowed}.self .step.notstarted{opacity:0.5}.self .step.waiting{opacity:0.5;-webkit-animation:waiting 1s ease-in-out infinite;animation:waiting 1s ease-in-out infinite}.self .step.done .icon,.self .step.done path{color:#fff;fill:white;background-color:#09d57c}.self .step .icon{-ms-flex-item-align:center;align-self:center;width:3em;height:3em;background-color:#eef1f2;border-radius:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .step .content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width: 1200px){.self .step .content{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding-left:20px}}.self .icon{font-size:1em}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "steps__self--3KyHm",
	"progress-cotainer": "steps__progress-cotainer--1m2lP",
	"progressCotainer": "steps__progress-cotainer--1m2lP",
	"progress": "steps__progress--32faB",
	"progressFill": "steps__progressFill--W7Rk5",
	"steps-container": "steps__steps-container--1FxNW",
	"stepsContainer": "steps__steps-container--1FxNW",
	"step": "steps__step--3BEfR",
	"disabled": "steps__disabled--gVRIq",
	"notstarted": "steps__notstarted--3EhQ-",
	"waiting": "steps__waiting--ZH46m",
	"done": "steps__done--2CvMD",
	"icon": "steps__icon--2bo5s",
	"content": "steps__content--1aKlz"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Whitelist.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".Whitelist__self--1BkMz{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:10px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.Whitelist__self--1BkMz .Whitelist__paper--2ZCsu{width:70%;padding:10px}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Whitelist.scss"],"names":[],"mappings":"AAAA,wBAAM,WAAW,YAAY,oBAAoB,oBAAoB,aAAa,gBAAgB,4BAA4B,6BAA6B,0BAA0B,sBAAsB,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,iDAAa,UAAU,YAAY,CAAC","file":"Whitelist.scss","sourcesContent":[".self{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:10px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .paper{width:70%;padding:10px}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "Whitelist__self--1BkMz",
	"paper": "Whitelist__paper--2ZCsu"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./styles/all.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=PT+Sans:400,700);", ""]);

// module
exports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{-webkit-box-sizing:content-box;box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{-webkit-box-sizing:border-box;box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}[hidden],template{display:none}body{font-family:PT Sans,sans-serif}", "", {"version":3,"sources":["/apps/apps/links/styles/all.scss"],"names":[],"mappings":"AAAA,4EAA4E,AAAuE,KAAK,iBAAiB,0BAA0B,6BAA6B,CAAC,KAAK,QAAQ,CAAC,wCAAwC,aAAa,CAAC,GAAG,cAAc,cAAe,CAAC,uBAAuB,aAAa,CAAC,OAAO,eAAe,CAAC,GAAG,+BAA+B,uBAAuB,SAAS,gBAAgB,CAAC,IAAI,gCAAiC,aAAa,CAAC,EAAE,6BAA6B,oCAAoC,CAAC,YAAY,mBAAmB,0BAA0B,yCAAyC,gCAAgC,CAAC,SAAS,oBAAmB,AAAU,kBAAkB,CAA3B,AAA4B,cAAc,gCAAiC,aAAa,CAAC,IAAI,iBAAiB,CAAC,KAAK,sBAAsB,UAAU,CAAC,MAAM,aAAa,CAAC,QAAQ,cAAc,cAAc,kBAAkB,uBAAuB,CAAC,IAAI,aAAc,CAAC,IAAI,SAAU,CAAC,YAAY,oBAAoB,CAAC,sBAAsB,aAAa,QAAQ,CAAC,IAAI,iBAAiB,CAAC,eAAe,eAAe,CAAC,sCAAsC,uBAAuB,eAAe,iBAAiB,QAAQ,CAAC,aAAa,gBAAgB,CAAC,cAAc,mBAAmB,CAAC,qDAA2D,yBAAyB,CAAC,wHAA8H,kBAAkB,SAAS,CAAC,4GAAkH,6BAA6B,CAAC,SAAS,0BAA6B,CAAC,OAAO,8BAA8B,sBAAsB,cAAc,cAAc,eAAe,UAAU,kBAAkB,CAAC,SAAS,qBAAqB,uBAAuB,CAAC,SAAS,aAAa,CAAC,6BAAiC,8BAA8B,sBAAsB,SAAS,CAAC,kFAAsF,WAAW,CAAC,cAAgB,6BAA6B,mBAAmB,CAAC,qFAAyF,uBAAuB,CAAC,6BAA6B,0BAA0B,YAAY,CAAC,aAAa,aAAa,CAAC,QAAQ,iBAAiB,CAAC,OAAO,oBAAoB,CAAC,AAAsB,kBAAS,YAAY,CAAC,KAAK,8BAAiC,CAAC","file":"all.scss","sourcesContent":["/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */@import url(\"https://fonts.googleapis.com/css?family=PT+Sans:400,700\");html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:0.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{-webkit-box-sizing:content-box;box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace, monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace, monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}button,html [type=\"button\"],[type=\"reset\"],[type=\"submit\"]{-webkit-appearance:button}button::-moz-focus-inner,[type=\"button\"]::-moz-focus-inner,[type=\"reset\"]::-moz-focus-inner,[type=\"submit\"]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type=\"button\"]:-moz-focusring,[type=\"reset\"]:-moz-focusring,[type=\"submit\"]:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:0.35em 0.75em 0.625em}legend{-webkit-box-sizing:border-box;box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=\"checkbox\"],[type=\"radio\"]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0}[type=\"number\"]::-webkit-inner-spin-button,[type=\"number\"]::-webkit-outer-spin-button{height:auto}[type=\"search\"]{-webkit-appearance:textfield;outline-offset:-2px}[type=\"search\"]::-webkit-search-cancel-button,[type=\"search\"]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}template{display:none}[hidden]{display:none}body{font-family:'PT Sans', sans-serif}\n"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "../../node_modules/utf8/utf8.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return utf8;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/module.js")(module), __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/value-equal/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);

/***/ }),

/***/ "../../node_modules/warning/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (false) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "../../node_modules/web3/index.js":
/***/ (function(module, exports, __webpack_require__) {

var Web3 = __webpack_require__("../../node_modules/web3/lib/web3.js");

// dont override global variable
if (typeof window !== 'undefined' && typeof window.Web3 === 'undefined') {
    window.Web3 = Web3;
}

module.exports = Web3;


/***/ }),

/***/ "../../node_modules/web3/lib/contracts/GlobalRegistrar.json":
/***/ (function(module, exports) {

module.exports = [{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"name","outputs":[{"name":"o_name","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"content","outputs":[{"name":"","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"reserve","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"subRegistrar","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_registrar","type":"address"}],"name":"setSubRegistrar","outputs":[],"type":"function"},{"constant":false,"inputs":[],"name":"Registrar","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_a","type":"address"},{"name":"_primary","type":"bool"}],"name":"setAddress","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_content","type":"bytes32"}],"name":"setContent","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"disown","outputs":[],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_name","type":"bytes32"},{"indexed":false,"name":"_winner","type":"address"}],"name":"AuctionEnded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_name","type":"bytes32"},{"indexed":false,"name":"_bidder","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"NewBid","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"}],"name":"Changed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"},{"indexed":true,"name":"addr","type":"address"}],"name":"PrimaryChanged","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/contracts/ICAPRegistrar.json":
/***/ (function(module, exports) {

module.exports = [{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_refund","type":"address"}],"name":"disown","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"reserve","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_a","type":"address"}],"name":"setAddr","outputs":[],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"}],"name":"Changed","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/contracts/SmartExchange.json":
/***/ (function(module, exports) {

module.exports = [{"constant":false,"inputs":[{"name":"from","type":"bytes32"},{"name":"to","type":"address"},{"name":"value","type":"uint256"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"from","type":"bytes32"},{"name":"to","type":"address"},{"name":"indirectId","type":"bytes32"},{"name":"value","type":"uint256"}],"name":"icapTransfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"to","type":"bytes32"}],"name":"deposit","outputs":[],"payable":true,"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"AnonymousDeposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"bytes32"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"bytes32"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"indirectId","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"IcapTransfer","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/solidity/address.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeAddress is a prootype that represents address type
 * It matches:
 * address
 * address[]
 * address[4]
 * address[][]
 * address[3][]
 * address[][6][], ...
 */
var SolidityTypeAddress = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputAddress;
};

SolidityTypeAddress.prototype = new SolidityType({});
SolidityTypeAddress.prototype.constructor = SolidityTypeAddress;

SolidityTypeAddress.prototype.isType = function (name) {
    return !!name.match(/address(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeAddress;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/bool.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeBool is a prootype that represents bool type
 * It matches:
 * bool
 * bool[]
 * bool[4]
 * bool[][]
 * bool[3][]
 * bool[][6][], ...
 */
var SolidityTypeBool = function () {
    this._inputFormatter = f.formatInputBool;
    this._outputFormatter = f.formatOutputBool;
};

SolidityTypeBool.prototype = new SolidityType({});
SolidityTypeBool.prototype.constructor = SolidityTypeBool;

SolidityTypeBool.prototype.isType = function (name) {
    return !!name.match(/^bool(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBool;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/bytes.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeBytes is a prototype that represents the bytes type.
 * It matches:
 * bytes
 * bytes[]
 * bytes[4]
 * bytes[][]
 * bytes[3][]
 * bytes[][6][], ...
 * bytes32
 * bytes8[4]
 * bytes[3][]
 */
var SolidityTypeBytes = function () {
    this._inputFormatter = f.formatInputBytes;
    this._outputFormatter = f.formatOutputBytes;
};

SolidityTypeBytes.prototype = new SolidityType({});
SolidityTypeBytes.prototype.constructor = SolidityTypeBytes;

SolidityTypeBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes([0-9]{1,})(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBytes;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/coder.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file coder.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");

var SolidityTypeAddress = __webpack_require__("../../node_modules/web3/lib/solidity/address.js");
var SolidityTypeBool = __webpack_require__("../../node_modules/web3/lib/solidity/bool.js");
var SolidityTypeInt = __webpack_require__("../../node_modules/web3/lib/solidity/int.js");
var SolidityTypeUInt = __webpack_require__("../../node_modules/web3/lib/solidity/uint.js");
var SolidityTypeDynamicBytes = __webpack_require__("../../node_modules/web3/lib/solidity/dynamicbytes.js");
var SolidityTypeString = __webpack_require__("../../node_modules/web3/lib/solidity/string.js");
var SolidityTypeReal = __webpack_require__("../../node_modules/web3/lib/solidity/real.js");
var SolidityTypeUReal = __webpack_require__("../../node_modules/web3/lib/solidity/ureal.js");
var SolidityTypeBytes = __webpack_require__("../../node_modules/web3/lib/solidity/bytes.js");

var isDynamic = function (solidityType, type) {
   return solidityType.isDynamicType(type) ||
          solidityType.isDynamicArray(type);
};

/**
 * SolidityCoder prototype should be used to encode/decode solidity params of any type
 */
var SolidityCoder = function (types) {
    this._types = types;
};

/**
 * This method should be used to transform type to SolidityType
 *
 * @method _requireType
 * @param {String} type
 * @returns {SolidityType}
 * @throws {Error} throws if no matching type is found
 */
SolidityCoder.prototype._requireType = function (type) {
    var solidityType = this._types.filter(function (t) {
        return t.isType(type);
    })[0];

    if (!solidityType) {
        throw Error('invalid solidity type!: ' + type);
    }

    return solidityType;
};

/**
 * Should be used to encode plain param
 *
 * @method encodeParam
 * @param {String} type
 * @param {Object} plain param
 * @return {String} encoded plain param
 */
SolidityCoder.prototype.encodeParam = function (type, param) {
    return this.encodeParams([type], [param]);
};

/**
 * Should be used to encode list of params
 *
 * @method encodeParams
 * @param {Array} types
 * @param {Array} params
 * @return {String} encoded list of params
 */
SolidityCoder.prototype.encodeParams = function (types, params) {
    var solidityTypes = this.getSolidityTypes(types);

    var encodeds = solidityTypes.map(function (solidityType, index) {
        return solidityType.encode(params[index], types[index]);
    });

    var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {
        var staticPartLength = solidityType.staticPartLength(types[index]);
        var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;

        return acc + (isDynamic(solidityTypes[index], types[index]) ?
            32 :
            roundedStaticPartLength);
    }, 0);

    var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);

    return result;
};

SolidityCoder.prototype.encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {
    var result = "";
    var self = this;

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            result += f.formatInputInt(dynamicOffset).encode();
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
        } else {
            // don't add length to dynamicOffset. it's already counted
            result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
        }

        // TODO: figure out nested arrays
    });

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
            result += e;
        }
    });
    return result;
};

// TODO: refactor whole encoding!
SolidityCoder.prototype.encodeWithOffset = function (type, solidityType, encoded, offset) {
    var self = this;
    if (solidityType.isDynamicArray(type)) {
        return (function () {
            // offset was already set
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = encoded[0];

            (function () {
                var previousLength = 2; // in int
                if (solidityType.isDynamicArray(nestedName)) {
                    for (var i = 1; i < encoded.length; i++) {
                        previousLength += +(encoded[i - 1])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                }
            })();

            // first element is length, skip it
            (function () {
                for (var i = 0; i < encoded.length - 1; i++) {
                    var additionalOffset = result / 2;
                    result += self.encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset +  additionalOffset);
                }
            })();

            return result;
        })();

    } else if (solidityType.isStaticArray(type)) {
        return (function () {
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = "";


            if (solidityType.isDynamicArray(nestedName)) {
                (function () {
                    var previousLength = 0; // in int
                    for (var i = 0; i < encoded.length; i++) {
                        // calculate length of previous item
                        previousLength += +(encoded[i - 1] || [])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                })();
            }

            (function () {
                for (var i = 0; i < encoded.length; i++) {
                    var additionalOffset = result / 2;
                    result += self.encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);
                }
            })();

            return result;
        })();
    }

    return encoded;
};

/**
 * Should be used to decode bytes to plain param
 *
 * @method decodeParam
 * @param {String} type
 * @param {String} bytes
 * @return {Object} plain param
 */
SolidityCoder.prototype.decodeParam = function (type, bytes) {
    return this.decodeParams([type], bytes)[0];
};

/**
 * Should be used to decode list of params
 *
 * @method decodeParam
 * @param {Array} types
 * @param {String} bytes
 * @return {Array} array of plain params
 */
SolidityCoder.prototype.decodeParams = function (types, bytes) {
    var solidityTypes = this.getSolidityTypes(types);
    var offsets = this.getOffsets(types, solidityTypes);

    return solidityTypes.map(function (solidityType, index) {
        return solidityType.decode(bytes, offsets[index],  types[index], index);
    });
};

SolidityCoder.prototype.getOffsets = function (types, solidityTypes) {
    var lengths =  solidityTypes.map(function (solidityType, index) {
        return solidityType.staticPartLength(types[index]);
    });

    for (var i = 1; i < lengths.length; i++) {
         // sum with length of previous element
        lengths[i] += lengths[i - 1];
    }

    return lengths.map(function (length, index) {
        // remove the current length, so the length is sum of previous elements
        var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
        return length - staticPartLength;
    });
};

SolidityCoder.prototype.getSolidityTypes = function (types) {
    var self = this;
    return types.map(function (type) {
        return self._requireType(type);
    });
};

var coder = new SolidityCoder([
    new SolidityTypeAddress(),
    new SolidityTypeBool(),
    new SolidityTypeInt(),
    new SolidityTypeUInt(),
    new SolidityTypeDynamicBytes(),
    new SolidityTypeBytes(),
    new SolidityTypeString(),
    new SolidityTypeReal(),
    new SolidityTypeUReal()
]);

module.exports = coder;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/dynamicbytes.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

var SolidityTypeDynamicBytes = function () {
    this._inputFormatter = f.formatInputDynamicBytes;
    this._outputFormatter = f.formatOutputDynamicBytes;
};

SolidityTypeDynamicBytes.prototype = new SolidityType({});
SolidityTypeDynamicBytes.prototype.constructor = SolidityTypeDynamicBytes;

SolidityTypeDynamicBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes(\[([0-9]*)\])*$/);
};

SolidityTypeDynamicBytes.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeDynamicBytes;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/formatters.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var SolidityParam = __webpack_require__("../../node_modules/web3/lib/solidity/param.js");


/**
 * Formats input value to byte representation of int
 * If value is negative, return it's two's complement
 * If the value is floating point, round it down
 *
 * @method formatInputInt
 * @param {String|Number|BigNumber} value that needs to be formatted
 * @returns {SolidityParam}
 */
var formatInputInt = function (value) {
    BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
    var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatDynamicInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputDynamicBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of string
 *
 * @method formatInputString
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputString = function (value) {
    var result = utils.fromUtf8(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of bool
 *
 * @method formatInputBool
 * @param {Boolean}
 * @returns {SolidityParam}
 */
var formatInputBool = function (value) {
    var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');
    return new SolidityParam(result);
};

/**
 * Formats input value to byte representation of real
 * Values are multiplied by 2^m and encoded as integers
 *
 * @method formatInputReal
 * @param {String|Number|BigNumber}
 * @returns {SolidityParam}
 */
var formatInputReal = function (value) {
    return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));
};

/**
 * Check if input value is negative
 *
 * @method signedIsNegative
 * @param {String} value is hex format
 * @returns {Boolean} true if it is negative, otherwise false
 */
var signedIsNegative = function (value) {
    return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';
};

/**
 * Formats right-aligned output bytes to int
 *
 * @method formatOutputInt
 * @param {SolidityParam} param
 * @returns {BigNumber} right-aligned output bytes formatted to big number
 */
var formatOutputInt = function (param) {
    var value = param.staticPart() || "0";

    // check if it's negative number
    // it it is, return two's complement
    if (signedIsNegative(value)) {
        return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);
    }
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to uint
 *
 * @method formatOutputUInt
 * @param {SolidityParam}
 * @returns {BigNumeber} right-aligned output bytes formatted to uint
 */
var formatOutputUInt = function (param) {
    var value = param.staticPart() || "0";
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to real
 *
 * @method formatOutputReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to real
 */
var formatOutputReal = function (param) {
    return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Formats right-aligned output bytes to ureal
 *
 * @method formatOutputUReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to ureal
 */
var formatOutputUReal = function (param) {
    return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Should be used to format output bool
 *
 * @method formatOutputBool
 * @param {SolidityParam}
 * @returns {Boolean} right-aligned input bytes formatted to bool
 */
var formatOutputBool = function (param) {
    return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @param {String} name type name
 * @returns {String} hex string
 */
var formatOutputBytes = function (param, name) {
    var matches = name.match(/^bytes([0-9]*)/);
    var size = parseInt(matches[1]);
    return '0x' + param.staticPart().slice(0, 2 * size);
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputDynamicBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} hex string
 */
var formatOutputDynamicBytes = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return '0x' + param.dynamicPart().substr(64, length);
};

/**
 * Should be used to format output string
 *
 * @method formatOutputString
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} ascii string
 */
var formatOutputString = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return utils.toUtf8(param.dynamicPart().substr(64, length));
};

/**
 * Should be used to format output address
 *
 * @method formatOutputAddress
 * @param {SolidityParam} right-aligned input bytes
 * @returns {String} address
 */
var formatOutputAddress = function (param) {
    var value = param.staticPart();
    return "0x" + value.slice(value.length - 40, value.length);
};

module.exports = {
    formatInputInt: formatInputInt,
    formatInputBytes: formatInputBytes,
    formatInputDynamicBytes: formatInputDynamicBytes,
    formatInputString: formatInputString,
    formatInputBool: formatInputBool,
    formatInputReal: formatInputReal,
    formatOutputInt: formatOutputInt,
    formatOutputUInt: formatOutputUInt,
    formatOutputReal: formatOutputReal,
    formatOutputUReal: formatOutputUReal,
    formatOutputBool: formatOutputBool,
    formatOutputBytes: formatOutputBytes,
    formatOutputDynamicBytes: formatOutputDynamicBytes,
    formatOutputString: formatOutputString,
    formatOutputAddress: formatOutputAddress
};


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/int.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeInt is a prootype that represents int type
 * It matches:
 * int
 * int[]
 * int[4]
 * int[][]
 * int[3][]
 * int[][6][], ...
 * int32
 * int64[]
 * int8[4]
 * int256[][]
 * int[3][]
 * int64[][6][], ...
 */
var SolidityTypeInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputInt;
};

SolidityTypeInt.prototype = new SolidityType({});
SolidityTypeInt.prototype.constructor = SolidityTypeInt;

SolidityTypeInt.prototype.isType = function (name) {
    return !!name.match(/^int([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeInt;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/param.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file param.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

/**
 * SolidityParam object prototype.
 * Should be used when encoding, decoding solidity bytes
 */
var SolidityParam = function (value, offset) {
    this.value = value || '';
    this.offset = offset; // offset in bytes
};

/**
 * This method should be used to get length of params's dynamic part
 * 
 * @method dynamicPartLength
 * @returns {Number} length of dynamic part (in bytes)
 */
SolidityParam.prototype.dynamicPartLength = function () {
    return this.dynamicPart().length / 2;
};

/**
 * This method should be used to create copy of solidity param with different offset
 *
 * @method withOffset
 * @param {Number} offset length in bytes
 * @returns {SolidityParam} new solidity param with applied offset
 */
SolidityParam.prototype.withOffset = function (offset) {
    return new SolidityParam(this.value, offset);
};

/**
 * This method should be used to combine solidity params together
 * eg. when appending an array
 *
 * @method combine
 * @param {SolidityParam} param with which we should combine
 * @param {SolidityParam} result of combination
 */
SolidityParam.prototype.combine = function (param) {
    return new SolidityParam(this.value + param.value); 
};

/**
 * This method should be called to check if param has dynamic size.
 * If it has, it returns true, otherwise false
 *
 * @method isDynamic
 * @returns {Boolean}
 */
SolidityParam.prototype.isDynamic = function () {
    return this.offset !== undefined;
};

/**
 * This method should be called to transform offset to bytes
 *
 * @method offsetAsBytes
 * @returns {String} bytes representation of offset
 */
SolidityParam.prototype.offsetAsBytes = function () {
    return !this.isDynamic() ? '' : utils.padLeft(utils.toTwosComplement(this.offset).toString(16), 64);
};

/**
 * This method should be called to get static part of param
 *
 * @method staticPart
 * @returns {String} offset if it is a dynamic param, otherwise value
 */
SolidityParam.prototype.staticPart = function () {
    if (!this.isDynamic()) {
        return this.value; 
    } 
    return this.offsetAsBytes();
};

/**
 * This method should be called to get dynamic part of param
 *
 * @method dynamicPart
 * @returns {String} returns a value if it is a dynamic param, otherwise empty string
 */
SolidityParam.prototype.dynamicPart = function () {
    return this.isDynamic() ? this.value : '';
};

/**
 * This method should be called to encode param
 *
 * @method encode
 * @returns {String}
 */
SolidityParam.prototype.encode = function () {
    return this.staticPart() + this.dynamicPart();
};

/**
 * This method should be called to encode array of params
 *
 * @method encodeList
 * @param {Array[SolidityParam]} params
 * @returns {String}
 */
SolidityParam.encodeList = function (params) {
    
    // updating offsets
    var totalOffset = params.length * 32;
    var offsetParams = params.map(function (param) {
        if (!param.isDynamic()) {
            return param;
        }
        var offset = totalOffset;
        totalOffset += param.dynamicPartLength();
        return param.withOffset(offset);
    });

    // encode everything!
    return offsetParams.reduce(function (result, param) {
        return result + param.dynamicPart();
    }, offsetParams.reduce(function (result, param) {
        return result + param.staticPart();
    }, ''));
};



module.exports = SolidityParam;



/***/ }),

/***/ "../../node_modules/web3/lib/solidity/real.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeReal is a prootype that represents real type
 * It matches:
 * real
 * real[]
 * real[4]
 * real[][]
 * real[3][]
 * real[][6][], ...
 * real32
 * real64[]
 * real8[4]
 * real256[][]
 * real[3][]
 * real64[][6][], ...
 */
var SolidityTypeReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputReal;
};

SolidityTypeReal.prototype = new SolidityType({});
SolidityTypeReal.prototype.constructor = SolidityTypeReal;

SolidityTypeReal.prototype.isType = function (name) {
    return !!name.match(/real([0-9]*)?(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeReal;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/string.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

var SolidityTypeString = function () {
    this._inputFormatter = f.formatInputString;
    this._outputFormatter = f.formatOutputString;
};

SolidityTypeString.prototype = new SolidityType({});
SolidityTypeString.prototype.constructor = SolidityTypeString;

SolidityTypeString.prototype.isType = function (name) {
    return !!name.match(/^string(\[([0-9]*)\])*$/);
};

SolidityTypeString.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeString;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/type.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityParam = __webpack_require__("../../node_modules/web3/lib/solidity/param.js");

/**
 * SolidityType prototype is used to encode/decode solidity params of certain type
 */
var SolidityType = function (config) {
    this._inputFormatter = config.inputFormatter;
    this._outputFormatter = config.outputFormatter;
};

/**
 * Should be used to determine if this SolidityType do match given name
 *
 * @method isType
 * @param {String} name
 * @return {Bool} true if type match this SolidityType, otherwise false
 */
SolidityType.prototype.isType = function (name) {
    throw "this method should be overrwritten for type " + name;
};

/**
 * Should be used to determine what is the length of static part in given type
 *
 * @method staticPartLength
 * @param {String} name
 * @return {Number} length of static part in bytes
 */
SolidityType.prototype.staticPartLength = function (name) {
    // If name isn't an array then treat it like a single element array.
    return (this.nestedTypes(name) || ['[1]'])
        .map(function (type) {
            // the length of the nested array
            return parseInt(type.slice(1, -1), 10) || 1;
        })
        .reduce(function (previous, current) {
            return previous * current;
        // all basic types are 32 bytes long
        }, 32);
};

/**
 * Should be used to determine if type is dynamic array
 * eg:
 * "type[]" => true
 * "type[4]" => false
 *
 * @method isDynamicArray
 * @param {String} name
 * @return {Bool} true if the type is dynamic array
 */
SolidityType.prototype.isDynamicArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should be used to determine if type is static array
 * eg:
 * "type[]" => false
 * "type[4]" => true
 *
 * @method isStaticArray
 * @param {String} name
 * @return {Bool} true if the type is static array
 */
SolidityType.prototype.isStaticArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should return length of static array
 * eg.
 * "int[32]" => 32
 * "int256[14]" => 14
 * "int[2][3]" => 3
 * "int" => 1
 * "int[1]" => 1
 * "int[]" => 1
 *
 * @method staticArrayLength
 * @param {String} name
 * @return {Number} static array length
 */
SolidityType.prototype.staticArrayLength = function (name) {
    var nestedTypes = this.nestedTypes(name);
    if (nestedTypes) {
       return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);
    }
    return 1;
};

/**
 * Should return nested type
 * eg.
 * "int[32]" => "int"
 * "int256[14]" => "int256"
 * "int[2][3]" => "int[2]"
 * "int" => "int"
 * "int[]" => "int"
 *
 * @method nestedName
 * @param {String} name
 * @return {String} nested name
 */
SolidityType.prototype.nestedName = function (name) {
    // remove last [] in name
    var nestedTypes = this.nestedTypes(name);
    if (!nestedTypes) {
        return name;
    }

    return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);
};

/**
 * Should return true if type has dynamic size by default
 * such types are "string", "bytes"
 *
 * @method isDynamicType
 * @param {String} name
 * @return {Bool} true if is dynamic, otherwise false
 */
SolidityType.prototype.isDynamicType = function () {
    return false;
};

/**
 * Should return array of nested types
 * eg.
 * "int[2][3][]" => ["[2]", "[3]", "[]"]
 * "int[] => ["[]"]
 * "int" => null
 *
 * @method nestedTypes
 * @param {String} name
 * @return {Array} array of nested types
 */
SolidityType.prototype.nestedTypes = function (name) {
    // return list of strings eg. "[]", "[3]", "[]", "[2]"
    return name.match(/(\[[0-9]*\])/g);
};

/**
 * Should be used to encode the value
 *
 * @method encode
 * @param {Object} value
 * @param {String} name
 * @return {String} encoded value
 */
SolidityType.prototype.encode = function (value, name) {
    var self = this;
    if (this.isDynamicArray(name)) {

        return (function () {
            var length = value.length;                          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            result.push(f.formatInputInt(length).encode());

            value.forEach(function (v) {
                result.push(self.encode(v, nestedName));
            });

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            for (var i = 0; i < length; i++) {
                result.push(self.encode(value[i], nestedName));
            }

            return result;
        })();

    }

    return this._inputFormatter(value, name).encode();
};

/**
 * Should be used to decode value from bytes
 *
 * @method decode
 * @param {String} bytes
 * @param {Number} offset in bytes
 * @param {String} name type name
 * @returns {Object} decoded value
 */
SolidityType.prototype.decode = function (bytes, offset, name) {
    var self = this;

    if (this.isDynamicArray(name)) {

        return (function () {
            var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes
            var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int
            var arrayStart = arrayOffset + 32; // array starts after length; // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);                      // in int
            var arrayStart = offset;                                        // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();
    } else if (this.isDynamicType(name)) {

        return (function () {
            var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes
            var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes
            var roundedLength = Math.floor((length + 31) / 32);                     // in int
            var param = new SolidityParam(bytes.substr(dynamicOffset * 2, ( 1 + roundedLength) * 64), 0);
            return self._outputFormatter(param, name);
        })();
    }

    var length = this.staticPartLength(name);
    var param = new SolidityParam(bytes.substr(offset * 2, length * 2));
    return this._outputFormatter(param, name);
};

module.exports = SolidityType;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/uint.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeUInt is a prootype that represents uint type
 * It matches:
 * uint
 * uint[]
 * uint[4]
 * uint[][]
 * uint[3][]
 * uint[][6][], ...
 * uint32
 * uint64[]
 * uint8[4]
 * uint256[][]
 * uint[3][]
 * uint64[][6][], ...
 */
var SolidityTypeUInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputUInt;
};

SolidityTypeUInt.prototype = new SolidityType({});
SolidityTypeUInt.prototype.constructor = SolidityTypeUInt;

SolidityTypeUInt.prototype.isType = function (name) {
    return !!name.match(/^uint([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUInt;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/ureal.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeUReal is a prootype that represents ureal type
 * It matches:
 * ureal
 * ureal[]
 * ureal[4]
 * ureal[][]
 * ureal[3][]
 * ureal[][6][], ...
 * ureal32
 * ureal64[]
 * ureal8[4]
 * ureal256[][]
 * ureal[3][]
 * ureal64[][6][], ...
 */
var SolidityTypeUReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputUReal;
};

SolidityTypeUReal.prototype = new SolidityType({});
SolidityTypeUReal.prototype.constructor = SolidityTypeUReal;

SolidityTypeUReal.prototype.isType = function (name) {
    return !!name.match(/^ureal([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUReal;


/***/ }),

/***/ "../../node_modules/web3/lib/utils/browser-xhr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// go env doesn't have and need XMLHttpRequest
if (typeof XMLHttpRequest === 'undefined') {
    exports.XMLHttpRequest = {};
} else {
    exports.XMLHttpRequest = XMLHttpRequest; // jshint ignore:line
}



/***/ }),

/***/ "../../node_modules/web3/lib/utils/config.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file config.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 * 
 * @module utils
 */

/**
 * Utility functions
 * 
 * @class [utils] config
 * @constructor
 */


/// required to define ETH_BIGNUMBER_ROUNDING_MODE
var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");

var ETH_UNITS = [
    'wei',
    'kwei',
    'Mwei',
    'Gwei',
    'szabo',
    'finney',
    'femtoether',
    'picoether',
    'nanoether',
    'microether',
    'milliether',
    'nano',
    'micro',
    'milli',
    'ether',
    'grand',
    'Mether',
    'Gether',
    'Tether',
    'Pether',
    'Eether',
    'Zether',
    'Yether',
    'Nether',
    'Dether',
    'Vether',
    'Uether'
];

module.exports = {
    ETH_PADDING: 32,
    ETH_SIGNATURE_LENGTH: 4,
    ETH_UNITS: ETH_UNITS,
    ETH_BIGNUMBER_ROUNDING_MODE: { ROUNDING_MODE: BigNumber.ROUND_DOWN },
    ETH_POLLING_TIMEOUT: 1000/2,
    defaultBlock: 'latest',
    defaultAccount: undefined
};



/***/ }),

/***/ "../../node_modules/web3/lib/utils/sha3.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file sha3.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var CryptoJS = __webpack_require__("../../node_modules/crypto-js/index.js");
var sha3 = __webpack_require__("../../node_modules/crypto-js/sha3.js");

module.exports = function (value, options) {
    if (options && options.encoding === 'hex') {
        if (value.length > 2 && value.substr(0, 2) === '0x') {
            value = value.substr(2);
        }
        value = CryptoJS.enc.Hex.parse(value);
    }

    return sha3(value, {
        outputLength: 256
    }).toString();
};



/***/ }),

/***/ "../../node_modules/web3/lib/utils/utils.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file utils.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 *
 * @module utils
 */

/**
 * Utility functions
 *
 * @class [utils] utils
 * @constructor
 */


var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var utf8 = __webpack_require__("../../node_modules/utf8/utf8.js");

var unitMap = {
    'noether':      '0',
    'wei':          '1',
    'kwei':         '1000',
    'Kwei':         '1000',
    'babbage':      '1000',
    'femtoether':   '1000',
    'mwei':         '1000000',
    'Mwei':         '1000000',
    'lovelace':     '1000000',
    'picoether':    '1000000',
    'gwei':         '1000000000',
    'Gwei':         '1000000000',
    'shannon':      '1000000000',
    'nanoether':    '1000000000',
    'nano':         '1000000000',
    'szabo':        '1000000000000',
    'microether':   '1000000000000',
    'micro':        '1000000000000',
    'finney':       '1000000000000000',
    'milliether':    '1000000000000000',
    'milli':         '1000000000000000',
    'ether':        '1000000000000000000',
    'kether':       '1000000000000000000000',
    'grand':        '1000000000000000000000',
    'mether':       '1000000000000000000000000',
    'gether':       '1000000000000000000000000000',
    'tether':       '1000000000000000000000000000000'
};

/**
 * Should be called to pad string to expected length
 *
 * @method padLeft
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padLeft = function (string, chars, sign) {
    return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
};

/**
 * Should be called to pad string to expected length
 *
 * @method padRight
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padRight = function (string, chars, sign) {
    return string + (new Array(chars - string.length + 1).join(sign ? sign : "0"));
};

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toUtf8 = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        if (code === 0)
            break;
        str += String.fromCharCode(code);
    }

    return utf8.decode(str);
};

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toAscii = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
    }

    return str;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromUtf8 = function(str) {
    str = utf8.encode(str);
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (code === 0)
            break;
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return "0x" + hex;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromAscii = function(str) {
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return "0x" + hex;
};

/**
 * Should be used to create full function/event name from json abi
 *
 * @method transformToFullName
 * @param {Object} json-abi
 * @return {String} full fnction/event name
 */
var transformToFullName = function (json) {
    if (json.name.indexOf('(') !== -1) {
        return json.name;
    }

    var typeName = json.inputs.map(function(i){return i.type; }).join();
    return json.name + '(' + typeName + ')';
};

/**
 * Should be called to get display name of contract function
 *
 * @method extractDisplayName
 * @param {String} name of function/event
 * @returns {String} display name for function/event eg. multiply(uint256) -> multiply
 */
var extractDisplayName = function (name) {
    var length = name.indexOf('(');
    return length !== -1 ? name.substr(0, length) : name;
};

/// @returns overloaded part of function/event name
var extractTypeName = function (name) {
    /// TODO: make it invulnerable
    var length = name.indexOf('(');
    return length !== -1 ? name.substr(length + 1, name.length - 1 - (length + 1)).replace(' ', '') : "";
};

/**
 * Converts value to it's decimal representation in string
 *
 * @method toDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var toDecimal = function (value) {
    return toBigNumber(value).toNumber();
};

/**
 * Converts value to it's hex representation
 *
 * @method fromDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var fromDecimal = function (value) {
    var number = toBigNumber(value);
    var result = number.toString(16);

    return number.lessThan(0) ? '-0x' + result.substr(1) : '0x' + result;
};

/**
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 *
 * @method toHex
 * @param {String|Number|BigNumber|Object}
 * @return {String}
 */
var toHex = function (val) {
    /*jshint maxcomplexity: 8 */

    if (isBoolean(val))
        return fromDecimal(+val);

    if (isBigNumber(val))
        return fromDecimal(val);

    if (typeof val === 'object')
        return fromUtf8(JSON.stringify(val));

    // if its a negative number, pass it through fromDecimal
    if (isString(val)) {
        if (val.indexOf('-0x') === 0)
            return fromDecimal(val);
        else if(val.indexOf('0x') === 0)
            return val;
        else if (!isFinite(val))
            return fromAscii(val);
    }

    return fromDecimal(val);
};

/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
var getValueOfUnit = function (unit) {
    unit = unit ? unit.toLowerCase() : 'ether';
    var unitValue = unitMap[unit];
    if (unitValue === undefined) {
        throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
    }
    return new BigNumber(unitValue, 10);
};

/**
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method fromWei
 * @param {Number|String} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert to, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var fromWei = function(number, unit) {
    var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method toWei
 * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert from, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var toWei = function(number, unit) {
    var returnValue = toBigNumber(number).times(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes an input and transforms it into an bignumber
 *
 * @method toBigNumber
 * @param {Number|String|BigNumber} a number, string, HEX string or BigNumber
 * @return {BigNumber} BigNumber
*/
var toBigNumber = function(number) {
    /*jshint maxcomplexity:5 */
    number = number || 0;
    if (isBigNumber(number))
        return number;

    if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {
        return new BigNumber(number.replace('0x',''), 16);
    }

    return new BigNumber(number.toString(10), 10);
};

/**
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 *
 * @method toTwosComplement
 * @param {Number|String|BigNumber}
 * @return {BigNumber}
 */
var toTwosComplement = function (number) {
    var bigNumber = toBigNumber(number).round();
    if (bigNumber.lessThan(0)) {
        return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
    }
    return bigNumber;
};

/**
 * Checks if the given string is strictly an address
 *
 * @method isStrictAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isStrictAddress = function (address) {
    return /^0x[0-9a-f]{40}$/i.test(address);
};

/**
 * Checks if the given string is an address
 *
 * @method isAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isAddress = function (address) {
    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        // check if it has the basic requirements of an address
        return false;
    } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        // If it's all small caps or all all caps, return true
        return true;
    } else {
        // Otherwise check each case
        return isChecksumAddress(address);
    }
};

/**
 * Checks if the given string is a checksummed address
 *
 * @method isChecksumAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isChecksumAddress = function (address) {
    // Check each case
    address = address.replace('0x','');
    var addressHash = sha3(address.toLowerCase());

    for (var i = 0; i < 40; i++ ) {
        // the nth letter should be uppercase if the nth digit of casemap is 1
        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
            return false;
        }
    }
    return true;
};



/**
 * Makes a checksum address
 *
 * @method toChecksumAddress
 * @param {String} address the given HEX adress
 * @return {String}
*/
var toChecksumAddress = function (address) {
    if (typeof address === 'undefined') return '';

    address = address.toLowerCase().replace('0x','');
    var addressHash = sha3(address);
    var checksumAddress = '0x';

    for (var i = 0; i < address.length; i++ ) {
        // If ith character is 9 to f then make it uppercase
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
};

/**
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 *
 * @method toAddress
 * @param {String} address
 * @return {String} formatted address
 */
var toAddress = function (address) {
    if (isStrictAddress(address)) {
        return address;
    }

    if (/^[0-9a-f]{40}$/.test(address)) {
        return '0x' + address;
    }

    return '0x' + padLeft(toHex(address).substr(2), 40);
};

/**
 * Returns true if object is BigNumber, otherwise false
 *
 * @method isBigNumber
 * @param {Object}
 * @return {Boolean}
 */
var isBigNumber = function (object) {
    return object instanceof BigNumber ||
        (object && object.constructor && object.constructor.name === 'BigNumber');
};

/**
 * Returns true if object is string, otherwise false
 *
 * @method isString
 * @param {Object}
 * @return {Boolean}
 */
var isString = function (object) {
    return typeof object === 'string' ||
        (object && object.constructor && object.constructor.name === 'String');
};

/**
 * Returns true if object is function, otherwise false
 *
 * @method isFunction
 * @param {Object}
 * @return {Boolean}
 */
var isFunction = function (object) {
    return typeof object === 'function';
};

/**
 * Returns true if object is Objet, otherwise false
 *
 * @method isObject
 * @param {Object}
 * @return {Boolean}
 */
var isObject = function (object) {
    return object !== null && !(object instanceof Array) && typeof object === 'object';
};

/**
 * Returns true if object is boolean, otherwise false
 *
 * @method isBoolean
 * @param {Object}
 * @return {Boolean}
 */
var isBoolean = function (object) {
    return typeof object === 'boolean';
};

/**
 * Returns true if object is array, otherwise false
 *
 * @method isArray
 * @param {Object}
 * @return {Boolean}
 */
var isArray = function (object) {
    return object instanceof Array;
};

/**
 * Returns true if given string is valid json object
 *
 * @method isJson
 * @param {String}
 * @return {Boolean}
 */
var isJson = function (str) {
    try {
        return !!JSON.parse(str);
    } catch (e) {
        return false;
    }
};

/**
 * Returns true if given string is a valid Ethereum block header bloom.
 *
 * @method isBloom
 * @param {String} hex encoded bloom filter
 * @return {Boolean}
 */
var isBloom = function (bloom) {
    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
    }
    return false;
};

/**
 * Returns true if given string is a valid log topic.
 *
 * @method isTopic
 * @param {String} hex encoded topic
 * @return {Boolean}
 */
var isTopic = function (topic) {
    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
    }
    return false;
};

module.exports = {
    padLeft: padLeft,
    padRight: padRight,
    toHex: toHex,
    toDecimal: toDecimal,
    fromDecimal: fromDecimal,
    toUtf8: toUtf8,
    toAscii: toAscii,
    fromUtf8: fromUtf8,
    fromAscii: fromAscii,
    transformToFullName: transformToFullName,
    extractDisplayName: extractDisplayName,
    extractTypeName: extractTypeName,
    toWei: toWei,
    fromWei: fromWei,
    toBigNumber: toBigNumber,
    toTwosComplement: toTwosComplement,
    toAddress: toAddress,
    isBigNumber: isBigNumber,
    isStrictAddress: isStrictAddress,
    isAddress: isAddress,
    isChecksumAddress: isChecksumAddress,
    toChecksumAddress: toChecksumAddress,
    isFunction: isFunction,
    isString: isString,
    isObject: isObject,
    isBoolean: isBoolean,
    isArray: isArray,
    isJson: isJson,
    isBloom: isBloom,
    isTopic: isTopic,
};


/***/ }),

/***/ "../../node_modules/web3/lib/version.json":
/***/ (function(module, exports) {

module.exports = {"version":"0.19.1"}

/***/ }),

/***/ "../../node_modules/web3/lib/web3.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file web3.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var RequestManager = __webpack_require__("../../node_modules/web3/lib/web3/requestmanager.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var Eth = __webpack_require__("../../node_modules/web3/lib/web3/methods/eth.js");
var DB = __webpack_require__("../../node_modules/web3/lib/web3/methods/db.js");
var Shh = __webpack_require__("../../node_modules/web3/lib/web3/methods/shh.js");
var Net = __webpack_require__("../../node_modules/web3/lib/web3/methods/net.js");
var Personal = __webpack_require__("../../node_modules/web3/lib/web3/methods/personal.js");
var Swarm = __webpack_require__("../../node_modules/web3/lib/web3/methods/swarm.js");
var Settings = __webpack_require__("../../node_modules/web3/lib/web3/settings.js");
var version = __webpack_require__("../../node_modules/web3/lib/version.json");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var extend = __webpack_require__("../../node_modules/web3/lib/web3/extend.js");
var Batch = __webpack_require__("../../node_modules/web3/lib/web3/batch.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var HttpProvider = __webpack_require__("../../node_modules/web3/lib/web3/httpprovider.js");
var IpcProvider = __webpack_require__("../../node_modules/web3/lib/web3/ipcprovider.js");
var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");



function Web3 (provider) {
    this._requestManager = new RequestManager(provider);
    this.currentProvider = provider;
    this.eth = new Eth(this);
    this.db = new DB(this);
    this.shh = new Shh(this);
    this.net = new Net(this);
    this.personal = new Personal(this);
    this.bzz = new Swarm(this);
    this.settings = new Settings();
    this.version = {
        api: version.version
    };
    this.providers = {
        HttpProvider: HttpProvider,
        IpcProvider: IpcProvider
    };
    this._extend = extend(this);
    this._extend({
        properties: properties()
    });
}

// expose providers on the class
Web3.providers = {
    HttpProvider: HttpProvider,
    IpcProvider: IpcProvider
};

Web3.prototype.setProvider = function (provider) {
    this._requestManager.setProvider(provider);
    this.currentProvider = provider;
};

Web3.prototype.reset = function (keepIsSyncing) {
    this._requestManager.reset(keepIsSyncing);
    this.settings = new Settings();
};

Web3.prototype.BigNumber = BigNumber;
Web3.prototype.toHex = utils.toHex;
Web3.prototype.toAscii = utils.toAscii;
Web3.prototype.toUtf8 = utils.toUtf8;
Web3.prototype.fromAscii = utils.fromAscii;
Web3.prototype.fromUtf8 = utils.fromUtf8;
Web3.prototype.toDecimal = utils.toDecimal;
Web3.prototype.fromDecimal = utils.fromDecimal;
Web3.prototype.toBigNumber = utils.toBigNumber;
Web3.prototype.toWei = utils.toWei;
Web3.prototype.fromWei = utils.fromWei;
Web3.prototype.isAddress = utils.isAddress;
Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
Web3.prototype.isIBAN = utils.isIBAN;
Web3.prototype.padLeft = utils.padLeft;
Web3.prototype.padRight = utils.padRight;


Web3.prototype.sha3 = function(string, options) {
    return '0x' + sha3(string, options);
};

/**
 * Transforms direct icap to address
 */
Web3.prototype.fromICAP = function (icap) {
    var iban = new Iban(icap);
    return iban.address();
};

var properties = function () {
    return [
        new Property({
            name: 'version.node',
            getter: 'web3_clientVersion'
        }),
        new Property({
            name: 'version.network',
            getter: 'net_version',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.ethereum',
            getter: 'eth_protocolVersion',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.whisper',
            getter: 'shh_version',
            inputFormatter: utils.toDecimal
        })
    ];
};

Web3.prototype.isConnected = function(){
    return (this.currentProvider && this.currentProvider.isConnected());
};

Web3.prototype.createBatch = function () {
    return new Batch(this);
};

module.exports = Web3;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/allevents.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file allevents.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var SolidityEvent = __webpack_require__("../../node_modules/web3/lib/web3/event.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

var AllSolidityEvents = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._json = json;
    this._address = address;
};

AllSolidityEvents.prototype.encode = function (options) {
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.address = this._address;

    return result;
};

AllSolidityEvents.prototype.decode = function (data) {
    data.data = data.data || '';
    data.topics = data.topics || [];

    var eventTopic = data.topics[0].slice(2);
    var match = this._json.filter(function (j) {
        return eventTopic === sha3(utils.transformToFullName(j));
    })[0];

    if (!match) { // cannot find matching event?
        console.warn('cannot find event for log');
        return data;
    }

    var event = new SolidityEvent(this._requestManager, match, this._address);
    return event.decode(data);
};

AllSolidityEvents.prototype.execute = function (options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 1)
            options = null;
    }

    var o = this.encode(options);
    var formatter = this.decode.bind(this);
    return new Filter(this._requestManager, o, watches.eth(), formatter, callback);
};

AllSolidityEvents.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    contract.allEvents = execute;
};

module.exports = AllSolidityEvents;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/batch.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file batch.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Jsonrpc = __webpack_require__("../../node_modules/web3/lib/web3/jsonrpc.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

var Batch = function (web3) {
    this.requestManager = web3._requestManager;
    this.requests = [];
};

/**
 * Should be called to add create new request to batch request
 *
 * @method add
 * @param {Object} jsonrpc requet object
 */
Batch.prototype.add = function (request) {
    this.requests.push(request);
};

/**
 * Should be called to execute batch request
 *
 * @method execute
 */
Batch.prototype.execute = function () {
    var requests = this.requests;
    this.requestManager.sendBatch(requests, function (err, results) {
        results = results || [];
        requests.map(function (request, index) {
            return results[index] || {};
        }).forEach(function (result, index) {
            if (requests[index].callback) {

                if (!Jsonrpc.isValidResponse(result)) {
                    return requests[index].callback(errors.InvalidResponse(result));
                }

                requests[index].callback(null, (requests[index].format ? requests[index].format(result.result) : result.result));
            }
        });
    }); 
};

module.exports = Batch;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/contract.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file contract.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var SolidityEvent = __webpack_require__("../../node_modules/web3/lib/web3/event.js");
var SolidityFunction = __webpack_require__("../../node_modules/web3/lib/web3/function.js");
var AllEvents = __webpack_require__("../../node_modules/web3/lib/web3/allevents.js");

/**
 * Should be called to encode constructor params
 *
 * @method encodeConstructorParams
 * @param {Array} abi
 * @param {Array} constructor params
 */
var encodeConstructorParams = function (abi, params) {
    return abi.filter(function (json) {
        return json.type === 'constructor' && json.inputs.length === params.length;
    }).map(function (json) {
        return json.inputs.map(function (input) {
            return input.type;
        });
    }).map(function (types) {
        return coder.encodeParams(types, params);
    })[0] || '';
};

/**
 * Should be called to add functions to contract object
 *
 * @method addFunctionsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addFunctionsToContract = function (contract) {
    contract.abi.filter(function (json) {
        return json.type === 'function';
    }).map(function (json) {
        return new SolidityFunction(contract._eth, json, contract.address);
    }).forEach(function (f) {
        f.attachToContract(contract);
    });
};

/**
 * Should be called to add events to contract object
 *
 * @method addEventsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addEventsToContract = function (contract) {
    var events = contract.abi.filter(function (json) {
        return json.type === 'event';
    });

    var All = new AllEvents(contract._eth._requestManager, events, contract.address);
    All.attachToContract(contract);

    events.map(function (json) {
        return new SolidityEvent(contract._eth._requestManager, json, contract.address);
    }).forEach(function (e) {
        e.attachToContract(contract);
    });
};


/**
 * Should be called to check if the contract gets properly deployed on the blockchain.
 *
 * @method checkForContractAddress
 * @param {Object} contract
 * @param {Function} callback
 * @returns {Undefined}
 */
var checkForContractAddress = function(contract, callback){
    var count = 0,
        callbackFired = false;

    // wait for receipt
    var filter = contract._eth.filter('latest', function(e){
        if (!e && !callbackFired) {
            count++;

            // stop watching after 50 blocks (timeout)
            if (count > 50) {

                filter.stopWatching(function() {});
                callbackFired = true;

                if (callback)
                    callback(new Error('Contract transaction couldn\'t be found after 50 blocks'));
                else
                    throw new Error('Contract transaction couldn\'t be found after 50 blocks');


            } else {

                contract._eth.getTransactionReceipt(contract.transactionHash, function(e, receipt){
                    if(receipt && !callbackFired) {

                        contract._eth.getCode(receipt.contractAddress, function(e, code){
                            /*jshint maxcomplexity: 6 */

                            if(callbackFired || !code)
                                return;

                            filter.stopWatching(function() {});
                            callbackFired = true;

                            if(code.length > 3) {

                                // console.log('Contract code deployed!');

                                contract.address = receipt.contractAddress;

                                // attach events and methods again after we have
                                addFunctionsToContract(contract);
                                addEventsToContract(contract);

                                // call callback for the second time
                                if(callback)
                                    callback(null, contract);

                            } else {
                                if(callback)
                                    callback(new Error('The contract code couldn\'t be stored, please check your gas amount.'));
                                else
                                    throw new Error('The contract code couldn\'t be stored, please check your gas amount.');
                            }
                        });
                    }
                });
            }
        }
    });
};

/**
 * Should be called to create new ContractFactory instance
 *
 * @method ContractFactory
 * @param {Array} abi
 */
var ContractFactory = function (eth, abi) {
    this.eth = eth;
    this.abi = abi;

    /**
     * Should be called to create new contract on a blockchain
     *
     * @method new
     * @param {Any} contract constructor param1 (optional)
     * @param {Any} contract constructor param2 (optional)
     * @param {Object} contract transaction object (required)
     * @param {Function} callback
     * @returns {Contract} returns contract instance
     */
    this.new = function () {
        /*jshint maxcomplexity: 7 */
        
        var contract = new Contract(this.eth, this.abi);

        // parse arguments
        var options = {}; // required!
        var callback;

        var args = Array.prototype.slice.call(arguments);
        if (utils.isFunction(args[args.length - 1])) {
            callback = args.pop();
        }

        var last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
            options = args.pop();
        }

        if (options.value > 0) {
            var constructorAbi = abi.filter(function (json) {
                return json.type === 'constructor' && json.inputs.length === args.length;
            })[0] || {};

            if (!constructorAbi.payable) {
                throw new Error('Cannot send value to non-payable constructor');
            }
        }

        var bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;

        if (callback) {

            // wait for the contract address adn check if the code was deployed
            this.eth.sendTransaction(options, function (err, hash) {
                if (err) {
                    callback(err);
                } else {
                    // add the transaction hash
                    contract.transactionHash = hash;

                    // call callback for the first time
                    callback(null, contract);

                    checkForContractAddress(contract, callback);
                }
            });
        } else {
            var hash = this.eth.sendTransaction(options);
            // add the transaction hash
            contract.transactionHash = hash;
            checkForContractAddress(contract);
        }

        return contract;
    };

    this.new.getData = this.getData.bind(this);
};

/**
 * Should be called to create new ContractFactory
 *
 * @method contract
 * @param {Array} abi
 * @returns {ContractFactory} new contract factory
 */
//var contract = function (abi) {
    //return new ContractFactory(abi);
//};



/**
 * Should be called to get access to existing contract on a blockchain
 *
 * @method at
 * @param {Address} contract address (required)
 * @param {Function} callback {optional)
 * @returns {Contract} returns contract if no callback was passed,
 * otherwise calls callback function (err, contract)
 */
ContractFactory.prototype.at = function (address, callback) {
    var contract = new Contract(this.eth, this.abi, address);

    // this functions are not part of prototype,
    // because we dont want to spoil the interface
    addFunctionsToContract(contract);
    addEventsToContract(contract);

    if (callback) {
        callback(null, contract);
    }
    return contract;
};

/**
 * Gets the data, which is data to deploy plus constructor params
 *
 * @method getData
 */
ContractFactory.prototype.getData = function () {
    var options = {}; // required!
    var args = Array.prototype.slice.call(arguments);

    var last = args[args.length - 1];
    if (utils.isObject(last) && !utils.isArray(last)) {
        options = args.pop();
    }

    var bytes = encodeConstructorParams(this.abi, args);
    options.data += bytes;

    return options.data;
};

/**
 * Should be called to create new contract instance
 *
 * @method Contract
 * @param {Array} abi
 * @param {Address} contract address
 */
var Contract = function (eth, abi, address) {
    this._eth = eth;
    this.transactionHash = null;
    this.address = address;
    this.abi = abi;
};

module.exports = ContractFactory;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/errors.js":
/***/ (function(module, exports) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file errors.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

module.exports = {
    InvalidNumberOfSolidityArgs: function () {
        return new Error('Invalid number of arguments to Solidity function');
    },
    InvalidNumberOfRPCParams: function () {
        return new Error('Invalid number of input parameters to RPC method');
    },
    InvalidConnection: function (host){
        return new Error('CONNECTION ERROR: Couldn\'t connect to node '+ host +'.');
    },
    InvalidProvider: function () {
        return new Error('Provider not set or invalid');
    },
    InvalidResponse: function (result){
        var message = !!result && !!result.error && !!result.error.message ? result.error.message : 'Invalid JSON RPC response: ' + JSON.stringify(result);
        return new Error(message);
    },
    ConnectionTimeout: function (ms){
        return new Error('CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');
    }
};


/***/ }),

/***/ "../../node_modules/web3/lib/web3/event.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file event.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

/**
 * This prototype should be used to create event filters
 */
var SolidityEvent = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._params = json.inputs;
    this._name = utils.transformToFullName(json);
    this._address = address;
    this._anonymous = json.anonymous;
};

/**
 * Should be used to get filtered param types
 *
 * @method types
 * @param {Bool} decide if returned typed should be indexed
 * @return {Array} array of types
 */
SolidityEvent.prototype.types = function (indexed) {
    return this._params.filter(function (i) {
        return i.indexed === indexed;
    }).map(function (i) {
        return i.type;
    });
};

/**
 * Should be used to get event display name
 *
 * @method displayName
 * @return {String} event display name
 */
SolidityEvent.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get event type name
 *
 * @method typeName
 * @return {String} event type name
 */
SolidityEvent.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be used to get event signature
 *
 * @method signature
 * @return {String} event signature
 */
SolidityEvent.prototype.signature = function () {
    return sha3(this._name);
};

/**
 * Should be used to encode indexed params and options to one final object
 * 
 * @method encode
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} everything combined together and encoded
 */
SolidityEvent.prototype.encode = function (indexed, options) {
    indexed = indexed || {};
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.topics = [];

    result.address = this._address;
    if (!this._anonymous) {
        result.topics.push('0x' + this.signature());
    }

    var indexedTopics = this._params.filter(function (i) {
        return i.indexed === true;
    }).map(function (i) {
        var value = indexed[i.name];
        if (value === undefined || value === null) {
            return null;
        }
        
        if (utils.isArray(value)) {
            return value.map(function (v) {
                return '0x' + coder.encodeParam(i.type, v);
            });
        }
        return '0x' + coder.encodeParam(i.type, value);
    });

    result.topics = result.topics.concat(indexedTopics);

    return result;
};

/**
 * Should be used to decode indexed params and options
 *
 * @method decode
 * @param {Object} data
 * @return {Object} result object with decoded indexed && not indexed params
 */
SolidityEvent.prototype.decode = function (data) {
 
    data.data = data.data || '';
    data.topics = data.topics || [];

    var argTopics = this._anonymous ? data.topics : data.topics.slice(1);
    var indexedData = argTopics.map(function (topics) { return topics.slice(2); }).join("");
    var indexedParams = coder.decodeParams(this.types(true), indexedData); 

    var notIndexedData = data.data.slice(2);
    var notIndexedParams = coder.decodeParams(this.types(false), notIndexedData);
    
    var result = formatters.outputLogFormatter(data);
    result.event = this.displayName();
    result.address = data.address;

    result.args = this._params.reduce(function (acc, current) {
        acc[current.name] = current.indexed ? indexedParams.shift() : notIndexedParams.shift();
        return acc;
    }, {});

    delete result.data;
    delete result.topics;

    return result;
};

/**
 * Should be used to create new filter object from event
 *
 * @method execute
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} filter object
 */
SolidityEvent.prototype.execute = function (indexed, options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 2)
            options = null;
        if(arguments.length === 1) {
            options = null;
            indexed = {};
        }
    }
    
    var o = this.encode(indexed, options);
    var formatter = this.decode.bind(this);
    return new Filter(this._requestManager, o, watches.eth(), formatter, callback);
};

/**
 * Should be used to attach event to contract object
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityEvent.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = this.execute.bind(this, contract);
};

module.exports = SolidityEvent;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/extend.js":
/***/ (function(module, exports, __webpack_require__) {

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

// TODO: refactor, so the input params are not altered.
// it's necessary to make same 'extension' work with multiple providers
var extend = function (web3) {
    /* jshint maxcomplexity:5 */
    var ex = function (extension) {

        var extendedObject;
        if (extension.property) {
            if (!web3[extension.property]) {
                web3[extension.property] = {};
            }
            extendedObject = web3[extension.property];
        } else {
            extendedObject = web3;
        }

        if (extension.methods) {
            extension.methods.forEach(function (method) {
                method.attachToObject(extendedObject);
                method.setRequestManager(web3._requestManager);
            });
        }

        if (extension.properties) {
            extension.properties.forEach(function (property) {
                property.attachToObject(extendedObject);
                property.setRequestManager(web3._requestManager);
            });
        }
    };

    ex.formatters = formatters; 
    ex.utils = utils;
    ex.Method = Method;
    ex.Property = Property;

    return ex;
};



module.exports = extend;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/filter.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file filter.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

/**
* Converts a given topic to a hex string, but also allows null values.
*
* @param {Mixed} value
* @return {String}
*/
var toTopic = function(value){

    if(value === null || typeof value === 'undefined')
        return null;

    value = String(value);

    if(value.indexOf('0x') === 0)
        return value;
    else
        return utils.fromUtf8(value);
};

/// This method should be called on options object, to verify deprecated properties && lazy load dynamic ones
/// @param should be string or object
/// @returns options string or object
var getOptions = function (options) {

    if (utils.isString(options)) {
        return options;
    }

    options = options || {};

    // make sure topics, get converted to hex
    options.topics = options.topics || [];
    options.topics = options.topics.map(function(topic){
        return (utils.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);
    });

    return {
        topics: options.topics,
        from: options.from,
        to: options.to,
        address: options.address,
        fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),
        toBlock: formatters.inputBlockNumberFormatter(options.toBlock)
    };
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method getLogsAtStart
@param {Object} self
@param {funciton}
*/
var getLogsAtStart = function(self, callback){
    // call getFilterLogs for the first watch callback start
    if (!utils.isString(self.options)) {
        self.get(function (err, messages) {
            // don't send all the responses to all the watches again... just to self one
            if (err) {
                callback(err);
            }

            if(utils.isArray(messages)) {
                messages.forEach(function (message) {
                    callback(null, message);
                });
            }
        });
    }
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollFilter
@param {Object} self
*/
var pollFilter = function(self) {

    var onMessage = function (error, messages) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isArray(messages)) {
            messages.forEach(function (message) {
                message = self.formatter ? self.formatter(message) : message;
                self.callbacks.forEach(function (callback) {
                    callback(null, message);
                });
            });
        }
    };

    self.requestManager.startPolling({
        method: self.implementation.poll.call,
        params: [self.filterId],
    }, self.filterId, onMessage, self.stopWatching.bind(self));

};

var Filter = function (requestManager, options, methods, formatter, callback, filterCreationErrorCallback) {
    var self = this;
    var implementation = {};
    methods.forEach(function (method) {
        method.setRequestManager(requestManager);
        method.attachToObject(implementation);
    });
    this.requestManager = requestManager;
    this.options = getOptions(options);
    this.implementation = implementation;
    this.filterId = null;
    this.callbacks = [];
    this.getLogsCallbacks = [];
    this.pollFilters = [];
    this.formatter = formatter;
    this.implementation.newFilter(this.options, function(error, id){
        if(error) {
            self.callbacks.forEach(function(cb){
                cb(error);
            });
            if (typeof filterCreationErrorCallback === 'function') {
              filterCreationErrorCallback(error);
            }
        } else {
            self.filterId = id;

            // check if there are get pending callbacks as a consequence
            // of calling get() with filterId unassigned.
            self.getLogsCallbacks.forEach(function (cb){
                self.get(cb);
            });
            self.getLogsCallbacks = [];

            // get filter logs for the already existing watch calls
            self.callbacks.forEach(function(cb){
                getLogsAtStart(self, cb);
            });
            if(self.callbacks.length > 0)
                pollFilter(self);

            // start to watch immediately
            if(typeof callback === 'function') {
                return self.watch(callback);
            }
        }
    });

    return this;
};

Filter.prototype.watch = function (callback) {
    this.callbacks.push(callback);

    if(this.filterId) {
        getLogsAtStart(this, callback);
        pollFilter(this);
    }

    return this;
};

Filter.prototype.stopWatching = function (callback) {
    this.requestManager.stopPolling(this.filterId);
    this.callbacks = [];
    // remove filter async
    if (callback) {
        this.implementation.uninstallFilter(this.filterId, callback);
    } else {
        return this.implementation.uninstallFilter(this.filterId);
    }
};

Filter.prototype.get = function (callback) {
    var self = this;
    if (utils.isFunction(callback)) {
        if (this.filterId === null) {
            // If filterId is not set yet, call it back
            // when newFilter() assigns it.
            this.getLogsCallbacks.push(callback);
        } else {
            this.implementation.getLogs(this.filterId, function(err, res){
                if (err) {
                    callback(err);
                } else {
                    callback(null, res.map(function (log) {
                        return self.formatter ? self.formatter(log) : log;
                    }));
                }
            });
        }
    } else {
        if (this.filterId === null) {
            throw new Error('Filter ID Error: filter().get() can\'t be chained synchronous, please provide a callback for the get() method.');
        }
        var logs = this.implementation.getLogs(this.filterId);
        return logs.map(function (log) {
            return self.formatter ? self.formatter(log) : log;
        });
    }

    return this;
};

module.exports = Filter;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/formatters.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var config = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");

/**
 * Should the format output to a big number
 *
 * @method outputBigNumberFormatter
 * @param {String|Number|BigNumber}
 * @returns {BigNumber} object
 */
var outputBigNumberFormatter = function (number) {
    return utils.toBigNumber(number);
};

var isPredefinedBlockNumber = function (blockNumber) {
    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';
};

var inputDefaultBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return config.defaultBlock;
    }
    return inputBlockNumberFormatter(blockNumber);
};

var inputBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return undefined;
    } else if (isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
    }
    return utils.toHex(blockNumber);
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputCallFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputCallFormatter = function (options){

    options.from = options.from || config.defaultAccount;

    if (options.from) {
        options.from = inputAddressFormatter(options.from);
    }

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputTransactionFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputTransactionFormatter = function (options){

    options.from = options.from || config.defaultAccount;
    options.from = inputAddressFormatter(options.from);

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the output of a transaction to its proper values
 *
 * @method outputTransactionFormatter
 * @param {Object} tx
 * @returns {Object}
*/
var outputTransactionFormatter = function (tx){
    if(tx.blockNumber !== null)
        tx.blockNumber = utils.toDecimal(tx.blockNumber);
    if(tx.transactionIndex !== null)
        tx.transactionIndex = utils.toDecimal(tx.transactionIndex);
    tx.nonce = utils.toDecimal(tx.nonce);
    tx.gas = utils.toDecimal(tx.gas);
    tx.gasPrice = utils.toBigNumber(tx.gasPrice);
    tx.value = utils.toBigNumber(tx.value);
    return tx;
};

/**
 * Formats the output of a transaction receipt to its proper values
 *
 * @method outputTransactionReceiptFormatter
 * @param {Object} receipt
 * @returns {Object}
*/
var outputTransactionReceiptFormatter = function (receipt){
    if(receipt.blockNumber !== null)
        receipt.blockNumber = utils.toDecimal(receipt.blockNumber);
    if(receipt.transactionIndex !== null)
        receipt.transactionIndex = utils.toDecimal(receipt.transactionIndex);
    receipt.cumulativeGasUsed = utils.toDecimal(receipt.cumulativeGasUsed);
    receipt.gasUsed = utils.toDecimal(receipt.gasUsed);

    if(utils.isArray(receipt.logs)) {
        receipt.logs = receipt.logs.map(function(log){
            return outputLogFormatter(log);
        });
    }

    return receipt;
};

/**
 * Formats the output of a block to its proper values
 *
 * @method outputBlockFormatter
 * @param {Object} block
 * @returns {Object}
*/
var outputBlockFormatter = function(block) {

    // transform to number
    block.gasLimit = utils.toDecimal(block.gasLimit);
    block.gasUsed = utils.toDecimal(block.gasUsed);
    block.size = utils.toDecimal(block.size);
    block.timestamp = utils.toDecimal(block.timestamp);
    if(block.number !== null)
        block.number = utils.toDecimal(block.number);

    block.difficulty = utils.toBigNumber(block.difficulty);
    block.totalDifficulty = utils.toBigNumber(block.totalDifficulty);

    if (utils.isArray(block.transactions)) {
        block.transactions.forEach(function(item){
            if(!utils.isString(item))
                return outputTransactionFormatter(item);
        });
    }

    return block;
};

/**
 * Formats the output of a log
 *
 * @method outputLogFormatter
 * @param {Object} log object
 * @returns {Object} log
*/
var outputLogFormatter = function(log) {
    if(log.blockNumber !== null)
        log.blockNumber = utils.toDecimal(log.blockNumber);
    if(log.transactionIndex !== null)
        log.transactionIndex = utils.toDecimal(log.transactionIndex);
    if(log.logIndex !== null)
        log.logIndex = utils.toDecimal(log.logIndex);

    return log;
};

/**
 * Formats the input of a whisper post and converts all values to HEX
 *
 * @method inputPostFormatter
 * @param {Object} transaction object
 * @returns {Object}
*/
var inputPostFormatter = function(post) {

    // post.payload = utils.toHex(post.payload);
    post.ttl = utils.fromDecimal(post.ttl);
    post.workToProve = utils.fromDecimal(post.workToProve);
    post.priority = utils.fromDecimal(post.priority);

    // fallback
    if (!utils.isArray(post.topics)) {
        post.topics = post.topics ? [post.topics] : [];
    }

    // format the following options
    post.topics = post.topics.map(function(topic){
        // convert only if not hex
        return (topic.indexOf('0x') === 0) ? topic : utils.fromUtf8(topic);
    });

    return post;
};

/**
 * Formats the output of a received post message
 *
 * @method outputPostFormatter
 * @param {Object}
 * @returns {Object}
 */
var outputPostFormatter = function(post){

    post.expiry = utils.toDecimal(post.expiry);
    post.sent = utils.toDecimal(post.sent);
    post.ttl = utils.toDecimal(post.ttl);
    post.workProved = utils.toDecimal(post.workProved);
    // post.payloadRaw = post.payload;
    // post.payload = utils.toAscii(post.payload);

    // if (utils.isJson(post.payload)) {
    //     post.payload = JSON.parse(post.payload);
    // }

    // format the following options
    if (!post.topics) {
        post.topics = [];
    }
    post.topics = post.topics.map(function(topic){
        return utils.toAscii(topic);
    });

    return post;
};

var inputAddressFormatter = function (address) {
    var iban = new Iban(address);
    if (iban.isValid() && iban.isDirect()) {
        return '0x' + iban.address();
    } else if (utils.isStrictAddress(address)) {
        return address;
    } else if (utils.isAddress(address)) {
        return '0x' + address;
    }
    throw new Error('invalid address');
};


var outputSyncingFormatter = function(result) {

    result.startingBlock = utils.toDecimal(result.startingBlock);
    result.currentBlock = utils.toDecimal(result.currentBlock);
    result.highestBlock = utils.toDecimal(result.highestBlock);
    if (result.knownStates) {
        result.knownStates = utils.toDecimal(result.knownStates);
        result.pulledStates = utils.toDecimal(result.pulledStates);
    }

    return result;
};

module.exports = {
    inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,
    inputBlockNumberFormatter: inputBlockNumberFormatter,
    inputCallFormatter: inputCallFormatter,
    inputTransactionFormatter: inputTransactionFormatter,
    inputAddressFormatter: inputAddressFormatter,
    inputPostFormatter: inputPostFormatter,
    outputBigNumberFormatter: outputBigNumberFormatter,
    outputTransactionFormatter: outputTransactionFormatter,
    outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,
    outputBlockFormatter: outputBlockFormatter,
    outputLogFormatter: outputLogFormatter,
    outputPostFormatter: outputPostFormatter,
    outputSyncingFormatter: outputSyncingFormatter
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/function.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file function.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");

/**
 * This prototype should be used to call/sendTransaction to solidity functions
 */
var SolidityFunction = function (eth, json, address) {
    this._eth = eth;
    this._inputTypes = json.inputs.map(function (i) {
        return i.type;
    });
    this._outputTypes = json.outputs.map(function (i) {
        return i.type;
    });
    this._constant = json.constant;
    this._payable = json.payable;
    this._name = utils.transformToFullName(json);
    this._address = address;
};

SolidityFunction.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

SolidityFunction.prototype.extractDefaultBlock = function (args) {
    if (args.length > this._inputTypes.length && !utils.isObject(args[args.length -1])) {
        return formatters.inputDefaultBlockNumberFormatter(args.pop()); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 *
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
SolidityFunction.prototype.validateArgs = function (args) {
    var inputArgs = args.filter(function (a) {
      // filter the options object but not arguments that are arrays
      return !(utils.isObject(a) === true && utils.isArray(a) === false);
    });
    if (inputArgs.length !== this._inputTypes.length) {
        throw errors.InvalidNumberOfSolidityArgs();
    }
};

/**
 * Should be used to create payload from arguments
 *
 * @method toPayload
 * @param {Array} solidity function params
 * @param {Object} optional payload options
 */
SolidityFunction.prototype.toPayload = function (args) {
    var options = {};
    if (args.length > this._inputTypes.length && utils.isObject(args[args.length -1])) {
        options = args[args.length - 1];
    }
    this.validateArgs(args);
    options.to = this._address;
    options.data = '0x' + this.signature() + coder.encodeParams(this._inputTypes, args);
    return options;
};

/**
 * Should be used to get function signature
 *
 * @method signature
 * @return {String} function signature
 */
SolidityFunction.prototype.signature = function () {
    return sha3(this._name).slice(0, 8);
};


SolidityFunction.prototype.unpackOutput = function (output) {
    if (!output) {
        return;
    }

    output = output.length >= 2 ? output.slice(2) : output;
    var result = coder.decodeParams(this._outputTypes, output);
    return result.length === 1 ? result[0] : result;
};

/**
 * Calls a contract function.
 *
 * @method call
 * @param {...Object} Contract function arguments
 * @param {function} If the last argument is a function, the contract function
 *   call will be asynchronous, and the callback will be passed the
 *   error and result.
 * @return {String} output bytes
 */
SolidityFunction.prototype.call = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var defaultBlock = this.extractDefaultBlock(args);
    var payload = this.toPayload(args);


    if (!callback) {
        var output = this._eth.call(payload, defaultBlock);
        return this.unpackOutput(output);
    }

    var self = this;
    this._eth.call(payload, defaultBlock, function (error, output) {
        if (error) return callback(error, null);

        var unpacked = null;
        try {
            unpacked = self.unpackOutput(output);
        }
        catch (e) {
            error = e;
        }

        callback(error, unpacked);
    });
};

/**
 * Should be used to sendTransaction to solidity function
 *
 * @method sendTransaction
 */
SolidityFunction.prototype.sendTransaction = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (payload.value > 0 && !this._payable) {
        throw new Error('Cannot send value to non-payable function');
    }

    if (!callback) {
        return this._eth.sendTransaction(payload);
    }

    this._eth.sendTransaction(payload, callback);
};

/**
 * Should be used to estimateGas of solidity function
 *
 * @method estimateGas
 */
SolidityFunction.prototype.estimateGas = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (!callback) {
        return this._eth.estimateGas(payload);
    }

    this._eth.estimateGas(payload, callback);
};

/**
 * Return the encoded data of the call
 *
 * @method getData
 * @return {String} the encoded data
 */
SolidityFunction.prototype.getData = function () {
    var args = Array.prototype.slice.call(arguments);
    var payload = this.toPayload(args);

    return payload.data;
};

/**
 * Should be used to get function display name
 *
 * @method displayName
 * @return {String} display name of the function
 */
SolidityFunction.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get function type name
 *
 * @method typeName
 * @return {String} type name of the function
 */
SolidityFunction.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be called to get rpc requests from solidity function
 *
 * @method request
 * @returns {Object}
 */
SolidityFunction.prototype.request = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);
    var format = this.unpackOutput.bind(this);

    return {
        method: this._constant ? 'eth_call' : 'eth_sendTransaction',
        callback: callback,
        params: [payload],
        format: format
    };
};

/**
 * Should be called to execute function
 *
 * @method execute
 */
SolidityFunction.prototype.execute = function () {
    var transaction = !this._constant;

    // send transaction
    if (transaction) {
        return this.sendTransaction.apply(this, Array.prototype.slice.call(arguments));
    }

    // call
    return this.call.apply(this, Array.prototype.slice.call(arguments));
};

/**
 * Should be called to attach function to contract
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityFunction.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    execute.request = this.request.bind(this);
    execute.call = this.call.bind(this);
    execute.sendTransaction = this.sendTransaction.bind(this);
    execute.estimateGas = this.estimateGas.bind(this);
    execute.getData = this.getData.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = execute; // circular!!!!
};

module.exports = SolidityFunction;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/httpprovider.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file httpprovider.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */


var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

// workaround to use httpprovider in different envs

// browser
if (typeof window !== 'undefined' && window.XMLHttpRequest) {
    XMLHttpRequest = window.XMLHttpRequest; // jshint ignore: line
// node
} else {
    XMLHttpRequest = __webpack_require__("../../node_modules/web3/lib/utils/browser-xhr.js").XMLHttpRequest; // jshint ignore: line
}

var XHR2 = __webpack_require__("../../node_modules/xhr2/lib/browser.js"); // jshint ignore: line

/**
 * HttpProvider should be used to send rpc calls over http
 */
var HttpProvider = function (host, timeout) {
    this.host = host || 'http://localhost:8545';
    this.timeout = timeout || 0;
};

/**
 * Should be called to prepare new XMLHttpRequest
 *
 * @method prepareRequest
 * @param {Boolean} true if request should be async
 * @return {XMLHttpRequest} object
 */
HttpProvider.prototype.prepareRequest = function (async) {
    var request;

    if (async) {
      request = new XHR2();
      request.timeout = this.timeout;
    }else {
      request = new XMLHttpRequest();
    }

    request.open('POST', this.host, async);
    request.setRequestHeader('Content-Type','application/json');
    return request;
};

/**
 * Should be called to make sync request
 *
 * @method send
 * @param {Object} payload
 * @return {Object} result
 */
HttpProvider.prototype.send = function (payload) {
    var request = this.prepareRequest(false);

    try {
        request.send(JSON.stringify(payload));
    } catch(error) {
        throw errors.InvalidConnection(this.host);
    }

    var result = request.responseText;

    try {
        result = JSON.parse(result);
    } catch(e) {
        throw errors.InvalidResponse(request.responseText);
    }

    return result;
};

/**
 * Should be used to make async request
 *
 * @method sendAsync
 * @param {Object} payload
 * @param {Function} callback triggered on end with (err, result)
 */
HttpProvider.prototype.sendAsync = function (payload, callback) {
    var request = this.prepareRequest(true);

    request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
            var result = request.responseText;
            var error = null;

            try {
                result = JSON.parse(result);
            } catch(e) {
                error = errors.InvalidResponse(request.responseText);
            }

            callback(error, result);
        }
    };

    request.ontimeout = function() {
      callback(errors.ConnectionTimeout(this.timeout));
    };

    try {
        request.send(JSON.stringify(payload));
    } catch(error) {
        callback(errors.InvalidConnection(this.host));
    }
};

/**
 * Synchronously tries to make Http request
 *
 * @method isConnected
 * @return {Boolean} returns true if request haven't failed. Otherwise false
 */
HttpProvider.prototype.isConnected = function() {
    try {
        this.send({
            id: 9999999999,
            jsonrpc: '2.0',
            method: 'net_listening',
            params: []
        });
        return true;
    } catch(e) {
        return false;
    }
};

module.exports = HttpProvider;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/iban.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file iban.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");

var padLeft = function (string, bytes) {
    var result = string;
    while (result.length < bytes * 2) {
        result = '0' + result;
    }
    return result;
};

/**
 * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
 * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
 *
 * @method iso13616Prepare
 * @param {String} iban the IBAN
 * @returns {String} the prepared IBAN
 */
var iso13616Prepare = function (iban) {
    var A = 'A'.charCodeAt(0);
    var Z = 'Z'.charCodeAt(0);

    iban = iban.toUpperCase();
    iban = iban.substr(4) + iban.substr(0,4);

    return iban.split('').map(function(n){
        var code = n.charCodeAt(0);
        if (code >= A && code <= Z){
            // A = 10, B = 11, ... Z = 35
            return code - A + 10;
        } else {
            return n;
        }
    }).join('');
};

/**
 * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
 *
 * @method mod9710
 * @param {String} iban
 * @returns {Number}
 */
var mod9710 = function (iban) {
    var remainder = iban,
        block;

    while (remainder.length > 2){
        block = remainder.slice(0, 9);
        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
    }

    return parseInt(remainder, 10) % 97;
};

/**
 * This prototype should be used to create iban object from iban correct string
 *
 * @param {String} iban
 */
var Iban = function (iban) {
    this._iban = iban;
};

/**
 * This method should be used to create iban object from ethereum address
 *
 * @method fromAddress
 * @param {String} address
 * @return {Iban} the IBAN object
 */
Iban.fromAddress = function (address) {
    var asBn = new BigNumber(address, 16);
    var base36 = asBn.toString(36);
    var padded = padLeft(base36, 15);
    return Iban.fromBban(padded.toUpperCase());
};

/**
 * Convert the passed BBAN to an IBAN for this country specification.
 * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
 * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
 *
 * @method fromBban
 * @param {String} bban the BBAN to convert to IBAN
 * @returns {Iban} the IBAN object
 */
Iban.fromBban = function (bban) {
    var countryCode = 'XE';

    var remainder = mod9710(iso13616Prepare(countryCode + '00' + bban));
    var checkDigit = ('0' + (98 - remainder)).slice(-2);

    return new Iban(countryCode + checkDigit + bban);
};

/**
 * Should be used to create IBAN object for given institution and identifier
 *
 * @method createIndirect
 * @param {Object} options, required options are "institution" and "identifier"
 * @return {Iban} the IBAN object
 */
Iban.createIndirect = function (options) {
    return Iban.fromBban('ETH' + options.institution + options.identifier);
};

/**
 * Thos method should be used to check if given string is valid iban object
 *
 * @method isValid
 * @param {String} iban string
 * @return {Boolean} true if it is valid IBAN
 */
Iban.isValid = function (iban) {
    var i = new Iban(iban);
    return i.isValid();
};

/**
 * Should be called to check if iban is correct
 *
 * @method isValid
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isValid = function () {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) &&
        mod9710(iso13616Prepare(this._iban)) === 1;
};

/**
 * Should be called to check if iban number is direct
 *
 * @method isDirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isDirect = function () {
    return this._iban.length === 34 || this._iban.length === 35;
};

/**
 * Should be called to check if iban number if indirect
 *
 * @method isIndirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isIndirect = function () {
    return this._iban.length === 20;
};

/**
 * Should be called to get iban checksum
 * Uses the mod-97-10 checksumming protocol (ISO/IEC 7064:2003)
 *
 * @method checksum
 * @returns {String} checksum
 */
Iban.prototype.checksum = function () {
    return this._iban.substr(2, 2);
};

/**
 * Should be called to get institution identifier
 * eg. XREG
 *
 * @method institution
 * @returns {String} institution identifier
 */
Iban.prototype.institution = function () {
    return this.isIndirect() ? this._iban.substr(7, 4) : '';
};

/**
 * Should be called to get client identifier within institution
 * eg. GAVOFYORK
 *
 * @method client
 * @returns {String} client identifier
 */
Iban.prototype.client = function () {
    return this.isIndirect() ? this._iban.substr(11) : '';
};

/**
 * Should be called to get client direct address
 *
 * @method address
 * @returns {String} client direct address
 */
Iban.prototype.address = function () {
    if (this.isDirect()) {
        var base36 = this._iban.substr(4);
        var asBn = new BigNumber(base36, 36);
        return padLeft(asBn.toString(16), 20);
    } 

    return '';
};

Iban.prototype.toString = function () {
    return this._iban;
};

module.exports = Iban;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/ipcprovider.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file ipcprovider.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");


var IpcProvider = function (path, net) {
    var _this = this;
    this.responseCallbacks = {};
    this.path = path;
    
    this.connection = net.connect({path: this.path});

    this.connection.on('error', function(e){
        console.error('IPC Connection Error', e);
        _this._timeout();
    });

    this.connection.on('end', function(){
        _this._timeout();
    }); 


    // LISTEN FOR CONNECTION RESPONSES
    this.connection.on('data', function(data) {
        /*jshint maxcomplexity: 6 */

        _this._parseResponse(data.toString()).forEach(function(result){

            var id = null;

            // get the id which matches the returned id
            if(utils.isArray(result)) {
                result.forEach(function(load){
                    if(_this.responseCallbacks[load.id])
                        id = load.id;
                });
            } else {
                id = result.id;
            }

            // fire the callback
            if(_this.responseCallbacks[id]) {
                _this.responseCallbacks[id](null, result);
                delete _this.responseCallbacks[id];
            }
        });
    });
};

/**
Will parse the response and make an array out of it.

@method _parseResponse
@param {String} data
*/
IpcProvider.prototype._parseResponse = function(data) {
    var _this = this,
        returnValues = [];
    
    // DE-CHUNKER
    var dechunkedData = data
        .replace(/\}[\n\r]?\{/g,'}|--|{') // }{
        .replace(/\}\][\n\r]?\[\{/g,'}]|--|[{') // }][{
        .replace(/\}[\n\r]?\[\{/g,'}|--|[{') // }[{
        .replace(/\}\][\n\r]?\{/g,'}]|--|{') // }]{
        .split('|--|');

    dechunkedData.forEach(function(data){

        // prepend the last chunk
        if(_this.lastChunk)
            data = _this.lastChunk + data;

        var result = null;

        try {
            result = JSON.parse(data);

        } catch(e) {

            _this.lastChunk = data;

            // start timeout to cancel all requests
            clearTimeout(_this.lastChunkTimeout);
            _this.lastChunkTimeout = setTimeout(function(){
                _this._timeout();
                throw errors.InvalidResponse(data);
            }, 1000 * 15);

            return;
        }

        // cancel timeout and set chunk to null
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;

        if(result)
            returnValues.push(result);
    });

    return returnValues;
};


/**
Get the adds a callback to the responseCallbacks object,
which will be called if a response matching the response Id will arrive.

@method _addResponseCallback
*/
IpcProvider.prototype._addResponseCallback = function(payload, callback) {
    var id = payload.id || payload[0].id;
    var method = payload.method || payload[0].method;

    this.responseCallbacks[id] = callback;
    this.responseCallbacks[id].method = method;
};

/**
Timeout all requests when the end/error event is fired

@method _timeout
*/
IpcProvider.prototype._timeout = function() {
    for(var key in this.responseCallbacks) {
        if(this.responseCallbacks.hasOwnProperty(key)){
            this.responseCallbacks[key](errors.InvalidConnection('on IPC'));
            delete this.responseCallbacks[key];
        }
    }
};


/**
Check if the current connection is still valid.

@method isConnected
*/
IpcProvider.prototype.isConnected = function() {
    var _this = this;

    // try reconnect, when connection is gone
    if(!_this.connection.writable)
        _this.connection.connect({path: _this.path});

    return !!this.connection.writable;
};

IpcProvider.prototype.send = function (payload) {

    if(this.connection.writeSync) {
        var result;

        // try reconnect, when connection is gone
        if(!this.connection.writable)
            this.connection.connect({path: this.path});

        var data = this.connection.writeSync(JSON.stringify(payload));

        try {
            result = JSON.parse(data);
        } catch(e) {
            throw errors.InvalidResponse(data);                
        }

        return result;

    } else {
        throw new Error('You tried to send "'+ payload.method +'" synchronously. Synchronous requests are not supported by the IPC provider.');
    }
};

IpcProvider.prototype.sendAsync = function (payload, callback) {
    // try reconnect, when connection is gone
    if(!this.connection.writable)
        this.connection.connect({path: this.path});


    this.connection.write(JSON.stringify(payload));
    this._addResponseCallback(payload, callback);
};

module.exports = IpcProvider;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/jsonrpc.js":
/***/ (function(module, exports) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file jsonrpc.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Aaron Kumavis <aaron@kumavis.me>
 * @date 2015
 */

// Initialize Jsonrpc as a simple object with utility functions.
var Jsonrpc = {
    messageId: 0
};

/**
 * Should be called to valid json create payload object
 *
 * @method toPayload
 * @param {Function} method of jsonrpc call, required
 * @param {Array} params, an array of method params, optional
 * @returns {Object} valid jsonrpc payload object
 */
Jsonrpc.toPayload = function (method, params) {
    if (!method)
        console.error('jsonrpc method should be specified!');

    // advance message ID
    Jsonrpc.messageId++;

    return {
        jsonrpc: '2.0',
        id: Jsonrpc.messageId,
        method: method,
        params: params || []
    };
};

/**
 * Should be called to check if jsonrpc response is valid
 *
 * @method isValidResponse
 * @param {Object}
 * @returns {Boolean} true if response is valid, otherwise false
 */
Jsonrpc.isValidResponse = function (response) {
    return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);

    function validateSingleMessage(message){
      return !!message &&
        !message.error &&
        message.jsonrpc === '2.0' &&
        typeof message.id === 'number' &&
        message.result !== undefined; // only undefined is not valid json object
    }
};

/**
 * Should be called to create batch payload object
 *
 * @method toBatchPayload
 * @param {Array} messages, an array of objects with method (required) and params (optional) fields
 * @returns {Array} batch payload
 */
Jsonrpc.toBatchPayload = function (messages) {
    return messages.map(function (message) {
        return Jsonrpc.toPayload(message.method, message.params);
    });
};

module.exports = Jsonrpc;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/method.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file method.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

var Method = function (options) {
    this.name = options.name;
    this.call = options.call;
    this.params = options.params || 0;
    this.inputFormatter = options.inputFormatter;
    this.outputFormatter = options.outputFormatter;
    this.requestManager = null;
};

Method.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be used to determine name of the jsonrpc method based on arguments
 *
 * @method getCall
 * @param {Array} arguments
 * @return {String} name of jsonrpc method
 */
Method.prototype.getCall = function (args) {
    return utils.isFunction(this.call) ? this.call(args) : this.call;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Method.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 * 
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
Method.prototype.validateArgs = function (args) {
    if (args.length !== this.params) {
        throw errors.InvalidNumberOfRPCParams();
    }
};

/**
 * Should be called to format input args of method
 * 
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Method.prototype.formatInput = function (args) {
    if (!this.inputFormatter) {
        return args;
    }

    return this.inputFormatter.map(function (formatter, index) {
        return formatter ? formatter(args[index]) : args[index];
    });
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Method.prototype.formatOutput = function (result) {
    return this.outputFormatter && result ? this.outputFormatter(result) : result;
};

/**
 * Should create payload from given input args
 *
 * @method toPayload
 * @param {Array} args
 * @return {Object}
 */
Method.prototype.toPayload = function (args) {
    var call = this.getCall(args);
    var callback = this.extractCallback(args);
    var params = this.formatInput(args);
    this.validateArgs(params);

    return {
        method: call,
        params: params,
        callback: callback
    };
};

Method.prototype.attachToObject = function (obj) {
    var func = this.buildCall();
    func.call = this.call; // TODO!!! that's ugly. filter.js uses it
    var name = this.name.split('.');
    if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
    } else {
        obj[name[0]] = func; 
    }
};

Method.prototype.buildCall = function() {
    var method = this;
    var send = function () {
        var payload = method.toPayload(Array.prototype.slice.call(arguments));
        if (payload.callback) {
            return method.requestManager.sendAsync(payload, function (err, result) {
                payload.callback(err, method.formatOutput(result));
            });
        }
        return method.formatOutput(method.requestManager.send(payload));
    };
    send.request = this.request.bind(this);
    return send;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Method.prototype.request = function () {
    var payload = this.toPayload(Array.prototype.slice.call(arguments));
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Method;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/db.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file db.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");

var DB = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;
    
    methods().forEach(function(method) { 
        method.attachToObject(self);
        method.setRequestManager(web3._requestManager);
    });
};

var methods = function () {
    var putString = new Method({
        name: 'putString',
        call: 'db_putString',
        params: 3
    });

    var getString = new Method({
        name: 'getString',
        call: 'db_getString',
        params: 2
    });

    var putHex = new Method({
        name: 'putHex',
        call: 'db_putHex',
        params: 3
    });

    var getHex = new Method({
        name: 'getHex',
        call: 'db_getHex',
        params: 2
    });

    return [
        putString, getString, putHex, getHex
    ];
};

module.exports = DB;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/eth.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var Contract = __webpack_require__("../../node_modules/web3/lib/web3/contract.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var IsSyncing = __webpack_require__("../../node_modules/web3/lib/web3/syncing.js");
var namereg = __webpack_require__("../../node_modules/web3/lib/web3/namereg.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var transfer = __webpack_require__("../../node_modules/web3/lib/web3/transfer.js");

var blockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? "eth_getBlockByHash" : "eth_getBlockByNumber";
};

var transactionFromBlockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getTransactionByBlockHashAndIndex' : 'eth_getTransactionByBlockNumberAndIndex';
};

var uncleCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleByBlockHashAndIndex' : 'eth_getUncleByBlockNumberAndIndex';
};

var getBlockTransactionCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getBlockTransactionCountByHash' : 'eth_getBlockTransactionCountByNumber';
};

var uncleCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleCountByBlockHash' : 'eth_getUncleCountByBlockNumber';
};

function Eth(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });


    this.iban = Iban;
    this.sendIBANTransaction = transfer.bind(null, this);
}

Object.defineProperty(Eth.prototype, 'defaultBlock', {
    get: function () {
        return c.defaultBlock;
    },
    set: function (val) {
        c.defaultBlock = val;
        return val;
    }
});

Object.defineProperty(Eth.prototype, 'defaultAccount', {
    get: function () {
        return c.defaultAccount;
    },
    set: function (val) {
        c.defaultAccount = val;
        return val;
    }
});

var methods = function () {
    var getBalance = new Method({
        name: 'getBalance',
        call: 'eth_getBalance',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: formatters.outputBigNumberFormatter
    });

    var getStorageAt = new Method({
        name: 'getStorageAt',
        call: 'eth_getStorageAt',
        params: 3,
        inputFormatter: [null, utils.toHex, formatters.inputDefaultBlockNumberFormatter]
    });

    var getCode = new Method({
        name: 'getCode',
        call: 'eth_getCode',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var getBlock = new Method({
        name: 'getBlock',
        call: blockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, function (val) { return !!val; }],
        outputFormatter: formatters.outputBlockFormatter
    });

    var getUncle = new Method({
        name: 'getUncle',
        call: uncleCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputBlockFormatter,

    });

    var getCompilers = new Method({
        name: 'getCompilers',
        call: 'eth_getCompilers',
        params: 0
    });

    var getBlockTransactionCount = new Method({
        name: 'getBlockTransactionCount',
        call: getBlockTransactionCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getBlockUncleCount = new Method({
        name: 'getBlockUncleCount',
        call: uncleCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getTransaction = new Method({
        name: 'getTransaction',
        call: 'eth_getTransactionByHash',
        params: 1,
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionFromBlock = new Method({
        name: 'getTransactionFromBlock',
        call: transactionFromBlockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionReceipt = new Method({
        name: 'getTransactionReceipt',
        call: 'eth_getTransactionReceipt',
        params: 1,
        outputFormatter: formatters.outputTransactionReceiptFormatter
    });

    var getTransactionCount = new Method({
        name: 'getTransactionCount',
        call: 'eth_getTransactionCount',
        params: 2,
        inputFormatter: [null, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var sendRawTransaction = new Method({
        name: 'sendRawTransaction',
        call: 'eth_sendRawTransaction',
        params: 1,
        inputFormatter: [null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'eth_sendTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var signTransaction = new Method({
        name: 'signTransaction',
        call: 'eth_signTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var sign = new Method({
        name: 'sign',
        call: 'eth_sign',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, null]
    });

    var call = new Method({
        name: 'call',
        call: 'eth_call',
        params: 2,
        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var estimateGas = new Method({
        name: 'estimateGas',
        call: 'eth_estimateGas',
        params: 1,
        inputFormatter: [formatters.inputCallFormatter],
        outputFormatter: utils.toDecimal
    });

    var compileSolidity = new Method({
        name: 'compile.solidity',
        call: 'eth_compileSolidity',
        params: 1
    });

    var compileLLL = new Method({
        name: 'compile.lll',
        call: 'eth_compileLLL',
        params: 1
    });

    var compileSerpent = new Method({
        name: 'compile.serpent',
        call: 'eth_compileSerpent',
        params: 1
    });

    var submitWork = new Method({
        name: 'submitWork',
        call: 'eth_submitWork',
        params: 3
    });

    var getWork = new Method({
        name: 'getWork',
        call: 'eth_getWork',
        params: 0
    });

    return [
        getBalance,
        getStorageAt,
        getCode,
        getBlock,
        getUncle,
        getCompilers,
        getBlockTransactionCount,
        getBlockUncleCount,
        getTransaction,
        getTransactionFromBlock,
        getTransactionReceipt,
        getTransactionCount,
        call,
        estimateGas,
        sendRawTransaction,
        signTransaction,
        sendTransaction,
        sign,
        compileSolidity,
        compileLLL,
        compileSerpent,
        submitWork,
        getWork
    ];
};


var properties = function () {
    return [
        new Property({
            name: 'coinbase',
            getter: 'eth_coinbase'
        }),
        new Property({
            name: 'mining',
            getter: 'eth_mining'
        }),
        new Property({
            name: 'hashrate',
            getter: 'eth_hashrate',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'syncing',
            getter: 'eth_syncing',
            outputFormatter: formatters.outputSyncingFormatter
        }),
        new Property({
            name: 'gasPrice',
            getter: 'eth_gasPrice',
            outputFormatter: formatters.outputBigNumberFormatter
        }),
        new Property({
            name: 'accounts',
            getter: 'eth_accounts'
        }),
        new Property({
            name: 'blockNumber',
            getter: 'eth_blockNumber',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'protocolVersion',
            getter: 'eth_protocolVersion'
        })
    ];
};

Eth.prototype.contract = function (abi) {
    var factory = new Contract(this, abi);
    return factory;
};

Eth.prototype.filter = function (fil, callback, filterCreationErrorCallback) {
    return new Filter(this._requestManager, fil, watches.eth(), formatters.outputLogFormatter, callback, filterCreationErrorCallback);
};

Eth.prototype.namereg = function () {
    return this.contract(namereg.global.abi).at(namereg.global.address);
};

Eth.prototype.icapNamereg = function () {
    return this.contract(namereg.icap.abi).at(namereg.icap.address);
};

Eth.prototype.isSyncing = function (callback) {
    return new IsSyncing(this._requestManager, callback);
};

module.exports = Eth;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/net.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file eth.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

var Net = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    properties().forEach(function(p) { 
        p.attachToObject(self);
        p.setRequestManager(web3._requestManager);
    });
};

/// @returns an array of objects describing web3.eth api properties
var properties = function () {
    return [
        new Property({
            name: 'listening',
            getter: 'net_listening'
        }),
        new Property({
            name: 'peerCount',
            getter: 'net_peerCount',
            outputFormatter: utils.toDecimal
        })
    ];
};

module.exports = Net;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/personal.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");

function Personal(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var newAccount = new Method({
        name: 'newAccount',
        call: 'personal_newAccount',
        params: 1,
        inputFormatter: [null]
    });

    var importRawKey = new Method({
        name: 'importRawKey',
		call: 'personal_importRawKey',
		params: 2
    });

    var sign = new Method({
        name: 'sign',
		call: 'personal_sign',
		params: 3,
		inputFormatter: [null, formatters.inputAddressFormatter, null]
    });

    var ecRecover = new Method({
        name: 'ecRecover',
		call: 'personal_ecRecover',
		params: 2
    });

    var unlockAccount = new Method({
        name: 'unlockAccount',
        call: 'personal_unlockAccount',
        params: 3,
        inputFormatter: [formatters.inputAddressFormatter, null, null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'personal_sendTransaction',
        params: 2,
        inputFormatter: [formatters.inputTransactionFormatter, null]
    });

    var lockAccount = new Method({
        name: 'lockAccount',
        call: 'personal_lockAccount',
        params: 1,
        inputFormatter: [formatters.inputAddressFormatter]
    });

    return [
        newAccount,
        importRawKey,
        unlockAccount,
        ecRecover,
        sign,
        sendTransaction,
        lockAccount
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'listAccounts',
            getter: 'personal_listAccounts'
        })
    ];
};


module.exports = Personal;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/shh.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file shh.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

var Shh = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) { 
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });
};

Shh.prototype.filter = function (fil, callback) {
    return new Filter(this._requestManager, fil, watches.shh(), formatters.outputPostFormatter, callback);
};

var methods = function () { 

    var post = new Method({
        name: 'post', 
        call: 'shh_post', 
        params: 1,
        inputFormatter: [formatters.inputPostFormatter]
    });

    var newIdentity = new Method({
        name: 'newIdentity',
        call: 'shh_newIdentity',
        params: 0
    });

    var hasIdentity = new Method({
        name: 'hasIdentity',
        call: 'shh_hasIdentity',
        params: 1
    });

    var newGroup = new Method({
        name: 'newGroup',
        call: 'shh_newGroup',
        params: 0
    });

    var addToGroup = new Method({
        name: 'addToGroup',
        call: 'shh_addToGroup',
        params: 0
    });

    return [
        post,
        newIdentity,
        hasIdentity,
        newGroup,
        addToGroup
    ];
};

module.exports = Shh;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/swarm.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file bzz.js
 * @author Alex Beregszaszi <alex@rtfs.hu>
 * @date 2016
 *
 * Reference: https://github.com/ethereum/go-ethereum/blob/swarm/internal/web3ext/web3ext.go#L33
 */



var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

function Swarm(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var blockNetworkRead = new Method({
        name: 'blockNetworkRead',
        call: 'bzz_blockNetworkRead',
        params: 1,
        inputFormatter: [null]
    });

    var syncEnabled = new Method({
        name: 'syncEnabled',
        call: 'bzz_syncEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var swapEnabled = new Method({
        name: 'swapEnabled',
        call: 'bzz_swapEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var download = new Method({
        name: 'download',
        call: 'bzz_download',
        params: 2,
        inputFormatter: [null, null]
    });

    var upload = new Method({
        name: 'upload',
        call: 'bzz_upload',
        params: 2,
        inputFormatter: [null, null]
    });

    var retrieve = new Method({
        name: 'retrieve',
        call: 'bzz_retrieve',
        params: 1,
        inputFormatter: [null]
    });

    var store = new Method({
        name: 'store',
        call: 'bzz_store',
        params: 2,
        inputFormatter: [null, null]
    });

    var get = new Method({
        name: 'get',
        call: 'bzz_get',
        params: 1,
        inputFormatter: [null]
    });

    var put = new Method({
        name: 'put',
        call: 'bzz_put',
        params: 2,
        inputFormatter: [null, null]
    });

    var modify = new Method({
        name: 'modify',
        call: 'bzz_modify',
        params: 4,
        inputFormatter: [null, null, null, null]
    });

    return [
        blockNetworkRead,
        syncEnabled,
        swapEnabled,
        download,
        upload,
        retrieve,
        store,
        get,
        put,
        modify
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'hive',
            getter: 'bzz_hive'
        }),
        new Property({
            name: 'info',
            getter: 'bzz_info'
        })
    ];
};


module.exports = Swarm;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/watches.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file watches.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");

/// @returns an array of objects describing web3.eth.filter api methods
var eth = function () {
    var newFilterCall = function (args) {
        var type = args[0];

        switch(type) {
            case 'latest':
                args.shift();
                this.params = 0;
                return 'eth_newBlockFilter';
            case 'pending':
                args.shift();
                this.params = 0;
                return 'eth_newPendingTransactionFilter';
            default:
                return 'eth_newFilter';
        }
    };

    var newFilter = new Method({
        name: 'newFilter',
        call: newFilterCall,
        params: 1
    });

    var uninstallFilter = new Method({
        name: 'uninstallFilter',
        call: 'eth_uninstallFilter',
        params: 1
    });

    var getLogs = new Method({
        name: 'getLogs',
        call: 'eth_getFilterLogs',
        params: 1
    });

    var poll = new Method({
        name: 'poll',
        call: 'eth_getFilterChanges',
        params: 1
    });

    return [
        newFilter,
        uninstallFilter,
        getLogs,
        poll
    ];
};

/// @returns an array of objects describing web3.shh.watch api methods
var shh = function () {
    var newFilter = new Method({
        name: 'newFilter',
        call: 'shh_newFilter',
        params: 1
    });

    var uninstallFilter = new Method({
        name: 'uninstallFilter',
        call: 'shh_uninstallFilter',
        params: 1
    });

    var getLogs = new Method({
        name: 'getLogs',
        call: 'shh_getMessages',
        params: 1
    });

    var poll = new Method({
        name: 'poll',
        call: 'shh_getFilterChanges',
        params: 1
    });

    return [
        newFilter,
        uninstallFilter,
        getLogs,
        poll
    ];
};

module.exports = {
    eth: eth,
    shh: shh
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/namereg.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file namereg.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var globalRegistrarAbi = __webpack_require__("../../node_modules/web3/lib/contracts/GlobalRegistrar.json");
var icapRegistrarAbi= __webpack_require__("../../node_modules/web3/lib/contracts/ICAPRegistrar.json");

var globalNameregAddress = '0xc6d9d2cd449a754c494264e1809c50e34d64562b';
var icapNameregAddress = '0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00';

module.exports = {
    global: {
        abi: globalRegistrarAbi,
        address: globalNameregAddress
    },
    icap: {
        abi: icapRegistrarAbi,
        address: icapNameregAddress
    }
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/property.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file property.js
 * @author Fabian Vogelsteller <fabian@frozeman.de>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

var Property = function (options) {
    this.name = options.name;
    this.getter = options.getter;
    this.setter = options.setter;
    this.outputFormatter = options.outputFormatter;
    this.inputFormatter = options.inputFormatter;
    this.requestManager = null;
};

Property.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be called to format input args of method
 *
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Property.prototype.formatInput = function (arg) {
    return this.inputFormatter ? this.inputFormatter(arg) : arg;
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Property.prototype.formatOutput = function (result) {
    return this.outputFormatter && result !== null && result !== undefined ? this.outputFormatter(result) : result;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Property.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};


/**
 * Should attach function to method
 *
 * @method attachToObject
 * @param {Object}
 * @param {Function}
 */
Property.prototype.attachToObject = function (obj) {
    var proto = {
        get: this.buildGet(),
        enumerable: true
    };

    var names = this.name.split('.');
    var name = names[0];
    if (names.length > 1) {
        obj[names[0]] = obj[names[0]] || {};
        obj = obj[names[0]];
        name = names[1];
    }

    Object.defineProperty(obj, name, proto);
    obj[asyncGetterName(name)] = this.buildAsyncGet();
};

var asyncGetterName = function (name) {
    return 'get' + name.charAt(0).toUpperCase() + name.slice(1);
};

Property.prototype.buildGet = function () {
    var property = this;
    return function get() {
        return property.formatOutput(property.requestManager.send({
            method: property.getter
        }));
    };
};

Property.prototype.buildAsyncGet = function () {
    var property = this;
    var get = function (callback) {
        property.requestManager.sendAsync({
            method: property.getter
        }, function (err, result) {
            callback(err, property.formatOutput(result));
        });
    };
    get.request = this.request.bind(this);
    return get;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Property.prototype.request = function () {
    var payload = {
        method: this.getter,
        params: [],
        callback: this.extractCallback(Array.prototype.slice.call(arguments))
    };
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Property;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/requestmanager.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file requestmanager.js
 * @author Jeffrey Wilcke <jeff@ethdev.com>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Marian Oancea <marian@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @author Gav Wood <g@ethdev.com>
 * @date 2014
 */

var Jsonrpc = __webpack_require__("../../node_modules/web3/lib/web3/jsonrpc.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

/**
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 * Singleton
 */
var RequestManager = function (provider) {
    this.provider = provider;
    this.polls = {};
    this.timeout = null;
};

/**
 * Should be used to synchronously send request
 *
 * @method send
 * @param {Object} data
 * @return {Object}
 */
RequestManager.prototype.send = function (data) {
    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return null;
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    var result = this.provider.send(payload);

    if (!Jsonrpc.isValidResponse(result)) {
        throw errors.InvalidResponse(result);
    }

    return result.result;
};

/**
 * Should be used to asynchronously send request
 *
 * @method sendAsync
 * @param {Object} data
 * @param {Function} callback
 */
RequestManager.prototype.sendAsync = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    this.provider.sendAsync(payload, function (err, result) {
        if (err) {
            return callback(err);
        }
        
        if (!Jsonrpc.isValidResponse(result)) {
            return callback(errors.InvalidResponse(result));
        }

        callback(null, result.result);
    });
};

/**
 * Should be called to asynchronously send batch request
 *
 * @method sendBatch
 * @param {Array} batch data
 * @param {Function} callback
 */
RequestManager.prototype.sendBatch = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toBatchPayload(data);

    this.provider.sendAsync(payload, function (err, results) {
        if (err) {
            return callback(err);
        }

        if (!utils.isArray(results)) {
            return callback(errors.InvalidResponse(results));
        }

        callback(err, results);
    }); 
};

/**
 * Should be used to set provider of request manager
 *
 * @method setProvider
 * @param {Object}
 */
RequestManager.prototype.setProvider = function (p) {
    this.provider = p;
};

/**
 * Should be used to start polling
 *
 * @method startPolling
 * @param {Object} data
 * @param {Number} pollId
 * @param {Function} callback
 * @param {Function} uninstall
 *
 * @todo cleanup number of params
 */
RequestManager.prototype.startPolling = function (data, pollId, callback, uninstall) {
    this.polls[pollId] = {data: data, id: pollId, callback: callback, uninstall: uninstall};


    // start polling
    if (!this.timeout) {
        this.poll();
    }
};

/**
 * Should be used to stop polling for filter with given id
 *
 * @method stopPolling
 * @param {Number} pollId
 */
RequestManager.prototype.stopPolling = function (pollId) {
    delete this.polls[pollId];

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to reset the polling mechanism of the request manager
 *
 * @method reset
 */
RequestManager.prototype.reset = function (keepIsSyncing) {
    /*jshint maxcomplexity:5 */

    for (var key in this.polls) {
        // remove all polls, except sync polls,
        // they need to be removed manually by calling syncing.stopWatching()
        if(!keepIsSyncing || key.indexOf('syncPoll_') === -1) {
            this.polls[key].uninstall();
            delete this.polls[key];
        }
    }

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to poll for changes on filter with given id
 *
 * @method poll
 */
RequestManager.prototype.poll = function () {
    /*jshint maxcomplexity: 6 */
    this.timeout = setTimeout(this.poll.bind(this), c.ETH_POLLING_TIMEOUT);

    if (Object.keys(this.polls).length === 0) {
        return;
    }

    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return;
    }

    var pollsData = [];
    var pollsIds = [];
    for (var key in this.polls) {
        pollsData.push(this.polls[key].data);
        pollsIds.push(key);
    }

    if (pollsData.length === 0) {
        return;
    }

    var payload = Jsonrpc.toBatchPayload(pollsData);
    
    // map the request id to they poll id
    var pollsIdMap = {};
    payload.forEach(function(load, index){
        pollsIdMap[load.id] = pollsIds[index];
    });


    var self = this;
    this.provider.sendAsync(payload, function (error, results) {


        // TODO: console log?
        if (error) {
            return;
        }

        if (!utils.isArray(results)) {
            throw errors.InvalidResponse(results);
        }
        results.map(function (result) {
            var id = pollsIdMap[result.id];

            // make sure the filter is still installed after arrival of the request
            if (self.polls[id]) {
                result.callback = self.polls[id].callback;
                return result;
            } else
                return false;
        }).filter(function (result) {
            return !!result; 
        }).filter(function (result) {
            var valid = Jsonrpc.isValidResponse(result);
            if (!valid) {
                result.callback(errors.InvalidResponse(result));
            }
            return valid;
        }).forEach(function (result) {
            result.callback(null, result.result);
        });
    });
};

module.exports = RequestManager;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/settings.js":
/***/ (function(module, exports) {



var Settings = function () {
    this.defaultBlock = 'latest';
    this.defaultAccount = undefined;
};

module.exports = Settings;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/syncing.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file syncing.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

var count = 1;

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollSyncing
@param {Object} self
*/
var pollSyncing = function(self) {

    var onMessage = function (error, sync) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isObject(sync) && sync.startingBlock)
            sync = formatters.outputSyncingFormatter(sync);

        self.callbacks.forEach(function (callback) {
            if (self.lastSyncState !== sync) {
                
                // call the callback with true first so the app can stop anything, before receiving the sync data
                if(!self.lastSyncState && utils.isObject(sync))
                    callback(null, true);
                
                // call on the next CPU cycle, so the actions of the sync stop can be processes first
                setTimeout(function() {
                    callback(null, sync);
                }, 0);
                
                self.lastSyncState = sync;
            }
        });
    };

    self.requestManager.startPolling({
        method: 'eth_syncing',
        params: [],
    }, self.pollId, onMessage, self.stopWatching.bind(self));

};

var IsSyncing = function (requestManager, callback) {
    this.requestManager = requestManager;
    this.pollId = 'syncPoll_'+ count++;
    this.callbacks = [];
    this.addCallback(callback);
    this.lastSyncState = false;
    pollSyncing(this);

    return this;
};

IsSyncing.prototype.addCallback = function (callback) {
    if(callback)
        this.callbacks.push(callback);
    return this;
};

IsSyncing.prototype.stopWatching = function () {
    this.requestManager.stopPolling(this.pollId);
    this.callbacks = [];
};

module.exports = IsSyncing;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/transfer.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file transfer.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var exchangeAbi = __webpack_require__("../../node_modules/web3/lib/contracts/SmartExchange.json");

/**
 * Should be used to make Iban transfer
 *
 * @method transfer
 * @param {String} from
 * @param {String} to iban
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transfer = function (eth, from, to, value, callback) {
    var iban = new Iban(to); 
    if (!iban.isValid()) {
        throw new Error('invalid iban address');
    }

    if (iban.isDirect()) {
        return transferToAddress(eth, from, iban.address(), value, callback);
    }
    
    if (!callback) {
        var address = eth.icapNamereg().addr(iban.institution());
        return deposit(eth, from, address, value, iban.client());
    }

    eth.icapNamereg().addr(iban.institution(), function (err, address) {
        return deposit(eth, from, address, value, iban.client(), callback);
    });
    
};

/**
 * Should be used to transfer funds to certain address
 *
 * @method transferToAddress
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transferToAddress = function (eth, from, to, value, callback) {
    return eth.sendTransaction({
        address: to,
        from: from,
        value: value
    }, callback);
};

/**
 * Should be used to deposit funds to generic Exchange contract (must implement deposit(bytes32) method!)
 *
 * @method deposit
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be transfered
 * @param {String} client unique identifier
 * @param {Function} callback, callback
 */
var deposit = function (eth, from, to, value, client, callback) {
    var abi = exchangeAbi;
    return eth.contract(abi).at(to).deposit(client, {
        from: from,
        value: value
    }, callback);
};

module.exports = transfer;



/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../../node_modules/xhr2/lib/browser.js":
/***/ (function(module, exports) {

module.exports = XMLHttpRequest;


/***/ }),

/***/ "../../packages/components/src/adsList.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/adsList.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./adsList.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./adsList.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/button.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/button.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./button.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./button.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/icon.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/icon.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./icon.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./icon.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/input.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/input.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./input.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./input.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/label.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/label.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./label.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./label.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/link.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/link.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./link.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./link.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/linkList.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/linkList.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./linkList.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./linkList.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/loader.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/loader.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./loader.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./loader.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/paper.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/paper.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./paper.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./paper.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/textWithLabel.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/textWithLabel.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./textWithLabel.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./textWithLabel.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/tooltip.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/tooltip.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./tooltip.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./tooltip.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./images/heart.svg":
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTQxcHgiIGhlaWdodD0iMTMxcHgiIHZpZXdCb3g9IjAgMCAxNDEgMTMxIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0Ni4yICg0NDQ5NikgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+R3JvdXAgMzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxjaXJjbGUgaWQ9InBhdGgtMSIgY3g9IjYwLjc4NjEzMjgiIGN5PSI1OS43ODYxMzI4IiByPSI0NS43ODYxMzI4Ij48L2NpcmNsZT4KICAgICAgICA8ZmlsdGVyIHg9Ii0zNS41JSIgeT0iLTMwLjAlIiB3aWR0aD0iMTcxLjAlIiBoZWlnaHQ9IjE3MS4wJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTIiPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSI1IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxMCIgaW49InNoYWRvd09mZnNldE91dGVyMSIgcmVzdWx0PSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMC4wMzUyOTQxMTc2ICAgMCAwIDAgMCAwLjgzNTI5NDExOCAgIDAgMCAwIDAgMC40ODYyNzQ1MSAgMCAwIDAgMC40NSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iTVZQIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iY3JlYXRlTmV3QWRDb25maXJtYXRpb24iIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03MzYuMDAwMDAwLCAtMzYxLjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzQxLjAwMDAwMCwgMzYyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTMiPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMiIgZmlsbC1vcGFjaXR5PSIwLjIiIGZpbGw9IiMwOUQ1N0MiIGN4PSIxMDMiIGN5PSIzMyIgcj0iMzMiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMiIgZmlsbC1vcGFjaXR5PSIwLjIiIGZpbGw9IiMwOUQ1N0MiIGN4PSIzMyIgY3k9IjczIiByPSIzMyI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiMwOUQ1N0MiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJub3VuXzc0NzMwMl9jYyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzYuMDAwMDAwLCA0Mi4wMDAwMDApIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuOTU2MDQ0LDAuMTA5ODkwMTEgQzE2LjcwMzI5NjcsLTMuMDQwNjIzMzFlLTE0IDE5LjA2NTkzNDEsMC45ODkwMTA5ODkgMjAuODI0MTc1OCwyLjg1NzE0Mjg2IEwyNC44OTAxMDk5LDcuMTQyODU3MTQgQzIzLjczNjI2MzcsOC40NjE1Mzg0NiAyMi44NTcxNDI5LDkuMzk1NjA0NCAyMi41Mjc0NzI1LDkuODM1MTY0ODQgQzIxLjkyMzA3NjksOS4xNzU4MjQxOCAyMC40Mzk1NjA0LDcuNDcyNTI3NDcgMTguOTU2MDQ0LDUuODc5MTIwODggQzE3LjU4MjQxNzYsNC4zOTU2MDQ0IDE1LjcxNDI4NTcsMy42ODEzMTg2OCAxMy43MzYyNjM3LDMuNzkxMjA4NzkgQzExLjg2ODEzMTksMy45MDEwOTg5IDEwLjE2NDgzNTIsNC43ODAyMTk3OCA5LjI4NTcxNDI5LDUuOTg5MDEwOTkgQzUuOTg5MDEwOTksMTAuNTQ5NDUwNSA5LjI4NTcxNDI5LDE0LjYxNTM4NDYgOS4yODU3MTQyOSwxNC42NzAzMjk3IEwyNC44MzUxNjQ4LDMyLjYzNzM2MjYgQzIzLjY4MTMxODcsMzMuOTU2MDQ0IDIyLjg1NzE0MjksMzQuOTQ1MDU0OSAyMi40NzI1Mjc1LDM1LjMyOTY3MDMgQzIwLjg3OTEyMDksMzMuMzUxNjQ4NCAxMC4zODQ2MTU0LDIxLjQyODU3MTQgNi4yMDg3OTEyMSwxNi41OTM0MDY2IEM1LjIxOTc4MDIyLDE1LjQ5NDUwNTUgMy4xMzE4NjgxMywxMS41OTM0MDY2IDQuODM1MTY0ODQsNi43NTgyNDE3NiBDNi40ODM1MTY0OCwyLjAzMjk2NzAzIDEwLjc2OTIzMDgsMC4yMTk3ODAyMiAxMy45NTYwNDQsMC4xMDk4OTAxMSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIzLjA3NjkyMzEsMTYuMzE4NjgxMyBDMjQuNDUwNTQ5NSwxNC43MjUyNzQ3IDI4Ljk1NjA0NCw5LjQ1MDU0OTQ1IDMxLjc1ODI0MTgsNi4zNzM2MjYzNyBDMzIuODU3MTQyOSw1LjE2NDgzNTE2IDM0LjI4NTcxNDMsNC40NTA1NDk0NSAzNS45ODkwMTEsNC4zOTU2MDQ0IEMzNy4zMDc2OTIzLDQuMzQwNjU5MzQgMzguNjgxMzE4Nyw0LjcyNTI3NDczIDM5LjcyNTI3NDcsNS40Mzk1NjA0NCBDMzYuNTkzNDA2Niw1LjY1OTM0MDY2IDM1LjA1NDk0NTEsNy41Mjc0NzI1MyAzNSw3LjU4MjQxNzU4IEwyNy42MzczNjI2LDE2LjMxODY4MTMgTDIzLjA3NjkyMzEsMTYuMzE4NjgxMyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMuMDc2OTIzMDgsMTkuNDUwNTQ5NSBDMC45ODkwMTA5ODksMTcuMDMyOTY3IDAuMTY0ODM1MTY1LDEzLjc5MTIwODggMC43MTQyODU3MTQsMTAuMTY0ODM1MiBDMS4xNTM4NDYxNSw3LjAzMjk2NzAzIDMuNzM2MjYzNzQsNC4wNjU5MzQwNyA2LjY0ODM1MTY1LDIuNzQ3MjUyNzUgQzUuNjU5MzQwNjYsMy43OTEyMDg3OSA0LjgzNTE2NDg0LDUuMDU0OTQ1MDUgNC4yODU3MTQyOSw2LjU5MzQwNjU5IEMyLjQ3MjUyNzQ3LDExLjU5MzQwNjYgNC43MjUyNzQ3MywxNS44MjQxNzU4IDUuNzY5MjMwNzcsMTYuOTc4MDIyIEMxMC4yNzQ3MjUzLDIyLjE5NzgwMjIgMjIuMTQyODU3MSwzNS44MjQxNzU4IDIyLjI1Mjc0NzMsMzUuOTM0MDY1OSBMMjIuNTI3NDcyNSwzNi4yNjM3MzYzIEwyMi43NDcyNTI3LDM2LjA0Mzk1NiBDMjIuOTEyMDg3OSwzNS44NzkxMjA5IDM3LjQ3MjUyNzUsMTkuMDY1OTM0MSA0MC43MTQyODU3LDE1LjQzOTU2MDQgQzQzLjQ2MTUzODUsMTIuMzA3NjkyMyA0My4wNzY5MjMxLDcuNjM3MzYyNjQgNDAuODI0MTc1OCw1LjU0OTQ1MDU1IEMzOS42MTUzODQ2LDQuMzk1NjA0NCAzNy44MDIxOTc4LDMuNzM2MjYzNzQgMzYuMDQzOTU2LDMuOTAxMDk4OSBDMzQuMjMwNzY5MiwzLjk1NjA0Mzk2IDMyLjYzNzM2MjYsNC43ODAyMTk3OCAzMS40Mjg1NzE0LDYuMDQzOTU2MDQgQzI4LjUxNjQ4MzUsOS4yMzA3NjkyMyAyMy42MjYzNzM2LDE0Ljg5MDEwOTkgMjIuNTI3NDcyNSwxNi4xNTM4NDYyIEMyMS41Mzg0NjE1LDE0Ljk0NTA1NDkgMTcuMTk3ODAyMiw5LjY3MDMyOTY3IDE0Ljk0NTA1NDksNy4xOTc4MDIyIEMxNC4yMzA3NjkyLDYuNDI4NTcxNDMgMTMuMDIxOTc4LDUuNjA0Mzk1NiAxMC43NjkyMzA4LDUuMzg0NjE1MzggQzExLjU5MzQwNjYsNC43ODAyMTk3OCAxMi42OTIzMDc3LDQuNDUwNTQ5NDUgMTMuNzkxMjA4OCw0LjM0MDY1OTM0IEMxNS4wNTQ5NDUxLDQuMjg1NzE0MjkgMTYuOTIzMDc2OSw0LjUwNTQ5NDUxIDE4LjUxNjQ4MzUsNi4yNjM3MzYyNiBDMjAuMzg0NjE1NCw4LjI0MTc1ODI0IDIyLjI1Mjc0NzMsMTAuNDM5NTYwNCAyMi4yNTI3NDczLDEwLjQzOTU2MDQgTDIyLjQ3MjUyNzUsMTAuNjU5MzQwNyBMMjIuNjkyMzA3NywxMC40Mzk1NjA0IEMyMi42OTIzMDc3LDEwLjQzOTU2MDQgMjUsNy44MDIxOTc4IDI4LjE4NjgxMzIsNC4xNzU4MjQxOCBDMzAuOTM0MDY1OSwxLjA5ODkwMTEgMzQuMjMwNzY5MiwwIDM2LjQ4MzUxNjUsMCBDMzguNzM2MjYzNywwIDQzLjQ2MTUzODUsMS4zNzM2MjYzNyA0NS40OTQ1MDU1LDYuNjQ4MzUxNjUgQzQ2LjcwMzI5NjcsOS44MzUxNjQ4NCA0Ni4xNTM4NDYyLDE0LjA2NTkzNDEgNDQuMTc1ODI0MiwxNi4zMTg2ODEzIEMzOC41NzE0Mjg2LDIyLjg1NzE0MjkgMjQuMTc1ODI0MiwzOS4yODU3MTQzIDIyLjMwNzY5MjMsNDEuNDgzNTE2NSBDMjAuMzg0NjE1NCwzOS4yODU3MTQzIDUuMjc0NzI1MjcsMjEuOTIzMDc2OSAzLjA3NjkyMzA4LDE5LjQ1MDU0OTUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik00Ny45NjcwMzMsMTguNDYxNTM4NSBDNDMuNTcxNDI4NiwyMy40MDY1OTM0IDI5LjE3NTgyNDIsNDAuMzI5NjcwMyAyNy45MTIwODc5LDQxLjc1ODI0MTggTDIzLjAyMTk3OCw0MS43NTgyNDE4IEMyNS41NDk0NTA1LDM4Ljc5MTIwODggMzkuMjg1NzE0MywyMy4xMzE4NjgxIDQ0LjcyNTI3NDcsMTYuODEzMTg2OCBDNDYuODY4MTMxOSwxNC4zOTU2MDQ0IDQ3LjQxNzU4MjQsMTAgNDYuMDk4OTAxMSw2LjU5MzQwNjU5IEM0NS40Mzk1NjA0LDUgNDQuNjE1Mzg0NiwzLjY4MTMxODY4IDQzLjYyNjM3MzYsMi43NDcyNTI3NSBDNDYuMDQzOTU2LDMuNzkxMjA4NzkgNDcuOTEyMDg3OSw1LjQ5NDUwNTQ5IDQ5LjAxMDk4OSw3LjkxMjA4NzkxIEw0OS4wNjU5MzQxLDguMDIxOTc4MDIgQzQ5LjAxMDk4OSw3Ljk2NzAzMjk3IDUxLjgxMzE4NjgsMTQuMDEwOTg5IDQ3Ljk2NzAzMywxOC40NjE1Mzg1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"

/***/ }),

/***/ "./src/index.tsx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: /apps/node_modules/preact/dist/preact.esm.js
var preact_esm = __webpack_require__("../../node_modules/preact/dist/preact.esm.js");

// EXTERNAL MODULE: /apps/node_modules/normalize.css/normalize.css
var normalize = __webpack_require__("../../node_modules/normalize.css/normalize.css");
var normalize_default = /*#__PURE__*/__webpack_require__.n(normalize);

// EXTERNAL MODULE: /apps/node_modules/warning/browser.js
var browser = __webpack_require__("../../node_modules/warning/browser.js");
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);

// EXTERNAL MODULE: /apps/node_modules/preact-compat/dist/preact-compat.es.js
var preact_compat_es = __webpack_require__("../../node_modules/preact-compat/dist/preact-compat.es.js");

// EXTERNAL MODULE: /apps/node_modules/prop-types/index.js
var prop_types = __webpack_require__("../../node_modules/prop-types/index.js");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: /apps/node_modules/history/createBrowserHistory.js
var history_createBrowserHistory = __webpack_require__("../../node_modules/history/createBrowserHistory.js");
var createBrowserHistory_default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory);

// EXTERNAL MODULE: /apps/node_modules/invariant/browser.js
var invariant_browser = __webpack_require__("../../node_modules/invariant/browser.js");
var invariant_browser_default = /*#__PURE__*/__webpack_require__.n(invariant_browser);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/Router.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for putting history on context.
 */

var Router_Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;


    invariant_browser_default()(children == null || preact_compat_es["a" /* default */].Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    browser_default()(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? preact_compat_es["a" /* default */].Children.only(children) : null;
  };

  return Router;
}(preact_compat_es["a" /* default */].Component);

Router_Router.propTypes = {
  history: prop_types_default.a.object.isRequired,
  children: prop_types_default.a.node
};
Router_Router.contextTypes = {
  router: prop_types_default.a.object
};
Router_Router.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_Router = (Router_Router);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Router.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Router = (es_Router);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/BrowserRouter.js
function BrowserRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BrowserRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function BrowserRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter_BrowserRouter = function (_React$Component) {
  BrowserRouter__inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    BrowserRouter__classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = BrowserRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createBrowserHistory_default()(_this.props), _temp), BrowserRouter__possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');
  };

  BrowserRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(react_router_dom_es_Router, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(preact_compat_es["a" /* default */].Component);

BrowserRouter_BrowserRouter.propTypes = {
  basename: prop_types_default.a.string,
  forceRefresh: prop_types_default.a.bool,
  getUserConfirmation: prop_types_default.a.func,
  keyLength: prop_types_default.a.number,
  children: prop_types_default.a.node
};


/* harmony default export */ var es_BrowserRouter = (BrowserRouter_BrowserRouter);
// EXTERNAL MODULE: /apps/node_modules/history/createHashHistory.js
var history_createHashHistory = __webpack_require__("../../node_modules/history/createHashHistory.js");
var createHashHistory_default = /*#__PURE__*/__webpack_require__.n(history_createHashHistory);

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/HashRouter.js
function HashRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function HashRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function HashRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter_HashRouter = function (_React$Component) {
  HashRouter__inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    HashRouter__classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = HashRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createHashHistory_default()(_this.props), _temp), HashRouter__possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');
  };

  HashRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(react_router_dom_es_Router, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(preact_compat_es["a" /* default */].Component);

HashRouter_HashRouter.propTypes = {
  basename: prop_types_default.a.string,
  getUserConfirmation: prop_types_default.a.func,
  hashType: prop_types_default.a.oneOf(['hashbang', 'noslash', 'slash']),
  children: prop_types_default.a.node
};


/* harmony default export */ var es_HashRouter = (HashRouter_HashRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Link.js
var Link__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Link__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Link__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Link__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link_Link = function (_React$Component) {
  Link__inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    Link__classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Link__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), Link__possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars

    invariant_browser_default()(this.context.router, 'You should not use <Link> outside a <Router>');

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return preact_compat_es["a" /* default */].createElement('a', Link__extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(preact_compat_es["a" /* default */].Component);

Link_Link.propTypes = {
  onClick: prop_types_default.a.func,
  target: prop_types_default.a.string,
  replace: prop_types_default.a.bool,
  to: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]).isRequired,
  innerRef: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func])
};
Link_Link.defaultProps = {
  replace: false
};
Link_Link.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      push: prop_types_default.a.func.isRequired,
      replace: prop_types_default.a.func.isRequired,
      createHref: prop_types_default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ var es_Link = (Link_Link);
// EXTERNAL MODULE: /apps/node_modules/history/createMemoryHistory.js
var history_createMemoryHistory = __webpack_require__("../../node_modules/history/createMemoryHistory.js");
var createMemoryHistory_default = /*#__PURE__*/__webpack_require__.n(history_createMemoryHistory);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/MemoryRouter.js
function MemoryRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MemoryRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MemoryRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter_MemoryRouter = function (_React$Component) {
  MemoryRouter__inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    MemoryRouter__classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = MemoryRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createMemoryHistory_default()(_this.props), _temp), MemoryRouter__possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');
  };

  MemoryRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(es_Router, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(preact_compat_es["a" /* default */].Component);

MemoryRouter_MemoryRouter.propTypes = {
  initialEntries: prop_types_default.a.array,
  initialIndex: prop_types_default.a.number,
  getUserConfirmation: prop_types_default.a.func,
  keyLength: prop_types_default.a.number,
  children: prop_types_default.a.node
};


/* harmony default export */ var es_MemoryRouter = (MemoryRouter_MemoryRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/MemoryRouter.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_MemoryRouter = (es_MemoryRouter);
// EXTERNAL MODULE: /apps/node_modules/react-router/node_modules/path-to-regexp/index.js
var path_to_regexp = __webpack_require__("../../node_modules/react-router/node_modules/path-to-regexp/index.js");
var path_to_regexp_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/matchPath.js


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var matchPath_compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = path_to_regexp_default()(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;

  var _compilePath = matchPath_compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

/* harmony default export */ var es_matchPath = (matchPath);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Route.js
var Route__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Route__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Route__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Route__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var Route_isEmptyChildren = function isEmptyChildren(children) {
  return preact_compat_es["a" /* default */].Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route_Route = function (_React$Component) {
  Route__inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    Route__classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Route__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), Route__possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: Route__extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    invariant_browser_default()(router, 'You should not use <Route> or withRouter() outside a <Router>');

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return path ? es_matchPath(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    browser_default()(!(this.props.component && this.props.children && !Route_isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    browser_default()(!(this.props.render && this.props.children && !Route_isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    browser_default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    browser_default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? preact_compat_es["a" /* default */].createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !Route_isEmptyChildren(children) ? preact_compat_es["a" /* default */].Children.only(children) : null : null;
  };

  return Route;
}(preact_compat_es["a" /* default */].Component);

Route_Route.propTypes = {
  computedMatch: prop_types_default.a.object, // private, from <Switch>
  path: prop_types_default.a.string,
  exact: prop_types_default.a.bool,
  strict: prop_types_default.a.bool,
  sensitive: prop_types_default.a.bool,
  component: prop_types_default.a.func,
  render: prop_types_default.a.func,
  children: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.node]),
  location: prop_types_default.a.object
};
Route_Route.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.object.isRequired,
    route: prop_types_default.a.object.isRequired,
    staticContext: prop_types_default.a.object
  })
};
Route_Route.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_Route = (Route_Route);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Route.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Route = (es_Route);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/NavLink.js
var NavLink__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function NavLink__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink_NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref.ariaCurrent,
      rest = NavLink__objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);

  return preact_compat_es["a" /* default */].createElement(react_router_dom_es_Route, {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return preact_compat_es["a" /* default */].createElement(es_Link, NavLink__extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? NavLink__extends({}, style, activeStyle) : style,
        'aria-current': isActive && ariaCurrent
      }, rest));
    }
  });
};

NavLink_NavLink.propTypes = {
  to: es_Link.propTypes.to,
  exact: prop_types_default.a.bool,
  strict: prop_types_default.a.bool,
  location: prop_types_default.a.object,
  activeClassName: prop_types_default.a.string,
  className: prop_types_default.a.string,
  activeStyle: prop_types_default.a.object,
  style: prop_types_default.a.object,
  isActive: prop_types_default.a.func,
  ariaCurrent: prop_types_default.a.oneOf(['page', 'step', 'location', 'true'])
};

NavLink_NavLink.defaultProps = {
  activeClassName: 'active',
  ariaCurrent: 'true'
};

/* harmony default export */ var es_NavLink = (NavLink_NavLink);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Prompt.js
function Prompt__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Prompt__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Prompt__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt_Prompt = function (_React$Component) {
  Prompt__inherits(Prompt, _React$Component);

  function Prompt() {
    Prompt__classCallCheck(this, Prompt);

    return Prompt__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    invariant_browser_default()(this.context.router, 'You should not use <Prompt> outside a <Router>');

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(preact_compat_es["a" /* default */].Component);

Prompt_Prompt.propTypes = {
  when: prop_types_default.a.bool,
  message: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired
};
Prompt_Prompt.defaultProps = {
  when: true
};
Prompt_Prompt.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      block: prop_types_default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ var es_Prompt = (Prompt_Prompt);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Prompt.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Prompt = (es_Prompt);
// EXTERNAL MODULE: /apps/node_modules/resolve-pathname/index.js
var resolve_pathname = __webpack_require__("../../node_modules/resolve-pathname/index.js");

// EXTERNAL MODULE: /apps/node_modules/value-equal/index.js
var value_equal = __webpack_require__("../../node_modules/value-equal/index.js");

// CONCATENATED MODULE: /apps/node_modules/history/es/PathUtils.js
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var PathUtils_stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};
// CONCATENATED MODULE: /apps/node_modules/history/es/LocationUtils.js
var LocationUtils__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var LocationUtils_createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = LocationUtils__extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(resolve_pathname["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var LocationUtils_locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal["default"])(a.state, b.state);
};
// CONCATENATED MODULE: /apps/node_modules/history/es/createTransitionManager.js


var createTransitionManager_createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    browser_default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          browser_default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ var es_createTransitionManager = (createTransitionManager_createTransitionManager);
// CONCATENATED MODULE: /apps/node_modules/history/es/DOMUtils.js
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};
// CONCATENATED MODULE: /apps/node_modules/history/es/createBrowserHistory.js
var createBrowserHistory__typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createBrowserHistory__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory_createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant_browser_default()(canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    browser_default()(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = PathUtils_stripBasename(path, basename);

    return LocationUtils_createLocation(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = es_createTransitionManager();

  var setState = function setState(nextState) {
    createBrowserHistory__extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + createPath(location);
  };

  var push = function push(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createBrowserHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        browser_default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createBrowserHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        browser_default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      addEventListener(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      removeEventListener(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ var es_createBrowserHistory = (createBrowserHistory_createBrowserHistory);
// CONCATENATED MODULE: /apps/node_modules/history/es/createHashHistory.js
var createHashHistory__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var createHashHistory_HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory_createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant_browser_default()(canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    browser_default()(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = PathUtils_stripBasename(path, basename);

    return LocationUtils_createLocation(path);
  };

  var transitionManager = es_createTransitionManager();

  var setState = function setState(nextState) {
    createHashHistory__extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && LocationUtils_locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + createPath(location));
  };

  var push = function push(path, state) {
    browser_default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = LocationUtils_createLocation(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        browser_default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    browser_default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = LocationUtils_createLocation(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    browser_default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      addEventListener(window, createHashHistory_HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      removeEventListener(window, createHashHistory_HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ var es_createHashHistory = (createHashHistory_createHashHistory);
// CONCATENATED MODULE: /apps/node_modules/history/es/createMemoryHistory.js
var createMemoryHistory__typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createMemoryHistory__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory_createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = es_createTransitionManager();

  var setState = function setState(nextState) {
    createMemoryHistory__extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? LocationUtils_createLocation(entry, undefined, createKey()) : LocationUtils_createLocation(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = createPath;

  var push = function push(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createMemoryHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createMemoryHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ var es_createMemoryHistory = (createMemoryHistory_createMemoryHistory);
// CONCATENATED MODULE: /apps/node_modules/history/es/index.js









// CONCATENATED MODULE: /apps/node_modules/react-router/es/Redirect.js
function Redirect__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Redirect__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Redirect__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect_Redirect = function (_React$Component) {
  Redirect__inherits(Redirect, _React$Component);

  function Redirect() {
    Redirect__classCallCheck(this, Redirect);

    return Redirect__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    invariant_browser_default()(this.context.router, 'You should not use <Redirect> outside a <Router>');

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = LocationUtils_createLocation(prevProps.to);
    var nextTo = LocationUtils_createLocation(this.props.to);

    if (LocationUtils_locationsAreEqual(prevTo, nextTo)) {
      browser_default()(false, 'You tried to redirect to the same route you\'re currently on: ' + ('"' + nextTo.pathname + nextTo.search + '"'));
      return;
    }

    this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;


    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(preact_compat_es["a" /* default */].Component);

Redirect_Redirect.propTypes = {
  push: prop_types_default.a.bool,
  from: prop_types_default.a.string,
  to: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]).isRequired
};
Redirect_Redirect.defaultProps = {
  push: false
};
Redirect_Redirect.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      push: prop_types_default.a.func.isRequired,
      replace: prop_types_default.a.func.isRequired
    }).isRequired,
    staticContext: prop_types_default.a.object
  }).isRequired
};


/* harmony default export */ var es_Redirect = (Redirect_Redirect);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Redirect.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Redirect = (es_Redirect);
// EXTERNAL MODULE: /apps/node_modules/history/PathUtils.js
var PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");
var PathUtils_default = /*#__PURE__*/__webpack_require__.n(PathUtils);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/StaticRouter.js
var StaticRouter__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function StaticRouter__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function StaticRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function StaticRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function StaticRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;


  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var StaticRouter_addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return StaticRouter__extends({}, location, {
    pathname: Object(PathUtils["addLeadingSlash"])(basename) + location.pathname
  });
};

var StaticRouter_stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = Object(PathUtils["addLeadingSlash"])(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return StaticRouter__extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var StaticRouter_createLocation = function createLocation(location) {
  return typeof location === 'string' ? Object(PathUtils["parsePath"])(location) : normalizeLocation(location);
};

var StaticRouter_createURL = function createURL(location) {
  return typeof location === 'string' ? location : Object(PathUtils["createPath"])(location);
};

var StaticRouter_staticHandler = function staticHandler(methodName) {
  return function () {
    invariant_browser_default()(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter_StaticRouter = function (_React$Component) {
  StaticRouter__inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    StaticRouter__classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = StaticRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return Object(PathUtils["addLeadingSlash"])(_this.props.basename + StaticRouter_createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
      context.url = StaticRouter_createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
      context.url = StaticRouter_createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), StaticRouter__possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = StaticRouter__objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: StaticRouter_stripBasename(basename, StaticRouter_createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: StaticRouter_staticHandler('go'),
      goBack: StaticRouter_staticHandler('goBack'),
      goForward: StaticRouter_staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return preact_compat_es["a" /* default */].createElement(es_Router, StaticRouter__extends({}, props, { history: history }));
  };

  return StaticRouter;
}(preact_compat_es["a" /* default */].Component);

StaticRouter_StaticRouter.propTypes = {
  basename: prop_types_default.a.string,
  context: prop_types_default.a.object.isRequired,
  location: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object])
};
StaticRouter_StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter_StaticRouter.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_StaticRouter = (StaticRouter_StaticRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/StaticRouter.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_StaticRouter = (es_StaticRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Switch.js
function Switch__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Switch__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Switch__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch_Switch = function (_React$Component) {
  Switch__inherits(Switch, _React$Component);

  function Switch() {
    Switch__classCallCheck(this, Switch);

    return Switch__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    invariant_browser_default()(this.context.router, 'You should not use <Switch> outside a <Router>');
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    browser_default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    browser_default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    preact_compat_es["a" /* default */].Children.forEach(children, function (element) {
      if (!preact_compat_es["a" /* default */].isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          sensitive = _element$props.sensitive,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? es_matchPath(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;
      }
    });

    return match ? preact_compat_es["a" /* default */].cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(preact_compat_es["a" /* default */].Component);

Switch_Switch.contextTypes = {
  router: prop_types_default.a.shape({
    route: prop_types_default.a.object.isRequired
  }).isRequired
};
Switch_Switch.propTypes = {
  children: prop_types_default.a.node,
  location: prop_types_default.a.object
};


/* harmony default export */ var es_Switch = (Switch_Switch);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Switch.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Switch = (es_Switch);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/matchPath.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_matchPath = (es_matchPath);
// EXTERNAL MODULE: /apps/node_modules/hoist-non-react-statics/index.js
var hoist_non_react_statics = __webpack_require__("../../node_modules/hoist-non-react-statics/index.js");
var hoist_non_react_statics_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/withRouter.js
var withRouter__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function withRouter__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A public higher-order component to access the imperative API
 */
var withRouter_withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = withRouter__objectWithoutProperties(props, ['wrappedComponentRef']);

    return preact_compat_es["a" /* default */].createElement(es_Route, { render: function render(routeComponentProps) {
        return preact_compat_es["a" /* default */].createElement(Component, withRouter__extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: prop_types_default.a.func
  };

  return hoist_non_react_statics_default()(C, Component);
};

/* harmony default export */ var es_withRouter = (withRouter_withRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/withRouter.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_withRouter = (es_withRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/index.js


























// EXTERNAL MODULE: /apps/node_modules/classnames/bind.js
var bind = __webpack_require__("../../node_modules/classnames/bind.js");
var bind_default = /*#__PURE__*/__webpack_require__.n(bind);

// EXTERNAL MODULE: /apps/packages/components/src/button.scss
var src_button = __webpack_require__("../../packages/components/src/button.scss");
var button_default = /*#__PURE__*/__webpack_require__.n(src_button);

// CONCATENATED MODULE: /apps/packages/components/src/Button.tsx
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const cx = bind["bind"](src_button);
const Button = (_a) => {
    var { class: className, secondary = false } = _a, restProps = __rest(_a, ["class", "secondary"]);
    return (Object(preact_esm["c" /* h */])("button", Object.assign({ class: cx(src_button["self"], className, { primary: !secondary, secondary }) }, restProps)));
};
/* harmony default export */ var src_Button = (Button);

// CONCATENATED MODULE: ./src/pages/Home.tsx



const Home = () => (Object(preact_esm["c" /* h */])("div", null,
    Object(preact_esm["c" /* h */])(es_Link, { to: "/whitelist" },
        Object(preact_esm["c" /* h */])(src_Button, null, "Whitelist")),
    Object(preact_esm["c" /* h */])(es_Link, { to: "/status" },
        Object(preact_esm["c" /* h */])(src_Button, null, "Status")),
    Object(preact_esm["c" /* h */])(es_Link, { to: "/linklist" },
        Object(preact_esm["c" /* h */])(src_Button, null, "LinkList"))));
/* harmony default export */ var pages_Home = (Home);

// EXTERNAL MODULE: /apps/node_modules/web3/index.js
var node_modules_web3 = __webpack_require__("../../node_modules/web3/index.js");
var web3_default = /*#__PURE__*/__webpack_require__.n(node_modules_web3);

// CONCATENATED MODULE: /apps/packages/utils/src/web3.ts

let web3_web3;
if (typeof window.web3 !== 'undefined') {
    web3_web3 = new node_modules_web3(window.web3.currentProvider);
}
else {
    web3_web3 = new node_modules_web3();
}
/* harmony default export */ var src_web3 = (web3_web3);

// CONCATENATED MODULE: /apps/packages/utils/src/userAgent.ts
/* tslint:disable */
const userAgent_mobileOrTablet = () => {
    var check = false;
    (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
        check = true; })(navigator.userAgent || navigator.vendor || window.opera);
    return check;
};

// EXTERNAL MODULE: /apps/packages/components/src/link.scss
var src_link = __webpack_require__("../../packages/components/src/link.scss");
var link_default = /*#__PURE__*/__webpack_require__.n(src_link);

// CONCATENATED MODULE: /apps/packages/components/src/Link.tsx



const Link_cx = bind["bind"](src_link);
const stopPropagation = (e) => e.stopPropagation();
const src_Link_Link = ({ class: className, link, lines = 2, style: externalStyle }) => {
    if (!(lines === 2 || lines === 8)) {
        throw new Error('Only 2 and 8 lines links are available');
    }
    return (Object(preact_esm["c" /* h */])("div", { class: bind(src_link["self"], className), style: externalStyle },
        Object(preact_esm["c" /* h */])("div", { class: src_link["title"] }, link.title),
        Object(preact_esm["c" /* h */])("div", { class: Link_cx('summary', { lines2: lines === 2, lines8: lines === 8 }) }, link.summary),
        Object(preact_esm["c" /* h */])("a", { class: src_link["link"], target: "_blank", href: link.target, onClick: stopPropagation }, link.target)));
};
/* harmony default export */ var src_Link = (src_Link_Link);

// EXTERNAL MODULE: /apps/node_modules/classnames/index.js
var classnames = __webpack_require__("../../node_modules/classnames/index.js");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: /apps/packages/components/src/paper.scss
var paper = __webpack_require__("../../packages/components/src/paper.scss");
var paper_default = /*#__PURE__*/__webpack_require__.n(paper);

// CONCATENATED MODULE: /apps/packages/components/src/Paper.tsx
var Paper___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const Paper = (_a) => {
    var { class: className } = _a, restProps = Paper___rest(_a, ["class"]);
    return (Object(preact_esm["c" /* h */])("div", Object.assign({}, restProps, { class: classnames(className, paper["self"]) })));
};
/* harmony default export */ var src_Paper = (Paper);

// EXTERNAL MODULE: /apps/packages/components/src/loader.scss
var loader = __webpack_require__("../../packages/components/src/loader.scss");
var loader_default = /*#__PURE__*/__webpack_require__.n(loader);

// CONCATENATED MODULE: /apps/packages/components/src/Loader.tsx



const Loader = ({ class: className }) => {
    return Object(preact_esm["c" /* h */])("div", { class: classnames(loader["self"], className) });
};
/* harmony default export */ var src_Loader = (Loader);

// EXTERNAL MODULE: /apps/packages/components/src/textWithLabel.scss
var textWithLabel = __webpack_require__("../../packages/components/src/textWithLabel.scss");
var textWithLabel_default = /*#__PURE__*/__webpack_require__.n(textWithLabel);

// EXTERNAL MODULE: /apps/packages/components/src/label.scss
var src_label = __webpack_require__("../../packages/components/src/label.scss");
var label_default = /*#__PURE__*/__webpack_require__.n(src_label);

// CONCATENATED MODULE: /apps/packages/components/src/Label.tsx


const Label = (props) => {
    if (props && props.children) {
        return Object(preact_esm["c" /* h */])("p", { class: src_label["self"] }, props.children);
    }
    return Object(preact_esm["c" /* h */])("p", { class: src_label["self"] });
};
/* harmony default export */ var src_Label = (Label);

// CONCATENATED MODULE: /apps/packages/components/src/TextWithLabel.tsx




const TextWithLabel = ({ label, text, class: className, children }) => {
    return (Object(preact_esm["c" /* h */])("div", { class: classnames(textWithLabel["self"], className) },
        Object(preact_esm["c" /* h */])(src_Label, null, label),
        Object(preact_esm["c" /* h */])("p", { class: textWithLabel["text"] }, text || children)));
};
/* harmony default export */ var src_TextWithLabel = (TextWithLabel);

// CONCATENATED MODULE: /apps/packages/components/src/Svg.tsx

const getSvgContentRegxp = /<svg[^>]*>(.*)<\/svg>/;
const Svg = ({ svg, size, viewBox, class: className }) => {
    let svgContent;
    const regexpResult = getSvgContentRegxp.exec(svg);
    if (regexpResult) {
        svgContent = regexpResult[1];
    }
    return (Object(preact_esm["c" /* h */])("svg", { class: className, style: { width: size }, alt: name, dangerouslySetInnerHTML: { __html: svgContent }, viewBox: viewBox, xmlns: "http://www.w3.org/2000/svg" }));
};
/* harmony default export */ var src_Svg = (Svg);

// EXTERNAL MODULE: /apps/node_modules/open-iconic/font/css/open-iconic.min.css
var open_iconic_min = __webpack_require__("../../node_modules/open-iconic/font/css/open-iconic.min.css");
var open_iconic_min_default = /*#__PURE__*/__webpack_require__.n(open_iconic_min);

// EXTERNAL MODULE: /apps/packages/components/src/icon.scss
var src_icon = __webpack_require__("../../packages/components/src/icon.scss");
var icon_default = /*#__PURE__*/__webpack_require__.n(src_icon);

// CONCATENATED MODULE: /apps/packages/components/src/Icon.tsx
var Icon___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};




const Icon = (_a) => {
    var { name, class: className } = _a, restProps = Icon___rest(_a, ["name", "class"]);
    return (Object(preact_esm["c" /* h */])("span", Object.assign({ class: classnames(src_icon["self"], className, 'oi'), "data-glyph": name, "aria-hidden": "true" }, restProps)));
};
/* harmony default export */ var src_Icon = (Icon);

// EXTERNAL MODULE: /apps/packages/components/src/tooltip.scss
var tooltip = __webpack_require__("../../packages/components/src/tooltip.scss");
var tooltip_default = /*#__PURE__*/__webpack_require__.n(tooltip);

// CONCATENATED MODULE: /apps/packages/components/src/Tooltip.tsx



const Tooltip = ({ class: className, style: externalStyle, text, children }) => (Object(preact_esm["c" /* h */])("div", { style: externalStyle, class: classnames(tooltip["self"], className) },
    children,
    text && Object(preact_esm["c" /* h */])("div", { class: tooltip["text"] }, text)));
/* harmony default export */ var src_Tooltip = (Tooltip);

// EXTERNAL MODULE: ./src/pages/Status/components/steps.scss
var steps = __webpack_require__("./src/pages/Status/components/steps.scss");
var steps_default = /*#__PURE__*/__webpack_require__.n(steps);

// CONCATENATED MODULE: ./src/pages/Status/components/Steps.tsx






const Steps_cx = bind["bind"](steps);
const cubeSvg = __webpack_require__("../../node_modules/svg-inline-loader/index.js?removeTags=true&removeSVGTagAttrs=true!./images/cube.svg");
const Step = ({ icon, state, children }) => (Object(preact_esm["c" /* h */])("div", { class: Steps_cx(steps["step"], { [state]: true }) },
    Object(preact_esm["c" /* h */])("div", { class: steps["icon"] }, icon),
    Object(preact_esm["c" /* h */])("div", { class: steps["content"] }, children)));
const Progress = ({ step0State, step1State, step2State, step0Ref, step1Ref, step2Ref }) => {
    const lastDoneStep = [step2State, step1State, step0State].indexOf('done');
    const lastDoneElement = [step2Ref, step1Ref, step0Ref][lastDoneStep];
    const fillStyle = {
        width: 0,
        height: 0,
        maxWidth: 0,
        maxHeight: 0,
    };
    if (lastDoneElement) {
        const rowDirection = step0Ref.base.offsetTop === step1Ref.base.offsetTop;
        fillStyle.width = fillStyle.maxWidth = rowDirection
            ? lastDoneElement.base.offsetLeft + lastDoneElement.base.offsetWidth / 2
            : '100%';
        fillStyle.height = fillStyle.maxHeight = !rowDirection
            ? lastDoneElement.base.offsetTop + lastDoneElement.base.offsetHeight / 2
            : '100%';
    }
    return (Object(preact_esm["c" /* h */])("div", { class: steps["progressCotainer"] },
        Object(preact_esm["c" /* h */])("div", { class: steps["progress"] },
            Object(preact_esm["c" /* h */])("div", { class: steps["progressFill"], style: fillStyle }))));
};
class Steps_Steps extends preact_esm["a" /* Component */] {
    constructor() {
        super(...arguments);
        this._onRef = (name) => (ref) => this[name] = ref;
    }
    render({ context, linkId, link, blockchainState }) {
        let step0State;
        let step0Reason;
        if (link) {
            step0State = 'done';
        }
        else if (blockchainState.web3Available) {
            if (blockchainState.blockNumber) {
                step0State = 'done';
            }
            else {
                step0State = 'waiting';
                step0Reason = 'Waiting for blockchain';
            }
        }
        else {
            step0State = 'disabled';
            step0Reason = 'Web is unavailable';
        }
        const step1State = step0State === 'waiting'
            ? 'notstarted'
            : link ? 'done' : 'waiting';
        const step2State = step1State === 'waiting' || step1State === 'notstarted'
            ? 'notstarted'
            : link && link.whitelisted ? 'done' : 'waiting';
        const [network] = context.split(':');
        const networkPrefix = network !== 'eth' ? `${network}.` : '';
        const [, tx] = linkId.split(':');
        const etherscanUrl = link ? `https://${networkPrefix}etherscan.io/tx/${tx}` : '';
        return (Object(preact_esm["c" /* h */])("div", { class: steps["self"] },
            Object(preact_esm["c" /* h */])(Progress, { step0State: step0State, step1State: step1State, step2State: step2State, step0Ref: this.step0Ref, step1Ref: this.step1Ref, step2Ref: this.step2Ref }),
            Object(preact_esm["c" /* h */])("div", { class: steps["stepsContainer"] },
                Object(preact_esm["c" /* h */])(Step, { ref: this._onRef('step0Ref'), state: step0State, icon: Object(preact_esm["c" /* h */])(src_Tooltip, { text: step0Reason },
                        Object(preact_esm["c" /* h */])(src_Icon, { class: steps["icon"], name: "eye" })) },
                    Object(preact_esm["c" /* h */])("p", null, "Visible on blockchain"),
                    Object(preact_esm["c" /* h */])("a", { href: etherscanUrl, target: "_blank" },
                        "Etherscan ",
                        Object(preact_esm["c" /* h */])(src_Icon, { name: "external-link" }))),
                Object(preact_esm["c" /* h */])(Step, { ref: this._onRef('step1Ref'), state: step1State, icon: Object(preact_esm["c" /* h */])(src_Svg, { svg: cubeSvg, size: "1.2em", viewBox: "0 0 23 27" }) },
                    Object(preact_esm["c" /* h */])("p", null, "Userfeeds Address"),
                    Object(preact_esm["c" /* h */])("span", null, "Visible to publisher")),
                Object(preact_esm["c" /* h */])(Step, { ref: this._onRef('step2Ref'), state: step2State, icon: Object(preact_esm["c" /* h */])(src_Icon, { class: steps["icon"], name: "check" }) },
                    Object(preact_esm["c" /* h */])("p", null, "Put on whitelist"),
                    Object(preact_esm["c" /* h */])("span", null, "All set!")))));
    }
}

// EXTERNAL MODULE: ./src/pages/Status/Status.scss
var Status_Status = __webpack_require__("./src/pages/Status/Status.scss");
var Status_default = /*#__PURE__*/__webpack_require__.n(Status_Status);

// CONCATENATED MODULE: ./src/pages/Status/index.tsx
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};










const heartSvg = __webpack_require__("./images/heart.svg");
const getTransactionReceipt = (tx) => {
    return new Promise((resolve, reject) => {
        src_web3.eth.getTransactionReceipt(tx, (error, result) => {
            if (error) {
                return reject(error);
            }
            resolve(result);
        });
    });
};
const getBlockNumber = () => {
    return new Promise((resolve, reject) => {
        src_web3.eth.getBlockNumber((error, currentBlockNumber) => {
            if (error) {
                return reject(error);
            }
            resolve(currentBlockNumber);
        });
    });
};
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
class pages_Status_Status extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        // ToDo fix - when network is unaailable
        this._fetchLinks = (context, algorithm, whitelist) => __awaiter(this, void 0, void 0, function* () {
            const baseURL = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/`, { cache: 'no-store' })
                    .then((res) => res.json());
                const whitelistedLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/?whitelist=${whitelist}`, { cache: 'no-store' })
                    .then((res) => res.json());
                const [allLinks, whitelistedLinks] = yield Promise.all([allLinksRequest,
                    whitelistedLinksRequest]);
                const links = allLinks.items.map((link) => {
                    const whitelisted = whitelistedLinks.items.find((a) => link.id === a.id);
                    return Object.assign({}, link, { whitelisted: !!whitelisted });
                });
                return links;
            }
            catch (_) {
                return [];
            }
        });
        this._observeBlockchainState = (linkId) => __awaiter(this, void 0, void 0, function* () {
            if (!src_web3.isConnected()) {
                return this.setState({ blockchain: Object.assign({}, this.state.blockchain, { web3Available: false }) });
            }
            this.setState({ blockchain: Object.assign({}, this.state.blockchain, { web3Available: true }) });
            const [, tx] = linkId.split(':');
            let receipt;
            do {
                receipt = yield getTransactionReceipt(tx);
                yield wait(1000);
            } while (!receipt);
            const currentBlockNumber = yield getBlockNumber();
            this.setState({
                blockchain: Object.assign({}, this.state.blockchain, { blockNumber: receipt.blockNumber, currentBlockNumber }),
            });
        });
        this._findLinkById = (linkId) => (links) => {
            const link = links.find((l) => l.id === linkId);
            this.setState({ link });
            return link;
        };
        this._bookmarkIt = (e) => {
            e.preventDefault();
            const bookmarkURL = window.location.href;
            const bookmarkTitle = document.title;
            if (!this.state.mobileOrTablet) {
                // Other browsers (mainly WebKit - Chrome/Safari)
                const commandKey = /Mac/i.test(navigator.userAgent) ? 'CMD' : 'Ctrl';
                alert(`Please press ${(commandKey)} D to add this page to your bookmarks.`);
            }
        };
        const params = new URLSearchParams(props.location.search);
        const context = params.get('context') || '';
        const algorithm = params.get('algorithm') || '';
        const whitelist = params.get('whitelist') || '';
        const linkId = params.get('linkId') || '';
        const publisherNote = params.get('publisherNote') || '';
        const location = params.get('location') || '';
        this.state = {
            mobileOrTablet: userAgent_mobileOrTablet(),
            linkId,
            context,
            algorithm,
            whitelist,
            publisherNote,
            location,
            blockchain: {
                web3Available: false,
                blockNumber: null,
                currentBlockNumber: null,
            },
        };
        this._observeBlockchainState(linkId);
        const setTimeoutForFetch = (timeout) => {
            setTimeout(() => {
                this._fetchLinks(context, algorithm, whitelist)
                    .then(this._findLinkById(linkId))
                    .then((link) => link && !link.whitelisted && setTimeoutForFetch(5000));
            }, timeout);
        };
        setTimeoutForFetch(0);
    }
    render() {
        if (!this.state.context) {
            return null;
        }
        const { mobileOrTablet, linkId, context, link, blockchain, location } = this.state;
        return (Object(preact_esm["c" /* h */])("div", { class: Status_Status["self"] },
            Object(preact_esm["c" /* h */])("div", null,
                Object(preact_esm["c" /* h */])("p", { class: Status_Status["previewTitle"] }, "Link preview:"),
                Object(preact_esm["c" /* h */])(src_Paper, { class: Status_Status["preview"] },
                    link && Object(preact_esm["c" /* h */])(src_Link, { link: link }),
                    !link && Object(preact_esm["c" /* h */])("div", { class: Status_Status["loader"] },
                        Object(preact_esm["c" /* h */])(src_Loader, null)))),
            Object(preact_esm["c" /* h */])(src_Paper, { class: Status_Status["content"] },
                Object(preact_esm["c" /* h */])("div", { class: Status_Status["introduction"] },
                    Object(preact_esm["c" /* h */])("img", { src: heartSvg }),
                    Object(preact_esm["c" /* h */])("h2", null, "Your link has been succesfully submited!"),
                    Object(preact_esm["c" /* h */])("p", null, "In order to track its progress please save the link")),
                Object(preact_esm["c" /* h */])("div", { class: Status_Status["info"] },
                    Object(preact_esm["c" /* h */])(src_TextWithLabel, { class: Status_Status["label"], label: "Link status:" },
                        Object(preact_esm["c" /* h */])("div", { class: Status_Status["linkLabel"] },
                            Object(preact_esm["c" /* h */])("a", { class: Status_Status["link"], href: window.location.href }, window.location.href),
                            !mobileOrTablet && Object(preact_esm["c" /* h */])(src_Button, { secondary: true, class: Status_Status["addBookmark"], onClick: this._bookmarkIt }, "Add to bookmarks"))),
                    Object(preact_esm["c" /* h */])(src_TextWithLabel, { class: Status_Status["label"], label: "Widget location:" },
                        Object(preact_esm["c" /* h */])("a", { href: location }, location))),
                Object(preact_esm["c" /* h */])(Steps_Steps, { linkId: linkId, context: context, link: link, blockchainState: blockchain }))));
    }
}

// EXTERNAL MODULE: /apps/node_modules/@userfeeds/core/index.js
var core = __webpack_require__("../../node_modules/@userfeeds/core/index.js");
var core_default = /*#__PURE__*/__webpack_require__.n(core);

// EXTERNAL MODULE: /apps/node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__("../../node_modules/lodash.debounce/index.js");
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);

// EXTERNAL MODULE: /apps/packages/components/src/input.scss
var input = __webpack_require__("../../packages/components/src/input.scss");
var input_default = /*#__PURE__*/__webpack_require__.n(input);

// CONCATENATED MODULE: /apps/packages/components/src/Input.tsx
var Input___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const Input_cx = bind["bind"](input);
class Input_Input extends preact_esm["a" /* Component */] {
    constructor() {
        super(...arguments);
        this._onInputRef = (ref) => this.input = ref;
        this._onPlaceholderClick = () => {
            if (this.input) {
                this.input.focus();
            }
        };
    }
    render(_a) {
        var { class: className, placeholder, errorMessage, value, multiline, disabled = false } = _a, restProps = Input___rest(_a, ["class", "placeholder", "errorMessage", "value", "multiline", "disabled"]);
        return (Object(preact_esm["c" /* h */])("div", { class: Input_cx(input["self"], className, { invalid: !!errorMessage }) },
            !multiline ? (Object(preact_esm["c" /* h */])("input", Object.assign({ ref: this._onInputRef, class: input["input"], value: value, disabled: disabled, required: true }, restProps))) : (Object(preact_esm["c" /* h */])("textarea", Object.assign({ ref: this._onInputRef, class: input["input"], value: value, disabled: disabled, required: true, rows: 3 }, restProps))),
            Object(preact_esm["c" /* h */])("span", { class: input["placeholder"], onClick: this._onPlaceholderClick }, placeholder),
            errorMessage && Object(preact_esm["c" /* h */])("span", { class: input["error"] }, errorMessage)));
    }
}

// EXTERNAL MODULE: /apps/packages/components/src/adsList.scss
var adsList = __webpack_require__("../../packages/components/src/adsList.scss");
var adsList_default = /*#__PURE__*/__webpack_require__.n(adsList);

// CONCATENATED MODULE: /apps/packages/components/src/AdsList.tsx



const AdsList_noop = () => null;
const Ad = ({ ad, onClick }) => (Object(preact_esm["c" /* h */])("div", { class: adsList["row"] },
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])("div", null,
            "URL: ",
            Object(preact_esm["c" /* h */])("a", { href: ad.target }, ad.target)),
        Object(preact_esm["c" /* h */])("div", null,
            "score: ",
            web3.fromWei(ad.score, 'ether')),
        Object(preact_esm["c" /* h */])("div", null, ad.title),
        Object(preact_esm["c" /* h */])("div", null, ad.summary)),
    Object(preact_esm["c" /* h */])("div", { class: adsList["button"] },
        Object(preact_esm["c" /* h */])(src_Button, { onClick: onClick.bind(null, ad), disabled: ad.whitelisted }, "Add to whitelist"))));
const AdsList = ({ ads = [], onItemClick = AdsList_noop }) => (Object(preact_esm["c" /* h */])("div", { class: adsList["self"] }, ads.map((ad) => (Object(preact_esm["c" /* h */])(Ad, { ad: ad, onClick: onItemClick })))));
/* harmony default export */ var src_AdsList = (AdsList);

// EXTERNAL MODULE: ./src/pages/Whitelist.scss
var Whitelist = __webpack_require__("./src/pages/Whitelist.scss");
var Whitelist_default = /*#__PURE__*/__webpack_require__.n(Whitelist);

// CONCATENATED MODULE: ./src/pages/Whitelist.tsx
var Whitelist___awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







class Whitelist_Creator extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._onContextChange = (e) => {
            this.setState({ context: e.target.value });
            this._fetchLinks();
        };
        this._onWhitelistChange = (e) => {
            this.setState({ whitelist: e.target.value });
            this._fetchLinks();
        };
        this._fetchLinks = lodash_debounce_default()(() => Whitelist___awaiter(this, void 0, void 0, function* () {
            const { context, algorithm, whitelist } = this.state;
            this.setState({ fetching: true });
            const baseURL = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/`)
                    .then((res) => res.json());
                const whitelistedLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/?whitelist=${whitelist}`)
                    .then((res) => res.json());
                const [allLinks, whitelistedLinks] = yield Promise.all([
                    allLinksRequest,
                    whitelistedLinksRequest,
                ]);
                const links = allLinks.items.map((link) => {
                    const whitelisted = !!whitelistedLinks.items.find((a) => link.id === a.id);
                    return Object.assign({}, link, { whitelisted });
                });
                this.setState({ links, fetching: false });
            }
            catch (_) {
                this.setState({ fetching: false });
            }
        }), 500);
        this._onLinkClick = (link) => {
            const [_, address] = this.state.whitelist.split(':');
            const claim = {
                claim: { target: link.id },
                credits: [{
                        type: 'interface',
                        value: window.location.href,
                    }],
            };
            core_default.a.ethereum.claims.sendClaim(address, claim);
        };
        const params = new URLSearchParams(props.location.search);
        this.state = {
            links: [],
            fetching: false,
            context: params.get('context') || '',
            algorithm: params.get('algorithm') || 'links',
            whitelist: params.get('whitelist') || '',
            contextFromParams: params.has('context'),
            whitelistFromParams: params.has('whitelist'),
        };
    }
    componentWillMount() {
        if (this.state.contextFromParams) {
            this._fetchLinks();
        }
    }
    render() {
        return (Object(preact_esm["c" /* h */])("div", { class: Whitelist["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Whitelist["paper"] },
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Userfeed ID", value: this.state.context, onInput: this._onContextChange, disabled: this.state.contextFromParams }),
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Whitelist ID", value: this.state.whitelist, onInput: this._onWhitelistChange, disabled: this.state.whitelistFromParams }),
                Object(preact_esm["c" /* h */])(src_AdsList, { ads: this.state.links, onItemClick: this._onLinkClick }))));
    }
}

// EXTERNAL MODULE: /apps/packages/components/src/linkList.scss
var linkList = __webpack_require__("../../packages/components/src/linkList.scss");
var linkList_default = /*#__PURE__*/__webpack_require__.n(linkList);

// CONCATENATED MODULE: /apps/packages/components/src/LinkList.tsx


const LinkList_noop = () => null;
const LinkList_Link = ({ link }) => (Object(preact_esm["c" /* h */])("div", { class: linkList["row"] },
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])("div", null,
            "URL: ",
            Object(preact_esm["c" /* h */])("a", { href: link.target }, link.target)),
        Object(preact_esm["c" /* h */])("div", null, link.summary))));
const LinkList_LinkList = ({ links = [] }) => (Object(preact_esm["c" /* h */])("div", { class: linkList["self"] }, links.map((link) => (Object(preact_esm["c" /* h */])(LinkList_Link, { link: link })))));
/* harmony default export */ var src_LinkList = (LinkList_LinkList);

// CONCATENATED MODULE: ./src/pages/LinkList.tsx
var LinkList___awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






class pages_LinkList_LinkList extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._onContextChange = (e) => {
            this.setState({ context: e.target.value });
            this._fetchLinks();
        };
        this._fetchLinks = lodash_debounce_default()(() => LinkList___awaiter(this, void 0, void 0, function* () {
            const { context } = this.state;
            this.setState({ fetching: true });
            const fetchUrl = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${fetchUrl}/${context}/authored/?type=link`)
                    .then((res) => res.json());
                const [allLinks] = yield Promise.all([allLinksRequest]);
                this.setState({ links: allLinks.items, fetching: false });
                return allLinks;
            }
            catch (_) {
                this.setState({ fetching: false });
                return null;
            }
        }), 500);
        const params = new URLSearchParams(props.location.search);
        this.state = {
            links: [],
            fetching: false,
            context: params.get('context') || '',
            algorithm: params.get('algorithm') || 'links',
            contextFromParams: params.has('context'),
        };
    }
    componentWillMount() {
        if (this.state.contextFromParams) {
            this._fetchLinks();
        }
    }
    render() {
        return (Object(preact_esm["c" /* h */])("div", { class: Whitelist["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Whitelist["paper"] },
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Advertiser ID", value: this.state.context, onInput: this._onContextChange, disabled: this.state.contextFromParams }),
                Object(preact_esm["c" /* h */])(src_LinkList, { links: this.state.links }))));
    }
}

// CONCATENATED MODULE: ./src/App.tsx






const App = () => (Object(preact_esm["c" /* h */])(es_HashRouter, null,
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { exact: true, path: "/", component: pages_Home }),
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { path: "/status", component: pages_Status_Status }),
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { path: "/whitelist", component: Whitelist_Creator }),
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { path: "/linklist", component: pages_LinkList_LinkList }))));
/* harmony default export */ var src_App = (App);

// EXTERNAL MODULE: ./styles/all.scss
var styles_all = __webpack_require__("./styles/all.scss");
var all_default = /*#__PURE__*/__webpack_require__.n(styles_all);

// CONCATENATED MODULE: ./src/index.tsx




const root = document.querySelector('.root');
if (root) {
    Object(preact_esm["e" /* render */])(Object(preact_esm["c" /* h */])(src_App, null), root);
}


/***/ }),

/***/ "./src/pages/Status/Status.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/Status.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Status.scss", function() {
			var newContent = require("!!../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Status.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/pages/Status/components/steps.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/components/steps.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./steps.scss", function() {
			var newContent = require("!!../../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./steps.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/pages/Whitelist.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Whitelist.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Whitelist.scss", function() {
			var newContent = require("!!../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Whitelist.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./styles/all.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./styles/all.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./all.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./all.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTUyN2I5YzEwNWMxODRlMGM5MTEiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL2V0aGVyZXVtQ2xhaW1zLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy91dGlscy9jb250cmFjdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9iaW5kLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy11dGYxNi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jZmIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWVjYi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtYW5zaXg5MjMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzEwMTI2LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtbm9wYWRkaW5nLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC16ZXJvcGFkZGluZy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LWxlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JpcGVtZDE2MC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3RyaXBsZWRlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzP2FjNWEiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2Nzcy9vcGVuLWljb25pYy5taW4uY3NzP2NlNmUiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLmVvdCIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMub3RmIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5zdmciLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLnR0ZiIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMud29mZiIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3ByZWFjdC1jb21wYXQvZGlzdC9wcmVhY3QtY29tcGF0LmVzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0LmVzbS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9pbWFnZXMvY3ViZS5zdmciLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2Fkc0xpc3Quc2Nzcz8xOGFkIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2Nzcz82ZGRjIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pY29uLnNjc3M/MjgzYSIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaW5wdXQuc2Nzcz9mNDJkIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzPzNjMmUiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmsuc2Nzcz83NWUyIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rTGlzdC5zY3NzPzE3NzciLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xvYWRlci5zY3NzPzliOTIiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3BhcGVyLnNjc3M/NmExMCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzP2ZiN2QiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzcz9lMTU3Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9TdGF0dXMvU3RhdHVzLnNjc3M/NTQ5ZiIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2Nzcz9jMWNlIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9XaGl0ZWxpc3Quc2Nzcz9jNzg0Iiwid2VicGFjazovLy8uL3N0eWxlcy9hbGwuc2Nzcz80MjdmIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL0lDQVBSZWdpc3RyYXIuanNvbiIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb24iLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9hZGRyZXNzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYm9vbC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2J5dGVzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9keW5hbWljYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9mb3JtYXR0ZXJzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvaW50LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvcGFyYW0uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9yZWFsLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvc3RyaW5nLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdHlwZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3VpbnQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91cmVhbC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL2Jyb3dzZXIteGhyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvY29uZmlnLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvc2hhMy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL3V0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdmVyc2lvbi5qc29uIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvYWxsZXZlbnRzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9iYXRjaC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvY29udHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2V4dGVuZC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZmlsdGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9mb3JtYXR0ZXJzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaHR0cHByb3ZpZGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9pYmFuLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9pcGNwcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvanNvbnJwYy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2RiLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2V0aC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9uZXQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvcGVyc29uYWwuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvc2hoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3N3YXJtLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3dhdGNoZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL25hbWVyZWcuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3Byb3BlcnR5LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9yZXF1ZXN0bWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3N5bmNpbmcuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3RyYW5zZmVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3hocjIvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2Fkc0xpc3Quc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYnV0dG9uLnNjc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2ljb24uc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaW5wdXQuc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGFiZWwuc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rTGlzdC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sb2FkZXIuc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90b29sdGlwLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vaW1hZ2VzL2hlYXJ0LnN2ZyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0xvY2F0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvQnV0dG9uLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL3V0aWxzL3NyYy93ZWIzLnRzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy91dGlscy9zcmMvdXNlckFnZW50LnRzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9MaW5rLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvUGFwZXIudHN4Iiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9Mb2FkZXIudHN4Iiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9MYWJlbC50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1RleHRXaXRoTGFiZWwudHN4Iiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9TdmcudHN4Iiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9JY29uLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvVG9vbHRpcC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL1N0ZXBzLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3RhdHVzL2luZGV4LnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvSW5wdXQudHN4Iiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9BZHNMaXN0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGlua0xpc3QudHN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9MaW5rTGlzdC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3RhdHVzL1N0YXR1cy5zY3NzIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9zdGVwcy5zY3NzIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9XaGl0ZWxpc3Quc2NzcyIsIndlYnBhY2s6Ly8vLi9zdHlsZXMvYWxsLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVC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O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixFQUFFOzs7QUFHRixDQUFDLEc7Ozs7Ozs7QUM5SUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDakJELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDM0VELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUMzUUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQzdFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDbkhELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUN6REQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDdkNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQ3JERCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUNoREQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDM0NELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDdkNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDN0JELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQzFJRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa2RBQWtkLCtCQUErQjtBQUNqZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0IsT0FBTztBQUN6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QTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUNsVUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQ2xGRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDbFVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBOzs7Ozs7Ozs7QUMzRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsMkI7Ozs7Ozs7O0FDdERBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU8sWUFBWSxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFGO0FBQ3JGOzs7Ozs7OztBQ2w4QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQUE7QUFDSCxFQUFFO0FBQ0YsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdEpBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ3RGQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSyxFO0FBQ0w7O0FBRUE7Ozs7Ozs7OztBQ2hFQTtBQUNB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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDM09BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDN1NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxjQUFjLEVBQUU7QUFDL0Y7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2pXQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOzs7Ozs7Ozs7QUNuREE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTs7Ozs7Ozs7QUNsSEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDcEZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTs7Ozs7Ozs7QUNoSkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2hIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDckNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDOUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxFO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7OztB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OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFn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Iiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2FwcHMvbGlua3MvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c3hcIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYTUyN2I5YzEwNWMxODRlMGM5MTEiLCJcbm1vZHVsZS5leHBvcnRzID0ge1xuICBldGhlcmV1bToge1xuICAgIGNsYWltczogcmVxdWlyZSgnLi9zcmMvZXRoZXJldW1DbGFpbXMnKSxcbiAgfSxcbiAgdXRpbHM6IHJlcXVpcmUoJy4vc3JjL3V0aWxzJyksXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCB7IGdldEN1cnJlbnROZXR3b3JrTmFtZSB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3Qge1xuICBwYXlhYmxlQWJpLFxuICBub3RwYXlhYmxlQWJpLFxuICBnZXRDb250cmFjdEFkZHJlc3MsXG59ID0gcmVxdWlyZSgnLi91dGlscy9jb250cmFjdCcpO1xuXG5mdW5jdGlvbiBzZW5kUGF5YWJsZUNsYWltKGFkZHJlc3MsIGNsYWltLCB2YWx1ZSkge1xuICBjb25zdCBjb250cmFjdCA9IHdlYjMuZXRoLmNvbnRyYWN0KHBheWFibGVBYmkpXG4gICAgLmF0KGdldENvbnRyYWN0QWRkcmVzcyhnZXRDdXJyZW50TmV0d29ya05hbWUoKSwgdHJ1ZSkpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29udHJhY3QucG9zdChcbiAgICAgIGFkZHJlc3MsXG4gICAgICBKU09OLnN0cmluZ2lmeShjbGFpbSksXG4gICAgICB7IHZhbHVlOiB3ZWIzLnRvV2VpKHZhbHVlLCAnZXRoZXInKSB9LFxuICAgICAgKGVycnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChlcnJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbmROb3RwYXlhYmxlQ2xhaW0oYWRkcmVzcywgY2xhaW0pIHtcbiAgY29uc3QgY29udHJhY3QgPSB3ZWIzLmV0aC5jb250cmFjdChub3RwYXlhYmxlQWJpKVxuICAgIC5hdChnZXRDb250cmFjdEFkZHJlc3MoZ2V0Q3VycmVudE5ldHdvcmtOYW1lKCksIGZhbHNlKSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb250cmFjdC5wb3N0KFxuICAgICAgSlNPTi5zdHJpbmdpZnkoY2xhaW0pLFxuICAgICAgKGVycnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChlcnJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbmRDbGFpbShhZGRyZXNzLCBjbGFpbSwgdmFsdWUpIHtcbiAgY29uc3QgcGF5YWJsZSA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIHBheWFibGVcbiAgICA/IHNlbmRQYXlhYmxlQ2xhaW0oYWRkcmVzcywgY2xhaW0sIHZhbHVlKVxuICAgIDogc2VuZE5vdHBheWFibGVDbGFpbShhZGRyZXNzLCBjbGFpbSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZW5kQ2xhaW0sXG4gIHNlbmRQYXlhYmxlQ2xhaW0sXG4gIHNlbmROb3RwYXlhYmxlQ2xhaW0sXG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy9ldGhlcmV1bUNsYWltcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvZXRoZXJldW1DbGFpbXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5jb25zdCBwYXlhYmxlQ29udHJhY3RBZGRyZXNzTWFwcGluZyA9IHtcbiAgcm9wc3RlbjogJzB4YTg0NWM2ODZhNjk2YzNkMzM5ODg5MTdjMzg3ZDhhYjkzOWM2NjIyNicsXG4gIHJpbmtlYnk6ICcweDBhNDhhYzgyNjNkOWQ3OTc2OGQxMGNmOWQ3ZTgyYTE5YzQ5ZjAwMDInLFxufTtcblxuY29uc3Qgbm90cGF5YWJsZUNvbnRyYWN0QWRkcmVzc01hcHBpbmcgPSB7XG4gIHJvcHN0ZW46ICcweDVjM2ZlNmI5NGI1N2MxZTI5NDAwMDQwMzM0MGYxMmYwODNlNzFiODMnLFxuICByaW5rZWJ5OiAnMHgwOWRjZGYzNGUwYzI4YjEwNmZkZmU1MTAwOWNiNzFhZTkyYmY4YmJjJyxcbn07XG5cbmZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyhuZXR3b3JrTmFtZSwgcGF5YWJsZSA9IHRydWUpIHtcbiAgbGV0IGNvbnRyYWN0O1xuICBpZiAocGF5YWJsZSkge1xuICAgIGNvbnRyYWN0ID0gcGF5YWJsZUNvbnRyYWN0QWRkcmVzc01hcHBpbmdbbmV0d29ya05hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNvbnRyYWN0ID0gbm90cGF5YWJsZUNvbnRyYWN0QWRkcmVzc01hcHBpbmdbbmV0d29ya05hbWVdO1xuICB9XG5cbiAgaWYgKCFjb250cmFjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3QgaXMgbm90IGF2YWlsYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyYWN0O1xufVxuXG5jb25zdCBwYXlhYmxlQWJpID0gW3tcbiAgY29uc3RhbnQ6IGZhbHNlLFxuICBpbnB1dHM6IFtcbiAgICB7IG5hbWU6ICd1c2VyZmVlZCcsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIHsgbmFtZTogJ2RhdGEnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICBdLFxuICBuYW1lOiAncG9zdCcsXG4gIG91dHB1dHM6IFtdLFxuICBwYXlhYmxlOiB0cnVlLFxuICB0eXBlOiAnZnVuY3Rpb24nLFxufSwge1xuICBhbm9ueW1vdXM6IGZhbHNlLFxuICBpbnB1dHM6IFtcbiAgICB7IG5hbWU6ICdzZW5kZXInLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IGZhbHNlIH0sXG4gICAgeyBuYW1lOiAndXNlcmZlZWQnLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IGZhbHNlIH0sXG4gICAgeyBuYW1lOiAnZGF0YScsIHR5cGU6ICdzdHJpbmcnLCBpbmRleGVkOiBmYWxzZSB9LFxuICBdLFxuICBuYW1lOiAnQ2xhaW0nLFxuICB0eXBlOiAnZXZlbnQnLFxufV07XG5cbmNvbnN0IG5vdHBheWFibGVBYmkgPSBbe1xuICBjb25zdGFudDogZmFsc2UsXG4gIGlucHV0czogW1xuICAgIHsgbmFtZTogJ2RhdGEnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICBdLFxuICBuYW1lOiAncG9zdCcsXG4gIG91dHB1dHM6IFtdLFxuICBwYXlhYmxlOiBmYWxzZSxcbiAgdHlwZTogJ2Z1bmN0aW9uJyxcbn0sIHtcbiAgYW5vbnltb3VzOiBmYWxzZSxcbiAgaW5wdXRzOiBbXG4gICAgeyBuYW1lOiAnc2VuZGVyJywgdHlwZTogJ2FkZHJlc3MnLCBpbmRleGVkOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogJ2RhdGEnLCB0eXBlOiAnc3RyaW5nJywgaW5kZXhlZDogZmFsc2UgfSxcbiAgXSxcbiAgbmFtZTogJ0NsYWltJyxcbiAgdHlwZTogJ2V2ZW50J1xufV07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXlhYmxlQWJpLFxuICBub3RwYXlhYmxlQWJpLFxuICBnZXRDb250cmFjdEFkZHJlc3MsXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvdXRpbHMvY29udHJhY3QuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL3V0aWxzL2NvbnRyYWN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuY29uc3QgbmV0d29ya01hcHBpbmcgPSB7XG4gICcxJzogJ2V0aGVyZXVtJyxcbiAgJzMnOiAncm9wc3RlbicsXG4gICc0JzogJ3JpbmtlYnknLFxuICAnNDInOiAna292YW4nLFxufTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudE5ldHdvcmtOYW1lKCkge1xuICBpZiAoIXdlYjMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dlYjMgbm90IGF2YWlsYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIG5ldHdvcmtNYXBwaW5nW3dlYjMudmVyc2lvbi5uZXR3b3JrXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEN1cnJlbnROZXR3b3JrTmFtZSxcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL3V0aWxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy91dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgYmlnbnVtYmVyLmpzIHY0LjAuNCBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanMvTElDRU5DRSAqL1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsT2JqKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLypcclxuICAgICAgYmlnbnVtYmVyLmpzIHY0LjAuNFxyXG4gICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICAgICAgQ29weXJpZ2h0IChjKSAyMDE3IE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAgICAgIE1JVCBFeHBhdCBMaWNlbmNlXHJcbiAgICAqL1xyXG5cclxuXHJcbiAgICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgICAgIGlzTnVtZXJpYyA9IC9eLT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgICAgICAgbm90Qm9vbCA9ICcgbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQnLFxyXG4gICAgICAgIHJvdW5kaW5nTW9kZSA9ICdyb3VuZGluZyBtb2RlJyxcclxuICAgICAgICB0b29NYW55RGlnaXRzID0gJ251bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzJyxcclxuICAgICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJyxcclxuICAgICAgICBCQVNFID0gMWUxNCxcclxuICAgICAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAgICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgICAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgICAgICAgKiB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24sIGJleW9uZCB3aGljaCBhblxyXG4gICAgICAgICAqIGV4Y2VwdGlvbiBpcyB0aHJvd24gKGlmIEVSUk9SUyBpcyB0cnVlKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdG9yRmFjdG9yeShjb25maWcpIHtcclxuICAgICAgICB2YXIgZGl2LCBwYXJzZU51bWVyaWMsXHJcblxyXG4gICAgICAgICAgICAvLyBpZCB0cmFja3MgdGhlIGNhbGxlciBmdW5jdGlvbiwgc28gaXRzIG5hbWUgY2FuIGJlIGluY2x1ZGVkIGluIGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICAgICAgICBpZCA9IDAsXHJcbiAgICAgICAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlLFxyXG4gICAgICAgICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRURJVEFCTEUgREVGQVVMVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAgICAgICAgKiBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLmNvbmZpZy5cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAgICAgICAgKiB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgICAgICAgICAqIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgICAgICAgICogRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgICAgICAgICogQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAgICAgICAgKiBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgICAgICAgICAqIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgICAgICAgICogSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAgICAgICAgKiBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAgICAgICAgKiBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgICAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICAgICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIEJpZ051bWJlciBFcnJvcnMgYXJlIGV2ZXIgdGhyb3duLlxyXG4gICAgICAgICAgICBFUlJPUlMgPSB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgICAgICAgIC8vIENoYW5nZSB0byBpbnRWYWxpZGF0b3JOb0Vycm9ycyBpZiBFUlJPUlMgaXMgZmFsc2UuXHJcbiAgICAgICAgICAgIGlzVmFsaWRJbnQgPSBpbnRWYWxpZGF0b3JXaXRoRXJyb3JzLCAgICAgLy8gaW50VmFsaWRhdG9yV2l0aEVycm9ycy9pbnRWYWxpZGF0b3JOb0Vycm9yc1xyXG5cclxuICAgICAgICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgICAgICAgICAqIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAgICAgICAgKiBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgICogRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAgICAgICAgKiBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgICAgICAgICAqIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgKiBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAgICAgICAgKiBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAgKiBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSB0b1Bvd2VyIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICAgICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICAgICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gICAgICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIG4uIEludGVnZXIsIDIgdG8gNjQgaW5jbHVzaXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJpZ051bWJlciggbiwgYiApIHtcclxuICAgICAgICAgICAgdmFyIGMsIGUsIGksIG51bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciB1c2FnZSB3aXRob3V0IG5ldy5cclxuICAgICAgICAgICAgaWYgKCAhKCB4IGluc3RhbmNlb2YgQmlnTnVtYmVyICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gJ0JpZ051bWJlcigpIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBuZXc6IHtufSdcclxuICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCAyNiwgJ2NvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBuZXcnLCBuICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggbiwgYiApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIGJhc2Ugbm90IGFuIGludGVnZXI6IHtifSdcclxuICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xyXG4gICAgICAgICAgICBpZiAoIGIgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggYiwgMiwgNjQsIGlkLCAnYmFzZScgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEdXBsaWNhdGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG4gaW5zdGFuY2VvZiBCaWdOdW1iZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gbi5zO1xyXG4gICAgICAgICAgICAgICAgICAgIHguZSA9IG4uZTtcclxuICAgICAgICAgICAgICAgICAgICB4LmMgPSAoIG4gPSBuLmMgKSA/IG4uc2xpY2UoKSA6IG47XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICggbnVtID0gdHlwZW9mIG4gPT0gJ251bWJlcicgKSAmJiBuICogMCA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IDEgLyBuIDwgMCA/ICggbiA9IC1uLCAtMSApIDogMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPT09IH5+biApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZSA9IDAsIGkgPSBuOyBpID49IDEwOyBpIC89IDEwLCBlKysgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5jID0gW25dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IG4gKyAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNOdW1lcmljLnRlc3QoIHN0ciA9IG4gKyAnJyApICkgcmV0dXJuIHBhcnNlTnVtZXJpYyggeCwgc3RyLCBudW0gKTtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiID0gYiB8IDA7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBuICsgJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHJldHVybiB2YWx1ZSBpcyByb3VuZGVkIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgIGlmICggYiA9PSAxMCApIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlciggbiBpbnN0YW5jZW9mIEJpZ051bWJlciA/IG4gOiBzdHIgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoIHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIC8vIEFueSBudW1iZXIgaW4gZXhwb25lbnRpYWwgZm9ybSB3aWxsIGZhaWwgZHVlIHRvIHRoZSBbRWVdWystXS5cclxuICAgICAgICAgICAgICAgIGlmICggKCBudW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJyApICYmIG4gKiAwICE9IDAgfHxcclxuICAgICAgICAgICAgICAgICAgISggbmV3IFJlZ0V4cCggJ14tPycgKyAoIGMgPSAnWycgKyBBTFBIQUJFVC5zbGljZSggMCwgYiApICsgJ10rJyApICtcclxuICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgYyArICcpPyQnLGIgPCAzNyA/ICdpJyA6ICcnICkgKS50ZXN0KHN0cikgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyggeCwgc3RyLCBudW0sIGIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gMSAvIG4gPCAwID8gKCBzdHIgPSBzdHIuc2xpY2UoMSksIC0xICkgOiAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIEVSUk9SUyAmJiBzdHIucmVwbGFjZSggL14wXFwuMCp8XFwuLywgJycgKS5sZW5ndGggPiAxNSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbnVtYmVyIHR5cGUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UoIGlkLCB0b29NYW55RGlnaXRzLCBuICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICAgICAgICAgICAgICBudW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKCBzdHIgPSBzdHIuc2xpY2UoMSksIC0xICkgOiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKCBzdHIsIDEwLCBiLCB4LnMgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICAgICAgaWYgKCAoIGUgPSBzdHIuaW5kZXhPZignLicpICkgPiAtMSApIHN0ciA9IHN0ci5yZXBsYWNlKCAnLicsICcnICk7XHJcblxyXG4gICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgICAgICBpZiAoICggaSA9IHN0ci5zZWFyY2goIC9lL2kgKSApID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGUgPCAwICkgZSA9IGk7XHJcbiAgICAgICAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoIGkgKyAxICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKCAwLCBpICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyApO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKCBsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4OyApO1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoIGksIGxlbiArIDEgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWxsb3cgbnVtYmVycyB3aXRoIG92ZXIgMTUgc2lnbmlmaWNhbnQgZGlnaXRzIGlmIG51bWJlciB0eXBlLlxyXG4gICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgICAgICAgaWYgKCBudW0gJiYgRVJST1JTICYmIGxlbiA+IDE1ICYmICggbiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgbiAhPT0gbWF0aGZsb29yKG4pICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIGlkLCB0b29NYW55RGlnaXRzLCB4LnMgKiBuICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZSA9IGUgLSBpIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgICAgICAgICBpZiAoIGUgPiBNQVhfRVhQICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBNSU5fRVhQICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IFsgeC5lID0gMCBdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9ICggZSArIDEgKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZSA8IDAgKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCBsZW4gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCggK3N0ci5zbGljZSggMCwgaSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jLnB1c2goICtzdHIuc2xpY2UoIGksIGkgKz0gTE9HX0JBU0UgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIHN0ci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGktLTsgc3RyICs9ICcwJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHguYy5wdXNoKCArc3RyICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICAgIHguYyA9IFsgeC5lID0gMCBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICAgICAgQmlnTnVtYmVyLmFub3RoZXIgPSBjb25zdHJ1Y3RvckZhY3Rvcnk7XHJcblxyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICAgICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQWNjZXB0IGFuIG9iamVjdCBvciBhbiBhcmd1bWVudCBsaXN0LCB3aXRoIG9uZSBvciBtYW55IG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBvclxyXG4gICAgICAgICAqIHBhcmFtZXRlcnMgcmVzcGVjdGl2ZWx5OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICBERUNJTUFMX1BMQUNFUyAge251bWJlcn0gIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZVxyXG4gICAgICAgICAqICAgUk9VTkRJTkdfTU9ERSAgIHtudW1iZXJ9ICBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlXHJcbiAgICAgICAgICogICBFWFBPTkVOVElBTF9BVCAge251bWJlcnxudW1iZXJbXX0gIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbC4sIDAgdG8gTUFYIGluY2wuXVxyXG4gICAgICAgICAqICAgUkFOR0UgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsLiwgaW50ZWdlciAxIHRvIE1BWCBpbmNsLl1cclxuICAgICAgICAgKiAgIEVSUk9SUyAgICAgICAgICB7Ym9vbGVhbnxudW1iZXJ9ICAgdHJ1ZSwgZmFsc2UsIDEgb3IgMFxyXG4gICAgICAgICAqICAgQ1JZUFRPICAgICAgICAgIHtib29sZWFufG51bWJlcn0gICB0cnVlLCBmYWxzZSwgMSBvciAwXHJcbiAgICAgICAgICogICBNT0RVTE9fTU9ERSAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOSBpbmNsdXNpdmVcclxuICAgICAgICAgKiAgIFBPV19QUkVDSVNJT04gICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVggaW5jbHVzaXZlXHJcbiAgICAgICAgICogICBGT1JNQVQgICAgICAgICAge29iamVjdH0gICAgICAgICAgIFNlZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0XHJcbiAgICAgICAgICogICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRS5nLlxyXG4gICAgICAgICAqIEJpZ051bWJlci5jb25maWcoMjAsIDQpIGlzIGVxdWl2YWxlbnQgdG9cclxuICAgICAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHYsIHAsXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIHIgPSB7fSxcclxuICAgICAgICAgICAgICAgIGEgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICBvID0gYVswXSxcclxuICAgICAgICAgICAgICAgIGhhcyA9IG8gJiYgdHlwZW9mIG8gPT0gJ29iamVjdCdcclxuICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IGlmICggby5oYXNPd25Qcm9wZXJ0eShwKSApIHJldHVybiAoIHYgPSBvW3BdICkgIT0gbnVsbDsgfVxyXG4gICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgaWYgKCBhLmxlbmd0aCA+IGkgKSByZXR1cm4gKCB2ID0gYVtpKytdICkgIT0gbnVsbDsgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIERFQ0lNQUxfUExBQ0VTIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBERUNJTUFMX1BMQUNFUyBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnREVDSU1BTF9QTEFDRVMnICkgJiYgaXNWYWxpZEludCggdiwgMCwgTUFYLCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHYgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBERUNJTUFMX1BMQUNFUztcclxuXHJcbiAgICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJPVU5ESU5HX01PREUgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJPVU5ESU5HX01PREUgb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ1JPVU5ESU5HX01PREUnICkgJiYgaXNWYWxpZEludCggdiwgMCwgOCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHYgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBFWFBPTkVOVElBTF9BVCBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVhQT05FTlRJQUxfQVQgb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0VYUE9ORU5USUFMX0FUJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSh2KSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzVmFsaWRJbnQoIHZbMF0sIC1NQVgsIDAsIDIsIHAgKSAmJiBpc1ZhbGlkSW50KCB2WzFdLCAwLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF0gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggaXNWYWxpZEludCggdiwgLU1BWCwgTUFYLCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oIFRPX0VYUF9QT1MgPSAoIHYgPCAwID8gLXYgOiB2ICkgfCAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IFsgVE9fRVhQX05FRywgVE9fRVhQX1BPUyBdO1xyXG5cclxuICAgICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBSQU5HRSBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0UgY2Fubm90IGJlIHplcm86IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJBTkdFIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdSQU5HRScgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGlzQXJyYXkodikgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1ZhbGlkSW50KCB2WzBdLCAtTUFYLCAtMSwgMiwgcCApICYmIGlzVmFsaWRJbnQoIHZbMV0sIDEsIE1BWCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpc1ZhbGlkSW50KCB2LCAtTUFYLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHYgfCAwICkgTUlOX0VYUCA9IC0oIE1BWF9FWFAgPSAoIHYgPCAwID8gLXYgOiB2ICkgfCAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoRVJST1JTKSByYWlzZSggMiwgcCArICcgY2Fubm90IGJlIHplcm8nLCB2ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IFsgTUlOX0VYUCwgTUFYX0VYUCBdO1xyXG5cclxuICAgICAgICAgICAgLy8gRVJST1JTIHtib29sZWFufG51bWJlcn0gdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIEVSUk9SUyBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdFUlJPUlMnICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB2ID09PSAhIXYgfHwgdiA9PT0gMSB8fCB2ID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkSW50ID0gKCBFUlJPUlMgPSAhIXYgKSA/IGludFZhbGlkYXRvcldpdGhFcnJvcnMgOiBpbnRWYWxpZGF0b3JOb0Vycm9ycztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsIHAgKyBub3RCb29sLCB2ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IEVSUk9SUztcclxuXHJcbiAgICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbnxudW1iZXJ9IHRydWUsIGZhbHNlLCAxIG9yIDAuXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBDUllQVE8gbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQ6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIGNyeXB0byB1bmF2YWlsYWJsZToge2NyeXB0b30nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0NSWVBUTycgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHYgPT09IHRydWUgfHwgdiA9PT0gZmFsc2UgfHwgdiA9PT0gMSB8fCB2ID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0eXBlb2YgY3J5cHRvID09ICd1bmRlZmluZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICF2ICYmIGNyeXB0byAmJiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUllQVE8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVSUk9SUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsICdjcnlwdG8gdW5hdmFpbGFibGUnLCB2ID8gdm9pZCAwIDogY3J5cHRvICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsIHAgKyBub3RCb29sLCB2ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IENSWVBUTztcclxuXHJcbiAgICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBNT0RVTE9fTU9ERSBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgTU9EVUxPX01PREUgb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ01PRFVMT19NT0RFJyApICYmIGlzVmFsaWRJbnQoIHYsIDAsIDksIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdiB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IE1PRFVMT19NT0RFO1xyXG5cclxuICAgICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBQT1dfUFJFQ0lTSU9OIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBQT1dfUFJFQ0lTSU9OIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdQT1dfUFJFQ0lTSU9OJyApICYmIGlzVmFsaWRJbnQoIHYsIDAsIE1BWCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHYgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdGT1JNQVQnICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdiA9PSAnb2JqZWN0JyApIHtcclxuICAgICAgICAgICAgICAgICAgICBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZSggMiwgcCArICcgbm90IGFuIG9iamVjdCcsIHYgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gRk9STUFUO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4T3JNaW4oIGFyZ3VtZW50cywgUC5sdCApOyB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhPck1pbiggYXJndW1lbnRzLCBQLmd0ICk7IH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICdyYW5kb20oKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAgICAgKiAncmFuZG9tKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xyXG4gICAgICAgICAqICdyYW5kb20oKSBjcnlwdG8gdW5hdmFpbGFibGU6IHtjcnlwdG99J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAgICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICAgICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vciggTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMgKTsgfVxyXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZHAgPSBkcCA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAxNCApID8gREVDSU1BTF9QTEFDRVMgOiBkcCB8IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gbWF0aGNlaWwoIGRwIC8gTE9HX0JBU0UgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoIG5ldyBVaW50MzJBcnJheSggayAqPSAyICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGs7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2ID49IDllMTUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoIG5ldyBVaW50MzJBcnJheSgyKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKCB2ICUgMWUxNCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKCBrICo9IDcgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGs7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9ICggKCBhW2ldICYgMzEgKSAqIDB4MTAwMDAwMDAwMDAwMCApICsgKCBhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDAgKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFbaSArIDJdICogMHgxMDAwMDAwMDAgKSArICggYVtpICsgM10gKiAweDEwMDAwMDAgKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFbaSArIDRdIDw8IDE2ICkgKyAoIGFbaSArIDVdIDw8IDggKSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA+PSA5ZTE1ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KCBhLCBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnB1c2goIHYgJSAxZTE0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEVSUk9SUykgcmFpc2UoIDE0LCAnY3J5cHRvIHVuYXZhaWxhYmxlJywgY3J5cHRvICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICAgICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGs7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2IDwgOWUxNSApIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgICAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBrICYmIGRwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgICAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKCBrIC8gdiApICogdjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbIGUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpIDwgTE9HX0JBU0UgKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgICAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICAgICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKCk7XHJcblxyXG5cclxuICAgICAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgICAgZnVuY3Rpb24gY29udmVydEJhc2UoIHN0ciwgYmFzZU91dCwgYmFzZUluLCBzaWduICkge1xyXG4gICAgICAgICAgICB2YXIgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICAgICAgICBpID0gc3RyLmluZGV4T2YoICcuJyApLFxyXG4gICAgICAgICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgICAgIGlmICggYmFzZUluIDwgMzcgKSBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgICAgICBpZiAoIGkgPj0gMCApIHtcclxuICAgICAgICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCAnLicsICcnICk7XHJcbiAgICAgICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgICAgICAgeCA9IHkucG93KCBzdHIubGVuZ3RoIC0gaSApO1xyXG4gICAgICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG4gICAgICAgICAgICAgICAgeS5jID0gdG9CYXNlT3V0KCB0b0ZpeGVkUG9pbnQoIGNvZWZmVG9TdHJpbmcoIHguYyApLCB4LmUgKSwgMTAsIGJhc2VPdXQgKTtcclxuICAgICAgICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG4gICAgICAgICAgICB4YyA9IHRvQmFzZU91dCggc3RyLCBiYXNlSW4sIGJhc2VPdXQgKTtcclxuICAgICAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSApO1xyXG4gICAgICAgICAgICBpZiAoICF4Y1swXSApIHJldHVybiAnMCc7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgLS1lO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgICAgICAgIHggPSBkaXYoIHgsIHksIGRwLCBybSwgYmFzZU91dCApO1xyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAgICAgaSA9IHhjW2RdO1xyXG4gICAgICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgciA9IHJtIDwgNCA/ICggaSAhPSBudWxsIHx8IHIgKSAmJiAoIHJtID09IDAgfHwgcm0gPT0gKCB4LnMgPCAwID8gMyA6IDIgKSApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYoIHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHJtID09ICggeC5zIDwgMCA/IDggOiA3ICkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZCA8IDEgfHwgIXhjWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDFeLWRwIG9yIDAuXHJcbiAgICAgICAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KCAnMScsIC1kcCApIDogJzAnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IEFMUEhBQkVULmNoYXJBdCggeGNbaSsrXSApICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgICAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KCB4LCBrLCBiYXNlICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgICAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB4ID0geC5zbGljZSgpOyBpLS07ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKCAoIG0gJSBTUVJUX0JBU0UgKSAqIFNRUlRfQkFTRSApICsgY2Fycnk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAoIHRlbXAgLyBiYXNlIHwgMCApICsgKCBtIC8gU1FSVF9CQVNFIHwgMCApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGFyZSggYSwgYiwgYUwsIGJMICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFMICE9IGJMICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gY21wID0gMDsgaSA8IGFMOyBpKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFbaV0gIT0gYltpXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWJ0cmFjdCggYSwgYiwgYUwsIGJhc2UgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGFMLS07ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggeCwgeSwgZHAsIHJtLCBiYXNlICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgICAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICggeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YyApID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICAgICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgICAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhYmFzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgICAgICAgICAgICBlID0gYml0Rmxvb3IoIHguZSAvIExPR19CQVNFICkgLSBiaXRGbG9vciggeS5lIC8gTE9HX0JBU0UgKTtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyB5Y1tpXSA9PSAoIHhjW2ldIHx8IDAgKTsgaSsrICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHljW2ldID4gKCB4Y1tpXSB8fCAwICkgKSBlLS07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggYmFzZSAvICggeWNbMF0gKyAxICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKCBiYXNlIC8gMiApIC0gMS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuID4gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWMgPSBtdWx0aXBseSggeWMsIG4sIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMgPSBtdWx0aXBseSggeGMsIG4sIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSB4Yy5zbGljZSggMCwgeUwgKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICAgICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB5Y1sxXSA+PSBiYXNlIC8gMiApIHljMCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmICggYmFzZSA9PSAzICYmIHljMCA9PSAxICkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoIHljLCByZW0sIHlMLCByZW1MICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNtcCA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHlMICE9IHJlbUwgKSByZW0wID0gcmVtMCAqIGJhc2UgKyAoIHJlbVsxXSB8fCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggcmVtMCAvIHljMCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMS4gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdCAobilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAyLiBpZiBwcm9kdWN0ID4gcmVtYWluZGVyOiBwcm9kdWN0IC09IGRpdmlzb3IsIG4tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDMuIHJlbWFpbmRlciAtPSBwcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgNC4gaWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIgYXQgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDUuIGNvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgNi4gSWYgcmVtYWluZGVyID4gZGl2aXNvcjogcmVtYWluZGVyIC09IGRpdmlzb3IsIG4rK1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoIHljLCBuLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY29tcGFyZSggcHJvZCwgcmVtLCBwcm9kTCwgcmVtTCApID09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuID09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9kTCA8IHJlbUwgKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QoIHJlbSwgcHJvZCwgcmVtTCwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjbXAgPT0gLTEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBjb21wYXJlKCB5YywgcmVtLCB5TCwgcmVtTCApIDwgMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QoIHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNtcCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZW1bMF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gWyB4Y1t4aV0gXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoICggeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsICkgJiYgcy0tICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXFjWzBdICkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYmFzZSA9PSBCQVNFICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91bmQoIHEsIGRwICsgKCBxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSApICsgMSwgcm0sIG1vcmUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkoKTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiBpcyBhIEJpZ051bWJlci5cclxuICAgICAgICAgKiBpIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgICAgICogcm0gaXMgdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgICAgICogY2FsbGVyIGlzIGNhbGxlciBpZDogdG9FeHBvbmVudGlhbCAxOSwgdG9GaXhlZCAyMCwgdG9Gb3JtYXQgMjEsIHRvUHJlY2lzaW9uIDI0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdCggbiwgaSwgcm0sIGNhbGxlciApIHtcclxuICAgICAgICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICAgICAgICBybSA9IHJtICE9IG51bGwgJiYgaXNWYWxpZEludCggcm0sIDAsIDgsIGNhbGxlciwgcm91bmRpbmdNb2RlIClcclxuICAgICAgICAgICAgICA/IHJtIHwgMCA6IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgICAgICBpZiAoICFuLmMgKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGkgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gY2FsbGVyID09IDE5IHx8IGNhbGxlciA9PSAyNCAmJiBuZSA8PSBUT19FWFBfTkVHXHJcbiAgICAgICAgICAgICAgICAgID8gdG9FeHBvbmVudGlhbCggc3RyLCBuZSApXHJcbiAgICAgICAgICAgICAgICAgIDogdG9GaXhlZFBvaW50KCBzdHIsIG5lICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuID0gcm91bmQoIG5ldyBCaWdOdW1iZXIobiksIGksIHJtICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKCBuLmMgKTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmICggY2FsbGVyID09IDE5IHx8IGNhbGxlciA9PSAyNCAmJiAoIGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKysgKTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKCBzdHIsIGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlICsgMSA+IGxlbiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAtLWkgPiAwICkgZm9yICggc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlICsgMSA9PSBsZW4gKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpLS07IHN0ciArPSAnMCcgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICAgICAgZnVuY3Rpb24gbWF4T3JNaW4oIGFyZ3MsIG1ldGhvZCApIHtcclxuICAgICAgICAgICAgdmFyIG0sIG4sXHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICggaXNBcnJheSggYXJnc1swXSApICkgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKCBhcmdzWzBdICk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7ICsraSA8IGFyZ3MubGVuZ3RoOyApIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKCBhcmdzW2ldICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgICAgICAgICBpZiAoICFuLnMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtZXRob2QuY2FsbCggbSwgbiApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIG4gaXMgYW4gaW50ZWdlciBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAgICAgICAqIFVzZSBmb3IgYXJndW1lbnQgdmFsaWRhdGlvbiB3aGVuIEVSUk9SUyBpcyB0cnVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGludFZhbGlkYXRvcldpdGhFcnJvcnMoIG4sIG1pbiwgbWF4LCBjYWxsZXIsIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIGlmICggbiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT0gdHJ1bmNhdGUobikgKSB7XHJcbiAgICAgICAgICAgICAgICByYWlzZSggY2FsbGVyLCAoIG5hbWUgfHwgJ2RlY2ltYWwgcGxhY2VzJyApICtcclxuICAgICAgICAgICAgICAgICAgKCBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZScgOiAnIG5vdCBhbiBpbnRlZ2VyJyApLCBuICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpc2UoIG4sIGMsIGUgKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMSxcclxuICAgICAgICAgICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIDsgIWNbLS1qXTsgYy5wb3AoKSApO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgICAgZm9yICggaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyApO1xyXG5cclxuICAgICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgICAgIGlmICggKCBlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEgKSA+IE1BWF9FWFAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBlIDwgTUlOX0VYUCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgbi5jID0gWyBuLmUgPSAwIF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgICAgICAgICAgbi5jID0gYztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICAgICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICAgICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHgsIHN0ciwgbnVtLCBiICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IG51bSA/IHN0ciA6IHN0ci5yZXBsYWNlKCB3aGl0ZXNwYWNlT3JQbHVzLCAnJyApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICAgICAgICAgIGlmICggaXNJbmZpbml0eU9yTmFOLnRlc3QocykgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW51bSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoIGJhc2VQcmVmaXgsIGZ1bmN0aW9uICggbSwgcDEsIHAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9ICggcDIgPSBwMi50b0xvd2VyQ2FzZSgpICkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoIGRvdEFmdGVyLCAnJDEnICkucmVwbGFjZSggZG90QmVmb3JlLCAnMC4kMScgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdHIgIT0gcyApIHJldHVybiBuZXcgQmlnTnVtYmVyKCBzLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVSUk9SUykgcmFpc2UoIGlkLCAnbm90IGEnICsgKCBiID8gJyBiYXNlICcgKyBiIDogJycgKSArICcgbnVtYmVyJywgc3RyICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuXHJcblxyXG4gICAgICAgIC8vIFRocm93IGEgQmlnTnVtYmVyIEVycm9yLlxyXG4gICAgICAgIGZ1bmN0aW9uIHJhaXNlKCBjYWxsZXIsIG1zZywgdmFsICkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoIFtcclxuICAgICAgICAgICAgICAgICduZXcgQmlnTnVtYmVyJywgICAgIC8vIDBcclxuICAgICAgICAgICAgICAgICdjbXAnLCAgICAgICAgICAgICAgIC8vIDFcclxuICAgICAgICAgICAgICAgICdjb25maWcnLCAgICAgICAgICAgIC8vIDJcclxuICAgICAgICAgICAgICAgICdkaXYnLCAgICAgICAgICAgICAgIC8vIDNcclxuICAgICAgICAgICAgICAgICdkaXZUb0ludCcsICAgICAgICAgIC8vIDRcclxuICAgICAgICAgICAgICAgICdlcScsICAgICAgICAgICAgICAgIC8vIDVcclxuICAgICAgICAgICAgICAgICdndCcsICAgICAgICAgICAgICAgIC8vIDZcclxuICAgICAgICAgICAgICAgICdndGUnLCAgICAgICAgICAgICAgIC8vIDdcclxuICAgICAgICAgICAgICAgICdsdCcsICAgICAgICAgICAgICAgIC8vIDhcclxuICAgICAgICAgICAgICAgICdsdGUnLCAgICAgICAgICAgICAgIC8vIDlcclxuICAgICAgICAgICAgICAgICdtaW51cycsICAgICAgICAgICAgIC8vIDEwXHJcbiAgICAgICAgICAgICAgICAnbW9kJywgICAgICAgICAgICAgICAvLyAxMVxyXG4gICAgICAgICAgICAgICAgJ3BsdXMnLCAgICAgICAgICAgICAgLy8gMTJcclxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nLCAgICAgICAgIC8vIDEzXHJcbiAgICAgICAgICAgICAgICAncmFuZG9tJywgICAgICAgICAgICAvLyAxNFxyXG4gICAgICAgICAgICAgICAgJ3JvdW5kJywgICAgICAgICAgICAgLy8gMTVcclxuICAgICAgICAgICAgICAgICdzaGlmdCcsICAgICAgICAgICAgIC8vIDE2XHJcbiAgICAgICAgICAgICAgICAndGltZXMnLCAgICAgICAgICAgICAvLyAxN1xyXG4gICAgICAgICAgICAgICAgJ3RvRGlnaXRzJywgICAgICAgICAgLy8gMThcclxuICAgICAgICAgICAgICAgICd0b0V4cG9uZW50aWFsJywgICAgIC8vIDE5XHJcbiAgICAgICAgICAgICAgICAndG9GaXhlZCcsICAgICAgICAgICAvLyAyMFxyXG4gICAgICAgICAgICAgICAgJ3RvRm9ybWF0JywgICAgICAgICAgLy8gMjFcclxuICAgICAgICAgICAgICAgICd0b0ZyYWN0aW9uJywgICAgICAgIC8vIDIyXHJcbiAgICAgICAgICAgICAgICAncG93JywgICAgICAgICAgICAgICAvLyAyM1xyXG4gICAgICAgICAgICAgICAgJ3RvUHJlY2lzaW9uJywgICAgICAgLy8gMjRcclxuICAgICAgICAgICAgICAgICd0b1N0cmluZycsICAgICAgICAgIC8vIDI1XHJcbiAgICAgICAgICAgICAgICAnQmlnTnVtYmVyJyAgICAgICAgICAvLyAyNlxyXG4gICAgICAgICAgICBdW2NhbGxlcl0gKyAnKCkgJyArIG1zZyArICc6ICcgKyB2YWwgKTtcclxuXHJcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSAnQmlnTnVtYmVyIEVycm9yJztcclxuICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByb3VuZCggeCwgc2QsIHJtLCByICkge1xyXG4gICAgICAgICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICAgICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAgICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHhjWyBuaSA9IDAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbIGQgLSBqIC0gMSBdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoICggaSArIDEgKSAvIExPR19CQVNFICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5pID49IHhjLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFsgZCAtIGogLSAxIF0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbIGQgLSBqIC0gMSBdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKCBqIDwgMCA/IG4gOiBuICUgcG93czEwWyBkIC0gaiAtIDEgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgICAgICAgICAgICA/ICggcmQgfHwgciApICYmICggcm0gPT0gMCB8fCBybSA9PSAoIHgucyA8IDAgPyAzIDogMiApIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKCBybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCAoIGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwWyBkIC0gaiBdIDogMCA6IHhjW25pIC0gMV0gKSAlIDEwICkgJiAxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm0gPT0gKCB4LnMgPCAwID8gOCA6IDcgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNkIDwgMSB8fCAheGNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsgKCBMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UgKSAlIExPR19CQVNFIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcG93czEwWyBMT0dfQkFTRSAtIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKCBuIC8gcG93czEwWyBkIC0gaiBdICUgcG93czEwW2pdICkgKiBrIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IDsgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmkgPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPSBrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1swXSA9PSBCQVNFICkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGNbbmldICE9IEJBU0UgKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgIGlmICggeC5lID4gTUFYX0VYUCApIHtcclxuICAgICAgICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHguZSA8IE1JTl9FWFAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICggeC5zIDwgMCApIHgucyA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSB3aG9sZVxyXG4gICAgICAgICAqIG51bWJlciBpbiB0aGUgZGlyZWN0aW9uIG9mIEluZmluaXR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuY2VpbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCBuZXcgQmlnTnVtYmVyKHRoaXMpLCB0aGlzLmUgKyAxLCAyICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuXHJcbiAgICAgICAgICogMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgICAgICogLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICAgICAqIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICAgICAqIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWVcclxuICAgICAgICAgKiBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbiwgdixcclxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLmM7XHJcblxyXG4gICAgICAgICAgICBpZiAoICFjICkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIG4gPSAoICggdiA9IGMubGVuZ3RoIC0gMSApIC0gYml0Rmxvb3IoIHRoaXMuZSAvIExPR19CQVNFICkgKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgICAgICAgIGlmICggdiA9IGNbdl0gKSBmb3IgKCA7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0gKTtcclxuICAgICAgICAgICAgaWYgKCBuIDwgMCApIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIG4gLyAwID0gSVxyXG4gICAgICAgICAqICBuIC8gTiA9IE5cclxuICAgICAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgICAgICogIDAgLyBuID0gMFxyXG4gICAgICAgICAqICAwIC8gMCA9IE5cclxuICAgICAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgICAgICogIDAgLyBJID0gMFxyXG4gICAgICAgICAqICBOIC8gbiA9IE5cclxuICAgICAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgICAgICogIE4gLyBOID0gTlxyXG4gICAgICAgICAqICBOIC8gSSA9IE5cclxuICAgICAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgICAgICogIEkgLyAwID0gSVxyXG4gICAgICAgICAqICBJIC8gTiA9IE5cclxuICAgICAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSAzO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2KCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmRpdlRvSW50ID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDQ7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSwgMCwgMSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZXF1YWxzID0gUC5lcSA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA1O1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgPT09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhIHdob2xlXHJcbiAgICAgICAgICogbnVtYmVyIGluIHRoZSBkaXJlY3Rpb24gb2YgLUluZmluaXR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggbmV3IEJpZ051bWJlcih0aGlzKSwgdGhpcy5lICsgMSwgMyApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmdyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA2O1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgPiAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gNztcclxuICAgICAgICAgICAgcmV0dXJuICggYiA9IGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApICkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuaXNJbnRlZ2VyID0gUC5pc0ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKCB0aGlzLmUgLyBMT0dfQkFTRSApID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5sZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gODtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApIDwgMDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5sZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDk7XHJcbiAgICAgICAgICAgIHJldHVybiAoIGIgPSBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSApID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqICBuIC0gMCA9IG5cclxuICAgICAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgICAgICogIG4gLSBJID0gLUlcclxuICAgICAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICAgICAqICAwIC0gMCA9IDBcclxuICAgICAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgICAgICogIDAgLSBJID0gLUlcclxuICAgICAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgICAgICogIE4gLSAwID0gTlxyXG4gICAgICAgICAqICBOIC0gTiA9IE5cclxuICAgICAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgICAgICogIEkgLSBuID0gSVxyXG4gICAgICAgICAqICBJIC0gMCA9IElcclxuICAgICAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgICAgICogIEkgLSBJID0gTlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAubWludXMgPSBQLnN1YiA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICAgICAgICBpZCA9IDEwO1xyXG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlciggeSwgYiApO1xyXG4gICAgICAgICAgICBiID0geS5zO1xyXG5cclxuICAgICAgICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgICAgICAgaWYgKCAhYSB8fCAhYiApIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICAgICAgIGlmICggYSAhPSBiICkge1xyXG4gICAgICAgICAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICAgICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAheGUgfHwgIXllICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiB4YyA/ICggeS5zID0gLWIsIHkgKSA6IG5ldyBCaWdOdW1iZXIoIHljID8geCA6IE5hTiApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgICAgICAgICAgaWYgKCAheGNbMF0gfHwgIXljWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWNbMF0gPyAoIHkucyA9IC1iLCB5ICkgOiBuZXcgQmlnTnVtYmVyKCB4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgICAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgICAgICAgaWYgKCBhID0geGUgLSB5ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHhMVHkgPSBhIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGIgPSBhOyBiLS07IHQucHVzaCgwKSApO1xyXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICAgICAgICAgIGogPSAoIHhMVHkgPSAoIGEgPSB4Yy5sZW5ndGggKSA8ICggYiA9IHljLmxlbmd0aCApICkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBhID0gYiA9IDA7IGIgPCBqOyBiKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggeGNbYl0gIT0geWNbYl0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgICAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICAgICAgICAgIGIgPSAoIGogPSB5Yy5sZW5ndGggKSAtICggaSA9IHhjLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgICAgICAgIGlmICggYiA+IDAgKSBmb3IgKCA7IGItLTsgeGNbaSsrXSA9IDAgKTtcclxuICAgICAgICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgICAgICAgZm9yICggOyBqID4gYTsgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB4Y1stLWpdIDwgeWNbal0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYiApO1xyXG4gICAgICAgICAgICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgZm9yICggOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgICAgIGlmICggIXhjWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgICAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgeS5jID0gWyB5LmUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgICAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGlzZSggeSwgeGMsIHllICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZCA9IDExO1xyXG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlciggeSwgYiApO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgICAgICAgaWYgKCAheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICF5LmMgfHwgeC5jICYmICF4LmNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBNT0RVTE9fTU9ERSA9PSA5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgICAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgICAgICAgICBzID0geS5zO1xyXG4gICAgICAgICAgICAgICAgeS5zID0gMTtcclxuICAgICAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIDMgKTtcclxuICAgICAgICAgICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgICAgICAgICBxLnMgKj0gcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIE1PRFVMT19NT0RFICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4Lm1pbnVzKCBxLnRpbWVzKHkpICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgICAgICogIG4gKyBOID0gTlxyXG4gICAgICAgICAqICBuICsgSSA9IElcclxuICAgICAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgICAgICogIDAgKyAwID0gMFxyXG4gICAgICAgICAqICAwICsgTiA9IE5cclxuICAgICAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgICAgICogIE4gKyBuID0gTlxyXG4gICAgICAgICAqICBOICsgMCA9IE5cclxuICAgICAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgICAgICogIE4gKyBJID0gTlxyXG4gICAgICAgICAqICBJICsgbiA9IElcclxuICAgICAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgICAgICogIEkgKyBOID0gTlxyXG4gICAgICAgICAqICBJICsgSSA9IElcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgdCxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgICAgICAgIGlkID0gMTI7XHJcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XHJcbiAgICAgICAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgICAgICBpZiAoICFhIHx8ICFiICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICAgICAgIGlmICggYSAhPSBiICkge1xyXG4gICAgICAgICAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgICAgIGlmICggIXhlIHx8ICF5ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiBuZXcgQmlnTnVtYmVyKCBhIC8gMCApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICAgICAgICBpZiAoICF4Y1swXSB8fCAheWNbMF0gKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlciggeGNbMF0gPyB4IDogYSAqIDAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgICAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICAgICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgICAgICAgIGlmICggYSA9IHhlIC0geWUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGEgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICggOyBhLS07IHQucHVzaCgwKSApO1xyXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgICAgICAgIGlmICggYSAtIGIgPCAwICkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgICAgICAgIGZvciAoIGEgPSAwOyBiOyApIHtcclxuICAgICAgICAgICAgICAgIGEgPSAoIHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSApIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGEpIHtcclxuICAgICAgICAgICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgICArK3llO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgICAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGlzZSggeSwgeGMsIHllICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFt6XSB7Ym9vbGVhbnxudW1iZXJ9IFdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlLCBmYWxzZSwgMSBvciAwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uICh6KSB7XHJcbiAgICAgICAgICAgIHZhciBuLCB2LFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBjID0geC5jO1xyXG5cclxuICAgICAgICAgICAgLy8gJ3ByZWNpc2lvbigpIGFyZ3VtZW50IG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7en0nXHJcbiAgICAgICAgICAgIGlmICggeiAhPSBudWxsICYmIHogIT09ICEheiAmJiB6ICE9PSAxICYmIHogIT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoRVJST1JTKSByYWlzZSggMTMsICdhcmd1bWVudCcgKyBub3RCb29sLCB6ICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHogIT0gISF6ICkgeiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggIWMgKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHYgPSBjW3ZdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIGZvciAoIDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIGZvciAoIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKysgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB6ICYmIHguZSArIDEgPiBuICkgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZlxyXG4gICAgICAgICAqIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIHRvIDAgYW5kIFJPVU5ESU5HX01PREUgcmVzcGVjdGl2ZWx5IGlmXHJcbiAgICAgICAgICogb21pdHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAncm91bmQoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXHJcbiAgICAgICAgICogJ3JvdW5kKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3JvdW5kKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAgICAgKiAncm91bmQoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnJvdW5kID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZHAgPT0gbnVsbCB8fCBpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAxNSApICkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQoIG4sIH5+ZHAgKyB0aGlzLmUgKyAxLCBybSA9PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICFpc1ZhbGlkSW50KCBybSwgMCwgOCwgMTUsIHJvdW5kaW5nTW9kZSApID8gUk9VTkRJTkdfTU9ERSA6IHJtIHwgMCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIElmIGsgaXMgb3V0IG9mIHJhbmdlIGFuZCBFUlJPUlMgaXMgZmFsc2UsIHRoZSByZXN1bHQgd2lsbCBiZSDCsTAgaWYgayA8IDAsIG9yIMKxSW5maW5pdHlcclxuICAgICAgICAgKiBvdGhlcndpc2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAnc2hpZnQoKSBhcmd1bWVudCBub3QgYW4gaW50ZWdlcjoge2t9J1xyXG4gICAgICAgICAqICdzaGlmdCgpIGFyZ3VtZW50IG91dCBvZiByYW5nZToge2t9J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuc2hpZnQgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkSW50KCBrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUiwgMTYsICdhcmd1bWVudCcgKVxyXG5cclxuICAgICAgICAgICAgICAvLyBrIDwgMWUrMjEsIG9yIHRydW5jYXRlKGspIHdpbGwgcHJvZHVjZSBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgICAgICA/IG4udGltZXMoICcxZScgKyB0cnVuY2F0ZShrKSApXHJcbiAgICAgICAgICAgICAgOiBuZXcgQmlnTnVtYmVyKCBuLmMgJiYgbi5jWzBdICYmICggayA8IC1NQVhfU0FGRV9JTlRFR0VSIHx8IGsgPiBNQVhfU0FGRV9JTlRFR0VSIClcclxuICAgICAgICAgICAgICAgID8gbi5zICogKCBrIDwgMCA/IDAgOiAxIC8gMCApXHJcbiAgICAgICAgICAgICAgICA6IG4gKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICAgICAqICBzcXJ0KCBOKSA9ICBOXHJcbiAgICAgICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAgICAgKiAgc3FydCggSSkgPSAgSVxyXG4gICAgICAgICAqICBzcXJ0KCAwKSA9ICAwXHJcbiAgICAgICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICBzID0geC5zLFxyXG4gICAgICAgICAgICAgICAgZSA9IHguZSxcclxuICAgICAgICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgICAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgICAgICAgIGlmICggcyAhPT0gMSB8fCAhYyB8fCAhY1swXSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCAhcyB8fCBzIDwgMCAmJiAoICFjIHx8IGNbMF0gKSA/IE5hTiA6IGMgPyB4IDogMSAvIDAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgICAgICAgcyA9IE1hdGguc3FydCggK3ggKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgICAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgICAgICAgIGlmICggcyA9PSAwIHx8IHMgPT0gMSAvIDAgKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICAgICAgICAgIGlmICggKCBuLmxlbmd0aCArIGUgKSAlIDIgPT0gMCApIG4gKz0gJzAnO1xyXG4gICAgICAgICAgICAgICAgcyA9IE1hdGguc3FydChuKTtcclxuICAgICAgICAgICAgICAgIGUgPSBiaXRGbG9vciggKCBlICsgMSApIC8gMiApIC0gKCBlIDwgMCB8fCBlICUgMiApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcyA9PSAxIC8gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gJzFlJyArIGU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5zbGljZSggMCwgbi5pbmRleE9mKCdlJykgKyAxICkgKyBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIoIHMgKyAnJyApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAgICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICAgICAgICBpZiAoIHIuY1swXSApIHtcclxuICAgICAgICAgICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBzIDwgMyApIHMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgIGZvciAoIDsgOyApIHtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgICAgICAgICAgICByID0gaGFsZi50aW1lcyggdC5wbHVzKCBkaXYoIHgsIHQsIGRwLCAxICkgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvZWZmVG9TdHJpbmcoIHQuYyAgICkuc2xpY2UoIDAsIHMgKSA9PT0gKCBuID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmVG9TdHJpbmcoIHIuYyApICkuc2xpY2UoIDAsIHMgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHIuZSA8IGUgKSAtLXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuLnNsaWNlKCBzIC0gMywgcyArIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCB0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0LnRpbWVzKHQpLmVxKHgpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCByLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggciwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIG4gKiAwID0gMFxyXG4gICAgICAgICAqICBuICogTiA9IE5cclxuICAgICAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgICAgICogIDAgKiBuID0gMFxyXG4gICAgICAgICAqICAwICogMCA9IDBcclxuICAgICAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgICAgICogIDAgKiBJID0gTlxyXG4gICAgICAgICAqICBOICogbiA9IE5cclxuICAgICAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgICAgICogIE4gKiBOID0gTlxyXG4gICAgICAgICAqICBOICogSSA9IE5cclxuICAgICAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgICAgICogIEkgKiAwID0gTlxyXG4gICAgICAgICAqICBJICogTiA9IE5cclxuICAgICAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciB0aW1lcyB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICB5YyA9ICggaWQgPSAxNywgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKSApLmM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgaWYgKCAheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGUgPSBiaXRGbG9vciggeC5lIC8gTE9HX0JBU0UgKSArIGJpdEZsb29yKCB5LmUgLyBMT0dfQkFTRSApO1xyXG4gICAgICAgICAgICB5LnMgKj0geC5zO1xyXG4gICAgICAgICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgICAgICAgaWYgKCB4Y0wgPCB5Y0wgKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApICk7XHJcblxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0geWNMOyAtLWkgPj0gMDsgKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gMDtcclxuICAgICAgICAgICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBrID0geGNMLCBqID0gaSArIGs7IGogPiBpOyApIHtcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoICggbSAlIHNxcnRCYXNlICkgKiBzcXJ0QmFzZSApICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAoIHhsbyAvIGJhc2UgfCAwICkgKyAoIG0gLyBzcXJ0QmFzZSB8IDAgKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgICAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpc2UoIHksIHpjLCBlICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2ZcclxuICAgICAgICAgKiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9EaWdpdHMoKSBwcmVjaXNpb24gb3V0IG9mIHJhbmdlOiB7c2R9J1xyXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHByZWNpc2lvbiBub3QgYW4gaW50ZWdlcjoge3NkfSdcclxuICAgICAgICAgKiAndG9EaWdpdHMoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9EaWdpdHMgPSBmdW5jdGlvbiAoIHNkLCBybSApIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICAgICAgICBzZCA9IHNkID09IG51bGwgfHwgIWlzVmFsaWRJbnQoIHNkLCAxLCBNQVgsIDE4LCAncHJlY2lzaW9uJyApID8gbnVsbCA6IHNkIHwgMDtcclxuICAgICAgICAgICAgcm0gPSBybSA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBybSwgMCwgOCwgMTgsIHJvdW5kaW5nTW9kZSApID8gUk9VTkRJTkdfTU9ERSA6IHJtIHwgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHNkID8gcm91bmQoIG4sIHNkLCBybSApIDogbjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3RvRXhwb25lbnRpYWwoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgICAgICogJ3RvRXhwb25lbnRpYWwoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCggdGhpcyxcclxuICAgICAgICAgICAgICBkcCAhPSBudWxsICYmIGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDE5ICkgPyB+fmRwICsgMSA6IG51bGwsIHJtLCAxOSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3RvRml4ZWQoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAgICAgKiAndG9GaXhlZCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAndG9GaXhlZCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgICAgICogJ3RvRml4ZWQoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCggdGhpcywgZHAgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAyMCApXHJcbiAgICAgICAgICAgICAgPyB+fmRwICsgdGhpcy5lICsgMSA6IG51bGwsIHJtLCAyMCApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICAgICAqIG9mIHRoZSBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLmNvbmZpZykuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgICAgICogICAgICBkZWNpbWFsU2VwYXJhdG9yIDogJy4nLFxyXG4gICAgICAgICAqICAgICAgZ3JvdXBTZXBhcmF0b3IgOiAnLCcsXHJcbiAgICAgICAgICogICAgICBncm91cFNpemUgOiAzLFxyXG4gICAgICAgICAqICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplIDogMCxcclxuICAgICAgICAgKiAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgOiAnXFx4QTAnLCAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICAgKiAgICAgIGZyYWN0aW9uR3JvdXBTaXplIDogMFxyXG4gICAgICAgICAqIH07XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xyXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uICggZHAsIHJtICkge1xyXG4gICAgICAgICAgICB2YXIgc3RyID0gZm9ybWF0KCB0aGlzLCBkcCAhPSBudWxsICYmIGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDIxIClcclxuICAgICAgICAgICAgICA/IH5+ZHAgKyB0aGlzLmUgKyAxIDogbnVsbCwgcm0sIDIxICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgICAgICAgICAgIGcxID0gK0ZPUk1BVC5ncm91cFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgZzIgPSArRk9STUFULnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBncm91cFNlcGFyYXRvciA9IEZPUk1BVC5ncm91cFNlcGFyYXRvcixcclxuICAgICAgICAgICAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgICAgICAgICAgICBpc05lZyA9IHRoaXMucyA8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZzEgPiAwICYmIGxlbiA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKCAwLCBpICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSArPSBnMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoIGksIGcxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGcyID4gMCApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgICAgICAgICAgPyBpbnRQYXJ0ICsgRk9STUFULmRlY2ltYWxTZXBhcmF0b3IgKyAoICggZzIgPSArRk9STUFULmZyYWN0aW9uR3JvdXBTaXplIClcclxuICAgICAgICAgICAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKCBuZXcgUmVnRXhwKCAnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgJyQmJyArIEZPUk1BVC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIClcclxuICAgICAgICAgICAgICAgICAgICA6IGZyYWN0aW9uUGFydCApXHJcbiAgICAgICAgICAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZSBmcmFjdGlvbiB3aXRoXHJcbiAgICAgICAgICogYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmVcclxuICAgICAgICAgKiBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW1cclxuICAgICAgICAgKiBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZSB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0b1xyXG4gICAgICAgICAqIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxIGFuZCA8IEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0ZyYWN0aW9uKCkgbWF4IGRlbm9taW5hdG9yIG5vdCBhbiBpbnRlZ2VyOiB7bWR9J1xyXG4gICAgICAgICAqICd0b0ZyYWN0aW9uKCkgbWF4IGRlbm9taW5hdG9yIG91dCBvZiByYW5nZToge21kfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgICAgICAgdmFyIGFyciwgZDAsIGQyLCBlLCBleHAsIG4sIG4wLCBxLCBzLFxyXG4gICAgICAgICAgICAgICAgayA9IEVSUk9SUyxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpLFxyXG4gICAgICAgICAgICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKSxcclxuICAgICAgICAgICAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1kICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICBFUlJPUlMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuICAgICAgICAgICAgICAgIEVSUk9SUyA9IGs7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBrID0gbi5pc0ludCgpICkgfHwgbi5sdChPTkUpICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoRVJST1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlKCAyMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAnbWF4IGRlbm9taW5hdG9yICcgKyAoIGsgPyAnb3V0IG9mIHJhbmdlJyA6ICdub3QgYW4gaW50ZWdlcicgKSwgbWQgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVSUk9SUyBpcyBmYWxzZTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBtZCBpcyBhIGZpbml0ZSBub24taW50ZWdlciA+PSAxLCByb3VuZCBpdCB0byBhbiBpbnRlZ2VyIGFuZCB1c2UgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgbWQgPSAhayAmJiBuLmMgJiYgcm91bmQoIG4sIG4uZSArIDEsIDEgKS5ndGUoT05FKSA/IG4gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICF4YyApIHJldHVybiB4LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAgICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgICAgICAgZC5jWzBdID0gUE9XU19URU5bICggZXhwID0gZSAlIExPR19CQVNFICkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHAgXTtcclxuICAgICAgICAgICAgbWQgPSAhbWQgfHwgbi5jbXAoZCkgPiAwID8gKCBlID4gMCA/IGQgOiBuMSApIDogbjtcclxuXHJcbiAgICAgICAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgICAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAgICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICAgICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgOyApICB7XHJcbiAgICAgICAgICAgICAgICBxID0gZGl2KCBuLCBkLCAwLCAxICk7XHJcbiAgICAgICAgICAgICAgICBkMiA9IGQwLnBsdXMoIHEudGltZXMoZDEpICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGQyLmNtcChtZCkgPT0gMSApIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICAgICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgICAgICAgICBuMSA9IG4wLnBsdXMoIHEudGltZXMoIGQyID0gbjEgKSApO1xyXG4gICAgICAgICAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICAgICAgICAgIGQgPSBuLm1pbnVzKCBxLnRpbWVzKCBkMiA9IGQgKSApO1xyXG4gICAgICAgICAgICAgICAgbiA9IGQyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkMiA9IGRpdiggbWQubWludXMoZDApLCBkMSwgMCwgMSApO1xyXG4gICAgICAgICAgICBuMCA9IG4wLnBsdXMoIGQyLnRpbWVzKG4xKSApO1xyXG4gICAgICAgICAgICBkMCA9IGQwLnBsdXMoIGQyLnRpbWVzKGQxKSApO1xyXG4gICAgICAgICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgICAgICAgZSAqPSAyO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICAgICAgICBhcnIgPSBkaXYoIG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSApLm1pbnVzKHgpLmFicygpLmNtcChcclxuICAgICAgICAgICAgICAgICAgZGl2KCBuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUgKS5taW51cyh4KS5hYnMoKSApIDwgMVxyXG4gICAgICAgICAgICAgICAgICAgID8gWyBuMS50b1N0cmluZygpLCBkMS50b1N0cmluZygpIF1cclxuICAgICAgICAgICAgICAgICAgICA6IFsgbjAudG9TdHJpbmcoKSwgZDAudG9TdHJpbmcoKSBdO1xyXG5cclxuICAgICAgICAgICAgTUFYX0VYUCA9IGV4cDtcclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICt0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcmFpc2VkIHRvIHRoZSBwb3dlciBuLlxyXG4gICAgICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZ1xyXG4gICAgICAgICAqIFJPVU5ESU5HX01PREUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgcG9zaXRpdmUgaW50ZWdlcnMsXHJcbiAgICAgICAgICogb3RoZXJ3aXNlIGl0IGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC50b1Bvd2VyKG4pLm1vZHVsbyhtKSAod2l0aCBQT1dfUFJFQ0lTSU9OIDApLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICdwb3coKSBleHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICAgICAqICdwb3coKSBleHBvbmVudCBvdXQgb2YgcmFuZ2U6IHtufSdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24gKCBuLCBtICkge1xyXG4gICAgICAgICAgICB2YXIgaywgeSwgeixcclxuICAgICAgICAgICAgICAgIGkgPSBtYXRoZmxvb3IoIG4gPCAwID8gLW4gOiArbiApLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG0gIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIGlkID0gMjM7XHJcbiAgICAgICAgICAgICAgICBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGFzcyDCsUluZmluaXR5IHRvIE1hdGgucG93IGlmIGV4cG9uZW50IGlzIG91dCBvZiByYW5nZS5cclxuICAgICAgICAgICAgaWYgKCAhaXNWYWxpZEludCggbiwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIsIDIzLCAnZXhwb25lbnQnICkgJiZcclxuICAgICAgICAgICAgICAoICFpc0Zpbml0ZShuKSB8fCBpID4gTUFYX1NBRkVfSU5URUdFUiAmJiAoIG4gLz0gMCApIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KG4pICE9IG4gJiYgISggbiA9IE5hTiApICkgfHwgbiA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgayA9IE1hdGgucG93KCAreCwgbiApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIG0gPyBrICUgbSA6IGsgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgIGlmICggbiA+IDEgJiYgeC5ndChPTkUpICYmIHguaXNJbnQoKSAmJiBtLmd0KE9ORSkgJiYgbS5pc0ludCgpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4Lm1vZChtKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeiA9IG07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE51bGxpZnkgbSBzbyBvbmx5IGEgc2luZ2xlIG1vZCBvcGVyYXRpb24gaXMgcGVyZm9ybWVkIGF0IHRoZSBlbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAgICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgICAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgICAgICAgICAvLyAoVXNpbmcgKyAxLjUgd291bGQgZ2l2ZSBbOSwgMjFdIGd1YXJkIGRpZ2l0cy4pXHJcbiAgICAgICAgICAgICAgICBrID0gbWF0aGNlaWwoIFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgOyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggaSAlIDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAheS5jICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB5LmMubGVuZ3RoID4gayApIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0geS5tb2QobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGkgPSBtYXRoZmxvb3IoIGkgLyAyICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFpICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuICAgICAgICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB4LmMgJiYgeC5jLmxlbmd0aCA+IGsgKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4Lm1vZChtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG0pIHJldHVybiB5O1xyXG4gICAgICAgICAgICBpZiAoIG4gPCAwICkgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geiA/IHkubW9kKHopIDogayA/IHJvdW5kKCB5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFICkgOiB5O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSBwcmVjaXNpb24gbm90IGFuIGludGVnZXI6IHtzZH0nXHJcbiAgICAgICAgICogJ3RvUHJlY2lzaW9uKCkgcHJlY2lzaW9uIG91dCBvZiByYW5nZToge3NkfSdcclxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b1ByZWNpc2lvbigpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoIHNkLCBybSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCggdGhpcywgc2QgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBzZCwgMSwgTUFYLCAyNCwgJ3ByZWNpc2lvbicgKVxyXG4gICAgICAgICAgICAgID8gc2QgfCAwIDogbnVsbCwgcm0sIDI0ICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIDY0IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b1N0cmluZygpIGJhc2Ugbm90IGFuIGludGVnZXI6IHtifSdcclxuICAgICAgICAgKiAndG9TdHJpbmcoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICB2YXIgc3RyLFxyXG4gICAgICAgICAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgICAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgICAgICAgaWYgKCBlID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMgPCAwICkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYiA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBiLCAyLCA2NCwgMjUsICdiYXNlJyApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICAgICAgICAgICAgID8gdG9FeHBvbmVudGlhbCggc3RyLCBlIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gY29udmVydEJhc2UoIHRvRml4ZWRQb2ludCggc3RyLCBlICksIGIgfCAwLCAxMCwgcyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcyA8IDAgJiYgbi5jWzBdICkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHRydW5jYXRlZCB0byBhIHdob2xlXHJcbiAgICAgICAgICogbnVtYmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCBuZXcgQmlnTnVtYmVyKHRoaXMpLCB0aGlzLmUgKyAxLCAxICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGUgPT09IG51bGwgKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyggbi5jICk7XHJcblxyXG4gICAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoIHN0ciwgZSApXHJcbiAgICAgICAgICAgICAgICA6IHRvRml4ZWRQb2ludCggc3RyLCBlICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgUC5pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmICggY29uZmlnICE9IG51bGwgKSBCaWdOdW1iZXIuY29uZmlnKGNvbmZpZyk7XHJcblxyXG4gICAgICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICAgICAgdmFyIGkgPSBuIHwgMDtcclxuICAgICAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgICAgICB2YXIgcywgeixcclxuICAgICAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICAgICAgZm9yICggOyBpIDwgajsgKSB7XHJcbiAgICAgICAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoIDsgei0tOyBzID0gJzAnICsgcyApO1xyXG4gICAgICAgICAgICByICs9IHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICggaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7ICk7XHJcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoIDAsIGogKyAxIHx8IDEgKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gICAgZnVuY3Rpb24gY29tcGFyZSggeCwgeSApIHtcclxuICAgICAgICB2YXIgYSwgYixcclxuICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgIHljID0geS5jLFxyXG4gICAgICAgICAgICBpID0geC5zLFxyXG4gICAgICAgICAgICBqID0geS5zLFxyXG4gICAgICAgICAgICBrID0geC5lLFxyXG4gICAgICAgICAgICBsID0geS5lO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgIGlmICggIWkgfHwgIWogKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgICAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIGEgfHwgYiApIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICBpZiAoIGkgIT0gaiApIHJldHVybiBpO1xyXG5cclxuICAgICAgICBhID0gaSA8IDA7XHJcbiAgICAgICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgICAgIGlmICggIWIgKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgICAgICBqID0gKCBrID0geGMubGVuZ3RoICkgPCAoIGwgPSB5Yy5sZW5ndGggKSA/IGsgOiBsO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgajsgaSsrICkgaWYgKCB4Y1tpXSAhPSB5Y1tpXSApIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgbiBpcyBhIHZhbGlkIG51bWJlciBpbiByYW5nZSwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgICogVXNlIGZvciBhcmd1bWVudCB2YWxpZGF0aW9uIHdoZW4gRVJST1JTIGlzIGZhbHNlLlxyXG4gICAgICogTm90ZTogcGFyc2VJbnQoJzFlKzEnKSA9PSAxIGJ1dCBwYXJzZUZsb2F0KCcxZSsxJykgPT0gMTAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGludFZhbGlkYXRvck5vRXJyb3JzKCBuLCBtaW4sIG1heCApIHtcclxuICAgICAgICByZXR1cm4gKCBuID0gdHJ1bmNhdGUobikgKSA+PSBtaW4gJiYgbiA8PSBtYXg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICogRWcuIGNvbnZlcnRCYXNlKCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgKiBFZy4gY29udmVydEJhc2UoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9CYXNlT3V0KCBzdHIsIGJhc2VJbiwgYmFzZU91dCApIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICggOyBpIDwgbGVuOyApIHtcclxuICAgICAgICAgICAgZm9yICggYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbiApO1xyXG4gICAgICAgICAgICBhcnJbIGogPSAwIF0gKz0gQUxQSEFCRVQuaW5kZXhPZiggc3RyLmNoYXJBdCggaSsrICkgKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgaiA8IGFyci5sZW5ndGg7IGorKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFycltqXSA+IGJhc2VPdXQgLSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXJyW2ogKyAxXSA9PSBudWxsICkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoIHN0ciwgZSApIHtcclxuICAgICAgICByZXR1cm4gKCBzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIgKSArXHJcbiAgICAgICAgICAoIGUgPCAwID8gJ2UnIDogJ2UrJyApICsgZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KCBzdHIsIGUgKSB7XHJcbiAgICAgICAgdmFyIGxlbiwgejtcclxuXHJcbiAgICAgICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICAgICAgaWYgKCBlIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIHogPSAnMC4nOyArK2U7IHogKz0gJzAnICk7XHJcbiAgICAgICAgICAgIHN0ciA9IHogKyBzdHI7XHJcblxyXG4gICAgICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgaWYgKCArK2UgPiBsZW4gKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCB6ID0gJzAnLCBlIC09IGxlbjsgLS1lOyB6ICs9ICcwJyApO1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IHo7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBsZW4gKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoIDAsIGUgKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xyXG4gICAgICAgIG4gPSBwYXJzZUZsb2F0KG4pO1xyXG4gICAgICAgIHJldHVybiBuIDwgMCA/IG1hdGhjZWlsKG4pIDogbWF0aGZsb29yKG4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBFWFBPUlRcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyID0gY29uc3RydWN0b3JGYWN0b3J5KCk7XHJcbiAgICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG5cclxuICAgIC8vIEFNRC5cclxuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcbiAgICAgICAgZGVmaW5lKCBmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0gKTtcclxuXHJcbiAgICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgICAvLyBCcm93c2VyLlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoICFnbG9iYWxPYmogKSBnbG9iYWxPYmogPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG4gICAgICAgIGdsb2JhbE9iai5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgICB9XHJcbn0pKHRoaXMpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKHRoaXMgJiYgdGhpc1thcmddIHx8IGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseSh0aGlzLCBhcmcpKTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaCh0aGlzICYmIHRoaXNba2V5XSB8fCBrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9iaW5kLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIExvb2t1cCB0YWJsZXNcblx0ICAgIHZhciBTQk9YID0gW107XG5cdCAgICB2YXIgSU5WX1NCT1ggPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzMgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8zID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgbG9va3VwIHRhYmxlc1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuXHQgICAgICAgIHZhciBkID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IGkgPDwgMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2FsayBHRigyXjgpXG5cdCAgICAgICAgdmFyIHggPSAwO1xuXHQgICAgICAgIHZhciB4aSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHNib3hcblx0ICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG5cdCAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2Mztcblx0ICAgICAgICAgICAgU0JPWFt4XSA9IHN4O1xuXHQgICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cblx0ICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcblx0ICAgICAgICAgICAgdmFyIHg0ID0gZFt4Ml07XG5cdCAgICAgICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMlt4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuXHQgICAgICAgICAgICBpZiAoIXgpIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4aSA9IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuXHQgICAgICAgICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxuXHQgICAgdmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTa2lwIHJlc2V0IG9mIG5Sb3VuZHMgaGFzIGJlZW4gc2V0IGJlZm9yZSBhbmQga2V5IGRpZCBub3QgY2hhbmdlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9uUm91bmRzICYmIHRoaXMuX2tleVByaW9yUmVzZXQgPT09IHRoaXMuX2tleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDY7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcblxuXHQgICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcblxuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xuXHQgICAgICAgICAgICB2YXIgczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG5cdCAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcblx0ICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxuXHQgICAgICAgICAgICB2YXIga3NSb3cgPSA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcblx0ICAgICAgICAgICAgICAgIHMwID0gdDA7XG5cdCAgICAgICAgICAgICAgICBzMSA9IHQxO1xuXHQgICAgICAgICAgICAgICAgczIgPSB0Mjtcblx0ICAgICAgICAgICAgICAgIHMzID0gdDM7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5BRVM7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdENyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuXHQgICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KCkpXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RlIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGl2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFhPUiBibG9ja3Ncblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gQ0JDO1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgbW9kZTogQ0JDLFxuXHQgICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG5cdCAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcblx0ICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XG5cblx0ICAgICAgICAgICAgLy8gRmluYWxpemVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgLy8gUGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXG5cdCAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcblx0ICAgICAgICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcblx0ICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcblx0ICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XG5cblx0ICAgICAgICAgICAgLy8gRm9ybWF0XG5cdCAgICAgICAgICAgIGlmIChzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xuXHQgICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxuXHQgICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuXHQgICAgICAgICAgICAgICAgdmFyIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQuc2lnQnl0ZXMgLT0gMTY7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcblx0ICAgICAgICAgICAgICAgIGtleToga2V5LFxuXHQgICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcblx0ICAgICAgICAgICAgICAgIGFsZ29yaXRobTogY2lwaGVyLFxuXHQgICAgICAgICAgICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcblx0ICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogY2lwaGVyLmJsb2NrU2l6ZSxcblx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY2ZnLmZvcm1hdFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxuXHQgICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMS2RmID0gQ19rZGYuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxuXHQgICAgICAgICAgICBpZiAoIXNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0LzgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIFNlcGFyYXRlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuXHQgICAgICAgICAgICBrZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcblx0ICAgICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtkZjogT3BlblNTTEtkZlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0Lm1peEluKGRlcml2ZWRQYXJhbXMpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBjaXBoZXJ0ZXh0LCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsIG9mIE9iamVjdC5jcmVhdGVcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge307XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICB2YXIgciA9IChmdW5jdGlvbiAobV93KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV93ID0gbV93O1xuXHQgICAgICAgICAgICAgICAgdmFyIG1feiA9IDB4M2FkZTY4YjE7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFzayA9IDB4ZmZmZmZmZmY7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbV96ID0gKDB4OTA2OSAqIChtX3ogJiAweEZGRkYpICsgKG1feiA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIG1fdyA9ICgweDQ2NTAgKiAobV93ICYgMHhGRkZGKSArIChtX3cgPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgLz0gMHgxMDAwMDAwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IDAuNTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9yID0gcigocmNhY2hlIHx8IE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApO1xuXG5cdCAgICAgICAgICAgICAgICByY2FjaGUgPSBfcigpICogMHgzYWRlNjdiNztcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IChiaXRzMSB8IGJpdHMyKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IEJFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmMTZCRSA9IENfZW5jLlV0ZjE2ID0gQ19lbmMuVXRmMTZCRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGYxNi5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgQkUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTYucGFyc2UodXRmMTZTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gdXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgTEUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIENfZW5jLlV0ZjE2TEUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHIgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gc3dhcEVuZGlhbigod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmYpO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgTEUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5wYXJzZSh1dGYxNlN0cik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSBzd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBzd2FwRW5kaWFuKHdvcmQpIHtcblx0ICAgICAgICByZXR1cm4gKCh3b3JkIDw8IDgpICYgMHhmZjAwZmYwMCkgfCAoKHdvcmQgPj4+IDgpICYgMHgwMGZmMDBmZik7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjE2O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtdXRmMTYuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLXV0ZjE2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTFcIiwgXCIuL2htYWNcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXG5cdCAgICAgKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuXHQgICAgICovXG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IE1ENSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xuXHQgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkV2cEtERjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZXZwa2RmLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXM7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXg7XG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdDtcblxuXHQgICAgdmFyIEhleEZvcm1hdHRlciA9IENfZm9ybWF0LkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGUgY2lwaGVydGV4dCBvZiBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5IZXguc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEhleC5wYXJzZShpbnB1dCk7XG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmZvcm1hdC5IZXg7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Zvcm1hdC1oZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBITUFDIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoYXNoZXIsIGtleSkge1xuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICBoYXNoZXIgPSB0aGlzLl9oYXNoZXIgPSBuZXcgaGFzaGVyLmluaXQoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQWxsb3cgYXJiaXRyYXJ5IGxlbmd0aCBrZXlzXG5cdCAgICAgICAgICAgIGlmIChrZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gaGFzaGVyLmZpbmFsaXplKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICBrZXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB2YXIgaUtleSA9IHRoaXMuX2lLZXkgPSBrZXkuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpS2V5V29yZHMgPSBpS2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFhPUiBrZXlzIHdpdGggcGFkIGNvbnN0YW50c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1Yztcblx0ICAgICAgICAgICAgICAgIGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9LZXkuc2lnQnl0ZXMgPSBpS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXRcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBITUFDIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaG1hYztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2htYWMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpLCByZXF1aXJlKFwiLi9saWItdHlwZWRhcnJheXNcIiksIHJlcXVpcmUoXCIuL2VuYy11dGYxNlwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9zaGEyNTZcIiksIHJlcXVpcmUoXCIuL3NoYTIyNFwiKSwgcmVxdWlyZShcIi4vc2hhNTEyXCIpLCByZXF1aXJlKFwiLi9zaGEzODRcIiksIHJlcXVpcmUoXCIuL3NoYTNcIiksIHJlcXVpcmUoXCIuL3JpcGVtZDE2MFwiKSwgcmVxdWlyZShcIi4vaG1hY1wiKSwgcmVxdWlyZShcIi4vcGJrZGYyXCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpLCByZXF1aXJlKFwiLi9tb2RlLWNmYlwiKSwgcmVxdWlyZShcIi4vbW9kZS1jdHJcIiksIHJlcXVpcmUoXCIuL21vZGUtY3RyLWdsYWRtYW5cIiksIHJlcXVpcmUoXCIuL21vZGUtb2ZiXCIpLCByZXF1aXJlKFwiLi9tb2RlLWVjYlwiKSwgcmVxdWlyZShcIi4vcGFkLWFuc2l4OTIzXCIpLCByZXF1aXJlKFwiLi9wYWQtaXNvMTAxMjZcIiksIHJlcXVpcmUoXCIuL3BhZC1pc285Nzk3MVwiKSwgcmVxdWlyZShcIi4vcGFkLXplcm9wYWRkaW5nXCIpLCByZXF1aXJlKFwiLi9wYWQtbm9wYWRkaW5nXCIpLCByZXF1aXJlKFwiLi9mb3JtYXQtaGV4XCIpLCByZXF1aXJlKFwiLi9hZXNcIiksIHJlcXVpcmUoXCIuL3RyaXBsZWRlc1wiKSwgcmVxdWlyZShcIi4vcmM0XCIpLCByZXF1aXJlKFwiLi9yYWJiaXRcIiksIHJlcXVpcmUoXCIuL3JhYmJpdC1sZWdhY3lcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIiwgXCIuL2xpYi10eXBlZGFycmF5c1wiLCBcIi4vZW5jLXV0ZjE2XCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL3NoYTFcIiwgXCIuL3NoYTI1NlwiLCBcIi4vc2hhMjI0XCIsIFwiLi9zaGE1MTJcIiwgXCIuL3NoYTM4NFwiLCBcIi4vc2hhM1wiLCBcIi4vcmlwZW1kMTYwXCIsIFwiLi9obWFjXCIsIFwiLi9wYmtkZjJcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIiwgXCIuL21vZGUtY2ZiXCIsIFwiLi9tb2RlLWN0clwiLCBcIi4vbW9kZS1jdHItZ2xhZG1hblwiLCBcIi4vbW9kZS1vZmJcIiwgXCIuL21vZGUtZWNiXCIsIFwiLi9wYWQtYW5zaXg5MjNcIiwgXCIuL3BhZC1pc28xMDEyNlwiLCBcIi4vcGFkLWlzbzk3OTcxXCIsIFwiLi9wYWQtemVyb3BhZGRpbmdcIiwgXCIuL3BhZC1ub3BhZGRpbmdcIiwgXCIuL2Zvcm1hdC1oZXhcIiwgXCIuL2Flc1wiLCBcIi4vdHJpcGxlZGVzXCIsIFwiLi9yYzRcIiwgXCIuL3JhYmJpdFwiLCBcIi4vcmFiYml0LWxlZ2FjeVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gQ2hlY2sgaWYgdHlwZWQgYXJyYXlzIGFyZSBzdXBwb3J0ZWRcblx0ICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXG5cdCAgICAvLyBSZWZlcmVuY2Ugb3JpZ2luYWwgaW5pdFxuXHQgICAgdmFyIHN1cGVySW5pdCA9IFdvcmRBcnJheS5pbml0O1xuXG5cdCAgICAvLyBBdWdtZW50IFdvcmRBcnJheS5pbml0IHRvIGhhbmRsZSB0eXBlZCBhcnJheXNcblx0ICAgIHZhciBzdWJJbml0ID0gV29yZEFycmF5LmluaXQgPSBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHQgICAgICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbnZlcnQgb3RoZXIgYXJyYXkgdmlld3MgdG8gdWludDhcblx0ICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcblx0ICAgICAgICAgICAgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEhhbmRsZSBVaW50OEFycmF5XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBFeHRyYWN0IGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IHR5cGVkQXJyYXlbaV0gPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmNhbGwodGhpcywgd29yZHMsIHR5cGVkQXJyYXlCeXRlTGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgc3ViSW5pdC5wcm90b3R5cGUgPSBXb3JkQXJyYXk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbGliLXR5cGVkYXJyYXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDaXBoZXIgRmVlZGJhY2sgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuQ0ZCID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBDRkIgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICBDRkIuRW5jcnlwdG9yID0gQ0ZCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0LmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIENGQi5EZWNyeXB0b3IgPSBDRkIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7XG5cblx0ICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdCh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcikge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIENGQjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkNGQjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jZmIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jZmIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKiogQHByZXNlcnZlXG5cdCAqIENvdW50ZXIgYmxvY2sgbW9kZSBjb21wYXRpYmxlIHdpdGggIERyIEJyaWFuIEdsYWRtYW4gZmlsZWVuYy5jXG5cdCAqIGRlcml2ZWQgZnJvbSBDcnlwdG9KUy5tb2RlLkNUUlxuXHQgKiBKYW4gSHJ1YnkgamhydWJ5LndlYkBnbWFpbC5jb21cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuQ1RSR2xhZG1hbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgQ1RSR2xhZG1hbiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0XHRmdW5jdGlvbiBpbmNXb3JkKHdvcmQpXG5cdFx0e1xuXHRcdFx0aWYgKCgod29yZCA+PiAyNCkgJiAweGZmKSA9PT0gMHhmZikgeyAvL292ZXJmbG93XG5cdFx0XHR2YXIgYjEgPSAod29yZCA+PiAxNikmMHhmZjtcblx0XHRcdHZhciBiMiA9ICh3b3JkID4+IDgpJjB4ZmY7XG5cdFx0XHR2YXIgYjMgPSB3b3JkICYgMHhmZjtcblxuXHRcdFx0aWYgKGIxID09PSAweGZmKSAvLyBvdmVyZmxvdyBiMVxuXHRcdFx0e1xuXHRcdFx0YjEgPSAwO1xuXHRcdFx0aWYgKGIyID09PSAweGZmKVxuXHRcdFx0e1xuXHRcdFx0XHRiMiA9IDA7XG5cdFx0XHRcdGlmIChiMyA9PT0gMHhmZilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGIzID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQrK2IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdCsrYjI7XG5cdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHQrK2IxO1xuXHRcdFx0fVxuXG5cdFx0XHR3b3JkID0gMDtcblx0XHRcdHdvcmQgKz0gKGIxIDw8IDE2KTtcblx0XHRcdHdvcmQgKz0gKGIyIDw8IDgpO1xuXHRcdFx0d29yZCArPSBiMztcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdHdvcmQgKz0gKDB4MDEgPDwgMjQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHdvcmQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5jQ291bnRlcihjb3VudGVyKVxuXHRcdHtcblx0XHRcdGlmICgoY291bnRlclswXSA9IGluY1dvcmQoY291bnRlclswXSkpID09PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBlbmNyX2RhdGEgaW4gZmlsZWVuYy5jIGZyb20gIERyIEJyaWFuIEdsYWRtYW4ncyBjb3VudHMgb25seSB3aXRoIERXT1JEIGogPCA4XG5cdFx0XHRcdGNvdW50ZXJbMV0gPSBpbmNXb3JkKGNvdW50ZXJbMV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvdW50ZXI7XG5cdFx0fVxuXG5cdCAgICB2YXIgRW5jcnlwdG9yID0gQ1RSR2xhZG1hbi5FbmNyeXB0b3IgPSBDVFJHbGFkbWFuLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlclxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cdCAgICAgICAgICAgIHZhciBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlciA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXG5cdFx0XHRcdGluY0NvdW50ZXIoY291bnRlcik7XG5cblx0XHRcdFx0dmFyIGtleXN0cmVhbSA9IGNvdW50ZXIuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBDVFJHbGFkbWFuLkRlY3J5cHRvciA9IEVuY3J5cHRvcjtcblxuXHQgICAgcmV0dXJuIENUUkdsYWRtYW47XG5cdH0oKSk7XG5cblxuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuQ1RSR2xhZG1hbjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci1nbGFkbWFuLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENvdW50ZXIgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuQ1RSID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBDVFIgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICB2YXIgRW5jcnlwdG9yID0gQ1RSLkVuY3J5cHRvciA9IENUUi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXHQgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXIgPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IGNvdW50ZXIuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgICAgICAvLyBJbmNyZW1lbnQgY291bnRlclxuXHQgICAgICAgICAgICBjb3VudGVyW2Jsb2NrU2l6ZSAtIDFdID0gKGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gKyAxKSB8IDBcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBDVFIuRGVjcnlwdG9yID0gRW5jcnlwdG9yO1xuXG5cdCAgICByZXR1cm4gQ1RSO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuQ1RSO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBFbGVjdHJvbmljIENvZGVib29rIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkVDQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgRUNCID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgRUNCLkVuY3J5cHRvciA9IEVDQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgRUNCLkRlY3J5cHRvciA9IEVDQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIEVDQjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkVDQjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1lY2IuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1lY2IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogT3V0cHV0IEZlZWRiYWNrIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLk9GQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgT0ZCID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgdmFyIEVuY3J5cHRvciA9IE9GQi5FbmNyeXB0b3IgPSBPRkIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyXG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IHRoaXMuX2tleXN0cmVhbTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBrZXlzdHJlYW0gPSB0aGlzLl9rZXlzdHJlYW0gPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIE9GQi5EZWNyeXB0b3IgPSBFbmNyeXB0b3I7XG5cblx0ICAgIHJldHVybiBPRkI7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5PRkI7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtb2ZiLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtb2ZiLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIEFOU0kgWC45MjMgcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5BbnNpWDkyMyA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGFTaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgLy8gQ29tcHV0ZSBsYXN0IGJ5dGUgcG9zaXRpb25cblx0ICAgICAgICB2YXIgbGFzdEJ5dGVQb3MgPSBkYXRhU2lnQnl0ZXMgKyBuUGFkZGluZ0J5dGVzIC0gMTtcblxuXHQgICAgICAgIC8vIFBhZFxuXHQgICAgICAgIGRhdGEuY2xhbXAoKTtcblx0ICAgICAgICBkYXRhLndvcmRzW2xhc3RCeXRlUG9zID4+PiAyXSB8PSBuUGFkZGluZ0J5dGVzIDw8ICgyNCAtIChsYXN0Qnl0ZVBvcyAlIDQpICogOCk7XG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyArPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5BbnNpeDkyMztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWFuc2l4OTIzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1hbnNpeDkyMy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBJU08gMTAxMjYgcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5Jc28xMDEyNiA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgLy8gUGFkXG5cdCAgICAgICAgZGF0YS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oblBhZGRpbmdCeXRlcyAtIDEpKS5cblx0ICAgICAgICAgICAgIGNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbblBhZGRpbmdCeXRlcyA8PCAyNF0sIDEpKTtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuSXNvMTAxMjY7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc28xMDEyNi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvMTAxMjYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogSVNPL0lFQyA5Nzk3LTEgUGFkZGluZyBNZXRob2QgMi5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5Jc285Nzk3MSA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIEFkZCAweDgwIGJ5dGVcblx0ICAgICAgICBkYXRhLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHg4MDAwMDAwMF0sIDEpKTtcblxuXHQgICAgICAgIC8vIFplcm8gcGFkIHRoZSByZXN0XG5cdCAgICAgICAgQ3J5cHRvSlMucGFkLlplcm9QYWRkaW5nLnBhZChkYXRhLCBibG9ja1NpemUpO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gUmVtb3ZlIHplcm8gcGFkZGluZ1xuXHQgICAgICAgIENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZy51bnBhZChkYXRhKTtcblxuXHQgICAgICAgIC8vIFJlbW92ZSBvbmUgbW9yZSBieXRlIC0tIHRoZSAweDgwIGJ5dGVcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzLS07XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzk3OTcxO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvOTc5NzEuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzk3OTcxLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIEEgbm9vcCBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLk5vUGFkZGluZyA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKCkge1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtbm9wYWRkaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1ub3BhZGRpbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogWmVybyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLlplcm9QYWRkaW5nID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgLy8gUGFkXG5cdCAgICAgICAgZGF0YS5jbGFtcCgpO1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgKz0gYmxvY2tTaXplQnl0ZXMgLSAoKGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcykgfHwgYmxvY2tTaXplQnl0ZXMpO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgIC8vIFVucGFkXG5cdCAgICAgICAgdmFyIGkgPSBkYXRhLnNpZ0J5dGVzIC0gMTtcblx0ICAgICAgICB3aGlsZSAoISgoZGF0YVdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZikpIHtcblx0ICAgICAgICAgICAgaS0tO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzID0gaSArIDE7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLlplcm9QYWRkaW5nO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtemVyb3BhZGRpbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLXplcm9wYWRkaW5nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTFcIiwgXCIuL2htYWNcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMTtcblx0ICAgIHZhciBITUFDID0gQ19hbGdvLkhNQUM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMiBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBQQktERjIgPSBDX2FsZ28uUEJLREYyID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZS4gRGVmYXVsdDogU0hBMVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcblx0ICAgICAgICAgICAgaGFzaGVyOiBTSEExLFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbXB1dGVzIHRoZSBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBITUFDXG5cdCAgICAgICAgICAgIHZhciBobWFjID0gSE1BQy5jcmVhdGUoY2ZnLmhhc2hlciwgcGFzc3dvcmQpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tJbmRleCA9IFdvcmRBcnJheS5jcmVhdGUoWzB4MDAwMDAwMDFdKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja0luZGV4V29yZHMgPSBibG9ja0luZGV4LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxuXHQgICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhtYWMudXBkYXRlKHNhbHQpLmZpbmFsaXplKGJsb2NrSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgaG1hYy5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1dvcmRzID0gYmxvY2sud29yZHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tXb3Jkc0xlbmd0aCA9IGJsb2NrV29yZHMubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICB2YXIgaW50ZXJtZWRpYXRlID0gYmxvY2s7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IGhtYWMuZmluYWxpemUoaW50ZXJtZWRpYXRlKTtcblx0ICAgICAgICAgICAgICAgICAgICBobWFjLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGVXb3JkcyA9IGludGVybWVkaWF0ZS53b3JkcztcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFhPUiBpbnRlcm1lZGlhdGUgd2l0aCBibG9ja1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tXb3Jkc0xlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrV29yZHNbal0gXj0gaW50ZXJtZWRpYXRlV29yZHNbal07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgICAgICBibG9ja0luZGV4V29yZHNbMF0rKztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLlBCS0RGMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIFBCS0RGMi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUEJLREYyO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGJrZGYyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0c1xuXHQgICAgdmFyIFMgID0gW107XG5cdCAgICB2YXIgQ18gPSBbXTtcblx0ICAgIHZhciBHICA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJhYmJpdCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGlzIGlzIGEgbGVnYWN5IHZlcnNpb24gdGhhdCBuZWdsZWN0ZWQgdG8gY29udmVydCB0aGUga2V5IHRvIGxpdHRsZS1lbmRpYW4uXG5cdCAgICAgKiBUaGlzIGVycm9yIGRvZXNuJ3QgYWZmZWN0IHRoZSBjaXBoZXIncyBzZWN1cml0eSxcblx0ICAgICAqIGJ1dCBpdCBkb2VzIGFmZmVjdCBpdHMgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucy5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJhYmJpdExlZ2FjeSA9IENfYWxnby5SYWJiaXRMZWdhY3kgPSBTdHJlYW1DaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEsgPSB0aGlzLl9rZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuY2ZnLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWCA9IFtcblx0ICAgICAgICAgICAgICAgIEtbMF0sIChLWzNdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzFdLCAoS1swXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1syXSwgKEtbMV0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbM10sIChLWzJdIDw8IDE2KSB8IChLWzFdID4+PiAxNilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBDID0gdGhpcy5fQyA9IFtcblx0ICAgICAgICAgICAgICAgIChLWzJdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksIChLWzBdICYgMHhmZmZmMDAwMCkgfCAoS1sxXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbM10gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSwgKEtbMV0gJiAweGZmZmYwMDAwKSB8IChLWzJdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1swXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLCAoS1syXSAmIDB4ZmZmZjAwMDApIHwgKEtbM10gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzFdIDw8IDE2KSB8IChLWzFdID4+PiAxNiksIChLWzNdICYgMHhmZmZmMDAwMCkgfCAoS1swXSAmIDB4MDAwMGZmZmYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gQ2FycnkgYml0XG5cdCAgICAgICAgICAgIHRoaXMuX2IgPSAwO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY291bnRlcnNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIENbaV0gXj0gWFsoaSArIDQpICYgN107XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJViBzZXR1cFxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIElWID0gaXYud29yZHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMCA9IElWWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzEgPSBJVlsxXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBzdWJ2ZWN0b3JzXG5cdCAgICAgICAgICAgICAgICB2YXIgaTAgPSAoKChJVl8wIDw8IDgpIHwgKElWXzAgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzAgPDwgMjQpIHwgKElWXzAgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkyID0gKCgoSVZfMSA8PCA4KSB8IChJVl8xID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8xIDw8IDI0KSB8IChJVl8xID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMSA9IChpMCA+Pj4gMTYpIHwgKGkyICYgMHhmZmZmMDAwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTMgPSAoaTIgPDwgMTYpICB8IChpMCAmIDB4MDAwMGZmZmYpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBNb2RpZnkgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIENbMF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzFdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1syXSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbM10gXj0gaTM7XG5cdCAgICAgICAgICAgICAgICBDWzRdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1s1XSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbNl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzddIF49IGkzO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbVxuXHQgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIGtleXN0cmVhbSB3b3Jkc1xuXHQgICAgICAgICAgICBTWzBdID0gWFswXSBeIChYWzVdID4+PiAxNikgXiAoWFszXSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMV0gPSBYWzJdIF4gKFhbN10gPj4+IDE2KSBeIChYWzVdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1syXSA9IFhbNF0gXiAoWFsxXSA+Pj4gMTYpIF4gKFhbN10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzNdID0gWFs2XSBeIChYWzNdID4+PiAxNikgXiAoWFsxXSA8PCAxNik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBTW2ldID0gKCgoU1tpXSA8PCA4KSAgfCAoU1tpXSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChTW2ldIDw8IDI0KSB8IChTW2ldID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXHQgICAgICAgIHZhciBDID0gdGhpcy5fQztcblxuXHQgICAgICAgIC8vIFNhdmUgb2xkIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgQ19baV0gPSBDW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBDWzBdID0gKENbMF0gKyAweDRkMzRkMzRkICsgdGhpcy5fYikgfCAwO1xuXHQgICAgICAgIENbMV0gPSAoQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoKENbMF0gPj4+IDApIDwgKENfWzBdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbMl0gPSAoQ1syXSArIDB4MzRkMzRkMzQgKyAoKENbMV0gPj4+IDApIDwgKENfWzFdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbM10gPSAoQ1szXSArIDB4NGQzNGQzNGQgKyAoKENbMl0gPj4+IDApIDwgKENfWzJdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNF0gPSAoQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoKENbM10gPj4+IDApIDwgKENfWzNdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNV0gPSAoQ1s1XSArIDB4MzRkMzRkMzQgKyAoKENbNF0gPj4+IDApIDwgKENfWzRdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNl0gPSAoQ1s2XSArIDB4NGQzNGQzNGQgKyAoKENbNV0gPj4+IDApIDwgKENfWzVdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbN10gPSAoQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoKENbNl0gPj4+IDApIDwgKENfWzZdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIHRoaXMuX2IgPSAoQ1s3XSA+Pj4gMCkgPCAoQ19bN10gPj4+IDApID8gMSA6IDA7XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGctdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGd4ID0gWFtpXSArIENbaV07XG5cblx0ICAgICAgICAgICAgLy8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdhID0gZ3ggJiAweGZmZmY7XG5cdCAgICAgICAgICAgIHZhciBnYiA9IGd4ID4+PiAxNjtcblxuXHQgICAgICAgICAgICAvLyBDYWxjdWxhdGUgaGlnaCBhbmQgbG93IHJlc3VsdCBvZiBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2ggPSAoKCgoZ2EgKiBnYSkgPj4+IDE3KSArIGdhICogZ2IpID4+PiAxNSkgKyBnYiAqIGdiO1xuXHQgICAgICAgICAgICB2YXIgZ2wgPSAoKChneCAmIDB4ZmZmZjAwMDApICogZ3gpIHwgMCkgKyAoKChneCAmIDB4MDAwMGZmZmYpICogZ3gpIHwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gSGlnaCBYT1IgbG93XG5cdCAgICAgICAgICAgIEdbaV0gPSBnaCBeIGdsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgWFswXSA9IChHWzBdICsgKChHWzddIDw8IDE2KSB8IChHWzddID4+PiAxNikpICsgKChHWzZdIDw8IDE2KSB8IChHWzZdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFsxXSA9IChHWzFdICsgKChHWzBdIDw8IDgpICB8IChHWzBdID4+PiAyNCkpICsgR1s3XSkgfCAwO1xuXHQgICAgICAgIFhbMl0gPSAoR1syXSArICgoR1sxXSA8PCAxNikgfCAoR1sxXSA+Pj4gMTYpKSArICgoR1swXSA8PCAxNikgfCAoR1swXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbM10gPSAoR1szXSArICgoR1syXSA8PCA4KSAgfCAoR1syXSA+Pj4gMjQpKSArIEdbMV0pIHwgMDtcblx0ICAgICAgICBYWzRdID0gKEdbNF0gKyAoKEdbM10gPDwgMTYpIHwgKEdbM10gPj4+IDE2KSkgKyAoKEdbMl0gPDwgMTYpIHwgKEdbMl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzVdID0gKEdbNV0gKyAoKEdbNF0gPDwgOCkgIHwgKEdbNF0gPj4+IDI0KSkgKyBHWzNdKSB8IDA7XG5cdCAgICAgICAgWFs2XSA9IChHWzZdICsgKChHWzVdIDw8IDE2KSB8IChHWzVdID4+PiAxNikpICsgKChHWzRdIDw8IDE2KSB8IChHWzRdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs3XSA9IChHWzddICsgKChHWzZdIDw8IDgpICB8IChHWzZdID4+PiAyNCkpICsgR1s1XSkgfCAwO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJhYmJpdExlZ2FjeS5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJhYmJpdExlZ2FjeS5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SYWJiaXRMZWdhY3kgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXRMZWdhY3kpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJhYmJpdExlZ2FjeTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LWxlZ2FjeS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQtbGVnYWN5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0c1xuXHQgICAgdmFyIFMgID0gW107XG5cdCAgICB2YXIgQ18gPSBbXTtcblx0ICAgIHZhciBHICA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJhYmJpdCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobVxuXHQgICAgICovXG5cdCAgICB2YXIgUmFiYml0ID0gQ19hbGdvLlJhYmJpdCA9IFN0cmVhbUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSyA9IHRoaXMuX2tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5jZmcuaXY7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIEtbaV0gPSAoKChLW2ldIDw8IDgpICB8IChLW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEtbaV0gPDwgMjQpIHwgKEtbaV0gPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWCA9IFtcblx0ICAgICAgICAgICAgICAgIEtbMF0sIChLWzNdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzFdLCAoS1swXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1syXSwgKEtbMV0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbM10sIChLWzJdIDw8IDE2KSB8IChLWzFdID4+PiAxNilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBDID0gdGhpcy5fQyA9IFtcblx0ICAgICAgICAgICAgICAgIChLWzJdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksIChLWzBdICYgMHhmZmZmMDAwMCkgfCAoS1sxXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbM10gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSwgKEtbMV0gJiAweGZmZmYwMDAwKSB8IChLWzJdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1swXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLCAoS1syXSAmIDB4ZmZmZjAwMDApIHwgKEtbM10gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzFdIDw8IDE2KSB8IChLWzFdID4+PiAxNiksIChLWzNdICYgMHhmZmZmMDAwMCkgfCAoS1swXSAmIDB4MDAwMGZmZmYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gQ2FycnkgYml0XG5cdCAgICAgICAgICAgIHRoaXMuX2IgPSAwO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY291bnRlcnNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIENbaV0gXj0gWFsoaSArIDQpICYgN107XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJViBzZXR1cFxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIElWID0gaXYud29yZHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMCA9IElWWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzEgPSBJVlsxXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBzdWJ2ZWN0b3JzXG5cdCAgICAgICAgICAgICAgICB2YXIgaTAgPSAoKChJVl8wIDw8IDgpIHwgKElWXzAgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzAgPDwgMjQpIHwgKElWXzAgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkyID0gKCgoSVZfMSA8PCA4KSB8IChJVl8xID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8xIDw8IDI0KSB8IChJVl8xID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMSA9IChpMCA+Pj4gMTYpIHwgKGkyICYgMHhmZmZmMDAwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTMgPSAoaTIgPDwgMTYpICB8IChpMCAmIDB4MDAwMGZmZmYpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBNb2RpZnkgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIENbMF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzFdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1syXSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbM10gXj0gaTM7XG5cdCAgICAgICAgICAgICAgICBDWzRdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1s1XSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbNl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzddIF49IGkzO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbVxuXHQgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIGtleXN0cmVhbSB3b3Jkc1xuXHQgICAgICAgICAgICBTWzBdID0gWFswXSBeIChYWzVdID4+PiAxNikgXiAoWFszXSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMV0gPSBYWzJdIF4gKFhbN10gPj4+IDE2KSBeIChYWzVdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1syXSA9IFhbNF0gXiAoWFsxXSA+Pj4gMTYpIF4gKFhbN10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzNdID0gWFs2XSBeIChYWzNdID4+PiAxNikgXiAoWFsxXSA8PCAxNik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBTW2ldID0gKCgoU1tpXSA8PCA4KSAgfCAoU1tpXSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChTW2ldIDw8IDI0KSB8IChTW2ldID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXHQgICAgICAgIHZhciBDID0gdGhpcy5fQztcblxuXHQgICAgICAgIC8vIFNhdmUgb2xkIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgQ19baV0gPSBDW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBDWzBdID0gKENbMF0gKyAweDRkMzRkMzRkICsgdGhpcy5fYikgfCAwO1xuXHQgICAgICAgIENbMV0gPSAoQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoKENbMF0gPj4+IDApIDwgKENfWzBdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbMl0gPSAoQ1syXSArIDB4MzRkMzRkMzQgKyAoKENbMV0gPj4+IDApIDwgKENfWzFdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbM10gPSAoQ1szXSArIDB4NGQzNGQzNGQgKyAoKENbMl0gPj4+IDApIDwgKENfWzJdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNF0gPSAoQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoKENbM10gPj4+IDApIDwgKENfWzNdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNV0gPSAoQ1s1XSArIDB4MzRkMzRkMzQgKyAoKENbNF0gPj4+IDApIDwgKENfWzRdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNl0gPSAoQ1s2XSArIDB4NGQzNGQzNGQgKyAoKENbNV0gPj4+IDApIDwgKENfWzVdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbN10gPSAoQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoKENbNl0gPj4+IDApIDwgKENfWzZdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIHRoaXMuX2IgPSAoQ1s3XSA+Pj4gMCkgPCAoQ19bN10gPj4+IDApID8gMSA6IDA7XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGctdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGd4ID0gWFtpXSArIENbaV07XG5cblx0ICAgICAgICAgICAgLy8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdhID0gZ3ggJiAweGZmZmY7XG5cdCAgICAgICAgICAgIHZhciBnYiA9IGd4ID4+PiAxNjtcblxuXHQgICAgICAgICAgICAvLyBDYWxjdWxhdGUgaGlnaCBhbmQgbG93IHJlc3VsdCBvZiBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2ggPSAoKCgoZ2EgKiBnYSkgPj4+IDE3KSArIGdhICogZ2IpID4+PiAxNSkgKyBnYiAqIGdiO1xuXHQgICAgICAgICAgICB2YXIgZ2wgPSAoKChneCAmIDB4ZmZmZjAwMDApICogZ3gpIHwgMCkgKyAoKChneCAmIDB4MDAwMGZmZmYpICogZ3gpIHwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gSGlnaCBYT1IgbG93XG5cdCAgICAgICAgICAgIEdbaV0gPSBnaCBeIGdsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgWFswXSA9IChHWzBdICsgKChHWzddIDw8IDE2KSB8IChHWzddID4+PiAxNikpICsgKChHWzZdIDw8IDE2KSB8IChHWzZdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFsxXSA9IChHWzFdICsgKChHWzBdIDw8IDgpICB8IChHWzBdID4+PiAyNCkpICsgR1s3XSkgfCAwO1xuXHQgICAgICAgIFhbMl0gPSAoR1syXSArICgoR1sxXSA8PCAxNikgfCAoR1sxXSA+Pj4gMTYpKSArICgoR1swXSA8PCAxNikgfCAoR1swXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbM10gPSAoR1szXSArICgoR1syXSA8PCA4KSAgfCAoR1syXSA+Pj4gMjQpKSArIEdbMV0pIHwgMDtcblx0ICAgICAgICBYWzRdID0gKEdbNF0gKyAoKEdbM10gPDwgMTYpIHwgKEdbM10gPj4+IDE2KSkgKyAoKEdbMl0gPDwgMTYpIHwgKEdbMl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzVdID0gKEdbNV0gKyAoKEdbNF0gPDwgOCkgIHwgKEdbNF0gPj4+IDI0KSkgKyBHWzNdKSB8IDA7XG5cdCAgICAgICAgWFs2XSA9IChHWzZdICsgKChHWzVdIDw8IDE2KSB8IChHWzVdID4+PiAxNikpICsgKChHWzRdIDw8IDE2KSB8IChHWzRdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs3XSA9IChHWzddICsgKChHWzZdIDw8IDgpICB8IChHWzZdID4+PiAyNCkpICsgR1s1XSkgfCAwO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJhYmJpdC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJhYmJpdC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SYWJiaXQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXQpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJhYmJpdDtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8qKlxuXHQgICAgICogUkM0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUkM0ID0gQ19hbGdvLlJDNCA9IFN0cmVhbUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaWdCeXRlcyA9IGtleS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBJbml0IHNib3hcblx0ICAgICAgICAgICAgdmFyIFMgPSB0aGlzLl9TID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIFNbaV0gPSBpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNldHVwXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5Qnl0ZUluZGV4ID0gaSAlIGtleVNpZ0J5dGVzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleUJ5dGUgPSAoa2V5V29yZHNba2V5Qnl0ZUluZGV4ID4+PiAyXSA+Pj4gKDI0IC0gKGtleUJ5dGVJbmRleCAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgaiA9IChqICsgU1tpXSArIGtleUJ5dGUpICUgMjU2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9IFNbaV07XG5cdCAgICAgICAgICAgICAgICBTW2ldID0gU1tqXTtcblx0ICAgICAgICAgICAgICAgIFNbal0gPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnRlcnNcblx0ICAgICAgICAgICAgdGhpcy5faSA9IHRoaXMuX2ogPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgTVtvZmZzZXRdIF49IGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbVdvcmQoKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIFMgPSB0aGlzLl9TO1xuXHQgICAgICAgIHZhciBpID0gdGhpcy5faTtcblx0ICAgICAgICB2YXIgaiA9IHRoaXMuX2o7XG5cblx0ICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW0gd29yZFxuXHQgICAgICAgIHZhciBrZXlzdHJlYW1Xb3JkID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDQ7IG4rKykge1xuXHQgICAgICAgICAgICBpID0gKGkgKyAxKSAlIDI1Njtcblx0ICAgICAgICAgICAgaiA9IChqICsgU1tpXSkgJSAyNTY7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICB2YXIgdCA9IFNbaV07XG5cdCAgICAgICAgICAgIFNbaV0gPSBTW2pdO1xuXHQgICAgICAgICAgICBTW2pdID0gdDtcblxuXHQgICAgICAgICAgICBrZXlzdHJlYW1Xb3JkIHw9IFNbKFNbaV0gKyBTW2pdKSAlIDI1Nl0gPDwgKDI0IC0gbiAqIDgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFVwZGF0ZSBjb3VudGVyc1xuXHQgICAgICAgIHRoaXMuX2kgPSBpO1xuXHQgICAgICAgIHRoaXMuX2ogPSBqO1xuXG5cdCAgICAgICAgcmV0dXJuIGtleXN0cmVhbVdvcmQ7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJDNCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJDNCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kaWZpZWQgUkM0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUkM0RHJvcCA9IENfYWxnby5SQzREcm9wID0gUkM0LmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyb3AgVGhlIG51bWJlciBvZiBrZXlzdHJlYW0gd29yZHMgdG8gZHJvcC4gRGVmYXVsdCAxOTJcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFJDNC5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZHJvcDogMTkyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBSQzQuX2RvUmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBEcm9wXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNmZy5kcm9wOyBpID4gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICBnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJDNERyb3AuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SQzREcm9wLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJDNERyb3AgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzREcm9wKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SQzQ7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JjNC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYzQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKiogQHByZXNlcnZlXG5cdChjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5cdFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuXHQgICAgLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cdCAgICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuXHRUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cdCovXG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXG5cdCAgICB2YXIgX3psID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcblx0ICAgICAgICA3LCAgNCwgMTMsICAxLCAxMCwgIDYsIDE1LCAgMywgMTIsICAwLCAgOSwgIDUsICAyLCAxNCwgMTEsICA4LFxuXHQgICAgICAgIDMsIDEwLCAxNCwgIDQsICA5LCAxNSwgIDgsICAxLCAgMiwgIDcsICAwLCAgNiwgMTMsIDExLCAgNSwgMTIsXG5cdCAgICAgICAgMSwgIDksIDExLCAxMCwgIDAsICA4LCAxMiwgIDQsIDEzLCAgMywgIDcsIDE1LCAxNCwgIDUsICA2LCAgMixcblx0ICAgICAgICA0LCAgMCwgIDUsICA5LCAgNywgMTIsICAyLCAxMCwgMTQsICAxLCAgMywgIDgsIDExLCAgNiwgMTUsIDEzXSk7XG5cdCAgICB2YXIgX3pyID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgNSwgMTQsICA3LCAgMCwgIDksICAyLCAxMSwgIDQsIDEzLCAgNiwgMTUsICA4LCAgMSwgMTAsICAzLCAxMixcblx0ICAgICAgICA2LCAxMSwgIDMsICA3LCAgMCwgMTMsICA1LCAxMCwgMTQsIDE1LCAgOCwgMTIsICA0LCAgOSwgIDEsICAyLFxuXHQgICAgICAgIDE1LCAgNSwgIDEsICAzLCAgNywgMTQsICA2LCAgOSwgMTEsICA4LCAxMiwgIDIsIDEwLCAgMCwgIDQsIDEzLFxuXHQgICAgICAgIDgsICA2LCAgNCwgIDEsICAzLCAxMSwgMTUsICAwLCAgNSwgMTIsICAyLCAxMywgIDksICA3LCAxMCwgMTQsXG5cdCAgICAgICAgMTIsIDE1LCAxMCwgIDQsICAxLCAgNSwgIDgsICA3LCAgNiwgIDIsIDEzLCAxNCwgIDAsICAzLCAgOSwgMTFdKTtcblx0ICAgIHZhciBfc2wgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAgMTEsIDE0LCAxNSwgMTIsICA1LCAgOCwgIDcsICA5LCAxMSwgMTMsIDE0LCAxNSwgIDYsICA3LCAgOSwgIDgsXG5cdCAgICAgICAgNywgNiwgICA4LCAxMywgMTEsICA5LCAgNywgMTUsICA3LCAxMiwgMTUsICA5LCAxMSwgIDcsIDEzLCAxMixcblx0ICAgICAgICAxMSwgMTMsICA2LCAgNywgMTQsICA5LCAxMywgMTUsIDE0LCAgOCwgMTMsICA2LCAgNSwgMTIsICA3LCAgNSxcblx0ICAgICAgICAgIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsICA5LCAgOCwgIDksIDE0LCAgNSwgIDYsICA4LCAgNiwgIDUsIDEyLFxuXHQgICAgICAgIDksIDE1LCAgNSwgMTEsICA2LCAgOCwgMTMsIDEyLCAgNSwgMTIsIDEzLCAxNCwgMTEsICA4LCAgNSwgIDYgXSk7XG5cdCAgICB2YXIgX3NyID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgOCwgIDksICA5LCAxMSwgMTMsIDE1LCAxNSwgIDUsICA3LCAgNywgIDgsIDExLCAxNCwgMTQsIDEyLCAgNixcblx0ICAgICAgICA5LCAxMywgMTUsICA3LCAxMiwgIDgsICA5LCAxMSwgIDcsICA3LCAxMiwgIDcsICA2LCAxNSwgMTMsIDExLFxuXHQgICAgICAgIDksICA3LCAxNSwgMTEsICA4LCAgNiwgIDYsIDE0LCAxMiwgMTMsICA1LCAxNCwgMTMsIDEzLCAgNywgIDUsXG5cdCAgICAgICAgMTUsICA1LCAgOCwgMTEsIDE0LCAxNCwgIDYsIDE0LCAgNiwgIDksIDEyLCAgOSwgMTIsICA1LCAxNSwgIDgsXG5cdCAgICAgICAgOCwgIDUsIDEyLCAgOSwgMTIsICA1LCAxNCwgIDYsICA4LCAxMywgIDYsICA1LCAxNSwgMTMsIDExLCAxMSBdKTtcblxuXHQgICAgdmFyIF9obCA9ICBXb3JkQXJyYXkuY3JlYXRlKFsgMHgwMDAwMDAwMCwgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhBOTUzRkQ0RV0pO1xuXHQgICAgdmFyIF9ociA9ICBXb3JkQXJyYXkuY3JlYXRlKFsgMHg1MEEyOEJFNiwgMHg1QzRERDEyNCwgMHg2RDcwM0VGMywgMHg3QTZENzZFOSwgMHgwMDAwMDAwMF0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJJUEVNRDE2MCBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJJUEVNRDE2MCA9IENfYWxnby5SSVBFTUQxNjAgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoICA9IFdvcmRBcnJheS5jcmVhdGUoWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG5cdCAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCAgPSB0aGlzLl9oYXNoLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaGwgPSBfaGwud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBociA9IF9oci53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHpsID0gX3psLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgenIgPSBfenIud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzbCA9IF9zbC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNyID0gX3NyLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhbCwgYmwsIGNsLCBkbCwgZWw7XG5cdCAgICAgICAgICAgIHZhciBhciwgYnIsIGNyLCBkciwgZXI7XG5cblx0ICAgICAgICAgICAgYXIgPSBhbCA9IEhbMF07XG5cdCAgICAgICAgICAgIGJyID0gYmwgPSBIWzFdO1xuXHQgICAgICAgICAgICBjciA9IGNsID0gSFsyXTtcblx0ICAgICAgICAgICAgZHIgPSBkbCA9IEhbM107XG5cdCAgICAgICAgICAgIGVyID0gZWwgPSBIWzRdO1xuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICB2YXIgdDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICB0ID0gKGFsICsgIE1bb2Zmc2V0K3psW2ldXSl8MDtcblx0ICAgICAgICAgICAgICAgIGlmIChpPDE2KXtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMShibCxjbCxkbCkgKyBobFswXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTwzMikge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYyKGJsLGNsLGRsKSArIGhsWzFdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDQ4KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjMoYmwsY2wsZGwpICsgaGxbMl07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NjQpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNChibCxjbCxkbCkgKyBobFszXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNShibCxjbCxkbCkgKyBobFs0XTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHQgPSB0fDA7XG5cdCAgICAgICAgICAgICAgICB0ID0gIHJvdGwodCxzbFtpXSk7XG5cdCAgICAgICAgICAgICAgICB0ID0gKHQrZWwpfDA7XG5cdCAgICAgICAgICAgICAgICBhbCA9IGVsO1xuXHQgICAgICAgICAgICAgICAgZWwgPSBkbDtcblx0ICAgICAgICAgICAgICAgIGRsID0gcm90bChjbCwgMTApO1xuXHQgICAgICAgICAgICAgICAgY2wgPSBibDtcblx0ICAgICAgICAgICAgICAgIGJsID0gdDtcblxuXHQgICAgICAgICAgICAgICAgdCA9IChhciArIE1bb2Zmc2V0K3pyW2ldXSl8MDtcblx0ICAgICAgICAgICAgICAgIGlmIChpPDE2KXtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNShicixjcixkcikgKyBoclswXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTwzMikge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY0KGJyLGNyLGRyKSArIGhyWzFdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDQ4KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjMoYnIsY3IsZHIpICsgaHJbMl07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NjQpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMihicixjcixkcikgKyBoclszXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMShicixjcixkcikgKyBocls0XTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHQgPSB0fDA7XG5cdCAgICAgICAgICAgICAgICB0ID0gIHJvdGwodCxzcltpXSkgO1xuXHQgICAgICAgICAgICAgICAgdCA9ICh0K2VyKXwwO1xuXHQgICAgICAgICAgICAgICAgYXIgPSBlcjtcblx0ICAgICAgICAgICAgICAgIGVyID0gZHI7XG5cdCAgICAgICAgICAgICAgICBkciA9IHJvdGwoY3IsIDEwKTtcblx0ICAgICAgICAgICAgICAgIGNyID0gYnI7XG5cdCAgICAgICAgICAgICAgICBiciA9IHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgdCAgICA9IChIWzFdICsgY2wgKyBkcil8MDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzJdICsgZGwgKyBlcil8MDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzNdICsgZWwgKyBhcil8MDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzRdICsgYWwgKyBicil8MDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzBdICsgYmwgKyBjcil8MDtcblx0ICAgICAgICAgICAgSFswXSA9ICB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbCA8PCA4KSAgfCAobkJpdHNUb3RhbCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cblx0ICAgIGZ1bmN0aW9uIGYxKHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCh4KSBeICh5KSBeICh6KSk7XG5cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjIoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKCh4KSYoeSkpIHwgKCh+eCkmKHopKSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGYzKHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCgoeCkgfCAofih5KSkpIF4gKHopKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjQoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKCh4KSAmICh6KSkgfCAoKHkpJih+KHopKSkpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmNSh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoeCkgXiAoKHkpIHwofih6KSkpKTtcblxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiByb3RsKHgsbikge1xuXHQgICAgICAgIHJldHVybiAoeDw8bikgfCAoeD4+PigzMi1uKSk7XG5cdCAgICB9XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlJJUEVNRDE2MCgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuUklQRU1EMTYwKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuUklQRU1EMTYwID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoUklQRU1EMTYwKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNSSVBFTUQxNjAobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjUklQRU1EMTYwID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFJJUEVNRDE2MCk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJJUEVNRDE2MDtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmlwZW1kMTYwLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JpcGVtZDE2MC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3Nixcblx0ICAgICAgICAgICAgICAgIDB4YzNkMmUxZjBcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IChuIDw8IDEpIHwgKG4gPj4+IDMxKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGUgKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAofmIgJiBkKSkgKyAweDVhODI3OTk5O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMHg2ZWQ5ZWJhMTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDYwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKSAtIDB4NzBlNDQzMjQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKGkgPCA4MCkgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBlID0gZDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9IHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEExKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGEyNTZcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMjU2XCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yMjQgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyMjQgPSBDX2FsZ28uU0hBMjI0ID0gU0hBMjU2LmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LFxuXHQgICAgICAgICAgICAgICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSBTSEEyNTYuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICBoYXNoLnNpZ0J5dGVzIC09IDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyMjQoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTIyNCA9IFNIQTI1Ni5fY3JlYXRlSGVscGVyKFNIQTIyNCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjI0KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTIyNCA9IFNIQTI1Ni5fY3JlYXRlSG1hY0hlbHBlcihTSEEyMjQpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTIyNDtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjI0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCByb3VuZCBjb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgSCA9IFtdO1xuXHQgICAgdmFyIEsgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG5cdCAgICAgICAgICAgIHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG4gPSAyO1xuXHQgICAgICAgIHZhciBuUHJpbWUgPSAwO1xuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuXHQgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDMpKTtcblxuXHQgICAgICAgICAgICAgICAgblByaW1lKys7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuKys7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIGYgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExICA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTF4ID4+PiAxMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgIHwgKGUgPj4+IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG5cdCAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgZiA9IGU7XG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gYjtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuXHQgICAgICAgICAgICBIWzZdID0gKEhbNl0gKyBnKSB8IDA7XG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjU2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQ7XG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgUkhPX09GRlNFVFMgPSBbXTtcblx0ICAgIHZhciBQSV9JTkRFWEVTICA9IFtdO1xuXHQgICAgdmFyIFJPVU5EX0NPTlNUQU5UUyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIENvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBDb21wdXRlIHJobyBvZmZzZXQgY29uc3RhbnRzXG5cdCAgICAgICAgdmFyIHggPSAxLCB5ID0gMDtcblx0ICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDI0OyB0KyspIHtcblx0ICAgICAgICAgICAgUkhPX09GRlNFVFNbeCArIDUgKiB5XSA9ICgodCArIDEpICogKHQgKyAyKSAvIDIpICUgNjQ7XG5cblx0ICAgICAgICAgICAgdmFyIG5ld1ggPSB5ICUgNTtcblx0ICAgICAgICAgICAgdmFyIG5ld1kgPSAoMiAqIHggKyAzICogeSkgJSA1O1xuXHQgICAgICAgICAgICB4ID0gbmV3WDtcblx0ICAgICAgICAgICAgeSA9IG5ld1k7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29tcHV0ZSBwaSBpbmRleCBjb25zdGFudHNcblx0ICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgUElfSU5ERVhFU1t4ICsgNSAqIHldID0geSArICgoMiAqIHggKyAzICogeSkgJSA1KSAqIDU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb21wdXRlIHJvdW5kIGNvbnN0YW50c1xuXHQgICAgICAgIHZhciBMRlNSID0gMHgwMTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHJvdW5kQ29uc3RhbnRNc3cgPSAwO1xuXHQgICAgICAgICAgICB2YXIgcm91bmRDb25zdGFudExzdyA9IDA7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChMRlNSICYgMHgwMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBiaXRQb3NpdGlvbiA9ICgxIDw8IGopIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYml0UG9zaXRpb24gPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3VuZENvbnN0YW50THN3IF49IDEgPDwgYml0UG9zaXRpb247XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChiaXRQb3NpdGlvbiA+PSAzMikgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3VuZENvbnN0YW50TXN3IF49IDEgPDwgKGJpdFBvc2l0aW9uIC0gMzIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IExGU1Jcblx0ICAgICAgICAgICAgICAgIGlmIChMRlNSICYgMHg4MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSBwb2x5bm9taWFsIG92ZXIgR0YoMik6IHheOCArIHheNiArIHheNSArIHheNCArIDFcblx0ICAgICAgICAgICAgICAgICAgICBMRlNSID0gKExGU1IgPDwgMSkgXiAweDcxO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBMRlNSIDw8PSAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgUk9VTkRfQ09OU1RBTlRTW2ldID0gWDY0V29yZC5jcmVhdGUocm91bmRDb25zdGFudE1zdywgcm91bmRDb25zdGFudExzdyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0cyBmb3IgdGVtcG9yYXJ5IHZhbHVlc1xuXHQgICAgdmFyIFQgPSBbXTtcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSBYNjRXb3JkLmNyZWF0ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTMgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEzID0gQ19hbGdvLlNIQTMgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gb3V0cHV0TGVuZ3RoXG5cdCAgICAgICAgICogICBUaGUgZGVzaXJlZCBudW1iZXIgb2YgYml0cyBpbiB0aGUgb3V0cHV0IGhhc2guXG5cdCAgICAgICAgICogICBPbmx5IHZhbHVlcyBwZXJtaXR0ZWQgYXJlOiAyMjQsIDI1NiwgMzg0LCA1MTIuXG5cdCAgICAgICAgICogICBEZWZhdWx0OiA1MTJcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEhhc2hlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgb3V0cHV0TGVuZ3RoOiA1MTJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlID0gW11cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZVtpXSA9IG5ldyBYNjRXb3JkLmluaXQoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMuYmxvY2tTaXplID0gKDE2MDAgLSAyICogdGhpcy5jZmcub3V0cHV0TGVuZ3RoKSAvIDMyO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICB2YXIgbkJsb2NrU2l6ZUxhbmVzID0gdGhpcy5ibG9ja1NpemUgLyAyO1xuXG5cdCAgICAgICAgICAgIC8vIEFic29yYlxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CbG9ja1NpemVMYW5lczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBNMmkgID0gTVtvZmZzZXQgKyAyICogaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgTTJpMSA9IE1bb2Zmc2V0ICsgMiAqIGkgKyAxXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIE0yaSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkgPDwgOCkgIHwgKE0yaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkgPDwgMjQpIHwgKE0yaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgTTJpMSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkxIDw8IDgpICB8IChNMmkxID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaTEgPDwgMjQpIHwgKE0yaTEgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQWJzb3JiIG1lc3NhZ2UgaW50byBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtpXTtcblx0ICAgICAgICAgICAgICAgIGxhbmUuaGlnaCBePSBNMmkxO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5sb3cgIF49IE0yaTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFRoZXRhXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIE1peCBjb2x1bW4gbGFuZXNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IDAsIHRMc3cgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdE1zdyBePSBsYW5lLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRMc3cgXj0gbGFuZS5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeCA9IFRbeF07XG5cdCAgICAgICAgICAgICAgICAgICAgVHguaGlnaCA9IHRNc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgVHgubG93ICA9IHRMc3c7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDQgPSBUWyh4ICsgNCkgJSA1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHgxID0gVFsoeCArIDEpICUgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4MU1zdyA9IFR4MS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDFMc3cgPSBUeDEubG93O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTWl4IHN1cnJvdW5kaW5nIGNvbHVtbnNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IFR4NC5oaWdoIF4gKChUeDFNc3cgPDwgMSkgfCAoVHgxTHN3ID4+PiAzMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0THN3ID0gVHg0LmxvdyAgXiAoKFR4MUxzdyA8PCAxKSB8IChUeDFNc3cgPj4+IDMxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVt4ICsgNSAqIHldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggXj0gdE1zdztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5sb3cgIF49IHRMc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSaG8gUGlcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGxhbmVJbmRleCA9IDE7IGxhbmVJbmRleCA8IDI1OyBsYW5lSW5kZXgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbbGFuZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZU1zdyA9IGxhbmUuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZUxzdyA9IGxhbmUubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByaG9PZmZzZXQgPSBSSE9fT0ZGU0VUU1tsYW5lSW5kZXhdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlIGxhbmVzXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJob09mZnNldCA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gKGxhbmVNc3cgPDwgcmhvT2Zmc2V0KSB8IChsYW5lTHN3ID4+PiAoMzIgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRMc3cgPSAobGFuZUxzdyA8PCByaG9PZmZzZXQpIHwgKGxhbmVNc3cgPj4+ICgzMiAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAocmhvT2Zmc2V0ID49IDMyKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gKGxhbmVMc3cgPDwgKHJob09mZnNldCAtIDMyKSkgfCAobGFuZU1zdyA+Pj4gKDY0IC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0THN3ID0gKGxhbmVNc3cgPDwgKHJob09mZnNldCAtIDMyKSkgfCAobGFuZUxzdyA+Pj4gKDY0IC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNwb3NlIGxhbmVzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFRQaUxhbmUgPSBUW1BJX0lOREVYRVNbbGFuZUluZGV4XV07XG5cdCAgICAgICAgICAgICAgICAgICAgVFBpTGFuZS5oaWdoID0gdE1zdztcblx0ICAgICAgICAgICAgICAgICAgICBUUGlMYW5lLmxvdyAgPSB0THN3O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSaG8gcGkgYXQgeCA9IHkgPSAwXG5cdCAgICAgICAgICAgICAgICB2YXIgVDAgPSBUWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXRlMCA9IHN0YXRlWzBdO1xuXHQgICAgICAgICAgICAgICAgVDAuaGlnaCA9IHN0YXRlMC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgVDAubG93ICA9IHN0YXRlMC5sb3c7XG5cblx0ICAgICAgICAgICAgICAgIC8vIENoaVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVJbmRleCA9IHggKyA1ICogeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtsYW5lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVExhbmUgPSBUW2xhbmVJbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUeDFMYW5lID0gVFsoKHggKyAxKSAlIDUpICsgNSAqIHldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVHgyTGFuZSA9IFRbKCh4ICsgMikgJSA1KSArIDUgKiB5XTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggcm93c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggPSBUTGFuZS5oaWdoIF4gKH5UeDFMYW5lLmhpZ2ggJiBUeDJMYW5lLmhpZ2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmxvdyAgPSBUTGFuZS5sb3cgIF4gKH5UeDFMYW5lLmxvdyAgJiBUeDJMYW5lLmxvdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJb3RhXG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJvdW5kQ29uc3RhbnQgPSBST1VORF9DT05TVEFOVFNbcm91bmRdO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5oaWdoIF49IHJvdW5kQ29uc3RhbnQuaGlnaDtcblx0ICAgICAgICAgICAgICAgIGxhbmUubG93ICBePSByb3VuZENvbnN0YW50Lmxvdzs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJpdHMgPSB0aGlzLmJsb2NrU2l6ZSAqIDMyO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4MSA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKE1hdGguY2VpbCgobkJpdHNMZWZ0ICsgMSkgLyBibG9ja1NpemVCaXRzKSAqIGJsb2NrU2l6ZUJpdHMpID4+PiA1KSAtIDFdIHw9IDB4ODA7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICB2YXIgb3V0cHV0TGVuZ3RoQnl0ZXMgPSB0aGlzLmNmZy5vdXRwdXRMZW5ndGggLyA4O1xuXHQgICAgICAgICAgICB2YXIgb3V0cHV0TGVuZ3RoTGFuZXMgPSBvdXRwdXRMZW5ndGhCeXRlcyAvIDg7XG5cblx0ICAgICAgICAgICAgLy8gU3F1ZWV6ZVxuXHQgICAgICAgICAgICB2YXIgaGFzaFdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoTGFuZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmVNc3cgPSBsYW5lLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZUxzdyA9IGxhbmUubG93O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgbGFuZU1zdyA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTXN3IDw8IDgpICB8IChsYW5lTXN3ID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVNc3cgPDwgMjQpIHwgKGxhbmVNc3cgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgIGxhbmVMc3cgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZUxzdyA8PCA4KSAgfCAobGFuZUxzdyA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTHN3IDw8IDI0KSB8IChsYW5lTHN3ID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNxdWVlemUgc3RhdGUgdG8gcmV0cmlldmUgaGFzaFxuXHQgICAgICAgICAgICAgICAgaGFzaFdvcmRzLnB1c2gobGFuZUxzdyk7XG5cdCAgICAgICAgICAgICAgICBoYXNoV29yZHMucHVzaChsYW5lTXN3KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQoaGFzaFdvcmRzLCBvdXRwdXRMZW5ndGhCeXRlcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IGNsb25lLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLnNsaWNlKDApO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlW2ldID0gc3RhdGVbaV0uY2xvbmUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTMoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTMod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEzID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMyk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMyhtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEzID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTMpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEzO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGE1MTJcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIiwgXCIuL3NoYTUxMlwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX3g2NCA9IEMueDY0O1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkO1xuXHQgICAgdmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgU0hBNTEyID0gQ19hbGdvLlNIQTUxMjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMzg0IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMzg0ID0gQ19hbGdvLlNIQTM4NCA9IFNIQTUxMi5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4KSwgbmV3IFg2NFdvcmQuaW5pdCgweDYyOWEyOTJhLCAweDM2N2NkNTA3KSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyksIG5ldyBYNjRXb3JkLmluaXQoMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEpLCBuZXcgWDY0V29yZC5pbml0KDB4OGViNDRhODcsIDB4Njg1ODE1MTEpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweGRiMGMyZTBkLCAweDY0Zjk4ZmE3KSwgbmV3IFg2NFdvcmQuaW5pdCgweDQ3YjU0ODFkLCAweGJlZmE0ZmE0KVxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSBTSEE1MTIuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICBoYXNoLnNpZ0J5dGVzIC09IDE2O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMzg0KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEzODQgPSBTSEE1MTIuX2NyZWF0ZUhlbHBlcihTSEEzODQpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTM4NChtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEzODQgPSBTSEE1MTIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMzg0KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEzODQ7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTM4NC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQ7XG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQ7XG5cdCAgICB2YXIgWDY0V29yZEFycmF5ID0gQ194NjQuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgZnVuY3Rpb24gWDY0V29yZF9jcmVhdGUoKSB7XG5cdCAgICAgICAgcmV0dXJuIFg2NFdvcmQuY3JlYXRlLmFwcGx5KFg2NFdvcmQsIGFyZ3VtZW50cyk7XG5cdCAgICB9XG5cblx0ICAgIC8vIENvbnN0YW50c1xuXHQgICAgdmFyIEsgPSBbXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiksIFg2NFdvcmRfY3JlYXRlKDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYpLCBYNjRXb3JkX2NyZWF0ZSgweGU5YjVkYmE1LCAweDgxODlkYmJjKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDM5NTZjMjViLCAweGYzNDhiNTM4KSwgWDY0V29yZF9jcmVhdGUoMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5MjNmODJhNCwgMHhhZjE5NGY5YiksIFg2NFdvcmRfY3JlYXRlKDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIpLCBYNjRXb3JkX2NyZWF0ZSgweDEyODM1YjAxLCAweDQ1NzA2ZmJlKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI0MzE4NWJlLCAweDRlZTRiMjhjKSwgWDY0V29yZF9jcmVhdGUoMHg1NTBjN2RjMywgMHhkNWZmYjRlMiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiksIFg2NFdvcmRfY3JlYXRlKDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUpLCBYNjRXb3JkX2NyZWF0ZSgweGMxOWJmMTc0LCAweGNmNjkyNjk0KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGU0OWI2OWMxLCAweDllZjE0YWQyKSwgWDY0V29yZF9jcmVhdGUoMHhlZmJlNDc4NiwgMHgzODRmMjVlMyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgwZmMxOWRjNiwgMHg4YjhjZDViNSksIFg2NFdvcmRfY3JlYXRlKDB4MjQwY2ExY2MsIDB4NzdhYzljNjUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUpLCBYNjRXb3JkX2NyZWF0ZSgweDRhNzQ4NGFhLCAweDZlYTZlNDgzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDVjYjBhOWRjLCAweGJkNDFmYmQ0KSwgWDY0V29yZF9jcmVhdGUoMHg3NmY5ODhkYSwgMHg4MzExNTNiNSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiksIFg2NFdvcmRfY3JlYXRlKDB4YTgzMWM2NmQsIDB4MmRiNDMyMTApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YjAwMzI3YzgsIDB4OThmYjIxM2YpLCBYNjRXb3JkX2NyZWF0ZSgweGJmNTk3ZmM3LCAweGJlZWYwZWU0KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGM2ZTAwYmYzLCAweDNkYTg4ZmMyKSwgWDY0V29yZF9jcmVhdGUoMHhkNWE3OTE0NywgMHg5MzBhYTcyNSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiksIFg2NFdvcmRfY3JlYXRlKDB4MTQyOTI5NjcsIDB4MGEwZTZlNzApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MjdiNzBhODUsIDB4NDZkMjJmZmMpLCBYNjRXb3JkX2NyZWF0ZSgweDJlMWIyMTM4LCAweDVjMjZjOTI2KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDRkMmM2ZGZjLCAweDVhYzQyYWVkKSwgWDY0V29yZF9jcmVhdGUoMHg1MzM4MGQxMywgMHg5ZDk1YjNkZiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSksIFg2NFdvcmRfY3JlYXRlKDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYpLCBYNjRXb3JkX2NyZWF0ZSgweDkyNzIyYzg1LCAweDE0ODIzNTNiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGEyYmZlOGExLCAweDRjZjEwMzY0KSwgWDY0V29yZF9jcmVhdGUoMHhhODFhNjY0YiwgMHhiYzQyMzAwMSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSksIFg2NFdvcmRfY3JlYXRlKDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgpLCBYNjRXb3JkX2NyZWF0ZSgweGQ2OTkwNjI0LCAweDU1NjVhOTEwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGY0MGUzNTg1LCAweDU3NzEyMDJhKSwgWDY0V29yZF9jcmVhdGUoMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgxOWE0YzExNiwgMHhiOGQyZDBjOCksIFg2NFdvcmRfY3JlYXRlKDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTkpLCBYNjRXb3JkX2NyZWF0ZSgweDM0YjBiY2I1LCAweGUxOWI0OGE4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDM5MWMwY2IzLCAweGM1Yzk1YTYzKSwgWDY0V29yZF9jcmVhdGUoMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg1YjljY2E0ZiwgMHg3NzYzZTM3MyksIFg2NFdvcmRfY3JlYXRlKDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMpLCBYNjRXb3JkX2NyZWF0ZSgweDc4YTU2MzZmLCAweDQzMTcyZjYwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDg0Yzg3ODE0LCAweGExZjBhYjcyKSwgWDY0V29yZF9jcmVhdGUoMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCksIFg2NFdvcmRfY3JlYXRlKDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTkpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUpLCBYNjRXb3JkX2NyZWF0ZSgweGM2NzE3OGYyLCAweGUzNzI1MzJiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGNhMjczZWNlLCAweGVhMjY2MTljKSwgWDY0V29yZF9jcmVhdGUoMHhkMTg2YjhjNywgMHgyMWMwYzIwNyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSksIFg2NFdvcmRfY3JlYXRlKDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEpLCBYNjRXb3JkX2NyZWF0ZSgweDBhNjM3ZGM1LCAweGEyYzg5OGE2KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDExM2Y5ODA0LCAweGJlZjkwZGFlKSwgWDY0V29yZF9jcmVhdGUoMHgxYjcxMGIzNSwgMHgxMzFjNDcxYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCksIFg2NFdvcmRfY3JlYXRlKDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMpLCBYNjRXb3JkX2NyZWF0ZSgweDQzMWQ2N2M0LCAweDljMTAwZDRjKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDRjYzVkNGJlLCAweGNiM2U0MmI2KSwgWDY0V29yZF9jcmVhdGUoMHg1OTdmMjk5YywgMHhmYzY1N2UyYSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYyksIFg2NFdvcmRfY3JlYXRlKDB4NmM0NDE5OGMsIDB4NGE0NzU4MTcpXG5cdCAgICBdO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzXG5cdCAgICB2YXIgVyA9IFtdO1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgV1tpXSA9IFg2NFdvcmRfY3JlYXRlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtNTEyIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBNTEyID0gQ19hbGdvLlNIQTUxMiA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDZhMDllNjY3LCAweGYzYmNjOTA4KSwgbmV3IFg2NFdvcmQuaW5pdCgweGJiNjdhZTg1LCAweDg0Y2FhNzNiKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiksIG5ldyBYNjRXb3JkLmluaXQoMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEpLCBuZXcgWDY0V29yZC5pbml0KDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDFmODNkOWFiLCAweGZiNDFiZDZiKSwgbmV3IFg2NFdvcmQuaW5pdCgweDViZTBjZDE5LCAweDEzN2UyMTc5KVxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIEgwID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIEgxID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIEgyID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIEgzID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIEg0ID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIEg1ID0gSFs1XTtcblx0ICAgICAgICAgICAgdmFyIEg2ID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIEg3ID0gSFs3XTtcblxuXHQgICAgICAgICAgICB2YXIgSDBoID0gSDAuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgwbCA9IEgwLmxvdztcblx0ICAgICAgICAgICAgdmFyIEgxaCA9IEgxLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIMWwgPSBIMS5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIMmggPSBIMi5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDJsID0gSDIubG93O1xuXHQgICAgICAgICAgICB2YXIgSDNoID0gSDMuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgzbCA9IEgzLmxvdztcblx0ICAgICAgICAgICAgdmFyIEg0aCA9IEg0LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBINGwgPSBINC5sb3c7XG5cdCAgICAgICAgICAgIHZhciBINWggPSBINS5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDVsID0gSDUubG93O1xuXHQgICAgICAgICAgICB2YXIgSDZoID0gSDYuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg2bCA9IEg2Lmxvdztcblx0ICAgICAgICAgICAgdmFyIEg3aCA9IEg3LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIN2wgPSBINy5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGFoID0gSDBoO1xuXHQgICAgICAgICAgICB2YXIgYWwgPSBIMGw7XG5cdCAgICAgICAgICAgIHZhciBiaCA9IEgxaDtcblx0ICAgICAgICAgICAgdmFyIGJsID0gSDFsO1xuXHQgICAgICAgICAgICB2YXIgY2ggPSBIMmg7XG5cdCAgICAgICAgICAgIHZhciBjbCA9IEgybDtcblx0ICAgICAgICAgICAgdmFyIGRoID0gSDNoO1xuXHQgICAgICAgICAgICB2YXIgZGwgPSBIM2w7XG5cdCAgICAgICAgICAgIHZhciBlaCA9IEg0aDtcblx0ICAgICAgICAgICAgdmFyIGVsID0gSDRsO1xuXHQgICAgICAgICAgICB2YXIgZmggPSBINWg7XG5cdCAgICAgICAgICAgIHZhciBmbCA9IEg1bDtcblx0ICAgICAgICAgICAgdmFyIGdoID0gSDZoO1xuXHQgICAgICAgICAgICB2YXIgZ2wgPSBINmw7XG5cdCAgICAgICAgICAgIHZhciBoaCA9IEg3aDtcblx0ICAgICAgICAgICAgdmFyIGhsID0gSDdsO1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgV2kgPSBXW2ldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBFeHRlbmQgbWVzc2FnZVxuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBXaS5oaWdoID0gTVtvZmZzZXQgKyBpICogMl0gICAgIHwgMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gV2kubG93ICA9IE1bb2Zmc2V0ICsgaSAqIDIgKyAxXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdhbW1hMFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ICA9IFdbaSAtIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweGggPSBnYW1tYTB4LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHhsID0gZ2FtbWEweC5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMGggID0gKChnYW1tYTB4aCA+Pj4gMSkgfCAoZ2FtbWEweGwgPDwgMzEpKSBeICgoZ2FtbWEweGggPj4+IDgpIHwgKGdhbW1hMHhsIDw8IDI0KSkgXiAoZ2FtbWEweGggPj4+IDcpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTBsICA9ICgoZ2FtbWEweGwgPj4+IDEpIHwgKGdhbW1hMHhoIDw8IDMxKSkgXiAoKGdhbW1hMHhsID4+PiA4KSB8IChnYW1tYTB4aCA8PCAyNCkpIF4gKChnYW1tYTB4bCA+Pj4gNykgfCAoZ2FtbWEweGggPDwgMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdhbW1hMVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ICA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4aCA9IGdhbW1hMXguaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeGwgPSBnYW1tYTF4Lmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExaCAgPSAoKGdhbW1hMXhoID4+PiAxOSkgfCAoZ2FtbWExeGwgPDwgMTMpKSBeICgoZ2FtbWExeGggPDwgMykgfCAoZ2FtbWExeGwgPj4+IDI5KSkgXiAoZ2FtbWExeGggPj4+IDYpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTFsICA9ICgoZ2FtbWExeGwgPj4+IDE5KSB8IChnYW1tYTF4aCA8PCAxMykpIF4gKChnYW1tYTF4bCA8PCAzKSB8IChnYW1tYTF4aCA+Pj4gMjkpKSBeICgoZ2FtbWExeGwgPj4+IDYpIHwgKGdhbW1hMXhoIDw8IDI2KSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2k3ICA9IFdbaSAtIDddO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTdoID0gV2k3LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpN2wgPSBXaTcubG93O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpMTYgID0gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTE2aCA9IFdpMTYuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2kxNmwgPSBXaTE2LmxvdztcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBnYW1tYTBsICsgV2k3bDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gZ2FtbWEwaCArIFdpN2ggKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWEwbCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IFdpbCArIGdhbW1hMWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IFdpaCArIGdhbW1hMWggKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWExbCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IFdpbCArIFdpMTZsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBXaWggKyBXaTE2aCArICgoV2lsID4+PiAwKSA8IChXaTE2bCA+Pj4gMCkgPyAxIDogMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXaS5oaWdoID0gV2loO1xuXHQgICAgICAgICAgICAgICAgICAgIFdpLmxvdyAgPSBXaWw7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaGggID0gKGVoICYgZmgpIF4gKH5laCAmIGdoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGwgID0gKGVsICYgZmwpIF4gKH5lbCAmIGdsKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWpoID0gKGFoICYgYmgpIF4gKGFoICYgY2gpIF4gKGJoICYgY2gpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hamwgPSAoYWwgJiBibCkgXiAoYWwgJiBjbCkgXiAoYmwgJiBjbCk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTBoID0gKChhaCA+Pj4gMjgpIHwgKGFsIDw8IDQpKSAgXiAoKGFoIDw8IDMwKSAgfCAoYWwgPj4+IDIpKSBeICgoYWggPDwgMjUpIHwgKGFsID4+PiA3KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwbCA9ICgoYWwgPj4+IDI4KSB8IChhaCA8PCA0KSkgIF4gKChhbCA8PCAzMCkgIHwgKGFoID4+PiAyKSkgXiAoKGFsIDw8IDI1KSB8IChhaCA+Pj4gNykpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMWggPSAoKGVoID4+PiAxNCkgfCAoZWwgPDwgMTgpKSBeICgoZWggPj4+IDE4KSB8IChlbCA8PCAxNCkpIF4gKChlaCA8PCAyMykgfCAoZWwgPj4+IDkpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTFsID0gKChlbCA+Pj4gMTQpIHwgKGVoIDw8IDE4KSkgXiAoKGVsID4+PiAxOCkgfCAoZWggPDwgMTQpKSBeICgoZWwgPDwgMjMpIHwgKGVoID4+PiA5KSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV1cblx0ICAgICAgICAgICAgICAgIHZhciBLaSAgPSBLW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIEtpaCA9IEtpLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICB2YXIgS2lsID0gS2kubG93O1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gaGwgKyBzaWdtYTFsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IGhoICsgc2lnbWExaCArICgodDFsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gdDFsICsgY2hsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IHQxaCArIGNoaCArICgodDFsID4+PiAwKSA8IChjaGwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IHQxbCArIEtpbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSB0MWggKyBLaWggKyAoKHQxbCA+Pj4gMCkgPCAoS2lsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSB0MWwgKyBXaWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gdDFoICsgV2loICsgKCh0MWwgPj4+IDApIDwgKFdpbCA+Pj4gMCkgPyAxIDogMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG5cdCAgICAgICAgICAgICAgICB2YXIgdDJsID0gc2lnbWEwbCArIG1hamw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDJoID0gc2lnbWEwaCArIG1hamggKyAoKHQybCA+Pj4gMCkgPCAoc2lnbWEwbCA+Pj4gMCkgPyAxIDogMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB3b3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICAgICAgaGggPSBnaDtcblx0ICAgICAgICAgICAgICAgIGhsID0gZ2w7XG5cdCAgICAgICAgICAgICAgICBnaCA9IGZoO1xuXHQgICAgICAgICAgICAgICAgZ2wgPSBmbDtcblx0ICAgICAgICAgICAgICAgIGZoID0gZWg7XG5cdCAgICAgICAgICAgICAgICBmbCA9IGVsO1xuXHQgICAgICAgICAgICAgICAgZWwgPSAoZGwgKyB0MWwpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGVoID0gKGRoICsgdDFoICsgKChlbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkaCA9IGNoO1xuXHQgICAgICAgICAgICAgICAgZGwgPSBjbDtcblx0ICAgICAgICAgICAgICAgIGNoID0gYmg7XG5cdCAgICAgICAgICAgICAgICBjbCA9IGJsO1xuXHQgICAgICAgICAgICAgICAgYmggPSBhaDtcblx0ICAgICAgICAgICAgICAgIGJsID0gYWw7XG5cdCAgICAgICAgICAgICAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGFoID0gKHQxaCArIHQyaCArICgoYWwgPj4+IDApIDwgKHQxbCA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEgwbCA9IEgwLmxvdyAgPSAoSDBsICsgYWwpO1xuXHQgICAgICAgICAgICBIMC5oaWdoID0gKEgwaCArIGFoICsgKChIMGwgPj4+IDApIDwgKGFsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEgxbCA9IEgxLmxvdyAgPSAoSDFsICsgYmwpO1xuXHQgICAgICAgICAgICBIMS5oaWdoID0gKEgxaCArIGJoICsgKChIMWwgPj4+IDApIDwgKGJsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEgybCA9IEgyLmxvdyAgPSAoSDJsICsgY2wpO1xuXHQgICAgICAgICAgICBIMi5oaWdoID0gKEgyaCArIGNoICsgKChIMmwgPj4+IDApIDwgKGNsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEgzbCA9IEgzLmxvdyAgPSAoSDNsICsgZGwpO1xuXHQgICAgICAgICAgICBIMy5oaWdoID0gKEgzaCArIGRoICsgKChIM2wgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg0bCA9IEg0LmxvdyAgPSAoSDRsICsgZWwpO1xuXHQgICAgICAgICAgICBINC5oaWdoID0gKEg0aCArIGVoICsgKChINGwgPj4+IDApIDwgKGVsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg1bCA9IEg1LmxvdyAgPSAoSDVsICsgZmwpO1xuXHQgICAgICAgICAgICBINS5oaWdoID0gKEg1aCArIGZoICsgKChINWwgPj4+IDApIDwgKGZsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg2bCA9IEg2LmxvdyAgPSAoSDZsICsgZ2wpO1xuXHQgICAgICAgICAgICBINi5oaWdoID0gKEg2aCArIGdoICsgKChINmwgPj4+IDApIDwgKGdsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg3bCA9IEg3LmxvdyAgPSAoSDdsICsgaGwpO1xuXHQgICAgICAgICAgICBINy5oaWdoID0gKEg3aCArIGhoICsgKChIN2wgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDEyOCkgPj4+IDEwKSA8PCA1KSArIDMwXSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDEyOCkgPj4+IDEwKSA8PCA1KSArIDMxXSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBoYXNoIHRvIDMyLWJpdCB3b3JkIGFycmF5IGJlZm9yZSByZXR1cm5pbmdcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLnRvWDMyKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTAyNC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTUxMih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTUxMiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTUxMik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBNTEyKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTUxMiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEE1MTIpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTUxMjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhNTEyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUGVybXV0ZWQgQ2hvaWNlIDEgY29uc3RhbnRzXG5cdCAgICB2YXIgUEMxID0gW1xuXHQgICAgICAgIDU3LCA0OSwgNDEsIDMzLCAyNSwgMTcsIDksICAxLFxuXHQgICAgICAgIDU4LCA1MCwgNDIsIDM0LCAyNiwgMTgsIDEwLCAyLFxuXHQgICAgICAgIDU5LCA1MSwgNDMsIDM1LCAyNywgMTksIDExLCAzLFxuXHQgICAgICAgIDYwLCA1MiwgNDQsIDM2LCA2MywgNTUsIDQ3LCAzOSxcblx0ICAgICAgICAzMSwgMjMsIDE1LCA3LCAgNjIsIDU0LCA0NiwgMzgsXG5cdCAgICAgICAgMzAsIDIyLCAxNCwgNiwgIDYxLCA1MywgNDUsIDM3LFxuXHQgICAgICAgIDI5LCAyMSwgMTMsIDUsICAyOCwgMjAsIDEyLCA0XG5cdCAgICBdO1xuXG5cdCAgICAvLyBQZXJtdXRlZCBDaG9pY2UgMiBjb25zdGFudHNcblx0ICAgIHZhciBQQzIgPSBbXG5cdCAgICAgICAgMTQsIDE3LCAxMSwgMjQsIDEsICA1LFxuXHQgICAgICAgIDMsICAyOCwgMTUsIDYsICAyMSwgMTAsXG5cdCAgICAgICAgMjMsIDE5LCAxMiwgNCwgIDI2LCA4LFxuXHQgICAgICAgIDE2LCA3LCAgMjcsIDIwLCAxMywgMixcblx0ICAgICAgICA0MSwgNTIsIDMxLCAzNywgNDcsIDU1LFxuXHQgICAgICAgIDMwLCA0MCwgNTEsIDQ1LCAzMywgNDgsXG5cdCAgICAgICAgNDQsIDQ5LCAzOSwgNTYsIDM0LCA1Myxcblx0ICAgICAgICA0NiwgNDIsIDUwLCAzNiwgMjksIDMyXG5cdCAgICBdO1xuXG5cdCAgICAvLyBDdW11bGF0aXZlIGJpdCBzaGlmdCBjb25zdGFudHNcblx0ICAgIHZhciBCSVRfU0hJRlRTID0gWzEsICAyLCAgNCwgIDYsICA4LCAgMTAsIDEyLCAxNCwgMTUsIDE3LCAxOSwgMjEsIDIzLCAyNSwgMjcsIDI4XTtcblxuXHQgICAgLy8gU0JPWGVzIGFuZCByb3VuZCBwZXJtdXRhdGlvbiBjb25zdGFudHNcblx0ICAgIHZhciBTQk9YX1AgPSBbXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDAwOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwMDA6IDB4ODA4MDAyLFxuXHQgICAgICAgICAgICAweDMwMDAwMDAwOiAweDIsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwMDA6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDUwMDAwMDAwOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHg2MDAwMDAwMDogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwMDA6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAwOiAweDIwMixcblx0ICAgICAgICAgICAgMHg5MDAwMDAwMDogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwMDA6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHhiMDAwMDAwMDogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwMDA6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHhkMDAwMDAwMDogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhmMDAwMDAwMDogMHg4MjAyLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwMDogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwMDA6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHgzODAwMDAwMDogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDAwOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDAwMDogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwMDA6IDB4ODA4MDAyLFxuXHQgICAgICAgICAgICAweDc4MDAwMDAwOiAweDIsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwMDA6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweDk4MDAwMDAwOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwMDA6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwMDAwOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHhjODAwMDAwMDogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwMDA6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHhlODAwMDAwMDogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwMDA6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDE6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwMTogMHgyLFxuXHQgICAgICAgICAgICAweDIwMDAwMDAxOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHgzMDAwMDAwMTogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwMDE6IDB4ODA4MDAyLFxuXHQgICAgICAgICAgICAweDUwMDAwMDAxOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwMDE6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDcwMDAwMDAxOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMTogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwMDE6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDAxOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHhiMDAwMDAwMTogMHg4MjAyLFxuXHQgICAgICAgICAgICAweGMwMDAwMDAxOiAweDIwMixcblx0ICAgICAgICAgICAgMHhkMDAwMDAwMTogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwMDE6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHhmMDAwMDAwMTogMHgwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDE4MDAwMDAxOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHgyODAwMDAwMTogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwMDE6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDAxOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwMDE6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweDY4MDAwMDAxOiAweDIsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwMDE6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHg4ODAwMDAwMTogMHg4MDAyLFxuXHQgICAgICAgICAgICAweDk4MDAwMDAxOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHhhODAwMDAwMTogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwMDE6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweGM4MDAwMDAxOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHhkODAwMDAwMTogMHgwLFxuXHQgICAgICAgICAgICAweGU4MDAwMDAxOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwMDE6IDB4ODA4MDAyXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHgzMDAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDQwMDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHg2MDAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDcwMDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDogMHg4NDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHhjMDAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweGQwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhlMDAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHgyODAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDM4MDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwMDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDY4MDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHg4ODAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweDk4MDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhhODAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHhjODAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDA6IDB4ODQwMDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHhmODAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxMTAwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHgxMjAwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHgxMzAwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHgxNDAwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHgxNTAwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHgxNjAwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHgxNzAwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4MTkwMDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4MWIwMDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4MWMwMDAwMDA6IDB4ODQwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4MWUwMDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDAwMDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTA4MDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTE4MDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHgxNDgwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHgxNTgwMDAwMDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHgxNjgwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHgxNzgwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODgwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHgxOTgwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHgxYTgwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHgxYjgwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHgxYzgwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFkODAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4MWU4MDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4MWY4MDAwMDA6IDB4ODQwMDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHgxMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgyMDAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHgzMDAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDUwMDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDYwMDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweDcwMDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDkwMDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDogMHgxMDEwMCxcblx0ICAgICAgICAgICAgMHhiMDAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHhjMDAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHhkMDAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweDI4MDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDM4MDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDU4MDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHg2ODAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHg4ODAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHg5ODAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweGE4MDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHhjODAwMDA6IDB4MTAxMDAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweDExMDAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTIwMDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHgxMzAwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4MTQwMDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweDE2MDAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHgxNzAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweDE5MDAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4MWIwMDAwMDogMHgxMDEwMCxcblx0ICAgICAgICAgICAgMHgxYzAwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDAwMDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4MWUwMDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHgxZjAwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTA4MDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDExODAwMDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDEyODAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHgxMzgwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHgxNTgwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4MTY4MDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4MTc4MDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweDE4ODAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweDFhODAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4MWI4MDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDFjODAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHgxZDgwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweDFmODAwMDA6IDB4MTAxMDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweDEwMDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDIwMDAwOiAweDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgzMDAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHg0MDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDUwMDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHg2MDAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHg3MDAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweGEwMDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweGIwMDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweGMwMDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweGQwMDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHhmMDAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHg4MDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDE4MDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweDI4MDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweDM4MDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHg2ODAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDc4MDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDg4MDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4OTgwMDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4YzgwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweGU4MDAwOiAweDQwMTA0MCxcblx0ICAgICAgICAgICAgMHhmODAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHgxMDAwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweDExMDAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTIwMDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDEzMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE0MDAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweDE1MDAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxNjAwMDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTcwMDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgxOTAwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDFiMDAwMDogMHg0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweDFkMDAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWUwMDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweDFmMDAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweDEwODAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMTgwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxNDgwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweDE1ODAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNjgwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTc4MDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweDE4ODAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHgxOTgwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHgxYTgwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWI4MDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweDFjODAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweDFkODAwMDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweDFmODAwMDogMHg0MDEwNDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwLFxuXHQgICAgICAgICAgICAweDEwMDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgyMDAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDMwMDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDAwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHg1MDAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4NjAwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHg3MDAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDgwMDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweGEwMDA6IDB4MjAwMDAwODAsXG5cdCAgICAgICAgICAgIDB4YjAwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHhjMDAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweGQwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhlMDAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxODAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDI4MDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MzgwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDQ4MDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHg2ODAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDc4MDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODgwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHg5ODAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHhiODAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4YzgwMDogMHgyMDAwMDA4MCxcblx0ICAgICAgICAgICAgMHhkODAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweGU4MDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHhmODAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDEwMDAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDExMDAwOiAweDgwLFxuXHQgICAgICAgICAgICAweDEyMDAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDEzMDAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDE0MDAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MTUwMDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTYwMDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTcwMDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxOTAwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDFiMDAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweDFjMDAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDFkMDAwOiAweDIwMDAwMDgwLFxuXHQgICAgICAgICAgICAweDFlMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxMDgwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxMTgwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDEyODAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxNjgwMDogMHg4MCxcblx0ICAgICAgICAgICAgMHgxNzgwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxODgwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHgxOTgwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxYTgwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFiODAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFjODAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MWQ4MDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWY4MDA6IDB4MjAwMDAwODBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDEwMDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweDIwMDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgzMDA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4NDAwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDUwMDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NjAwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHg3MDA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4OTAwOiAweDEwMDAyMDA4LFxuXHQgICAgICAgICAgICAweGEwMDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4YjAwOiAweDgsXG5cdCAgICAgICAgICAgIDB4YzAwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweGQwMDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4ZTAwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4ZjAwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweDgwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDE4MDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgyODA6IDB4OCxcblx0ICAgICAgICAgICAgMHgzODA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDQ4MDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4NTgwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDY4MDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHg3ODA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHg4ODA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDk4MDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweGE4MDogMHgxMDAwMjAwOCxcblx0ICAgICAgICAgICAgMHhiODA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4YzgwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZDgwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweGU4MDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDEwMDA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxMjAwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDEzMDA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHgxNDAwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNTAwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE2MDA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTcwMDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTkwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFhMDA6IDB4OCxcblx0ICAgICAgICAgICAgMHgxYjAwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDFjMDA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwOiAweDEwMDAyMDA4LFxuXHQgICAgICAgICAgICAweDFlMDA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTA4MDogMHg4LFxuXHQgICAgICAgICAgICAweDExODA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweDEyODA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDEzODA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTQ4MDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHgxNTgwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTY4MDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxNzgwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDE4ODA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxYTgwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4MWI4MDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MWM4MDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MWQ4MDogMHgwLFxuXHQgICAgICAgICAgICAweDFlODA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWY4MDogMHgxMDAwMjAwOFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDEwOiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MjA6IDB4NDAwLFxuXHQgICAgICAgICAgICAweDMwOiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHg0MDogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweDUwOiAweDAsXG5cdCAgICAgICAgICAgIDB4NjA6IDB4MSxcblx0ICAgICAgICAgICAgMHg3MDogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDgwOiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4OTA6IDB4MTAwMDAxLFxuXHQgICAgICAgICAgICAweGEwOiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4YjA6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHhjMDogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweGQwOiAweDQwMSxcblx0ICAgICAgICAgICAgMHhlMDogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4ZjA6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4OiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTg6IDB4MCxcblx0ICAgICAgICAgICAgMHgyODogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDM4OiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4NDg6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDU4OiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4Njg6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHg3ODogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4ODg6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDk4OiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4YTg6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHhiODogMHgxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4Yzg6IDB4NDAwLFxuXHQgICAgICAgICAgICAweGQ4OiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4ZTg6IDB4MSxcblx0ICAgICAgICAgICAgMHhmODogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTAwOiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTEwOiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMjA6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgxMzA6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxNDA6IDB4MTAwMDAxLFxuXHQgICAgICAgICAgICAweDE1MDogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweDE2MDogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweDE3MDogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MTgwOiAweDQwMSxcblx0ICAgICAgICAgICAgMHgxOTA6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxYTA6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweDFiMDogMHgxLFxuXHQgICAgICAgICAgICAweDFjMDogMHgwLFxuXHQgICAgICAgICAgICAweDFkMDogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweDFlMDogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweDFmMDogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4MTA4OiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxMTg6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgxMjg6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxMzg6IDB4MSxcblx0ICAgICAgICAgICAgMHgxNDg6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNTg6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDE2ODogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4MTc4OiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTg4OiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTk4OiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWE4OiAweDAsXG5cdCAgICAgICAgICAgIDB4MWI4OiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MWM4OiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxZDg6IDB4NDAwLFxuXHQgICAgICAgICAgICAweDFlODogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweDFmODogMHgxMDAwMDFcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4MTogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHgyOiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzogMHgyMCxcblx0ICAgICAgICAgICAgMHg0OiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDU6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHg2OiAweDgwMjA4MDAsXG5cdCAgICAgICAgICAgIDB4NzogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4ODogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDk6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHhhOiAweDIwODAwLFxuXHQgICAgICAgICAgICAweGI6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHhjOiAweDgyMCxcblx0ICAgICAgICAgICAgMHhkOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweGY6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDA6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAxOiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDI6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMzogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA0OiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDU6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDY6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDc6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDg6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwOTogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGE6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGI6IDB4ODAyMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwYzogMHgwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBkOiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGU6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwZjogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHgxMTogMHg4MDIwODAwLFxuXHQgICAgICAgICAgICAweDEyOiAweDIwLFxuXHQgICAgICAgICAgICAweDEzOiAweDgwMCxcblx0ICAgICAgICAgICAgMHgxNDogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweDE1OiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4MTY6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHgxNzogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHgxODogMHgwLFxuXHQgICAgICAgICAgICAweDE5OiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDFhOiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4MWI6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHgxYzogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDFkOiAweDIwODAwLFxuXHQgICAgICAgICAgICAweDFlOiAweDgyMCxcblx0ICAgICAgICAgICAgMHgxZjogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDEwOiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDExOiAweDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMjogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDEzOiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE0OiAweDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE1OiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTY6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNzogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE4OiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTk6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxYTogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFiOiAweDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWM6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWQ6IDB4ODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFlOiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFmOiAweDgwMjA4MDBcblx0ICAgICAgICB9XG5cdCAgICBdO1xuXG5cdCAgICAvLyBNYXNrcyB0aGF0IHNlbGVjdCB0aGUgU0JPWCBpbnB1dFxuXHQgICAgdmFyIFNCT1hfTUFTSyA9IFtcblx0ICAgICAgICAweGY4MDAwMDAxLCAweDFmODAwMDAwLCAweDAxZjgwMDAwLCAweDAwMWY4MDAwLFxuXHQgICAgICAgIDB4MDAwMWY4MDAsIDB4MDAwMDFmODAsIDB4MDAwMDAxZjgsIDB4ODAwMDAwMWZcblx0ICAgIF07XG5cblx0ICAgIC8qKlxuXHQgICAgICogREVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBERVMgPSBDX2FsZ28uREVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFNlbGVjdCA1NiBiaXRzIGFjY29yZGluZyB0byBQQzFcblx0ICAgICAgICAgICAgdmFyIGtleUJpdHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5Qml0UG9zID0gUEMxW2ldIC0gMTtcblx0ICAgICAgICAgICAgICAgIGtleUJpdHNbaV0gPSAoa2V5V29yZHNba2V5Qml0UG9zID4+PiA1XSA+Pj4gKDMxIC0ga2V5Qml0UG9zICUgMzIpKSAmIDE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBc3NlbWJsZSAxNiBzdWJrZXlzXG5cdCAgICAgICAgICAgIHZhciBzdWJLZXlzID0gdGhpcy5fc3ViS2V5cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBuU3ViS2V5ID0gMDsgblN1YktleSA8IDE2OyBuU3ViS2V5KyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBzdWJrZXlcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJLZXkgPSBzdWJLZXlzW25TdWJLZXldID0gW107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0U2hpZnQgPSBCSVRfU0hJRlRTW25TdWJLZXldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTZWxlY3QgNDggYml0cyBhY2NvcmRpbmcgdG8gUEMyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgbGVmdCAyOCBrZXkgYml0c1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YktleVsoaSAvIDYpIHwgMF0gfD0ga2V5Qml0c1soKFBDMltpXSAtIDEpICsgYml0U2hpZnQpICUgMjhdIDw8ICgzMSAtIGkgJSA2KTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBmcm9tIHRoZSByaWdodCAyOCBrZXkgYml0c1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YktleVs0ICsgKChpIC8gNikgfCAwKV0gfD0ga2V5Qml0c1syOCArICgoKFBDMltpICsgMjRdIC0gMSkgKyBiaXRTaGlmdCkgJSAyOCldIDw8ICgzMSAtIGkgJSA2KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gU2luY2UgZWFjaCBzdWJrZXkgaXMgYXBwbGllZCB0byBhbiBleHBhbmRlZCAzMi1iaXQgaW5wdXQsXG5cdCAgICAgICAgICAgICAgICAvLyB0aGUgc3Via2V5IGNhbiBiZSBicm9rZW4gaW50byA4IHZhbHVlcyBzY2FsZWQgdG8gMzItYml0cyxcblx0ICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFsbG93cyB0aGUga2V5IHRvIGJlIHVzZWQgd2l0aG91dCBleHBhbnNpb25cblx0ICAgICAgICAgICAgICAgIHN1YktleVswXSA9IChzdWJLZXlbMF0gPDwgMSkgfCAoc3ViS2V5WzBdID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IDc7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YktleVtpXSA9IHN1YktleVtpXSA+Pj4gKChpIC0gMSkgKiA0ICsgMyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzdWJLZXlbN10gPSAoc3ViS2V5WzddIDw8IDUpIHwgKHN1YktleVs3XSA+Pj4gMjcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnZlcnNlIHN1YmtleXNcblx0ICAgICAgICAgICAgdmFyIGludlN1YktleXMgPSB0aGlzLl9pbnZTdWJLZXlzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaW52U3ViS2V5c1tpXSA9IHN1YktleXNbMTUgLSBpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fc3ViS2V5cyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZTdWJLZXlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwgc3ViS2V5cykge1xuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXRcblx0ICAgICAgICAgICAgdGhpcy5fbEJsb2NrID0gTVtvZmZzZXRdO1xuXHQgICAgICAgICAgICB0aGlzLl9yQmxvY2sgPSBNW29mZnNldCArIDFdO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgcGVybXV0YXRpb25cblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDQsICAweDBmMGYwZjBmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDIsICAweDMzMzMzMzMzKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsICAweDAwZmYwMGZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDEsICAweDU1NTU1NTU1KTtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAwOyByb3VuZCA8IDE2OyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJLZXkgPSBzdWJLZXlzW3JvdW5kXTtcblx0ICAgICAgICAgICAgICAgIHZhciBsQmxvY2sgPSB0aGlzLl9sQmxvY2s7XG5cdCAgICAgICAgICAgICAgICB2YXIgckJsb2NrID0gdGhpcy5fckJsb2NrO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBGZWlzdGVsIGZ1bmN0aW9uXG5cdCAgICAgICAgICAgICAgICB2YXIgZiA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGYgfD0gU0JPWF9QW2ldWygockJsb2NrIF4gc3ViS2V5W2ldKSAmIFNCT1hfTUFTS1tpXSkgPj4+IDBdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbEJsb2NrID0gckJsb2NrO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fckJsb2NrID0gbEJsb2NrIF4gZjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVuZG8gc3dhcCBmcm9tIGxhc3Qgcm91bmRcblx0ICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sQmxvY2s7XG5cdCAgICAgICAgICAgIHRoaXMuX2xCbG9jayA9IHRoaXMuX3JCbG9jaztcblx0ICAgICAgICAgICAgdGhpcy5fckJsb2NrID0gdDtcblxuXHQgICAgICAgICAgICAvLyBGaW5hbCBwZXJtdXRhdGlvblxuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMSwgIDB4NTU1NTU1NTUpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgOCwgIDB4MDBmZjAwZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgIDB4MzMzMzMzMzMpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMTYsIDB4MDAwMGZmZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgIDB4MGYwZjBmMGYpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdID0gdGhpcy5fbEJsb2NrO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdGhpcy5fckJsb2NrO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiA2NC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzIsXG5cblx0ICAgICAgICBibG9ja1NpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLy8gU3dhcCBiaXRzIGFjcm9zcyB0aGUgbGVmdCBhbmQgcmlnaHQgd29yZHNcblx0ICAgIGZ1bmN0aW9uIGV4Y2hhbmdlTFIob2Zmc2V0LCBtYXNrKSB7XG5cdCAgICAgICAgdmFyIHQgPSAoKHRoaXMuX2xCbG9jayA+Pj4gb2Zmc2V0KSBeIHRoaXMuX3JCbG9jaykgJiBtYXNrO1xuXHQgICAgICAgIHRoaXMuX3JCbG9jayBePSB0O1xuXHQgICAgICAgIHRoaXMuX2xCbG9jayBePSB0IDw8IG9mZnNldDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZXhjaGFuZ2VSTChvZmZzZXQsIG1hc2spIHtcblx0ICAgICAgICB2YXIgdCA9ICgodGhpcy5fckJsb2NrID4+PiBvZmZzZXQpIF4gdGhpcy5fbEJsb2NrKSAmIG1hc2s7XG5cdCAgICAgICAgdGhpcy5fbEJsb2NrIF49IHQ7XG5cdCAgICAgICAgdGhpcy5fckJsb2NrIF49IHQgPDwgb2Zmc2V0O1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkRFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkRFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5ERVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKERFUyk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVHJpcGxlLURFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgVHJpcGxlREVTID0gQ19hbGdvLlRyaXBsZURFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgREVTIGluc3RhbmNlc1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMxID0gREVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDAsIDIpKSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczIgPSBERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoMiwgNCkpKTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMyA9IERFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSg0LCA2KSkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMS5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMi5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMy5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczMuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczEuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDE5Mi8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzIsXG5cblx0ICAgICAgICBibG9ja1NpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5UcmlwbGVERVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5UcmlwbGVERVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihUcmlwbGVERVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlRyaXBsZURFUztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvdHJpcGxlZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3RyaXBsZWRlcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBYMzJXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogeDY0IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIDY0LWJpdCB3b3JkLlxuXHQgICAgICovXG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIDY0LWJpdCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggMzIgYml0cy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgMzIgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHg2NFdvcmQgPSBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhpZ2gsIGxvdykge1xuXHQgICAgICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoO1xuXHQgICAgICAgICAgICB0aGlzLmxvdyA9IGxvdztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIE5PVHMgdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIG5lZ2F0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbmVnYXRlZCA9IHg2NFdvcmQubm90KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gbm90OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gfnRoaXMuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IH50aGlzLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBBTkRzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gQU5EIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIEFORGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGFuZGVkID0geDY0V29yZC5hbmQoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIGFuZDogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggJiB3b3JkLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyAmIHdvcmQubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIE9ScyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIE9SIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIE9SaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3JlZCA9IHg2NFdvcmQub3IoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIG9yOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCB8IHdvcmQuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IHwgd29yZC5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgWE9ScyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIFhPUiB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBYT1JpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB4b3JlZCA9IHg2NFdvcmQueG9yKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyB4b3I6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoIF4gd29yZC5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgXiB3b3JkLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogU2hpZnRzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIGxlZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgc2hpZnRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzaGlmdGVkID0geDY0V29yZC5zaGlmdEwoMjUpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHNoaWZ0TDogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gaWYgKG4gPCAzMikge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSAodGhpcy5oaWdoIDw8IG4pIHwgKHRoaXMubG93ID4+PiAoMzIgLSBuKSk7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgPDwgbjtcblx0ICAgICAgICAgICAgLy8gfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5sb3cgPDwgKG4gLSAzMik7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gMDtcblx0ICAgICAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTaGlmdHMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgc2hpZnRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzaGlmdGVkID0geDY0V29yZC5zaGlmdFIoNyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gc2hpZnRSOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyBpZiAobiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gKHRoaXMubG93ID4+PiBuKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbikpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggPj4+IG47XG5cdCAgICAgICAgICAgIC8vIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5oaWdoID4+PiAobiAtIDMyKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gMDtcblx0ICAgICAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSb3RhdGVzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIGxlZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHJvdGF0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcm90YXRlZCA9IHg2NFdvcmQucm90TCgyNSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gcm90TDogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuc2hpZnRMKG4pLm9yKHRoaXMuc2hpZnRSKDY0IC0gbikpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSb3RhdGVzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIHJpZ2h0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciByb3RhdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHJvdGF0ZWQgPSB4NjRXb3JkLnJvdFIoNyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gcm90UjogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuc2hpZnRSKG4pLm9yKHRoaXMuc2hpZnRMKDY0IC0gbikpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gYWRkIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIGFkZGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGFkZGVkID0geDY0V29yZC5hZGQoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIGFkZDogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9ICh0aGlzLmxvdyArIHdvcmQubG93KSB8IDA7XG5cdCAgICAgICAgICAgIC8vIHZhciBjYXJyeSA9IChsb3cgPj4+IDApIDwgKHRoaXMubG93ID4+PiAwKSA/IDEgOiAwO1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9ICh0aGlzLmhpZ2ggKyB3b3JkLmhpZ2ggKyBjYXJyeSkgfCAwO1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDY0LWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgQ3J5cHRvSlMueDY0LldvcmQgb2JqZWN0cy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgQ3J5cHRvSlMueDY0LldvcmQgb2JqZWN0cy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxuXHQgICAgICAgICAqICAgICBdKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpLFxuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MTgxOTFhMWIsIDB4MWMxZDFlMWYpXG5cdCAgICAgICAgICogICAgIF0sIDEwKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgNjQtYml0IHdvcmQgYXJyYXkgdG8gYSAzMi1iaXQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NyeXB0b0pTLmxpYi5Xb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheSdzIGRhdGEgYXMgYSAzMi1iaXQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHgzMldvcmRBcnJheSA9IHg2NFdvcmRBcnJheS50b1gzMigpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvWDMyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgeDY0V29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgeDY0V29yZHNMZW5ndGggPSB4NjRXb3Jkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgeDMyV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4NjRXb3Jkc0xlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgeDY0V29yZCA9IHg2NFdvcmRzW2ldO1xuXHQgICAgICAgICAgICAgICAgeDMyV29yZHMucHVzaCh4NjRXb3JkLmhpZ2gpO1xuXHQgICAgICAgICAgICAgICAgeDMyV29yZHMucHVzaCh4NjRXb3JkLmxvdyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gWDMyV29yZEFycmF5LmNyZWF0ZSh4MzJXb3JkcywgdGhpcy5zaWdCeXRlcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB4NjRXb3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUgXCJ3b3Jkc1wiIGFycmF5XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBlYWNoIFg2NFdvcmQgb2JqZWN0XG5cdCAgICAgICAgICAgIHZhciB3b3Jkc0xlbmd0aCA9IHdvcmRzLmxlbmd0aDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkc0xlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpXSA9IHdvcmRzW2ldLmNsb25lKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3g2NC1jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3g2NC1jb3JlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohIG5vcm1hbGl6ZS5jc3MgdjcuMC4wIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL2h0bWx7bGluZS1oZWlnaHQ6MS4xNTstbXMtdGV4dC1zaXplLWFkanVzdDoxMDAlOy13ZWJraXQtdGV4dC1zaXplLWFkanVzdDoxMDAlfWJvZHl7bWFyZ2luOjB9YXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLG5hdixzZWN0aW9ue2Rpc3BsYXk6YmxvY2t9aDF7Zm9udC1zaXplOjJlbTttYXJnaW46LjY3ZW0gMH1maWdjYXB0aW9uLGZpZ3VyZSxtYWlue2Rpc3BsYXk6YmxvY2t9ZmlndXJle21hcmdpbjoxZW0gNDBweH1ocntib3gtc2l6aW5nOmNvbnRlbnQtYm94O2hlaWdodDowO292ZXJmbG93OnZpc2libGV9cHJle2ZvbnQtZmFtaWx5Om1vbm9zcGFjZSxtb25vc3BhY2U7Zm9udC1zaXplOjFlbX1he2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7LXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcDpvYmplY3RzfWFiYnJbdGl0bGVde2JvcmRlci1ib3R0b206bm9uZTt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkfWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OmluaGVyaXQ7Zm9udC13ZWlnaHQ6Ym9sZGVyfWNvZGUsa2JkLHNhbXB7Zm9udC1mYW1pbHk6bW9ub3NwYWNlLG1vbm9zcGFjZTtmb250LXNpemU6MWVtfWRmbntmb250LXN0eWxlOml0YWxpY31tYXJre2JhY2tncm91bmQtY29sb3I6I2ZmMDtjb2xvcjojMDAwfXNtYWxse2ZvbnQtc2l6ZTo4MCV9c3ViLHN1cHtmb250LXNpemU6NzUlO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9c3Vie2JvdHRvbTotLjI1ZW19c3Vwe3RvcDotLjVlbX1hdWRpbyx2aWRlb3tkaXNwbGF5OmlubGluZS1ibG9ja31hdWRpbzpub3QoW2NvbnRyb2xzXSl7ZGlzcGxheTpub25lO2hlaWdodDowfWltZ3tib3JkZXItc3R5bGU6bm9uZX1zdmc6bm90KDpyb290KXtvdmVyZmxvdzpoaWRkZW59YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMDAlO2xpbmUtaGVpZ2h0OjEuMTU7bWFyZ2luOjB9YnV0dG9uLGlucHV0e292ZXJmbG93OnZpc2libGV9YnV0dG9uLHNlbGVjdHt0ZXh0LXRyYW5zZm9ybTpub25lfVt0eXBlPXJlc2V0XSxbdHlwZT1zdWJtaXRdLGJ1dHRvbixodG1sIFt0eXBlPWJ1dHRvbl17LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbn1bdHlwZT1idXR0b25dOjotbW96LWZvY3VzLWlubmVyLFt0eXBlPXJlc2V0XTo6LW1vei1mb2N1cy1pbm5lcixbdHlwZT1zdWJtaXRdOjotbW96LWZvY3VzLWlubmVyLGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcntib3JkZXItc3R5bGU6bm9uZTtwYWRkaW5nOjB9W3R5cGU9YnV0dG9uXTotbW96LWZvY3VzcmluZyxbdHlwZT1yZXNldF06LW1vei1mb2N1c3JpbmcsW3R5cGU9c3VibWl0XTotbW96LWZvY3VzcmluZyxidXR0b246LW1vei1mb2N1c3Jpbmd7b3V0bGluZToxcHggZG90dGVkIEJ1dHRvblRleHR9ZmllbGRzZXR7cGFkZGluZzouMzVlbSAuNzVlbSAuNjI1ZW19bGVnZW5ke2JveC1zaXppbmc6Ym9yZGVyLWJveDtjb2xvcjppbmhlcml0O2Rpc3BsYXk6dGFibGU7bWF4LXdpZHRoOjEwMCU7cGFkZGluZzowO3doaXRlLXNwYWNlOm5vcm1hbH1wcm9ncmVzc3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX10ZXh0YXJlYXtvdmVyZmxvdzphdXRvfVt0eXBlPWNoZWNrYm94XSxbdHlwZT1yYWRpb117Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MH1bdHlwZT1udW1iZXJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFt0eXBlPW51bWJlcl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b257aGVpZ2h0OmF1dG99W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6dGV4dGZpZWxkO291dGxpbmUtb2Zmc2V0Oi0ycHh9W3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtY2FuY2VsLWJ1dHRvbixbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfTo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbjtmb250OmluaGVyaXR9ZGV0YWlscyxtZW51e2Rpc3BsYXk6YmxvY2t9c3VtbWFyeXtkaXNwbGF5Omxpc3QtaXRlbX1jYW52YXN7ZGlzcGxheTppbmxpbmUtYmxvY2t9W2hpZGRlbl0sdGVtcGxhdGV7ZGlzcGxheTpub25lfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS9hcHBzL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAZm9udC1mYWNle2ZvbnQtZmFtaWx5Okljb25zO3NyYzp1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvb3Blbi1pY29uaWMuZW90XCIpICsgXCIpO3NyYzp1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvb3Blbi1pY29uaWMuZW90XCIpICsgXCI/I2ljb25pYy1zbSkgZm9ybWF0KFxcXCJlbWJlZGRlZC1vcGVudHlwZVxcXCIpLHVybChcIiArIHJlcXVpcmUoXCIuLi9mb250cy9vcGVuLWljb25pYy53b2ZmXCIpICsgXCIpIGZvcm1hdChcXFwid29mZlxcXCIpLHVybChcIiArIHJlcXVpcmUoXCIuLi9mb250cy9vcGVuLWljb25pYy50dGZcIikgKyBcIikgZm9ybWF0KFxcXCJ0cnVldHlwZVxcXCIpLHVybChcIiArIHJlcXVpcmUoXCIuLi9mb250cy9vcGVuLWljb25pYy5vdGZcIikgKyBcIikgZm9ybWF0KFxcXCJvcGVudHlwZVxcXCIpLHVybChcIiArIHJlcXVpcmUoXCIuLi9mb250cy9vcGVuLWljb25pYy5zdmdcIikgKyBcIiNpY29uaWMtc20pIGZvcm1hdChcXFwic3ZnXFxcIik7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS5vaVtkYXRhLWdseXBoXS5vaS10ZXh0LXJlcGxhY2V7Zm9udC1zaXplOjA7bGluZS1oZWlnaHQ6MH0ub2lbZGF0YS1nbHlwaF0ub2ktdGV4dC1yZXBsYWNlOmJlZm9yZXt3aWR0aDoxZW07dGV4dC1hbGlnbjpjZW50ZXJ9Lm9pW2RhdGEtZ2x5cGhdOmJlZm9yZXtmb250LWZhbWlseTpJY29ucztkaXNwbGF5OmlubGluZS1ibG9jaztzcGVhazpub25lO2xpbmUtaGVpZ2h0OjE7dmVydGljYWwtYWxpZ246YmFzZWxpbmU7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlfS5vaVtkYXRhLWdseXBoXTplbXB0eTpiZWZvcmV7d2lkdGg6MWVtO3RleHQtYWxpZ246Y2VudGVyO2JveC1zaXppbmc6Y29udGVudC1ib3h9Lm9pW2RhdGEtZ2x5cGhdLm9pLWFsaWduLWxlZnQ6YmVmb3Jle3RleHQtYWxpZ246bGVmdH0ub2lbZGF0YS1nbHlwaF0ub2ktYWxpZ24tcmlnaHQ6YmVmb3Jle3RleHQtYWxpZ246cmlnaHR9Lm9pW2RhdGEtZ2x5cGhdLm9pLWFsaWduLWNlbnRlcjpiZWZvcmV7dGV4dC1hbGlnbjpjZW50ZXJ9Lm9pW2RhdGEtZ2x5cGhdLm9pLWZsaXAtaG9yaXpvbnRhbDpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVYKC0xKTstbXMtdHJhbnNmb3JtOnNjYWxlWCgtMSk7dHJhbnNmb3JtOnNjYWxlWCgtMSl9Lm9pW2RhdGEtZ2x5cGhdLm9pLWZsaXAtdmVydGljYWw6YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWSgtMSk7LW1zLXRyYW5zZm9ybTpzY2FsZVgoLTEpO3RyYW5zZm9ybTpzY2FsZVkoLTEpfS5vaVtkYXRhLWdseXBoXS5vaS1mbGlwLWhvcml6b250YWwtdmVydGljYWw6YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC0xKTstbXMtdHJhbnNmb3JtOnNjYWxlWCgtMSk7dHJhbnNmb3JtOnNjYWxlKC0xKX0ub2lbZGF0YS1nbHlwaD1hY2NvdW50LWxvZ2luXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDBcXFwifS5vaVtkYXRhLWdseXBoPWFjY291bnQtbG9nb3V0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDFcXFwifS5vaVtkYXRhLWdseXBoPWFjdGlvbi1yZWRvXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDJcXFwifS5vaVtkYXRhLWdseXBoPWFjdGlvbi11bmRvXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDNcXFwifS5vaVtkYXRhLWdseXBoPWFsaWduLWNlbnRlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDA0XFxcIn0ub2lbZGF0YS1nbHlwaD1hbGlnbi1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDVcXFwifS5vaVtkYXRhLWdseXBoPWFsaWduLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDZcXFwifS5vaVtkYXRhLWdseXBoPWFwZXJ0dXJlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDdcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LWJvdHRvbV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDA4XFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy1jaXJjbGUtYm90dG9tXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDlcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LWNpcmNsZS1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMEFcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LWNpcmNsZS1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDBCXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy1jaXJjbGUtdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMENcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwRFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwRVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctdGhpY2stYm90dG9tXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMEZcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LXRoaWNrLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctdGhpY2stcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctdGhpY2stdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTJcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LXRvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDEzXFxcIn0ub2lbZGF0YS1nbHlwaD1hdWRpby1zcGVjdHJ1bV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDE0XFxcIn0ub2lbZGF0YS1nbHlwaD1hdWRpb106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDE1XFxcIn0ub2lbZGF0YS1nbHlwaD1iYWRnZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDE2XFxcIn0ub2lbZGF0YS1nbHlwaD1iYW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmFyLWNoYXJ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMThcXFwifS5vaVtkYXRhLWdseXBoPWJhc2tldF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDE5XFxcIn0ub2lbZGF0YS1nbHlwaD1iYXR0ZXJ5LWVtcHR5XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMUFcXFwifS5vaVtkYXRhLWdseXBoPWJhdHRlcnktZnVsbF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDFCXFxcIn0ub2lbZGF0YS1nbHlwaD1iZWFrZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmVsbF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDFEXFxcIn0ub2lbZGF0YS1nbHlwaD1ibHVldG9vdGhdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxRVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Ym9sZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDFGXFxcIn0ub2lbZGF0YS1nbHlwaD1ib2x0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjBcXFwifS5vaVtkYXRhLWdseXBoPWJvb2tdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Ym9va21hcmtdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Ym94XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjNcXFwifS5vaVtkYXRhLWdseXBoPWJyaWVmY2FzZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDI0XFxcIn0ub2lbZGF0YS1nbHlwaD1icml0aXNoLXBvdW5kXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjVcXFwifS5vaVtkYXRhLWdseXBoPWJyb3dzZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyNlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YnJ1c2hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YnVnXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjhcXFwifS5vaVtkYXRhLWdseXBoPWJ1bGxob3JuXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjlcXFwifS5vaVtkYXRhLWdseXBoPWNhbGN1bGF0b3JdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FsZW5kYXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FtZXJhLXNscl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDJDXFxcIn0ub2lbZGF0YS1nbHlwaD1jYXJldC1ib3R0b21dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyRFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FyZXQtbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDJFXFxcIn0ub2lbZGF0YS1nbHlwaD1jYXJldC1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDJGXFxcIn0ub2lbZGF0YS1nbHlwaD1jYXJldC10b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FydF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDMxXFxcIn0ub2lbZGF0YS1nbHlwaD1jaGF0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzJcXFwifS5vaVtkYXRhLWdseXBoPWNoZWNrXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzNcXFwifS5vaVtkYXRhLWdseXBoPWNoZXZyb24tYm90dG9tXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzRcXFwifS5vaVtkYXRhLWdseXBoPWNoZXZyb24tbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDM1XFxcIn0ub2lbZGF0YS1nbHlwaD1jaGV2cm9uLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzZcXFwifS5vaVtkYXRhLWdseXBoPWNoZXZyb24tdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzdcXFwifS5vaVtkYXRhLWdseXBoPWNpcmNsZS1jaGVja106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDM4XFxcIn0ub2lbZGF0YS1nbHlwaD1jaXJjbGUteF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDM5XFxcIn0ub2lbZGF0YS1nbHlwaD1jbGlwYm9hcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2xvY2tdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2xvdWQtZG93bmxvYWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2xvdWQtdXBsb2FkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwM0RcXFwifS5vaVtkYXRhLWdseXBoPWNsb3VkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwM0VcXFwifS5vaVtkYXRhLWdseXBoPWNsb3VkeV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDNGXFxcIn0ub2lbZGF0YS1nbHlwaD1jb2RlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDBcXFwifS5vaVtkYXRhLWdseXBoPWNvZ106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQxXFxcIn0ub2lbZGF0YS1nbHlwaD1jb2xsYXBzZS1kb3duXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDJcXFwifS5vaVtkYXRhLWdseXBoPWNvbGxhcHNlLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0M1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29sbGFwc2UtcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0NFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29sbGFwc2UtdXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0NVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29tbWFuZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQ2XFxcIn0ub2lbZGF0YS1nbHlwaD1jb21tZW50LXNxdWFyZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQ3XFxcIn0ub2lbZGF0YS1nbHlwaD1jb21wYXNzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDhcXFwifS5vaVtkYXRhLWdseXBoPWNvbnRyYXN0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDlcXFwifS5vaVtkYXRhLWdseXBoPWNvcHl3cml0aW5nXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNEFcXFwifS5vaVtkYXRhLWdseXBoPWNyZWRpdC1jYXJkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNEJcXFwifS5vaVtkYXRhLWdseXBoPWNyb3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0Q1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZGFzaGJvYXJkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNERcXFwifS5vaVtkYXRhLWdseXBoPWRhdGEtdHJhbnNmZXItZG93bmxvYWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0RVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZGF0YS10cmFuc2Zlci11cGxvYWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0RlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZGVsZXRlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTBcXFwifS5vaVtkYXRhLWdseXBoPWRpYWxdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1MVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZG9jdW1lbnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1MlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZG9sbGFyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTNcXFwifS5vaVtkYXRhLWdseXBoPWRvdWJsZS1xdW90ZS1zYW5zLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1NFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZG91YmxlLXF1b3RlLXNhbnMtcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1NVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZG91YmxlLXF1b3RlLXNlcmlmLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1NlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZG91YmxlLXF1b3RlLXNlcmlmLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTdcXFwifS5vaVtkYXRhLWdseXBoPWRyb3BsZXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1OFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZWplY3RdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1OVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZWxldmF0b3JdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1QVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZWxsaXBzZXNdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1QlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZW52ZWxvcGUtY2xvc2VkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNUNcXFwifS5vaVtkYXRhLWdseXBoPWVudmVsb3BlLW9wZW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1RFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXVyb106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDVFXFxcIn0ub2lbZGF0YS1nbHlwaD1leGNlcnB0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNUZcXFwifS5vaVtkYXRhLWdseXBoPWV4cGFuZC1kb3duXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjBcXFwifS5vaVtkYXRhLWdseXBoPWV4cGFuZC1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjFcXFwifS5vaVtkYXRhLWdseXBoPWV4cGFuZC1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDYyXFxcIn0ub2lbZGF0YS1nbHlwaD1leHBhbmQtdXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2M1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXh0ZXJuYWwtbGlua106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDY0XFxcIn0ub2lbZGF0YS1nbHlwaD1leWVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2NVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXllZHJvcHBlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDY2XFxcIn0ub2lbZGF0YS1nbHlwaD1maWxlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjdcXFwifS5vaVtkYXRhLWdseXBoPWZpcmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2OFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZmxhZ106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDY5XFxcIn0ub2lbZGF0YS1nbHlwaD1mbGFzaF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDZBXFxcIn0ub2lbZGF0YS1nbHlwaD1mb2xkZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2QlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Zm9ya106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDZDXFxcIn0ub2lbZGF0YS1nbHlwaD1mdWxsc2NyZWVuLWVudGVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNkRcXFwifS5vaVtkYXRhLWdseXBoPWZ1bGxzY3JlZW4tZXhpdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDZFXFxcIn0ub2lbZGF0YS1nbHlwaD1nbG9iZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDZGXFxcIn0ub2lbZGF0YS1nbHlwaD1ncmFwaF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDcwXFxcIn0ub2lbZGF0YS1nbHlwaD1ncmlkLWZvdXItdXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3MVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Z3JpZC10aHJlZS11cF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDcyXFxcIn0ub2lbZGF0YS1nbHlwaD1ncmlkLXR3by11cF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDczXFxcIn0ub2lbZGF0YS1nbHlwaD1oYXJkLWRyaXZlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzRcXFwifS5vaVtkYXRhLWdseXBoPWhlYWRlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDc1XFxcIn0ub2lbZGF0YS1nbHlwaD1oZWFkcGhvbmVzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzZcXFwifS5vaVtkYXRhLWdseXBoPWhlYXJ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzdcXFwifS5vaVtkYXRhLWdseXBoPWhvbWVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3OFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9aW1hZ2VdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3OVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9aW5ib3hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3QVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9aW5maW5pdHldOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3QlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9aW5mb106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDdDXFxcIn0ub2lbZGF0YS1nbHlwaD1pdGFsaWNdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3RFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9anVzdGlmeS1jZW50ZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3RVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9anVzdGlmeS1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwN0ZcXFwifS5vaVtkYXRhLWdseXBoPWp1c3RpZnktcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4MFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9a2V5XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODFcXFwifS5vaVtkYXRhLWdseXBoPWxhcHRvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDgyXFxcIn0ub2lbZGF0YS1nbHlwaD1sYXllcnNdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4M1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9bGlnaHRidWxiXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODRcXFwifS5vaVtkYXRhLWdseXBoPWxpbmstYnJva2VuXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODVcXFwifS5vaVtkYXRhLWdseXBoPWxpbmstaW50YWN0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODZcXFwifS5vaVtkYXRhLWdseXBoPWxpc3QtcmljaF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDg3XFxcIn0ub2lbZGF0YS1nbHlwaD1saXN0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODhcXFwifS5vaVtkYXRhLWdseXBoPWxvY2F0aW9uXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODlcXFwifS5vaVtkYXRhLWdseXBoPWxvY2stbG9ja2VkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOEFcXFwifS5vaVtkYXRhLWdseXBoPWxvY2stdW5sb2NrZWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4QlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bG9vcC1jaXJjdWxhcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDhDXFxcIn0ub2lbZGF0YS1nbHlwaD1sb29wLXNxdWFyZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDhEXFxcIn0ub2lbZGF0YS1nbHlwaD1sb29wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOEVcXFwifS5vaVtkYXRhLWdseXBoPW1hZ25pZnlpbmctZ2xhc3NdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4RlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWFwLW1hcmtlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDkwXFxcIn0ub2lbZGF0YS1nbHlwaD1tYXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5MVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtcGF1c2VdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5MlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtcGxheV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDkzXFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1yZWNvcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5NFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtc2tpcC1iYWNrd2FyZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDk1XFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1za2lwLWZvcndhcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5NlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtc3RlcC1iYWNrd2FyZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDk3XFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1zdGVwLWZvcndhcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5OFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtc3RvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDk5XFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpY2FsLWNyb3NzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOUFcXFwifS5vaVtkYXRhLWdseXBoPW1lbnVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5QlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWljcm9waG9uZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDlDXFxcIn0ub2lbZGF0YS1nbHlwaD1taW51c106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDlEXFxcIn0ub2lbZGF0YS1nbHlwaD1tb25pdG9yXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOUVcXFwifS5vaVtkYXRhLWdseXBoPW1vb25dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5RlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bW92ZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEEwXFxcIn0ub2lbZGF0YS1nbHlwaD1tdXNpY2FsLW5vdGVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGFwZXJjbGlwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTJcXFwifS5vaVtkYXRhLWdseXBoPXBlbmNpbF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEEzXFxcIn0ub2lbZGF0YS1nbHlwaD1wZW9wbGVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBNFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGVyc29uXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTVcXFwifS5vaVtkYXRhLWdseXBoPXBob25lXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTZcXFwifS5vaVtkYXRhLWdseXBoPXBpZS1jaGFydF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEE3XFxcIn0ub2lbZGF0YS1nbHlwaD1waW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGxheS1jaXJjbGVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGx1c106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEFBXFxcIn0ub2lbZGF0YS1nbHlwaD1wb3dlci1zdGFuZGJ5XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQUJcXFwifS5vaVtkYXRhLWdseXBoPXByaW50XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQUNcXFwifS5vaVtkYXRhLWdseXBoPXByb2plY3RdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBRFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cHVsc2VdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBRVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cHV6emxlLXBpZWNlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQUZcXFwifS5vaVtkYXRhLWdseXBoPXF1ZXN0aW9uLW1hcmtdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cmFpbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEIxXFxcIn0ub2lbZGF0YS1nbHlwaD1yYW5kb21dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cmVsb2FkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjNcXFwifS5vaVtkYXRhLWdseXBoPXJlc2l6ZS1ib3RoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjRcXFwifS5vaVtkYXRhLWdseXBoPXJlc2l6ZS1oZWlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCNVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cmVzaXplLXdpZHRoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjZcXFwifS5vaVtkYXRhLWdseXBoPXJzcy1hbHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9cnNzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjhcXFwifS5vaVtkYXRhLWdseXBoPXNjcmlwdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEI5XFxcIn0ub2lbZGF0YS1nbHlwaD1zaGFyZS1ib3hlZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEJBXFxcIn0ub2lbZGF0YS1nbHlwaD1zaGFyZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEJCXFxcIn0ub2lbZGF0YS1nbHlwaD1zaGllbGRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9c2lnbmFsXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQkRcXFwifS5vaVtkYXRhLWdseXBoPXNpZ25wb3N0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQkVcXFwifS5vaVtkYXRhLWdseXBoPXNvcnQtYXNjZW5kaW5nXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQkZcXFwifS5vaVtkYXRhLWdseXBoPXNvcnQtZGVzY2VuZGluZ106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEMwXFxcIn0ub2lbZGF0YS1nbHlwaD1zcHJlYWRzaGVldF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEMxXFxcIn0ub2lbZGF0YS1nbHlwaD1zdGFyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzJcXFwifS5vaVtkYXRhLWdseXBoPXN1bl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEMzXFxcIn0ub2lbZGF0YS1nbHlwaD10YWJsZXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDNFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGFnXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzVcXFwifS5vaVtkYXRhLWdseXBoPXRhZ3NdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDNlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGFyZ2V0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzdcXFwifS5vaVtkYXRhLWdseXBoPXRhc2tdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGVybWluYWxdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGV4dF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMENBXFxcIn0ub2lbZGF0YS1nbHlwaD10aHVtYi1kb3duXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQ0JcXFwifS5vaVtkYXRhLWdseXBoPXRodW1iLXVwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQ0NcXFwifS5vaVtkYXRhLWdseXBoPXRpbWVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQ0RcXFwifS5vaVtkYXRhLWdseXBoPXRyYW5zZmVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQ0VcXFwifS5vaVtkYXRhLWdseXBoPXRyYXNoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQ0ZcXFwifS5vaVtkYXRhLWdseXBoPXVuZGVybGluZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQwXFxcIn0ub2lbZGF0YS1nbHlwaD12ZXJ0aWNhbC1hbGlnbi1ib3R0b21dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dmVydGljYWwtYWxpZ24tY2VudGVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDJcXFwifS5vaVtkYXRhLWdseXBoPXZlcnRpY2FsLWFsaWduLXRvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQzXFxcIn0ub2lbZGF0YS1nbHlwaD12aWRlb106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQ0XFxcIn0ub2lbZGF0YS1nbHlwaD12b2x1bWUtaGlnaF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQ1XFxcIn0ub2lbZGF0YS1nbHlwaD12b2x1bWUtbG93XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDZcXFwifS5vaVtkYXRhLWdseXBoPXZvbHVtZS1vZmZdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9d2FybmluZ106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQ4XFxcIn0ub2lbZGF0YS1nbHlwaD13aWZpXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDlcXFwifS5vaVtkYXRhLWdseXBoPXdyZW5jaF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMERBXFxcIn0ub2lbZGF0YS1nbHlwaD14XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwREJcXFwifS5vaVtkYXRhLWdseXBoPXllbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMERDXFxcIn0ub2lbZGF0YS1nbHlwaD16b29tLWluXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRERcXFwifS5vaVtkYXRhLWdseXBoPXpvb20tb3V0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwREVcXFwifVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2Nzcy9vcGVuLWljb25pYy5taW4uY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9jc3Mvb3Blbi1pY29uaWMubWluLmNzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBjYW5Vc2VET00gPSBleHBvcnRzLmNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUuYWRkRXZlbnRMaXN0ZW5lciA/IG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIGdldENvbmZpcm1hdGlvbiA9IGV4cG9ydHMuZ2V0Q29uZmlybWF0aW9uID0gZnVuY3Rpb24gZ2V0Q29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cbnZhciBzdXBwb3J0c0hpc3RvcnkgPSBleHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG52YXIgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSA9IGV4cG9ydHMuc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cbnZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGV4cG9ydHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBmdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvcHN0YXRlIGV2ZW50IGlzIGFuIGV4dHJhbmVvdXMgV2ViS2l0IGV2ZW50LlxuICogQWNjb3VudHMgZm9yIHRoZSBmYWN0IHRoYXQgQ2hyb21lIG9uIGlPUyBmaXJlcyByZWFsIHBvcHN0YXRlIGV2ZW50c1xuICogY29udGFpbmluZyB1bmRlZmluZWQgc3RhdGUgd2hlbiBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uXG4gKi9cbnZhciBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZXhwb3J0cy5pc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvRE9NVXRpbHMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVzb2x2ZVBhdGhuYW1lID0gcmVxdWlyZSgncmVzb2x2ZS1wYXRobmFtZScpO1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXNvbHZlUGF0aG5hbWUpO1xuXG52YXIgX3ZhbHVlRXF1YWwgPSByZXF1aXJlKCd2YWx1ZS1lcXVhbCcpO1xuXG52YXIgX3ZhbHVlRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsdWVFcXVhbCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICgwLCBfcmVzb2x2ZVBhdGhuYW1lMi5kZWZhdWx0KShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufTtcblxudmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiAoMCwgX3ZhbHVlRXF1YWwyLmRlZmF1bHQpKGEuc3RhdGUsIGIuc3RhdGUpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBhZGRMZWFkaW5nU2xhc2ggPSBleHBvcnRzLmFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG52YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbnZhciBoYXNCYXNlbmFtZSA9IGV4cG9ydHMuaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBleHBvcnRzLnN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbnZhciBzdHJpcFRyYWlsaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG52YXIgcGFyc2VQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBjcmVhdGVQYXRoID0gZXhwb3J0cy5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuVXNlSGlzdG9yeSA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KSgpO1xuICB2YXIgbmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIgPSAhKDAsIF9ET01VdGlscy5zdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKSgpO1xuXG4gIHZhciBfcHJvcHMkZm9yY2VSZWZyZXNoID0gcHJvcHMuZm9yY2VSZWZyZXNoLFxuICAgICAgZm9yY2VSZWZyZXNoID0gX3Byb3BzJGZvcmNlUmVmcmVzaCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcHJvcHMkZm9yY2VSZWZyZXNoLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyAoMCwgX1BhdGhVdGlscy5zdHJpcFRyYWlsaW5nU2xhc2gpKCgwLCBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCkocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHZhciBfcmVmID0gaGlzdG9yeVN0YXRlIHx8IHt9LFxuICAgICAgICBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG5cblxuICAgIHZhciBwYXRoID0gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKCgwLCBfRE9NVXRpbHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCkoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcblxuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxLZXlzW3ByZXZJbmRleF0gPSBsb2NhdGlvbi5rZXk7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArICgwLCBfUGF0aFV0aWxzLnN0cmlwTGVhZGluZ1NsYXNoKShwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoX0RPTVV0aWxzLmNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKSgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gX0RPTVV0aWxzLmdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IHByb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyAoMCwgX1BhdGhVdGlscy5zdHJpcFRyYWlsaW5nU2xhc2gpKCgwLCBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCkocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCFiYXNlbmFtZSB8fCAoMCwgX1BhdGhVdGlscy5oYXNCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiAoMCwgX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWwpKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkodG9Mb2NhdGlvbikpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFsoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShpbml0aWFsTG9jYXRpb24pXTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGhpc3RvcnkubG9jYXRpb24pKTtcblxuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJyk7XG5cbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIYXNoSGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBwcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB1bmRlZmluZWQgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBwcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoZW50cnksIHVuZGVmaW5lZCwgZW50cnkua2V5IHx8IGNyZWF0ZUtleSgpKTtcbiAgfSk7XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gX1BhdGhVdGlscy5jcmVhdGVQYXRoO1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcblxuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIGhpc3RvcnkuZW50cmllc1toaXN0b3J5LmluZGV4XSA9IGxvY2F0aW9uO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChoaXN0b3J5LmluZGV4ICsgbiwgMCwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aCAtIDEpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgIHZhciBsb2NhdGlvbiA9IGhpc3RvcnkuZW50cmllc1tuZXh0SW5kZXhdO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChvaykge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNaW1pYyB0aGUgYmVoYXZpb3Igb2YgRE9NIGhpc3RvcmllcyBieVxuICAgICAgICAvLyBjYXVzaW5nIGEgcmVuZGVyIGFmdGVyIGEgY2FuY2VsbGVkIFBPUC5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGNhbkdvID0gZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBoaXN0b3J5LmluZGV4ICsgbjtcbiAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgJiYgbmV4dEluZGV4IDwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBlbnRyaWVzLmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBlbnRyaWVzW2luZGV4XSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgZW50cmllczogZW50cmllcyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY2FuR286IGNhbkdvLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlTWVtb3J5SGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICB2YXIgc2V0UHJvbXB0ID0gZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKTtcblxuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpO1xuXG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgdmFyIGFwcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9ub3JtYWxpemUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL25vcm1hbGl6ZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL25vcm1hbGl6ZS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL29wZW4taWNvbmljLm1pbi5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vb3Blbi1pY29uaWMubWluLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vb3Blbi1pY29uaWMubWluLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2Nzcy9vcGVuLWljb25pYy5taW4uY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0O2Jhc2U2NCxKRzRBQUh4dEFBQUJBQUlBQUFBQUFBSUFCUU1BQUFBQUFBQUJBSkFCQUFBQUFFeFFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUdZd0xLd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQW9BU1FCakFHOEFiZ0J6QUFBQURBQnBBR01BYndCdUFHa0FZd0FBQUJ3QVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXhBQzRBTVFBZ0FBQUFFZ0JWQUc0QWRBQnBBSFFBYkFCbEFHUUFNUUFBQUFBQUFBRUFBQUFQQUlBQUF3QndSa1pVVFd2d0FhUUFBQUQ4QUFBQUhFOVRMekkwQmxGaUFBQUJHQUFBQUdCamJXRndBQS9raVFBQUFYZ0FBQUZDWTNaMElBQUFBQUFBQUdHSUFBQUFDbVp3WjIyK2IrWTVBQUJobEFBQUMyeG5ZWE53QUFBQUVBQUFZWUFBQUFBSVoyeDVaa2psN3E0QUFBSzhBQUJTR0dobFlXUUI4N3RGQUFCVTFBQUFBRFpvYUdWaEJvd0VBUUFBVlF3QUFBQWthRzEwZUpxZUFCb0FBRlV3QUFBRGhteHZZMkdqdW85RUFBQll1QUFBQWNadFlYaHdBWndMMWdBQVdvQUFBQUFnYm1GdFpZNzJFTVVBQUZxZ0FBQUNmSEJ2YzNUdEVEUCtBQUJkSEFBQUJHTndjbVZ3M1dzRGhRQUFiUUFBQUFCN0FBQUFBUUFBQUFETVBhTFBBQUFBQU0vWkwyb0FBQUFBejlrdmFnQUVBdjRCa0FBRkFBQUNDQUl3QUFBQWNBSUlBakFBQUFHQUFDY0F6d0FBQWdBRkF3QUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUJRWmtWa0FNRGdBT0RlQXlBQUFBQklBeUFBWlFBQUFBRUFBQUFBQUFBQUFBQUFBQ0FBQVFBQUFBTUFBQUFEQUFBQUhBQUJBQUFBQUFBOEFBTUFBUUFBQUJ3QUJBQWdBQUFBQkFBRUFBRUFBT0RlLy84QUFPQUEvLzhnQXdBQkFBQUFBQUFBQVFZQUFBRUFBQUFBQUFBQUFRSUFBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FCb0FBQURzQWhVQUF3QUhBQWkxQmdRQkFBSXRLek1STXhFbk14RWpHdEs0bnA0Q0ZmM3JHZ0hoQUFJQUFBQUFBeUFDdkFBSEFBNEFDTFVLQ0FJQUFpMHJBU0VSSVRVaEVTRWZBUWMxSVRVaEFTd0I5UDRNQVpEK2NHVEl5UDV3QVpBQ3ZQMUVaQUgwWkphV1pHUUFBZ0FBQUFBRElBSzhBQWNBRGdBSXRRMElBZ0FDTFNzQklSRWhOU0VSSVFjVklSVWhGU2NCTEFIMC9nd0JrUDV3WkFHUS9uRElBcno5UkdRQjlHUmtaR1NXQUFBQkFBQUFaQU1nQXJ3QUR3QUdzd1lBQVMwckVpQVdIUUV6Qnljek5UUW1JZ1lWTk0wQklzMWt5TWhra3RDU0Fyek5rVExJeURKb2twSm9rUUFCQUFBQVpBTWdBcndBRHdBR3N3c0FBUzByQUNBV0ZUUW1JZ1lkQVRNSEp6TTFOQUV4QVNMTmt0Q1NaTWpJWkFLOHpaRm9rcEpvTXNqSU1wRUFBQUFBQkFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRFVBS0Rnd0tDQVlFQWdBRUxTc1JJUlVoRnlFVklRY2hGU0VYSVJVaEF5RDg0R1FDV1Ayb1pBTWcvT0JrQWxqOXFBSzhaR1JrWkdSa1pBQUFBQUFFQUFBQUFBTWdBcndBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt4RWhGU0VWSVJVaEZTRVZJUlVoRlNFRElQemdBbGo5cUFNZy9PQUNXUDJvQXJ4a1pHUmtaR1JrQUFBQUJBQUFBQUFESUFLOEFBTUFCd0FMQUE4QURVQUtEZ3dLQ0FZRUFnQUVMU3NSSVJVaEZ5RVZJUWNoRlNFWElSVWhBeUQ4NE1nQ1dQMm95QU1nL09ESUFsajlxQUs4WkdSa1pHUmtaQUFBQUFBRkFBRC9ud01nQXJ3QUJRQUxBQkVBRmdBYkFBOUFEQnNYRXhJUURBZ0dBd0FGTFNzQk1oY0hKVFlIRndVbU5UUWxGaFVVQnlNbEV5NEJKd1VoRGdFSEFaQnNZa3Yrdmx5d3YvN0tCZ0t3Y0JEYS9xSndYcGNxQVVzQmRER2pZZ0s4TytIcU1uQ0szaVFrcUd0MW5pUkFOZjZsRVhkV0hGTnBDUUFBQVFBQUFBQUI5QU1nQUFZQUJyTUVBQUV0S3hNekVUTUxBVFBJWk1qMy9jZ0RJUDRNL3RRQkxBQUFBQUFDQUFBQUFBTWdBeUFBQndBT0FBaTFDd2dFQUFJdEt4SWdGaEFHSUNZUUpSRWpDUUVqRWVvQlRPcnEvclRxQVN6SUFTd0JMTWdESU9yK3RPcnFBVXlHL3RUKzFBRXNBU3dBQUFBQUFnQUFBQUFESUFNZ0FBY0FEZ0FJdFFvSUJBQUNMU3NTSUJZUUJpQW1FQ1VKQVRVaE5TSHFBVXpxNnY2MDZnR1EvdFFCTEFFcy90UURJT3IrdE9ycUFVeUcvdFQrMU1qSUFBQUFBQUlBQUFBQUF5QURJQUFIQUE0QUNMVU5DQVFBQWkwckVpQVdFQVlnSmhBbEZTRVZJUlVCNmdGTTZ1cit0T29Ca1A3VUFTd0JMQU1nNnY2MDZ1b0JUSWJJeU1nQkxBQUFBQUlBQUFBQUF5QURJQUFIQUE0QUNMVUxDQVFBQWkwckVpQVdFQVlnSmhBbEFUTVJNeEV6NmdGTTZ1cit0T29Ca1A3VXlNaklBeURxL3JUcTZnRk1odjdVL3RRQkxBQUFBQUVBQUFCa0F5QUNXQUFHQUFhekJRQUJMU3NCRlNFVklSVWxBU3dCOVA0TS90UUNXTWhreVBjQUFBQUFBUUFBQUdRRElBSllBQVlBQnJNQ0FBRXRLd0VOQVRVaE5TRUI5QUVzL3RUK0RBSDBBbGozL2Noa0FBQUJBQUFBQUFKWUF5QUFCZ0FHc3dRQUFTMHJFek1STXdrQk04akl5UDdYL3RISUF5RCtEUDdVQVN3QUFBRUFBQUJrQXlBQ3ZBQUdBQWF6QlFBQkxTc0JGU0VWSVJVQkFTd0I5UDRNL3RRQ3ZNakl5QUVwQUFBQUFRQUFBR1FESUFLOEFBWUFCck1DQUFFdEt3a0NOU0UxSVFIMEFTeisxUDRNQWZRQ3ZQN1gvdEhJeUFBQkFBQUFBQUpZQXlBQUJnQUdzd01BQVMwckNRRWpFU01SSXdFcEFTL0l5TWdESVA3VS9nd0I5QUFBQUFFQUFBQUFBZlFESUFBR0FBYXpBd0FCTFNzYkFTTVJJeEVqOS8zSVpNZ0RJUDdVL2d3QjlBQUVBQUFBQUFLOEF5QUFBd0FIQUFzQUR3QU5RQW9PREFvSUJnUUNBQVF0S3dFekVTTURNeEVqQVRNUkl3RXpGU01Ca0dSa3lHUmtBWkJrWlAyb1pHUURJUHpnQXJ6OXFBSDAvbkFCTE1nQUFBUUFBQUFpQXlBQ1dBQUtBQlVBSHdBcEFBMUFDaVFnSEJZUUN3WUFCQzByRXhjR0ZSUVhCeTRCTlRRbEZoVVVCZ2NuTmpVMEp3VVhCaFVVRndjbU5UUWxGaFVVQnljMk5UUW5kRWhZV0VnM1BRS3NkRDAzU0ZoWS9wOUZIQnhGT3dGVk96dEZIQndDV0VoWWVYMVlTRGVVVXFWMGRLVlNsRGRJV0gxNVdFUklIQ2tzSEVnN1ZWSTZPMUZWTzBnY0xDa2NBQUFDQUFBQUFBR1FBeUFBQndBUEFBaTFEUWdFQUFJdEt4SXlGaFFHSWlZMEV4WXpNamNSSndkMnBIWjJwSFprTmk0dE4yUmtBeUIycEhaMnBQNlZFeFArd1dSa0FBTUFBQUFBQXlBRElBQUhBQThBRndBS3R4SVFEUWdFQUFNdEt4SWdGaEFHSUNZUUpTSUdGUlFYQVNZWEFSWXpNalkxTk9zQlN1dnIvcmJyQVpCOHNEZ0JvMDZUL2wxT1lYeXdBeURyL3JicjZ3RktoN0I4WVU0Qm96aDkvbDA0c0h4aEFBQURBQUFBQUFNZ0Fyd0FCUUFKQUEwQUNyY01DZ2dHQkFBRExTc1JNeEVoRlNFQk14RWpBVE1SSTJRQ3ZQemdBZlRJeVA3VXlNZ0N2UDJvWkFLOC9nd0JMUDdVQUFRQUFBQUFBeUFESUFBWEFCb0FKZ0F5QUExQUNpMG5JUnNaR0F3QkJDMHJBVFlYSGdJWE14VWpFUlFHSXlFaUpqVVJJelV6RXpZWEJ5RUVJZ1lkQVJRV01qWTlBVFFrSWdZZEFSUVdNalk5QVRRQmpSRVJBV3g0RElCa0ZBNzk3QTRVWklEcURoaVFBU0QrN3lvZEhTb2RBUThxSFIwcUhRTWdBUTRCZ1k0UFpQNlNEaFFVRGdGdVpBRVpFWDZzeUIwVlpCVWRIUlZrRlIwZEZXUVZIUjBWWkJVQUFnQUFBR1FESUFLOEFBOEFFd0FJdFJFUUNRQUNMU3NUSVRJZEFUTVZJeFVVSXlFaU5SRTBGeEVoRVFrQ3FnbGtaQW45Vmdsa0FmUUN2QXEreUw4SkNRSkdDV1QrY0FHUUFBQUFBQUVBQUFCa0F5QUN2QUFQQUFhekNRQUJMU3NUSVRJZEFUTVZJeFVVSXlFaU5SRTBDUUtxQ1dSa0NmMVdDUUs4Q3I3SXZ3a0pBa1lKQUFBQUFBSUFBUCtjQXlBQ3ZBQW1BQzhBQ0xVc0p4WUNBaTByRXpRMk93TWhNaFlVQmlzQkZSSVhGaFVVQnlNR0l5RWlKalUwTnpZVE5TTWlCaU1pSmdVakZRY0dCeUV2QVZ3YUV3TUZCUUgwRlIwZEZUS09HQ0lwQXlzNS9nQStVaUlZampJQkJnRVZIUUdZeUFZL09BSENkd1lDaWhJZ0hTb2RqZjd6S0RjelBpa3BVajR6TnlnQkRZMEJIaDJpQ250cDVBb0FBQUFDQUFBQUFBTWdBeUFBRFFBVEFBaTFFUTRIQUFJdEt3QXlGaFVVRnhZVklUUTNOalUwRXpNVUJpSW1BVDZrZG9aQy9PQkNobVRJTzFJN0F5QjJVcHR2TjA5UE4yK2JVdjI2S1RzN0FBQUFBQU1BQUFBQUFpWURJQUFOQUJBQUV3QUt0eElSRHc0RkFBTXRLeE16QlFjWEJTTTFCeWMzSnpjWE54VTNCeFUzbGpJQlh1SGgvcUl5UzB1V2xrdExaSmFXbGdNZytwT1ordnBMUzVhV1MwdGt5R1RJeUdRQUFBQURBQUFBQUFNZ0F5QUFGUUFkQUNVQUNyY2ZIaGNXQ3dBRExTc1JJVElXRlJRSEhnRVZGQVlqSVRVeU5qVVJOQ1lqSVJVek1qWTBKaU1ERVRNeU5qUW1Jd0gwVW5Zc1FVK1NhUDNhS1RzN0tRRXNaQ2s3T3lsa2xqNVlXRDRESUhaU1JqY2ZlRXBva21RN0tRR1FLVHZJTzFJNy90VCsxRmg4V0FBQUFRQUFBQUFCOUFNZ0FBVUFCck1EQUFFdEt3RVJNd0VSSXdFc3lQN1V5QU1nL3RUK0RBRXNBQUVBQUFBQUFyd0RJQUFiQUFhekVnQUJMU3NUSVJFM0Z4RXpNaFlWRVNFaUJoUVdNeUVWSVNJbU5SRTNQZ0UzWkFFc1pHUXlGUjM5MmhVZEhSVUNKdjNhUGxnREJpc2RBeUQrMUdSa0FTd2RGZjNhSFNvZFpGZytBaVlUSFNzR0FBRUFBQUFBQVpBRElBQUVBQWF6QWdBQkxTc1JJUkVuQndHUXlNZ0RJUHpneU1nQUFBSUFBQUFBQXlBRElBQURBQThBQ0xVTEJBSUFBaTByRVNFVklSVWhGVE0xSVJFVUl5RWlOUU1nL09BQkxNc0JLUW44OGdrRElHUmtaMmY5c1FrSkFBQURBQUFBQUFNZ0F5QUFGd0FiQUNjQUNyY2pIQmtZQ3dBRExTc0JNeklXSFFFek1oMEJGQVlqSVNJbVBRRTBPd0UxTkRZWEZUTTFBUll6SVRJM0ZSUWpJU0kxQVN6SUtUdS9DUjBWL1VRVkhRbS9PeW5JL2d3WUdnSzhHaGdKL1BJSkF5QTdLV1FKOFJVZEhSWHhDV1FwTzJSa1pQNFZDUW5JQ1FrQUFRQUFBQUFDV0FNZ0FDUUFCck1WQUFFdEt3RXlGaFVqTkNZaklnY0dGUlFXRnpNVkl3WUhJUlVoTlRjMk55TTFNeTRDTlRRM05nRXNYbXBrTWpJdkdSd1pBNnl5RjFvQjYvMm9FRmNUZW4wQ0R3Z3lOd01nYWw0eU1oOGpPeHgzSEdSaFoyUjZERmRQWkExSFBCOWVQa1VBQUFBRUFBRC9uQU1nQXJ3QUZBQWNBQ2dBTEFBTlFBb3FLU0VkR1JVTEFBUXRLeE03QXlFeUZoVVJGQVlqSVNJbU5SRTFORFlXSWdZVUZqSTJORGNpQmhRV015RXlOalFtSXdVUklSRWlCQU1FQlFLOEZSMGRGZjFFRlIwVWx5b2RIU29kbGhVZEhSVUJMQlVkSFJYOTJnSllBcndkRmYxRUZSMGRGUUs4QWc4ZFlCMHFIUjBxSFIwcUhSMHFIY2orY0FHUUFBQUFBZ0FBQUFBREdnTWRBQTBBR3dBSXRSTU9Cd0FDTFNzQkh3RVdCd0VQQVM0Qkp6OEJDUUV5RmhVVUJpTWlKejRCTlRRMkF1Z0dMQVVGL3ZZUEdSRlBOZ3dOQVhmK0tEaE9uRzVLUEQxSlRRTWRBeXdGQi82SkRRdzJUeEVaRHdFSy9uWk9PRzZjSWlOOFNUaE9BQUFBQUFFQUFQKzdBczRDdkFCbkFBYXpNZ3NCTFNzVE5EWXpNaDhCTnk0QlBnRXlIZ0VHQnhjM05qTXlGaFVVQmc4QkZoY3pNaFlVQmlzQkZBY1hIZ0VWRkFZaklpOEJCZ2NtUFFjMEppTWlCZ2NXRkFjZEF4UUhKaWNIQmlNaUpqVTBOajhCSmpVckFTSW1OVFEyT3dJMk55Y3VBUWtiRXc0TWd4MGNCaVJKVmtra0JSd2Nnd3NLRlIwUUMzTVVCVVFWSFIwVk1nWk9EeFlkRlJBUFFTVkNQQjBWRWh3RUFRRTdReVJDRHhBVkhSWVBUZ1l5QlJVZEhSVUZSUVVVZEF3UUFjTVNJQWRDRmgxWVRUZzNUVmdlRmtJSEhSVU5HZ1k0SXc4ZEtoMGlJQ2dFSFJBVkhRc2pTQ1loSjRjRUJRWUZCVmNWSFJjUkF4QURVZ1FGa0NnZ0tVVWpDeDBWRUIwRUtDQWlIUlVVSGc4ak9BVWFBQUlBQUFBQ0Fyd0N2QUFIQUJ3QUNMVVNDUVVBQWkwckFUTXlGUkVVS3dFQkpSRW5GU0lIRnhZT0FTWW5BeU1pUFFFME93RUNXRnNKQ1Z2K2VnRWkraGNGU3dnT0ppb0laMXNKQ2JZQ3ZBbjl1Z2tCazVQK0RIMERGcklUS2hBT0V3RVFDYllKQUFBQUJ3QUFBQUFDdkFNZ0FBc0FEd0FUQUJjQUd3QWZBQ01BRTBBUUlTQWRIQmtZRlJRUkVBME1CUUFITFNzVElUSVZFUlFqSVNJMUVUUVhGU0UxQVJVek5UTVZNelV6RVRNUkJSVXpOVE1WTXpVSkFxb0pDZjFXQ1dRQjlQNE1aR1JrWkdUK0RHUmtaQU1nQ2Z6eUNRa0REZ2xreU1qKzFHUmtaR1QrMUFFc3lHUmtaR1FBQndBQUFBQUN2QU1nQUFNQUN3QVBBQk1BRndBYkFCOEFFMEFRSFJ3WkdCVVVFUkFOREFjRUFnQUhMU3NSSVJVaEZTRVJGQ01oSWpVVEZUTTFNeFV6TlRNVk16VUZGVE0xTXhVek5RSzgvVVFDdkFuOVZnbGtaR1JrWkdUK0RHUmtaQU1neUdUK0ZRa0pBWWRrWkdSa1pHVElaR1JrWkFBQUJBQUFBQUFESUFNZ0FCZ0FJQUFvQURBQURVQUtMU2tsSVIwWkN3QUVMU3NCTXpJZkFSWTdBVElWRVJRaklTSTFFVFEyT3dFeVB3RTJBaUlHRkJZeU5qUWtJZ1lVRmpJMk5DWXlGaFFHSWlZMEFabTJDQVJlQkFoU0NRbjg4Z2xZUG8wSUJGNEU1aW9kSFNvZEFYNmtkbmFrZHZGU096dFNPd01nQ2JZSkNmMjZDUWtCdVQ1WUNiWUovdFFkS2gwZEtoMTJwSFoycEJJN1VqczdVZ0FBQUFFQUFBRElBeUFDV0FBQ0FBYXpBZ0FCTFNzUklRRURJUDV3QWxqK2NBQUFBUUFBQUFBQmtBTWdBQUlBQnJNQkFBRXRLd0VSQVFHUS9uQURJUHpnQVpBQUFBQUFBUUFBQUFBQmtBTWdBQUlBQnJNQ0FBRXRLeEVKQVFHUS9uQURJUDV3L25BQUFBQUFBUUFBQU1nRElBSllBQUlBQnJNQkFBRXRLd2tCSVFHUUFaRDg0QUpZL25BQUFBQUFBd0FBQUFBREh3SllBQ0VBS1FBeEFBcTNMaW9tSWhJQ0F5MHJFVFEyT3dReUZoOEJJVElXRHdFT0FTTWhJaVluTGdFdkFTTWlCaU1pSmdBeUZoUUdJaVkwSkRJV0ZBWWlKalFiRXdNRkJNZ05HZ1VtQWJ3S0NBTlJBeFVML3FJS0ZRTU9OZzBLbGdFRkFSVWVBVkVxSFIwcUhRRkpLaDBkS2gwQ0poSWdFUXRJRHdyNkNnOFBDaW1vS1JrQkh2NVRIU29kSFNvZEhTb2RIU29BQWdBQUFBQURJQUs4QUFZQUN3QUl0UWtIQmdBQ0xTc1JJUlVoRVNNSEFTRVJKeUVCOVA3VVpHUUJMQUgwWlA1d0FyeGsvdFJrQVN6K0RHUUFBUUFBQUVJREVBSzhBQTBBQnJNQ0FBRXRLd0VYQVM0Q0x3RTNGaGMrQWdLQmovNFRJRWxhR0VpTlMwNG5qblFDdkkzK0V5SktXUmxIalV4S0o0NTBBQUVBQUFBeUF5QUNXQUFGQUFhekJBQUJMU3NURnpjWENRR1crdnFXL25EK2NBSlkrdnFXL25BQmtBQUFBUUFBQUFBQ0pnTWdBQVVBQnJNRUFBRXRLd0VYQnhjSEFRR1FsdnI2bHY1d0F5Q1crdnFXQVpBQUFBQUJBQUFBQUFJbUF5QUFCUUFHc3dJQUFTMHJFd2tCSnpjbmxnR1EvbkNXK3ZvRElQNXcvbkNXK3ZvQUFBRUFBQUF5QXlBQ1dBQUZBQWF6QWdBQkxTc0pBUWNuQnljQmtBR1FsdnI2bGdKWS9uQ1crdnFXQUFBQUFnQUFBQUFESUFNZ0FBY0FEUUFJdFF3SUJBQUNMU3NTSUJZUUJpQW1FQ1VISndjWEFlb0JUT3JxL3JUcUFsajZaRWlzQVVJRElPcit0T3JxQVV3NCttUklyQUZDQUFBQUFnQUFBQUFESUFNZ0FBY0FFd0FJdFF3SUJBQUNMU3NTSUJZUUJpQW1FRGNIRndjWE54YzNKemNuQitvQlRPcnEvclRxK2tpV2xraVdsa2lXbGtpV0F5RHEvclRxNmdGTU9FaVdsa2lXbGtpV2xraVdBQUFBQUFJQUFBQUFBcndESUFBUkFDVUFDTFVkRWdrQUFpMHJBRElXSFFFek1oWWRBU0UxTkRZN0FUVTBCVE1WSVRVek1oWVZFUlFHSXlFaUpqVVJORFlCU1NvZFN3c08vdFFPQzB2KzdVc0I5RXNMRGc0TC9YWUxEZzRESUIwVk1nNExTMHNMRGpJVlI4aklEZ3Y5ZGdzT0Rnc0NpZ3NPQUFBQUFBTUFBQUFBQXlBRElBQUhBQThBR0FBS3R4VVFEQWdFQUFNdEt4SWdGaEFHSUNZUUpDSUdGQll5TmpRbE14VVdGd2NtTHdIckFVcnI2LzYyNndJTStMQ3crTEQrb21RaUprZ2tNQkFESU92K3R1dnJBVXFIc1Bpd3NQaE10U1FoU0Nnd0RBQUNBQUFBQUFNZ0F5QUFHUUFzQUFpMUpoNEpBQUl0S3dFeUZoMEJIZ0VWRkFjak5UUW1JZ1lkQVNFbU5UUTJNejRCRXpzQk1qWXpNaFlkQWpNSEp6TTlBVFEyQWNKb2tpczVDYjlZZkZqKzhCeDJVaEdQU2dNRUFRWUNGUjJXeU1pV0ZBTWdrbWd5RUZVeEdoZ3lQbGhZUGpJeE0xSjJWbkwrY0FFZEZRR1d5TWlXQWc4ZEFBQUFBZ0FBQUFBRElBTWdBQlFBSHdBSXRSb1ZDUUFDTFNzQk1oWWRBUjRCRlJRSEl5Y0hJeVkxTkRZelBnRVRGeU1WRkFZaUpqMEJJd0hDYUpJck9RbU55TWplSEhaU0VZOWErc2dkS2gzSUF5Q1NhRElRVlRFYUdNaklNVE5TZGxaeS9qNzZNaFVkSFJVeUFBQUFBUUFBQUdRRElBSzhBQklBQnJNSkFBRXRLd0V5RmgwQkhnRVZGQVlqSVNJbU5EWXpQZ0VCd21pU0t6bFlQdjQrVW5aMlVoR1BBcnlTYURJUVZURStXSGFrZGxaeUFBQUFBZ0FBQUFBRElBTWdBQXNBSGdBSXRSVU1Cd0FDTFNzVE1oY2lCZ2NHQnlZMU5EWUZNaFlkQVI0QkZSUUdJeUVpSmpRMk16NEIrbnROYXJFcU9pb1prZ0V3YUpJck9WZysvajVTZG5aU0VZOERJR1J6WGhBZk5EWm9rc2lTYURJUVZURStXSGFrZGxaeUFBQUFBd0FBQUdRRElBSzhBQU1BQ1FBUEFBcTNEUW9IQkFJQUF5MHJBVE1CSXdNekJ4Y2pKeVV6Rndjak53SDBaUDdVWkdSa1pHUmtaQUpZWkdSa1pHUUN2UDJvQWZUSXlNakl5TWpJQUFJQUFBQUFBeUFESUFBZkFDY0FDTFVrSUJBQUFpMHJBVE1mQVRjWEJ4OEJGUThCRndjbkR3RWpMd0VISnpjdkFUVS9BU2MzRnpjV0lnWVVGakkyTkFGZVpESWNkMGd5REhkM0RESklkeHd5WkRJY2QwZ3lESGQzRERKSWR4eWlmRmhZZkZnRElIY01Na2gzSERKa01oeDNTRElNZDNjTU1raDNIREprTWh4M1NESU1nMWg4V0ZoOEFBQUFBd0FBQUFBRElBTWdBQU1BQmdBS0FBcTNDUWNHQkFJQUF5MHJFU0VWSVJjaEJ3VWhGU0VESVB6Z3lBR1F5UDV3QXlEODRBTWd5R1RJeUdRQUF3QUFBQUFESUFNZ0FBTUFCd0FLQUFxM0NRZ0dCQUlBQXkwckVUTVJJd0V6RVNNREVTZGtaQUpZeU1oa3lBTWcvT0FESVB6Z0FsaitjTWdBQXdBQUFBQURJQU1nQUFNQUJ3QUtBQXEzQ2dnR0JBSUFBeTByRVRNUkl3RXpFU01CRndmSXlBSzhaR1QrY01qSUF5RDg0QU1nL09BQ1dNaklBQUFBQUFNQUFBQUFBeUFESUFBREFBWUFDZ0FLdHdrSEJRUUNBQU10S3hFaEZTRUZGeUVISVJVaEF5RDg0QUdReVA1d3lBTWcvT0FESUdUSXlHVElBQVlBQUFBQUFyd0N2QUFuQURBQU9RQTlBRVlBVHdBUlFBNUtSMEkrT3pvMU1Td29GQUFHTFNzU01oWWRBVE0xTkRZeUZoUUdLd0VWTXpJV0ZBWWlKajBCSXhVVUJpSW1ORFk3QVRVaklpWTBGaUlHRkJZN0FUVTBKQ0lHSFFFek1qWTBCUlV6TlFjaUJoUVdNalk5QVNFVkZCWXlOalFtSTFoOFdHUllmRmhZUGpJeVBsaFlmRmhrV0h4WVdENHlNajVZcXlvZEhSVXlBWE1xSFRJVkhmN1VaUG9WSFIwcUhRRXNIU29kSFJVQ3ZGZytNakkrV0ZoOFdHUllmRmhZUGpJeVBsaFlmRmhrV0h3TUhTb2RNaFVkSFJVeUhTcXJaR1RJSFNvZEhSVXlNaFVkSFNvZEFBQUJBQUFBQUFNZ0F5QUFDZ0FHc3dZQkFTMHJFVFF6SVRJVkVTY2hJalVKQXc0SnlQMnhDUU1YQ1FyODZzZ0pBQUFFQUFBQUFBTWdBeUFBQndBUEFCTUFHd0FOUUFvWUZCSVFEQWdFQUFRdEt4SWdGaEFHSUNZUUpDSUdGQll5TmpRbkF3VVRGaUlHRkJZeU5qVHJBVXJyNi82MjZ3SU0rTEN3K0xCa1pQN1VaSGtxSFIwcUhRTWc2LzYyNitzQlNvZXcrTEN3K0V6KzFHUUJMRElkS2gwZEtnQUFBQUlBQUFBQUF5QURJQUFIQUEwQUNMVUpDQVFBQWkwckVpQVdFQVlnSmhBbEVUSTJOQ2JyQVVycjYvNjI2d0dRZkxDd0F5RHIvcmJyNndGS2gvMm9zUGl3QUFBQUJRQUFBQUFESUFNZ0FBTUFCd0FMQUE4QUZ3QVBRQXdVRUE0TUNnZ0dCQUlBQlMwckVTRVZJUlVoRlNFVklSVWhGU0VWSVNReUZoUUdJaVkwQXlEODRBSDAvZ3dESVB6Z0FsajlxQUxaS2gwZEtoMERJR1JrWk1oa1pHUmtIU29kSFNvQUFBUUFBQUJrQXlBQ3ZBQUpBQk1BRndBYkFBMUFDaGtZRlJRT0NnVUFCQzByRXlFeUZoMEJJVFUwTmdjaEVSUUdJeUVpSmpVM0ZUTTFNeFV6TlJrQzdnc08vT0FPRGdNZ0RndjlFZ3NPWkdSa1pBSzhEZ3RMU3dzT3lQNkpDdzRPQzY5a1pHUmtBQUFBQXdBQUFBQURJQU1nQUJJQUZRQVlBQXEzRnhZVUV3c0FBeTByRXpNVklUY1hCeEV6RlNNVkl6VWhFU00xTXhjUkFSY0JJV1JrQWNKa01tUmtaR1QrREdSa1pBRmVNdjZpQVY0RElHUmtNbVQrUG1Sa1pBSDBaR1Qrb2dGZU12NmlBQUFBQUFVQUFBQUFBeUFESUFBSEFBOEFGd0FzQURRQUQwQU1NUzBtR3hRUURBZ0VBQVV0S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFrTWhZVUJpSW1OQWMwTmpjN0FqSWZBVGN5RmhRR0lpWTFOeWNtSkRJV0ZBWWlKalRyQVVycjYvNjI2d0lNK0xDdytMRCt2eW9kSFNvZGxoUU9Bd01JRmc1YkdTazdPMUk3QmxvUUFVa3FIUjBxSFFNZzYvNjI2K3NCU29ldytMQ3crRXdkS2gwZEtuY1BIUVFRV2dZN1VqczdLUmxiRGtZZEtoMGRLZ0FBQUFJQUFBQUFBeUFESUFBR0FBb0FDTFVKQndRQUFpMHJBVE1STXdrQk13RWhGU0VCTE1qSS90VCsxTWorMUFNZy9PQURJUDdVL3RRQkxQNXdaQUFBQUFBQ0FBQUFBQU1nQXlBQUF3QUtBQWkxQndRQ0FBSXRLeEVoRlNFRkFTTVJJeEVqQXlEODRBR1FBU3pJeU1nRElHUmsvdFQrMUFFc0FBSUFBQUJrQXlBQ3ZBQUVBQkFBQ0xVSkJRSUFBaTByRXlFUklRTWxCeGNIRnpjWE55YzNKd2ZJQWxqOXFNZ0JYa2lXbGtpV2xraVdsa2lXQXJ6OXFBRXMza2lXbGtpV2xraVdsa2lXQUFBQUFnQUFBR1FESUFLOEFBc0FHQUFJdFJNTUF3QUNMU3NTSUJZVkl6UW1JZ1lWSXpRbEZ6Y2VBUlVVQmlJbU5UUTI2d0ZLNjJTdytMQmtBVlU3T3o1UGRxUjJUd0s4NjZWOHNMQjhwUnBZV0JOcFExSjJkbEpEYVFBQUFBQUZBQUFBQUFLOEF5QUFCUUFJQUF3QUVBQVVBQTlBREJJUkRnMEtDUWNHQkFBRkxTc1JJUkVoRVNFSkFTRWxGVE0xQnhVek5RY1ZJVFVCTEFHUS9VUUJrQUVzL3RUKzFHUmtaR1FCa0FNZy9uRCtjQU1nL3RSa1pHVElaR1RJWkdRQUFBQUFBUUFBLzV3QjlBSzhBRHNBQnJNZUFBRXRLeE16RlRNeUZ4WWRBU00xSmlzQklnWWRBUlFXRndVZUFSMEJGQVlyQVJVak5TTWlKeVk5QVRNVkZqc0JNalk5QVRRbUp5VXVBVDBCTkRZN0FjaGtTekVnTEdRSUVmb0xEaGNMQVFFeFBFb3pTMlJMTVNBc1pBZ1IrZ3NPRnd2Ky96RThTak5MQXJ4a0ZoOHZaRjRHRGdzeUN4NERRUXhPTXpJelNtUmtGaDh2WkY0R0Rnc3lDeDREUVF4T016SXpTZ0FDQUFBQVpBTWdBcndBQXdBSEFBaTFCd1FEQUFJdEt4RWhFUWtCSVJFQkFTeisxQUgwQVN6KzFBSzgvdFQrMUFKWS90VCsxQUFBQUFJQUFBQmtBeUFDdkFBREFBY0FDTFVGQkFFQUFpMHJBUkVoRVFFUklSRUJMUDdVQXlEKzFBSzgvYWdCTEFFcy9hZ0JMQUFDQUFBQVpBTWdBcndBQ2dBVkFBaTFFUXNHQUFJdEt3RVZJZ1lWTXhFaEVUUTJJUlVpQmhVekVTRVJORFlCTEZOMXlQN1VzQUp3VTNYSS90U3dBcnhrZFZQKzFBRXNmTEJrZFZQKzFBRXNmTEFBQUFBQ0FBQUFaQU1nQXJ3QUNnQVZBQWkxRHdzRUFBSXRLeEVoRVJRR0l6VXlOalVqQVNFUkZBWWpOVEkyTlNNQkxMQjhVM1hJQWZRQkxMQjhVM1hJQXJ6KzFIeXdaSFZUQVN6KzFIeXdaSFZUQUFJQUFQL3FBbGdESUFBU0FDSUFDTFVZRXdrQUFpMHJBUmNlQkJVVUJpSW1OVFErQXpjQ0lnWVZGQll6TWpZMEppTWlKalUwQVN3aURTaFpSVGV3K0xBM1JWa29EVjhxSFhaU0ZSMGRGU2s3QXlBaURTdHliNUk5ZkxDd2ZEMlNiM0lyRGY1S0hSVlNkaDBxSFRzcEZRQUNBQUFBQUFNZ0F5QUFBZ0FHQUFpMUJRTUJBQUl0S3drQklSVWhGU0VCa0FHUS9PQURJUHpnQXlEK0RHVElBQUFDQUFBQUFBSllBeUFBQWdBRkFBaTFCUU1CQUFJdEt3a0JJUlVoQVFFc0FTejlxQUpZL3RRRElQN1V5UDdVQUFBREFBQUJMQU1nQWZRQUF3QUhBQXNBQ3JjS0NBWUVBZ0FETFNzUk14VWpKVE1WSXlVekZTUEl5QUVzeU1nQkxNaklBZlRJeU1qSXlBQUFBQUFDQUFBQVpBTWdBcndBQkFBSkFBaTFDQVVEQUFJdEt4RWhGUVVsRlFVbEVTRURJUDV3L25BQmtBR1EvT0FDdkdUSXlHVEl5UDV3QUFNQUFBQUFBeUFESUFBRUFBb0FEd0FLdHc0TENBVUNBQU10S3dFRkVTRVJKUVVWQlNVMUJTRVZCeWNCa0FHUS9PQUJrUDdVQVN3QkxQNE1BWkRJeUFNZ3lQMm9BbGhZbHJ5V2xyd21aR1JrQUFBQUFBRUFBUCtjQXlBQ3ZBQWpBQWF6RlFBQkxTc0JNaGNISmlJR0J5RUhJUlFYSVFjakZqTXlOeFVHSXlJbUp5RTNNeVkxSXpjelBnRUNXR05jRUU3Q21SOEJTeEQrc2hNQktSRGVXb1J5Vmw1cWJMWTIvd0FUeFJESUdiOGkxQUs4TW1vNGIxbGtMVGRrWkU1Nk9HMWJaRUFrWklPcEFBQUFBQVlBQUFBQUF5QUN2QUFEQUFjQUN3QVBBQk1BRndBUlFBNFdGQklRRGd3S0NBWUVBZ0FHTFNzUklSVWhGU0VWSVJVaEZTRVZNeFVqTnpNVkl6Y3pGU01DdlAxRUFmVCtEQU1nL09Ca1pNaGtaTWhrWkFLOFpHUmtaR1JrWkdSa1pHUUFBQUFEQUFBQUFBTWdBeUFBQXdBR0FBb0FDcmNKQndZRUFnQURMU3NSSVJVaEZ5RUhCU0VWSVFNZy9PRElBWkRJL25BRElQemdBeUJrWk1qSXlBQURBQUFBQUFNZ0F5QUFBd0FIQUFvQUNyY0tDQVlFQWdBRExTc1JNeEVqQVRNUkl3RVhCMlJrQWxqSXlQNXd5TWdESVB6Z0F5RDg0QUpZeU1nQUFBQUFBd0FBQUFBRElBTWdBQU1BQndBS0FBcTNDUWdHQkFJQUF5MHJFVE1SSXdFekVTTURFU2ZJeUFLOFpHUmt5QU1nL09BRElQemdBbGorY01nQUF3QUFBQUFESUFNZ0FBTUFCZ0FLQUFxM0NRY0ZCQUlBQXkwckVTRVZJUVVYSVFjaEZTRURJUHpnQVpESS9uRElBeUQ4NEFNZ3lNaklaR1FBQWdBQUFBQURJQU1nQUFrQUVBQUl0UTRLQ0FBQ0xTc1JNeFVqRVNFMU14VWhBU0VSSndjbk44aGtBbGhrL09BQmtBR1FsdnBrK2dNZ1pQMm9aTWdESVA1d2x2cGsrZ0FBQXdBQUFHUURJQUs4QUJzQUl3QTFBQXEzTVNRZ0hBMEFBeTByQVRJZUJCOEJEZ1FqSWk0Q0x3RStCaFlpQmhRV01qWTBKeklYQmhVVUZqTXlOeFlWRkFZaUpqUTJBWk15WTB4Rk1TUUpDUVlYVDFhR1JVZUhYRWNSRVFNTUtTNUlUV1NEcEhaMnBIYklDaEljSFJVZURnWTdVanM3QXJ3aE5VQkFOUkVRRENsblQwRStXRmdmSHdZV1BqbEZNaUprZHFSMmRxUVNCZzRlRlIwY0Vnb3BPenRTT3dBQ0FBRC9uQU1pQXIwQUlRQWxBQWkxSkNJWkF3SXRLd0U3QVRZek1oOEJOell5RnhZVUR3RVhGaFVVQmlNaUx3RUJJUkVCSnlZMU5EWVhBUmNCQVVzREF3TUhGZzllUWl0K0t5d3NRVjBTSFJVWkR6NytnLzd6QVhjL0VCV0Mvc2VBQVR3Q3ZBRVJYVUVyS3l4OExFSmVEaGdWSFJSQi9vTUJFQUY5UHc0V0R4M1gvc1dFQVR3QUFnQUFBQUFDdkFNZ0FBVUFDQUFJdFFjR0JBQUNMU3NSSVJFaEVTRUpBU0VCTEFHUS9VUUJrQUVzL3RRRElQNXcvbkFESVA3VUFBQUNBQUFBQUFLOEF5QUFHZ0FzQUFpMUl4c05BQUl0S3hNZUJCVVVEZ1FYTGdRMU5ENEVOQUVlQkJVVUJpTWhORDRFTk1nSUcwVTFLeXM5UVMwTEdRZ2JSVFVySVRFNU1TQUJHQWdiUlRVclB5WCsxQ0V4T1RFZ0F5QUVFRGhBYURndVhVZFNSbHd1QkJBNFFHZzRLRkJBUWtGQ1R2NzlCQkE0UUdnNFptSW9VRUJDUVVKT0FBQUFBZ0FBQUFBRElBTWdBQU1BREFBSXRRa0VBZ0FDTFNzUk14RWpFeUVWSVFjWElUVWpaR1RJQVN3QkxNakkvbkRJQXlEODRBTWdaTXZGWkFBQUFRQUFBQUFCa0FNZ0FBb0FCck1HQUFFdEt4TXpCek1ETXdFRE16Y2pscFpreUphVy90Umtoa0xJQXlESS90VCsxQUVzeUFBQUFBQUNBQUFBQUFNZ0F5QUFCUUFQQUFpMUNnWUVBQUl0S3hFaEZTRVZJUlVoRVJRR0l5RWlKalVCTEFIMC9PQURJQjBWL1VRVkhRTWdaR1JrL2o0VkhSMFZBQUFBQUFFQUFBQUFBcndESUFBd0FBYXpKUUFCTFNzU01oWVZGQVlIRlRZN0FUSTJQUUV1QVRVME5qSVdGUlFHQnhVVUJpc0JJZ2NlQVJVVUJpSW1OVFEyTnpVdUFUVTBXSHhZTnkwYkY4Z1ZIUzAzV0h4WU55MVlQc2dTRUNZdVdIeFlOeTB0TndNZ1dENHhUUTkyQ1IwVk93OU5NVDVZV0Q0eFRRODdQbGdRRWtnc1BsaFlQakZORDlvUFRURStBQUFBQUFJQUFBQUFBeUFESUFBR0FBMEFDTFVLQndRQUFpMHJFU0VIRndjbkJ5RVhOeEVoTnljQmtKYVdaSmFXQWZTV2x2NXdscFlESUphV1pKYVdscGIrY0phV0FBQUFBZ0FBQUFBRElBTWdBQVlBRFFBSXRRc0hBd0FDTFNzVEZ6Y1JJVGNuQVNFSEZ3Y25CMlNXbHY1d2xwWUJrQUdRbHBaa2xwWURJSmFXL25DV2x2N1VscFprbHBZQUFBQUFBd0FBQUFBRElBTWdBQWNBUmdCVkFBcTNVVWNuQ0FRQUF5MHJFaUFXRUFZZ0poQWxJZ2NYRmdZSEJpSUdGeFlHTGdFSEJoNEJCeWNpQnhZWEhnRVhIZ0VIRmpNeU5qYzJKaU1pTGdJM1BnTW5KajRCTlRRbUp5WStBemNtRnc0QkZ4WTJGeDREUHdFMUp1b0JUT3JxL3JUcUFaQlFTUllXRFJZS0t4RUZCZ29PRndZVEdTQUhPd29HQVJJSlRnMGxOaEE2TUV1REtRSVhIUjR3TVJzQkFSOGVFUTBOQlJSRUFRRURDd1lUQXpuQ0l6a0ZBellJQXdrSEVBa1dFQU1nNnY2MDZ1b0JUSVlzRXc4akNRUU9GeFFJQ1FnRUVrTkdBU0lLSGpZRENRMFdhU0FXUXpvVUdBY1RLUjRQTENFb0N4SU5HUW9WRndZRkN3MEhFZ0lUYlFvZkRBZ0JCZ01VRFFZTEZnTW1BQUFDQUFBQUFBTWdBeUFBQndBTEFBaTFDZ2dFQUFJdEt3RVhBU2NISndFWEFTRVZJUUsvWWY1d1pNaGtBU3hrL25BRElQemdBeUJrL25Ca3kyUUJMMlQrY0dRQUFCQUFBQUFBQXJ3Q3ZBQURBQWNBQ3dBUEFCTUFGd0FiQUI4QUl3QW5BQ3NBTHdBekFEY0FPd0EvQUNWQUlqNDhPamcyTkRJd0xpd3FLQ1lrSWlBZUhCb1lGaFFTRUE0TUNnZ0dCQUlBRUMwckVUTVZJemN6RlNNM014VWpOek1WSXdVekZTTTNNeFVqTnpNVkl6Y3pGU01GTXhVak56TVZJemN6RlNNM014VWpCVE1WSXpjekZTTTNNeFVqTnpNVkkyUmt5R1JreUdSa3lHUmsvYWhrWk1oa1pNaGtaTWhrWlAyb1pHVElaR1RJWkdUSVpHVDlxR1JreUdSa3lHUmt5R1JrQXJ4a1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtBQWtBQUFBQUF5QURJQUFEQUFjQUN3QVBBQk1BRndBYkFCOEFJd0FYUUJRaUlCNGNHaGdXRkJJUURnd0tDQVlFQWdBSkxTc1JNeFVqSlRNVkl5VXpGU01GTXhVakpUTVZJeVV6RlNNRk14VWpKVE1WSXlVekZTUEl5QUVzeU1nQkxNakkvYWpJeUFFc3lNZ0JMTWpJL2FqSXlBRXN5TWdCTE1qSUF5REl5TWpJeUdUSXlNakl5R1RJeU1qSXlBQUFBQVFBQUFBQUF5QURJQUFEQUFjQUN3QVBBQTFBQ2c0TUNnZ0dCQUlBQkMwckVTRVJJUUVoRVNFRklSRWhBU0VSSVFFcy90UUI5QUVzL3RUK0RBRXMvdFFCOUFFcy90UURJUDdVQVN6KzFNaisxQUVzL3RRQUFBQURBQUFBQUFLOEF5QUFEUUFaQUNFQUNyY2VHaFVPQmdBRExTc1RJVElWRVJRR0l5RWlKalVSTkJFV015RXlOeEVVSXlFaU5TUWlCaFFXTWpZMEV3S1dFeDBWL2FnVkhSZ2FBbGdhR0JQOWFoTUNPeW9kSFNvZEF5QVQvclVWSFIwVkFVc1QvaFVKQ2Y3ZUV4TzFIU29kSFNvQUFBRUFBQUFBQXJ3Q3ZBQXpBQWF6R2dBQkxTc1JJUlVqSWdZZEFTRTFOQ1lyQVRVaEZTTWlCaFVSRkJZN0FSVWhOVE15TmowQklSVVVGanNCRlNFMU16STJOUkUwSmlzQkFTd3lGUjBCTEIwVk1nRXNNaFVkSFJVeS90UXlGUjMrMUIwVk12N1VNaFVkSFJVeUFyeGtIUldXbGhVZFpHUWRGZjV3RlIxa1pCMFZscFlWSFdSa0hSVUJrQlVkQUFBQUFBRUFBQUFBQXlBQ3ZBQWxBQWF6Q3dBQkxTc0FNaFlkQVRNeUZoMEJGQVlyQVNJbU5SRTBKaUlHRlJFVUJpc0JJaVk5QVRRMk93RTFOQUVVK0xBeUZSMGRGV1FWSFhXbWRSMFZaQlVkSFJVeUFyeXdmR1FkRmNnVkhSMFZBVjVUZFhWVC9xSVZIUjBWeUJVZFpId0FBQUFCQUFBQUV3TWdBcndBRFFBR3N3d0NBUzByRURRMk1oWVZORFl5RmhRSENRRjJwSFoycEhZNy9xditxd0dpcEhaMlVsSjJkcVE3L3F3QlZBQUJBQUFBQUFNZ0Fyd0FDZ0FHc3dNQUFTMHJDUUVuRVNNMUl4VWpFU01Ca0FHUVpNakl5R1FDdlA3VUEvNXR5TWdCa0FBQUFnQUFBQUFESUFNZ0FBTUFEUUFJdFFjRUFnQUNMU3NSSVJFaEV4RTNBVE0xSnpjWEVRTWcvT0JrWkFHUVpNaGtaQU1nL09BQ3ZQN1VaUDV3Wk1oa1pBRXNBQUFDQUFBQUFBTWdBeUFBQ3dBVEFBaTFEd3dGQUFJdEt4TWhNaFVSRkNNaElqVVJOQmNSTXhjek56TVJFd0w2RXhQOUJoTmtaR1RJWkdRRElCUDlCaE1UQXZvVHlQN1VaR1FCTEFBQUF3QUFBTWdESUFKWUFCVUFJQUFyQUFxM0ppRWFGZ29BQXkwckV6SVdGejRCTXpJV0ZBWWpJaVluRGdFaklpWTBOaGNpQmhRV016STJOeTRCSVNJR0J4NEJNekkyTkNiSU4xNHpNMTQzWFd0clhUZGVNek5mTmwxcmExMHpNVEV6SFQ4cUtqOEJjeDAvS2lvL0hUTXhNUUpZUURvNlFIaWdlRUE2T2tCNG9IaGtQRkE4TkRBd05EUXdNRFE4VUR3QUFnQUFBQUFCa0FNZ0FBY0FKUUFJdFJZSUJBQUNMU3NBTWhZVUJpSW1OQVl5RmhVVUJoVVVGakkyTlRNVUJpTWlKalUwUGdFMU5DWWlCaFVqTkFFRFVqczdVanR3ZkZoa0hTb2RaRmcrUDFjeU1oMHFIV1FESUR0U096dFN2MWs5SmNjT0ZSMGRGVDVZVmtBbGNWb0tGUjBkRlQ0QUFBQUFBUUFBQUFBQ3ZBTWdBQkFBQnJNSEFBRXRLeE1oRlNNREJ6TVZJVFV6UGdJL0FTUElBZlI2NmdhaS9neDZJazVnR2dlakF5QmsvYlFNWkdSWXhPOUJEQUFBQUFBRUFBQUFBQU1nQXJ3QUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLeEVoRlNFVklSVWhGU0VWSVJjaEZTRURJUHpnQXlEODRBTWcvT0JrQWxqOXFBSzhaR1JrWkdSa1pBQUFCQUFBQUFBRElBSzhBQU1BQndBTEFBOEFEVUFLRGd3S0NBWUVBZ0FFTFNzUklSVWhGU0VWSVJVaEZTRVZJUlVoQXlEODRBTWcvT0FESVB6Z0FsajlxQUs4WkdSa1pHUmtaQUFBQUFRQUFBQUFBeUFDdkFBREFBY0FDd0FQQUExQUNnNE1DZ2dHQkFJQUJDMHJFU0VWSVJVaEZTRVZJUlVoRnlFVklRTWcvT0FESVB6Z0F5RDg0TWdDV1Ayb0FyeGtaR1JrWkdSa0FBQUNBQUFBQUFNZ0F5QUFFUUFaQUFpMUZoSUxBQUl0S3dBeUZoUUdJeUluQnhVakZTRTFBU1kxTkNRaUJoUVdNalkwQWI3UWtwSm9JQThEeVA3VUFTOERBVlZTT3p0U093TWdrdENTQXdOa3lNZ0JMdzhnYUM0N1VqczdVZ0FBQUFBQ0FBQUFBQU1nQWxnQUdBQWdBQWkxSEJrTkFBSXRLeE03QXlFeUZoVVJNeFVVQmlNaElpWTlBVE1STlRRMkZ4RXpGVE0xTXhHR0F3UUVCUUgwRlIxa0hSWDlSQlVkWkJSUVpNaGtBbGdkRmY2aWxoVWRIUldXQVY0Q0R4MWcvdFJrWkFFc0FBQUFBQU1BQUFBQUF5QURJQUFEQUFrQUR3QUt0d3dLQmdRQ0FBTXRLeEVoRVNFbE14RWhOU0UzTXhFaE5TRUJrUDV3QWZSay9uQUJMTWhrL25BQkxBTWcvbkRJL25Ca1pQNXdaQUFBQUFBRUFBRC9td0g4QXIwQUVRQWpBRDBBVUFBTlFBcE5RRElsSEJNS0FRUXRLd0UyTXpJV0ZSUUdCd1VHSXlJbU5UUTJOeUUyTXpJV0ZSUUdCd1VHSXlJbU5UUTJOeUUyTXpJV0ZSUUdEd0VlQVJVVUJpTWlKaXNCTGdFMU5EWTNGelEyT3dReUZoUUdLd0VpQmlNaUpnRlJDZ3NWSFJBTC90UVBFQlVkRmc4QmtBc0tGUjBRQy81d0R4QVZIUllQQVpBTENoVWRFQXRxRWhrZUZRRUdBY2dUSFE4TERoc1RBd1FGWkJVZEhSVmtBUVlCRlIwQ3RnY2RGUTBhQnBZTEhSVVFIUVFISFJVTkdnYklDeDBWRUIwRUJ4MFZEUm9HT0FNZEVoVWVBUUVkRkF3YUJ2UVNJQjBxSFFFZUFBUUFBQUFBQXg0RElBQUZBQ2NBU2dCUUFBMUFDazlMUlMwUUNBSUFCQzByRXpNVkl6VXpKVE0yRnhZWEZoUVBBUVlqSWlZMU5EOEJOaVluSmdZUEFRWWpJaVkxTkQ4Qk5nRTJPd0V5TmpNeUZoUVBBUVlXRnhZMlB3RTJNeklXRlJRUEFRWUhCaVluSmpRM0JUTVZJeFVqeDJUSVpBR0RBU0lXTnlvNk9wWVBIQlVkR0pZZUFSMGdWUnNzRHhzVkhSZ3JNdjdVRFFrREFRWUJGUjBPbGg0QkhTQlZHeXdQR3hVZEdDc2ZMRFJ5S1RvNkFibklaR1FESU1oa1lRSUZEQ282cER1V0dCMFZIQStXSGxVZEhnTWJMQmdkRlJ3UExEVCswUkFCSFNvT2xoNVZIUjRER3l3WUhSVWNEeXdmRUJNWktUdWtPb3hrWkFBQUFBSUFBQUFGQXg0REhRQXJBRlFBQ0xWVVRRa0JBaTByQVRZWEZoY1dGQThCQmljdUJTTW1OVFEyTXpJWEZoY1dQd0UySmljbUJnY0dJeUltTlRRM05nY2VBaGNlQVJVVUJpTWlKeVluSmc4QkJoWVhGalkzTmpNeUZoVVVCd1lIQmlZbkpqUS9BVFlDU2lNV055bzZPcFpVWWd3V0RSRUZEZ0VhSFJVT0RBOGFOek9XSGdFZElGVWJEeHdWSFJneWVoWWdHQWNQRmgwVkVBOFRIRGt1bGg0QkhTQlZHdzhiRlIwWEh5dzBjaWs2T3BaUUF4MENCUXdxT3FRN2xsUUdBUU1EQndNSURoNFZIZ2NMQWdRemxoNVZIUjRER3hnZEZSd1BOT01CQ0FzQ0JCMFFGUjBMQ1FFQ0xwWWVWUjBlQXhzWUhSVWREaDhRRXhrcE82UTZsbEFBQUFBQUJnQUFBQUFESUFLOEFBTUFCd0FMQUE4QUV3QVhBQkZBRGhZVUVoQU9EQW9JQmdRQ0FBWXRLeEVoRVNFQklSVWhGU0VWSVFVaEVTRUJJUlVoRlNFVklRRXMvdFFCa0FHUS9uQUJMUDdVL25BQkxQN1VBWkFCa1A1d0FTeisxQUs4L3RRQkxHUmtaR1QrMUFFc1pHUmtBQWdBQUFBQUF5QUN2QUFIQUFzQUV3QVhBQjhBSXdBckFDOEFGVUFTTGl3b0pDSWdIQmdXRkJBTUNnZ0VBQWd0S3hJeUZoUUdJaVkwTnlFVklRWXlGaFFHSWlZME55RVZJUVl5RmhRR0lpWTBOeUVWSVFZeUZoUUdJaVkwTnlFVklSMHFIUjBxSGNnQ1dQMm9xeW9kSFNvZHlBSlkvYWlyS2gwZEtoM0lBbGo5cUtzcUhSMHFIY2dDV1Ayb0Fyd2RLaDBkS2gxa1pCMHFIUjBxSFdSa0hTb2RIU29kWkdRZEtoMGRLaDFrQUFBQUFRQUFBQUFESUFNZ0FBTUFCck1CQUFFdEt3a0JBeVVESVA1d1pQN1VBeUQ4NEFFc1pBQUFBQUlBQUFBQUFsZ0N2QUFMQUJNQUNMVVFEQVlBQWkwckVqSVdIUUV6RVNFUk16VTBOaUlHSFFFek5UVGFwSFprL2FoazhsUTZ5QUs4ZGxKay9uQUJrR1JTRWpvcVpHUXFBQUVBQUFBQUFsZ0RJQUFSQUFhekJnQUJMU3NTTWhZZEFUTVJJUkVoTlRRbUlnWVZJelRhcEhaay9hZ0JrRHBVT21RRElIWlN5UDV3QVpESUtqbzZLbElBQUFBQUFnQUFBR1FESUFLOEFBb0FGUUFJdFE4TEJnQUNMU3NCRlNJR0ZUTUhKek0wTmdVWEl4UUdJelV5TmpVakFaQlRkV1NXbG1Td0FYYVdaTEI4VTNWa0FyeGtkVlBJeUh5d1pNaDhzR1IxVXdBQ0FBQUFBQU1nQXlBQUNnQVZBQWkxRWdzRUFBSXRLeE1oRVRNSEp6TTFJUlVqSHdFakZTRTFNeFVoRVNOa0FsaGtscFprL25Ca01wWmtBWkJrL2Foa0F5RCsxUHI2eUdReStzaGt5QUVzQUFJQUFBQUFBeUFDdkFBTEFCY0FDTFVXREFJQUFpMHJBUmNITlNFVkl6VTBOak1oQVJVaE5UTVZGQVlqSVJVbkFsakl5UDRNWkRzcEFmVCtjQUgwWkRzcC9neklBcnlXbG1Sa1pDazcvdFJrWkdRcE8yU1dBQUFDQUFELy9nTWlBeUFBR1FBakFBaTFIeG9OQUFJdEt4SWdGaFVVQnhZZkFSNEJGUlFHSXlJbUx3RW1Kd1lqSWlZUUFUSTJOVFFtSWdZVUZzMEJJczBzQ2daa0RCSThLaEVyREdRRkIwMVprYzBCWG1xUWt0Q1NrZ01nelpGV1VBWUdaQXdyRVNvOEVneGtCQWtwelFFaS9uV1FhbWlTa3RDU0FBQUFBZ0FBQUFBQ1dBTWdBQkFBR0FBSXRSVVJDUUFDTFNzU01oWVZGQTRDRHdFdUJEVTBKQ0lHRkJZeU5qU3crTEErV0ZnZkh3d3BaMDlCQVg2a2RuYWtkZ01nc0h3NGtINXVJQ0FNSzMxMWt6aDhUSGFrZG5ha0FBUUFBQUFBQXlFRElBQUlBQmNBSmdBdUFBMUFDaXNuSHhnUkR3Y0FCQzByRVNFUkZoVVVCeFVoSlRRMk93SVJJUkVoTlNzQklpWUNNaFlWRkFZUEFTNEVOVFFXSWdZVUZqSTJOQU1nQVFIODRBSHZIUlVGbHYyb0FsaVdCUlVkejN4WVN5VW1CaFEwS0NDcktoMGRLaDBESVAzakF3Z0hBKzc2RkI0QmtQMm9aQjBCYzFnK0xIMHBLQVlXUGpwS0hENE1IU29kSFNvQUFnQUFBR1FDV0FLOEFBTUFCd0FJdFFZRUFnQUNMU3NSTXhFakFUTVJJOGpJQVpESXlBSzgvYWdDV1Ayb0FBQUFBUUFBQUdRQ1dBSzhBQUlBQnJNQ0FBRXRLeEVKQVFKWS9hZ0N2UDdVL3RRQUFBQUFBUUFBQUdRQ1dBSzhBQWNBQnJNRUFBRXRLeEl5RmhRR0lpWTBzUGl3c1Bpd0FyeXcrTEN3K0FBQUFBQUNBQUFBWkFNZ0Fyd0FBZ0FGQUFpMUJRUUJBQUl0S3dFUkFTRUJFUUdRL25BQmtBR1FBcno5cUFFc0FTejlxQUFDQUFBQVpBTWdBcndBQWdBRkFBaTFCQU1DQUFJdEt4RUpBU0VSQVFHUS9uQUJrQUdRQXJ6KzFQN1VBbGorMUFBQ0FBQUFaQUs4QXJ3QUF3QUdBQWkxQmdVQ0FBSXRLeEV6RVNNVEFSSEl5TWdCOUFLOC9hZ0JMQUVzL2FnQUFBQUNBQUFBWkFLOEFyd0FBZ0FHQUFpMUJBTUNBQUl0S3hFSkFTRVJNeEVCOVA0TUFmVElBcnorMVA3VUFsajlxQUFCQUFBQVpBSllBcndBQXdBR3N3SUFBUzByRVNFUklRSlkvYWdDdlAyb0FBRUFBQUFBQXlBRElBQUxBQWF6QmdBQkxTc1RJUlV6RVNNVklUVWpFVFBJQVpESXlQNXd5TWdESU1qK2NNaklBWkFBQUFBREFBQUFBd01nQXJ3QUF3QUhBQXNBQ3JjS0NBWUVBZ0FETFNzUklSVWhGU0VWSVJVaEZTRURJUHpnQXlEODRBTWcvT0FDdkdURlpNaGtBQUFDQUFEL25BSllBc0FBRUFBOEFBaTFMeFVKQVFJdEt3RTJNeklXSFFJVUJpSW1QUUkwTmdjN0FUSTJNeklXSFFJVUZqSTJQUUUwTmpJV0hRRVVCZ2NWTXpJV0ZTRTBOanNCTlM0QlBRSTBOZ0VXRGdncE96dFNPeTdVQkFNQkJnSVZIWFdtZFIwcUhZOXJNaWs3L25BN0tUSnJqeFFDdkFRN0tRVElLVHM3S2NnQ0lUckJBUjBWQVRKVGRYVlRNaFVkSFJVeWJxWVNhanNwS1R0cUVxWnVNZ0lQSFFBQUFBQUJBQUFCTEFNZ0FmUUFBd0FHc3dJQUFTMHJFU0VWSVFNZy9PQUI5TWdBQUFJQUFQK2NBeUFDdkFBZ0FDUUFDTFVpSVJJQUFpMHJFenNESVRJV0ZSRVVCaXNCRlRNeUZoVWhORFk3QVRVaklpWTFFVFUwTmhjUklSRWlCQU1FQlFLOEZSMGRGZnBrS1R2OXFEc3BaUG9WSFJSUUFsZ0N2QjBWL2d3VkhXUTdLU2s3WkIwVkFmUUNEeDFnL25BQmtBQUJBQUQvc2dNS0Fyd0FEd0FHc3drQUFTMHJBUVlWRkJZek1qY09BU01pSmpVME5nRVFGdXFtUVQ4bzBJS202cGdDdkQ5QnB1b1dlSmpxcG9MUUFBQUFBUUFBQUFBQ3ZBSzhBQmNBQnJNTUFBRXRLd0VYSXhVek5SY0hOU01WTXdjbk16VWpGU2MzRlRNMUl3RmVsbVNXbHBhV1pKYVdaSmFXbHBaa0FyeVdsbVNXbG1TV2xwYVdaSmFXWkpZQUFBQUJBQUFBQUFNZ0F5QUFIUUFHc3hBQUFTMHJBUkVVQmlJbU5EWXpNaGMxQkFjUkZBWWlKalEyTXpJWEVUNEVBeUJZZkZoWVBoY2IvdldGV0h4WVdENFhHd1FVV0hqa0F5RDkyajVZV0h4WUNjNElLdjV6UGxoWWZGZ0pBWmtFRGlJYUZnQUFBUUFBLzUwQ3VnSzhBQ3dBQnJNbkFBRXRLd0F5RnhZVUR3RUdJaVkwUHdFWER3RUdGQll5UHdFK0FTY3VBUWNCRGdFWEZqSS9BaGNIQmlJbU5EY0JBYUdrT3pvNitpUm5TQ1JnUlZvSEJ3NFlCL29jQVIwZFZSNys2aklCTXpTU05BbDBSWDFRNUtCUUFSWUN2RHM3cERyMEpFaG5KR0ZGWGdNSUZoQUk5eDVSSGgwQkh2N3ROSkF6TkRRTWNVVjlVS0RrVUFFUUFBQUNBQUFBQUFNZ0F5QUFBd0FJQUFpMUJnUUNBQUl0S3dFWEJ5Y0hGd0VqTlFKWXlHVElaTWorY01nRElNaGt5R1RJL25ESUFBQUFBQVFBQUFBQUF5QURJQUFNQUJRQUhnQXFBQTFBQ2lZZkdSVVJEUVFBQkMwckFUSVdGQVlqSWljMk5UUW5OZ1F5RmhRR0lpWTBCUjRCSFFFak5UUW5OZ1VXTWpjZUFSMEJJVFUwTmdJbVBsaFlQaG9oQ1VndS91SjhXRmg4V0FKeElpbklMR1g5dWtmUVJ5SXAvZ3dwQXlCMXBuVVRKeXArVmxoa2RhWjFkYWJIRVQ4bXBrSklQZ01UVkZRUlB5YW1waVkvQUFBQ0FBQUFBQU1nQXlBQUJ3QVRBQWkxRHdnRUFBSXRLd0F5RmhRR0lpWTBBeFl5Tng0QkhRRWhOVFEyQVQybWRYV21kUWxaOEZsUWIvemdid01nazg2VGs4NytuMlJrQkhOUlpHUlJjd0FBQUFNQUFBQUFBZlFESUFBTEFBOEFGd0FLdHhRUURRd0ZBQU10S3hNaE1oVVJGQ01oSWpVUk5CY1JJUkVDSWdZVUZqSTJOQk1CemhNVC9qSVRaQUVzZ1NvZEhTb2RBeUFUL1FZVEV3TDZFMlQrREFIMC9kb2RLaDBkS2dBQUF3QUFBQUFESUFNZ0FBVUFEd0FXQUFxM0VoQUxCZ01BQXkwckFUSVhFUUUyQlI0QkZSUUdJeUluQVNVWEJ5NEJOVFFCWGhvWS90ZGxBU2lBck0yUmUyTUJFUDVuN2RRMlBnTWdBLzV6QVNsbmFoUENnNUhOVVFFUTBlclVLbnBHZkFBQUFBRUFBUCtjQXJ3Q3ZBQWpBQWF6RlFJQkxTc1RORFk3QXlFeUZoUUdLd0VWTXpJV0ZTRVJCeWNSSVRRMk93RTFJeUlHSXlJbVhCc1RBd1FGQVpBVkhSMFZNbVFwTy83VU9DeisxRHNwWkRJQkJnRVZIUUtLRWlBZEtoM0lPeW4rMUdSa0FTd3BPOGdCSGdBQUFBSUFBQUFBQXlBRElBQUhBQW9BQ0xVSkNBUUFBaTByRWlBV0VBWWdKaEFsRVNYcUFVenE2djYwNmdFc0FTd0RJT3IrdE9ycUFVd2kvbkRJQUFFQUFBQUFBeUFESUFBTEFBYXpCZ0FCTFNzQk14RWhGU0VSSXhFaE5TRUJMTWdCTFA3VXlQN1VBU3dESVA3VXlQN1VBU3pJQUFBQUFnQUFBQUFDdkFNZ0FBTUFIZ0FJdFJnRUFnQUNMU3NCTXhFakF4Y0hCaFVVRmpJMk5UUW1Md0UzRng0QkZSUUdJQ1kxTkRZM0FTeGtaSUErS0Y2UzBKSTBMU1UrSmo1SXpmN2V6VWcrQXlEK2NBRUFUaDlMZW1pU2ttZzdaeU1mVGg4eGtGS1J6YzJSVXBBeEFBQUFBQU1BQUFBQUF5QURJQUFEQUJNQUZ3QUt0eFlVQ1FRQ0FBTXRLeE1oRlNFSElUSVZFUlFyQVRVaEZTTWlOUkUwRnlFUkljZ0JrUDV3dndNT0NRbGIvYWhiQ2NnQmtQNXdBeURJWkFuKzVnbkl5QWtCR2duSS90UUFBQUFBQlFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRXdBUFFBd1NFQTRNQ2dnR0JBSUFCUzByRVRNUkl3RXpFU01CTXhVakZ6TVZJeGN6RlNOa1pBSzhaR1QrRE1qSVpNaklaTWpJQXJ6OVJBSzgvVVFDV0dSa1pHUmtBQUVBQVAvaEF5QUN2QUFiQUFhekVnQUJMU3NCRmhNK0FUY1dGek1WSXljR0J5WURCZ0lISmljak5UTWZBVFlTQVVVYWFRODZEeFJEcWVjTlNpWVdZUlZURlJ3NGRMd0pBdzlXQXJ4WC9yUWxsQ1VtaG1RY3VGdEpBVGhEL3ZaRFdLNWtJZ1l4QVJzQUFRQUEvNXdESUFLOEFEa0FCck1mQWdFdEt4TTBOaklXRlJRT0FRY0dGVE1WTWpjK0FqTXlGaFFHSXlJdUFTY21JeFVqTkRjK0FqVTBKaUlHRlJRZUFSY1dGU01STXpRbkxnTElPVlk1Q1JBREErY1dCZ2NkRncwck9Ua3JEUmNkQndZVzV3TURFQWs1VmprSkVBTUQ1K2NEQXhBSkFsZ3JPVGtyRFJjZEJ3WVc1d01ERUFrNVZqa0pFQU1ENXhZR0J4MFhEU3M1T1NzTkZ4MEhCaFlDV0JZR0J4MFhBQUFBQWdBQS81d0I4UUs4QUNzQUx3QUl0UzRzRHdBQ0xTc1RNaGNXRlJRT0FRY09CQjBCSXpVMFBnRTNQZ2cxTkNjbUl5SUhCZ2NuTmpjMkV6TVZJL2QrUVRzcktpSVhDeDRJQ1dRb0tpRUNHd1FWQkE4REJ3SWNKbFJQSlJnSFpBb3hRa2hrWkFLOE96WlhObDh1SGhRTElSWW9HQmtaTmw0d0hRSVhCUlFJRXc0V0Z3NHBHU0lsR0MwTVR6RkMvVVJrQUFBQUFBUUFBQUFBQXlBRElBQWZBRE1BUndCYkFBMUFDbFJNUURnc0pBb0FCQzByQVRJV0hRRWVBUlVVQmdjdUFTTWlCeTRCSWdZSEppTWlCeVkxTkRZelBnRURPd0V5TmpNeUZoMENGQVlpSmowQ05EWUhPd0V5TmpNeUZoMENGQVlpSmowQ05EWWxPd0V5TmpNeUZoMENGQVlpSmowQ05EWUJ3bWlTS3prL01SRkxMaHNkRFZCbVVBMGRHemtvTlhaU0VZOGFCQU1CQmdJVkhSMHFIUlM2QkFNQkJnSVZIUjBxSFJRQm5nTUVBUVlDRlIwZEtoMFVBeUNTYURJUVZURXpVQTBxTkF3eFB6OHhEQ0k2VEZKMlZuTCtEQUVkRlFISUZSMGRGY2dDRHgxZ0FSMFZBV1FWSFIwVlpBSVBIUVFCSFJVQlpCVWRIUlZrQWc4ZEFBRUFBQUFBQXlBRElBQWpBQWF6Q3dBQkxTc0JGd2MxSXdjZkFUTTFGd2MxSXlJdkFRY0dLd0UxTXpjdkFTTTFNeklmQVRjMk93RUNXTWpJTXBtdkJoYkl5Qmt1SUthWkh5OWtaS2FqQTJSa0xpQ1pqUjh2TWdNZ2xwWmt2ODREWkphV1pDYSt2aVprenI4RFpDYXlzaVlBQUFBQUFRQUFBQUFESUFNZ0FCVUFCck1RQUFFdEt3RXlGemNSSVRjbUl5SUdGQll5TnhjR0l5SW1FRFlCa0tKM2QvN1ViVmw0ZkxDdytGaElkS2lsNitzRElIZDMvdFJ0VzdENHNGaElkT3NCU3VzQUFBQUFBUUFBQUFBRElBTWdBQWtBQnJNRkFBRXRLd0VoRVNjQkZ5RVJGd0VCa0FHUXB2NXdwdjV3cGdHUUF5RCtjS2IrY0tZQmtLWUJrQUFCQUFBQUFBSDBBeUFBQ1FBR3N3VUFBUzByR3dFakZUTUxBVE0xSS9yNnlNajYrc2pJQXlEKzFNaisxQUVzeUFBQkFBQUFaQU1nQWxnQUNRQUdzd1VBQVMwckFSVXpOUTBCTlNNVkpRRXN5QUVzL3RUSS90UUNXTWpJK3ZySXlQb0FBQUFBQXdBQUFBQURJQU1nQUFvQUVnQVhBQXEzRmhNT0N3VUFBeTByRVRJRUZoSVZJelFDSkNNVk1nQVZJelFtSXhVeUZoVWpvZ0VwMW4vSW9QN3NwTTRCSnNpdmZWSjJ5QU1nZjliKzE2S2tBUlNnWlA3YXpuMnZaSFpTQUFBRUFBQUFBQU1nQXlBQUNnQVRBQnNBSXdBTlFBb2dIQmNVRHdzRUFBUXRLeE15QkJJVkl6UXVBaU1WTWg0QkZTTTBKaU1WTWhZVkl6UW1Jd1l5RmhRR0lpWTBaTDRCUXJ4a1g2RGZlb2ptaG1UcXBueXdaSFZUS1ZJN08xSTdBeUM4L3I2K2V0K2dYMlNHNW9pbTZtU3dmRk4xWkR0U096dFNBQUFBQVFBQUFBQURJQU1nQUNFQUJyTVJBQUV0S3dFaE1oWWRBU0UxTkNZaUJoMEJJUkVVQmlNaElpWTlBVE1WRkJZeU5qVVJORFlCTEFHUUtUditjQjBxSFFHUU95bitEQ2s3WkIwcUhUc0RJRHNweUpZVkhSMFYrdjdVS1RzN0tjaVdGUjBkRlFJbUtUc0FBQUFBQWdBQUFBQURJQUs4QUJJQUhRQUl0Um9UQ2dBQ0xTc1RNeFVqRVNFMU14VVVCaU1oSWlZMUVUUTJJUmNITlNNaUJnYytBVE5MNGNnQmtHUXNILzQrSHl3c0Fpekl5TWhHYkJBUjRKa0N2R1QrREdSOUh5d3NId0ltSHl6SXlHUldRNWJMQUFFQUFBQUFBeUFDdkFBTUFBYXpCd0FCTFNzSkFqVWpJZ1lITkQ0Q013SDBBU3orMUdTWTBpWXRiY2lTQXJ6KzVQN0V5SnFTZHF5TFJ3QUFBQUlBQUFBQUF5QURJQUFVQUJ3QUNMVVdGUXNCQWkwckFUY1hGZ1FYRlJRSEJnY0dJaWNtSnlZOUFUWWtFeEVGRmhjV0Z4WUJmUk1USlFFT1NwTTlRRWh3U0VBOWswb0JEamorMmd4dU9ESXJBeGNKQ1E5ekhoL2d3MUV2TlRVdlVjWGVIeDV6L1Z3Q1QzcTFrMG9rSHdBRUFBQUFBQUs4QXlBQUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLd0V6RVNNRE14RWpBek1SSXdNekVTTUNXR1JreUdSa3lHUmt5R1JrQXlEODRBSzgvVVFCOVA0TUFTeisxQUFBQUFFQUFBQUFBcndESUFBTkFBYXpCd0FCTFNzQk14VXpGd2NqRVNNUkl5YzNNd0VzWk1oa1pNaGt5R1JreUFNZ3lHUmsvbkFCOUdSa0FBQUFBQVFBQUFBQUF5QURJQUFHQUFvQURnQVNBQTFBQ2hFUERRc0pCd1FBQkMwckV6TVJNd2NuTXhNekZTTVZJUlVoRlNFVkljaGt5UHI2eU1qSXlBRXMvdFFCa1A1d0F5RDlxTWpJQWxoa1pHUmtaQUFBQUFRQUFBQUFBeUFESUFBR0FBb0FEZ0FTQUExQUNoRVBEUXNKQndRQUJDMHJFek1STXdjbk14TWhGU0VWSVJVaEZUTVZJOGhreVByNnlNZ0JrUDV3QVN6KzFNaklBeUQ5cU1qSUFsaGtaR1JrWkFBQUFBY0FBQUFBQXlBQ3ZBQVBBQk1BRndBYkFCOEFJd0FuQUJOQUVDVWtJU0FkSEJrWUZSUVJFQWNBQnkwckV5RXlGaFVSRkFZaklTSW1OUkUwTmhjVk16VXpGU0UxQlJVek5UTVZJVFVGRlRNMU14VWhOVXNDaWg4c0xCLzlkaDhzTERoa1pBR1EvYWhrWkFHUS9haGtaQUdRQXJ3c0gvM2FIeXdzSHdJbUh5eGtaR1JrWk1oa1pHUmt5R1JrWkdRQUFBRUFBQUFBQXlBRElBQUpBQWF6QkFBQkxTc0JFeUVIRXljSEV5Y2hBWkJrQVN6NlpQcjZaUG9CTEFNZy90VEkvdFRJeUFFc3lBQUFDUUFBQUFBRElBTWdBQWNBRHdBWEFCOEFKd0F2QURjQVB3QkhBQmRBRkVSQVBEZzBNQ3dvSkNBY0dCUVFEQWdFQUFrdEt3QXlGaFFHSWlZMEJqSVdGQVlpSmpRa01oWVVCaUltTkFReUZoUUdJaVkwQmpJV0ZBWWlKalFrTWhZVUJpSW1OQVF5RmhRR0lpWTBKRElXRkFZaUpqUUdNaFlVQmlJbU5BRjdLaDBkS2gzZEtoMGRLaDBDRVNvZEhTb2QvdWFrZG5ha2Rxc3FIUjBxSFFMWktoMGRLaDM5eFNvZEhTb2RBaEVxSFIwcUhkMHFIUjBxSFFNZ0hTb2RIU3BISFNvZEhTb2RIU29kSFNwSGRxUjJkcVFnSFNvZEhTb2RIU29kSFNyZEhTb2RIU29kSFNvZEhTcEhIU29kSFNvQUF3QUFBQUFDdkFNZ0FBOEFFd0FaQUFxM0Z4UVJFQWNBQXkwckV5RXlGaFVSRkFZaklTSW1OUkUwTmhjUklSRUNJZ1lXTWpZaUFuZ09GQlFPL1lnT0ZCUlFBZlRkT2gwY1BCd0RJQlFPL1NRT0ZCUU9BdHdPRkdUK0RBSDAvZG95TWpJQUFBSUFBQUFBQXlBRElBQUVBQXdBQ0xVSkJRTUFBaTByRVNFSkFqWWlCaFFXTWpZMEFTd0I5UDdVL2d6eFVqczdVanNESVA0TS90UUI5TWc3VWpzN1VnQURBQUFBWkFNZ0FsZ0FCQUFLQUJJQUNyY1BDd2dGQXdBRExTc1JNd0VIQVNVekFRY25OeVFpQmhRV01qWTB5QUVzeVA3VUFWU2dBU3pJVG5mK0tpb2RIU29kQWxqKzFNZ0JMTWorMU1oT2VzZ2RLaDBkS2dBQUJBQUFBQUFESUFNZ0FBY0FEd0FYQUI4QURVQUtIQmdVRUF3SUJBQUVMU3NTSUJZUUJpQW1FQ1FpQmhRV01qWTBKRElXRkFZaUpqUTJJZ1lVRmpJMk5Pc0JTdXZyL3JickFnejRzTEQ0c1A2Q3BIWjJwSGJ5VkRvNlZEb0RJT3YrdHV2ckFVcUhzUGl3c1BoTWRxUjJkcVFTT2xRNk9sUUFBZ0FBQUFBRElBSzhBQWtBRHdBSXRRd0tDQUFDTFNzUklRY2hFU0UxTnhFaEFSY0JKemNYQWk5ay9wa0I5R1Q5UkFLOFpQNXd5R1JrQXJ4ay9neWZaUDZaQXJ4ay9uRElaR1FBQUFNQUFBQUFBeUFESUFBTEFCRUFGUUFLdHhNU0VBd0ZBQU10S3hNaE1oVVJGQ01oSWpVUk5CY0hGd2NYTnhjVklUVUpBdzRKQ2Z6eUNaWklaR1JJckU0QkxBTWdDZnp5Q1FrRERnbE9TR1JrU0t3eVpHUUFBQUFCQUFBQUFBTWdBeUFBR1FBR3N3MEFBUzByRVNFVkl6UW1Ld0VSRkJZN0FSVWhOVE15TmpVUkl5SUdGU01ESURJN0taWWRGVEwrY0RJVkhaWXBPeklESU1ncE8vM2FGUjFrWkIwVkFpWTdLUUFBQUFBQ0FBQUFBd0s4QXJ3QUF3QWRBQWkxRlFRQ0FBSXRLeEV6RVNNVElUSVhFaFVVQmlzQklnWVZGQmNXRGdFbUp5NENKeVlqWkdUSUFWNGhEbWNkRlpZVUhpOEdFaVlrQ3dJK09BZ2NMQUs4L25BQmtCLyszUndWSFI4VEg1a1VKUXdSRkFON2FBZ2NBQUlBQUFBQUFyd0N2QUFjQUNBQUNMVWZIUlFDQWkwckFUWTNGeDRCQndZVkZCWTdBVElXRlJRR0R3RUdJeUVSTWpjK0FnRXpFU01Ca0JBZkV4TVNCaThlRkpZVkhUUWFHUTRoL3FJc0hBZzRQdjV5WkdRQ21oOERBd1lsRkprZkV4OGRGUXlnU2trZkFaQWNDR2g3L3ZuK2NBQUFBZ0FBLzV3Q3ZBSzhBQjhBS2dBSXRTTWdGd0FDTFNzVElSVWpGUllYQnlZaklnWVVGakkyTlRRbk54WVZGQVlnSmpVME5qYzFJd1VBQndZaUpqUTNQZ0UzeUFFc1pESVdJaWt2YUpLUzBKSVFXeG5OL3Q3TnJJQmtBZlQrMkJRUEpoNFBDY0JiQXJ4a0JnZ0lYaENTMEpLU2FDOHBKVVE1a2MzTmtZUEdFZ01RL3FRVUR4NG1Ed21XUndBQ0FBQUFBQU1nQXJ3QUJnQU5BQWkxREFjQ0FBSXRLd0VYQnpVaE5TRUJGU0VWSVJVbkFsakl5UDJvQWxqK2NBSlkvYWpJQXJ5V2xtUmsvdFJrWkdTV0FBQUFBQUlBQUFBQUFyd0RJQUFQQUNjQUNMVWpFQWdBQWkwckFUTXlGaFV6TWhZVklUUTJPd0UwTmdNekVSUVdNalkxRVRNUkZCWXlOalVSTXhFVUl5RWlOUUVzWkNrN1pDazcvVVE3S1dRN24yUWRLaDFrSFNvZFpCUCtNaE1ESURzcE95a3BPeWs3L3RUK29oVWRIUlVCWHY2aUZSMGRGUUZlL2g4VEV3QUNBQUFBQUFLOEF5QUFFUUFWQUFpMUZCSU1BQUl0S3hNekVSUVdNalkxRVRNUkZBWXJBU0ltTlFNaEZTRmt5RHRTTzJSMlVqSm5rMlFDdlAxRUF5RCtjQ2s3T3lrQmtQNXdVbloxVS83VVpBQUFBQUFFQUFBQUFBTWdBcndBQ3dBWEFDTUFKd0FOUUFvbUpCMFlFUXdGQUFRdEt4TXpNaFVSRkNzQklqVVJOQ0V6TWhVUkZDc0JJalVSTkFVek1oVVJGQ3NCSWpVUk5BRWhGU0VKdGdrSnRna0NZYllKQ2JZSi90MjJDUW0yQ2Y3VUF5RDg0QUs4Q2Y0ZUNRa0I0Z2tKL2g0SkNRSGlDY2dKL3VZSkNRRWFDZjV3WkFBQUFBQUhBQUFBQUFNZ0Fyd0FCd0FQQUJjQUd3QWpBQ3NBTXdBVFFCQXZMQ2NrSHh3YUdCUVFEQWdFQUFjdEt4TXpNaDBCSXpVMElUTXlIUUVqTlRRRk16SWRBU00xTkFVaEZTRVZNeFVVS3dFaU5TVXpGUlFyQVNJMUpUTVZGQ3NCSWpVS3RRbklBbUsxQ2NqKzNyVUp5UDdVQXlEODRNZ0p0Z2tCTE1nSnRRb0JMTWdKdFFvQ3ZBbS92d2tKdjc4SlpBbGJXd25JWkdTL0NRbS9Xd2tKVzc4SkNRQUFBQVFBQUFBQUF5QUN2QUFEQUE4QUd3QW5BQTFBQ2lFY0ZSQUpCQUlBQkMwckVTRVZJUmN6TWhVUkZDc0JJalVSTkNFek1oVVJGQ3NCSWpVUk5DRXpNaFVSRkNzQklqVVJOQU1nL09BSnRna0p0Z2tCTmJZSkNiWUpBVFcyQ1FtMkNRSzhaR1FKL2g0SkNRSGlDUW4rNWdrSkFSb0pDZjRlQ1FrQjRna0FBQUFBQVFBQUFHUURJQUpZQUJVQUJyTU5BQUV0S3hNaE1oWWRBVGN6RVNNbkZSUUdJeUVpSmpVUk5EWXlBZlFWSFdSa1pHUWRGZjRNRlIwZEFsZ2RGWlprL3RSa2xoVWRIUlVCa0JVZEFBTUFBQUFBQXlBRElBQUhBQndBSkFBS3R5UWRFZ2tDQUFNdEt3RXpFU01uSXhFeklUVXlGeDRCRkFZSEl3WWpOVEkzUGdFMEppY21CeGNlQVJRR0R3RUJUa0pDaHNqSUFTd2xKbUovZjJJRElpWWFHRUZWVlVFWUdoa2hLaXNnR1FNZy9PRElBWkJrQ2htaDBLSVpDV1FHRVd1TWF4RUdaQU1JTjBRM0NBTUFBZ0FBQUFBQ1dBTWdBQWNBRHdBSXRROElBZ0FDTFNzQk14RWpKeU1STXdVWEhnRVVCZzhCQVU1Q1FvYkl5QUVzR1NFcUt5QVpBeUQ4NE1nQmtHUURDRGRFTndnREFBQUFBUUFBQUFBQmtBTWdBQWNBQnJNQ0FBRXRLd0V6RVNNbkl4RXpBVTVDUW9iSXlBTWcvT0RJQVpBQUFBQURBQUFBQUFLOEF5QUFEd0FUQUJjQUNyY1ZGQkVRQndBRExTc0JNeklYQVJjVkZDTWhJajBCTndFMkF4VXpOUU1WTXpVQk5WSUlCQUVtQXduOVZna0RBU1lFQVdSa1pBTWdDZjFXRTFFSkNWRVRBcW9KL3RUSXlQN1VaR1FBQUFBREFBQUFBQUx4QXlBQUNRQVNBQm9BQ3JjWEV3MEtBd0FETFNzQk1oY0hKaU1pQnljMkVqSVhCeVlqSWdjbkZqSVdGQVlpSmpRQmQ5Q3FOWTI0czQ4MXFsanFZelZJVzFWS05xeFNPenRTT3dNZ2JWSmJXMUp0L3RRK1ZTOHZWZTQ3VWpzN1VnQUFBQUlBQUFBQUF5RURJQUFaQUNFQUNMVWVHZzhBQWkwckFUSVhCeFV6TnhZVkZBWWpJaWNCQmlJbkpqUTNBU1kxTkRZQUlnWVVGakkyTkFJbklBOWh5R0VEazJjcU1QN2dIRmdjSFIwQkl4T1Qvcm9xSFIwcUhRTWdBMkhJWVE4Z2FKSVQvdDBjSEIxV0hRRWZNQ3Rva3YxMkhTb2RIU29BQUFFQUFQK3NBeEFDdkFBWEFBYXpEUUFCTFNzVEZoYytBamNYQng0Q0Z3Y3VBaWNISnpZM0ppZU5BZndiWmxJa2ovMGNabFVtanlSVFpSdjlqVFBIK1FFQ3ZBSDVIR1ZUSm8zOUcyVlRKSThtVldZYy9ZOHd4L3dCQUFBQUFRQUFBQUFDdkFNZ0FCY0FCck1PQUFFdEt4RXpFek1UTXdNekZTRVZJUlVoRlNNMUlUVWhOU0UxTTJUbkp1ZGs0ZUgrMUFFcy90UmsvdFFCTFA3VTRRTWcvdFFCTFA3VVpHUmt5TWhrWkdRQUFBQUFBd0FBLy80RElnTWdBQmtBSndBekFBcTNMaWdlR2cwQUF5MHJFaUFXRlJRSEZoOEJIZ0VWRkFZaklpWXZBU1luQmlNaUpoQWtJZ1lVRmpNeU56WS9BVFkxTkNVekZUTVZJeFVqTlNNMU04MEJJczBzQ0FWbkRCSThLaEVyREdRRkJFOWFrYzBCeHRDU2ttaGNSdzRSQXpYKzFHUmtaR1JrWkFNZ3paRllVUVFGWkF3ckVTbzhFZ3huQlFnc3pRRWlhWkxRa2p3WENBTkRXV2d1WkdSa1pHUUFBQUFEQUFELy9nTWlBeUFBR1FBbkFDc0FDcmNxS0I0YURRQURMU3NTSUJZVkZBY1dId0VlQVJVVUJpTWlKaThCSmljR0l5SW1FQ1FpQmhRV016STNOajhCTmpVMEJTRVZJYzBCSXMwc0NBVm5EQkk4S2hFckRHUUZCRTlha2MwQnh0Q1NrbWhjUnc0UkF6WCtjQUVzL3RRRElNMlJXRkVFQldRTUt4RXFQQklNWndVSUxNMEJJbW1TMEpJOEZ3Z0RRMWxvTm1RQUFRQUFBQUVabVNzTGpCbGZEenoxQUFzRElBQUFBQURQMlM5cUFBQUFBTS9aTDJvQUFQK2JBeUlESUFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVArYkFFZ0RoQUFBQUFBRElnQUJBQUFBQUFBQUFBQUFBQUFBQUFBQTRRRWdBQm9BQUFBQUFRb0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQWxnQUFBTWdBQUFCa0FBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQmtBQUFBWkFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFPRUFBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUE0UUFBQUpZQUFBRGhBQUFBbGdBQUFKWUFBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUs4QUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWZRQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUFaQUFBQU1nQUFBRElBQUFBNFFBQUFNZ0FBQURJQUFBQTRRQUFBQUFBQUFBQUFBV0FCWUFGZ0E0QUZvQWVBQ1lBTUFBNWdFT0FVd0JZZ0dJQWE0QjBnSDJBZ3dDSWdJNEFrNENaQUo2QW80Q3RnTUFBeUlEVkFOMkE4Z0Q3Z1FNQkZZRWZnU3FCT2dFL0FVc0JUNEZYZ1djQmRZR0lBWllCdUlIRmdkWUI1UUg1QWYwQ0FZSUdBZ3FDSGdJbGdpMkNNd0k0Z2o0Q1E0Sk1nbGVDWm9KekFvUUNrWUthZ3FnQ3NZTERBc3FDMGdMYUF1R0Mvb01FZ3hNREc0TW9BelVEUVlOWUEyQURad054QTN5RGlRT2RnNlNEcXdPMWc3K0R6WVBUZzltRDRRUG9BL0tFQVlRT0JCV0VIWVFsQkN5RU5ZUktCRnNFWWdSekJIcUVnWVNLQkp3RXBJU3RoTStFMkFUMGhRYUZFWVVnQlRJRlFBVkhoVTRGVm9WZ0JYSUZnUVdKaFpNRm5JV21CYklGdndYSWhlWUdCWVltQmpRR1NnWlBCbGdHWUlacWhuU0dmNGFQQnBvR3JRYXpCcmVHdlFiREJza0d6d2JWQnRrRzM0Ym5CdndIQUFjT0J4WUhJQWNzaHorSFJvZFpCMk1IYm9kN0I0aUhrQWVYQjZVSHNJZTdoOGlIM1lmd0NBK0lIZ2dvaUMrSU5ZZzhDRWVJVndoa2lIRUllSWlHaUpDSW1BaWlpSzBJdndqR0NPUUk4SWo0aVFPSkVva2NDU2NKTVlrK2lVMEpYb2xuQ1hhSmdRbVJpYVlKdGdtL2ljK0oySW5lQ2VvSjl3b0dDaEdLSEFvd2lrTUFBQUFBUUFBQU9JQWFBQVFBQUFBQUFBQ0FBQUFBQUJ6QUFBQU5ndHNBQUFBQUFBQUFBNEFyZ0FCQUFBQUFBQUFBRUlBaGdBQkFBQUFBQUFCQUFVQTFRQUJBQUFBQUFBQ0FBWUE2UUFCQUFBQUFBQURBQ1FCT2dBQkFBQUFBQUFFQUFrQmN3QUJBQUFBQUFBRkFBNEJtd0FCQUFBQUFBQUdBQXNCd2dBREFBRUVDUUFBQUlRQUFBQURBQUVFQ1FBQkFBb0F5UUFEQUFFRUNRQUNBQXdBMndBREFBRUVDUUFEQUVnQThBQURBQUVFQ1FBRUFCSUJYd0FEQUFFRUNRQUZBQndCZlFBREFBRUVDUUFHQUJZQnFnQkRBSElBWlFCaEFIUUFaUUJrQUNBQVlnQjVBQ0FBVUFBdUFFb0FMZ0FnQUU4QWJnQnZBSElBYVFBZ0FIY0FhUUIwQUdnQUlBQkdBRzhBYmdCMEFFWUFid0J5QUdjQVpRQWdBRElBTGdBd0FDQUFLQUJvQUhRQWRBQndBRG9BTHdBdkFHWUFid0J1QUhRQVpnQnZBSElBWndCbEFDNEFjd0JtQUM0QWJnQmxBSFFBS1FBQVEzSmxZWFJsWkNCaWVTQlFMa291SUU5dWIzSnBJSGRwZEdnZ1JtOXVkRVp2Y21kbElESXVNQ0FvYUhSMGNEb3ZMMlp2Ym5SbWIzSm5aUzV6Wmk1dVpYUXBBQUJKQUdNQWJ3QnVBSE1BQUVsamIyNXpBQUJwQUdNQWJ3QnVBR2tBWXdBQWFXTnZibWxqQUFCR0FHOEFiZ0IwQUVZQWJ3QnlBR2NBWlFBZ0FESUFMZ0F3QUNBQU9nQWdBRlVBYmdCMEFHa0FkQUJzQUdVQVpBQXhBQ0FBT2dBZ0FERUFMUUEzQUMwQU1nQXdBREVBTkFBQVJtOXVkRVp2Y21kbElESXVNQ0E2SUZWdWRHbDBiR1ZrTVNBNklERXROeTB5TURFMEFBQlZBRzRBZEFCcEFIUUFiQUJsQUdRQU1RQUFWVzUwYVhSc1pXUXhBQUJXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURFQUxnQXhBQ0FBQUZabGNuTnBiMjRnTVM0eExqRWdBQUJ2QUhBQVpRQnVBQzBBYVFCakFHOEFiZ0JwQUdNQUFHOXdaVzR0YVdOdmJtbGpBQUFDQUFBQUFBQUEvNE1BTWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPSUFBQUFCQUFJQkFnRURBUVFCQlFFR0FRY0JDQUVKQVFvQkN3QkVBRVVBUmdCSEFFZ0FTUUVNQVEwQkRnRVBBUkFCRVFFU0FSTUJGQUVWQVJZQkZ3RVlBUmtCR2dFYkFSd0JIUUVlQVI4QklBRWhBU0lCSXdFa0FTVUJKZ0VuQVNnQktRRXFBU3NCTEFFdEFTNEJMd0V3QVRFQk1nRXpBVFFCTlFFMkFUY0JPQUU1QVRvQk93RThBVDBCUGdFL0FVQUJRUUZDQVVNQlJBRkZBVVlCUndGSUFVa0JTZ0ZMQVV3QlRRRk9BVThCVUFGUkFWSUJVd0ZVQVZVQlZnRlhBVmdCV1FGYUFWc0JYQUZkQVY0Qlh3RmdBV0VCWWdGakFXUUJaUUZtQVdjQmFBRnBBV29CYXdGc0FXMEJiZ0Z2QVhBQmNRRnlBWE1CZEFGMUFYWUJkd0Y0QVhrQmVnRjdBWHdCZlFGK0FYOEJnQUdCQVlJQmd3R0VBWVVCaGdHSEFZZ0JpUUdLQVlzQmpBR05BWTRCandHUUFaRUJrZ0dUQVpRQmxRR1dBWmNCbUFHWkFab0Jtd0djQVowQm5nR2ZBYUFCb1FHaUFhTUJwQUdsQWFZQnB3R29BYWtBb0FHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnVBRzVBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJ4d0hJQWNrQnlnSExBY3dCelFIT0FjOEIwQUhSQWRJQjB3SFVBZFVCMWdIWEFkZ0IyUUFCTVFFeUFUTUJOQUUxQVRZQk53RTRBVGtDTVRBQ01URUNNVElDTVRNQ01UUUNNVFVDTVRZQ01UY0NNVGdDTVRrQ01XRUNNV0lDTVdNQ01XUUNNV1VDTVdZQ01qQUNNakVDTWpJQ01qTUNNalFDTWpVQ01qWUNNamNDTWpnQ01qa0NNbUVDTW1JQ01tTUNNbVFDTW1VQ01tWUNNekFDTXpFQ016SUNNek1DTXpRQ016VUNNellDTXpjQ016Z0NNemtDTTJFQ00ySUNNMk1DTTJRQ00yVUNNMllDTkRBQ05ERUNORElDTkRNQ05EUUNORFVDTkRZQ05EY0NORGdDTkRrQ05HRUNOR0lDTkdNQ05HUUNOR1VDTkdZQ05UQUNOVEVDTlRJQ05UTUNOVFFDTlRVQ05UWUNOVGNDTlRnQ05Ua0NOV0VDTldJQ05XTUNOV1FDTldVQ05XWUNOakFDTmpFQ05qSUNOak1DTmpRQ05qVUNOallDTmpjQ05qZ0NOamtDTm1FQ05tSUNObU1DTm1RQ05tVUNObVlDTnpBQ056RUNOeklDTnpNQ056UUNOelVDTnpZQ056Y0NOemdDTnprQ04yRUNOMklDTjJNQ04yUUNOMlVDTjJZQ09EQUNPREVDT0RJQ09ETUNPRFFDT0RVQ09EWUNPRGNDT0RnQ09Ea0NPR0VDT0dJQ09HTUNPR1FDT0dVQ09HWUNPVEFDT1RFQ09USUNPVE1DT1RRQ09UVUNPVFlDT1RjQ09UZ0NPVGtDT1dFQ09XSUNPV01DT1dRQ09XVUNPV1lDWVRBQ1lURUNZVElDWVRNQ1lUUUNZVFVDWVRZQ1lUY0NZVGdDWVRrQ1lXRUNZV0lDWVdNQ1lXUUNZV1lDWWpBQ1lqRUNZaklDWWpNQ1lqUUNZalVDWWpZQ1lqY0NZamdDWWprQ1ltRUNZbUlDWW1NQ1ltUUNZbVVDWW1ZQ1l6QUNZekVDWXpJQ1l6TUNZelFDWXpVQ1l6WUNZemNDWXpnQ1l6a0NZMkVDWTJJQ1kyTUNZMlFDWTJVQ1kyWUNaREFDWkRFQ1pESUNaRE1DWkRRQ1pEVUNaRFlDWkRjQ1pEZ0NaRGtDWkdFQ1pHSUNaR01DWkdRQ1pHVUFBQUVBQWYvL0FBOEFBQUFBQUFBQUFBQUFBQUN3QUN3Z3NBQlZXRVZaSUNCTHVBQU9VVXV3QmxOYVdMQTBHN0FvV1dCbUlJcFZXTEFDSldHNUNBQUlBR05qSTJJYklTR3dBRm13QUVNalJMSUFBUUJEWUVJdHNBRXNzQ0JnWmkyd0Fpd2daQ0N3d0ZDd0JDWmFzaWdCQ2tORlkwVlNXMWdoSXlFYmlsZ2dzRkJRV0NHd1FGa2JJTEE0VUZnaHNEaFpXU0N4QVFwRFJXTkZZV1N3S0ZCWUliRUJDa05GWTBVZ3NEQlFXQ0d3TUZrYklMREFVRmdnWmlDS2ltRWdzQXBRV0dBYklMQWdVRmdoc0FwZ0d5Q3dObEJZSWJBMllCdGdXVmxaRzdBQksxbFpJN0FBVUZobFdWa3RzQU1zSUVVZ3NBUWxZV1Fnc0FWRFVGaXdCU05Dc0FZalFoc2hJVm13QVdBdHNBUXNJeUVqSVNCa3NRVmlRaUN3QmlOQ3NRRUtRMFZqc0FwRHNBQmdSYkFES2lFZ3NBWkRJSW9naXJBQks3RXdCU1dLVVZoZ1VCdGhVbGxZSTFraElMQkFVMWl3QVNzYkliQkFXU093QUZCWVpWa3RzQVVzc0FkREs3SUFBZ0JEWUVJdHNBWXNzQWNqUWlNZ3NBQWpRbUd3QW1KbXNBRmpzQUZnc0FVcUxiQUhMQ0FnUlNDd0MwTmp1QVFBWWlDd0FGQllzRUJnV1dhd0FXTmdSTEFCWUMyd0NDeXlCd3NBUTBWQ0tpR3lBQUVBUTJCQ0xiQUpMTEFBUXlORXNnQUJBRU5nUWkyd0Npd2dJRVVnc0FFckk3QUFRN0FFSldBZ1JZb2pZU0JrSUxBZ1VGZ2hzQUFic0RCUVdMQWdHN0JBV1ZranNBQlFXR1Zac0FNbEkyRkVSTEFCWUMyd0N5d2dJRVVnc0FFckk3QUFRN0FFSldBZ1JZb2pZU0Jrc0NSUVdMQUFHN0JBV1NPd0FGQllaVm13QXlVallVUkVzQUZnTGJBTUxDQ3dBQ05Dc2dzS0EwVllJUnNqSVZrcUlTMndEU3l4QWdKRnNHUmhSQzJ3RGl5d0FXQWdJTEFNUTBxd0FGQllJTEFNSTBKWnNBMURTckFBVWxnZ3NBMGpRbGt0c0E4c0lMQVFZbWF3QVdNZ3VBUUFZNG9qWWJBT1EyQWdpbUFnc0E0alFpTXRzQkFzUzFSWXNRUmtSRmtrc0ExbEkzZ3RzQkVzUzFGWVMxTllzUVJrUkZrYklWa2tzQk5sSTNndHNCSXNzUUFQUTFWWXNROFBRN0FCWVVLd0R5dFpzQUJEc0FJbFFyRU1BaVZDc1EwQ0pVS3dBUllqSUxBREpWQllzUUVBUTJDd0JDVkNpb29naWlOaHNBNHFJU093QVdFZ2lpTmhzQTRxSVJ1eEFRQkRZTEFDSlVLd0FpVmhzQTRxSVZtd0RFTkhzQTFEUjJDd0FtSWdzQUJRV0xCQVlGbG1zQUZqSUxBTFEyTzRCQUJpSUxBQVVGaXdRR0JaWnJBQlkyQ3hBQUFUSTBTd0FVT3dBRDZ5QVFFQlEyQkNMYkFUTEFDeEFBSkZWRml3RHlOQ0lFV3dDeU5Dc0FvanNBQmdRaUJnc0FGaHRSQVFBUUFPQUVKQ2ltQ3hFZ1lyc0hJckd5SlpMYkFVTExFQUV5c3RzQlVzc1FFVEt5MndGaXl4QWhNckxiQVhMTEVERXlzdHNCZ3NzUVFUS3kyd0dTeXhCUk1yTGJBYUxMRUdFeXN0c0Jzc3NRY1RLeTJ3SEN5eENCTXJMYkFkTExFSkV5c3RzQjRzQUxBTks3RUFBa1ZVV0xBUEkwSWdSYkFMSTBLd0NpT3dBR0JDSUdDd0FXRzFFQkFCQUE0QVFrS0tZTEVTQml1d2Npc2JJbGt0c0I4c3NRQWVLeTJ3SUN5eEFSNHJMYkFoTExFQ0hpc3RzQ0lzc1FNZUt5MndJeXl4QkI0ckxiQWtMTEVGSGlzdHNDVXNzUVllS3kyd0ppeXhCeDRyTGJBbkxMRUlIaXN0c0Nnc3NRa2VLeTJ3S1N3Z1BMQUJZQzJ3S2l3Z1lMQVFZQ0JESTdBQllFT3dBaVZoc0FGZ3NDa3FJUzJ3S3l5d0tpdXdLaW90c0N3c0lDQkhJQ0N3QzBOanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ0kyRTRJeUNLVlZnZ1J5QWdzQXREWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqWUNOaE9Cc2hXUzJ3TFN3QXNRQUNSVlJZc0FFV3NDd3FzQUVWTUJzaVdTMndMaXdBc0EwcnNRQUNSVlJZc0FFV3NDd3FzQUVWTUJzaVdTMndMeXdnTmJBQllDMndNQ3dBc0FGRlk3Z0VBR0lnc0FCUVdMQkFZRmxtc0FGanNBRXJzQXREWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqc0FFcnNBQVd0QUFBQUFBQVJENGpPTEV2QVJVcUxiQXhMQ0E4SUVjZ3NBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZTEFBUTJFNExiQXlMQzRYUEMyd015d2dQQ0JISUxBTFEyTzRCQUJpSUxBQVVGaXdRR0JaWnJBQlkyQ3dBRU5oc0FGRFl6Z3RzRFFzc1FJQUZpVWdMaUJIc0FBalFyQUNKVW1LaWtjalJ5TmhJRmhpR3lGWnNBRWpRckl6QVFFVkZDb3RzRFVzc0FBV3NBUWxzQVFsUnlOSEkyR3dDVU1yWllvdUl5QWdQSW80TGJBMkxMQUFGckFFSmJBRUpTQXVSeU5ISTJFZ3NBUWpRckFKUXlzZ3NHQlFXQ0N3UUZGWXN3SWdBeUFic3dJbUF4cFpRa0lqSUxBSVF5Q0tJMGNqUnlOaEkwWmdzQVJEc0FKaUlMQUFVRml3UUdCWlpyQUJZMkFnc0FFcklJcUtZU0N3QWtOZ1pDT3dBME5oWkZCWXNBSkRZUnV3QTBOZ1diQURKYkFDWWlDd0FGQllzRUJnV1dhd0FXTmhJeUFnc0FRbUkwWmhPQnNqc0FoRFJyQUNKYkFJUTBjalJ5TmhZQ0N3QkVPd0FtSWdzQUJRV0xCQVlGbG1zQUZqWUNNZ3NBRXJJN0FFUTJDd0FTdXdCU1Zoc0FVbHNBSmlJTEFBVUZpd1FHQlpackFCWTdBRUptRWdzQVFsWUdRanNBTWxZR1JRV0NFYkl5RlpJeUFnc0FRbUkwWmhPRmt0c0Rjc3NBQVdJQ0Fnc0FVbUlDNUhJMGNqWVNNOE9DMndPQ3l3QUJZZ3NBZ2pRaUFnSUVZalI3QUJLeU5oT0Myd09TeXdBQmF3QXlXd0FpVkhJMGNqWWJBQVZGZ3VJRHdqSVJ1d0FpV3dBaVZISTBjallTQ3dCU1d3QkNWSEkwY2pZYkFHSmJBRkpVbXdBaVZodVFnQUNBQmpZeU1nV0dJYklWbGp1QVFBWWlDd0FGQllzRUJnV1dhd0FXTmdJeTRqSUNBOGlqZ2pJVmt0c0Rvc3NBQVdJTEFJUXlBdVJ5TkhJMkVnWUxBZ1lHYXdBbUlnc0FCUVdMQkFZRmxtc0FGakl5QWdQSW80TGJBN0xDTWdMa2F3QWlWR1VsZ2dQRmt1c1NzQkZDc3RzRHdzSXlBdVJyQUNKVVpRV0NBOFdTNnhLd0VVS3kyd1BTd2pJQzVHc0FJbFJsSllJRHhaSXlBdVJyQUNKVVpRV0NBOFdTNnhLd0VVS3kyd1BpeXdOU3NqSUM1R3NBSWxSbEpZSUR4WkxyRXJBUlFyTGJBL0xMQTJLNG9nSUR5d0JDTkNpamdqSUM1R3NBSWxSbEpZSUR4WkxyRXJBUlFyc0FSRExyQXJLeTJ3UUN5d0FCYXdCQ1d3QkNZZ0xrY2pSeU5oc0FsREt5TWdQQ0F1SXppeEt3RVVLeTJ3UVN5eENBUWxRckFBRnJBRUpiQUVKU0F1UnlOSEkyRWdzQVFqUXJBSlF5c2dzR0JRV0NDd1FGRllzd0lnQXlBYnN3SW1BeHBaUWtJaklFZXdCRU93QW1JZ3NBQlFXTEJBWUZsbXNBRmpZQ0N3QVNzZ2lvcGhJTEFDUTJCa0k3QURRMkZrVUZpd0FrTmhHN0FEUTJCWnNBTWxzQUppSUxBQVVGaXdRR0JaWnJBQlkyR3dBaVZHWVRnaklEd2pPQnNoSUNCR0kwZXdBU3NqWVRnaFdiRXJBUlFyTGJCQ0xMQTFLeTZ4S3dFVUt5MndReXl3TmlzaEl5QWdQTEFFSTBJak9MRXJBUlFyc0FSRExyQXJLeTJ3UkN5d0FCVWdSN0FBSTBLeUFBRUJGUlFUTHJBeEtpMndSU3l3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckF4S2kyd1JpeXhBQUVVRTdBeUtpMndSeXl3TkNvdHNFZ3NzQUFXUlNNZ0xpQkdpaU5oT0xFckFSUXJMYkJKTExBSUkwS3dTQ3N0c0Vvc3NnQUFRU3N0c0Vzc3NnQUJRU3N0c0V3c3NnRUFRU3N0c0Uwc3NnRUJRU3N0c0U0c3NnQUFRaXN0c0U4c3NnQUJRaXN0c0ZBc3NnRUFRaXN0c0ZFc3NnRUJRaXN0c0ZJc3NnQUFQaXN0c0ZNc3NnQUJQaXN0c0ZRc3NnRUFQaXN0c0ZVc3NnRUJQaXN0c0ZZc3NnQUFRQ3N0c0Zjc3NnQUJRQ3N0c0Znc3NnRUFRQ3N0c0Zrc3NnRUJRQ3N0c0Zvc3NnQUFReXN0c0Zzc3NnQUJReXN0c0Z3c3NnRUFReXN0c0Ywc3NnRUJReXN0c0Y0c3NnQUFQeXN0c0Y4c3NnQUJQeXN0c0dBc3NnRUFQeXN0c0dFc3NnRUJQeXN0c0dJc3NEY3JMckVyQVJRckxiQmpMTEEzSzdBN0t5MndaQ3l3Tnl1d1BDc3RzR1Vzc0FBV3NEY3JzRDByTGJCbUxMQTRLeTZ4S3dFVUt5MndaeXl3T0N1d095c3RzR2dzc0RncnNEd3JMYkJwTExBNEs3QTlLeTJ3YWl5d09Tc3VzU3NCRkNzdHNHc3NzRGtyc0RzckxiQnNMTEE1SzdBOEt5MndiU3l3T1N1d1BTc3RzRzRzc0RvckxyRXJBUlFyTGJCdkxMQTZLN0E3S3kyd2NDeXdPaXV3UENzdHNIRXNzRG9yc0QwckxiQnlMTE1KQkFJRFJWZ2hHeU1oV1VJcnNBaGxzQU1rVUhpd0FSVXdMUUJMdUFESVVsaXhBUUdPV2JBQnVRZ0FDQUJqY0xFQUJVS3hBQUFxc1FBRlFyRUFDQ3F4QUFWQ3NRQUlLckVBQlVLNUFBQUFDU3F4QUFWQ3VRQUFBQWtxc1FNQVJMRWtBWWhSV0xCQWlGaXhBMlJFc1NZQmlGRll1Z2lBQUFFRVFJaGpWRml4QXdCRVdWbFpXYkVBRENxNEFmK0ZzQVNOc1FJQVJBQT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLmVvdFxuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuZW90XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmZvbnQvb3BlbnR5cGU7YmFzZTY0LFQxUlVUd0FLQUlBQUF3QWdRMFpHSUYzTlFvb0FBQVZRQUFCSkZrWkdWRTFyOEFHa0FBQlI2QUFBQUJ4UFV5OHlOQVpSZ2dBQUFSQUFBQUJnWTIxaGNBQU40NFFBQUFQc0FBQUJRbWhsWVdRQjg3dEZBQUFBckFBQUFEWm9hR1ZoQm93RC93QUFBT1FBQUFBa2FHMTBlSm9FQUFBQUFFNW9BQUFEZm0xaGVIQUE0RkFBQUFBQkNBQUFBQVp1WVcxbGp2WVF4UUFBQVhBQUFBSjhjRzl6ZFArR0FESUFBQVV3QUFBQUlBQUJBQUFBQVJtWlFUQmpObDhQUFBVQUN3TWdBQUFBQU0vWkwyb0FBQUFBejlrdmFnQUEvNXNESWdNZ0FBQUFDQUFDQUFBQUFBQUFBQUVBQUFNZy81c0FTQU9FQUFBQUFBTWlBQUVBQUFBQUFBQUFBQUFBQUFBQUFBRGZBQUJRQUFEZ0FBQUFCQUwrQVpBQUJRQUFBZ2dDTUFBQUFIQUNDQUl3QUFBQmdBQW5BTThBQUFJQUJRTUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBVUdaRlpBREE0QURnM2dNZ0FBQUFTQU1nQUdVQUFBQUJBQUFBQUFBQUFBQUFJQUFnQUFFQUFBQU9BSzRBQVFBQUFBQUFBQUJDQUlZQUFRQUFBQUFBQVFBRkFOVUFBUUFBQUFBQUFnQUdBT2tBQVFBQUFBQUFBd0FrQVRvQUFRQUFBQUFBQkFBSkFYTUFBUUFBQUFBQUJRQU9BWnNBQVFBQUFBQUFCZ0FMQWNJQUF3QUJCQWtBQUFDRUFBQUFBd0FCQkFrQUFRQUtBTWtBQXdBQkJBa0FBZ0FNQU5zQUF3QUJCQWtBQXdCSUFQQUFBd0FCQkFrQUJBQVNBVjhBQXdBQkJBa0FCUUFjQVgwQUF3QUJCQWtBQmdBV0Fhb0FRd0J5QUdVQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUZBQUxnQktBQzRBSUFCUEFHNEFid0J5QUdrQUlBQjNBR2tBZEFCb0FDQUFSZ0J2QUc0QWRBQkdBRzhBY2dCbkFHVUFJQUF5QUM0QU1BQWdBQ2dBYUFCMEFIUUFjQUE2QUM4QUx3Qm1BRzhBYmdCMEFHWUFid0J5QUdjQVpRQXVBSE1BWmdBdUFHNEFaUUIwQUNrQUFFTnlaV0YwWldRZ1lua2dVQzVLTGlCUGJtOXlhU0IzYVhSb0lFWnZiblJHYjNKblpTQXlMakFnS0doMGRIQTZMeTltYjI1MFptOXlaMlV1YzJZdWJtVjBLUUFBU1FCakFHOEFiZ0J6QUFCSlkyOXVjd0FBYVFCakFHOEFiZ0JwQUdNQUFHbGpiMjVwWXdBQVJnQnZBRzRBZEFCR0FHOEFjZ0JuQUdVQUlBQXlBQzRBTUFBZ0FEb0FJQUJWQUc0QWRBQnBBSFFBYkFCbEFHUUFNUUFnQURvQUlBQXhBQzBBTndBdEFESUFNQUF4QURRQUFFWnZiblJHYjNKblpTQXlMakFnT2lCVmJuUnBkR3hsWkRFZ09pQXhMVGN0TWpBeE5BQUFWUUJ1QUhRQWFRQjBBR3dBWlFCa0FERUFBRlZ1ZEdsMGJHVmtNUUFBVmdCbEFISUFjd0JwQUc4QWJnQWdBREVBTGdBeEFDNEFNUUFnQUFCV1pYSnphVzl1SURFdU1TNHhJQUFBYndCd0FHVUFiZ0F0QUdrQVl3QnZBRzRBYVFCakFBQnZjR1Z1TFdsamIyNXBZd0FBQUFBREFBQUFBd0FBQUJ3QUFRQUFBQUFBUEFBREFBRUFBQUFjQUFRQUlBQUFBQVFBQkFBQkFBRGczdi8vQUFEZ0FQLy9JQUVBQVFBQUFBQUFBQUVHQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdBQUFBQUFBUCtEQURJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFCQVFBQVFFQkRHOXdaVzR0YVdOdmJtbGpBQUVDQUFFQU92anpBUGowQWZqMUF2ajJBL2dWQkI0S0FCSmZpNHNlQ2dBU1g0dUxEQWVLSnZtMitiVUZIQVFORHh3QUFCQWNCY3dSSEFBdUhFVldFZ0RjQWdBQkFBRUFBZ0FEQUFRQUJRQUdBQWNBQ0FBSkFBb0FEQUFPQUJBQUVnQVVBQllBR0FBYUFCd0FIZ0FnQUNJQUpBQW1BQ2dBS2dBc0FDNEFNQUF5QURRQU5nQTRBRG9BUEFBK0FFQUFRZ0JFQUVZQVNBQktBRXdBVGdCUUFGSUFWQUJXQUZnQVdnQmNBRjRBWUFCaUFHUUFaZ0JvQUdvQWJBQnVBSEFBY2dCMEFIWUFlQUI2QUh3QWZnQ0FBSUlBaEFDR0FJZ0FpZ0NNQUk0QWtBQ1NBSlFBbGdDWUFKb0FuQUNlQUtBQW9nQ2tBS1lBcUFDcUFLd0FyZ0N3QUxJQXRBQzJBTGdBdWdDOEFMNEF3QURDQU1RQXhnRElBTW9BekFET0FOQUEwZ0RVQU5ZQTJBRGFBTndBM2dEZ0FPSUE1QURtQU9nQTZnRHNBTzRBOEFEeUFQUUE5Z0Q0QVBvQS9BRCtBUUFCQWdFRUFRWUJDQUVLQVF3QkRnRVFBUklCRkFFV0FSZ0JHZ0VjQVI0QklBRWlBU1FCSmdFb0FTb0JMQUV1QVRBQk1nRTBBVFlCT0FFNkFUd0JQZ0ZBQVVJQlJBRkdBVWdCU2dGTUFVNEJVQUZTQVZRQlZnRllBVm9CWEFGZUFXQUJZZ0ZrQVdZQmFBRnFBV3dCYmdGd0FYSUJkQUYyQVhnQmVnRjhBWDRCZ0FHQ0FZUUJoZ0dJQVlvQmpBR09BWkFCa2dHVUFaWUJtQUdhQVp3Qm5nR2dBYUlCcEFHbUFhc0I3UUgyQWZzeE1qTTBOVFkzT0RreE1ERXhNVEl4TXpFME1UVXhOakUzTVRneE9URmhNV0l4WXpGa01XVXhaakl3TWpFeU1qSXpNalF5TlRJMk1qY3lPREk1TW1FeVlqSmpNbVF5WlRKbU16QXpNVE15TXpNek5ETTFNell6TnpNNE16a3pZVE5pTTJNelpETmxNMlkwTURReE5ESTBNelEwTkRVME5qUTNORGcwT1RSaE5HSTBZelJrTkdVMFpqVXdOVEUxTWpVek5UUTFOVFUyTlRjMU9EVTVOV0UxWWpWak5XUTFaVFZtTmpBMk1UWXlOak0yTkRZMU5qWTJOelk0TmprMllUWmlObU0yWkRabE5tWTNNRGN4TnpJM016YzBOelUzTmpjM056ZzNPVGRoTjJJM1l6ZGtOMlUzWmpnd09ERTRNamd6T0RRNE5UZzJPRGM0T0RnNU9HRTRZamhqT0dRNFpUaG1PVEE1TVRreU9UTTVORGsxT1RZNU56azRPVGs1WVRsaU9XTTVaRGxsT1daaE1HRXhZVEpoTTJFMFlUVmhObUUzWVRoaE9XRmhZV0poWTJGa1lXWmlNR0l4WWpKaU0ySTBZalZpTm1JM1lqaGlPV0poWW1KaVkySmtZbVZpWm1Nd1l6RmpNbU16WXpSak5XTTJZemRqT0dNNVkyRmpZbU5qWTJSalpXTm1aREJrTVdReVpETmtOR1ExWkRaa04yUTRaRGxrWVdSaVpHTmtaR1JsTVM0eExqRkRjbVZoZEdWa0lHSjVJRkF1U2k0Z1QyNXZjbWtnZDJsMGFDQkdiMjUwUm05eVoyVWdNaTR3SUNob2RIUndPaTh2Wm05dWRHWnZjbWRsTG5ObUxtNWxkQ2xWYm5ScGRHeGxaREZKWTI5dWN3QUFBQUdIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQUVJQVF3QkVBRVVBUmdCSEFaRUJrZ0dUQVpRQmxRR1dBWmNCbUFHWkFab0Jtd0djQVowQm5nR2ZBYUFCb1FHaUFhTUJwQUdsQWFZQnB3R29BYWtCcWdHckFhd0JyUUd1QWE4QnNBR3hBYklCc3dHMEFiVUJ0Z0czQWJnQnVRRzZBYnNCdkFHOUFiNEJ2d0hBQWNFQndnSERBY1FCeFFIR0FjY0J5QUhKQWNvQnl3SE1BYzBCemdIUEFkQUIwUUhTQWRNQjFBSFZBZFlCMXdIWUFka0IyZ0hiQWR3QjNRSGVBZDhCNEFIaEFlSUI0d0hrQWVVQjVnSG5BZWdCNlFIcUFlc0I3QUh0QWU0Qjd3SHdBZkVCOGdIekFmUUI5UUgyQWZjQitBSDVBZm9CK3dIOEFmMEIvZ0gvQWdBQ0FRSUNBZ01DQkFJRkFnWUNCd0lJQWdrQ0NnSUxBZ3dDRFFJT0FnOENFQUlSQWhJQ0V3SVVBaFVDRmdJWEFoZ0NHUUlhQWhzQ0hBSWRBaDRDSHdJZ0FpRUNJZ0lqQWlRQ0pRSW1BaWNDS0FJcEFpb0NLd0lzQWkwQ0xnQ1FBaThDTUFJeEFqSUNNd0kwQWpVQ05nSTNBamdDT1FJNkFqc0NQQUk5QWo0Q1B3SkFBa0VDUWdKREFrUUNSUUpHQWtjQ1NBSkpBa29DU3dKTUFrMENUZ0pQQWxBQ1VRSlNBbE1DVkFKVkFsWUNWd0pZQWxrQ1dnSmJBbHdDWFFKZUFPQUNBQUVBSXdCTUFIc0F2QUQ4QVNBQlJBRm9BZDhDQVFJdEFsTUNmUUttQXNRQzNRTUFBeUFET3dOZUEzOERyUVJJQkhnRXh3VDNCVjBGcHdYVEJuRUd0UWNBQjNBSGpBZlVCKzhJRndpUENSY0poUW5jQ3ZFTFRBdXpEQkVNdEF6QkROUU01QXp5RFdzTm5nM0tEZVVPQkE0akRqNE9YZzUxRHRRUERnK1dEL3NRQnhBOUVITVE3eEVSRVRRUlZoRjJFaWtTV0JLRUVxd1MzUk1wRTI0VUFoUXJGRlVVY0JUTkZSQVZxQlc3RmRJV0ZCWkpGcUlXdWhiYUZ2a1hHeGRkRitnWUtSaExHRzBZa0Jpd0dPZ1pTaG05R2RzYUxocFNHbjRhdFJ0SEcxWWJaeHdXSEQwY3VoejhIU01kZ1IzdEhtSWVsaDdGSHZnZlBSK3hJRFFnYXlDUElMTWcxeUV4SVlZaHJTS1pJNGtrZlNTNUpQVWxDU1ZISllJbHp5WVpKbUFtNVNjYko1SW5waWV6SitNbi9TZ1ZLQ29vUlNoWktJSW9ueWxSS1Z3cHVTbjhLbEVxb0Nzc0sxQXI5eXhNTEpnczlTMU5MV290a3kzN0xrOHVqQzd0TDRrditERDRNVzR4enpINk1pY3lVVEtqTXdjemJUTytNK2swVXpTSE5NazAralVyTllnMXNUWWNObTgya1RiSU52ODNPemVHTjhrNEh6aUNPUmM1U2ptNU9mbzZKanJOT3ZZN0t6dUpPNkU3c1R2NFBHRTgwajBjUFd3OW5UM0dMb3V6K0ZtekFiT3o5NFN6QTdNVzk5VDRxZnZVQnJQOGdSWDRXZmVFL0ZrSERvdnY5MXp2OTF6dkFmbFE3d01VNFBmQStWQVZJQXI4SlB0Y0ZTZjhKQ2Y0SkNjSDkxejNLZ1VPaSsvM1hPLzNYTzhCK1ZEdkF4VGc5OEQ1VUJVZ0N2enMrMXdWKzF6N0t2ZGMreXFMNy9na2k0dnYvQ1NMQlE3NDdPOEIrSWozWEFQMzh2bFFGZnRWK3pIN01mdFY5eDczQlBjRTl4NzNIdmNFK3dUN0hoOVpKd2YzWFB0YzkxejNYQ2VMaTcwRjkxWDdNZmN4KzFVZUR2anM3d0h2OTF3RCtGYjVVQlg3VmZzeCt6SDdWUjlaSndmM1hQdGM5MXozWENlTGk3MEY5eDczQlBjRTl4NzNIdmNFK3dUN0h2ZFYrekgzTWZ0VkhnNkw3Ky92Nysvdjd3SDVVQVFoQ3YxUSsxd1ZJZ3I5VVB0Y0ZTRUsvVkQ3WEJVaUNnNkw3Ky92Nysvdjd3SDVVQVFoQ3YyMCsxd1ZJZ3I4N1B0Y0ZTRUsvYlQ3WEJVaUNnNkw3Ky92Nysvdjd3SDVVQVFoQ3Z6cysxd1ZJZ3I5dFB0Y0ZTRUsvT3o3WEJVaUNnNkwrYlFEK0NUNVVCVkdpMHA0VW13STk5YjdmdGIzZFFWUHIwU2lRSXNJKzZmN0JCVS9RbG9taS9zR2kzS05kSTl6Q1BmSzkzSUYrQWozRVJYN0R2d0w5MjZMQlpPcms2eUxyb3YyWU90RzB3ajhiUHZXRmZ0RCt4RUZ3dnNGOHpYM0ZIUUl0L2RXRmNuN1dRWDNHWmYzQmRmTDl3RUlEdmFnZGdIM1hPOEQ5MXo1dEJYOGlQdGNCL2VSKzhEM2kvZkErMXlMaS9pSUJRNmdkdmxRN3dHTDk4RDNYUGZBQS9naytiUVZJd29uSnhYM1hQdkE5MXdHKzhEN3dQdkE5OEQzWElzRkRvdjN3UGRjOThBQitWRHZBL2drK2JRVkl3b25CUHRjOThEN1hQdkErMXdIKzhEM3dBVU9pL2ZBOTF6M3dBR0w3d1A0SlBtMEZTTUtKd1Qzd1B2QSs4RDd3SXYzWFB2QWk0djNYUGZBaXdVT2krOEJpL2ZBOTF6M3dBUDRKUG0wRlNNS0p3VDN3UHZBKzF5TGkvdkErMXlMaS9mQSsxeUxCUTczd084Qjk4RDQ3Qlg3d1B1Ujk4RDdpNHYzWFBpSWk0dnYvSWlMQlE3M3dPOEIrSWo0N0JYN1hQeUlKL2lJKzF3SDk4RDNrUVVPOXFCMkFmZGM5MXdEOTF6NXRCWDhpUHRjQi9mRCs4RDN2ZmZBKzF5TGkvaUlCUTczd1BkY0FmZkErVkFWKzhEN3cvZkErNzJMOTF6NGlJdUw5MXo4aUlzRkR2ZkE5MXdCK0lqNVVCWDdYUHlJKzF6NGlQdGNCL2ZBOThNRkR2YWdkZ0gzWFBkY0EvZTkrYlFWKzczN3dQZGNpNHY4aVBkY2k0djRpUGRjaXdVTzlxQjJBZmRjN3dQM2kvbTBGZnVMKzhEM1hJdUwvSWp2aTR2NGlQZGNpd1VPb0hZQmkrL3Y3Ky92Nys4RCtDVDV0QlVrQ3Z2QUp4WDg3Ty80N0FmM3dDY1ZKUXI5VUNjVisxenY5MXdIRG92djcrLzNYTy92N3dQM0NQanNGVU5EWHlpTCt3S0wrd0szSk5ORENOUFRCVlhCYWRlTDNvdmVyZFBCd1FqNGhOTVZRME1Gd1ZXdFE0czRpemhwUDFWVkNOTkRCZFBUdC9LTDl3S0w5d0pmN2tQVENQdzkreUFWWjJkMFdZdFVpMVNpVnE5bkNORFRCWG1kZ2FXTHA0dW5sYUtkblFqM2FkSVZSa1FGblhtVmRJdHZpMitCY1hsNUNOQkRCYSt2b3NDTHdvdkNkTHhucndnT0xxQjIrQ1Q0SkFHTCtDUUQ5MXo1dEJVbUNpZjhkUldMKzlQdjcrOG5pL2ZUQld1QWFvTm9pMmlMYVpOc2xnZ09pKy80N084QmkrLzQ3TzhEK0NUNXRCVW5DaWNFell2SGRyeG9DUHczL0RjRmFMeDJ4NHZOaS9jNjl4cjNHdmM2aXdqM2lQc1JGYTVhb0UrTFNZdjdPdnNhK3hyN09vdEppMCtnV3E0SURvdnZBWXZ2Ny9kYzcvZGNBL2xRQlAxUStiVHYvVkQ0N0FmNEpCYjhpUGRjK0lnSC9JajdYQlg3d1BkYzk4QUhEb3Z2OThEdkFlL3Y3L2RjNys4REZEajRJZm0wRlg2S2ZvU0NnQWo3ZnZ1dCt4U0xpeWZ2aTR2OEFnVjVtM3VkSHZpb0JwMmJtNTBmK0FMdjcvc1VCM0NzKzJqM2tJbU5nSlNCa0g2S0NJNzdGQlgzSlB0QSs3U0xCWVg3WEJVb0N2ZkFGaWdLRHUvditDVHZFb3Z2K0lqM1hQdGM3eFBvbFBsUUZZV0lpSVVmL05vSGhZNklrUjc1UGdhUmpvNlJIL2RUQnhQdzcvZGNCaFBvSi9kU0JwR0lqNFVlL09NbkZmaUkvQ1Q4aUFZTzcvanNBWlQ1VUJXRmlJaUZIL3phQjRXT2lKRWUrVDRHa1k2T2tSLzNVKy8zWENmM1VnZVJpSStGSGc0bjk4RDRKTzhCOTF6djkxenZBK2Y1SGhWdm9YU25IbzJMajR5Tml3aTkreUVHZ25yN0EvdHFYVDE3Y1hscGkxMkxaSnBscFhHbGNiRjhzb3NJK0pRR3NZdXZtNldrQ0k0R3BhV2FzWXV5aTdoNXJudWxYZG43QS9kcWdwd0k5eUc5QjZlaG9hZW5kYUZ2SC95SWk0YUxob3VJaXdWeGVIQjBIL2dzV1JXTCt6YVJnUVdMaThyN0Q4TWlDUHhXQnNQMHl2Y1BpNHNJa1pXTDl6WUZEb3Z2Ny9qc0FmZ2srYlFWK3dJeE1mc0NINHNqVnkwNVIySnBjbHVMVndqNXRBYUx2M0s3WXEwNXoxZnBpL01JOXdJeDVmc0NIaWY5VUJWVXVGN0N3cmk0d2g0TzlxQjJBZmNxN3dQM0t2bTBGWXY3amtEV1FFRDNLdnNxK3lyN0t0WkExdGFMKzQ2OWkvZnk5NDc3ZGZjdDkzWDNKL3Z5OTQ0RnZmc3FGZmNxSi9zcUp3VW5CUGNxSi9zcUp3VU9pKy8zd08vM1hPOFM3L2RjOTF6M1hDZjNYQlAwK2JRRUp3ZkN1RjVVSC93a0IxUmVYbFFlSi9pNkIvY2U5d1QzQlBjZUg0dnZVT0Eyc3dnVCtLYXRuTGVMdWdqM0FqSGwrd0llKzF3bkZlOEd3cmhlVkZSZVhsUWZKd1luQlBjcUJoUDAzczVJT0RoSVNEZ2YreW9HRHZhZ2RnSDN3UG0wRmZ2QS9JajNYSXVMKzhEM3dQaUkrMXlMQlE2TDd3R0w3L2lJN3dQditiUVZlSWdGWklOc2JJTmtDSWg0aS95NkJUak9TTjRlK0xydi9Mb0diM1docDZlaG9hY2YrTHI0dWdhbmRhRnZIbG43d0FZbjd5Y25pL2ZBQlE0dW9IWUJpL2drQS9tMEJJdjl0UGRjOTF6M1hQdGNpL20wQlE3NVVPOEIrYlFFSVFyOXRQdGNGZnpqQjRXT2lKRWUrYUlHa1k2T2tSLzQ0L3U5SlB0ZjhnY09pL2RjNy9mQTcrOEI5MXp2OTF6dkEvZkErYlFWVkY1ZVZCOG4rMU1IaFlpSWhSLzdoUWR2b1hXbkh2bFFCcWVob2FjZjk0VUhrWWlPaFI3N1UrOEd3bDY0VkI3N1hDY1Y5MXduKzF3Rys4RDhHeFg3WEFlRmpvaVJIdm1pQnBHT2pwRWY5MXdIZTRWN2lIbUxDUDFRQm5tTGU0NTdrUWdPOW92djkxenY5OER2RXUvdlBlLzNSdThUOVBmQStiUVZUWXRWY1dsZ2FXRjdVNHRSaTBhY1U1TlpDUHNSSndZVDdQY09Cb0JlY1ZkR1JnaDdmNHY3RHZqc2k0dnYvSCtMQmN2VXJzNlp4d2ozUnUvN1FBWVQ5SVBQZDhPTHZvdXlscTJjb0p5Z241V3VpN0tMb1lDWmZabDlsbldMWkFqdkJvdkZlNzltc0FobXNGZWJVWXNJRGlmditDVHY3KzhCaSsvdjcvZ2s3d090K1ZBVmVJVjhkWXQzQ0l1SmkvMVFCVytoZGFjZStWQUdwNkdocHgvNVVBZW5kYUZ2SHYxUWk0YUxoNHVJaXdYM0JDY1ZLUXIzWEJiM3dBYW5vWFZ2YjNWMWJ4Lzd3QVp2ZGFHbnA2R2hweC83anZ0Y0ZmanMvQ1Q4N0FZT29IWUI5eHIzbmdQNWZQbXhGWVdJL0F2N25uNThmM0lGMDNUQ1ZLSkRDS1NYbXBqM252Z0xCWTZQakkrSGp3aGZ0d1g4ZVB3ZUZVRlJUMEVmaXloVk5EdGRzblc2Zjd1TENQY245d3YzQy9jbjFVL0hRUjhPaHU3MTd3SDRMZmZBQTVUNFZ4V0xlWmQzbTRRSTl3aFRCWUo3Z1hxRmVnaEdpNGFMQlc5MWMzRnZvWFduSDVDTHZZc0ZpM1NOZFk5MkNEMWpCWGFHZTNTTGRvdHZvWFduaTVXTG1KQ1RrUWpOcmdXalhiRmt0SEt1bnFPa2k2Y0lpL2NraTVDTGo0dmRCWXlPaTVDTGpvdU9pNUNLanBDaW9KeWppd2lub1hWdkg0czBpNGFMaG91Rmk0YUxoNHY3R3dXTGNLUnhybmkwbzdHem83a0l6R2dGazRXWWhwV0xwNHVob1l1bmk2QjdvbmFRQ0QyekJZK2dqYUdMb2dpOUJxZWhvYWVuZGFGdkgwY0doWnlCbklLYkNQY0h3d1dhazVlZmk1eUxwM1doYjR1Q2k0V0loWWNJK3hkSmI2RUYyZDQ5OXp2N0M0djdDNHM5K3ozYU9naHVkZnNYelFXRWo0Q09nNHR3aTNod2kzUUlEdmpzN3dQNDdQbFFGZnpzNWdlUmpvNlJIL2phQjVHSWpvVWUvSFg3V1JWNGlQdEtpd1dGaUlpRkgvdEtCNFdPaUpFZTVvdnkrNlFGbG5Lc2dLU1dwSmFXcklDa0NFRDNSZ1dPbVpXVG1vc0lpNDczanZzUmkvaUlCUTZMNysvdjcrLzNYTzhCaSsvdjcrL3Y3KzhEbFBtMEZZV0lpSVVmL2FJSGhZNklrUjc1UGdhUmpvNlJIL21pQjVHSWpvVWUvT01uRmZpSSsxejhpQVluQk84bkp3YjNYTzhWN3ljbkJ2ZGM3eFh2KzhBbkJ2d2s3eFh2SnljRzkxenZGZThuSndZT2krL3Y3Ky92Ny9kY0FZdnY3Ky92NysvdkEvbTBCUHRjK1ZEM1hBZjlVUHZBRmZ4L0I0V09pSkVlK1Q0R2tZNk9rUi80ZndmODdDY1Y3eWNuQnZkYzd4WHZKeWNHOTF6dkZlOG5Kd2I4SkNjVjd5Y25CdmRjN3hYdkp5Y0dEb3Z2Ny9kYzcvZkErOER2RW92djcrL3Y5MXp2N3hQditDMzV0QldGaTRlSGlZWUlMZnRLQlJQZmlZYUhoNFdMQ1BzaEJqaElTRGdmL0UwSGhZNklrUjc1b2dhUmpvNlJIL2phQjVHSWpvVWVPUWFGaTRlUGlaQUlMZmRLQlJQdmlaQ0hqNFdMQ0JQZi9FMzd3Qldub1hWdmIzVjFiMjkxb2FjZnA2R2hweDRUNy9meUZ2Y0M1VEg3QXZzQ01USDdBdnNDTWVYM0FoLzNBdVhsOXdJZUp3UXFDZzc0N0FUNEpQd2srQ1Q0SkFVT0xxQjJBZmdrK2JRVi9DVDhKUGdrL0NRRkRpNmdkZ0g1dEFTTC9iVDRKUGdrQlE3NEpQanNGZndrL0NUNXRJc0ZEb3Z2Ny9mQWkrOFM5OGp2OTF6dkU3ajR1Z1J2b25TbkhvMkxqb3lOaXdqM0tvdVZjZ1dtT0tZM3BqZ0lFOWlQZnB0L21Zc0k5L0lHbVl1Y2w0K1lDTnozamdVVHVJK1locGQ5aXdnVDJQeFFpMlhUQlJPNGhKcDNtSHFMQ1B0Y2k0ZUxob3VJaXdWeGQzQjBIL2Y2L0ZZVkt3cjN3QllyQ2c2Z2R1LzRKTy92QVl2M1hPLzRpQVA1VUFTTC9JanY3KytMaS9mQTk4Q0xpKzhGKzF6N1hCWDhKUGdrQis4bmkvaUlCUTc1RmZsUUZmc0Yrd3Y3Q3ZzRyt3ajdDVmU4V0wxWnZnajdJZnNoMDBRRjFFSFdROUkvQ1BpQitJRUZEdmNxK093Vit5cjdLdmdrL0NUNEpQZ2sreXIzS3Z1Tys0NEZEdmFnZGdINEpQbTBGZndrL0NUNEpQd2s5eXIzS3Z1Tzk0NzNqdmVPQlE3Mm9IWUI5eXI1dEJYN0t2c3E5NDc3anZ1Tys0NzNLdnNxK0NUNEpBVU8rQ1Q0N0JYOEpQd2s5eXI3S3ZlTzk0NzNqdnVPOXlyM0tnVU9pL20wQWZnaytiUVZJd3IzWFB0R0ZkTkQrOWI3MXZ0QTkwRFQwKzhuQlE2TCtiUUJpL20wQS9naytiUVZJd3I3S3Z0R0ZTd0tEb3Y0aU8vdkFZdnY5MXp2OTF6dkF4UTQ5L0w1dEJWdmRYVnZIMWxBQjMyQWdIMGZRUGZBMWdlWmdKWjlIa0M5QnFkMW9XOGUrOWtuRlgyQWdIMGYvUjRIZlphQW1SNzVIZ2FabHBhWkgva2VCNW1BbG4wZVFQdGMvSWozWEFZT2krLzQ3TzhCaSsvM2p1LzNqdThERkRqNEpQbTBGU2NLSndRdENsa25GWXY3Y3B0L0JhaHVwMjZtYlFqVDB3VnlvWE9pZEtNSTkwa0hEcUIyK0lqM3dBR0w5OER2NysvM1hBUDRWdm0wRmZzTml5RTFkUHNHK3dLTE1UR0wrd0tMWnBacW5HMEk5NlM5QnQ3T3p0N2V6a2c0SGxuM1V3ZVJtNDZiaTUyTHpHSExVYUFJdlFmM0h2c0U5d1Q3SGg1Ny9DUVZlSVY4ZFl0M0NJdUppL3NxK3lxTDkxejdYUGRjOTF6N0tvdUw5eXFMakFXbmRhRnZIb2lMaUlxSWl3aUhCZzZnZGdINEpPOEQrRmI1dEJYN0RZc2hOWFQ3QnZzQ2l6RXhpL3NDaTJhV2FweHRDUGR5aS9kYzkxejNYUHRjOXlHTEJaR2JqcHVMbll2TVljdFJvQWk5Qi9jZSt3VDNCUHNlSHZ4V0JQdU8rNDczWEl1TFdRVnZvWFducDZHaHB4Njk5MXdIRHUvNDdBSDRWdmxRRlM0S0RvdjQ3QUgzanZtMEZmc2Urd1Q3QlBzZUg0dGtsR21iYXFtaHJacXZsY0wzRVBjVDRQY2ppMTNIUTdNNWl3ajNYUHRjRlM0S0R2aUkrVkFWKzhEODdPK0w5OEQ0N0FYOGlDY1ZKL3RjNy90Yzc0c245MXp2OTF3RitDUVc3L3RjSi90Yzc0dnY5MXduOTF3RkRvdjNqdmZBOTQ0QmkvZU85OEQzamdQMzh2bTBGVm43QzI5Lyt3dTlRME85K3d0L2Ivc0xXWXNuOXd0WmwyOVord3ZUUS9jTHZhZC92ZnNMQmUrTHZmY0xwNWYzQzFuVDAxbjNDNWVuOXd1OWkrLzdDNzEvcDczM0MwUFQrd3RaYjVjRldmY0xCVm43amhYZXprZzRPRWhJT0RoSXp0N2V6czdlSHc2TDcvaUk5MXdCK2JRRUx3cjg3UHZBRmZkYysxejNYUGRjQmZ6cy9DUVZJUW9Pb0hZQmkrLzRpUGRjQS9tMEJDUUsrSWdXTUFyN3dQdGNGZnRjKzF6M1hQdGNCUTZnZGdHTDkxejRpTzhEK2JRRU1BcjRpQllrQ3Z5SSsxd1ZpL3drOTF6M1hBVU9pL2RjK0lqdkFmbTBCQ0VLL0NUN3dCWDdYUHRjK0NTTEJmenNKeFV2Q2c2TDcrL3Y3Ky92N3dHTDcrL3Y3Ky92N3dQM0t2bFFGVGhJU0RnNHpramVINzBuV1FZNFNFZzRPTTVJM3Q3T3p0NGZ2ZTlaQnpqT1NON2V6czdlM2tqT09CNVo3NzBHM3M3TzN0NUl6amc0U0VnNEgxa252UWZlU000NEhpY0VwNkYxYng5WldRZHZkYUducDZHaHB4LzRKQmFub1hWdmIzVjFieDladlFhbm9hR25IdnVPKzF3Vjd5Y25CdnNxSnhXOVdRWnZkWFZ2YjNXaHA2ZWhvYWNlOS9JV3ZRYW5vWFZ2YjNWMWIyOTFvYWNmRHFCMjkxejQ3QUdMK2JRRCthc0UvTm9IaFk2SWtSNzQ0NHYzWFB0Y2kvbXFCWkdJajRVZS9hSUdob2VIaGg4T2krLzQ3TzhCaSsvNDdPOEQrQ1Q1dEJVbkNpY0VMUXIzWENjVis4QW5KL3ZBOThEdkJTZjNLaFVwQ2c2TDcvanM3d0dMK0NUM3dPOEQrQ1Q1dEJVbkNpY0U5enIzR3ZzYSt6cjdPdnNhK3hyN09oOE9pKy92Ny9kYzcrL3ZBZmxRN3dQNXRBUWhDdjIwKzF3VkovaUk3d2Y4aVB2QUZTRUsvYlQ3WEJVaUN2Y3FGaXNLRHUvdjcvZGM3KzhCaSsvdjd3TVU0S1Q1VUJWOWdJQjlIMEQ1dE5ZSG1ZQ1dmUjc5bS90Y0Zmd0xCMzJXZ0prZStZSUdtWmFXbVIvNEN3ZjlVUHRjRmU4bkp3YjNYTzhWN3ljbkJnNmdkdS92K0NUdkFlL3YrQ1R2QSsvNXRCVW5KeWZ2L0lqNGlDZnY3Ky92Si9oV0IrL3ZXYjBuSi94V2k0dnZCZnRjQlBmeWkvdnkrL0lGK0NUM3dCWDc4dnZ5Qnc2TDcrLzNYSXZ2aSsvdjd4S0w3L2RjOTF6N0t1Kzk3Ky92RTZ4QStDVDV0Qlg3Y1B0SSswajdjUHR3OTBqN1NQZHc5M0QzU1BkSTkzQWY5M0Q3U1BkSSszQWVKd1F0Q2hPZFFDY0VNUXI3WFBzb0ZZdC9rbnVVZ3dqbE1BVVQza0NGY2dWVXVGN0N3cmk0d3NKZXVGUWVjb1V3NVFXRGxIdVNmNHNJZzR1SWk0aUxCWGlGZkhXTGR3Z1RyTUQzOHJzVk1Rb09pKzhCOThEM1hBUDN3UG0wRmZ2QSsxd0g5OEQ3d1BmQTk4RDdYSXVMOThBRi9JajlVQlVoQ2c2Z2R2bFE3d0gzd1BkY0EvbTBCQ0VLL0NUN1hCWDd3UHZBOTF5TGkvdkE5MXlMaS9mQTkxeUxCUTczWFBsUUZmdGMrOEQzWFB2QStPeUxpL2pzQmZ4V1BSVXNDZzc0N084QmkrL3YrQ1R2N3dNVWNQZ2srVkFWKzNEN1NQdEkrM0FmN3diM092Y2E5eHIzT3ZjNjl4cjdHdnM2SHU4RzkzRDdTUGRJKzNBZVVQdGxGVHB5VHorTE1RajdBdVV4OXdMM0F1WGw5d0llaStWUDF6cWtDRkF6QlE2TDcrLzNYUHRjNysvdkVvdnY3KzhUblBtMEJQMjArVkQ0SkFjVHpQd2srQ1FHN3hZVG5QdkE5OEFIL096dkZlOG5Kd1luQk84R0U3d25Kd2NuQkJQTU1nb085b3Z2K0NUdkFZdnY3Ky92N3dNVU9QZGMrVkFWSjBBSFIxSlNSeDlaQjR0SHRsTE5ld2ozbFVvRm1ZZWZjb3Q4Q0ZrSGZZQ0FmUjc3amdaL2k0S09oNDRJNlNjbkI0dHBvRytpZTZKN3A0V3Bpd2pXSisvdjFnYlB4TVRQSDcwSGk4OWd4RW1iQ1B1VnpBVjlqM2VraTVvSXZRZVpscGFaSHZlT0JwZUxsSWlQaUFndDcrOEhpNjEycDNTYmRKdHZrVzJMQ0VEdkJnNkw5OEQzWFBmQUEvbFFCRE1LOTF3V013b09pL2ZBOTF6M3dBUDN3UGxRRlRRSytJajQ3QlUwQ2c3djk4RDNYTzhTaS9mQSs4RHYrQ1Qzd1B2QTd4UGc5OEQ1VUJVMUNoUFErMXdHRStEM0ErVGs5d01lRThqNGlPOFZOUW9UeFB0Y0JoUEk5d1BrNVBjREhnN3Y3L2RjOThBU2kvZkFKKy8zWFBmQUorOFQ0UGxRQlB2QUJ4UFE5MXdHRStBMkNoUEk5MXdXKzhBSEU4VDNYQVlUeURZS0R2WjE3d0dMNy9lTzk0NEQ5OEQ1dEJWcGFRV0FnUHVUKzVlTCsyNEkrem4zRy9zYjl6bjNPZmNiOXh2M09SNkw5Mjc3ay9lWGdKWUkrMHo4U2hXbm9YVnZWTGhld3FlaGRXOXZkWFZ2K3dJeDVmY0NwNkdocHg4T2kvZGNBZmdrK2JRVi9DVDhpUG0waXdYOXRDY1ZMd29POXFCMkFmZkErYlFWKzhEN3dQanNpd1g4N1B0Y0ZmZkErOEQzd1BmQUJRNzN3UGRjQVl2M1hPLzNYTy8zWEFNVWNQaUlCRGNLN3hZM0N1OFdOd29PK1ZBRWl5ZjRKUHRjK0NUM1hJdnZCZjIwKzF3Vi9DVDV0UGdrQi93aysxd0ZEcUIyQVl2ditPenZBL2drK2JRVi9DVDdYSXY4N1BtMGk0djQ3QVg4Sk9NVjk4RDdLb3Y3VVB2QSt5cjd3UGNxaS9kUUJlOWxGWXNuOTF3bjkxenZpKzhGRGlmdjcrL3Y3L2RjN3dIM1hPOEQrT3o1VUJYN1RvdjdMZnNVWHZ0QUNQdFRpM0luOTF5TEJZdHBrMm1UYXdqN1dZdDRKL2VVaXdYUit3cjNFem4zSjR2VWk4K2d4cTRJOXc0SFZsdEdiVDJMTW9zOXNsVElDUGR5aTV2dis3MkxCWUNyZzZ1THJ3ajM0b3ViNy92Zml3VzA5d2ozQWQvM0Y0dk5pOGQydkdnSW0vVUZVcXBLbmthTENBNkw3Ky92Nysvdjd3R0w3Ky92Nys4REZBNzVVQVFuK1ZEdkIvMVErMXdWSi9pSTd3ZjhpUHRjRlNFSy9iVDdYQlVuNys4SDd4WW43KzhIN3hZbjcrOEhEb3YzWFBpSTd3SDV0QVFoQ3Z6cysxd1Y5MXo3WFBkYzkxd0YvT3o4SkJVdkNnNmdkZ0dMNy9pSTkxd0QrYlFFSkFyNGlCWXdDdnpzKzF3Vmkvd2s5MXozWEFVT29IWUJpL2RjK0lqdkEvbTBCREFLK0lnV0pBcjdYUHRjRmZ0YysxejNYUHRjQlE2TDcvaUk5MXdCK2JRRUx3cjhKUHdrRmZ0YysxejRKSXNGL093bkZTRUtEb3Z2K096dkFZdnYrT3p2QS9tMEJQMjArYlQzWENjbi9PejQ3Ty92Qi9kY0Z2Y3EreXI3anZ1Tzd5ZjNqdmVPOXlyN0tvdjRKQVVPNysvdjcvZGM3d0gzd084RCtDZjVVQlg3a2ZzcSs4Q0xpL2NxKzhEM2tmZUw5eXIzd0l1TCt5cjN3UHVMSDRnbkZUZ0tKd1JVWGw1VVZMaGV3c0s0dU1JZmk1V0lsSWlVZzN0N2YzZUxiNHQxb1l1bmk1K1htNXVUZ282Q2pvR0xDQTc0Sy9mZitWQVZlSVY3ZFl0M2kzK1NlNVNEQ01wTS9BdjhFWXY3cFBlaGkvZ1IrQkhKU2dXVGdKNkNtSXVuaTZHaGk2ZUxtSU9jZ1pNSUx1bk16UVhGeFl2clVjVlN4Q21MVWxJSVNVb3Q2QVdEbEhxVGY0dUlpNGVMaUlvSWlBYjNCZnR2RmZjWCt4ZjcwUHZRK3hUM0dBVU9pL2drQVl2M3dBUDV0QVQ5dFBsUStDVDhKUGdrQis4Vys4RDN3QWNPb0hZU2kvZ2tKL2drRThEM1hQbTBGZS83WFB2QUo0djdYSXY3WFBkY0o0dUxLZmRhOTc3eGkvZGNDUGRjKzF6dml4NzN3UHZBRlJPZzcvdGMrOEFuaS90Y0NQZkFCclBIdmZjcTkxejdYTytMSHc2Z2RnR0w3d1A1dEFRa0N1OFcvQ1QzWENmNEpBZjdYUGRaOTF6M1gvdkFpNHZ2QlE0dW9IWUI5eXI1dEJYN0t2dkE5MXlMU2Z0Yyt4cUw3L3ZBOThEM3dQc3FpL2NxOThEN1hJdnY5MXdGRG92NGlPLzNYUHRjN3hJVHdQbTBCUHRjQnhPZytiVHYvSWdHRThEdkIvdkErOEFWL0ZZSGI2RjFweDc1VUFhbm9hR25IL2hXQnc2Z2R2ZkE3eEtMOThEN1hPLzNYUGZBKzF6dkUrRDNLdm0wRlRoSVNEZ2ZFOUNMU2JSVXhuY0krMjRIRStSUWQySlVpMGtJT001STN0N096dDRlaThkcHZWbWpsSlNXa3BtTENQZGNCdDNQejkwZnhnY1R5TWFmdE1LTHpRamVTTTQ0T0VoSU9CNFQxSXRKdEZUR2R3aFFCMjkxZFc4ZSsxd0dlb3Q1aDN5R0NQY0tCeFBneHArMHdvdk5DTjVJempnZURxQjJBZm0wQkRrSzcvd2tGVG9LRHFCMkFlLzV0QlU2Q3ZjcSs0NFZPUW9PaSsvNDdPOEJpKzhEK0NUNXRCVWpDaWNFcll1cGdxbUJkbmR6ZVk5NWozbk1rSXRtaTNCaGdxbHRybWdvVFlsZGlEZmlmdENMQ0xXTGxuZUljMVUrTDFzbWkyV0xhWlJwbUtHM1dlSmNwM1NpV29KdmxvS21ncWFLcVFpT2tKQ1FrNHNJeG1rRm5ZOHc5eEsxcForWHMxZCt3bisrdW5TcG1LV1duNmxxblFoMW5nVzRwcitjdzRzSTkzdjdBUldkZFpwemxuRUlpNGgxZFFWdmI0YThnSlYrbDExOWhacUVuY09qc1pZSURvdnZBZmxUK2JRVis4UDd3Q2Z2KzhEN3crOG45MXozWCs4bitDVDRKQVg5dFB6c0ZTRUtEb3Z2NysvdjcrL3ZBWXZ2NysvdjcrL3ZBL2xRQkNmdjd3ZnZGaWZ2N3dmdkZpZnY3d2Z2Rmlmdjd3ZjlVUHRjRlNmdjd3ZnZGaWZ2N3dmdkZpZnY3d2Z2Rmlmdjd3ZjlVUHRjRlNmdjd3ZnZGaWZ2N3dmdkZpZnY3d2Z2Rmlmdjd3ZjlVUHRjRlNmdjd3ZnZGaWZ2N3dmdkZpZnY3d2Z2Rmlmdjd3Y09pL2RjNy9kYzcvZGNBWXYzWE8vM1hPLzNYQU1VL1BtMEJEY0s3eFkzQ3U4V053cjl0UHZBRlRjSzd4WTNDdThXTndyOXRQdkFGVGNLN3hZM0N1OFdOd29PaS9mQTkxejN3QUdMOThEM1hQZkFBL20wQkRzSzkxd1dPd3I5dFB5SUZUc0s5MXdXT3dvT2krL3Y3Ky80SkFINDdPOERudm0wRllDRGc0QWYrOThIYjZGMXB4NzQ3QWFub2FHbkgvZmZCNWFEazRBZS9UMzhmeFg3dGdlQWs0T1dIdmtxQnBhVGs1WWY5N1lIZTRWN2lIbUxDUHpzQm5tTGU0NTdrUWo0dXZzQkZTa0tEb3Z2OTF6djkxenZBZS92OThEdkF4VGcrVkFFSjcwSHA2RjFieC84SkFkdmRYVnZIbGtuOThEdldRWnZkYUduSC9jcTk4RDdLZ2R2ZFhWdkhsa245OER2V1FadmRhR25IL2drQjZlaG9hY2V2ZS83d0NlOUJxZWhkVzhmK3lyN3dQY3FCNmVob2FjZXZlOEdEcUIyK096dkVvdjNYQ2Z2K0NUM1hQdGM3eFBRK0NUNVVCWDdPZnNiK3h2N09SOG5XUWNUNEc5MWRXOGYrMXdIYjZGMXB4N3ZCcWVob2FjZkU5VDM4Z2YzQStUazl3UDNBK1F5K3dNZUU4ajc4Z2R2b1hXbkh1OEdwNkdocHgvM1hBZW5kYUZ2SGhQVVdlOEc5em43Ry9jYit6a2VEdmlJQkl0VW9sbXZad2ozNmZ2bzkrbjM2QVd2cjZLOWk4SUk5d0V3NXZzQit3RXdNUHNCOXdFdzV2c0Ird0V3TVBzQkhnNmdkZ0h2OTF6M1hQZGNBL2drK1ZBVi9DVDd3TytMaS93azkxeUxpL2RjOTF5TGkvdGM5MXlMaS9nbjc0Z0ZEb3Z2K096dkFZdnYrT3p2QS9tMEJQMjArYlQ1dEFmOVVDY1YrT3o3d0FZbjd5Y245MXo3WElzbko0djhKUGdrSnljRkRvdjNYUGdrOTF3QmkrLzQ3TzhEbnZtMEZZQ0RnNEFmL1k0SGdKT0RsaDc1amdhV2s1T1dIL21PQjVhRGs0QWUvVDM3WEJYNDdQdkFKd1luSi90Y2l5ZnZKNHNGRHZkYzcvZGM3d0dMNy9qczd3UDNYUGpzRmZzWFJpWW9LTkFtOXhjZjJvdkt3OFhOeFVuSVU5eUxDUGNYMFBEdTdrYncreGNmT290T1UxRkpVYzFOd3p1TENDY0V0WXU1WExsV1hWWmRYR0dMQ0VGeHdibTVwY0hWSC9na0Z0V2xWVjFkY1ZWQkgyQ0xYcnBkd0xuQXVMcTJpd2dPTG92djkvTHZ2ZmRjRXUvdmkvZGMrMXp2RStUM3dQbTBGUlBvVkY1ZVZCOFQ1RlM0WHNJZUUrakN1TGpDSDhKZXVGUWUreXI3amhVNFNFZzRIeFB3N3dhbm9hR25IaFBrcDZGMWJ4OFQ4SXR2Si9zY2l6VUlOYzVMM2g0VDZON096dDRmRStRbkJtOTFkVzhlRS9CdmRhR25IeFBraTYvdjl5aUx6UWpjU05BNEhnNkw3L2pzN3dIM1hQbTBGU2YzTndlRWZ3VTkrMWc4KzFjKysxa0krdzRuK0lqdit6WUdrWmNGMmZkWTJ2ZFgyUGRaQ1BjTzd3WU9pKy92NysvdjcrOEIrVkFFSVFyOXRQdGNGU0VLL2JUN1hCVWhDdjFRKzF3Vklnb09pKy92NysvdjcrOEIrVkFFSVFyOXRQdGNGU0VLL2JUN1hCVWhDdjIwKzF3Vklnb09pKy92NysvdjcrOEIrVkFFSVFyOXRQdGNGU0VLL2JUN1hCVWhDdnpzKzF3Vklnb09vSGIzd1BkYzkxenZBZmZBOTF6M1hPOEQrTHI1dEJYN0h2c0Urd1Q3SGgrTGU0dDdqbndJKzhQN3c0djdYUGZBaTR2M1hQZGNpNHZ2am80Rm1vaWJpNXVMQ1BjZTl3VDNCUGNlOXg3N0JQY0UreDRmdlNjVlBBb09pL2RjOThEdkFlL3YrQ1R2QS9jYStPd1ZlSVY4ZFl0M0NJdUppL3Z5SjR1TCt5b0ZiNkYxcHg3NVVBYW5vYUduSC9jcUovZnlCNmQxb1c4ZS9JaUxob3VIaTRlTEJjb25GZmdrKzhBbkovdGM3eWNHRG92djcrL3YrQ1FCaS9nazcrL3Y3d1A1dEFUOEpQZ2srQ1FINy90Y0ZUMEs3L3RjRlQwS0R2WW43eEwzQS9mSCs1LzNaQk9BOStYNVNoWDd3UHNxQlhhR2UzU0xkb3R2b1hXbmk1V0xtSkNUa1FqM3dQY3FCWnFUbDUrTG5JdW5kYUZ2aXdpQ2k0V0loWWNJNy9zcUZmd2srMXdGZG9aN2RJdDJpMitoZGFlTGxZdVlrSk9SQ1Bnazkxd0ZtcE9YbjR1Y2k2ZDFvVytMZ291RmlJV0hDUHRjQlB2QSt5b0ZFOEI5ZzM5M2kzdUxjYUYwcFlvSUU2RDNYQWFOaTQrS2pZc0lFOENub3FLbkg0dWplS0Z6andqMXd3V2FrNWVmaTV5THAzV2hiNHVDaTRXSWhZY0lFNkQ3c3Z3ZUZXK2hkS2Nlall1UGpJMkxDTzhHcDZHaHA2ZDFvVzhmSjR1R2k0ZUxpSXNGY1hkd2RCOE9vSGJ2Ny9nazd3SDNXKy8zWE84RDkxdjV0QlVuSnlmM1hQZGNCL2V6aUJWVGlHTjNhMm9JWUY4RmZvT0FkNHQ4aTIraGRhZUxtb3VlbHBPWUNMZTNCYTJ0MEpLMFlySmtqRXBqWXdqN0t2c3FCWDZEZ0hlTGZJdHZvWFduaTVxTG41YVRtQWozS3ZjcUJkblppL2NSUGRsdnAycWRaNU41ajNlTGVZb0kvQS83eHhYN0t2c3FCVDA5aS9zUjJUM0RVOXg3MGFTbWxhV2FvYUVJdHJjRm1KT1duNHVhaTZkMW9XK0xmSXQ0Z0lOK0NGOWZCV2xwUm9SaXRHU3lpc3l6c3dqM0t2Y3FCWk9Ua1p1TGxvdW5kYUZ2aTRtTGg0cUppd2lJQm9PTGdZQ0hoZ2ozdC91MkZmdGM3Ky92N3djTzk1VHE2ZTQ5N3hJVGdQamUrYkVWVTRoamQydHFmb09BZDR0OGkyK2hkYWVMbW91ZmxwT1lyYTNRa3JSaXNtU01TbU5qQ1BzcSt5b0ZYMTluaG5HTmNZMThsb3VMaEkrQWpvT0xiNHQxZEl0dmkzcVdlSnFEbW9PZWZiMklDTDJJMFo3SnlRajNLdmNxQmRuWmkvY1JQZGx2cDJxZFo1TUllWTkyaTNtS0NCT2crMXo3ZXhWWmpVZDVUMDhJK3lyN0tnVTlQWXY3RWRrOXcxUGNlOUdrcHBXbG1xR2htSk9WbjR1YWk2ZDFvVytMZkl0NGdJTitDR2xwUm9SaXRHU3lpc3l6c3dqM0t2Y3FCYk96cnBDbmlxZUtub0tMaXdnVHdKT0ZtSWFWaTZlTG9hR0xwNHVnZTZKMmtBaDJrSDJhV1kwSURvdnY3Ky92NysvdkFZdjN3QVA1VUFRN0N1OFdKL2drN3dmOEpQdGNGU2Yzd084SC9WRDdYQlU3Q3U4V0ovZ2s3d2Y4SlB0Y0ZTZjN3TzhIRG92djcrL3Y3Ky92QVl2dkE3MzVVQlVyQ3ZjcUZpSUsvWUw3WEJVckN2Y3FGaUlLL1lMN1hCVXJDdmNxRmlJSy9ZTDdYQlVyQ3ZjcUZpSUtEcUIyQWZtMCtiUVYvYlQ4SlBmQUorLzd3QVVPOW92NEpQZGM3d0h2Ny9kYzd3UDN3UGxRRmZzQ01USDdBaDhuSi93aytPejRKQ2Z2Qi9jQ01lWDdBaDRuQk1PM1gxTWZKL3RjN3dmRHQ3ZkRIZzcyaS9nazk4RHZBZS92OTF6dkEvZkErYlFWK3dJeE1mc0NIKzhHdzdlM3c4TzNYMU1lKzF6OEpQd2srT3o0SkNmM1hBZjNBakhsK3dJZUR1L3YrQ1R2QWUvditDVHZBL2drK1ZBVit6bjdHL3NiK3prZko0djNLdnRjOXlyM1hDZUxCZmNENU9UM0F4NzNqaGI3S3Z0Yzc0c0Yrd015TXZzREhpY0g5em4zRy9jYjl6a2Y3d1lPaSsvNDdPOEI3Ky80Sk84RDcvbTBGZnRjNysvNEpQdGNKd2YzS3Z1Tzl5cjNqaWVMaS9mQUJmeTYrNDRWK3lyN2p1K0xpL3ZBK095TGkvZGNKNHVMSi93a2k0djNYTytMQlE2Z2R1L3Y5OER2QVl2ditPenZBL2pzK1ZBVkoveUlCMVJlWGxRZkorL3YrSWduQi9kYzl5b0YvT3o3amhYN1hQc3E5MXo3S292ditJaUxCY0s0dU1JZjd5Y24vSWdIRHZncjcrLzRpTzhCaSsvNGlPOEQ5L0w1dEJYN1Zmc3grekg3VmZ0Vjl6SDdNZmRWSDhhTHhacThwWTZIa0lXUGlBanZKd1diZTZ4OW9vdkRpN201aThPTG9uMnNlNXNJSis4Rmg0K0VrSWFPcHJ5Y3hJdkhDUGRWK3pIM01mdFZIdnpzQlBzZit3UDNBL2NmOXgvM0EvY0Q5eC8zSC9jRCt3UDdIL3NpK3dEN0FQc2lIdzcyb0hiNVVPOEJpKy80Sk84RDk4RDV0Qlg3T3ZzYSt4cjdPdnRjOThEN3dJdUw5OEQzd1BkYzl6cjdHdmNhK3pvZkp3UTRDZzc0SzR2djcrLzNYTy92N3dHTDcrL3Y3Ky8zWE84RCtiUUUvYlQ1dFBlQ0I0eU9pNCtMam91T2k1Q0tqZ2o0c1FmN3hmeTZGVytoZGFjZWtJdjNLb3VMSi96c2k0djQ3UGpzaTR2OEpQc3FpNGFMQlc5MWMzRWYreVgzOGhVNFNFZzRKL2NxK3lxTGkvY3E5eXJ2M2tqT09COG5CQ2tLRHZhTDkxejNYUGRjQS9sUUJENEs5MXdXUGdvTzl2bFFCSXY4N1Bqczk4QUZEdmJ2K093QmkvanNBL2ZBK1ZBVit6cjdHdnNhK3pyN092Y2EreHIzT3ZjNjl4cjNHdmM2OXpyN0d2Y2Erem9mRHZnaytWQVYvQ1Q3d1Bnays4QUY5OEFFK0NUN3dJdjQ3QVVPK1ZBRWkvenMrQ1Qzd0FYN3dBVDRKUGZBL0NUM3dBVU9pL2RjQS9sUUJENEsrOEFFK0lqN3dJdjQ3QVVPK0lqM1hBUDVVQVNML096NGlQZkFCZnZBQlBkYytPejdYQVlPOXUvNDdBR0wrT3dEK1ZBRS9PejQ3UGpzQnc2Z2R2ZGMrQ1FCOTF6NEpBUDNYUG0wRmZ0YysxejhKUGRjKzF6NEpQZGM5MXo0SlB0Yzkxd0hEbzd2OTF6djkxbnZBZmxRQkNFSy9iVDd2UlVoQ3YyMCs4QVZJUW9POWlmdjllbnYrQ2dTaSsvdjkxejdLdS8zS3U4VCt2ZXErVkFWWUlGb1g0dGZDSXVKaS90Y0JWUzRYc0xDdUxqQ0hvdjNYSXVQQmNKZXVGUWVnb3VGaVlTSkNQdUkrMXdWZUlWOGRZdDNDSXVKaTFrRkUvYUwreWozQWZzTzl5RnpDQ0VIRS9wWkJsUmVYbFFmK0NRR3dsNjRWQjRUOWxuMUJ2Y2hvL2NCOXc2TDl5Z0l2UWVuZGFGdmIzVjFieDVaQi9zRE1qTDdBL3NETXVUM0F4Nkx2WXVNQmFkMW9XOGVpSXVJaW9pTENJZ0dEdmZBOTF3QitJZ0VMd29PSisvdjcvZ2s3d0dMNy9qczd3T3QrVkFWZUlWOGRZdDNDSXVKaS95SUJXK2hkYWNlOTQ0bkp3WlVYbDVVSC9qc0JzSmV1RlFlSisvM2pnYW5vYUduSC9pSUI2ZDFvVzhlL1ZDTGhvdUhpNGlMQmNrbkZmanMvQ1Q4N0FZT1BmZU9BWXYzamdQM3BQbFFGZnN5VnZzRyt5bUwrMFNMKzNIM1IvdEg5M0dMOTBTTDl5bjNCc0QzTW1OOVlJTmVpL3R4aS90SDkwZUw5M0dMdUpPMm1iTUlEcUIyOThEdkFmZkE3d1AzOHZsUUZmc3EreXJ2aTR2N0t2c3FpNHZ2K3lyN0t2Y3EreXFMNy9jcWk0djdLaWVMOXlyN0t2Y3E5eW9uaTR2M0tnWDNLaWNHOXlyM0t2c3E5eXFMSi9zcWk0djNLdStMQlE2TDk4RDdYUGZBOTFuM1h4S0w5OEFuNy9kYzk4QW43eE9xK2JUNXRCWDhpQ2NuaXgvOExRZDhrSG1QZW9zSUU3QS9DaE5xK0NFSDFLTDNFcUQzWFpFSSsySUhmSkI1ajNxTENCTmtQd29POTJQNGgvbFFGVmlMV0hka1pBajdxdnVrQlNBZ2kvdEM5aUQySVBkQ2kvYjJDUGNSOXhGRzBQc0krd1dDZndWR1J2c0VpMGJRUjgrTjl3TE4wQWozcXZlbkJiT3p6SXF5WkxKa2lVMW1Zd2o3anZ1TEJZR0JlWXVCbFlHVmk1MlZsUWlTanVYcFJ0QXJLZ1ZiVzRzOHUxdTdXOXFMdTdzSTk0NzNpQVhaMll2M0VUM1paTEpZbjFpTENBNmdkZ0g0N1BtMEZTY245MXo3WE8vdkJmd2tGdndrL0NTTCsxejNYSXY0SlBna0JRNkw5MXp2K0NUN3dQZ2tFdS8zd08vM1hDZjNYQk80K0xyNXRCVllpMTluY0ZlNFZhWkJpemVMYm9oeGhYR2VnSjJEb1lzSTNzN2w5d0lmOXdKSTVUZ2VFOUQ3d0NjVk9FZ3grd0w3QXM0eDN0N081ZmNDSC9jQ1NPVTRIdmh2KzlBVllGaFBiRW1KQ0JQVXBtV2NYWXRaQ0VuM1hQYzZCNHUvYkxkZm9RajlIaWNWWDNWc1g0dFhDUHM2QnhPWStJajNPZ2FMdjJ5M1g2RmVWazVzUm90R2kwNnFYc0FJRG92M1hPLzRpQUgzWFBna0EvZ2srYlFWK3dJeCt3VDdIdnNlNWZzRTl3TDNBdVgzQlBjZTl4NHg5d1Q3QWgvN1pmeUlGU0dHTmpTTCt3QUlKL20wN3dlTDl3QTI0aUdRVlU1QlpEcUxPb3RCc2xYSUNBNzJpNzN2dmZpSTd4S0w5MXo3WE8vM1hQZGNKKzhUNnA3NXRCV0FnNE9BSC8yT0I0Q1RnNVllK0dJR2xwT1RsaC81amdlV2c1T0FIdndSSnhYM3dQeUkrOEFHOXlwWkZSUDBLUW9Pb0hZQjkvTDV0QlVxaXpSa1RFc0k5NzM3dll2NElRVjdqWHFNZW9zSTl5b2hGWXY3NmZ1ays2UUZ5Rm5YYk9DTDkxV0w5ekgzTVl2M1ZZdjNSUHNYOXlQN1BhUUkvQzM3R0JWVFZXaEJpemVMSzdrNDBWUUk5MmozYUFVTzk4RHY5MXp2QWZmQTd3UG4rUjRWYjZGMHB4Nk5pNCtNallzSXZmdGNKd1pVWGw1VUgvZkErOEFHdHlmRDc0djN3UGZBaXdYQ1hyaFVIaWYzWEwwR3A2R2hwNmQxb1c4Zi9DU0xob3VIaTRpTEJYRjNjSFFmRG92NXRBR0w5OEFEK0NUNXRCVWpDaWY3WEJYM3dQdGMrOEQ3WEFVT29IYjN3UGRjQWZmQTkxd0Q5OEQ1dEJYN3dQdkErMXozd1B2QTkxejN3UGZBOTF6N3dQZkFCdzZMN3dHTDcvZGM3L2RjN3dNVWNQZkErYlFWSlFyN2VQc2tGV1ZzQlRwTFZpZUwrd01JKzFYM01mc3g5MVgzVmZjeDl6SDNWUjZMOXdOWDd6bkxDR1dxVFQyd2JBWEZYYkpFaXpzSSt4LzdBL3NEK3gvN0gvc0Q5d1AzSHg2TDI2L1N4YmtJczZvRkRvdjN3Ty92Ny9kY0FZdnY3L2drNys4REZCejNYUG0wRmZ0YytDVDNYQWY4NC92QUZZV0lpSVVmKzY0SGhZNklrUjdtOTF6NDdQdGM1Z2FSam82UkgvZXVCNUdJam9VZS9PUDdYQlg3d1Bnazk4QUhEcUIyNysvdjcrL3ZBWXZ2K096dkEvbFFCUDFRNy9sUUIvanNGdjFRNy9sUUIvenNKeFVuOTF6dkJ5ZjdYQlVuOTF6dkJ5ZjdYQlVuOTF6dkJ3NzNlKzhCOTluNVVCVmgreHhpK3h4aCt4MElpSkdDcmZ0UWk0c245d2lMQmFjMHB6U25NN1gzR2JUM0dyWDNHYlA3RkxUN0ZMSDdGYkhtc09ldzV3aVliL2Q3aTR2dit6MkxCVzdGYjhSdHhHNUJiVUZ1UVYvM0gxNzNIMkgzSVFnTzcvanMvT3ozWEJLTDkxeUw5MXlMOTF3VGtQZGMrT3dWaTIrZGQ1Vnpqb1dMZ1l0L0NCT28rM3Y4N1BkN0JvdVhpNVdJa1lHamVaK0xwd2pFdHJiRXhMWmdVaDZMYjNsM2dYT0loWXVCaTM4STkzdjNld2FYaTVXTGtZZ0lFMGlqZ1o5NXA0c0l4TGEyeE1SZ3RsSWZiNHQzZVhPQmhZaUJpMytMQ1BkNyszc0hpNWVMbFk2UkNCT1FsYU9kbjR1bkNNUmd0bEllVW1CZ1VoOE9raWZ2K096dkFmZFo3Ky92QS9lTCtWQVZOb3RNY1dOalkyTjlXWVpsQ085L0JZK2xrNk9lbnA2ZXFwM05pODJMcjN1ZmVaOTVrM1NMY29zNGFIUlpYMWxmU2t1TCt3a0ljdStrQjR2ZXFxSzl0NzIzME11TDl3bUx1M3ZCWUxKZ3NrdWZONHNJV2YxUUZTZnY3d2NPaS9kYzcvZkErMXo0SkJMdjcrL3Y3KzhVSEJPOCtGYjV0QlVUM1BzTml5RTFkUHNHQ0JPOCt3SXhNZnNDSDR0WG4xMnNad2dUM0tXaHJaZXdpNStMbm9hY2hBZ1R2SnpMeGJ2UWk5Q0x4VnVjU3dnVDNKeVNucENmaThxTHdHU2hWTXVjdThXTDBJdk1ZY3RSb0FpOUIvY2Urd1QzQlBzZUh2c0kvSWdWZUlWOGRZdDNDSXVKaS90Y0JXK2hkYWVub2FHbkhvdjNYSXVNQmFkMW9XOGVpSXVJaW9pTENJZ0crMkFuRlhpRmZIV0xkd2lMaVlzbkJXK2hkYWVub2FHbkhvdnZpNHdGcDNXaGJ4NklpNGlLaUlzSWlBYjRJQlo0aFh4MWkzY0lpNG1MSndWdm9YV25wNkdocHg2TDc0dU1CYWQxb1c4ZWlJdUlpb2lMQ0ljR0RxQjI3Ky80Sk84QitPejV0QlVuV1Fkb2kzYUFkWEFJK3lIN1J2c3Q5MFlGZGFWMWwybUxDQ2NuN3dhT2lQYzMrMVA3T3Z0aUo0dUxKKytMQmE2TG9KYWhwZ2ozTGZkUzl6cjdVZ1doY2FCL3Jvc0lwQ2NHOTF6M0t2dGM5eXFMSjNXTGhZNzdRL2RpOXkzM1U3MkxpeWYzWFBjcUJRNkw3L2pzN3dHTDd3UDRKUG0wRmZ0dyswajdTUHR3KzNEM1NQdEk5M0FmOXdLTDhiZlQwd2hEMHdWVlZVQnBPSXNJK3pyN0d2Y2E5enIzT3ZjYTl4cjNPaC9laTlObndWUUkrd0g3QWZmQWk0djN3UHNMK3dzRlE5TW91dnNDaXdnT29IWUIrQ1Q1dEJYM092czYvQ1Q4SlBzNjl6cUwvQ1Q0Skl2N092YzYrQ1Q0SlBjNit6cUwrQ1FGRHZhZ2RnSDNYTzhEOTQ3NXRCWDdqdnZBOTF5TGkvdGMrMXlMOTQ3N3dQZU85OEQ3WEl1TDkxejNYSXNGRHZmQTd3SDN3UGpzRmZ2QSs0NzN3UHVPaS9kYzkxeUxpL3RjOThEM2p2dkE5NDZMKzF6N1hJc0ZEcUIyK096M1hBSDQ3UGRjQS9tMEJQdGNCL2ZoOTUvN24vdmhIL2RjQnZoTisvdjMrL3hOSHZ2QUJQdGNCL2M3OXhuN0dmczdIL2RjQnZlbiszWDNkZnVuSHZ2QUJQdGM5MXdIOXdJeDVmc0NIZzZMOTF6djcrL3Y3KzhCaS9kYzcrL3Y3Ky92QSsvNXRCVW5CL2ZnOTZEN29QdmdIKzhHK0JiN3p2Zk8vQlllKzF3RUp3ZjNjdmRHKzBiN2NoL3ZCdmVvKzNUM2RQdW9IdnRjQkNjSDl3UGtNdnNESCs4Rzl6bjdHL2NiK3prZSsxd0VLZ29PaS9nay9DVHYrQ1Qzd0NmdkVvdnY3KzhUWFBmQStiUVZWRjVlVkIvOHVnZHZkWFZ2YjNXaHB4NzNLaWY3WEFkVXVGN0NIaE9NK0lnR0UwekN1TGpDSHhPYzk4RDhKUGVPQjZlaG9hZW5vWFZ2SGhNcyt5cjRKQWNUSFBkY0J4TXN3bDY0VkI0T2krLzRpTzhCaSsvNEpPOEQxdmxRRldKcGFXSWYvTG9IWXExcHRCNzRWZ2EwcmEyMEgvY1JKeWY4SlBpSTkxenZCL2ZBRmljSCsyR0wrenI3TG5UN1c2RGoyc3pwaXdqM1hDY0c5MXozWEFVT29IYjN3UGRjQWZpSStWQVYrMXdIL0NRbisySDd1eCsvOTFyM0tQSDNYSXNJNy90Y0J2ZkE5OUFGRG92dkFmZ1IrYXNWK3hOVyt4SlUreFJYQ0d3SGkvczZ6dnNtMnlDelZyWmZ0V3kxYkxOMXVZdTVpN09odGFxMXFyYTNzOERiOWM3M0o0djNPZ2lxQi9zVXYvc1N3dnNUd0FoNGxBWDlVQVNIaTI2U2FxTnFvMld6YUxsTDRGbjNDWVAzRWdqM3V2Y09CUTZnZGdHTDcrL3Y3Ky92N3dQNDdQbTBGU1FLKzhBbkZmMVE3L2xRQi92QSsxd1YvSWp2K0lnSCs4RDdYQlg3d08vM3dBY09vSGI0SlBkY0ovZGNFdmZBN3hPdzk4RDV0QlVuKzF3SEU5QW5Kd1VUc084bjkxeUxpL3lJNzRzRkU5RDRKUGRjQnhPdzcrOEZFOUFuNy90Y2k0djNYQVVPb0hiM3dPL3Y3Ky92QWZkYzd3UDNYUG0wRlVBSzd4WW45MXp2Qi90Yysxd1ZKL2ZBN3dmN3dQdGNGU2Y0Sk84SERxQjI5OER2Nysvdjd3SDNYTzhEOTF6NXRCVkFDdThXSi9nazd3ZjhKUHRjRlNmM3dPOEgrOEQ3WEJVbjkxenZCdzZMNysvdjcrL3Y3d0dMNysvditDVHZBOWI1VUJWaWFXbGlIL3k2QjJLdGFiUWUrUjRHdEsydHRCLzR1Z2UwYWExaUh2MEZKeFh2SnljRzkxenZGVElLKzF3bkZlOG5Kd2IzWE84Vk1ncjdYQ2NWN3ljbkJ2ZGM3eFV5Q2c2Z2RnSDRKUG0wRlNmN3dQdkFpL2VPKzF3bis4RDNqdmRjOTQ3N1hDZjN3UGVPOTF6N3dJc0ZEb3Z2aSsvM0t1LzNLdStMN3hLTDc0dnY5eXJ2OXlydmkrOFRLUUQ0SlBtMEZURUtFek1BKzQ0bkZURUsrSWdXRXpHQUt3cjdqaWNWRTNPQUpncjc4dnNxRlJNbEFDc0srVkFXRXlGQUt3b1RZd0Q4N1B1T0ZURUsrSWdXRTJHQUt3b1RvUUQ3amljVk1Rb09vSGIzS3IzNGlPOEJpKy80aU84RHJmbTBGWGw3ZTNrZi9YQUhlWnQ3blI3NURBYWRtNXVkSC9sd0I1MTdtM2tlL01vbkZmaUkvSWo4aUFiM2psa1ZzWXVrWVhocWVHcFppM2lzZUt5a3RiR0xDQTZnZHZsUTd3R0w3d1A1dEFTTCs4RDRpUHlJOThEM3dQeUkrSWdGSnljVlBBb08rSWp2QVl2dkEvanNCSXY3WFBmQSs4RDNYUGRjKzhEM3dBWDNJQmIzd2Z2QSt3djdEdGs5OTF6M1hQdkE5OEFGKy9JbkZTa0tEb3Z2NysvM1hPL3Y3d0dMNysvdjkxenY3KzhEK0NUNXRCVW5DaWNFTFFvbkJDWUtKd1REdDE5VFUxOWZVMU5mdDhQRHQ3ZkRIdzZMNy9pSTd3R0w3L2lJN3dQNVVBVDlVUGxROS9zSEp5ZUwrelA4aUl1TCtJajMrNHZ2N3dYM0lSYjd3UHZBSis4bkovZGMrMXo0SlBna0JRNkwrQ1R2OThBQitWRHZBNVQ1dEJXRmlJaUZILzJpQjRXT2lKRWUrYUlHa1k2T2tSLzVvZ2VSaUk2Rkh2MFZQUlgzUVB0QSswRDdRRVBUNys4bjd3WDMxdnNxRmZmQUovdkFCZzZMNy9qczd3R0x2ZmVPOTF6M2pyMERGRGo1dEFUN1hMMEh3cmk0d2g3M0t2eTZCbTkxZFc4ZVdTZjRKTzlaQm05MW9hY2YrTHIzS2dmQ3VGNVVINzMzWEFZT2krL3YrSWo3d093VGdQbFFCQ1VLRThEdkZ2d2tCNmVMcElLZWVBZ1RvSjU0NnZ0Vm1YR1pjYVYrcFpPbGs1aW9nNldEcFdUM0dZdWtDS1NocEtjZTl5b0dFOENub2FHbnB5VDN0NHNmZzUxNW1IYUxDQTZnZGhLTDcrLzRpUHZBN0JQUStDVDVMaFY5Y1N6N1ZYaDRDQlBnZUhoeWdtK0xDUHdrOS9JSG9JdWRtSk9kQ0l2eTk3ZW5wM1doYngvN0tnWnZkYVNrSHhQUWk2U3k5eG1UcFpPbGZxaHhrd2g0amdWNGlYbCtnWGdJL0NUN25oVWxDZzRuNy9pSTdJN3ZBWXZ2K0lqdkEvZGMrVkFWSisrSUIvcytjL3NXK3llTCswUUkrMVgzTWZzeDkxWDNWZmN4OXpIM1ZSNkx0NEMyZmJFSU1HWUZsbStRYm90c0NQc2Yrd1A3QS9zZit4LzdBL2NEOXgvM0gvY0Q5d1AzSHg2cGk2bUdwNEFJcmVrRmRaTnlqM0tQQ0pIdjd3ZjNYUHNJRll1TC9BRDdySGQzZDNlTGI1OTNuM2VuaTUrZm41LzN2UGZ3aTRzSURxQjI3Ky8zd084QitPejVVQlVuL093bitPd25CL2RjOXlvRi9PejdqaFg3WFBzcTkxejdLb3Z2K095TGkrLzg3SXNGRG92ditJajNYUHRjN3hMdjcrL3Y3KzhVSEJQYzk4RDV0QlVUdkZSZVhsUWZKd1pVWGw1VUgvbFFCc0pldUZRZUp3WVQzTUpldUZRZSs4RDd3Qlg4ZFFlQWs0T1dIdmhpQnBhVGs1WWYrSFVuKy9JSGIzVjFiMjkxb2FjZTkvSW4rL0lIYjNWMWIyOTFvYWNlOS9JSERvdnY3KzhCNy9kYzkxenZBKy81dEJYOEpBZjdBdmNFTWZjZUhyMEc5d0xsNWZjQ0gvZ2tKL3drQjFSZVhsUlVYcmpDSHZna0IvdkEvVkFWSi9sUTd3Y09pKy92K0lnQmkvZGM3L2RjNy9kY0F4UTRsUGxRRlVFSytEWVdRUXI4ZHZ0Y0ZVSUsvSC84SkJVaENnNkw5MXduNysvdjcvZGMrMXp2RW92M1hPLzNYTy8zWEJRSEV6ZVYrVkFWaFllSWhSLzdVL2RjOTFNSGtZaU9oUjc0TnhhR2hvaUZIL3RUOTF6M1V3ZVJpSTZGSGhNdi9IVW5GWVdIaUlVZk1QZGM1Z2VSaUk2Rkh2eC8rMXdWSVFvVHAvMjArMXdWKzFNSGhZNklrUjczU2dhUmpvNlJIL2RUQnhObjd4WXdCNFdQaUpFZTkwa0drWTZPa1IvbUJ4T243eGI3VXdlRmo0aVJIdmRKQnBHT2pwRWY5MU1IRG92NGlPL3ZBWXYzWE8vM1hPLzNYQU1VT1BsUUJDRUsvYXY3WEJWQkN2Y0tGa0lLOXdvV1FRb083L2lJQWIzNDdCVnZkWFZ2SC93a0IyK2hkYWNlK0lnR3A2R2hweCtMOXlydkorK0xpL2ZBSjRzbko0djNLZ1duZGFGdkhnNmdkdS92K0NUdkFZdjRKTy92Nys4RDkrTDV0QlZEQ3UvN1hCV2NpNXlKbTRmaGRjczlpeTJMTFVzOU5YVjdoM3FKZW9zSUp3ZWtpNk9Pb3BFSWpnYjNGcXpxOXdxTDl5Q0w5eUFzOXduN0ZxeDBrWEdQY1lzSSsxd0VSQW9POXFCMkFZdjRKTy92QS9maStiUVZRd3J2KzhBVlJBb09McUIyQVl2NEpBUDM0dm0wRlVNS0RvdnY3KzhCOThuNXRCV0ZpNGVIaVlZSSs3cjlQb2g0aXpvRmhZNklrUjc1UGdhUmpvNlJINHZjaUo3N3V2aytCWW1RaDQrRml3Z3crOEFWNy90Y0p3WW5CTzhuSndZT2kvZGM5MXp2OTF6dkFmZW45MXdEK0F2NXRCWDdIb3Y3RkdUN0FVVUl3RGtGNk1iM0FxdjNDNHYzREl2M0JHem9Ud2pBM1FYN0FkSDdGN0w3SG9zSSs4QUVQSXREZFUxakNNRTJCYnFwdjV6SGk4YUx4WHE1YlFqQTRBVk5zaitpUFlzSSs4QUVLZ29PK0N1THZmZU85MXdCOThIM1hBUDR1L20wRmZzZSt3VDdCUHNlSDR0cmsyeVdid2o3dC91ekJXUmtpMG15Wko5M3BZT2xpNldMcFpPZm53ajN0UGUzQmFlQXFZT3JpL2NlaS9jRTl3U0w5eDZMbTR1YmlKb0lLaXI3WEl1TDkxenM3QVY4am51TGU0c0kvRmI5SGhVcENnNzNJZmxRRmZzaCt5RUYzemZlTnQ0M09EZzVOelk3Q1BjaCt5UDNrZmVSQmQwMzN6amNOUWozSS9jakJUWGNPTjgzM1FqM2tmZVIreVAzSVFVN05qWTVPVGczM2piZU45OElEcUIyOTF6djcrOEI5OER2QS9tMEJQZDErOEQ3ZFl1TEovZkFpNHNuKzhDTGl5ZjN3SXVMKzF6dmk0djNYUGZBaTR2dis4Q0xpKzhGOThEdiszVUc5M1gzd0NlTCszdjd3R1dMKzN2M3dBVU8rQ3Z2Ny9kYzcvZGM3d0dMNy9kYzcvZGM3d01VL1BmeStiUVZSUW9uQkVZS1dTY1ZKeWNuN3lmdjcrL3ZKKzhIRHZncjcrLzNYTy8zWE84QmkrLzRpTzhERk9EMzh2bTBGVVVLSndSR0N2c3ErMXdWSi9mQTd3Y08rYlFVK0lFVm5nd0s3d3E5dDVIdnZiM3ZqK3Z2OTF3TURPOEx2YjN2azdXYnJaTG83Ky8zWEF3TkhBQXVFd0FuQWdBQkFBOEFGUUFiQUQwQVJBQkxBR1VBaHdDZkFMRUF3d0RWQVAwQkh3RlFBVmdCWUFGekFYb0JoZ0dTQWFNQnVRSEJBZHNCOGdJSUFoQUNJZ0l0QWpVQ1F3SllBbllDbEFLc0FzQUREZ05BSi9nay9JajhKQ2Y0aVBsUUJ3c24rYlR2QndzbitPenZCd3Y3Y2Z0SCswZjdjZnR4OTBmN1IvZHg5M0gzUi9kSDkzSDNjZnRIOTBmN2NSOEwvYlR2K2JRSEMvd2s3L2drQnd2N0FqRXgrd0w3QXVVeDl3TDNBdVhsOXdMM0FqSGwrd0lmQy90dyswajdTUHR3KzNEM1NQdEk5M0QzY1BkSTkwajNjUGR3KzBqM1NQdHdId3Vub1hWdkh5Y0hiM1YxYjI5MW9hY2U3d2Vub2FHbkhndW5vWFZ2YjNWMWIyOTFvYWVub2FHbkh3dFVYbDVVVkxoZXdzSzR1TUxDWHJoVUh3dHZkWFZ2YjZGMXA2ZWhvYWVuZGFGdkh3djNLdnNxOXlyM0t0TkQreXI3S3ZjcSt5cERRL3NxOXlyN0t2c3FROVAzS3ZjcSt5cjNLZ1VMOXpyM0d2c2ErenI3T3ZzYSt4cjdPdnM2K3hyM0d2YzY5enIzR3ZjYTl6b2ZDL3NOaXlFMWRQc0dDUHNDTVRIN0F2c0M1VEgzQWgvNFZnYmV6czdlSDR2TVljdFJvQWk5Qi9jZSt3VDNCUHNlSGd2N1hQbTA5MXdIQy8yMDkxejV0QWNMYjNWMWIyK2hkYWVub2FHbkg2ZDFvVzhlQy9na0ovd2tCZ3VML096M3dQZkFpL2ZBQlF2N3dQdkFpL3ZBOThDTEJRdjdPZnNiK3h2N09SLzd3UGZBOThBSEMvc0RNakw3QXg0bkIvYzU5eHYzRy9jNUgvZkFCd3Y3WFBkYzkxd0hDL2NDNVRIN0F2c0NNVEg3QXZzQ01lWDNBdmNDNWVYM0FoOExpL3drOXlyM0t2Y3EreXJ2Ny9zcTl5cjNLdmNxQlFzbkovY3EreXI3S3ZzcStDU0xpL2drK3lyN0tnVUwrOEQzd1BmQUJ3dkN1RjVVVkY1ZVZGUmV1TUxDdUxqQ0h3djd3UHZBSi9naytDUUhDL3pzOTF6NDdBY0xPRWhJT0RqT1NON2V6czdlSHd2ODdQdGNCL2VPKzF6M2p2ZGMrMXlMaS9qc0JRdUZpSWlGSC94MkI0V09pSkVlOTBvR2tZNk9rUi80ZGdlUmlJNkZIZ3VGaUlpRkgvdXVCNFdPaUpFZTkwb0drWTZPa1IvM3JnZVJpSTZGSGd2N0d2dGMrMXlMaS93azkxeUw5eHI3WE0yTGkvbTBCUXVMKzF5a2pnVzJscXV6aTdtTHVXeXpYNVlJQy90Vit6SDdNZnRWKzFYM01mc3g5MVVmeUl2Rm03Mm5qWWVQaFk2SUNPOGtCWnQ3ckgyaWk4T0x1Ym1MdzR1aWZheDdtd2drN3dXSWpvV1BoNDJtdlp6Rmk4Z0k5MVg3TWZjeCsxVWVDL2NmOXdQN0Evc2ZINHRRZUZWcFlBaUlpQVYvaFg5OWhJQmZabEowVFlzSSt4LzdBL2NEOXgvM0gvY0Q5d1AzSHg4TEFBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQUdRQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBQ1dBQUFBeUFBQUFHUUFBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBR1FBQUFCa0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUE0UUFBQU1nQUFBRElBQUFBeUFBQUFHUUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFHUUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURoQUFBQWxnQUFBT0VBQUFDV0FBQUFsZ0FBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXJ3QUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQjlBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQUJrQUFBQXlBQUFBTWdBQUFEaEFBQUF5QUFBQU1nQUFBRGhBQUFBQUFBQUFBQUFBRUFBQUFBekQyaXp3QUFBQURQMlM5cUFBQUFBTS9aTDJvPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMub3RmXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5vdGZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCemRHRnVaR0ZzYjI1bFBTSnVieUkvUGdvOElVUlBRMVJaVUVVZ2MzWm5JRkJWUWt4SlF5QWlMUzh2VnpOREx5OUVWRVFnVTFaSElERXVNUzh2UlU0aUlDSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OUhjbUZ3YUdsamN5OVRWa2N2TVM0eEwwUlVSQzl6ZG1jeE1TNWtkR1FpSUQ0S1BDRXRMUW95TURFMExUY3RNVG9nUTNKbFlYUmxaQzRLTFMwK0NqeHpkbWNnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLUEcxbGRHRmtZWFJoUGdwRGNtVmhkR1ZrSUdKNUlFWnZiblJHYjNKblpTQXlNREV5TURjek1TQmhkQ0JVZFdVZ1NuVnNJQ0F4SURJd09qTTVPakl5SURJd01UUUtJRUo1SUZBdVNpNGdUMjV2Y21rS1EzSmxZWFJsWkNCaWVTQlFMa291SUU5dWIzSnBJSGRwZEdnZ1JtOXVkRVp2Y21kbElESXVNQ0FvYUhSMGNEb3ZMMlp2Ym5SbWIzSm5aUzV6Wmk1dVpYUXBDand2YldWMFlXUmhkR0UrQ2p4a1pXWnpQZ284Wm05dWRDQnBaRDBpYjNCbGJpMXBZMjl1YVdNaUlHaHZjbWw2TFdGa2RpMTRQU0k0TURBaUlENEtJQ0E4Wm05dWRDMW1ZV05sSUFvZ0lDQWdabTl1ZEMxbVlXMXBiSGs5SWtsamIyNXpJZ29nSUNBZ1ptOXVkQzEzWldsbmFIUTlJalF3TUNJS0lDQWdJR1p2Ym5RdGMzUnlaWFJqYUQwaWJtOXliV0ZzSWdvZ0lDQWdkVzVwZEhNdGNHVnlMV1Z0UFNJNE1EQWlDaUFnSUNCd1lXNXZjMlV0TVQwaU1pQXdJRFVnTXlBd0lEQWdNQ0F3SURBZ01DSUtJQ0FnSUdGelkyVnVkRDBpT0RBd0lnb2dJQ0FnWkdWelkyVnVkRDBpTUNJS0lDQWdJR0ppYjNnOUlpMHdMalVnTFRFd01TQTRNRElnT0RBd0xqRXlOaUlLSUNBZ0lIVnVaR1Z5YkdsdVpTMTBhR2xqYTI1bGMzTTlJalV3SWdvZ0lDQWdkVzVrWlhKc2FXNWxMWEJ2YzJsMGFXOXVQU0l0TVRBd0lnb2dJQ0FnZFc1cFkyOWtaUzF5WVc1blpUMGlWU3RGTURBd0xVVXdSRVVpQ2lBZ0x6NEtJQ0FnSUR4dGFYTnphVzVuTFdkc2VYQm9JQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlJaUIxYm1samIyUmxQU0ltSTNobE1EQXdPeUlnQ21ROUlrMHpNREFnTnpBd2FEVXdNSFl0TnpBd2FDMDFNREIyTVRBd2FEUXdNSFkxTURCb0xUUXdNSFl4TURCNlRUUXdNQ0ExTURCc01qQXdJQzB4TlRCc0xUSXdNQ0F0TVRVd2RqRXdNR2d0TkRBd2RqRXdNR2cwTURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l4SWlCMWJtbGpiMlJsUFNJbUkzaGxNREF4T3lJZ0NtUTlJazB6TURBZ056QXdhRFV3TUhZdE56QXdhQzAxTURCMk1UQXdhRFF3TUhZMU1EQm9MVFF3TUhZeE1EQjZUVEl3TUNBMU1EQjJMVEV3TUdnME1EQjJMVEV3TUdndE5EQXdkaTB4TURCc0xUSXdNQ0F4TlRCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01ESTdJaUFLWkQwaVRUTTFNQ0EzTURCak1Ua3pJREFnTXpVd0lDMHhOVGNnTXpVd0lDMHpOVEIyTFRVd2FERXdNR3d0TWpBd0lDMHlNREJzTFRJd01DQXlNREJvTVRBd2RqVXdZekFnTVRNNElDMHhNVElnTWpVd0lDMHlOVEFnTWpVd2N5MHlOVEFnTFRFeE1pQXRNalV3SUMweU5UQmpNQ0F4T1RNZ01UVTNJRE0xTUNBek5UQWdNelV3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeklpQjFibWxqYjJSbFBTSW1JM2hsTURBek95SWdDbVE5SWswME5UQWdOekF3WXpFNU15QXdJRE0xTUNBdE1UVTNJRE0xTUNBdE16VXdZekFnTVRNNElDMHhNVElnTWpVd0lDMHlOVEFnTWpVd2N5MHlOVEFnTFRFeE1pQXRNalV3SUMweU5UQjJMVFV3YURFd01Hd3RNakF3SUMweU1EQnNMVEl3TUNBeU1EQm9NVEF3ZGpVd1l6QWdNVGt6SURFMU55QXpOVEFnTXpVd0lETTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTkNJZ2RXNXBZMjlrWlQwaUppTjRaVEF3TkRzaUlBcGtQU0pOTUNBM01EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZUVEV3TUNBMU1EQm9OakF3ZGkweE1EQm9MVFl3TUhZeE1EQjZUVEFnTXpBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHhNREFnTVRBd2FEWXdNSFl0TVRBd2FDMDJNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTFJaUIxYm1samIyUmxQU0ltSTNobE1EQTFPeUlnQ21ROUlrMHdJRGN3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1DQTFNREJvTmpBd2RpMHhNREJvTFRZd01IWXhNREI2VFRBZ016QXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB3SURFd01HZzJNREIyTFRFd01HZ3ROakF3ZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOaUlnZFc1cFkyOWtaVDBpSmlONFpUQXdOanNpSUFwa1BTSk5NQ0EzTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUSXdNQ0ExTURCb05qQXdkaTB4TURCb0xUWXdNSFl4TURCNlRUQWdNekF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWsweU1EQWdNVEF3YURZd01IWXRNVEF3YUMwMk1EQjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJM0lpQjFibWxqYjJSbFBTSW1JM2hsTURBM095SWdDbVE5SWswME1EQWdOekF3WXpjMUlEQWdNVFEySUMweU15QXlNRFlnTFRVNWJDMDNOU0F0TWpJMWJDMHpNaklnTWpNMFl6VTNJRE14SURFeU1pQTFNQ0F4T1RFZ05UQjZUVEV5TlNBMU9EaHNNVGt4SUMweE16aHNMVE14TUNBdE1qSXlZeTAwSURJMElDMDJJRFEzSUMwMklEY3lZekFnTVRFMElEUTVJREl4TlNBeE1qVWdNamc0ZWswMk9EZ2dOVGMxWXpZNUlDMDNNaUF4TVRJZ0xURTJPQ0F4TVRJZ0xUSTNOV013SUMwek5TQXRPQ0F0TmpnZ0xURTJJQzB4TURCb0xUSXhPSHBOTWpFMklESTFNMnd4TVRJZ0xUTTBOMk10TVRJNElESXpJQzB5TXpJZ01UQTVJQzB5T0RjZ01qSXllazB6TnpJZ01UQXdDbWd6TnpKakxUWTBJQzB4TURrZ0xURTNOeUF0TVRnMUlDMHpNVEFnTFRFNU4zb2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXdPRHNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5NakF3SURnd01HZ3hNREIyTFRVd01HZ3lNREJzTFRJME55QXRNekF3YkMweU5UTWdNekF3YURJd01IWTFNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpraUlIVnVhV052WkdVOUlpWWplR1V3TURrN0lpQUtaRDBpVFRRd01DQTRNREJqTWpJeElEQWdOREF3SUMweE56a2dOREF3SUMwME1EQnpMVEUzT1NBdE5EQXdJQzAwTURBZ0xUUXdNSE10TkRBd0lERTNPU0F0TkRBd0lEUXdNSE14TnprZ05EQXdJRFF3TUNBME1EQjZUVE13TUNBM01EQjJMVE13TUdndE1qQXdiRE13TUNBdE16QXdiRE13TUNBek1EQm9MVEl3TUhZek1EQm9MVEl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVlTSWdkVzVwWTI5a1pUMGlKaU40WlRBd1lUc2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qRWdNQ0EwTURBZ0xURTNPU0EwTURBZ0xUUXdNSE10TVRjNUlDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGM1SUMwME1EQWdOREF3Y3pFM09TQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNR3d0TXpBd0lDMHpNREJzTXpBd0lDMHpNREIyTWpBd2FETXdNSFl5TURCb0xUTXdNSFl5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01HSTdJaUFLWkQwaVRUUXdNQ0E0TURCak1qSXhJREFnTkRBd0lDMHhOemtnTkRBd0lDMDBNREJ6TFRFM09TQXROREF3SUMwME1EQWdMVFF3TUhNdE5EQXdJREUzT1NBdE5EQXdJRFF3TUhNeE56a2dOREF3SURRd01DQTBNREI2VFRRd01DQTNNREIyTFRJd01HZ3RNekF3ZGkweU1EQm9NekF3ZGkweU1EQnNNekF3SURNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZeUlnZFc1cFkyOWtaVDBpSmlONFpUQXdZenNpSUFwa1BTSk5OREF3SURnd01HTXlNakVnTUNBME1EQWdMVEUzT1NBME1EQWdMVFF3TUhNdE1UYzVJQzAwTURBZ0xUUXdNQ0F0TkRBd2N5MDBNREFnTVRjNUlDMDBNREFnTkRBd2N6RTNPU0EwTURBZ05EQXdJRFF3TUhwTk5EQXdJRGN3TUd3dE16QXdJQzB6TURCb01qQXdkaTB6TURCb01qQXdkak13TUdneU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVFpSUhWdWFXTnZaR1U5SWlZamVHVXdNR1E3SWlBS1pEMGlUVE13TUNBMk1EQjJMVEl3TUdnMU1EQjJMVEV3TUdndE5UQXdkaTB5TURCc0xUTXdNQ0F5TkRkNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltVWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01HVTdJaUFLWkQwaVRUVXdNQ0EyTURCc016QXdJQzB5TkRkc0xUTXdNQ0F0TWpVemRqSXdNR2d0TlRBd2RqRXdNR2cxTURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ptSWlCMWJtbGpiMlJsUFNJbUkzaGxNREJtT3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB5TURBZ09EQXdhREl3TUhZdE5UQXdhREl3TUd3dE1qazNJQzB6TURCc0xUTXdNeUF6TURCb01qQXdkalV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1UQWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01UQTdJaUFLWkQwaVRUTXdNQ0EzTURCMkxUSXdNR2cxTURCMkxUSXdNR2d0TlRBd2RpMHlNREJzTFRNd01DQXlPVGQ2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpFeElpQjFibWxqYjJSbFBTSW1JM2hsTURFeE95SWdDbVE5SWswMU1EQWdOekF3YkRNd01DQXRNamszYkMwek1EQWdMVE13TTNZeU1EQm9MVFV3TUhZeU1EQm9OVEF3ZGpJd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNVElpSUhWdWFXTnZaR1U5SWlZamVHVXdNVEk3SWlCb2IzSnBlaTFoWkhZdGVEMGlOakF3SWlBS1pEMGlUVEk1TnlBNE1EQnNNekF6SUMwek1EQm9MVEl3TUhZdE5UQXdhQzB5TURCMk5UQXdhQzB5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqRXpJaUIxYm1samIyUmxQU0ltSTNobE1ERXpPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHlORGNnT0RBd2JESTFNeUF0TXpBd2FDMHlNREIyTFRVd01HZ3RNVEF3ZGpVd01HZ3RNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeE5DSWdkVzVwWTI5a1pUMGlKaU40WlRBeE5Ec2lJQXBrUFNKTk5EQXdJRGd3TUdneE1EQjJMVGd3TUdndE1UQXdkamd3TUhwTk1qQXdJRGN3TUdneE1EQjJMVFl3TUdndE1UQXdkall3TUhwTk5qQXdJRFl3TUdneE1EQjJMVFF3TUdndE1UQXdkalF3TUhwTk1DQTFNREJvTVRBd2RpMHlNREJvTFRFd01IWXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpFMUlpQjFibWxqYjJSbFBTSW1JM2hsTURFMU95SWdDbVE5SWsweE1UWWdOakF3YkRjeUlDMDNNbU10TlRRZ0xUVTBJQzA0T0NBdE1USTJJQzA0T0NBdE1qQTVjek0wSUMweE5Ua2dPRGdnTFRJeE0yd3ROeklnTFRjeVl5MDNNaUEzTWlBdE1URTJJREUzTlNBdE1URTJJREk0TlhNME5DQXlNRGtnTVRFMklESTRNWHBOTmpnMElEWXdNR00zTWlBdE56SWdNVEUySUMweE56RWdNVEUySUMweU9ERnpMVFEwSUMweU1UTWdMVEV4TmlBdE1qZzFiQzAzTWlBM01tTTFOQ0ExTkNBNE9DQXhNekFnT0RnZ01qRXpjeTB6TkNBeE5UVWdMVGc0SURJd09YcE5NalU1SURRMk1HdzJPU0F0TnpKakxURTRJQzB4T0NBdE1qZ2dMVFF4SUMweU9DQXROamtLY3pFd0lDMDFOQ0F5T0NBdE56SnNMVFk1SUMwM01tTXRNellnTXpZZ0xUVTVJRGc1SUMwMU9TQXhORFJ6TWpNZ01UQTFJRFU1SURFME1YcE5OVFF4SURRMU9XTXpOaUF0TXpZZ05Ua2dMVGcxSURVNUlDMHhOREJ6TFRJeklDMHhNRGdnTFRVNUlDMHhORFJzTFRZNUlEY3lZekU0SURFNElESTRJRFEwSURJNElEY3ljeTB4TUNBMU1TQXRNamdnTmpsNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqRTJJaUIxYm1samIyUmxQU0ltSTNobE1ERTJPeUlnYUc5eWFYb3RZV1IyTFhnOUlqUXdNQ0lnQ21ROUlrMHlNREFnT0RBd1l6RXhNQ0F3SURJd01DQXRPVEFnTWpBd0lDMHlNREJ6TFRrd0lDMHlNREFnTFRJd01DQXRNakF3Y3kweU1EQWdPVEFnTFRJd01DQXlNREJ6T1RBZ01qQXdJREl3TUNBeU1EQjZUVEV3TUNBek1UbGpNekVnTFRFeElEWTFJQzB4T1NBeE1EQWdMVEU1Y3pZNElEZ2dNVEF3SURFNWRpMHpNVGxzTFRFd01DQXhNREJzTFRFd01DQXRNVEF3ZGpNeE9Yb2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNVGNpSUhWdWFXTnZaR1U5SWlZamVHVXdNVGM3SWlBS1pEMGlUVFF3TUNBNE1EQmpNakl3SURBZ05EQXdJQzB4T0RBZ05EQXdJQzAwTURCekxURTRNQ0F0TkRBd0lDMDBNREFnTFRRd01ITXROREF3SURFNE1DQXROREF3SURRd01ITXhPREFnTkRBd0lEUXdNQ0EwTURCNlRUUXdNQ0EzTURCakxURTJOaUF3SUMwek1EQWdMVEV6TkNBdE16QXdJQzB6TURCak1DQXROallnTWpFZ0xURXlOaUExTmlBdE1UYzFiRFF4T1NBME1UbGpMVFE1SURNMUlDMHhNRGtnTlRZZ0xURTNOU0ExTm5wTk5qUTBJRFUzTld3dE5ERTVJQzAwTVRsak5Ea2dMVE0xSURFd09TQXROVFlnTVRjMUlDMDFObU14TmpZZ01DQXpNREFnTVRNMElETXdNQ0F6TURBS1l6QWdOallnTFRJeElERXlOaUF0TlRZZ01UYzFlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l4T0NJZ2RXNXBZMjlrWlQwaUppTjRaVEF4T0RzaUlBcGtQU0pOTUNBM01EQm9NVEF3ZGkwMk1EQm9OekF3ZGkweE1EQm9MVGd3TUhZM01EQjZUVFV3TUNBM01EQm9NakF3ZGkwMU1EQm9MVEl3TUhZMU1EQjZUVEl3TUNBMU1EQm9NakF3ZGkwek1EQm9MVEl3TUhZek1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakU1SWlCMWJtbGpiMlJsUFNJbUkzaGxNREU1T3lJZ0NtUTlJazB6T1RjZ09EQXdZekV6SURFZ01qTWdMVFFnTXpRZ0xURXpZeklnTFRJZ01qRTBJQzB5TlRRZ01qUXhJQzB5T0Rkb01USTRkaTB4TURCb0xURXdNSFl0TXpZMll6QWdMVEU0SUMweE5pQXRNelFnTFRNMElDMHpOR2d0TlRNeVl5MHhPQ0F3SUMwek5DQXhOaUF0TXpRZ016UjJNelkyYUMweE1EQjJNVEF3YURFeU9Hd3lNelFnTWpneFl6a2dNVEVnTWpJZ01UZ2dNelVnTVRsNlRUUXdNQ0EyTnpKc0xURTBOQ0F0TVRjeWFESTRPSHBOTWpVd0lETXdNR010TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCMkxURXdNR013SUMweU9DQXlNaUF0TlRBZ05UQWdMVFV3Y3pVd0lESXlJRFV3SURVd0NuWXhNREJqTUNBeU9DQXRNaklnTlRBZ0xUVXdJRFV3ZWswMU5UQWdNekF3WXkweU9DQXdJQzAxTUNBdE1qSWdMVFV3SUMwMU1IWXRNVEF3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQjJNVEF3WXpBZ01qZ2dMVEl5SURVd0lDMDFNQ0ExTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1XRWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01XRTdJaUFLWkQwaVRUa2dOekF3YURZNE1tTTJJREFnT1NBdE5DQTVJQzB4TUhZdE1Ua3dhREV3TUhZdE1qQXdhQzB4TURCMkxURTVNV013SUMwMklDMHpJQzA1SUMwNUlDMDVhQzAyT0RKakxUWWdNQ0F0T1NBeklDMDVJRGwyTlRneVl6QWdOaUF6SURrZ09TQTVlazB4TURBZ05qQXdkaTAwTURCb05UQXdkalF3TUdndE5UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l4WWlJZ2RXNXBZMjlrWlQwaUppTjRaVEF4WWpzaUlBcGtQU0pOT1NBM01EQm9Oamd5WXpZZ01DQTVJQzAwSURrZ0xURXdkaTB4T1RCb01UQXdkaTB5TURCb0xURXdNSFl0TVRreFl6QWdMVFlnTFRNZ0xUa2dMVGtnTFRsb0xUWTRNbU10TmlBd0lDMDVJRE1nTFRrZ09YWTFPREpqTUNBMklETWdPU0E1SURsNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqRmpJaUIxYm1samIyUmxQU0ltSTNobE1ERmpPeUlnQ21ROUlrMDVNaUEyTlRCak1DQXlNeUF4T1NBMU1DQTBOU0ExTUdnemFEVm9OV2cxTURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUdndE5UQjJMVEUwTVdNNUlDMHhOeUF4TWpBZ0xUSXpNU0F4TmpZZ0xUTXdPV014TmlBdE1qWWdNelFnTFRZeElETTBJQzB4TURaak1DQXRNemtnTFRFMUlDMDNOeUF0TkRFZ0xURXdNMmd0TTJNdE1qWWdMVEkxSUMwMk1pQXROREVnTFRFd01DQXROREZvTFRVeE1tTXRNemtnTUNBdE56Y2dNVFVnTFRFd015QTBNWE10TkRFZ05qUWdMVFF4SURFd00yTXdJRFEySURFNElEZ3dJRE0wSURFd05ncGpORFlnTnpnZ01UVTNJREk1TWlBeE5qWWdNekE1ZGpFME1XZ3ROVEJqTFRJZ01DQXROaUF0TVNBdE9DQXRNV010TWpnZ01DQXROVEFnTWpNZ0xUVXdJRFV4ZWswMU1EQWdOakF3YUMweU1EQjJMVEUyTW13dE5pQXRNVEJ6TFRZeklDMHhNak1nTFRFeE9TQXRNakk0YURRMU1HTXROVFlnTVRBMUlDMHhNVGtnTWpJNElDMHhNVGtnTWpJNGJDMDJJREV3ZGpFMk1ub2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNV1FpSUhWdWFXTnZaR1U5SWlZamVHVXdNV1E3SWlBS1pEMGlUVFF3TUNBNE1EQmpNVEV3SURBZ01qQXdJQzA1TUNBeU1EQWdMVEl3TUdNd0lDMHhNRFFnTlRJZ0xURTVPQ0F4TXpRZ0xUSTJObU0wTVNBdE16UWdOallnTFRneUlEWTJJQzB4TXpSb0xUZ3dNR013SURVeUlESTFJREV3TUNBMk5pQXhNelJqT0RJZ05qZ2dNVE0wSURFMk1pQXhNelFnTWpZMll6QWdNVEV3SURrd0lESXdNQ0F5TURBZ01qQXdlazB6TURBZ01UQXdhREl3TUdNd0lDMDFOU0F0TkRVZ0xURXdNQ0F0TVRBd0lDMHhNREJ6TFRFd01DQTBOU0F0TVRBd0lERXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTVdVaUlIVnVhV052WkdVOUlpWWplR1V3TVdVN0lpQm9iM0pwZWkxaFpIWXRlRDBpTmpBd0lpQUtaRDBpVFRFMU1DQTRNREJvTlRCc016VXdJQzB5TlRCc0xUSXlOU0F0TVRRM2JESXlOU0F0TVRVemJDMHpOVEFnTFRJMU1HZ3ROVEIyTWpVd2JDMDNOU0F0TnpWc0xUYzFJRGMxYkRFMU1DQXhOVEJzTFRFMU1DQXhOVEJzTnpVZ056VnNOelVnTFRjMWRqSTFNSHBOTWpVd0lEWTFNSFl0TWpBd2JERTFNQ0F4TURCNlRUSTFNQ0F6TlRCMkxUSXdNR3d4TlRBZ01UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l4WmlJZ2RXNXBZMjlrWlQwaUppTjRaVEF4WmpzaUlBcGtQU0pOTUNBNE1EQm9OVEF3WXpFeE1DQXdJREl3TUNBdE9UQWdNakF3SUMweU1EQmpNQ0F0TkRjZ0xURTNJQzA1TVNBdE5EUWdMVEV5TldNNE5TQXROREFnTVRRMElDMHhNalVnTVRRMElDMHlNalZqTUNBdE1UTTRJQzB4TVRJZ0xUSTFNQ0F0TWpVd0lDMHlOVEJvTFRVMU1IWXhNREJqTlRVZ01DQXhNREFnTkRVZ01UQXdJREV3TUhZME1EQmpNQ0ExTlNBdE5EVWdNVEF3SUMweE1EQWdNVEF3ZGpFd01IcE5NekF3SURjd01IWXRNakF3YURFd01HTTFOU0F3SURFd01DQTBOU0F4TURBZ01UQXdjeTAwTlNBeE1EQWdMVEV3TUNBeE1EQm9MVEV3TUhwTk16QXdJRFF3TUhZdE16QXdhREUxTUFwak9ETWdNQ0F4TlRBZ05qY2dNVFV3SURFMU1ITXROamNnTVRVd0lDMHhOVEFnTVRVd2FDMHhOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpJd0lpQjFibWxqYjJSbFBTSW1JM2hsTURJd095SWdhRzl5YVhvdFlXUjJMWGc5SWpZd01DSWdDbVE5SWswek1EQWdPREF3ZGkwek1EQm9NakF3YkMwek1EQWdMVFV3TUhZek1EQm9MVEl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1qRWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01qRTdJaUFLWkQwaVRURXdNQ0E0TURCb016QXdkaTB6TURCc01UQXdJREV3TUd3eE1EQWdMVEV3TUhZek1EQm9OVEJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3ZGkwMU5UQm9MVFUxTUdNdE1qZ2dNQ0F0TlRBZ0xUSXlJQzAxTUNBdE5UQnpNaklnTFRVd0lEVXdJQzAxTUdnMU5UQjJMVEV3TUdndE5UVXdZeTA0TXlBd0lDMHhOVEFnTmpjZ0xURTFNQ0F4TlRCMk5UVXdiRE1nTVRsak9DQXpPU0F6T1NBM01DQTNPQ0EzT0hvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1qSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01qSTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU5EQXdJaUFLWkQwaVRUQWdPREF3YURRd01IWXRPREF3YkMweU1EQWdNakF3YkMweU1EQWdMVEl3TUhZNE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakl6SWlCMWJtbGpiMlJsUFNJbUkzaGxNREl6T3lJZ0NtUTlJazB3SURnd01HZzRNREIyTFRFd01HZ3RPREF3ZGpFd01IcE5NQ0EyTURCb016QXdkaTB4TUROb01qQXpkakV3TTJneU9UZDJMVFU1TVdNd0lDMDJJQzB6SUMwNUlDMDVJQzA1YUMwM09ESmpMVFlnTUNBdE9TQXpJQzA1SURsMk5Ua3hlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l5TkNJZ2RXNXBZMjlrWlQwaUppTjRaVEF5TkRzaUlBcGtQU0pOTXpBd0lEZ3dNR2d5TURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdkaTB4TURCb01Ua3hZellnTUNBNUlDMHpJRGtnTFRsMkxUSTBNV013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xUY3dNR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZGpJME1XTXdJRFlnTXlBNUlEa2dPV2d4T1RGMk1UQXdZekFnTlRVZ05EVWdNVEF3SURFd01DQXhNREI2VFRNd01DQTNNREIyTFRFd01HZ3lNREIyTVRBd2FDMHlNREI2VFRBZ01qQTVZekUySUMwMklETXlJQzA1SURVd0lDMDVhRGN3TUdNeE9DQXdJRE0wSURNZ05UQWdPWFl0TWpBd1l6QWdMVFlnTFRNZ0xUa2dMVGtnTFRsb0xUYzRNZ3BqTFRZZ01DQXRPU0F6SUMwNUlEbDJNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeU5TSWdkVzVwWTI5a1pUMGlKaU40WlRBeU5Uc2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16QXdJRGd3TUdNMU9DQXdJREV4TUNBdE1UWWdNVFEzSUMwMU0zTTFNeUF0T0RrZ05UTWdMVEUwTjJndE1UQXdZekFnTXprZ0xURXhJRFl4SUMweU5TQTNOWE10TXpZZ01qVWdMVGMxSURJMVl5MHpOU0F3SUMwMU5TQXRNVEFnTFRjeUlDMHpNWE10TWpnZ0xUVTFJQzB5T0NBdE9UUmpNQ0F0TlRFZ01qQWdMVEV3TnlBeU9DQXRNVGMxYURFM01uWXRNVEF3YUMweE56aGpMVEUwSUMwMk1DQXRORGtnTFRFeU55QXRNVEV6SUMweU1EQm9ORGt4ZGkweE1EQm9MVFl3TUhZeE1qSnNNVFlnTVRKak5qa2dOamtnT1RVZ01USXhJREV3TmlBeE5qWm9MVEV5TW5ZeE1EQm9NVEkxQ21NdE9DQTFNQ0F0TWpVZ01UQTJJQzB5TlNBeE56VmpNQ0ExT0NBeE5pQXhNVFFnTlRBZ01UVTJZek0wSURReklEZzRJRFk1SURFMU1DQTJPWG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTWpZaUlIVnVhV052WkdVOUlpWWplR1V3TWpZN0lpQUtaRDBpVFRNMElEY3dNR2cwYUROb05HZzFhRGN3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCMkxUY3dNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xUY3dNR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZGpjd01IWXlZekFnTWpBZ01UVWdORElnTXpRZ05EaDZUVEUxTUNBMk1EQmpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3Y3pJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEJ6TFRJeUlEVXdJQzAxTUNBMU1IcE5NelV3SURZd01HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJ6TWpJZ0xUVXdJRFV3SUMwMU1HZ3pNREJqTWpnZ01DQTFNQ0F5TWlBMU1DQTFNQXB6TFRJeUlEVXdJQzAxTUNBMU1HZ3RNekF3ZWsweE1EQWdOREF3ZGkwME1EQm9OakF3ZGpRd01HZ3ROakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeU55SWdkVzVwWTI5a1pUMGlKaU40WlRBeU56c2lJQXBrUFNKTk56UTBJRGM1TjJ3MklDMHpiRFEwSUMwME5HTTBJQzAwSURNZ0xUZ2dNQ0F0TVRKc0xUSTJOaUF0TXpjMWJDMHhOU0F0TVROc0xUSTFJQzB4TW1NdE1qTWdOeklnTFRjNElERXlOeUF0TVRVd0lERTFNR3d4TWlBeU5Xd3hNeUF4Tld3ek56VWdNalkyZWsweU5qWWdOREF3WXpjMElEQWdNVE0wSUMwMk1DQXhNelFnTFRFek5HTXdJQzB4TkRjZ0xURXhPU0F0TWpZMklDMHlOallnTFRJMk5tTXRORGdnTUNBdE9UVWdNVElnTFRFek5DQXpOR000TUNBME5pQXhNelFnTVRNeklERXpOQ0F5TXpKak1DQTNOQ0ExT0NBeE16UWdNVE15SURFek5Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNamdpSUhWdWFXTnZaR1U5SWlZamVHVXdNamc3SWlBS1pEMGlUVGtnTkRVeFl6QWdNak1nTVRrZ05UQWdORFlnTlRCak9DQXdJREU1SUMweklESTJJQzAzYkRFek1TQXROalpzTWprZ01qSmpMVGM1SURneElDMHhJREkxTUNBeE1UZ2dNalV3Y3pFNU55QXRNVFkzSURFeE9TQXRNalV3YkRJNElDMHlNbXd4TXpFZ05qWmpOaUEwSURFeUlEY2dNakVnTjJNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCak1DQXRNVGNnTFRFeUlDMHpOeUF0TWpjZ0xUUTFiQzB4TVRVZ0xUVTJZemtnTFRFMklERTVJQzB6TXlBeU5TQXROVEJvTmpoak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUdndE5UQUtZekFnTFRJeklDMHlJQzAwTlNBdE5pQXROalpzTnpnZ0xUUXdZekl4SUMwMUlETTNJQzB5T0NBek55QXRORGxqTUNBdE1qZ2dMVEl5SUMwMU1DQXROVEFnTFRVd1l5MHhNQ0F3SUMweU15QTFJQzB6TVNBeE1Xd3ROalVnTXpWakxUSTBJQzAwTmlBdE5qSWdMVGcySUMweE1ETWdMVEV4TUdNdE16VWdNVGtnTFRZd0lEUTFJQzAyTUNBM01uWXhNelYyTkhZMWRqWjJOWFkxZGpnM1l6QWdNamdnTFRJeUlEVXdJQzAxTUNBMU1HTXRNalFnTUNBdE5EVWdMVEUzSUMwMU1DQXROREJqTVNBdE15QXhJQzA0SURFZ0xURXhjekFnTFRnZ0xURWdMVEV4ZGkwNE1uWXROSFl0TlhZdE1UUTBDbU13SUMweU9DQXRNalFnTFRVeklDMDFPU0F0TnpKakxUUXhJREkxSUMwM09TQTJOQ0F0TVRBeklERXhNR3d0TmpZZ0xUTTFZeTA0SUMwMklDMHlNU0F0TVRFZ0xUTXhJQzB4TVdNdE1qZ2dNQ0F0TlRBZ01qSWdMVFV3SURVd1l6QWdNakVnTVRZZ05EUWdNemNnTkRsc056Z2dOREJqTFRRZ01qRWdMVFlnTkRNZ0xUWWdOalpvTFRVd2FDMDFZeTB5T0NBd0lDMDFNQ0F5TWlBdE5UQWdOVEJqTUNBeU5pQXlNaUExTUNBMU1DQTFNR2cxYURZNVl6WWdNVGNnTVRZZ016UWdNalVnTlRCc0xURXhOaUExTm1NdE1UWWdOeUF0TWpnZ01qY2dMVEk0SURRMWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXlPU0lnZFc1cFkyOWtaVDBpSmlONFpUQXlPVHNpSUFwa1BTSk5OakF3SURjd01HZzVNV00ySURBZ09TQXRNeUE1SUMwNWRpMDFPREpqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0T1RGMk5qQXdlazB5TVRBZ05UQXpiREk1TUNBeE5EZDJMVFV3TUd3dE1qVXdJREV5TlhZdE0yTXRNVFVnTUNBdE1qVWdMVGdnTFRJNElDMHlNbXczTlNBdE1UYzRZekV4SUMweU5TQXdJQzAxT0NBdE1qVWdMVFk1Y3kwMU9DQXdJQzAyT1NBeU5Xd3RNVEF6SURJM01tZ3RPVEZqTFRZZ01DQXRPU0F6SUMwNUlEbDJNVGd5WXpBZ05pQXpJRGtnT1NBNWFERTRNbm9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTW1FaUlIVnVhV052WkdVOUlpWWplR1V3TW1FN0lpQUtaRDBpVFRrZ09EQXdhRFk0TW1NMklEQWdPU0F0TXlBNUlDMDVkaTAzT0RKak1DQXROaUF0TXlBdE9TQXRPU0F0T1dndE5qZ3lZeTAySURBZ0xUa2dNeUF0T1NBNWRqYzRNbU13SURZZ015QTVJRGtnT1hwTk1UQXdJRGN3TUhZdE1qQXdhRFV3TUhZeU1EQm9MVFV3TUhwTk1UQXdJRFF3TUhZdE1UQXdhREV3TUhZeE1EQm9MVEV3TUhwTk16QXdJRFF3TUhZdE1UQXdhREV3TUhZeE1EQm9MVEV3TUhwTk5UQXdJRFF3TUhZdE16QXdhREV3TUhZek1EQm9MVEV3TUhwTk1UQXdJREl3TUhZdE1UQXdhREV3TUhZeE1EQm9MVEV3TUhwTk16QXdJREl3TUhZdE1UQXdhREV3TUhZeE1EQm9MVEV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1tSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01tSTdJaUFLWkQwaVRUQWdPREF3YURjd01IWXRNakF3YUMwM01EQjJNakF3ZWswd0lEVXdNR2czTURCMkxUUTVNV013SUMwMklDMHpJQzA1SUMwNUlDMDVhQzAyT0RKakxUWWdNQ0F0T1NBeklDMDVJRGwyTkRreGVrMHhNREFnTkRBd2RpMHhNREJvTVRBd2RqRXdNR2d0TVRBd2VrMHpNREFnTkRBd2RpMHhNREJvTVRBd2RqRXdNR2d0TVRBd2VrMDFNREFnTkRBd2RpMHhNREJvTVRBd2RqRXdNR2d0TVRBd2VrMHhNREFnTWpBd2RpMHhNREJvTVRBd2RqRXdNR2d0TVRBd2VrMHpNREFnTWpBd2RpMHhNREJvTVRBd2RqRXdNR2d0TVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXlZeUlnZFc1cFkyOWtaVDBpSmlONFpUQXlZenNpSUFwa1BTSk5OREE1SURnd01HZ3hPREpqTmlBd0lERXdJQzAwSURFeUlDMDViRGswSUMweE9ESmpNaUF0TlNBMklDMDVJREV5SUMwNWFEZ3lZellnTUNBNUlDMHpJRGtnTFRsMkxUVTRNbU13SUMwMklDMHpJQzA1SUMwNUlDMDVhQzAzT0RKakxUWWdNQ0F0T1NBeklDMDVJRGwyTkRReFl6QWdPRE1nTmpjZ01UVXdJREUxTUNBeE5UQm9NVFF4WXpZZ01DQXhNQ0EwSURFeUlEbHNPVFFnTVRneVl6SWdOU0EySURrZ01USWdPWHBOTVRVd0lEVXdNR010TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCek1qSWdMVFV3SURVd0lDMDFNSE0xTUNBeU1pQTFNQ0ExTUhNdE1qSWdOVEFnTFRVd0lEVXdlZ3BOTlRBd0lEVXdNR010TVRFd0lEQWdMVEl3TUNBdE9UQWdMVEl3TUNBdE1qQXdjemt3SUMweU1EQWdNakF3SUMweU1EQnpNakF3SURrd0lESXdNQ0F5TURCekxUa3dJREl3TUNBdE1qQXdJREl3TUhwTk5UQXdJRFF3TUdNMU5TQXdJREV3TUNBdE5EVWdNVEF3SUMweE1EQnpMVFExSUMweE1EQWdMVEV3TUNBdE1UQXdjeTB4TURBZ05EVWdMVEV3TUNBeE1EQnpORFVnTVRBd0lERXdNQ0F4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqSmtJaUIxYm1samIyUmxQU0ltSTNobE1ESmtPeUlnQ21ROUlrMHdJRFl3TUdnNE1EQnNMVFF3TUNBdE5EQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l5WlNJZ2RXNXBZMjlrWlQwaUppTjRaVEF5WlRzaUlHaHZjbWw2TFdGa2RpMTRQU0kwTURBaUlBcGtQU0pOTkRBd0lEZ3dNSFl0T0RBd2JDMDBNREFnTkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXlaaUlnZFc1cFkyOWtaVDBpSmlONFpUQXlaanNpSUdodmNtbDZMV0ZrZGkxNFBTSTBNREFpSUFwa1BTSk5NQ0E0TURCc05EQXdJQzAwTURCc0xUUXdNQ0F0TkRBd2RqZ3dNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTXpBaUlIVnVhV052WkdVOUlpWWplR1V3TXpBN0lpQUtaRDBpVFRRd01DQTJNREJzTkRBd0lDMDBNREJvTFRnd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNekVpSUhWdWFXTnZaR1U5SWlZamVHVXdNekU3SWlBS1pEMGlUVEFnTlRVd1l6QWdNak1nTWpBZ05UQWdORFlnTlRCb00yZzFhRFJvTWpBd1l6RTNJREFnTXpjZ0xURXpJRFEwSUMweU9Hd3pPQ0F0TnpKb05EUTBZekUwSURBZ01Ua2dMVEV5SURFMUlDMHlOV3d0T0RFZ0xUSTFNR010TkNBdE1UTWdMVEl4SUMweU5TQXRNelVnTFRJMWFDMHpOVEJqTFRFMElEQWdMVE13SURFeUlDMHpOQ0F5TldNdE1qY2dPRE1nTFRVMElERTJOeUF0T0RFZ01qVXdiQzB4TUNBeU5XZ3RNVFV3WXkweUlEQWdMVFVnTFRFZ0xUY2dMVEZqTFRJNElEQWdMVFV4SURJeklDMDFNU0ExTVhwTk16VTRJREV3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRBS2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdjekl5SURVd0lEVXdJRFV3ZWswMk5UZ2dNVEF3WXpJNElEQWdOVEFnTFRJeUlEVXdJQzAxTUhNdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1ITXlNaUExTUNBMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTXpJaUlIVnVhV052WkdVOUlpWWplR1V3TXpJN0lpQUtaRDBpVFRBZ056QXdhRFV3TUhZdE1UQXdhQzB6TURCMkxUTXdNR2d0TVRBd2JDMHhNREFnTFRFd01IWTFNREI2VFRNd01DQTFNREJvTlRBd2RpMDFNREJzTFRFd01DQXhNREJvTFRRd01IWTBNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpNeklpQjFibWxqYjJSbFBTSW1JM2hsTURNek95SWdDbVE5SWswMk5ERWdOekF3YkRFME15QXRNVFF4YkMwME9UTWdMVFE1TTJNdE56RWdOellnTFRFME5pQXhORGdnTFRJeE9TQXlNakpzTFRjeUlEY3hiREUwTVNBeE5ERmpOVEFnTFRVeElERXdNU0F0TVRBeElERTFNeUF0TVRVd1l6RXhOaUF4TVRjZ01qTTBJREl6TVNBek5EY2dNelV3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJek5DSWdkVzVwWTI5a1pUMGlKaU40WlRBek5Ec2lJQXBrUFNKTk1UVXdJRFl3TUd3eU5UQWdMVEkxTUd3eU5UQWdNalV3YkRFMU1DQXRNVFV3YkMwME1EQWdMVFF3TUd3dE5EQXdJRFF3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU16VWlJSFZ1YVdOdlpHVTlJaVlqZUdVd016VTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU5qQXdJaUFLWkQwaVRUUXdNQ0E0TURCc01UVXdJQzB4TlRCc0xUSTFNQ0F0TWpVd2JESTFNQ0F0TWpVd2JDMHhOVEFnTFRFMU1Hd3ROREF3SURRd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNellpSUhWdWFXTnZaR1U5SWlZamVHVXdNelk3SWlCb2IzSnBlaTFoWkhZdGVEMGlOakF3SWlBS1pEMGlUVEUxTUNBNE1EQnNOREF3SUMwME1EQnNMVFF3TUNBdE5EQXdiQzB4TlRBZ01UVXdiREkxTUNBeU5UQnNMVEkxTUNBeU5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak0zSWlCMWJtbGpiMlJsUFNJbUkzaGxNRE0zT3lJZ0NtUTlJazAwTURBZ05qQXdiRFF3TUNBdE5EQXdiQzB4TlRBZ0xURTFNR3d0TWpVd0lESTFNR3d0TWpVd0lDMHlOVEJzTFRFMU1DQXhOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpNNElpQjFibWxqYjJSbFBTSW1JM2hsTURNNE95SWdDbVE5SWswME1EQWdPREF3WXpJeU1TQXdJRFF3TUNBdE1UYzVJRFF3TUNBdE5EQXdjeTB4TnprZ0xUUXdNQ0F0TkRBd0lDMDBNREJ6TFRRd01DQXhOemtnTFRRd01DQTBNREJ6TVRjNUlEUXdNQ0EwTURBZ05EQXdlazAyTURBZ05qSXliQzB5TlRBZ0xUSTFNR3d0TVRBd0lERXdNR3d0TnpJZ0xUY3liREUzTWlBdE1UY3liRE15TWlBek1qSjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak01SWlCMWJtbGpiMlJsUFNJbUkzaGxNRE01T3lJZ0NtUTlJazAwTURBZ09EQXdZekl5TVNBd0lEUXdNQ0F0TVRjNUlEUXdNQ0F0TkRBd2N5MHhOemtnTFRRd01DQXROREF3SUMwME1EQnpMVFF3TUNBeE56a2dMVFF3TUNBME1EQnpNVGM1SURRd01DQTBNREFnTkRBd2VrMHlOVEFnTmpJeWJDMDNNaUF0TnpKc01UVXdJQzB4TlRCc0xURTFNQ0F0TVRVd2JEY3lJQzAzTW13eE5UQWdNVFV3YkRFMU1DQXRNVFV3YkRjeUlEY3liQzB4TlRBZ01UVXdiREUxTUNBeE5UQnNMVGN5SURjeWJDMHhOVEFnTFRFMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNMkVpSUhWdWFXTnZaR1U5SWlZamVHVXdNMkU3SWlBS1pEMGlUVE0xTUNBNE1EQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTAxTUdnM05XTXhOQ0F3SURJMUlDMHhNU0F5TlNBdE1qVjJMVGMxYUMwek1EQjJOelZqTUNBeE5DQXhNU0F5TlNBeU5TQXlOV2czTlhZMU1HTXdJREk0SURJeUlEVXdJRFV3SURVd2VrMHlOU0EzTURCb056VjJMVEl3TUdnMU1EQjJNakF3YURjMVl6RTBJREFnTWpVZ0xURXhJREkxSUMweU5YWXROalV3WXpBZ0xURTBJQzB4TVNBdE1qVWdMVEkxSUMweU5XZ3ROalV3WXkweE5DQXdJQzB5TlNBeE1TQXRNalVnTWpWMk5qVXdZekFnTVRRZ01URWdNalVnTWpVZ01qVjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak5pSWlCMWJtbGpiMlJsUFNJbUkzaGxNRE5pT3lJZ0NtUTlJazAwTURBZ09EQXdZekl5TUNBd0lEUXdNQ0F0TVRnd0lEUXdNQ0F0TkRBd2N5MHhPREFnTFRRd01DQXROREF3SUMwME1EQnpMVFF3TUNBeE9EQWdMVFF3TUNBME1EQnpNVGd3SURRd01DQTBNREFnTkRBd2VrMDBNREFnTnpBd1l5MHhOallnTUNBdE16QXdJQzB4TXpRZ0xUTXdNQ0F0TXpBd2N6RXpOQ0F0TXpBd0lETXdNQ0F0TXpBd2N6TXdNQ0F4TXpRZ016QXdJRE13TUhNdE1UTTBJRE13TUNBdE16QXdJRE13TUhwTk16VXdJRFl3TUdneE1EQjJMVEU0TVdNeU15QXRNalFnTkRjZ0xUUTNJRGN5SUMwMk9Xd3ROeklnTFRjeVl5MHlOeUF6TUNBdE5UVWdOVGtnTFRnMElEZzRiQzB4TmlBeE1ncDJNakl5ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJell5SWdkVzVwWTI5a1pUMGlKaU40WlRBell6c2lJQXBrUFNKTk5EVXdJRGd3TUdNeE16Z2dNQ0F5TlRBZ0xURXhNaUF5TlRBZ0xUSTFNSFl0TlRCak5UZ2dMVEl4SURFd01DQXRPRFVnTVRBd0lDMHhOVEJqTUNBdE1UZ2dMVE1nTFRNMElDMDVJQzAxTUdndE1Ua3hkalV3WXpBZ09ETWdMVFkzSURFMU1DQXRNVFV3SURFMU1ITXRNVFV3SUMwMk55QXRNVFV3SUMweE5UQjJMVFV3YUMweU56SmpMVEUzSURNd0lDMHlPQ0EyTXlBdE1qZ2dNVEF3WXpBZ01URXdJRGt3SURJd01DQXlNREFnTWpBd1l6SXpJREV4TkNBeE1qa2dNakF3SURJMU1DQXlNREI2VFRRek5DQTBNREJvTTJnMFl6TWdNQ0EySURFZ09TQXhZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSFl0TVFwMkxURTFNR2d4TlRCc0xUSXdNQ0F0TWpBd2JDMHlNREFnTWpBd2FERTFNSFl4TlRCMk1tTXdJREl3SURFMUlEUXlJRE0wSURRNGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXpaQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXpaRHNpSUFwa1BTSk5ORFV3SURnd01HTXhNemdnTUNBeU5UQWdMVEV4TWlBeU5UQWdMVEkxTUhZdE5UQmpOVGdnTFRJeElERXdNQ0F0T0RVZ01UQXdJQzB4TlRCak1DQXRNVGdnTFRNZ0xUTTBJQzA1SUMwMU1HZ3RNVFF4YkMweU1EQWdNakF3YkMweU1EQWdMVEl3TUdndE1qSXlZeTB4TnlBek1DQXRNamdnTmpNZ0xUSTRJREV3TUdNd0lERXhNQ0E1TUNBeU1EQWdNakF3SURJd01HTXlNeUF4TVRRZ01USTVJREl3TUNBeU5UQWdNakF3ZWswME5UQWdNelV3YkRJMU1DQXRNalV3YUMweU1EQjJMVFV3WXpBZ0xUSTRJQzB5TWlBdE5UQWdMVFV3SUMwMU1ITXROVEFnTWpJZ0xUVXdJRFV3ZGpVd2FDMHlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpObElpQjFibWxqYjJSbFBTSW1JM2hsTURObE95SWdDbVE5SWswME5UQWdOekF3WXpFek9DQXdJREkxTUNBdE1URXlJREkxTUNBdE1qVXdkaTAxTUdNMU9DQXRNakVnTVRBd0lDMDROU0F4TURBZ0xURTFNR013SUMwNE15QXROamNnTFRFMU1DQXRNVFV3SUMweE5UQm9MVFExTUdNdE1URXdJREFnTFRJd01DQTVNQ0F0TWpBd0lESXdNSE01TUNBeU1EQWdNakF3SURJd01HTXlNeUF4TVRRZ01USTVJREl3TUNBeU5UQWdNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJelppSWdkVzVwWTI5a1pUMGlKaU40WlRBelpqc2lJQXBrUFNKTk1qVXdJRGd3TUdNNE1pQXdJREUxTkNBdE5EQWdNakF3SUMweE1EQmpMVEUwTXlBd0lDMHlOekFnTFRnMUlDMHpNalVnTFRJd09XTXRNellnTFRFd0lDMDNNQ0F0TWpVZ0xURXdNQ0F0TkRkakxURTJJRE16SUMweU5TQTJOeUF0TWpVZ01UQTJZekFnTVRNNElERXhNaUF5TlRBZ01qVXdJREkxTUhwTk5EVXdJRFl3TUdNeE16Z2dNQ0F5TlRBZ0xURXhNaUF5TlRBZ0xUSTFNSFl0TlRCak5UZ2dMVEl4SURFd01DQXRPRFVnTVRBd0lDMHhOVEJqTUNBdE9ETWdMVFkzSUMweE5UQWdMVEUxTUNBdE1UVXdhQzAwTlRCakxURXhNQ0F3SUMweU1EQWdPVEFnTFRJd01DQXlNREFLY3prd0lESXdNQ0F5TURBZ01qQXdZekl6SURFeE5DQXhNamtnTWpBd0lESTFNQ0F5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqUXdJaUIxYm1samIyUmxQU0ltSTNobE1EUXdPeUlnQ21ROUlrMDFNREFnTnpBd2FERXdNR3d0TXpBd0lDMDJNREJvTFRFd01IcE5NVEF3SURZd01HZ3hNREJzTFRFd01DQXRNakF3YkRFd01DQXRNakF3YUMweE1EQnNMVEV3TUNBeU1EQjZUVFl3TUNBMk1EQm9NVEF3YkRFd01DQXRNakF3YkMweE1EQWdMVEl3TUdndE1UQXdiREV3TUNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalF4SWlCMWJtbGpiMlJsUFNJbUkzaGxNRFF4T3lJZ0NtUTlJazB6TlRBZ09EQXdhREV3TUd3MU1DQXRNVEU1YkRJNElDMHhNbXd4TVRrZ05UQnNOeklnTFRjeWJDMDFNQ0F0TVRFNWJERXlJQzB5T0d3eE1Ua2dMVFV3ZGkweE1EQnNMVEV4T1NBdE5UQnNMVEV5SUMweU9HdzFNQ0F0TVRFNWJDMDNNaUF0TnpKc0xURXhPU0ExTUd3dE1qZ2dMVEV5YkMwMU1DQXRNVEU1YUMweE1EQnNMVFV3SURFeE9Xd3RNamdnTVRKc0xURXhPU0F0TlRCc0xUY3lJRGN5YkRVd0lERXhPV3d0TVRJZ01qaHNMVEV4T1NBMU1IWXhNREJzTVRFNUlEVXdiREV5SURJNGJDMDFNQ0F4TVRsc056SWdOekpzTVRFNUlDMDFNR3d5T0NBeE1ucE5OREF3SURVMU1BcGpMVGd6SURBZ0xURTFNQ0F0TmpjZ0xURTFNQ0F0TVRVd2N6WTNJQzB4TlRBZ01UVXdJQzB4TlRCek1UVXdJRFkzSURFMU1DQXhOVEJ6TFRZM0lERTFNQ0F0TVRVd0lERTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTkRJaUlIVnVhV052WkdVOUlpWWplR1V3TkRJN0lpQUtaRDBpVFRBZ09EQXdhRGd3TUhZdE1qQXdhQzA0TURCMk1qQXdlazB5TURBZ05UQXdhRFF3TUd3dE1qQXdJQzB5TURCNlRUQWdNVEF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJME15SWdkVzVwWTI5a1pUMGlKaU40WlRBME16c2lJQXBrUFNKTk1DQTRNREJvTVRBd2RpMDRNREJvTFRFd01IWTRNREI2VFRZd01DQTRNREJvTWpBd2RpMDRNREJvTFRJd01IWTRNREI2VFRVd01DQTJNREIyTFRRd01Hd3RNakF3SURJd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlORFFpSUhWdWFXTnZaR1U5SWlZamVHVXdORFE3SWlBS1pEMGlUVEFnT0RBd2FESXdNSFl0T0RBd2FDMHlNREIyT0RBd2VrMDNNREFnT0RBd2FERXdNSFl0T0RBd2FDMHhNREIyT0RBd2VrMHpNREFnTmpBd2JESXdNQ0F0TWpBd2JDMHlNREFnTFRJd01IWTBNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpRMUlpQjFibWxqYjJSbFBTSW1JM2hsTURRMU95SWdDbVE5SWswd0lEZ3dNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTkRBd0lEVXdNR3d5TURBZ0xUSXdNR2d0TkRBd2VrMHdJREl3TUdnNE1EQjJMVEl3TUdndE9EQXdkakl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5EWWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05EWTdJaUFLWkQwaVRURTFNQ0EzTURCak9ETWdNQ0F4TlRBZ0xUWTNJREUxTUNBdE1UVXdkaTAxTUdneE1EQjJOVEJqTUNBNE15QTJOeUF4TlRBZ01UVXdJREUxTUhNeE5UQWdMVFkzSURFMU1DQXRNVFV3Y3kwMk55QXRNVFV3SUMweE5UQWdMVEUxTUdndE5UQjJMVEV3TUdnMU1HTTRNeUF3SURFMU1DQXROamNnTVRVd0lDMHhOVEJ6TFRZM0lDMHhOVEFnTFRFMU1DQXRNVFV3Y3kweE5UQWdOamNnTFRFMU1DQXhOVEIyTlRCb0xURXdNSFl0TlRCak1DQXRPRE1nTFRZM0lDMHhOVEFnTFRFMU1DQXRNVFV3Y3kweE5UQWdOamNnTFRFMU1DQXhOVEJ6TmpjZ01UVXdJREUxTUNBeE5UQm9OVEIyTVRBd2FDMDFNQXBqTFRneklEQWdMVEUxTUNBMk55QXRNVFV3SURFMU1ITTJOeUF4TlRBZ01UVXdJREUxTUhwTk1UVXdJRFl3TUdNdE1qZ2dNQ0F0TlRBZ0xUSXlJQzAxTUNBdE5UQnpNaklnTFRVd0lEVXdJQzAxTUdnMU1IWTFNR013SURJNElDMHlNaUExTUNBdE5UQWdOVEI2VFRVMU1DQTJNREJqTFRJNElEQWdMVFV3SUMweU1pQXROVEFnTFRVd2RpMDFNR2cxTUdNeU9DQXdJRFV3SURJeUlEVXdJRFV3Y3kweU1pQTFNQ0F0TlRBZ05UQjZUVE13TUNBME1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVEUxTUNBeU1EQmpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3Y3pJeUlDMDFNQ0ExTUNBdE5UQUtjelV3SURJeUlEVXdJRFV3ZGpVd2FDMDFNSHBOTlRBd0lESXdNSFl0TlRCak1DQXRNamdnTWpJZ0xUVXdJRFV3SUMwMU1ITTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2FDMDFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTkRjaUlIVnVhV052WkdVOUlpWWplR1V3TkRjN0lpQUtaRDBpVFRBZ056a3hZekFnTlNBMElEa2dPU0E1YURjNE1tTTJJREFnT1NBdE5DQTVJQzB4TUhZdE56a3diQzB5TURBZ01qQXdhQzAxT1RGakxUWWdNQ0F0T1NBeklDMDVJRGwyTlRneWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTBPQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTBPRHNpSUFwa1BTSk5OREF3SURnd01HTXlNakFnTUNBME1EQWdMVEU0TUNBME1EQWdMVFF3TUhNdE1UZ3dJQzAwTURBZ0xUUXdNQ0F0TkRBd2N5MDBNREFnTVRnd0lDMDBNREFnTkRBd2N6RTRNQ0EwTURBZ05EQXdJRFF3TUhwTk5EQXdJRGN3TUdNdE1UWTJJREFnTFRNd01DQXRNVE0wSUMwek1EQWdMVE13TUhNeE16UWdMVE13TUNBek1EQWdMVE13TUhNek1EQWdNVE0wSURNd01DQXpNREJ6TFRFek5DQXpNREFnTFRNd01DQXpNREI2VFRZd01DQTJNREJzTFRFd01DQXRNekF3YkMwek1EQWdMVEV3TUd3eE1EQWdNekF3ZWswME1EQWdORFV3WXkweU9DQXdJQzAxTUNBdE1qSWdMVFV3SUMwMU1BcHpNaklnTFRVd0lEVXdJQzAxTUhNMU1DQXlNaUExTUNBMU1ITXRNaklnTlRBZ0xUVXdJRFV3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJME9TSWdkVzVwWTI5a1pUMGlKaU40WlRBME9Uc2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qQWdNQ0EwTURBZ0xURTRNQ0EwTURBZ0xUUXdNSE10TVRnd0lDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGd3SUMwME1EQWdOREF3Y3pFNE1DQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNSFl0TmpBd1l6RTJOaUF3SURNd01DQXhNelFnTXpBd0lETXdNSE10TVRNMElETXdNQ0F0TXpBd0lETXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTkdFaUlIVnVhV052WkdVOUlpWWplR1V3TkdFN0lpQUtaRDBpVFRBZ09EQXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB3SURZd01HZzFNREIyTFRFd01HZ3ROVEF3ZGpFd01IcE5NQ0F6TURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUQWdNVEF3YURZd01IWXRNVEF3YUMwMk1EQjJNVEF3ZWswM05UQWdNVEF3WXpJNElEQWdOVEFnTFRJeUlEVXdJQzAxTUhNdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1ITXlNaUExTUNBMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTkdJaUlIVnVhV052WkdVOUlpWWplR1V3TkdJN0lpQUtaRDBpVFRJMUlEY3dNR2czTlRCak1UUWdNQ0F5TlNBdE1URWdNalVnTFRJMWRpMDNOV2d0T0RBd2RqYzFZekFnTVRRZ01URWdNalVnTWpVZ01qVjZUVEFnTlRBd2FEZ3dNSFl0TXpjMVl6QWdMVEUwSUMweE1TQXRNalVnTFRJMUlDMHlOV2d0TnpVd1l5MHhOQ0F3SUMweU5TQXhNU0F0TWpVZ01qVjJNemMxZWsweE1EQWdNekF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWswek1EQWdNekF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMFl5SWdkVzVwWTI5a1pUMGlKaU40WlRBMFl6c2lJQXBrUFNKTk1UQXdJRGd3TUdneE1EQjJMVEV3TUdnME5UQnNNVEF3SURFd01HdzFNQ0F0TlRCc0xURXdNQ0F0TVRBd2RpMDBOVEJvTVRBd2RpMHhNREJvTFRFd01IWXRNVEF3YUMweE1EQjJNVEF3YUMwMU1EQjJOVEF3YUMweE1EQjJNVEF3YURFd01IWXhNREI2VFRJd01DQTJNREIyTFRNMU1Hd3pOVEFnTXpVd2FDMHpOVEI2VFRZd01DQTFOVEJzTFRNMU1DQXRNelV3YURNMU1IWXpOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpSa0lpQjFibWxqYjJSbFBTSW1JM2hsTURSa095SWdDbVE5SWswME1EQWdPREF3WXpJeU1DQXdJRFF3TUNBdE1UZ3dJRFF3TUNBdE5EQXdjeTB4T0RBZ0xUUXdNQ0F0TkRBd0lDMDBNREJ6TFRRd01DQXhPREFnTFRRd01DQTBNREJ6TVRnd0lEUXdNQ0EwTURBZ05EQXdlazAwTURBZ056QXdZeTB4TmpZZ01DQXRNekF3SUMweE16UWdMVE13TUNBdE16QXdjekV6TkNBdE16QXdJRE13TUNBdE16QXdjek13TUNBeE16UWdNekF3SURNd01ITXRNVE0wSURNd01DQXRNekF3SURNd01IcE5OREF3SURZd01HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEJ6TWpJZ05UQWdOVEFnTlRCNkNrMHlNREFnTkRVeVl6QWdNakFnTVRVZ05ESWdNelFnTkRob00yZ3phRGhqTVRJZ01DQXlPQ0F0TnlBek5pQXRNVFpzT1RFZ0xUa3diREkxSURaak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdjeTAwTlNBdE1UQXdJQzB4TURBZ0xURXdNSE10TVRBd0lEUTFJQzB4TURBZ01UQXdiRFlnTWpWc0xUa3dJRGt4WXkwNUlEZ2dMVEUySURJMElDMHhOaUF6Tm5wTk5UVXdJRFV3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCekxUSXlJQzAxTUNBdE5UQWdMVFV3Y3kwMU1DQXlNaUF0TlRBZ05UQnpNaklnTlRBZ05UQWdOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpSbElpQjFibWxqYjJSbFBTSW1JM2hsTURSbE95SWdDbVE5SWswek1EQWdPREF3YURJd01IWXRNekF3YURJd01Hd3RNekF3SUMwek1EQnNMVE13TUNBek1EQm9NakF3ZGpNd01IcE5NQ0F4TURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqUm1JaUIxYm1samIyUmxQU0ltSTNobE1EUm1PeUlnQ21ROUlrMHdJRGd3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk5EQXdJRFl3TUd3ek1EQWdMVE13TUdndE1qQXdkaTB6TURCb0xUSXdNSFl6TURCb0xUSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTlRBaUlIVnVhV052WkdVOUlpWWplR1V3TlRBN0lpQUtaRDBpVFRJd01DQTNNREJvTmpBd2RpMDJNREJvTFRZd01Hd3RNakF3SURNd01IcE5NelV3SURZeU1td3ROeklnTFRjeWJERTFNQ0F0TVRVd2JDMHhOVEFnTFRFMU1HdzNNaUF0TnpKc01UVXdJREUxTUd3eE5UQWdMVEUxTUd3M01pQTNNbXd0TVRVd0lERTFNR3d4TlRBZ01UVXdiQzAzTWlBM01td3RNVFV3SUMweE5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalV4SWlCMWJtbGpiMlJsUFNJbUkzaGxNRFV4T3lJZ0NtUTlJazAwTURBZ056QXdZekl5TUNBd0lEUXdNQ0F0TVRnd0lEUXdNQ0F0TkRBd2FDMHhNREJqTUNBeE5qWWdMVEV6TkNBek1EQWdMVE13TUNBek1EQnpMVE13TUNBdE1UTTBJQzB6TURBZ0xUTXdNR2d0TVRBd1l6QWdNakl3SURFNE1DQTBNREFnTkRBd0lEUXdNSHBOTXpReElEUTVNV3cxT1NBdE9EaHNOVGtnT0Roak9ERWdMVEkxSURFME1TQXRNVEF4SURFME1TQXRNVGt4WXpBZ0xURXhNQ0F0T1RBZ0xUSXdNQ0F0TWpBd0lDMHlNREJ6TFRJd01DQTVNQ0F0TWpBd0lESXdNR013SURrd0lEWXdJREUyTmlBeE5ERWdNVGt4ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMU1pSWdkVzVwWTI5a1pUMGlKaU40WlRBMU1qc2lJQXBrUFNKTk1DQTRNREJvTXpBd2RpMDBNREJvTkRBd2RpMDBNREJvTFRjd01IWTRNREI2VFRRd01DQTRNREJzTXpBd0lDMHpNREJvTFRNd01IWXpNREI2VFRFd01DQTJNREIyTFRFd01HZ3hNREIyTVRBd2FDMHhNREI2VFRFd01DQTBNREIyTFRFd01HZ3hNREIyTVRBd2FDMHhNREI2VFRFd01DQXlNREIyTFRFd01HZzBNREIyTVRBd2FDMDBNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpVeklpQjFibWxqYjJSbFBTSW1JM2hsTURVek95SWdhRzl5YVhvdFlXUjJMWGc5SWpZd01DSWdDbVE5SWsweU1EQWdOekF3YURFd01IWXRNVEF3YURjMVl6TXdJREFnTlRnZ0xUWWdPREVnTFRJeWN6UTBJQzAwTkNBME5DQXROemgyTFRFd01HZ3RNVEF3ZGprMFl5MDBJRE1nTFRFeklEWWdMVEkxSURab0xUSTFNR010TVRRZ01DQXRNalVnTFRFeElDMHlOU0F0TWpWMkxUVXdZekFnTFRFMUlESXdJQzAwTUNBek5DQXRORFJzTWpVM0lDMDJOV00yTmlBdE1UWWdNVEE1SUMwM015QXhNRGtnTFRFME1YWXROVEJqTUNBdE5qZ2dMVFUzSUMweE1qVWdMVEV5TlNBdE1USTFhQzAzTlhZdE1UQXdhQzB4TURCMk1UQXdhQzAzTldNdE16QWdNQ0F0TlRnZ05pQXRPREVnTWpKekxUUTBJRFEwSUMwME5DQTNPQXAyTVRBd2FERXdNSFl0T1RSak5DQXRNeUF4TXlBdE5pQXlOU0F0Tm1neU5UQmpNVFFnTUNBeU5TQXhNU0F5TlNBeU5YWTFNR013SURFMUlDMHlNQ0EwTUNBdE16UWdORFJzTFRJMU55QTJOV010TmpZZ01UWWdMVEV3T1NBM015QXRNVEE1SURFME1YWTFNR013SURZNElEVTNJREV5TlNBeE1qVWdNVEkxYURjMWRqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTlRRaUlIVnVhV052WkdVOUlpWWplR1V3TlRRN0lpQUtaRDBpVFRBZ056QXdhRE13TUhZdE16QXdiQzB6TURBZ0xUTXdNSFkyTURCNlRUVXdNQ0EzTURCb016QXdkaTB6TURCc0xUTXdNQ0F0TXpBd2RqWXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTlRVaUlIVnVhV052WkdVOUlpWWplR1V3TlRVN0lpQUtaRDBpVFRNd01DQTNNREIyTFRZd01HZ3RNekF3ZGpNd01IcE5PREF3SURjd01IWXROakF3YUMwek1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMU5pSWdkVzVwWTI5a1pUMGlKaU40WlRBMU5qc2lJQXBrUFNKTk16QXdJRGN3TUhZdE1UQXdZeTB4TVRFZ01DQXRNakF3SUMwNE9TQXRNakF3SUMweU1EQm9NakF3ZGkwek1EQm9MVE13TUhZek1EQmpNQ0F4TmpVZ01UTTFJRE13TUNBek1EQWdNekF3ZWswNE1EQWdOekF3ZGkweE1EQmpMVEV4TVNBd0lDMHlNREFnTFRnNUlDMHlNREFnTFRJd01HZ3lNREIyTFRNd01HZ3RNekF3ZGpNd01HTXdJREUyTlNBeE16VWdNekF3SURNd01DQXpNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpVM0lpQjFibWxqYjJSbFBTSW1JM2hsTURVM095SWdDbVE5SWswd0lEY3dNR2d6TURCMkxUTXdNR013SUMweE5qVWdMVEV6TlNBdE16QXdJQzB6TURBZ0xUTXdNSFl4TURCak1URXhJREFnTWpBd0lEZzVJREl3TUNBeU1EQm9MVEl3TUhZek1EQjZUVFV3TUNBM01EQm9NekF3ZGkwek1EQmpNQ0F0TVRZMUlDMHhNelVnTFRNd01DQXRNekF3SUMwek1EQjJNVEF3WXpFeE1TQXdJREl3TUNBNE9TQXlNREFnTWpBd2FDMHlNREIyTXpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTFPQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTFPRHNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5NekF3SURnd01Hd3pOQ0F0TXpSak1URWdMVEV4SURJMk5pQXRNamN3SURJMk5pQXRORGc0WXpBZ0xURTJOU0F0TVRNMUlDMHpNREFnTFRNd01DQXRNekF3Y3kwek1EQWdNVE0xSUMwek1EQWdNekF3WXpBZ01qRTRJREkxTlNBME56Y2dNalkySURRNE9IcE5NVFV3SURNeU9HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJqTUNBdE1URXdJRGt3SUMweU1EQWdNakF3SUMweU1EQmpNamdnTUNBMU1DQXlNaUExTUNBMU1ITXRNaklnTlRBZ0xUVXdJRFV3WXkwMU5TQXdJQzB4TURBZ05EVWdMVEV3TUNBeE1EQmpNQ0F5T0NBdE1qSWdOVEFnTFRVd0lEVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxT1NJZ2RXNXBZMjlrWlQwaUppTjRaVEExT1RzaUlBcGtQU0pOTkRBd0lEZ3dNR3cwTURBZ0xUVXdNR2d0T0RBd2VrMHdJREl3TUdnNE1EQjJMVEl3TUdndE9EQXdkakl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5XRWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05XRTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU5qQXdJaUFLWkQwaVRUTXdNQ0E0TURCc016QXdJQzB6TURCb0xUWXdNSHBOTUNBek1EQm9OakF3YkMwek1EQWdMVE13TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5XSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05XSTdJaUFLWkQwaVRUQWdOVEF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWswek1EQWdOVEF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWswMk1EQWdOVEF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMVl5SWdkVzVwWTI5a1pUMGlKaU40WlRBMVl6c2lJQXBrUFNKTk1DQTNNREJvT0RBd2RpMHhNREJzTFRRd01DQXRNakF3YkMwME1EQWdNakF3ZGpFd01IcE5NQ0ExTURCc05EQXdJQzB5TURCc05EQXdJREl3TUhZdE5EQXdhQzA0TURCMk5EQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxWkNJZ2RXNXBZMjlrWlQwaUppTjRaVEExWkRzaUlBcGtQU0pOTkRBd0lEZ3dNR3cwTURBZ0xUSXdNSFl0TmpBd2FDMDRNREIyTmpBd2VrMDBNREFnTmpnNGJDMHpNREFnTFRFMU1IWXRNVGc0YkRNd01DQXRNVFV3YkRNd01DQXhOVEIyTVRnNGVrMHlNREFnTlRBd2FEUXdNSFl0TVRBd2JDMHlNREFnTFRFd01Hd3RNakF3SURFd01IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpWbElpQjFibWxqYjJSbFBTSW1JM2hsTURWbE95SWdDbVE5SWswMk1EQWdOekF3WXpZNUlEQWdNVE0wSUMweE9TQXhPVEVnTFRVd2JDMHhOaUF0TVRBMll5MDBPU0F6TlNBdE1UQTVJRFUySUMweE56VWdOVFpqTFRFek1TQXdJQzB5TkRBZ0xUZzBJQzB5T0RFZ0xUSXdNR2d6TXpGc0xURTJJQzB4TURCb0xUTXpOR013SUMwek5pQTRJQzAyT0NBeE9TQXRNVEF3YURJNU4yd3RNVFlnTFRFd01HZ3RNakl5WXpVMUlDMDJNU0F4TXpNZ0xURXdNQ0F5TWpJZ0xURXdNR00zT0NBd0lERTBOeUF6TUNBeU1EQWdOemgyTFRFeU1tTXROVGtnTFRNMUlDMHhNamNnTFRVMklDMHlNREFnTFRVMll5MHhORGNnTUNBdE1qYzBJRGd5SUMwek5EUWdNakF3YUMweU5UWUtiREU1SURFd01HZ3hPVGRqTFRnZ016SWdMVEUySURZMklDMHhOaUF4TURCb0xUSXdNR3d5TlNBeE1EQm9NVGt4WXpRMUlERTNNaUF4T1RnZ016QXdJRE00TkNBek1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalZtSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFZtT3lJZ0NtUTlJazB3SURjd01HZzNNREIyTFRFd01HZ3ROekF3ZGpFd01IcE5NQ0ExTURCb05UQXdkaTB4TURCb0xUVXdNSFl4TURCNlRUQWdNekF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWswd0lERXdNR2d4TURCMkxURXdNR2d0TVRBd2RqRXdNSHBOTWpBd0lERXdNR2d4TURCMkxURXdNR2d0TVRBd2RqRXdNSHBOTkRBd0lERXdNR2d4TURCMkxURXdNR2d0TVRBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTmpBaUlIVnVhV052WkdVOUlpWWplR1V3TmpBN0lpQUtaRDBpVFRBZ09EQXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB5TURBZ05qQXdhRFF3TUd3dE1qQXdJQzB5TURCNlRUQWdNakF3YURnd01IWXRNakF3YUMwNE1EQjJNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMk1TSWdkVzVwWTI5a1pUMGlKaU40WlRBMk1Uc2lJQXBrUFNKTk1DQTRNREJvTVRBd2RpMDRNREJvTFRFd01IWTRNREI2VFRZd01DQTRNREJvTWpBd2RpMDRNREJvTFRJd01IWTRNREI2VFRJd01DQTJNREJzTWpBd0lDMHlNREJzTFRJd01DQXRNakF3ZGpRd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOaklpSUhWdWFXTnZaR1U5SWlZamVHVXdOakk3SWlBS1pEMGlUVEFnT0RBd2FESXdNSFl0T0RBd2FDMHlNREIyT0RBd2VrMDNNREFnT0RBd2FERXdNSFl0T0RBd2FDMHhNREIyT0RBd2VrMDJNREFnTmpBd2RpMDBNREJzTFRJd01DQXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpZeklpQjFibWxqYjJSbFBTSW1JM2hsTURZek95SWdDbVE5SWswd0lEZ3dNR2c0TURCMkxUSXdNR2d0T0RBd2RqSXdNSHBOTkRBd0lEUXdNR3d5TURBZ0xUSXdNR2d0TkRBd2VrMHdJREV3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5qUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05qUTdJaUFLWkQwaVRUQWdPREF3YURJd01IWXRNVEF3YUMweE1EQjJMVFl3TUdnMk1EQjJNVEF3YURFd01IWXRNakF3YUMwNE1EQjJPREF3ZWswME1EQWdPREF3YURRd01IWXROREF3YkMweE5UQWdNVFV3YkMweU5UQWdMVEkxTUd3dE1UQXdJREV3TUd3eU5UQWdNalV3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMk5TSWdkVzVwWTI5a1pUMGlKaU40WlRBMk5Uc2lJQXBrUFNKTk5EQXpJRGN3TUdNeU5EY2dNQ0F6T1RjZ0xUTXdNQ0F6T1RjZ0xUTXdNSE10TVRVd0lDMHpNREFnTFRNNU55QXRNekF3WXkweU5UTWdNQ0F0TkRBeklETXdNQ0F0TkRBeklETXdNSE14TlRBZ016QXdJRFF3TXlBek1EQjZUVFF3TUNBMk1EQmpMVEV4TUNBd0lDMHlNREFnTFRrd0lDMHlNREFnTFRJd01ITTVNQ0F0TWpBd0lESXdNQ0F0TWpBd2N6SXdNQ0E1TUNBeU1EQWdNakF3Y3kwNU1DQXlNREFnTFRJd01DQXlNREI2VFRRd01DQTFNREJqTVRBZ01DQXhPU0F0TXlBeU9DQXRObU10TVRZZ0xUZ2dMVEk0SUMweU5DQXRNamdnTFRRMFl6QWdMVEk0SURJeUlDMDFNQ0ExTUNBdE5UQUtZekl3SURBZ016WWdNVElnTkRRZ01qaGpNeUF0T1NBMklDMHhPQ0EySUMweU9HTXdJQzAxTlNBdE5EVWdMVEV3TUNBdE1UQXdJQzB4TURCekxURXdNQ0EwTlNBdE1UQXdJREV3TUhNME5TQXhNREFnTVRBd0lERXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTmpZaUlIVnVhV052WkdVOUlpWWplR1V3TmpZN0lpQm9iM0pwZWkxaFpIWXRlRDBpT1RBd0lpQUtaRDBpVFRNek1TQTNNREJvTTJnell6TWdNU0EzSURFZ01UQWdNV014TWlBd0lESTVJQzA0SURNM0lDMHhOMnc1TkNBdE9UTnNOallnTmpWak5UY2dOVGNnTVRVMUlEVTNJREl4TWlBd1l6VTRJQzAxT0NBMU9DQXRNVFUwSURBZ0xUSXhNbXd0TmpVZ0xUWTJiRGt6SUMwNU5HTXhNQ0F0T0NBeE9DQXRNalVnTVRnZ0xUTTRZekFnTFRJNElDMHlNaUF0TlRBZ0xUVXdJQzAxTUdNdE1UTWdNQ0F0TXpJZ09TQXROREFnTWpCc0xUWXlJRFkxYkMwek9ERWdMVE00TVdndE1qWTVkakkzTW13ek56VWdNemd4YkMwMk15QTJNMk10T1NBNElDMHhOaUF5TkNBdE1UWWdNelpqTUNBeU1DQXhOaUEwTWlBek5TQTBPSG9LVFRRME55QTBPREZzTFRNeE15QXRNekUxYkRFeU9DQXRNVE15YkRNeE5pQXpNVFo2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpZM0lpQjFibWxqYjJSbFBTSW1JM2hsTURZM095SWdDbVE5SWswd0lEZ3dNR2d6TURCMkxUUXdNR2cwTURCMkxUUXdNR2d0TnpBd2RqZ3dNSHBOTkRBd0lEZ3dNR3d6TURBZ0xUTXdNR2d0TXpBd2RqTXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTmpnaUlIVnVhV052WkdVOUlpWWplR1V3TmpnN0lpQUtaRDBpVFRJd01DQTRNREJqTUNBd0lESXdNQ0F0TVRBd0lESXdNQ0F0TXpBd2N5MHlPVGdnTFRNd01pQXRNakF3SUMwMU1EQmpNQ0F3SUMweU1EQWdNVEF3SUMweU1EQWdNekF3Y3pNd01DQXpNREFnTWpBd0lEVXdNSHBOTlRBd0lEVXdNR013SURBZ01qQXdJQzB4TURBZ01qQXdJQzB6TURCak1DQXRNVFV3SUMwMk1DQXRNakF3SUMweE1EQWdMVEl3TUdndE16QXdZekFnTWpBd0lETXdNQ0F6TURBZ01qQXdJRFV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5qa2lJSFZ1YVdOdlpHVTlJaVlqZUdVd05qazdJaUFLWkQwaVRUQWdPREF3YURFd01IWXRPREF3YUMweE1EQjJPREF3ZWsweU1EQWdPREF3YURNd01IWXRNVEF3YURNd01Hd3RNakF3SUMweU1ETnNNakF3SUMweE9UZG9MVFF3TUhZeE1EQm9MVEl3TUhZME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalpoSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFpoT3lJZ2FHOXlhWG90WVdSMkxYZzlJalF3TUNJZ0NtUTlJazB4TlRBZ09EQXdhREUxTUd3dE1UQXdJQzB5TURCb01qQXdiQzB4TlRBZ0xUTXdNR2d4TlRCc0xUTXdNQ0F0TXpBd2JDMHhNREFnTXpBd2FERXpOR3cyTmlBeU1EQm9MVEl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5tSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05tSTdJaUFLWkQwaVRUQWdPREF3YURNd01IWXRNVEF3YURVd01IWXRNVEF3YUMwNE1EQjJNakF3ZWswd0lEVXdNR2c0TURCMkxUUTFNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xUY3dNR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZGpRMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlObU1pSUhWdWFXTnZaR1U5SWlZamVHVXdObU03SWlBS1pEMGlUVEUxTUNBNE1EQmpPRE1nTUNBeE5UQWdMVFkzSURFMU1DQXRNVFV3WXpBZ0xUWTJJQzAwTVNBdE1USXhJQzB4TURBZ0xURTBNWFl0TVRFNFl6RTFJRFVnTXpNZ09TQTFNQ0E1YURJd01HTXlPQ0F3SURVd0lESXlJRFV3SURVd2RqVTVZeTAxT1NBeU1DQXRNVEF3SURjMUlDMHhNREFnTVRReFl6QWdPRE1nTmpjZ01UVXdJREUxTUNBeE5UQnpNVFV3SUMwMk55QXhOVEFnTFRFMU1HTXdJQzAyTmlBdE5ERWdMVEV5TVNBdE1UQXdJQzB4TkRGMkxUVTVZekFnTFRneUlDMDJPQ0F0TVRVd0lDMHhOVEFnTFRFMU1HZ3RNakF3WXkweE5DQXdJQzB5TlNBdE55QXRNelFnTFRFMkNtTTFNQ0F0TWpRZ09EUWdMVGMwSURnMElDMHhNelJqTUNBdE9ETWdMVFkzSUMweE5UQWdMVEUxTUNBdE1UVXdjeTB4TlRBZ05qY2dMVEUxTUNBeE5UQmpNQ0EyTmlBME1TQXhNakVnTVRBd0lERTBNWFl5TVRoakxUVTVJREl3SUMweE1EQWdOelVnTFRFd01DQXhOREZqTUNBNE15QTJOeUF4TlRBZ01UVXdJREUxTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5tUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05tUTdJaUFLWkQwaVRUQWdPREF3YURRd01Hd3RNVFV3SUMweE5UQnNNVFV3SUMweE5UQnNMVEV3TUNBdE1UQXdiQzB4TlRBZ01UVXdiQzB4TlRBZ0xURTFNSFkwTURCNlRUVXdNQ0EwTURCc01UVXdJQzB4TlRCc01UVXdJREUxTUhZdE5EQXdhQzAwTURCc01UVXdJREUxTUd3dE1UVXdJREUxTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5tVWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05tVTdJaUFLWkQwaVRURXdNQ0E0TURCc01UVXdJQzB4TlRCc01UVXdJREUxTUhZdE5EQXdhQzAwTURCc01UVXdJREUxTUd3dE1UVXdJREUxTUhwTk5EQXdJRFF3TUdnME1EQnNMVEUxTUNBdE1UVXdiREUxTUNBdE1UVXdiQzB4TURBZ0xURXdNR3d0TVRVd0lERTFNR3d0TVRVd0lDMHhOVEIyTkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTJaaUlnZFc1cFkyOWtaVDBpSmlONFpUQTJaanNpSUFwa1BTSk5OREF3SURnd01HTXlNakVnTUNBME1EQWdMVEUzT1NBME1EQWdMVFF3TUhNdE1UYzVJQzAwTURBZ0xUUXdNQ0F0TkRBd2N5MDBNREFnTVRjNUlDMDBNREFnTkRBd2N6RTNPU0EwTURBZ05EQXdJRFF3TUhwTk5EQXdJRGN3TUdNdE5UWWdNQ0F0TVRBNElDMHhOeUF0TVRVeklDMDBOR3d5TWlBdE1UbGpNek1nTFRFNElERXpJQzAwT0NBdE1UTWdMVFU1WXkwek1DQXRNVE1nTFRjM0lERXdJQzAyTlNBdE5ERmpNVE1nTFRVMUlDMHlOeUF0TXlBdE5EY2dMVEUxWXkwME1pQXRNallnTkRrZ0xURTFNaUF6TVNBdE1UVTJiQzAxT1NBek5HTXRPQ0F3SUMweE15QXROU0F0TVRZZ0xURXdDbU14SUMwek1DQXhNQ0F0TlRjZ01Ua2dMVGcwWXpJNElDMHhNU0EzTnlBdE1pQXhNREFnTFRJMVl6UTNJQzB5T0NBNU55QXRNVEUxSURjMUlDMHhOVGxqTXpRZ0xURXpJRFk0SUMweU1pQXhNRFlnTFRJeVl6RXdNU0F3SURFNU15QTBPQ0F5TkRjZ01USTFZek1nTWpRZ0xUZ2dORFFnTFRVd0lEUTBZeTAyT1NBd0lDMHhOVFlnTVRNZ0xURTFNeUE1TjJNeUlEUTJJREV3TVNBeE1EZ2dOallnTVRRell5MHpNQ0F6TUNBeE1pQXpPU0F4TWlBMk5tTXdJRE0zSUMwMk5TQXpNaUF0TmprZ05UQnpNakFnTXpZZ05ERWdOVFpqTFRNd0lERXdJQzAyTUNBeE9TQXRPVFFnTVRsNlRUWXpNU0ExT1RFS1l5MHpPQ0F0TVRFZ0xUazBJQzB6TlNBdE9EY2dMVFV6WXpZZ0xURTFJRFV5SUMweElEWTFJQzB4TTJNeE1TQXRNVEFnTVRZZ0xUVTVJRFEwSUMwek1Xd3lNaUF5TW5Zell5MHhNU0F5TmlBdE1qWWdOVEFnTFRRMElEY3llaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzTUNJZ2RXNXBZMjlrWlQwaUppTjRaVEEzTURzaUlBcGtQU0pOTnpBeklEZ3dNR3c1TnlBdE1UQXdiQzAwTURBZ0xUUXdNR3d0TVRBd0lERXdNR3d0TWpBd0lDMHlNRE5zTFRFd01DQXhNREJzTXpBd0lETXdNMnd4TURBZ0xURXdNSHBOTUNBeE1EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamN4SWlCMWJtbGpiMlJsUFNJbUkzaGxNRGN4T3lJZ0NtUTlJazB3SURjd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5NakF3SURjd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5OREF3SURjd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5OakF3SURjd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5NQ0ExTURCb01UQXdkaTB4TURCb0xURXdNSFl4TURCNlRUSXdNQ0ExTURCb01UQXdkaTB4TURCb0xURXdNSFl4TURCNlRUUXdNQ0ExTURCb01UQXdkaTB4TURCb0xURXdNSFl4TURCNlRUWXdNQ0ExTURCb01UQXdkaTB4TURCb0xURXdNSFl4TURCNlRUQWdNekF3YURFd01IWXRNVEF3YUMweE1EQjJNVEF3ZWsweU1EQWdNekF3YURFd01BcDJMVEV3TUdndE1UQXdkakV3TUhwTk5EQXdJRE13TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk5qQXdJRE13TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk1DQXhNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRJd01DQXhNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRRd01DQXhNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRZd01DQXhNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpjeUlpQjFibWxqYjJSbFBTSW1JM2hsTURjeU95SWdDbVE5SWswd0lEZ3dNR2d5TURCMkxUSXdNR2d0TWpBd2RqSXdNSHBOTXpBd0lEZ3dNR2d5TURCMkxUSXdNR2d0TWpBd2RqSXdNSHBOTmpBd0lEZ3dNR2d5TURCMkxUSXdNR2d0TWpBd2RqSXdNSHBOTUNBMU1EQm9NakF3ZGkweU1EQm9MVEl3TUhZeU1EQjZUVE13TUNBMU1EQm9NakF3ZGkweU1EQm9MVEl3TUhZeU1EQjZUVFl3TUNBMU1EQm9NakF3ZGkweU1EQm9MVEl3TUhZeU1EQjZUVEFnTWpBd2FESXdNSFl0TWpBd2FDMHlNREIyTWpBd2VrMHpNREFnTWpBd2FESXdNSFl0TWpBd2FDMHlNREIyTWpBd2VrMDJNREFnTWpBd2FESXdNSFl0TWpBd2FDMHlNREIyTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNNeUlnZFc1cFkyOWtaVDBpSmlONFpUQTNNenNpSUFwa1BTSk5NQ0E0TURCb016QXdkaTB6TURCb0xUTXdNSFl6TURCNlRUVXdNQ0E0TURCb016QXdkaTB6TURCb0xUTXdNSFl6TURCNlRUQWdNekF3YURNd01IWXRNekF3YUMwek1EQjJNekF3ZWswMU1EQWdNekF3YURNd01IWXRNekF3YUMwek1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJM05DSWdkVzVwWTI5a1pUMGlKaU40WlRBM05Ec2lJQXBrUFNKTk1Ua2dPREF3YURZMk1tTXhNU0F3SURFNUlDMDRJREU1SUMweE9YWXRNek14WXpBZ0xUSTRJQzB5TWlBdE5UQWdMVFV3SUMwMU1HZ3ROakF3WXkweU9DQXdJQzAxTUNBeU1pQXROVEFnTlRCMk16TXhZekFnTVRFZ09DQXhPU0F4T1NBeE9YcE5NQ0F6TURsak1UWWdMVFlnTXpJZ0xUa2dOVEFnTFRsb05qQXdZekU0SURBZ016UWdNeUExTUNBNWRpMHlPVEJqTUNBdE1URWdMVGdnTFRFNUlDMHhPU0F0TVRsb0xUWTJNbU10TVRFZ01DQXRNVGtnT0NBdE1Ua2dNVGwyTWprd2VrMDFOVEFnTWpBd1l5MHlPQ0F3SUMwMU1DQXRNaklnTFRVd0lDMDFNSE15TWlBdE5UQWdOVEFnTFRVd0NuTTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNOU0lnZFc1cFkyOWtaVDBpSmlONFpUQTNOVHNpSUFwa1BTSk5NQ0EzTURCb016QXdkaTB4TURCb0xUVXdZeTB5T0NBd0lDMDFNQ0F0TWpJZ0xUVXdJQzAxTUhZdE1UVXdhRE13TUhZeE5UQmpNQ0F5T0NBdE1qSWdOVEFnTFRVd0lEVXdhQzAxTUhZeE1EQm9NekF3ZGkweE1EQm9MVFV3WXkweU9DQXdJQzAxTUNBdE1qSWdMVFV3SUMwMU1IWXROREF3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCb05UQjJMVEV3TUdndE16QXdkakV3TUdnMU1HTXlPQ0F3SURVd0lESXlJRFV3SURVd2RqRTFNR2d0TXpBd2RpMHhOVEJqTUNBdE1qZ2dNaklnTFRVd0lEVXdJQzAxTUdnMU1IWXRNVEF3YUMwek1EQjJNVEF3YURVd1l6STRJREFnTlRBZ01qSWdOVEFnTlRBS2RqUXdNR013SURJNElDMHlNaUExTUNBdE5UQWdOVEJvTFRVd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTnpZaUlIVnVhV052WkdVOUlpWWplR1V3TnpZN0lpQUtaRDBpVFRRd01DQTNNREJqTVRZMUlEQWdNekF3SUMweE16VWdNekF3SUMwek1EQjJMVEV3TUdnMU1HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQjJMVEl3TUdNd0lDMHlPQ0F0TWpJZ0xUVXdJQzAxTUNBdE5UQm9MVEV3TUdNdE1qZ2dNQ0F0TlRBZ01qSWdMVFV3SURVd2RqTTFNR013SURFeE1TQXRPRGtnTWpBd0lDMHlNREFnTWpBd2N5MHlNREFnTFRnNUlDMHlNREFnTFRJd01IWXRNelV3WXpBZ0xUSTRJQzB5TWlBdE5UQWdMVFV3SUMwMU1HZ3RNVEF3WXkweU9DQXdJQzAxTUNBeU1pQXROVEFnTlRCMk1qQXdZekFnTWpnZ01qSWdOVEFnTlRBZ05UQm9OVEIyTVRBd0NtTXdJREUyTlNBeE16VWdNekF3SURNd01DQXpNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpjM0lpQjFibWxqYjJSbFBTSW1JM2hsTURjM095SWdDbVE5SWswd0lEVXdNR013SURFd09TQTVNU0F5TURBZ01qQXdJREl3TUhNeU1EQWdMVGt4SURJd01DQXRNakF3WXpBZ01UQTVJRGt4SURJd01DQXlNREFnTWpBd2N6SXdNQ0F0T1RFZ01qQXdJQzB5TURCak1DQXROVFVnTFRJeklDMHhNRFVnTFRVNUlDMHhOREZzTFRNME1TQXRNelF3YkMwek5ERWdNelF3WXkwek5pQXpOaUF0TlRrZ09EWWdMVFU1SURFME1Yb2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOemdpSUhWdWFXTnZaR1U5SWlZamVHVXdOemc3SWlBS1pEMGlUVFF3TUNBM01EQnNOREF3SUMwek1EQnNMVEV3TUNBemRpMDBNRE5vTFRJd01IWXlNREJvTFRJd01IWXRNakF3YUMweU1EQjJOREF3YUMweE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamM1SWlCMWJtbGpiMlJsUFNJbUkzaGxNRGM1T3lJZ0NtUTlJazB3SURnd01HZzRNREIyTFRnd01HZ3RPREF3ZGpnd01IcE5NVEF3SURjd01IWXRNekF3YkRFd01DQXhNREJzTkRBd0lDMDBNREJvTVRBd2RqRXdNR3d0TWpBd0lESXdNR3d4TURBZ01UQXdiREV3TUNBdE1UQXdkak13TUdndE5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzWVNJZ2RXNXBZMjlrWlQwaUppTjRaVEEzWVRzaUlBcGtQU0pOTVRrZ09EQXdhRGMyTW1NeE1TQXdJREU1SUMwNElERTVJQzB4T1hZdE56WXlZekFnTFRFeElDMDRJQzB4T1NBdE1Ua2dMVEU1YUMwM05qSmpMVEV4SURBZ0xURTVJRGdnTFRFNUlERTVkamMyTW1Nd0lERXhJRGdnTVRrZ01Ua2dNVGw2VFRFd01DQTJNREIyTFRNd01HZ3hNREJzTVRBd0lDMHhNREJvTWpBd2JERXdNQ0F4TURCb01UQXdkak13TUdndE5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzWWlJZ2RXNXBZMjlrWlQwaUppTjRaVEEzWWpzaUlBcGtQU0pOTWpBd0lEWXdNR000TUNBd0lERTBNaUF0TlRZZ01qQXdJQzB4TWpKak5UZ2dOallnTVRFNUlERXlNaUF5TURBZ01USXlZekV6TVNBd0lESXdNQ0F0TVRBeElESXdNQ0F0TWpBd2N5MDJPU0F0TWpBd0lDMHlNREFnTFRJd01HTXRPREVnTUNBdE1UUXlJRFUySUMweU1EQWdNVEl5WXkwMU9DQXROallnTFRFeU1TQXRNVEl5SUMweU1EQWdMVEV5TW1NdE1UTXhJREFnTFRJd01DQXhNREVnTFRJd01DQXlNREJ6TmprZ01qQXdJREl3TUNBeU1EQjZUVEl3TUNBMU1EQmpMVGMwSURBZ0xURXdNQ0F0TlRRZ0xURXdNQ0F0TVRBd2N6STJJQzB4TURBZ01UQXdJQzB4TURBS1l6UXlJREFnT0RnZ05EY2dNVE0wSURFd01HTXRORFlnTlRNZ0xUa3lJREV3TUNBdE1UTTBJREV3TUhwTk5qQXdJRFV3TUdNdE5ETWdNQ0F0T0RnZ0xUUTNJQzB4TXpRZ0xURXdNR00wTmlBdE5UTWdPVEVnTFRFd01DQXhNelFnTFRFd01HTTNOQ0F3SURFd01DQTFOQ0F4TURBZ01UQXdjeTB5TmlBeE1EQWdMVEV3TUNBeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamRqSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGRqT3lJZ2FHOXlhWG90WVdSMkxYZzlJalF3TUNJZ0NtUTlJazB6TURBZ09EQXdZelUxSURBZ01UQXdJQzAwTlNBeE1EQWdMVEV3TUhNdE5EVWdMVEV3TUNBdE1UQXdJQzB4TURCekxURXdNQ0EwTlNBdE1UQXdJREV3TUhNME5TQXhNREFnTVRBd0lERXdNSHBOTVRVd0lEVTFNR000TXlBd0lERTFNQ0F0TmprZ01UVXdJQzB4TlRCak1DQXROallnTFRFd01DQXRNakUwSUMweE1EQWdMVEkxTUdNd0lDMHlPQ0F5TWlBdE5UQWdOVEFnTFRVd2N6VXdJREl5SURVd0lEVXdhREV3TUdNd0lDMDRNeUF0TmpjZ0xURTFNQ0F0TVRVd0lDMHhOVEJ6TFRFMU1DQTJOQ0F0TVRVd0lERTFNSE14TURBZ01qSXlJREV3TUNBeU5UQnpMVEl5SURVd0lDMDFNQ0ExTUFwekxUVXdJQzB5TWlBdE5UQWdMVFV3YUMweE1EQmpNQ0E0TXlBMk55QXhOVEFnTVRVd0lERTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTjJRaUlIVnVhV052WkdVOUlpWWplR1V3TjJRN0lpQUtaRDBpVFRJd01DQTRNREJvTlRBd2RpMHhNREJvTFRFeU1tTXROemNnTFRFNU55QXRNVFUySUMwek9USWdMVEl6TkNBdE5UZzRiQzAySUMweE1tZ3hOakoyTFRFd01HZ3ROVEF3ZGpFd01HZ3hNakpqTnpjZ01UazNJREUxTmlBek9USWdNak0wSURVNE9HdzNJREV5YUMweE5qTjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJM1pTSWdkVzVwWTI5a1pUMGlKaU40WlRBM1pUc2lJQXBrUFNKTk1DQTNNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRBZ05UQXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB3SURNd01HZzRNREIyTFRFd01HZ3RPREF3ZGpFd01IcE5NVEF3SURFd01HZzJNREIyTFRFd01HZ3ROakF3ZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOMllpSUhWdWFXTnZaR1U5SWlZamVHVXdOMlk3SWlBS1pEMGlUVEFnTnpBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJRFV3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1DQXpNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRBZ01UQXdhRFl3TUhZdE1UQXdhQzAyTURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0TUNJZ2RXNXBZMjlrWlQwaUppTjRaVEE0TURzaUlBcGtQU0pOTUNBM01EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZUVEFnTlRBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJRE13TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1qQXdJREV3TUdnMk1EQjJMVEV3TUdndE5qQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9ERWlJSFZ1YVdOdlpHVTlJaVlqZUdVd09ERTdJaUFLWkQwaVRUVTFNQ0E0TURCak1UTTRJREFnTWpVd0lDMHhNVElnTWpVd0lDMHlOVEJ6TFRFeE1pQXRNalV3SUMweU5UQWdMVEkxTUdNdE1UWWdNQ0F0TXpJZ01DQXRORGNnTTJ3dE15QXRNM1l0TVRBd2FDMHlNREIyTFRJd01HZ3RNekF3ZGpJd01Hd3pNRE1nTXpBell5MHpJREUxSUMweklETXhJQzB6SURRM1l6QWdNVE00SURFeE1pQXlOVEFnTWpVd0lESTFNSHBOTmpBd0lEY3dNR010TlRVZ01DQXRNVEF3SUMwME5TQXRNVEF3SUMweE1EQnpORFVnTFRFd01DQXhNREFnTFRFd01ITXhNREFnTkRVZ01UQXdJREV3TUhNdE5EVWdNVEF3SUMweE1EQWdNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNE1pSWdkVzVwWTI5a1pUMGlKaU40WlRBNE1qc2lJQXBrUFNKTk1UTTBJRFl3TUdnemFEUm9OR2cxYURVd01HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQjJMVE0xTUdneE1EQjJMVEUxTUdNd0lDMHlPQ0F0TWpJZ0xUVXdJQzAxTUNBdE5UQm9MVGN3TUdNdE1qZ2dNQ0F0TlRBZ01qSWdMVFV3SURVd2RqRTFNR2d4TURCMk16VXdkakpqTUNBeU1DQXhOU0EwTWlBek5DQTBPSHBOTWpBd0lEVXdNSFl0TXpBd2FERXdNSFl0TVRBd2FESXdNSFl4TURCb01UQXdkak13TUdndE5EQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0TXlJZ2RXNXBZMjlrWlQwaUppTjRaVEE0TXpzaUlBcGtQU0pOTUNBNE1EQm9OREF3ZGkwME1EQm9MVFF3TUhZME1EQjZUVFV3TUNBMk1EQm9NVEF3ZGkwME1EQm9MVFF3TUhZeE1EQm9NekF3ZGpNd01IcE5OekF3SURRd01HZ3hNREIyTFRRd01HZ3ROREF3ZGpFd01HZ3pNREIyTXpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTROQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTRORHNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5Nek0zSURZNU5HTTJJRFFnTVRJZ055QXlNU0EzWXpJNElEQWdOVEFnTFRJeUlEVXdJQzAxTUdNd0lDMHhOeUF0TVRJZ0xUTTNJQzB5TnlBdE5EVnNMVE13TUNBdE1UVXdZeTA0SUMwMklDMHlNU0F0TVRFZ0xUTXhJQzB4TVdNdE1qZ2dNQ0F0TlRBZ01qSWdMVFV3SURVd1l6QWdNakVnTVRZZ05EUWdNemNnTkRsNlRUUXpOeUExTkRSak5pQTBJREV5SURjZ01qRWdOMk15T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJqTUNBdE1UY2dMVEV5SUMwek55QXRNamNnTFRRMWJDMDBNREFnTFRJd01HTXRPQ0F0TmlBdE1qRWdMVEV4SUMwek1TQXRNVEZqTFRJNElEQWdMVFV3SURJeUlDMDFNQ0ExTUFwak1DQXlNU0F4TmlBME5DQXpOeUEwT1hwTk5ETTNJRE0wTkdNMklEUWdNVElnTnlBeU1TQTNZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNR013SUMweE55QXRNVElnTFRNM0lDMHlOeUF0TkRWc0xURXdOaUF0TlRaak1qUWdMVFFnTkRNZ0xUSTJJRFF6SUMwMU1HTXdJQzB5T0NBdE1qTWdMVFV4SUMwMU1TQXROVEZqTFRJZ01DQXROaUF4SUMwNElERm9MVEl3TUdNdE1qWWdNU0F0TkRnZ01qUWdMVFE0SURVd1l6QWdNVFlnTVRJZ016WWdNallnTkRSNlRURTFNU0F0TlRCak1DQXlNeUF5TUNBMU1DQTBOaUExTUdnemFEUm9OV2d4TURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd0NuTXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xURXdNR010TWlBd0lDMDJJQzB4SUMwNElDMHhZeTB5T0NBd0lDMDFNQ0F5TXlBdE5UQWdOVEY2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpnMUlpQjFibWxqYjJSbFBTSW1JM2hsTURnMU95SWdDbVE5SWsweE9Ua2dPREF3YURFd01IWXRNakF3YUMweU1EQjJNVEF3YURFd01IWXhNREI2VFRVNE5pQTNPVGRvTVdNeE9DQXhJRE00SURFZ05UWWdMVE5qTXpZZ0xUZ2dOamtnTFRJMklEazNJQzAxTkdNM09DQXROemdnTnpnZ0xUSXdNeUF3SUMweU9ERnNMVEUxTUNBdE1UVXdZeTA0SUMweE15QXRNamdnTFRJMElDMDBNeUF0TWpSakxUSTRJREFnTFRVd0lESXlJQzAxTUNBMU1HTXdJREUxSURFeElETTFJREkwSURRemJERTFNQ0F4TlRCak5EQWdOREFnTXprZ01UQTFJREFnTVRRMFl5MDBNU0EwTVNBdE1URXdJRE0wSUMweE5EUWdNR3d0TkRRZ0xUUTBDbU10T0NBdE1UTWdMVEkzSUMweU5DQXRORElnTFRJMFl5MHlPQ0F3SUMwMU1DQXlNaUF0TlRBZ05UQmpNQ0F4TlNBeE1TQXpOU0F5TkNBME0ydzBNeUEwTkdNek1pQXpNeUEzTWlBMU15QXhNamdnTlRaNlRUSXdPQ0EwT1RCak5DQTFJREUwSURFMklESXlJREUyYUROak1pQXdJRFlnTVNBNElERmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdZekFnTFRFeElDMDJJQzB5TnlBdE1UUWdMVE0xYkMweE5UQWdMVEUxTUdNdE5EQWdMVFF3SUMwek9TQXRNVEExSURBZ0xURTBOR00wTVNBdE5ERWdNVEV3SUMwek5DQXhORFFnTUd3ME5DQTBOR000SURFeklESTNJREkwSURReUlESTBDbU15T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJqTUNBdE1UVWdMVEV4SUMwek5TQXRNalFnTFRRemJDMDBNeUF0TkRSakxUSXlJQzB5TWlBdE5EZ2dMVE0zSUMwM05TQXRORGRqTFRjd0lDMHlOU0F0TVRVeElDMDVJQzB5TURjZ05EZGpMVGM0SURjNElDMDNPQ0F5TURNZ01DQXlPREY2VFRRNU9TQXlNREJvTWpBd2RpMHhNREJvTFRFd01IWXRNVEF3YUMweE1EQjJNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNE5pSWdkVzVwWTI5a1pUMGlKaU40WlRBNE5qc2lJQXBrUFNKTk5UZzJJRGM1TjJNeE9DQXhJRE01SURFZ05UY2dMVE5qTXpZZ0xUZ2dOamtnTFRJMklEazNJQzAxTkdNM09DQXROemdnTnpnZ0xUSXdNeUF3SUMweU9ERnNMVEUxTUNBdE1UVXdZeTAyTWlBdE5qSWdMVEV6TWlBdE9ERWdMVEU0TWlBdE56aHpMVFk1SURFM0lDMDROQ0F5TlhNdE1qWWdNamNnTFRJMklEUTBZekFnTWpnZ01qSWdOVEVnTlRBZ05URmpPQ0F3SURFNUlDMHpJREkySUMwM1l6QWdNQ0F4TlNBdE1URWdOREVnTFRFemN6WXlJRE1nTVRBMklEUTNiREUxTUNBeE5UQmpOREFnTkRBZ016a2dNVEExSURBZ01UUTBZeTAwTVNBME1TQXRNVEV3SURNMElDMHhORFFnTUFwakxUZ2dMVEV6SUMweU9DQXRNalFnTFRReklDMHlOR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3WXpBZ01UVWdNVEVnTXpVZ01qUWdORE5qTXpJZ016TWdOeklnTlRNZ01USTRJRFUyZWswek9EWWdOVFkyWXpVd0lDMHlJRFkwSUMweE55QTROU0F0TWpKek16Y2dMVEk0SURNM0lDMDBPV013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCakxURXdJREFnTFRJeklEVWdMVE14SURFeFl6QWdNQ0F0TVRrZ09TQXRORGNnTVRCekxUWXpJQzAwSUMweE1ETWdMVFEwYkMweE5UQWdMVEUxTUdNdE5EQWdMVFF3SUMwek9TQXRNVEExSURBZ0xURTBOR00wTVNBdE5ERWdNVEV3SUMwek5DQXhORFFnTUFwak9DQXhNeUF5TnlBeU5DQTBNaUF5TkdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCak1DQXRNVFVnTFRFd0lDMHpOU0F0TWpNZ0xUUXpZeTB5TWlBdE1qSWdMVFE0SUMwek55QXROelVnTFRRM1l5MDNNQ0F0TWpVZ0xURTFNU0F0T1NBdE1qQTNJRFEzWXkwM09DQTNPQ0F0TnpnZ01qQXpJREFnTWpneGJERTFNQ0F4TlRCak5qQWdOakFnTVRJNElEYzRJREUzT0NBM05ub2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPRGNpSUhWdWFXTnZaR1U5SWlZamVHVXdPRGM3SWlBS1pEMGlUVEFnTnpBd2FETXdNSFl0TXpBd2FDMHpNREIyTXpBd2VrMDBNREFnTnpBd2FEUXdNSFl0TVRBd2FDMDBNREIyTVRBd2VrMDBNREFnTlRBd2FETXdNSFl0TVRBd2FDMHpNREIyTVRBd2VrMHdJRE13TUdnek1EQjJMVE13TUdndE16QXdkak13TUhwTk5EQXdJRE13TUdnME1EQjJMVEV3TUdndE5EQXdkakV3TUhwTk5EQXdJREV3TUdnek1EQjJMVEV3TUdndE16QXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9EZ2lJSFZ1YVdOdlpHVTlJaVlqZUdVd09EZzdJaUFLWkQwaVRUVXdJRGN3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCekxUSXlJQzAxTUNBdE5UQWdMVFV3Y3kwMU1DQXlNaUF0TlRBZ05UQnpNaklnTlRBZ05UQWdOVEI2VFRJd01DQTNNREJvTmpBd2RpMHhNREJvTFRZd01IWXhNREI2VFRVd0lEVXdNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJ6TFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCek1qSWdOVEFnTlRBZ05UQjZUVEl3TUNBMU1EQm9OakF3ZGkweE1EQm9MVFl3TUhZeE1EQjZUVFV3SURNd01HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEFLY3pJeUlEVXdJRFV3SURVd2VrMHlNREFnTXpBd2FEWXdNSFl0TVRBd2FDMDJNREIyTVRBd2VrMDFNQ0F4TURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdjekl5SURVd0lEVXdJRFV3ZWsweU1EQWdNVEF3YURZd01IWXRNVEF3YUMwMk1EQjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNE9TSWdkVzVwWTI5a1pUMGlKaU40WlRBNE9Uc2lJQXBrUFNKTk9EQXdJRGd3TUd3dE5EQXdJQzA0TURCc0xURXdNQ0F6TURCc0xUTXdNQ0F4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqaGhJaUIxYm1samIyUmxQU0ltSTNobE1EaGhPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHpNREFnTnpBd1l6RXhNQ0F3SURJd01DQXRPVEFnTWpBd0lDMHlNREIyTFRFd01HZ3hNREIyTFRRd01HZ3ROakF3ZGpRd01HZ3hNREIyTVRBd1l6QWdNVEV3SURrd0lESXdNQ0F5TURBZ01qQXdlazB6TURBZ05qQXdZeTAxTmlBd0lDMHhNREFnTFRRMElDMHhNREFnTFRFd01IWXRNVEF3YURJd01IWXhNREJqTUNBMU5pQXRORFFnTVRBd0lDMHhNREFnTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTRZaUlnZFc1cFkyOWtaVDBpSmlONFpUQTRZanNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5NekF3SURnd01HTXhNVEFnTUNBeU1EQWdMVGt3SURJd01DQXRNakF3ZGkweU1EQm9NVEF3ZGkwME1EQm9MVFl3TUhZME1EQm9OREF3ZGpJd01HTXdJRFUySUMwME5DQXhNREFnTFRFd01DQXhNREJ6TFRFd01DQXRORFFnTFRFd01DQXRNVEF3YUMweE1EQmpNQ0F4TVRBZ09UQWdNakF3SURJd01DQXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpoaklpQjFibWxqYjJSbFBTSW1JM2hsTURoak95SWdDbVE5SWswME1EQWdOekF3ZGkweE1EQmpMVEV4TVNBd0lDMHlNREFnTFRnNUlDMHlNREFnTFRJd01HZ3hNREJzTFRFMU1DQXRNakF3YkMweE5UQWdNakF3YURFd01HTXdJREUyTlNBeE16VWdNekF3SURNd01DQXpNREI2VFRZMU1DQTJNREJzTVRVd0lDMHlNREJvTFRFd01HTXdJQzB4TmpVZ0xURXpOU0F0TXpBd0lDMHpNREFnTFRNd01IWXhNREJqTVRFeElEQWdNakF3SURnNUlESXdNQ0F5TURCb0xURXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT0dRaUlIVnVhV052WkdVOUlpWWplR1V3T0dRN0lpQUtaRDBpVFRFd01DQTRNREJvTmpBd2RpMHpNREJvTVRBd2JDMHhOVEFnTFRJMU1Hd3RNVFV3SURJMU1HZ3hNREIyTWpBd2FDMDBNREIyTFRFd01HZ3RNVEF3ZGpJd01IcE5NVFV3SURVMU1Hd3hOVEFnTFRJMU1HZ3RNVEF3ZGkweU1EQm9OREF3ZGpFd01HZ3hNREIyTFRJd01HZ3ROakF3ZGpNd01HZ3RNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNFpTSWdkVzVwWTI5a1pUMGlKaU40WlRBNFpUc2lJQXBrUFNKTk5qQXdJRGN3TUd3eU1EQWdMVEUxTUd3dE1qQXdJQzB4TlRCMk1UQXdhQzAxTURCMkxURXdNR2d0TVRBd2RqRXdNR013SURVMUlEUTFJREV3TUNBeE1EQWdNVEF3YURVd01IWXhNREI2VFRJd01DQXpNREIyTFRFd01HZzFNREIyTVRBd2FERXdNSFl0TVRBd1l6QWdMVFUxSUMwME5TQXRNVEF3SUMweE1EQWdMVEV3TUdndE5UQXdkaTB4TURCc0xUSXdNQ0F4TlRCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqaG1JaUIxYm1samIyUmxQU0ltSTNobE1EaG1PeUlnYUc5eWFYb3RZV1IyTFhnOUlqa3dNQ0lnQ21ROUlrMHpOVEFnT0RBd1l6RTVNeUF3SURNMU1DQXRNVFUzSURNMU1DQXRNelV3WXpBZ0xUWXdJQzB4TnlBdE1URTNJQzAwTkNBdE1UWTJZelVnTFRNZ01USWdMVGdnTVRZZ0xURXliREV3TUNBdE1UQXdZekUySUMweE5pQXpNQ0F0TkRrZ016QWdMVGN5WXpBZ0xUVTJJQzAwTmlBdE1UQXlJQzB4TURJZ0xURXdNbU10TWpNZ01DQXROVFlnTVRRZ0xUY3lJRE13YkMweE1EQWdNVEF3WXkwMElETWdMVGtnT1NBdE1USWdNVE5qTFRRNUlDMHlOaUF0TVRBM0lDMDBNU0F0TVRZMklDMDBNV010TVRreklEQWdMVE0xTUNBeE5UY2dMVE0xTUNBek5UQnpNVFUzSURNMU1DQXpOVEFnTXpVd2VrMHpOVEFnTWpBd0NtTXhORElnTUNBeU5UQWdNVEE0SURJMU1DQXlOVEJqTUNBeE16a2dMVEV4TVNBeU5UQWdMVEkxTUNBeU5UQnpMVEkxTUNBdE1URXhJQzB5TlRBZ0xUSTFNSE14TVRFZ0xUSTFNQ0F5TlRBZ0xUSTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT1RBaUlIVnVhV052WkdVOUlpWWplR1V3T1RBN0lpQm9iM0pwZWkxaFpIWXRlRDBpTmpBd0lpQUtaRDBpVFRNd01DQTRNREJqTVRZMklEQWdNekF3SUMweE16UWdNekF3SUMwek1EQmpNQ0F0TWpBd0lDMHpNREFnTFRVd01DQXRNekF3SUMwMU1EQnpMVE13TUNBek1EQWdMVE13TUNBMU1EQmpNQ0F4TmpZZ01UTTBJRE13TUNBek1EQWdNekF3ZWswek1EQWdOekF3WXkweE1UQWdNQ0F0TWpBd0lDMDVNQ0F0TWpBd0lDMHlNREJ6T1RBZ0xUSXdNQ0F5TURBZ0xUSXdNSE15TURBZ09UQWdNakF3SURJd01ITXRPVEFnTWpBd0lDMHlNREFnTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTVNU0lnZFc1cFkyOWtaVDBpSmlONFpUQTVNVHNpSUdodmNtbDZMV0ZrZGkxNFBTSTVNREFpSUFwa1BTSk5NQ0E0TURCb09EQXdkaTAxTkRGak1TQXRNeUF4SUMwNElERWdMVEV4Y3pBZ0xUY2dMVEVnTFRFd2RpMHlNemhvTFRnd01IWTRNREI2VFRRNU5TQXlOVEJqTUNBeU5pQXlNaUExTUNBMU1DQTFNR2cxYURFMU1IWTBNREJvTFRZd01IWXROakF3YURZd01IWXhNREJvTFRFMU1HZ3ROV010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZWswek5UQWdOakF3WXpneklEQWdNVFV3SUMwMk55QXhOVEFnTFRFMU1HTXdJQzB4TURBZ0xURTFNQ0F0TWpVd0lDMHhOVEFnTFRJMU1ITXRNVFV3SURFMU1DQXRNVFV3SURJMU1HTXdJRGd6SURZM0lERTFNQ0F4TlRBZ01UVXdlazB6TlRBZ05UQXdDbU10TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCek1qSWdMVFV3SURVd0lDMDFNSE0xTUNBeU1pQTFNQ0ExTUhNdE1qSWdOVEFnTFRVd0lEVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1TWlJZ2RXNXBZMjlrWlQwaUppTjRaVEE1TWpzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTUNBM01EQm9NakF3ZGkwMk1EQm9MVEl3TUhZMk1EQjZUVFF3TUNBM01EQm9NakF3ZGkwMk1EQm9MVEl3TUhZMk1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamt6SWlCMWJtbGpiMlJsUFNJbUkzaGxNRGt6T3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB3SURjd01HdzJNREFnTFRNd01Hd3ROakF3SUMwek1EQjJOakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNU5DSWdkVzVwWTI5a1pUMGlKaU40WlRBNU5Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16QXdJRGN3TUdNeE5qWWdNQ0F6TURBZ0xURXpOQ0F6TURBZ0xUTXdNSE10TVRNMElDMHpNREFnTFRNd01DQXRNekF3Y3kwek1EQWdNVE0wSUMwek1EQWdNekF3Y3pFek5DQXpNREFnTXpBd0lETXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT1RVaUlIVnVhV052WkdVOUlpWWplR1V3T1RVN0lpQUtaRDBpVFRRd01DQTNNREIyTFRZd01Hd3ROREF3SURNd01IcE5OREF3SURRd01HdzBNREFnTXpBd2RpMDJNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWprMklpQjFibWxqYjJSbFBTSW1JM2hsTURrMk95SWdDbVE5SWswd0lEY3dNR3cwTURBZ0xUTXdNR3d0TkRBd0lDMHpNREIyTmpBd2VrMDBNREFnTVRBd2RqWXdNR3cwTURBZ0xUTXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT1RjaUlIVnVhV052WkdVOUlpWWplR1V3T1RjN0lpQUtaRDBpVFRBZ056QXdhREl3TUhZdE5qQXdhQzB5TURCMk5qQXdlazB5TURBZ05EQXdiRFV3TUNBek1EQjJMVFl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9UZ2lJSFZ1YVdOdlpHVTlJaVlqZUdVd09UZzdJaUFLWkQwaVRUQWdOekF3YkRVd01DQXRNekF3YkMwMU1EQWdMVE13TUhZMk1EQjZUVFV3TUNBeE1EQjJOakF3YURJd01IWXROakF3YUMweU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJams1SWlCMWJtbGpiMlJsUFNJbUkzaGxNRGs1T3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB3SURjd01HZzJNREIyTFRZd01HZ3ROakF3ZGpZd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPV0VpSUhWdWFXTnZaR1U5SWlZamVHVXdPV0U3SWlBS1pEMGlUVEl3TUNBNE1EQm9OREF3ZGkweU1EQm9NakF3ZGkwME1EQm9MVEl3TUhZdE1qQXdhQzAwTURCMk1qQXdhQzB5TURCMk5EQXdhREl3TUhZeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamxpSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGxpT3lJZ0NtUTlJazB3SURjd01HZzRNREIyTFRFd01HZ3RPREF3ZGpFd01IcE5NQ0EwTUROb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUQWdNVEF6YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNVl5SWdkVzVwWTI5a1pUMGlKaU40WlRBNVl6c2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk1qYzRJRGN3TUdNM0lESWdNVE1nTkNBeU1pQTBZelUxSURBZ01UQXdJQzAwTlNBeE1EQWdMVEV3TUhZdE5IWXRNakF3WXpBZ0xUVTFJQzAwTlNBdE1UQXdJQzB4TURBZ0xURXdNSE10TVRBd0lEUTFJQzB4TURBZ01UQXdkakl3TUhZeVl6QWdORFFnTXpVZ09EZ2dOemdnT1RoNlRUTTBJRFV3TUdnMGFETmpNeUF3SURZZ01TQTVJREZqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3ZGkweGRpMDFNR013SUMweE1URWdPRGtnTFRJd01DQXlNREFnTFRJd01ITXlNREFnT0RrZ01qQXdJREl3TUhZMU1HTXdJREk0SURJeUlEVXdJRFV3SURVd2N6VXdJQzB5TWlBMU1DQXROVEIyTFRVd0NtTXdJQzB4TkRnZ0xURXdPU0F0TWpjd0lDMHlOVEFnTFRJNU5IWXRNVEEyYURVd1l6VTFJREFnTVRBd0lDMDBOU0F4TURBZ0xURXdNR2d0TkRBd1l6QWdOVFVnTkRVZ01UQXdJREV3TUNBeE1EQm9OVEIyTVRBMll5MHhOREVnTWpRZ0xUSTFNQ0F4TkRZZ0xUSTFNQ0F5T1RSMk5UQjJNbU13SURJd0lERTFJRFF5SURNMElEUTRlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1WkNJZ2RXNXBZMjlrWlQwaUppTjRaVEE1WkRzaUlBcGtQU0pOTUNBMU1EQm9PREF3ZGkweU1EQm9MVGd3TUhZeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamxsSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGxsT3lJZ0NtUTlJazB6TkNBM01EQm9OR2d6YURSb05XZzNNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3ZGkwMU1EQmpNQ0F0TWpnZ0xUSXlJQzAxTUNBdE5UQWdMVFV3YUMweU5UQjJMVEV3TUdneE1EQmpOVFVnTUNBeE1EQWdMVFExSURFd01DQXRNVEF3YUMwMk1EQmpNQ0ExTlNBME5TQXhNREFnTVRBd0lERXdNR2d4TURCMk1UQXdhQzB5TlRCakxUSTRJREFnTFRVd0lESXlJQzAxTUNBMU1IWTFNREIyTW1Nd0lESXdJREUxSURReUlETTBJRFE0ZWsweE1EQWdOakF3ZGkwME1EQm9OakF3ZGpRd01HZ3ROakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNVppSWdkVzVwWTI5a1pUMGlKaU40WlRBNVpqc2lJQXBrUFNKTk1qY3lJRGN3TUdNdE1UUWdMVFF3SUMweU1pQXRPRE1nTFRJeUlDMHhNamhqTUNBdE1qSXhJREUzT1NBdE5EQXdJRFF3TUNBdE5EQXdZelExSURBZ09EZ2dPQ0F4TWpnZ01qSmpMVFV6SUMweE5UZ2dMVEl3TWlBdE1qY3lJQzB6TnpnZ0xUSTNNbU10TWpJeElEQWdMVFF3TUNBeE56a2dMVFF3TUNBME1EQmpNQ0F4TnpZZ01URTBJRE15TlNBeU56SWdNemM0ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaE1DSWdkVzVwWTI5a1pUMGlKaU40WlRCaE1Ec2lJQXBrUFNKTk16VXdJRGN3TUd3eE5UQWdMVEUxTUdndE1UQXdkaTB4TlRCb01UVXdkakV3TUd3eE5UQWdMVEUxTUd3dE1UVXdJQzB4TlRCMk1UQXdhQzB4TlRCMkxURTFNR2d4TURCc0xURTFNQ0F0TVRVd2JDMHhOVEFnTVRVd2FERXdNSFl4TlRCb0xURTFNSFl0TVRBd2JDMHhOVEFnTVRVd2JERTFNQ0F4TlRCMkxURXdNR2d4TlRCMk1UVXdhQzB4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltRXhJaUIxYm1samIyUmxQU0ltSTNobE1HRXhPeUlnQ21ROUlrMDRNREFnT0RBd2RpMDFOVEJqTUNBdE9ETWdMVFkzSUMweE5UQWdMVEUxTUNBdE1UVXdjeTB4TlRBZ05qY2dMVEUxTUNBeE5UQnpOamNnTVRVd0lERTFNQ0F4TlRCak1UY2dNQ0F6TlNBdE5DQTFNQ0F0T1hZeU1EWmpMVEl3TVNBdE5pQXRNekkzSUMweU55QXROREF3SUMwMU1IWXRNemszWXpBZ0xUZ3pJQzAyTnlBdE1UVXdJQzB4TlRBZ0xURTFNSE10TVRVd0lEWTNJQzB4TlRBZ01UVXdjelkzSURFMU1DQXhOVEFnTVRVd1l6RTNJREFnTXpVZ0xUUWdOVEFnTFRsMk5EQTVjekV3TUNBeE1EQWdOakF3SURFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZVElpSUhWdWFXTnZaR1U5SWlZamVHVXdZVEk3SWlCb2IzSnBlaTFoWkhZdGVEMGlOekF3SWlBS1pEMGlUVFE1T1NBM01EQmpOVEVnTUNBeE1ESWdMVEl3SURFME1TQXROVGxqTnpnZ0xUYzRJRGM0SUMweU1ETWdNQ0F0TWpneGJDMHlOVEFnTFRJME5HTXRORGdnTFRRNElDMHhNamNnTFRRNElDMHhOelVnTUhNdE5EZ2dNVEkzSURBZ01UYzFiRGsySURrM2JEWTVJQzAyT1d3dE9UQWdMVGswYkMwM0lDMHpZeTB4TUNBdE1UQWdMVEV3SUMweU9DQXdJQzB6T0hNeU9DQXRNVEFnTXpnZ01Hd3lOVEFnTWpRM1l6TTNJRFF3SURNNUlERXdNaUF3SURFME1YTXRNVEEwSURRd0lDMHhORFFnTUd3dE1qYzRJQzB5TnpWakxUWTJJQzAyT1NBdE5qZ2dMVEUzT1NBd0lDMHlORGNLWXpZNUlDMDJPU0F4T0RFZ0xUWTVJREkxTUNBd2JEa2dNVEpzTVRFMklERXhNMncyT1NBdE5qbHNMVEV5TlNBdE1USTFZeTB4TURjZ0xURXdOeUF0TWpneElDMHhNRGNnTFRNNE9DQXdjeTB4TURjZ01qZ3hJREFnTXpnNGJESTNPQ0F5TnpKak16a2dNemtnT1RBZ05Ua2dNVFF4SURVNWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhNeUlnZFc1cFkyOWtaVDBpSmlONFpUQmhNenNpSUFwa1BTSk5OakF3SURnd01Hd3lNREFnTFRJd01Hd3RNVEF3SUMweE1EQnNMVEl3TUNBeU1EQjZUVFF3TUNBMk1EQnNNakF3SUMweU1EQnNMVFF3TUNBdE5EQXdhQzB5TURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poTkNJZ2RXNXBZMjlrWlQwaUppTjRaVEJoTkRzaUlBcGtQU0pOTlRVd0lEZ3dNR000TXlBd0lERTFNQ0F0T1RBZ01UVXdJQzB5TURCekxUWTNJQzB5TURBZ0xURTFNQ0F0TWpBd1l5MHlNaUF3SUMwME1DQTRJQzAxT1NBeE9XTTJJREkySURrZ05USWdPU0E0TVdNd0lEZzBJQzB5TnlBeE5UZ2dMVGN5SURJeE1tTXlOeUExTWlBM01TQTRPQ0F4TWpJZ09EaDZUVEkxTUNBM01EQmpPRE1nTUNBeE5UQWdMVGt3SURFMU1DQXRNakF3Y3kwMk55QXRNakF3SUMweE5UQWdMVEl3TUhNdE1UVXdJRGt3SUMweE5UQWdNakF3Y3pZM0lESXdNQ0F4TlRBZ01qQXdlazAzTWpVZ016ZzBZelEwSUMweU1pQTNOU0F0TmpZZ056VWdMVEV4T0hZdE1UWTJhQzB5TURCMk5qWUtZekFnTlRBZ0xURTNJRGsySUMwME5DQXhNelJqTmpZZ01pQXhNallnTXpNZ01UWTVJRGcwZWswM05TQXlPRFJqTkRVZ0xUVXpJREV3TmlBdE9EUWdNVGMxSUMwNE5ITXhNekFnTXpFZ01UYzFJRGcwWXpRMElDMHlNaUEzTlNBdE5qWWdOelVnTFRFeE9IWXRNVFkyYUMwMU1EQjJNVFkyWXpBZ05USWdNekVnT1RZZ056VWdNVEU0ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaE5TSWdkVzVwWTI5a1pUMGlKaU40WlRCaE5Uc2lJQXBrUFNKTk5EQXdJRGd3TUdNeE1UQWdNQ0F5TURBZ0xURXhNaUF5TURBZ0xUSTFNSE10T1RBZ0xUSTFNQ0F0TWpBd0lDMHlOVEJ6TFRJd01DQXhNVElnTFRJd01DQXlOVEJ6T1RBZ01qVXdJREl3TUNBeU5UQjZUVEU1TVNBek1EQmpOVFFnTFRZeElERXlPQ0F0TVRBd0lESXdPU0F0TVRBd2N6RTFOU0F6T1NBeU1Ea2dNVEF3WXpFd05pQXROU0F4T1RFZ0xUa3lJREU1TVNBdE1qQXdkaTB4TURCb0xUZ3dNSFl4TURCak1DQXhNRGdnT0RVZ01UazFJREU1TVNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUUySWlCMWJtbGpiMlJsUFNJbUkzaGxNR0UyT3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB4T1NBNE1EQm9ORFl5WXpFeElEQWdNVGtnTFRnZ01Ua2dMVEU1ZGkwM05qSmpNQ0F0TVRFZ0xUZ2dMVEU1SUMweE9TQXRNVGxvTFRRMk1tTXRNVEVnTUNBdE1Ua2dPQ0F0TVRrZ01UbDJOell5WXpBZ01URWdPQ0F4T1NBeE9TQXhPWHBOTVRBd0lEY3dNSFl0TlRBd2FETXdNSFkxTURCb0xUTXdNSHBOTWpVd0lERTFNR010TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCek1qSWdMVFV3SURVd0lDMDFNSE0xTUNBeU1pQTFNQ0ExTUhNdE1qSWdOVEFnTFRVd0lEVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poTnlJZ2RXNXBZMjlrWlQwaUppTjRaVEJoTnpzaUlBcGtQU0pOTXpVd0lEZ3dNR014TnlBd0lETTBJQzB4SURVd0lDMHpkaTB6T1Rkc0xUSTVOeUF5T1Rkak5qTWdOalFnTVRVd0lERXdNeUF5TkRjZ01UQXplazAxTURBZ05qazBZekUyT1NBdE1qVWdNekF3SUMweE5qZ2dNekF3SUMwek5EUmpNQ0F0TVRreklDMHhOVGNnTFRNMU1DQXRNelV3SUMwek5UQmpMVGcxSURBZ0xURTJNU0F6TVNBdE1qSXlJRGd4YkRJM01pQXlOekoyTXpReGVrMDVNU0ExTmpKc01qTTNJQzB5TXpSc0xUSXhNaUF0TWpFeVl5MDNNQ0ExTlNBdE1URTJJREV6T0NBdE1URTJJREl6TkdNd0lEZzBJRE0xSURFMU9DQTVNU0F5TVRKNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltRTRJaUIxYm1samIyUmxQU0ltSTNobE1HRTRPeUlnQ21ROUlrMDVNaUEyTlRCak1DQXlNeUF5TUNBMU1DQTBOaUExTUdnemFEUm9OV2cwTURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUdndE5UQjJMVEl3TUdneE1EQmpOVFVnTUNBeE1EQWdMVFExSURFd01DQXRNVEF3YUMwek1EQjJMVE13TUd3dE5UWWdMVEV3TUd3dE5EUWdNVEF3ZGpNd01HZ3RNekF3WXpBZ05UVWdORFVnTVRBd0lERXdNQ0F4TURCb01UQXdkakl3TUdndE5UQmpMVElnTUNBdE5pQXRNU0F0T0NBdE1XTXRNamdnTUNBdE5UQWdNak1nTFRVd0lEVXhlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poT1NJZ2RXNXBZMjlrWlQwaUppTjRaVEJoT1RzaUlBcGtQU0pOTkRBd0lEZ3dNR015TWpFZ01DQTBNREFnTFRFM09TQTBNREFnTFRRd01ITXRNVGM1SUMwME1EQWdMVFF3TUNBdE5EQXdjeTAwTURBZ01UYzVJQzAwTURBZ05EQXdjekUzT1NBME1EQWdOREF3SURRd01IcE5NekF3SURZd01IWXROREF3YkRNd01DQXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1GaElpQjFibWxqYjJSbFBTSW1JM2hsTUdGaE95SWdDbVE5SWswek1EQWdPREF3YURJd01IWXRNekF3YURNd01IWXRNakF3YUMwek1EQjJMVE13TUdndE1qQXdkak13TUdndE16QXdkakl3TUdnek1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaFlpSWdkVzVwWTI5a1pUMGlKaU40WlRCaFlqc2lJQXBrUFNKTk16QXdJRGd3TUdneE1EQjJMVFF3TUdndE1UQXdkalF3TUhwTk1UY3lJRFkxTm13Mk1pQXROemhzTFRRd0lDMHpNV010TlRnZ0xUUTJJQzA1TkNBdE1URTNJQzA1TkNBdE1UazNZekFnTFRFek9TQXhNVEVnTFRJMU1DQXlOVEFnTFRJMU1ITXlOVEFnTVRFeElESTFNQ0F5TlRCak1DQTRNQ0F0TXprZ01UVXhJQzA1TnlBeE9UZHNMVE0zSURNeGJEWXlJRGM0YkRNNElDMHpNV000TWlBdE5qUWdNVE0wSUMweE5qUWdNVE0wSUMweU56VmpNQ0F0TVRreklDMHhOVGNnTFRNMU1DQXRNelV3SUMwek5UQnpMVE0xTUNBeE5UY2dMVE0xTUNBek5UQmpNQ0F4TVRFZ05UTWdNakV4SURFek5DQXlOelY2Q2lJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaFl5SWdkVzVwWTI5a1pUMGlKaU40WlRCaFl6c2lJQXBrUFNKTk1qQXdJRGd3TUdnME1EQjJMVEl3TUdndE5EQXdkakl3TUhwTk9TQTFNREJvTnpneVl6WWdNQ0E1SUMweklEa2dMVGwyTFRJNE1tTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDVNWFl5TURCb0xUWXdNSFl0TWpBd2FDMDVNV010TmlBd0lDMDVJRE1nTFRrZ09YWXlPREpqTUNBMklETWdPU0E1SURsNlRUSXdNQ0F6TURCb05EQXdkaTB6TURCb0xUUXdNSFl6TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltRmtJaUIxYm1samIyUmxQU0ltSTNobE1HRmtPeUlnQ21ROUlrMHdJRGN3TUdneE1EQjJMVGN3TUdndE1UQXdkamN3TUhwTk56QXdJRGN3TUdneE1EQjJMVGN3TUdndE1UQXdkamN3TUhwTk1qQXdJRFl3TUdneU1EQjJMVEV3TUdndE1qQXdkakV3TUhwTk16QXdJRFF3TUdneU1EQjJMVEV3TUdndE1qQXdkakV3TUhwTk5EQXdJREl3TUdneU1EQjJMVEV3TUdndE1qQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVlXVWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1lXVTdJaUFLWkQwaVRUTXlOU0EzTURCak5ESWdMVEUwTVNBNE55QXRNamd3SURFek1TQXROREU1WXpJNUlEYzBJRFU1SURFME9DQTRPQ0F5TWpKak16QWdMVFUzSURVNElDMHhNVFFnT0RjZ0xURTNNbWd4TmpsMkxURXdNR2d0TWpNeGJDMHhNeUF5T0dNdE16Y2dMVGt5SUMwM05DQXRNVGcwSUMweE1USWdMVEkzTldNdE16Z2dNVEk1SUMwM09TQXlOVGNnTFRFeE9TQXpPRFZqTFRReUlDMHhNek1nTFRneklDMHlOamNnTFRFeU5TQXROREF3WXkweU9DQTRPQ0F0TlRZZ01UYzFJQzA0TkNBeU5qSm9MVEV4Tm5ZeE1EQm9NVGc0YkRrZ0xUTTBiRE1nTFRaak5ESWdNVE0zSURneklESTNNeUF4TWpVZ05EQTVlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poWmlJZ2RXNXBZMjlrWlQwaUppTjRaVEJoWmpzaUlBcGtQU0pOTWpBd0lEWXdNR013SURVM0lEUXpJREV3TUNBeE1EQWdNVEF3Y3pFd01DQXRORE1nTVRBd0lDMHhNREJqTUNBdE1qZ2dMVEU0SUMwME9DQXRNamdnTFRjeVl5MHpJQzAySUMweklDMHhOaUF0TXlBdE1qaG9Nak14ZGkweU16RmpNVElnTUNBeU1pQXdJREk0SUROak1qUWdNVEFnTkRRZ01qZ2dOeklnTWpoak5UY2dNQ0F4TURBZ0xUUXpJREV3TUNBdE1UQXdjeTAwTXlBdE1UQXdJQzB4TURBZ0xURXdNR010TWpnZ01DQXRORGdnTVRnZ0xUY3lJREk0WXkwMklETWdMVEUySURNZ0xUSTRJRE4yTFRJek1XZ3RNak14WXpBZ01USWdNQ0F5TWlBeklESTRZekV3SURJMElESTRJRFEwSURJNElEY3lDbU13SURVM0lDMDBNeUF4TURBZ0xURXdNQ0F4TURCekxURXdNQ0F0TkRNZ0xURXdNQ0F0TVRBd1l6QWdMVEk0SURFNElDMDBPQ0F5T0NBdE56SmpNeUF0TmlBeklDMHhOaUF6SUMweU9HZ3RNak14ZGpZd01HZ3lNekZqTUNBeE1pQXdJREl5SUMweklESTRZeTB4TUNBeU5DQXRNamdnTkRRZ0xUSTRJRGN5ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaU1DSWdkVzVwWTI5a1pUMGlKaU40WlRCaU1Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMU1EQWlJQXBrUFNKTk1qUTNJRGN3TUdNNE5DQXdJREUwT0NBdE1qQWdNVGt4SUMwMU9YTTFPU0F0T1RNZ05Ua2dMVEUwTVdNd0lDMHhNVGNnTFRZNUlDMHhPREVnTFRFeE9TQXRNakkxY3kwNE1TQXROamNnTFRneElDMHhOVEIyTFRJMWFDMHhNREIyTWpWak1DQXhNVGNnTmpVZ01UZ3hJREV4TlNBeU1qVnpPRFVnTmpjZ09EVWdNVFV3WXpBZ01qVWdMVGdnTkRnZ0xUSTRJRFkyY3kwMU5pQXpOQ0F0TVRJeUlETTBjeTA1TnlBdE1UZ2dMVEV4TmlBdE16ZHpMVEkzSUMwME15QXRNekVnTFRZNWJDMHhNREFnTVRKak5TQXpPQ0F4T1NBNE9DQTFPU0F4TWpoek1UQXpJRFkySURFNE9DQTJObnBOTVRrM0lEQm9NVEF3Q25ZdE1UQXdhQzB4TURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppTVNJZ2RXNXBZMjlrWlQwaUppTjRaVEJpTVRzaUlBcGtQU0pOTkRVd0lEZ3dNR014TXpnZ01DQXlOVEFnTFRFeE1pQXlOVEFnTFRJMU1IWXROVEJqTlRnZ0xUSXhJREV3TUNBdE9EVWdNVEF3SUMweE5UQmpNQ0F0TmprZ0xUUTRJQzB4TWpjZ0xURXhNaUF0TVRRMFl5MHlNaUExTlNBdE56VWdPVFFnTFRFek9DQTVOR010TWpBZ01DQXRNemtnTFRVZ0xUVTJJQzB4TW1NdE1UY2dOalFnTFRjMUlERXhNaUF0TVRRMElERXhNbk10TVRJM0lDMDBPQ0F0TVRRMElDMHhNVEpqTFRFM0lEY2dMVE0ySURFeUlDMDFOaUF4TW1NdE16Y2dNQ0F0TnpFZ0xURXlJQzA1TnlBdE16UmpMVE16SURNMklDMDFNeUE0TWlBdE5UTWdNVE0wQ21Nd0lERXhNQ0E1TUNBeU1EQWdNakF3SURJd01HTXlNeUF4TVRRZ01USTVJREl3TUNBeU5UQWdNakF3ZWswek16UWdNekF3YURSb00yTXpJREFnTmlBeElEa2dNV015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEIyTFRGMkxUSXdNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCekxUVXdJREl5SUMwMU1DQTFNSFl5TURCMk1tTXdJREl3SURFMUlEUXlJRE0wSURRNGVrMHhNelFnTWpBd2FEUm9NMk16SURBZ05pQXhJRGtnTVdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCMkxURjJMVEV3TUdNd0lDMHlPQ0F0TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhZeE1EQjJNZ3BqTUNBeU1DQXhOU0EwTWlBek5DQTBPSHBOTlRNMElESXdNR2d6YURSak15QXdJRFlnTVNBNUlERmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTB4ZGkweE1EQmpNQ0F0TWpnZ0xUSXlJQzAxTUNBdE5UQWdMVFV3Y3kwMU1DQXlNaUF0TlRBZ05UQjJNVEF3ZGpKak1DQXlNQ0F4TlNBME1pQXpOQ0EwT0hvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVlqSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1lqSTdJaUFLWkQwaVRUWXdNQ0E0TURCc01qQXdJQzB4TlRCc0xUSXdNQ0F0TVRVd2RqRXdNR2d0TlRCc0xURTFNeUF0TVRreGJERTNOU0F0TWpBMmJEWWdMVE5vTWpKMk1UQXdiREl3TUNBdE1UVXdiQzB5TURBZ0xURTFNSFl4TURCb0xUSTFZeTB6TlNBd0lDMDFOaUF4TWlBdE56Z2dNemhzTFRFMk5pQXhPVEJzTFRFMU15QXRNVGt3WXkweU1pQXRNamNnTFRReklDMHpPQ0F0TnpnZ0xUTTRhQzB4TURCMk1UQXdhREV3TUd3eE5qWWdNakEyYkMweE5qTWdNVGt4YkMweklETm9MVEV3TUhZeE1EQm9NVEF3WXpNMElEQWdOVFlnTFRFeUlEYzRJQzB6T0d3eE5UTWdMVEUzT0d3eE5ERWdNVGM0Q21NeU1pQXlOeUEwTXlBek9DQTNPQ0F6T0dnMU1IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1JeklpQjFibWxqYjJSbFBTSW1JM2hsTUdJek95SWdDbVE5SWswME1EQWdPREF3WXpFeE1DQXdJREl3T1NBdE5EY2dNamd4SUMweE1UbHNNVEU1SURFeE9YWXRNekF3YUMwek1EQnNNVEE1SURFd09XTXROVFFnTlRVZ0xURXlOaUE1TVNBdE1qQTVJRGt4WXkweE5qWWdNQ0F0TXpBd0lDMHhNelFnTFRNd01DQXRNekF3Y3pFek5DQXRNekF3SURNd01DQXRNekF3WXpneklEQWdNVFU0SURNMElESXhNaUE0T0d3M01pQXROekpqTFRjeUlDMDNNaUF0TVRjMElDMHhNVFlnTFRJNE5DQXRNVEUyWXkweU1qQWdNQ0F0TkRBd0lERTRNQ0F0TkRBd0lEUXdNSE14T0RBZ05EQXdJRFF3TUNBME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUkwSWlCMWJtbGpiMlJsUFNJbUkzaGxNR0kwT3lJZ0NtUTlJazAwTURBZ09EQXdhRFF3TUhZdE5EQXdiQzB4TmpZZ01UWTJiQzAwTURBZ0xUUXdNR3d4TmpZZ0xURTJObWd0TkRBd2RqUXdNR3d4TmpZZ0xURTJObXcwTURBZ05EQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppTlNJZ2RXNXBZMjlrWlQwaUppTjRaVEJpTlRzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTWpVd0lEZ3dNR3d5TlRBZ0xUTXdNR2d0TWpBd2RpMHlNREJvTWpBd2JDMHlOVEFnTFRNd01Hd3RNalV3SURNd01HZ3lNREIyTWpBd2FDMHlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1JMklpQjFibWxqYjJSbFBTSW1JM2hsTUdJMk95SWdDbVE5SWswek1EQWdOakF3ZGkweU1EQm9NakF3ZGpJd01Hd3pNREFnTFRJMU1Hd3RNekF3SUMweU5UQjJNakF3YUMweU1EQjJMVEl3TUd3dE16QXdJREkxTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVlqY2lJSFZ1YVdOdlpHVTlJaVlqZUdVd1lqYzdJaUFLWkQwaVRUQWdPREF3WXpRME1TQXdJRGd3TUNBdE16VTVJRGd3TUNBdE9EQXdhQzB5TURCak1DQXpNek1nTFRJMk55QTJNREFnTFRZd01DQTJNREIyTWpBd2VrMHdJRFV3TUdNeU56VWdNQ0ExTURBZ0xUSXlOU0ExTURBZ0xUVXdNR2d0TWpBd1l6QWdNVFkzSUMweE16TWdNekF3SUMwek1EQWdNekF3ZGpJd01IcE5NQ0F5TURCak1URXdJREFnTWpBd0lDMDVNQ0F5TURBZ0xUSXdNR2d0TWpBd2RqSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWWpnaUlIVnVhV052WkdVOUlpWWplR1V3WWpnN0lpQUtaRDBpVFRFd01DQTRNREJqTXpnMklEQWdOekF3SUMwek1UUWdOekF3SUMwM01EQm9MVEV3TUdNd0lETXpNaUF0TWpZNElEWXdNQ0F0TmpBd0lEWXdNSFl4TURCNlRURXdNQ0EyTURCak1qYzJJREFnTlRBd0lDMHlNalFnTlRBd0lDMDFNREJvTFRFd01HTXdJREl5TWlBdE1UYzRJRFF3TUNBdE5EQXdJRFF3TUhZeE1EQjZUVEV3TUNBME1EQmpNVFkxSURBZ016QXdJQzB4TXpVZ016QXdJQzB6TURCb0xURXdNR013SURFeE1TQXRPRGtnTWpBd0lDMHlNREFnTWpBd2RqRXdNSHBOTVRBd0lESXdNR00xTlNBd0lERXdNQ0F0TkRVZ01UQXdJQzB4TURCekxUUTFJQzB4TURBZ0xURXdNQ0F0TVRBd0NuTXRNVEF3SURRMUlDMHhNREFnTVRBd2N6UTFJREV3TUNBeE1EQWdNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaU9TSWdkVzVwWTI5a1pUMGlKaU40WlRCaU9Uc2lJQXBrUFNKTk16QXdJRGd3TUdnME1EQmpOVFVnTUNBeE1EQWdMVFExSURFd01DQXRNVEF3ZGkweU1EQm9MVFF3TUhZeE5UQmpNQ0F5T0NBdE1qSWdOVEFnTFRVd0lEVXdjeTAxTUNBdE1qSWdMVFV3SUMwMU1IWXRNalV3YURRd01IWXRNekF3WXpBZ0xUVTFJQzAwTlNBdE1UQXdJQzB4TURBZ0xURXdNR2d0TlRBd1l5MDFOU0F3SUMweE1EQWdORFVnTFRFd01DQXhNREIyTWpBd2FERXdNSFl0TVRVd1l6QWdMVEk0SURJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEIyTlRVd1l6QWdOVFVnTkRVZ01UQXdJREV3TUNBeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUpoSWlCMWJtbGpiMlJsUFNJbUkzaGxNR0poT3lJZ0NtUTlJazAzTlNBM01EQm9NakkxZGkweE1EQm9MVEl3TUhZdE5UQXdhRFF3TUhZeE1EQm9NVEF3ZGkweE1qVmpNQ0F0TkRFZ0xUTTBJQzAzTlNBdE56VWdMVGMxYUMwME5UQmpMVFF4SURBZ0xUYzFJRE0wSUMwM05TQTNOWFkxTlRCak1DQTBNU0F6TkNBM05TQTNOU0EzTlhwTk5qQXdJRGN3TUd3eU1EQWdMVEl3TUd3dE1qQXdJQzB5TURCMk1UQXdhQzB5TURCakxUazBJREFnTFRFM015QXROalVnTFRFNU5DQXRNVFV6WXpJeklERTVPU0F4T0RrZ016VXpJRE01TkNBek5UTjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaVlpSWdkVzVwWTI5a1pUMGlKaU40WlRCaVlqc2lJQXBrUFNKTk5UQXdJRGN3TUd3ek1EQWdMVEk0Tkd3dE16QXdJQzB6TVRaMk1qQXdhQzB4TURCakxUSXdNQ0F3SUMwek5EZ2dMVEV3TWlBdE5EQXdJQzB6TURCak1DQXlPVFVnTVRBd0lEVXdNQ0ExTURBZ05UQXdkakl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVltTWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1ltTTdJaUFLWkQwaVRUTTRNU0EzT1RGc01Ua2dPV3d4T1NBdE9XTXhNamNnTFRVeklESTFNeUF0TVRBNElETTRNU0F0TVRZd2RpMHpNV013SUMweE5qWWdMVFkzSUMwek1UTWdMVEUwTnlBdE5ERTVZeTAwTUNBdE5UTWdMVGd6SUMwNU55QXRNVEkxSUMweE1qaHpMVGd5SUMwMU15QXRNVEk0SUMwMU0zTXRPRFlnTWpJZ0xURXlPQ0ExTTNNdE9EVWdOelVnTFRFeU5TQXhNamhqTFRnd0lERXdOeUF0TVRRM0lESTFNeUF0TVRRM0lEUXhPWFl6TVdNeE1qZ2dOVElnTWpVMElERXdOeUF6T0RFZ01UWXdlazAwTURBZ01UQXdkalU1TVd3dE1qazBJQzB4TWpKak9DQXRNVEkySURVNElDMHlORE1nTVRJeUlDMHpNamdLWXpNMUlDMDBOaUEzTXlBdE9EWWdNVEEySUMweE1UQnpOaklnTFRNeElEWTJJQzB6TVhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVltUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1ltUTdJaUFLWkQwaVRUWXdNQ0E0TURCb01UQXdkaTA0TURCb0xURXdNSFk0TURCNlRUUXdNQ0EzTURCb01UQXdkaTAzTURCb0xURXdNSFkzTURCNlRUSXdNQ0ExTURCb01UQXdkaTAxTURCb0xURXdNSFkxTURCNlRUQWdNekF3YURFd01IWXRNekF3YUMweE1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaVpTSWdkVzVwWTI5a1pUMGlKaU40WlRCaVpUc2lJQXBrUFNKTk16QXdJRGd3TUdneE1EQjJMVEl3TUdneU1EQnNNVEF3SUMweE1EQnNMVEV3TUNBdE1UQXdhQzB5TURCMkxUUXdNR2d0TVRBd2RqVXdNR2d0TWpBd2JDMHhNREFnTVRBd2JERXdNQ0F4TURCb01qQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVltWWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1ltWTdJaUFLWkQwaVRUSXdNQ0E0TURCb01UQXdkaTAyTURCb01qQXdiQzB5TlRBZ0xUSXdNR3d0TWpVd0lESXdNR2d5TURCMk5qQXdlazAwTURBZ09EQXdhREl3TUhZdE1UQXdhQzB5TURCMk1UQXdlazAwTURBZ05qQXdhRE13TUhZdE1UQXdhQzB6TURCMk1UQXdlazAwTURBZ05EQXdhRFF3TUhZdE1UQXdhQzAwTURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0pqTUNJZ2RXNXBZMjlrWlQwaUppTjRaVEJqTURzaUlBcGtQU0pOTWpBd0lEZ3dNR2d4TURCMkxUWXdNR2d5TURCc0xUSTFNQ0F0TWpBd2JDMHlOVEFnTWpBd2FESXdNSFkyTURCNlRUUXdNQ0E0TURCb05EQXdkaTB4TURCb0xUUXdNSFl4TURCNlRUUXdNQ0EyTURCb016QXdkaTB4TURCb0xUTXdNSFl4TURCNlRUUXdNQ0EwTURCb01qQXdkaTB4TURCb0xUSXdNSFl4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltTXhJaUIxYm1samIyUmxQU0ltSTNobE1HTXhPeUlnQ21ROUlrMDNOU0EzTURCb05qVXdZelF4SURBZ056VWdMVE0wSURjMUlDMDNOWFl0TlRVd1l6QWdMVFF4SUMwek5DQXROelVnTFRjMUlDMDNOV2d0TmpVd1l5MDBNU0F3SUMwM05TQXpOQ0F0TnpVZ056VjJOVFV3WXpBZ05ERWdNelFnTnpVZ056VWdOelY2VFRFd01DQTJNREIyTFRFd01HZ3hNREIyTVRBd2FDMHhNREI2VFRNd01DQTJNREIyTFRFd01HZzBNREIyTVRBd2FDMDBNREI2VFRFd01DQTBNREIyTFRFd01HZ3hNREIyTVRBd2FDMHhNREI2VFRNd01DQTBNREIyTFRFd01HZzBNREIyTVRBd2FDMDBNREI2VFRFd01DQXlNREIyTFRFd01HZ3hNREIyTVRBd2FDMHhNREI2VFRNd01DQXlNREFLZGkweE1EQm9OREF3ZGpFd01HZ3ROREF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKak1pSWdkVzVwWTI5a1pUMGlKaU40WlRCak1qc2lJQXBrUFNKTk5EQXdJRGd3TUd3eE1EQWdMVE13TUdnek1EQnNMVEkxTUNBdE1qQXdiREV3TUNBdE16QXdiQzB5TlRBZ01qQXdiQzB5TlRBZ0xUSXdNR3d4TURBZ016QXdiQzB5TlRBZ01qQXdhRE13TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVl6TWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1l6TTdJaUFLWkQwaVRUUXdNQ0E0TURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdjekl5SURVd0lEVXdJRFV3ZWsweE5UQWdOekF3WXpJNElEQWdOVEFnTFRJeUlEVXdJQzAxTUhNdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1ITXlNaUExTUNBMU1DQTFNSHBOTmpVd0lEY3dNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJ6TFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCek1qSWdOVEFnTlRBZ05UQjZUVFF3TUNBMk1EQmpNVEV3SURBZ01qQXdJQzA1TUNBeU1EQWdMVEl3TUFwekxUa3dJQzB5TURBZ0xUSXdNQ0F0TWpBd2N5MHlNREFnT1RBZ0xUSXdNQ0F5TURCek9UQWdNakF3SURJd01DQXlNREI2VFRVd0lEUTFNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJ6TFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCek1qSWdOVEFnTlRBZ05UQjZUVGMxTUNBME5UQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdjeTB5TWlBdE5UQWdMVFV3SUMwMU1ITXROVEFnTWpJZ0xUVXdJRFV3Y3pJeUlEVXdJRFV3SURVd2VrMHhOVEFnTWpBd1l6STRJREFnTlRBZ0xUSXlJRFV3SUMwMU1ITXRNaklnTFRVd0lDMDFNQ0F0TlRCekxUVXdJREl5SUMwMU1DQTFNQXB6TWpJZ05UQWdOVEFnTlRCNlRUWTFNQ0F5TURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdjekl5SURVd0lEVXdJRFV3ZWswME1EQWdNVEF3WXpJNElEQWdOVEFnTFRJeUlEVXdJQzAxTUhNdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1ITXlNaUExTUNBMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWXpRaUlIVnVhV052WkdVOUlpWWplR1V3WXpRN0lpQUtaRDBpVFRNMElEZ3dNR2cyTXpKak1UZ2dNQ0F6TkNBdE1UWWdNelFnTFRNMGRpMDNNekpqTUNBdE1UZ2dMVEUySUMwek5DQXRNelFnTFRNMGFDMDJNekpqTFRFNElEQWdMVE0wSURFMklDMHpOQ0F6TkhZM016SmpNQ0F4T0NBeE5pQXpOQ0F6TkNBek5IcE5NVEF3SURjd01IWXROVEF3YURVd01IWTFNREJvTFRVd01IcE5NelV3SURFMU1HTXRNemdnTUNBdE5qTWdMVFF5SUMwME5DQXROelZ6TmprZ0xUTXpJRGc0SURCekxUWWdOelVnTFRRMElEYzFlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0pqTlNJZ2RXNXBZMjlrWlQwaUppTjRaVEJqTlRzaUlBcGtQU0pOTUNBNE1EQm9NekF3YkRVd01DQXROVEF3YkMwek1EQWdMVE13TUd3dE5UQXdJRFV3TUhZek1EQjZUVEl3TUNBM01EQmpMVFUxSURBZ0xURXdNQ0F0TkRVZ0xURXdNQ0F0TVRBd2N6UTFJQzB4TURBZ01UQXdJQzB4TURCek1UQXdJRFExSURFd01DQXhNREJ6TFRRMUlERXdNQ0F0TVRBd0lERXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWXpZaUlIVnVhV052WkdVOUlpWWplR1V3WXpZN0lpQUtaRDBpVFRBZ05qQXdhREl3TUd3ek1EQWdMVE13TUd3dE1qQXdJQzB5TURCc0xUTXdNQ0F6TURCMk1qQXdlazB6TkRBZ05qQXdhREUyTUd3ek1EQWdMVE13TUd3dE1qQXdJQzB5TURCc0xUYzRJRGM0YkRFeE9TQXhNako2VFRFMU1DQTFNREJqTFRJNElEQWdMVFV3SUMweU1pQXROVEFnTFRVd2N6SXlJQzAxTUNBMU1DQXROVEJ6TlRBZ01qSWdOVEFnTlRCekxUSXlJRFV3SUMwMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWXpjaUlIVnVhV052WkdVOUlpWWplR1V3WXpjN0lpQUtaRDBpVFRRd01DQTRNREJqTWpJd0lEQWdOREF3SUMweE9EQWdOREF3SUMwME1EQnpMVEU0TUNBdE5EQXdJQzAwTURBZ0xUUXdNSE10TkRBd0lERTRNQ0F0TkRBd0lEUXdNSE14T0RBZ05EQXdJRFF3TUNBME1EQjZUVFF3TUNBM01EQmpMVEUyTmlBd0lDMHpNREFnTFRFek5DQXRNekF3SUMwek1EQnpNVE0wSUMwek1EQWdNekF3SUMwek1EQnpNekF3SURFek5DQXpNREFnTXpBd2N5MHhNelFnTXpBd0lDMHpNREFnTXpBd2VrMDBNREFnTmpBd1l6RXhNQ0F3SURJd01DQXRPVEFnTWpBd0lDMHlNREJ6TFRrd0lDMHlNREFnTFRJd01DQXRNakF3Y3kweU1EQWdPVEFnTFRJd01DQXlNREFLY3prd0lESXdNQ0F5TURBZ01qQXdlazAwTURBZ05UQXdZeTAxTmlBd0lDMHhNREFnTFRRMElDMHhNREFnTFRFd01ITTBOQ0F0TVRBd0lERXdNQ0F0TVRBd2N6RXdNQ0EwTkNBeE1EQWdNVEF3Y3kwME5DQXhNREFnTFRFd01DQXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1NNElpQjFibWxqYjJSbFBTSW1JM2hsTUdNNE95SWdDbVE5SWswd0lEY3dNR2cxTlRsc0xURXdNQ0F0TVRBd2FDMHpOVGwyTFRVd01HZzFNREIyTVRVNWJERXdNQ0F4TURCMkxUTTFPV2d0TnpBd2RqY3dNSHBOTnpBd0lEY3dNR3d4TURBZ0xURXdNR3d0TkRBd0lDMDBNREJzTFRJd01DQXlNREJzTVRBd0lERXdNR3d4TURBZ0xURXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWXpraUlIVnVhV052WkdVOUlpWWplR1V3WXprN0lpQUtaRDBpVFRrZ09EQXdhRGM0TW1NMklEQWdPU0F0TXlBNUlDMDVkaTAzT0RKak1DQXROaUF0TXlBdE9TQXRPU0F0T1dndE56Z3lZeTAySURBZ0xUa2dNeUF0T1NBNWRqYzRNbU13SURZZ015QTVJRGtnT1hwTk1UVXdJRGN5TW13dE56SWdMVGN5YkRFd01DQXRNVEF3YkMweE1EQWdMVEV3TUd3M01pQXROekpzTVRjeUlERTNNbnBOTkRBd0lEVXdNSFl0TVRBd2FETXdNSFl4TURCb0xUTXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWTJFaUlIVnVhV052WkdVOUlpWWplR1V3WTJFN0lpQUtaRDBpVFRBZ09EQXdhRGd3TUhZdE1qQXdhQzAxTUdNd0lEVTFJQzAwTlNBeE1EQWdMVEV3TUNBeE1EQm9MVEUxTUhZdE5UVXdZekFnTFRJNElESXlJQzAxTUNBMU1DQXROVEJvTlRCMkxURXdNR2d0TkRBd2RqRXdNR2cxTUdNeU9DQXdJRFV3SURJeUlEVXdJRFV3ZGpVMU1HZ3RNVFV3WXkwMU5TQXdJQzB4TURBZ0xUUTFJQzB4TURBZ0xURXdNR2d0TlRCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0pqWWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJqWWpzaUlBcGtQU0pOTUNBM01EQm9NVEF3ZGkwME1EQm9MVEV3TUhZME1EQjZUVEl3TUNBM01EQm9NelV3WXpJeElEQWdNemtnTFRFeklEUTNJQzB6TVdNd0lEQWdNVEF6SUMweU9URWdNVEF6SUMwek1UbHpMVEl5SUMwMU1DQXROVEFnTFRVd2FDMHhOVEJqTFRJNElEQWdMVFV3SUMweU5TQXROVEFnTFRVd2N6TTVJQzB4TlRnZ05EY2dMVEU0TkhNdE5TQXROVFVnTFRNeElDMDJNM010TlRJZ05TQXROallnTXpGekxURXdPU0F5TVRrZ0xURXlPQ0F5TXpoekxUUTBJREk0SUMwM01pQXlPSFkwTURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltTmpJaUIxYm1samIyUmxQU0ltSTNobE1HTmpPeUlnQ21ROUlrMDBNREFnTmpZMll6RXdJREU1SURJNElETXlJRFEzSURNMGJERTVJQzB6WXpJMklDMDRJRE01SUMwek55QXpNU0F0TmpOekxUUTNJQzB4TlRrZ0xUUTNJQzB4T0RSek1qSWdMVFV3SURVd0lDMDFNR2d4TlRCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHhNRE1nTFRNeE9TQXRNVEF6SUMwek1UbGpMVGdnTFRFNElDMHlOaUF0TXpFZ0xUUTNJQzB6TVdndE16VXdkalF3TUdNeU9DQXdJRFV6SURrZ056SWdNamh6TVRFMElESXhNaUF4TWpnZ01qTTRlazB3SURRd01HZ3hNREIyTFRRd01HZ3RNVEF3ZGpRd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZMlFpSUhWdWFXTnZaR1U5SWlZamVHVXdZMlE3SWlBS1pEMGlUVEl3TUNBM01EQm9NekF3ZGkweE1EQm9MVEV3TUhZdE5tTXlOU0F0TkNBMU1DQXRPQ0EzTWlBdE1UWnNMVE0wSUMwNU5HTXRNamdnTVRFZ0xUVTRJREUySUMwNE9DQXhObU10TVRNNUlEQWdMVEkxTUNBdE1URXhJQzB5TlRBZ0xUSTFNSE14TVRFZ0xUSTFNQ0F5TlRBZ0xUSTFNSE15TlRBZ01URXhJREkxTUNBeU5UQmpNQ0F6TVNBdE5TQTJNQ0F0TVRZZ09EaHNPVEVnTXpkak1UUWdMVE00SURJMUlDMDRNU0F5TlNBdE1USTFZekFnTFRFNU15QXRNVFUzSUMwek5UQWdMVE0xTUNBdE16VXdjeTB6TlRBZ01UVTNJQzB6TlRBZ016VXdZekFnTVRjMklERXpNQ0F6TWpNZ016QXdJRE0wTjNZekNtZ3RNVEF3ZGpFd01IcE5OekF3SURVNE5HTXdJREFnTFRJNU5pQXRNelE0SUMwek1UWWdMVE0yT0hNdE5EZ2dMVEl3SUMwMk9DQXdjeTB5TUNBME9DQXdJRFk0Y3pNNE5DQXpNREFnTXpnMElETXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWTJVaUlIVnVhV052WkdVOUlpWWplR1V3WTJVN0lpQUtaRDBpVFRZd01DQTNNREJzTWpBd0lDMHhOVEJzTFRJd01DQXRNVFV3ZGpFd01HZ3ROakF3ZGpFd01HZzJNREIyTVRBd2VrMHlNREFnTXpBd2RpMHhNREJvTmpBd2RpMHhNREJvTFRZd01IWXRNVEF3YkMweU1EQWdNVFV3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKalppSWdkVzVwWTI5a1pUMGlKaU40WlRCalpqc2lJQXBrUFNKTk16QXdJRGd3TUdneE1EQmpOVFVnTUNBeE1EQWdMVFExSURFd01DQXRNVEF3YURFd01HTTFOU0F3SURFd01DQXRORFVnTVRBd0lDMHhNREJvTFRjd01HTXdJRFUxSURRMUlERXdNQ0F4TURBZ01UQXdhREV3TUdNd0lEVTFJRFExSURFd01DQXhNREFnTVRBd2VrMHhNREFnTlRBd2FERXdNSFl0TXpVd1l6QWdMVEk0SURJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEIyTXpVd2FERXdNSFl0TXpVd1l6QWdMVEk0SURJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEIyTXpVd2FERXdNSFl0TkRneFl6QWdMVEV4SUMwNElDMHhPU0F0TVRrZ0xURTVhQzAwTmpJS1l5MHhNU0F3SUMweE9TQTRJQzB4T1NBeE9YWTBPREY2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1Rd0lpQjFibWxqYjJSbFBTSW1JM2hsTUdRd095SWdDbVE5SWsweE1EQWdPREF3YURJd01IWXROREF3WXpBZ0xUVTFJRFExSUMweE1EQWdNVEF3SUMweE1EQnpNVEF3SURRMUlERXdNQ0F4TURCMk5EQXdhREV3TUhZdE5EQXdZekFnTFRFeE1DQXRPVEFnTFRJd01DQXRNakF3SUMweU1EQm9MVFV3WXkweE16Z2dNQ0F0TWpVd0lEa3dJQzB5TlRBZ01qQXdkalF3TUhwTk1DQXhNREJvTnpBd2RpMHhNREJvTFRjd01IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1ReElpQjFibWxqYjJSbFBTSW1JM2hsTUdReE95SWdDbVE5SWswNUlEY3dNR2d4T0RKak5pQXdJRGtnTFRNZ09TQXRPWFl0TkRneVl6QWdMVFlnTFRNZ0xUa2dMVGtnTFRsb0xURTRNbU10TmlBd0lDMDVJRE1nTFRrZ09YWTBPREpqTUNBMklETWdPU0E1SURsNlRUWXdPU0EzTURCb01UZ3lZellnTUNBNUlDMHpJRGtnTFRsMkxUUTRNbU13SUMwMklDMHpJQzA1SUMwNUlDMDVhQzB4T0RKakxUWWdNQ0F0T1NBeklDMDVJRGwyTkRneVl6QWdOaUF6SURrZ09TQTVlazB6TURrZ05UQXdhREU0TW1NMklEQWdPU0F0TXlBNUlDMDVkaTB5T0RKak1DQXROaUF0TXlBdE9TQXRPU0F0T1dndE1UZ3lZeTAySURBZ0xUa2dNeUF0T1NBNWRqSTRNZ3BqTUNBMklETWdPU0E1SURsNlRUQWdNVEF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKa01pSWdkVzVwWTI5a1pUMGlKaU40WlRCa01qc2lJQXBrUFNKTk1UQWdOekF3YURFNE1XTTJJREFnT1NBdE15QTVJQzA1ZGkweE9URm9MVEl3TUhZeE9URmpNQ0EySURRZ09TQXhNQ0E1ZWswMk1UQWdOekF3YURFNE1XTTJJREFnT1NBdE15QTVJQzA1ZGkweE9URm9MVEl3TUhZeE9URmpNQ0EySURVZ09TQXhNQ0E1ZWswek1UQWdOakF3YURFNE1XTTJJREFnT1NBdE15QTVJQzA1ZGkwNU1XZ3RNakF3ZGpreFl6QWdOaUEwSURrZ01UQWdPWHBOTUNBME1EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZUVEFnTWpBd2FESXdNSFl0TVRreFl6QWdMVFlnTFRNZ0xUa2dMVGtnTFRsb0xURTRNbU10TmlBd0lDMDVJRE1nTFRrZ09YWXhPVEY2VFRNd01DQXlNREFLYURJd01IWXRPVEZqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0TVRneFl5MDJJREFnTFRFd0lETWdMVEV3SURsMk9URjZUVFl3TUNBeU1EQm9NakF3ZGkweE9URmpNQ0F0TmlBdE15QXRPU0F0T1NBdE9XZ3RNVGd4WXkwMklEQWdMVEV3SURNZ0xURXdJRGwyTVRreGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmtNeUlnZFc1cFkyOWtaVDBpSmlONFpUQmtNenNpSUFwa1BTSk5NQ0EzTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUa2dOVEF3YURFNE1tTTJJREFnT1NBdE15QTVJQzA1ZGkwME9ESmpNQ0F0TmlBdE15QXRPU0F0T1NBdE9XZ3RNVGd5WXkwMklEQWdMVGtnTXlBdE9TQTVkalE0TW1Nd0lEWWdNeUE1SURrZ09YcE5NekE1SURVd01HZ3hPREpqTmlBd0lEa2dMVE1nT1NBdE9YWXRNamd5WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRFNE1tTXROaUF3SUMwNUlETWdMVGtnT1hZeU9ESmpNQ0EySURNZ09TQTVJRGw2VFRZd09TQTFNREJvTVRneVl6WWdNQ0E1SUMweklEa2dMVGwyTFRRNE1tTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMHhPRElLWXkwMklEQWdMVGtnTXlBdE9TQTVkalE0TW1Nd0lEWWdNeUE1SURrZ09Yb2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlaRFFpSUhWdWFXTnZaR1U5SWlZamVHVXdaRFE3SWlBS1pEMGlUVFV3SURZd01HZzFNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3ZGkweE5UQnNNVEF3SURFd01HZ3hNREIyTFRNd01HZ3RNVEF3YkMweE1EQWdNVEF3ZGkweE5UQmpNQ0F0TWpnZ0xUSXlJQzAxTUNBdE5UQWdMVFV3YUMwMU1EQmpMVEk0SURBZ0xUVXdJREl5SUMwMU1DQTFNSFkwTURCak1DQXlPQ0F5TWlBMU1DQTFNQ0ExTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVpEVWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1pEVTdJaUFLWkQwaVRUTXpOQ0E0TURCb05qWjJMVGd3TUdndE5qWnNMVEV6TkNBeU1EQm9MVEl3TUhZME1EQm9NakF3ZWswMU1EQWdOakF3ZGpFd01HTXlOaUF3SURVeUlDMDBJRGMxSUMweE1HTXhNekFnTFRNeklESXlOU0F0TVRVd0lESXlOU0F0TWprd2N5MDVOU0F0TWpVNElDMHlNalVnTFRJNU1XZ3RNMk10TWpNZ0xUWWdMVFEzSUMwNUlDMDNNaUF0T1hZeE1EQmpNVGNnTUNBek5DQXlJRFV3SURaak9EWWdNaklnTVRVd0lERXdNQ0F4TlRBZ01UazBjeTAyTkNBeE56SWdMVEUxTUNBeE9UUmpMVEUySURRZ0xUTXpJRFlnTFRVd0lEWjZUVFV3TUNBMU1EQnNNalVnTFRNS1l6UTBJQzB4TVNBM05TQXROVEVnTnpVZ0xUazNjeTB6TWlBdE9EWWdMVGMxSUMwNU4yd3RNalVnTFROMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0prTmlJZ2RXNXBZMjlrWlQwaUppTjRaVEJrTmpzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTXpNMElEZ3dNR2cyTm5ZdE9EQXdhQzAyTm13dE1UTTBJREl3TUdndE1qQXdkalF3TUdneU1EQjZUVFV3TUNBMU1EQnNNalVnTFROak5EUWdMVEV4SURjMUlDMDFNU0EzTlNBdE9UZHpMVE15SUMwNE5pQXROelVnTFRrM2JDMHlOU0F0TTNZeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVEzSWlCMWJtbGpiMlJsUFNJbUkzaGxNR1EzT3lJZ2FHOXlhWG90WVdSMkxYZzlJalF3TUNJZ0NtUTlJazB6TXpRZ09EQXdhRFkyZGkwNE1EQm9MVFkyYkMweE16UWdNakF3YUMweU1EQjJOREF3YURJd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlaRGdpSUhWdWFXTnZaR1U5SWlZamVHVXdaRGc3SWlBS1pEMGlUVE13T1NBNE1EQm9PREpqTmlBd0lERXdJQzAwSURFeUlDMDViREk1TkNBdE5qZ3liRE1nTFRFNWRpMDRNV013SUMwMklDMHpJQzA1SUMwNUlDMDVhQzAyT0RKakxUWWdNQ0F0T1NBeklDMDVJRGwyT0RGc015QXhPV3d5T1RRZ05qZ3lZeklnTlNBMklEa2dNVElnT1hwTk16QXdJRFV3TUhZdE1qQXdhREV3TUhZeU1EQm9MVEV3TUhwTk16QXdJREl3TUhZdE1UQXdhREV3TUhZeE1EQm9MVEV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVpEa2lJSFZ1YVdOdlpHVTlJaVlqZUdVd1pEazdJaUFLWkQwaVRUTTNOU0E0TURCak1UTTRJREFnTWpZNUlDMHpPU0F6TnpnZ0xURXdPV3d0TlRNZ0xUZ3lZeTA1TXlBMk1DQXRNakExSURreElDMHpNalVnT1RGakxURXhPU0F3SUMweU1qa2dMVE15SUMwek1qSWdMVGt4YkMwMU15QTRNbU14TURrZ056QWdNak0zSURFd09TQXpOelVnTVRBNWVrMHpOelVnTlRBd1l6YzRJREFnTVRVMElDMHlNeUF5TVRZZ0xUWXliQzAxTXlBdE9EVmpMVFEySURNd0lDMHhNRFFnTkRjZ0xURTJNeUEwTjJNdE5qQWdNQ0F0TVRFeUlDMHhOeUF0TVRVNUlDMDBOMnd0TlRRZ09EVmpOaklnTkRBZ01UTTBJRFl5SURJeE15QTJNbnBOTXpjMUlESXdNQXBqTlRVZ01DQXhNREFnTFRRMUlERXdNQ0F0TVRBd2N5MDBOU0F0TVRBd0lDMHhNREFnTFRFd01ITXRNVEF3SURRMUlDMHhNREFnTVRBd2N6UTFJREV3TUNBeE1EQWdNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKa1lTSWdkVzVwWTI5a1pUMGlKaU40WlRCa1lUc2lJR2h2Y21sNkxXRmtkaTE0UFNJNU1EQWlJQXBrUFNKTk5UVXhJRGd3TUdNeE5pQXdJRE15SURBZ05EY2dMVE5zTFRrM0lDMDVOM1l0TWpBd2FESXdNR3c1TnlBNU4yTXpJQzB4TlNBeklDMHpNU0F6SUMwME4yTXdJQzB4TXpnZ0xURXhNaUF0TWpVd0lDMHlOVEFnTFRJMU1HTXRNeklnTUNBdE5qSWdPQ0F0T1RBZ01UbHNMVEk0T0NBdE1qa3hZeTB5TUNBdE1qQWdMVFEySUMweU9DQXROeklnTFRJNGN5MDFNaUE0SUMwM01pQXlPR010TXprZ016a2dMVE01SURFd05TQXdJREUwTkd3eU9URWdNamczWXkweE1TQXlPQ0F0TVRrZ05Ua2dMVEU1SURreFl6QWdNVE00SURFeE1pQXlOVEFnTWpVd0lESTFNSHBOTVRBeElERTFNQXBqTFRJNElEQWdMVFV3SUMweU1pQXROVEFnTFRVd2N6SXlJQzAxTUNBMU1DQXROVEJ6TlRBZ01qSWdOVEFnTlRCekxUSXlJRFV3SUMwMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWkdJaUlIVnVhV052WkdVOUlpWWplR1V3WkdJN0lpQUtaRDBpVFRFME1TQTNNREJqT0RRZ0xUZzBJREUyT1NBdE1UWTNJREkxTXlBdE1qVXdZemd5SURneklERTJOeUF4TmpVZ01qUTNJREkxTUd3eE5ETWdMVEUwTVd3dE1qVXpJQzB5TlROak9EUWdMVGd5SURFMk55QXRNVFkySURJMU15QXRNalEzYkMweE5ETWdMVEUwTTJNdE9ERWdPRFlnTFRFMk5TQXhOamtnTFRJME55QXlOVE5zTFRJMU15QXRNalV6YkMweE5ERWdNVFF6WXpnMUlEZ3dJREUyTnlBeE5qUWdNalV3SURJME4yTXRPRE1nT0RRZ0xURTJOaUF4TmprZ0xUSTFNQ0F5TlRONklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltUmpJaUIxYm1samIyUmxQU0ltSTNobE1HUmpPeUlnQ21ROUlrMHdJRGd3TUdneE1EQnNNak14SUMwek1EQm9NemhzTWpNeElETXdNR2d4TURCc0xUSXlOU0F0TXpBd2FESXlOWFl0TVRBd2FDMHpNREIyTFRFd01HZ3pNREIyTFRFd01HZ3RNekF3ZGkweU1EQm9MVEV3TUhZeU1EQm9MVE13TUhZeE1EQm9NekF3ZGpFd01HZ3RNekF3ZGpFd01HZ3lNalY2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1Sa0lpQjFibWxqYjJSbFBTSW1JM2hsTUdSa095SWdhRzl5YVhvdFlXUjJMWGc5SWprd01DSWdDbVE5SWswek5UQWdPREF3WXpFNU15QXdJRE0xTUNBdE1UVTNJRE0xTUNBdE16VXdZekFnTFRZeElDMHhOeUF0TVRFNUlDMDBOQ0F0TVRZNVl6UWdMVElnTVRBZ0xUWWdNVE1nTFRsc01UQXpJQzB4TURCak1UWWdMVEUySURNd0lDMDBPU0F6TUNBdE56SmpNQ0F0TlRZZ0xUUTJJQzB4TURJZ0xURXdNaUF0TVRBeVl5MHlNeUF3SUMwMU5pQXhOQ0F0TnpJZ016QnNMVEV3TUNBeE1ETmpMVE1nTXlBdE55QTVJQzA1SURFell5MDFNQ0F0TWpnZ0xURXdPQ0F0TkRRZ0xURTJPU0F0TkRSakxURTVNeUF3SUMwek5UQWdNVFUzSUMwek5UQWdNelV3Y3pFMU55QXpOVEFnTXpVd0lETTFNSHBOTXpVd0lEY3dNQXBqTFRFek9TQXdJQzB5TlRBZ0xURXhNU0F0TWpVd0lDMHlOVEJ6TVRFeElDMHlOVEFnTWpVd0lDMHlOVEJqTmpJZ01DQXhNVGtnTWpNZ01UWXpJRFl3WXpjZ01URWdNVGtnTWpVZ016RWdNekZzTXlBell6TTBJRFF6SURVeklEazNJRFV6SURFMU5tTXdJREV6T1NBdE1URXhJREkxTUNBdE1qVXdJREkxTUhwTk16QXdJRFl3TUdneE1EQjJMVEV3TUdneE1EQjJMVEV3TUdndE1UQXdkaTB4TURCb0xURXdNSFl4TURCb0xURXdNSFl4TURCb01UQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVpHVWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1pHVTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU9UQXdJaUFLWkQwaVRUTTFNQ0E0TURCak1Ua3pJREFnTXpVd0lDMHhOVGNnTXpVd0lDMHpOVEJqTUNBdE5qRWdMVEUzSUMweE1Ua2dMVFEwSUMweE5qbGpOQ0F0TWlBeE1DQXROaUF4TXlBdE9Xd3hNRE1nTFRFd01HTXhOaUF0TVRZZ016QWdMVFE1SURNd0lDMDNNbU13SUMwMU5pQXRORFlnTFRFd01pQXRNVEF5SUMweE1ESmpMVEl6SURBZ0xUVTJJREUwSUMwM01pQXpNR3d0TVRBd0lERXdNMk10TXlBeklDMDNJRGtnTFRrZ01UTmpMVFV3SUMweU9DQXRNVEE0SUMwME5DQXRNVFk1SUMwME5HTXRNVGt6SURBZ0xUTTFNQ0F4TlRjZ0xUTTFNQ0F6TlRCek1UVTNJRE0xTUNBek5UQWdNelV3ZWswek5UQWdOekF3Q21NdE1UTTVJREFnTFRJMU1DQXRNVEV4SUMweU5UQWdMVEkxTUhNeE1URWdMVEkxTUNBeU5UQWdMVEkxTUdNMk1pQXdJREV4T1NBeU15QXhOak1nTmpCak55QXhNU0F4T1NBeU5TQXpNU0F6TVd3eklETmpNelFnTkRNZ05UTWdPVGNnTlRNZ01UVTJZekFnTVRNNUlDMHhNVEVnTWpVd0lDMHlOVEFnTWpVd2VrMHlNREFnTlRBd2FETXdNSFl0TVRBd2FDMHpNREIyTVRBd2VpSWdMejRLSUNBOEwyWnZiblErQ2p3dlpHVm1jejQ4TDNOMlp6NEtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLnN2Z1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuc3ZnXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC10dGY7YmFzZTY0LEFBRUFBQUFQQUlBQUF3QndSa1pVVFd2d0FhUUFBQUQ4QUFBQUhFOVRMekkwQmxGaUFBQUJHQUFBQUdCamJXRndBQS9raVFBQUFYZ0FBQUZDWTNaMElBQUFBQUFBQUdHSUFBQUFDbVp3WjIyK2IrWTVBQUJobEFBQUMyeG5ZWE53QUFBQUVBQUFZWUFBQUFBSVoyeDVaa2psN3E0QUFBSzhBQUJTR0dobFlXUUI4N3RGQUFCVTFBQUFBRFpvYUdWaEJvd0VBUUFBVlF3QUFBQWthRzEwZUpxZUFCb0FBRlV3QUFBRGhteHZZMkdqdW85RUFBQll1QUFBQWNadFlYaHdBWndMMWdBQVdvQUFBQUFnYm1GdFpZNzJFTVVBQUZxZ0FBQUNmSEJ2YzNUdEVEUCtBQUJkSEFBQUJHTndjbVZ3M1dzRGhRQUFiUUFBQUFCN0FBQUFBUUFBQUFETVBhTFBBQUFBQU0vWkwyb0FBQUFBejlrdmFnQUVBdjRCa0FBRkFBQUNDQUl3QUFBQWNBSUlBakFBQUFHQUFDY0F6d0FBQWdBRkF3QUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUJRWmtWa0FNRGdBT0RlQXlBQUFBQklBeUFBWlFBQUFBRUFBQUFBQUFBQUFBQUFBQ0FBQVFBQUFBTUFBQUFEQUFBQUhBQUJBQUFBQUFBOEFBTUFBUUFBQUJ3QUJBQWdBQUFBQkFBRUFBRUFBT0RlLy84QUFPQUEvLzhnQXdBQkFBQUFBQUFBQVFZQUFBRUFBQUFBQUFBQUFRSUFBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FCb0FBQURzQWhVQUF3QUhBQWkxQmdRQkFBSXRLek1STXhFbk14RWpHdEs0bnA0Q0ZmM3JHZ0hoQUFJQUFBQUFBeUFDdkFBSEFBNEFDTFVLQ0FJQUFpMHJBU0VSSVRVaEVTRWZBUWMxSVRVaEFTd0I5UDRNQVpEK2NHVEl5UDV3QVpBQ3ZQMUVaQUgwWkphV1pHUUFBZ0FBQUFBRElBSzhBQWNBRGdBSXRRMElBZ0FDTFNzQklSRWhOU0VSSVFjVklSVWhGU2NCTEFIMC9nd0JrUDV3WkFHUS9uRElBcno5UkdRQjlHUmtaR1NXQUFBQkFBQUFaQU1nQXJ3QUR3QUdzd1lBQVMwckVpQVdIUUV6Qnljek5UUW1JZ1lWTk0wQklzMWt5TWhra3RDU0Fyek5rVExJeURKb2twSm9rUUFCQUFBQVpBTWdBcndBRHdBR3N3c0FBUzByQUNBV0ZUUW1JZ1lkQVRNSEp6TTFOQUV4QVNMTmt0Q1NaTWpJWkFLOHpaRm9rcEpvTXNqSU1wRUFBQUFBQkFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRFVBS0Rnd0tDQVlFQWdBRUxTc1JJUlVoRnlFVklRY2hGU0VYSVJVaEF5RDg0R1FDV1Ayb1pBTWcvT0JrQWxqOXFBSzhaR1JrWkdSa1pBQUFBQUFFQUFBQUFBTWdBcndBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt4RWhGU0VWSVJVaEZTRVZJUlVoRlNFRElQemdBbGo5cUFNZy9PQUNXUDJvQXJ4a1pHUmtaR1JrQUFBQUJBQUFBQUFESUFLOEFBTUFCd0FMQUE4QURVQUtEZ3dLQ0FZRUFnQUVMU3NSSVJVaEZ5RVZJUWNoRlNFWElSVWhBeUQ4NE1nQ1dQMm95QU1nL09ESUFsajlxQUs4WkdSa1pHUmtaQUFBQUFBRkFBRC9ud01nQXJ3QUJRQUxBQkVBRmdBYkFBOUFEQnNYRXhJUURBZ0dBd0FGTFNzQk1oY0hKVFlIRndVbU5UUWxGaFVVQnlNbEV5NEJKd1VoRGdFSEFaQnNZa3Yrdmx5d3YvN0tCZ0t3Y0JEYS9xSndYcGNxQVVzQmRER2pZZ0s4TytIcU1uQ0szaVFrcUd0MW5pUkFOZjZsRVhkV0hGTnBDUUFBQVFBQUFBQUI5QU1nQUFZQUJyTUVBQUV0S3hNekVUTUxBVFBJWk1qMy9jZ0RJUDRNL3RRQkxBQUFBQUFDQUFBQUFBTWdBeUFBQndBT0FBaTFDd2dFQUFJdEt4SWdGaEFHSUNZUUpSRWpDUUVqRWVvQlRPcnEvclRxQVN6SUFTd0JMTWdESU9yK3RPcnFBVXlHL3RUKzFBRXNBU3dBQUFBQUFnQUFBQUFESUFNZ0FBY0FEZ0FJdFFvSUJBQUNMU3NTSUJZUUJpQW1FQ1VKQVRVaE5TSHFBVXpxNnY2MDZnR1EvdFFCTEFFcy90UURJT3IrdE9ycUFVeUcvdFQrMU1qSUFBQUFBQUlBQUFBQUF5QURJQUFIQUE0QUNMVU5DQVFBQWkwckVpQVdFQVlnSmhBbEZTRVZJUlVCNmdGTTZ1cit0T29Ca1A3VUFTd0JMQU1nNnY2MDZ1b0JUSWJJeU1nQkxBQUFBQUlBQUFBQUF5QURJQUFIQUE0QUNMVUxDQVFBQWkwckVpQVdFQVlnSmhBbEFUTVJNeEV6NmdGTTZ1cit0T29Ca1A3VXlNaklBeURxL3JUcTZnRk1odjdVL3RRQkxBQUFBQUVBQUFCa0F5QUNXQUFHQUFhekJRQUJMU3NCRlNFVklSVWxBU3dCOVA0TS90UUNXTWhreVBjQUFBQUFBUUFBQUdRRElBSllBQVlBQnJNQ0FBRXRLd0VOQVRVaE5TRUI5QUVzL3RUK0RBSDBBbGozL2Noa0FBQUJBQUFBQUFKWUF5QUFCZ0FHc3dRQUFTMHJFek1STXdrQk04akl5UDdYL3RISUF5RCtEUDdVQVN3QUFBRUFBQUJrQXlBQ3ZBQUdBQWF6QlFBQkxTc0JGU0VWSVJVQkFTd0I5UDRNL3RRQ3ZNakl5QUVwQUFBQUFRQUFBR1FESUFLOEFBWUFCck1DQUFFdEt3a0NOU0UxSVFIMEFTeisxUDRNQWZRQ3ZQN1gvdEhJeUFBQkFBQUFBQUpZQXlBQUJnQUdzd01BQVMwckNRRWpFU01SSXdFcEFTL0l5TWdESVA3VS9nd0I5QUFBQUFFQUFBQUFBZlFESUFBR0FBYXpBd0FCTFNzYkFTTVJJeEVqOS8zSVpNZ0RJUDdVL2d3QjlBQUVBQUFBQUFLOEF5QUFBd0FIQUFzQUR3QU5RQW9PREFvSUJnUUNBQVF0S3dFekVTTURNeEVqQVRNUkl3RXpGU01Ca0dSa3lHUmtBWkJrWlAyb1pHUURJUHpnQXJ6OXFBSDAvbkFCTE1nQUFBUUFBQUFpQXlBQ1dBQUtBQlVBSHdBcEFBMUFDaVFnSEJZUUN3WUFCQzByRXhjR0ZSUVhCeTRCTlRRbEZoVVVCZ2NuTmpVMEp3VVhCaFVVRndjbU5UUWxGaFVVQnljMk5UUW5kRWhZV0VnM1BRS3NkRDAzU0ZoWS9wOUZIQnhGT3dGVk96dEZIQndDV0VoWWVYMVlTRGVVVXFWMGRLVlNsRGRJV0gxNVdFUklIQ2tzSEVnN1ZWSTZPMUZWTzBnY0xDa2NBQUFDQUFBQUFBR1FBeUFBQndBUEFBaTFEUWdFQUFJdEt4SXlGaFFHSWlZMEV4WXpNamNSSndkMnBIWjJwSFprTmk0dE4yUmtBeUIycEhaMnBQNlZFeFArd1dSa0FBTUFBQUFBQXlBRElBQUhBQThBRndBS3R4SVFEUWdFQUFNdEt4SWdGaEFHSUNZUUpTSUdGUlFYQVNZWEFSWXpNalkxTk9zQlN1dnIvcmJyQVpCOHNEZ0JvMDZUL2wxT1lYeXdBeURyL3JicjZ3RktoN0I4WVU0Qm96aDkvbDA0c0h4aEFBQURBQUFBQUFNZ0Fyd0FCUUFKQUEwQUNyY01DZ2dHQkFBRExTc1JNeEVoRlNFQk14RWpBVE1SSTJRQ3ZQemdBZlRJeVA3VXlNZ0N2UDJvWkFLOC9nd0JMUDdVQUFRQUFBQUFBeUFESUFBWEFCb0FKZ0F5QUExQUNpMG5JUnNaR0F3QkJDMHJBVFlYSGdJWE14VWpFUlFHSXlFaUpqVVJJelV6RXpZWEJ5RUVJZ1lkQVJRV01qWTlBVFFrSWdZZEFSUVdNalk5QVRRQmpSRVJBV3g0RElCa0ZBNzk3QTRVWklEcURoaVFBU0QrN3lvZEhTb2RBUThxSFIwcUhRTWdBUTRCZ1k0UFpQNlNEaFFVRGdGdVpBRVpFWDZzeUIwVlpCVWRIUlZrRlIwZEZXUVZIUjBWWkJVQUFnQUFBR1FESUFLOEFBOEFFd0FJdFJFUUNRQUNMU3NUSVRJZEFUTVZJeFVVSXlFaU5SRTBGeEVoRVFrQ3FnbGtaQW45Vmdsa0FmUUN2QXEreUw4SkNRSkdDV1QrY0FHUUFBQUFBQUVBQUFCa0F5QUN2QUFQQUFhekNRQUJMU3NUSVRJZEFUTVZJeFVVSXlFaU5SRTBDUUtxQ1dSa0NmMVdDUUs4Q3I3SXZ3a0pBa1lKQUFBQUFBSUFBUCtjQXlBQ3ZBQW1BQzhBQ0xVc0p4WUNBaTByRXpRMk93TWhNaFlVQmlzQkZSSVhGaFVVQnlNR0l5RWlKalUwTnpZVE5TTWlCaU1pSmdVakZRY0dCeUV2QVZ3YUV3TUZCUUgwRlIwZEZUS09HQ0lwQXlzNS9nQStVaUlZampJQkJnRVZIUUdZeUFZL09BSENkd1lDaWhJZ0hTb2RqZjd6S0RjelBpa3BVajR6TnlnQkRZMEJIaDJpQ250cDVBb0FBQUFDQUFBQUFBTWdBeUFBRFFBVEFBaTFFUTRIQUFJdEt3QXlGaFVVRnhZVklUUTNOalUwRXpNVUJpSW1BVDZrZG9aQy9PQkNobVRJTzFJN0F5QjJVcHR2TjA5UE4yK2JVdjI2S1RzN0FBQUFBQU1BQUFBQUFpWURJQUFOQUJBQUV3QUt0eElSRHc0RkFBTXRLeE16QlFjWEJTTTFCeWMzSnpjWE54VTNCeFUzbGpJQlh1SGgvcUl5UzB1V2xrdExaSmFXbGdNZytwT1ordnBMUzVhV1MwdGt5R1RJeUdRQUFBQURBQUFBQUFNZ0F5QUFGUUFkQUNVQUNyY2ZIaGNXQ3dBRExTc1JJVElXRlJRSEhnRVZGQVlqSVRVeU5qVVJOQ1lqSVJVek1qWTBKaU1ERVRNeU5qUW1Jd0gwVW5Zc1FVK1NhUDNhS1RzN0tRRXNaQ2s3T3lsa2xqNVlXRDRESUhaU1JqY2ZlRXBva21RN0tRR1FLVHZJTzFJNy90VCsxRmg4V0FBQUFRQUFBQUFCOUFNZ0FBVUFCck1EQUFFdEt3RVJNd0VSSXdFc3lQN1V5QU1nL3RUK0RBRXNBQUVBQUFBQUFyd0RJQUFiQUFhekVnQUJMU3NUSVJFM0Z4RXpNaFlWRVNFaUJoUVdNeUVWSVNJbU5SRTNQZ0UzWkFFc1pHUXlGUjM5MmhVZEhSVUNKdjNhUGxnREJpc2RBeUQrMUdSa0FTd2RGZjNhSFNvZFpGZytBaVlUSFNzR0FBRUFBQUFBQVpBRElBQUVBQWF6QWdBQkxTc1JJUkVuQndHUXlNZ0RJUHpneU1nQUFBSUFBQUFBQXlBRElBQURBQThBQ0xVTEJBSUFBaTByRVNFVklSVWhGVE0xSVJFVUl5RWlOUU1nL09BQkxNc0JLUW44OGdrRElHUmtaMmY5c1FrSkFBQURBQUFBQUFNZ0F5QUFGd0FiQUNjQUNyY2pIQmtZQ3dBRExTc0JNeklXSFFFek1oMEJGQVlqSVNJbVBRRTBPd0UxTkRZWEZUTTFBUll6SVRJM0ZSUWpJU0kxQVN6SUtUdS9DUjBWL1VRVkhRbS9PeW5JL2d3WUdnSzhHaGdKL1BJSkF5QTdLV1FKOFJVZEhSWHhDV1FwTzJSa1pQNFZDUW5JQ1FrQUFRQUFBQUFDV0FNZ0FDUUFCck1WQUFFdEt3RXlGaFVqTkNZaklnY0dGUlFXRnpNVkl3WUhJUlVoTlRjMk55TTFNeTRDTlRRM05nRXNYbXBrTWpJdkdSd1pBNnl5RjFvQjYvMm9FRmNUZW4wQ0R3Z3lOd01nYWw0eU1oOGpPeHgzSEdSaFoyUjZERmRQWkExSFBCOWVQa1VBQUFBRUFBRC9uQU1nQXJ3QUZBQWNBQ2dBTEFBTlFBb3FLU0VkR1JVTEFBUXRLeE03QXlFeUZoVVJGQVlqSVNJbU5SRTFORFlXSWdZVUZqSTJORGNpQmhRV015RXlOalFtSXdVUklSRWlCQU1FQlFLOEZSMGRGZjFFRlIwVWx5b2RIU29kbGhVZEhSVUJMQlVkSFJYOTJnSllBcndkRmYxRUZSMGRGUUs4QWc4ZFlCMHFIUjBxSFIwcUhSMHFIY2orY0FHUUFBQUFBZ0FBQUFBREdnTWRBQTBBR3dBSXRSTU9Cd0FDTFNzQkh3RVdCd0VQQVM0Qkp6OEJDUUV5RmhVVUJpTWlKejRCTlRRMkF1Z0dMQVVGL3ZZUEdSRlBOZ3dOQVhmK0tEaE9uRzVLUEQxSlRRTWRBeXdGQi82SkRRdzJUeEVaRHdFSy9uWk9PRzZjSWlOOFNUaE9BQUFBQUFFQUFQKzdBczRDdkFCbkFBYXpNZ3NCTFNzVE5EWXpNaDhCTnk0QlBnRXlIZ0VHQnhjM05qTXlGaFVVQmc4QkZoY3pNaFlVQmlzQkZBY1hIZ0VWRkFZaklpOEJCZ2NtUFFjMEppTWlCZ2NXRkFjZEF4UUhKaWNIQmlNaUpqVTBOajhCSmpVckFTSW1OVFEyT3dJMk55Y3VBUWtiRXc0TWd4MGNCaVJKVmtra0JSd2Nnd3NLRlIwUUMzTVVCVVFWSFIwVk1nWk9EeFlkRlJBUFFTVkNQQjBWRWh3RUFRRTdReVJDRHhBVkhSWVBUZ1l5QlJVZEhSVUZSUVVVZEF3UUFjTVNJQWRDRmgxWVRUZzNUVmdlRmtJSEhSVU5HZ1k0SXc4ZEtoMGlJQ2dFSFJBVkhRc2pTQ1loSjRjRUJRWUZCVmNWSFJjUkF4QURVZ1FGa0NnZ0tVVWpDeDBWRUIwRUtDQWlIUlVVSGc4ak9BVWFBQUlBQUFBQ0Fyd0N2QUFIQUJ3QUNMVVNDUVVBQWkwckFUTXlGUkVVS3dFQkpSRW5GU0lIRnhZT0FTWW5BeU1pUFFFME93RUNXRnNKQ1Z2K2VnRWkraGNGU3dnT0ppb0laMXNKQ2JZQ3ZBbjl1Z2tCazVQK0RIMERGcklUS2hBT0V3RVFDYllKQUFBQUJ3QUFBQUFDdkFNZ0FBc0FEd0FUQUJjQUd3QWZBQ01BRTBBUUlTQWRIQmtZRlJRUkVBME1CUUFITFNzVElUSVZFUlFqSVNJMUVUUVhGU0UxQVJVek5UTVZNelV6RVRNUkJSVXpOVE1WTXpVSkFxb0pDZjFXQ1dRQjlQNE1aR1JrWkdUK0RHUmtaQU1nQ2Z6eUNRa0REZ2xreU1qKzFHUmtaR1QrMUFFc3lHUmtaR1FBQndBQUFBQUN2QU1nQUFNQUN3QVBBQk1BRndBYkFCOEFFMEFRSFJ3WkdCVVVFUkFOREFjRUFnQUhMU3NSSVJVaEZTRVJGQ01oSWpVVEZUTTFNeFV6TlRNVk16VUZGVE0xTXhVek5RSzgvVVFDdkFuOVZnbGtaR1JrWkdUK0RHUmtaQU1neUdUK0ZRa0pBWWRrWkdSa1pHVElaR1JrWkFBQUJBQUFBQUFESUFNZ0FCZ0FJQUFvQURBQURVQUtMU2tsSVIwWkN3QUVMU3NCTXpJZkFSWTdBVElWRVJRaklTSTFFVFEyT3dFeVB3RTJBaUlHRkJZeU5qUWtJZ1lVRmpJMk5DWXlGaFFHSWlZMEFabTJDQVJlQkFoU0NRbjg4Z2xZUG8wSUJGNEU1aW9kSFNvZEFYNmtkbmFrZHZGU096dFNPd01nQ2JZSkNmMjZDUWtCdVQ1WUNiWUovdFFkS2gwZEtoMTJwSFoycEJJN1VqczdVZ0FBQUFFQUFBRElBeUFDV0FBQ0FBYXpBZ0FCTFNzUklRRURJUDV3QWxqK2NBQUFBUUFBQUFBQmtBTWdBQUlBQnJNQkFBRXRLd0VSQVFHUS9uQURJUHpnQVpBQUFBQUFBUUFBQUFBQmtBTWdBQUlBQnJNQ0FBRXRLeEVKQVFHUS9uQURJUDV3L25BQUFBQUFBUUFBQU1nRElBSllBQUlBQnJNQkFBRXRLd2tCSVFHUUFaRDg0QUpZL25BQUFBQUFBd0FBQUFBREh3SllBQ0VBS1FBeEFBcTNMaW9tSWhJQ0F5MHJFVFEyT3dReUZoOEJJVElXRHdFT0FTTWhJaVluTGdFdkFTTWlCaU1pSmdBeUZoUUdJaVkwSkRJV0ZBWWlKalFiRXdNRkJNZ05HZ1VtQWJ3S0NBTlJBeFVML3FJS0ZRTU9OZzBLbGdFRkFSVWVBVkVxSFIwcUhRRkpLaDBkS2gwQ0poSWdFUXRJRHdyNkNnOFBDaW1vS1JrQkh2NVRIU29kSFNvZEhTb2RIU29BQWdBQUFBQURJQUs4QUFZQUN3QUl0UWtIQmdBQ0xTc1JJUlVoRVNNSEFTRVJKeUVCOVA3VVpHUUJMQUgwWlA1d0FyeGsvdFJrQVN6K0RHUUFBUUFBQUVJREVBSzhBQTBBQnJNQ0FBRXRLd0VYQVM0Q0x3RTNGaGMrQWdLQmovNFRJRWxhR0VpTlMwNG5qblFDdkkzK0V5SktXUmxIalV4S0o0NTBBQUVBQUFBeUF5QUNXQUFGQUFhekJBQUJMU3NURnpjWENRR1crdnFXL25EK2NBSlkrdnFXL25BQmtBQUFBUUFBQUFBQ0pnTWdBQVVBQnJNRUFBRXRLd0VYQnhjSEFRR1FsdnI2bHY1d0F5Q1crdnFXQVpBQUFBQUJBQUFBQUFJbUF5QUFCUUFHc3dJQUFTMHJFd2tCSnpjbmxnR1EvbkNXK3ZvRElQNXcvbkNXK3ZvQUFBRUFBQUF5QXlBQ1dBQUZBQWF6QWdBQkxTc0pBUWNuQnljQmtBR1FsdnI2bGdKWS9uQ1crdnFXQUFBQUFnQUFBQUFESUFNZ0FBY0FEUUFJdFF3SUJBQUNMU3NTSUJZUUJpQW1FQ1VISndjWEFlb0JUT3JxL3JUcUFsajZaRWlzQVVJRElPcit0T3JxQVV3NCttUklyQUZDQUFBQUFnQUFBQUFESUFNZ0FBY0FFd0FJdFF3SUJBQUNMU3NTSUJZUUJpQW1FRGNIRndjWE54YzNKemNuQitvQlRPcnEvclRxK2tpV2xraVdsa2lXbGtpV0F5RHEvclRxNmdGTU9FaVdsa2lXbGtpV2xraVdBQUFBQUFJQUFBQUFBcndESUFBUkFDVUFDTFVkRWdrQUFpMHJBRElXSFFFek1oWWRBU0UxTkRZN0FUVTBCVE1WSVRVek1oWVZFUlFHSXlFaUpqVVJORFlCU1NvZFN3c08vdFFPQzB2KzdVc0I5RXNMRGc0TC9YWUxEZzRESUIwVk1nNExTMHNMRGpJVlI4aklEZ3Y5ZGdzT0Rnc0NpZ3NPQUFBQUFBTUFBQUFBQXlBRElBQUhBQThBR0FBS3R4VVFEQWdFQUFNdEt4SWdGaEFHSUNZUUpDSUdGQll5TmpRbE14VVdGd2NtTHdIckFVcnI2LzYyNndJTStMQ3crTEQrb21RaUprZ2tNQkFESU92K3R1dnJBVXFIc1Bpd3NQaE10U1FoU0Nnd0RBQUNBQUFBQUFNZ0F5QUFHUUFzQUFpMUpoNEpBQUl0S3dFeUZoMEJIZ0VWRkFjak5UUW1JZ1lkQVNFbU5UUTJNejRCRXpzQk1qWXpNaFlkQWpNSEp6TTlBVFEyQWNKb2tpczVDYjlZZkZqKzhCeDJVaEdQU2dNRUFRWUNGUjJXeU1pV0ZBTWdrbWd5RUZVeEdoZ3lQbGhZUGpJeE0xSjJWbkwrY0FFZEZRR1d5TWlXQWc4ZEFBQUFBZ0FBQUFBRElBTWdBQlFBSHdBSXRSb1ZDUUFDTFNzQk1oWWRBUjRCRlJRSEl5Y0hJeVkxTkRZelBnRVRGeU1WRkFZaUpqMEJJd0hDYUpJck9RbU55TWplSEhaU0VZOWErc2dkS2gzSUF5Q1NhRElRVlRFYUdNaklNVE5TZGxaeS9qNzZNaFVkSFJVeUFBQUFBUUFBQUdRRElBSzhBQklBQnJNSkFBRXRLd0V5RmgwQkhnRVZGQVlqSVNJbU5EWXpQZ0VCd21pU0t6bFlQdjQrVW5aMlVoR1BBcnlTYURJUVZURStXSGFrZGxaeUFBQUFBZ0FBQUFBRElBTWdBQXNBSGdBSXRSVU1Cd0FDTFNzVE1oY2lCZ2NHQnlZMU5EWUZNaFlkQVI0QkZSUUdJeUVpSmpRMk16NEIrbnROYXJFcU9pb1prZ0V3YUpJck9WZysvajVTZG5aU0VZOERJR1J6WGhBZk5EWm9rc2lTYURJUVZURStXSGFrZGxaeUFBQUFBd0FBQUdRRElBSzhBQU1BQ1FBUEFBcTNEUW9IQkFJQUF5MHJBVE1CSXdNekJ4Y2pKeVV6Rndjak53SDBaUDdVWkdSa1pHUmtaQUpZWkdSa1pHUUN2UDJvQWZUSXlNakl5TWpJQUFJQUFBQUFBeUFESUFBZkFDY0FDTFVrSUJBQUFpMHJBVE1mQVRjWEJ4OEJGUThCRndjbkR3RWpMd0VISnpjdkFUVS9BU2MzRnpjV0lnWVVGakkyTkFGZVpESWNkMGd5REhkM0RESklkeHd5WkRJY2QwZ3lESGQzRERKSWR4eWlmRmhZZkZnRElIY01Na2gzSERKa01oeDNTRElNZDNjTU1raDNIREprTWh4M1NESU1nMWg4V0ZoOEFBQUFBd0FBQUFBRElBTWdBQU1BQmdBS0FBcTNDUWNHQkFJQUF5MHJFU0VWSVJjaEJ3VWhGU0VESVB6Z3lBR1F5UDV3QXlEODRBTWd5R1RJeUdRQUF3QUFBQUFESUFNZ0FBTUFCd0FLQUFxM0NRZ0dCQUlBQXkwckVUTVJJd0V6RVNNREVTZGtaQUpZeU1oa3lBTWcvT0FESVB6Z0FsaitjTWdBQXdBQUFBQURJQU1nQUFNQUJ3QUtBQXEzQ2dnR0JBSUFBeTByRVRNUkl3RXpFU01CRndmSXlBSzhaR1QrY01qSUF5RDg0QU1nL09BQ1dNaklBQUFBQUFNQUFBQUFBeUFESUFBREFBWUFDZ0FLdHdrSEJRUUNBQU10S3hFaEZTRUZGeUVISVJVaEF5RDg0QUdReVA1d3lBTWcvT0FESUdUSXlHVElBQVlBQUFBQUFyd0N2QUFuQURBQU9RQTlBRVlBVHdBUlFBNUtSMEkrT3pvMU1Td29GQUFHTFNzU01oWWRBVE0xTkRZeUZoUUdLd0VWTXpJV0ZBWWlKajBCSXhVVUJpSW1ORFk3QVRVaklpWTBGaUlHRkJZN0FUVTBKQ0lHSFFFek1qWTBCUlV6TlFjaUJoUVdNalk5QVNFVkZCWXlOalFtSTFoOFdHUllmRmhZUGpJeVBsaFlmRmhrV0h4WVdENHlNajVZcXlvZEhSVXlBWE1xSFRJVkhmN1VaUG9WSFIwcUhRRXNIU29kSFJVQ3ZGZytNakkrV0ZoOFdHUllmRmhZUGpJeVBsaFlmRmhrV0h3TUhTb2RNaFVkSFJVeUhTcXJaR1RJSFNvZEhSVXlNaFVkSFNvZEFBQUJBQUFBQUFNZ0F5QUFDZ0FHc3dZQkFTMHJFVFF6SVRJVkVTY2hJalVKQXc0SnlQMnhDUU1YQ1FyODZzZ0pBQUFFQUFBQUFBTWdBeUFBQndBUEFCTUFHd0FOUUFvWUZCSVFEQWdFQUFRdEt4SWdGaEFHSUNZUUpDSUdGQll5TmpRbkF3VVRGaUlHRkJZeU5qVHJBVXJyNi82MjZ3SU0rTEN3K0xCa1pQN1VaSGtxSFIwcUhRTWc2LzYyNitzQlNvZXcrTEN3K0V6KzFHUUJMRElkS2gwZEtnQUFBQUlBQUFBQUF5QURJQUFIQUEwQUNMVUpDQVFBQWkwckVpQVdFQVlnSmhBbEVUSTJOQ2JyQVVycjYvNjI2d0dRZkxDd0F5RHIvcmJyNndGS2gvMm9zUGl3QUFBQUJRQUFBQUFESUFNZ0FBTUFCd0FMQUE4QUZ3QVBRQXdVRUE0TUNnZ0dCQUlBQlMwckVTRVZJUlVoRlNFVklSVWhGU0VWSVNReUZoUUdJaVkwQXlEODRBSDAvZ3dESVB6Z0FsajlxQUxaS2gwZEtoMERJR1JrWk1oa1pHUmtIU29kSFNvQUFBUUFBQUJrQXlBQ3ZBQUpBQk1BRndBYkFBMUFDaGtZRlJRT0NnVUFCQzByRXlFeUZoMEJJVFUwTmdjaEVSUUdJeUVpSmpVM0ZUTTFNeFV6TlJrQzdnc08vT0FPRGdNZ0RndjlFZ3NPWkdSa1pBSzhEZ3RMU3dzT3lQNkpDdzRPQzY5a1pHUmtBQUFBQXdBQUFBQURJQU1nQUJJQUZRQVlBQXEzRnhZVUV3c0FBeTByRXpNVklUY1hCeEV6RlNNVkl6VWhFU00xTXhjUkFSY0JJV1JrQWNKa01tUmtaR1QrREdSa1pBRmVNdjZpQVY0RElHUmtNbVQrUG1Sa1pBSDBaR1Qrb2dGZU12NmlBQUFBQUFVQUFBQUFBeUFESUFBSEFBOEFGd0FzQURRQUQwQU1NUzBtR3hRUURBZ0VBQVV0S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFrTWhZVUJpSW1OQWMwTmpjN0FqSWZBVGN5RmhRR0lpWTFOeWNtSkRJV0ZBWWlKalRyQVVycjYvNjI2d0lNK0xDdytMRCt2eW9kSFNvZGxoUU9Bd01JRmc1YkdTazdPMUk3QmxvUUFVa3FIUjBxSFFNZzYvNjI2K3NCU29ldytMQ3crRXdkS2gwZEtuY1BIUVFRV2dZN1VqczdLUmxiRGtZZEtoMGRLZ0FBQUFJQUFBQUFBeUFESUFBR0FBb0FDTFVKQndRQUFpMHJBVE1STXdrQk13RWhGU0VCTE1qSS90VCsxTWorMUFNZy9PQURJUDdVL3RRQkxQNXdaQUFBQUFBQ0FBQUFBQU1nQXlBQUF3QUtBQWkxQndRQ0FBSXRLeEVoRlNFRkFTTVJJeEVqQXlEODRBR1FBU3pJeU1nRElHUmsvdFQrMUFFc0FBSUFBQUJrQXlBQ3ZBQUVBQkFBQ0xVSkJRSUFBaTByRXlFUklRTWxCeGNIRnpjWE55YzNKd2ZJQWxqOXFNZ0JYa2lXbGtpV2xraVdsa2lXQXJ6OXFBRXMza2lXbGtpV2xraVdsa2lXQUFBQUFnQUFBR1FESUFLOEFBc0FHQUFJdFJNTUF3QUNMU3NTSUJZVkl6UW1JZ1lWSXpRbEZ6Y2VBUlVVQmlJbU5UUTI2d0ZLNjJTdytMQmtBVlU3T3o1UGRxUjJUd0s4NjZWOHNMQjhwUnBZV0JOcFExSjJkbEpEYVFBQUFBQUZBQUFBQUFLOEF5QUFCUUFJQUF3QUVBQVVBQTlBREJJUkRnMEtDUWNHQkFBRkxTc1JJUkVoRVNFSkFTRWxGVE0xQnhVek5RY1ZJVFVCTEFHUS9VUUJrQUVzL3RUKzFHUmtaR1FCa0FNZy9uRCtjQU1nL3RSa1pHVElaR1RJWkdRQUFBQUFBUUFBLzV3QjlBSzhBRHNBQnJNZUFBRXRLeE16RlRNeUZ4WWRBU00xSmlzQklnWWRBUlFXRndVZUFSMEJGQVlyQVJVak5TTWlKeVk5QVRNVkZqc0JNalk5QVRRbUp5VXVBVDBCTkRZN0FjaGtTekVnTEdRSUVmb0xEaGNMQVFFeFBFb3pTMlJMTVNBc1pBZ1IrZ3NPRnd2Ky96RThTak5MQXJ4a0ZoOHZaRjRHRGdzeUN4NERRUXhPTXpJelNtUmtGaDh2WkY0R0Rnc3lDeDREUVF4T016SXpTZ0FDQUFBQVpBTWdBcndBQXdBSEFBaTFCd1FEQUFJdEt4RWhFUWtCSVJFQkFTeisxQUgwQVN6KzFBSzgvdFQrMUFKWS90VCsxQUFBQUFJQUFBQmtBeUFDdkFBREFBY0FDTFVGQkFFQUFpMHJBUkVoRVFFUklSRUJMUDdVQXlEKzFBSzgvYWdCTEFFcy9hZ0JMQUFDQUFBQVpBTWdBcndBQ2dBVkFBaTFFUXNHQUFJdEt3RVZJZ1lWTXhFaEVUUTJJUlVpQmhVekVTRVJORFlCTEZOMXlQN1VzQUp3VTNYSS90U3dBcnhrZFZQKzFBRXNmTEJrZFZQKzFBRXNmTEFBQUFBQ0FBQUFaQU1nQXJ3QUNnQVZBQWkxRHdzRUFBSXRLeEVoRVJRR0l6VXlOalVqQVNFUkZBWWpOVEkyTlNNQkxMQjhVM1hJQWZRQkxMQjhVM1hJQXJ6KzFIeXdaSFZUQVN6KzFIeXdaSFZUQUFJQUFQL3FBbGdESUFBU0FDSUFDTFVZRXdrQUFpMHJBUmNlQkJVVUJpSW1OVFErQXpjQ0lnWVZGQll6TWpZMEppTWlKalUwQVN3aURTaFpSVGV3K0xBM1JWa29EVjhxSFhaU0ZSMGRGU2s3QXlBaURTdHliNUk5ZkxDd2ZEMlNiM0lyRGY1S0hSVlNkaDBxSFRzcEZRQUNBQUFBQUFNZ0F5QUFBZ0FHQUFpMUJRTUJBQUl0S3drQklSVWhGU0VCa0FHUS9PQURJUHpnQXlEK0RHVElBQUFDQUFBQUFBSllBeUFBQWdBRkFBaTFCUU1CQUFJdEt3a0JJUlVoQVFFc0FTejlxQUpZL3RRRElQN1V5UDdVQUFBREFBQUJMQU1nQWZRQUF3QUhBQXNBQ3JjS0NBWUVBZ0FETFNzUk14VWpKVE1WSXlVekZTUEl5QUVzeU1nQkxNaklBZlRJeU1qSXlBQUFBQUFDQUFBQVpBTWdBcndBQkFBSkFBaTFDQVVEQUFJdEt4RWhGUVVsRlFVbEVTRURJUDV3L25BQmtBR1EvT0FDdkdUSXlHVEl5UDV3QUFNQUFBQUFBeUFESUFBRUFBb0FEd0FLdHc0TENBVUNBQU10S3dFRkVTRVJKUVVWQlNVMUJTRVZCeWNCa0FHUS9PQUJrUDdVQVN3QkxQNE1BWkRJeUFNZ3lQMm9BbGhZbHJ5V2xyd21aR1JrQUFBQUFBRUFBUCtjQXlBQ3ZBQWpBQWF6RlFBQkxTc0JNaGNISmlJR0J5RUhJUlFYSVFjakZqTXlOeFVHSXlJbUp5RTNNeVkxSXpjelBnRUNXR05jRUU3Q21SOEJTeEQrc2hNQktSRGVXb1J5Vmw1cWJMWTIvd0FUeFJESUdiOGkxQUs4TW1vNGIxbGtMVGRrWkU1Nk9HMWJaRUFrWklPcEFBQUFBQVlBQUFBQUF5QUN2QUFEQUFjQUN3QVBBQk1BRndBUlFBNFdGQklRRGd3S0NBWUVBZ0FHTFNzUklSVWhGU0VWSVJVaEZTRVZNeFVqTnpNVkl6Y3pGU01DdlAxRUFmVCtEQU1nL09Ca1pNaGtaTWhrWkFLOFpHUmtaR1JrWkdSa1pHUUFBQUFEQUFBQUFBTWdBeUFBQXdBR0FBb0FDcmNKQndZRUFnQURMU3NSSVJVaEZ5RUhCU0VWSVFNZy9PRElBWkRJL25BRElQemdBeUJrWk1qSXlBQURBQUFBQUFNZ0F5QUFBd0FIQUFvQUNyY0tDQVlFQWdBRExTc1JNeEVqQVRNUkl3RVhCMlJrQWxqSXlQNXd5TWdESVB6Z0F5RDg0QUpZeU1nQUFBQUFBd0FBQUFBRElBTWdBQU1BQndBS0FBcTNDUWdHQkFJQUF5MHJFVE1SSXdFekVTTURFU2ZJeUFLOFpHUmt5QU1nL09BRElQemdBbGorY01nQUF3QUFBQUFESUFNZ0FBTUFCZ0FLQUFxM0NRY0ZCQUlBQXkwckVTRVZJUVVYSVFjaEZTRURJUHpnQVpESS9uRElBeUQ4NEFNZ3lNaklaR1FBQWdBQUFBQURJQU1nQUFrQUVBQUl0UTRLQ0FBQ0xTc1JNeFVqRVNFMU14VWhBU0VSSndjbk44aGtBbGhrL09BQmtBR1FsdnBrK2dNZ1pQMm9aTWdESVA1d2x2cGsrZ0FBQXdBQUFHUURJQUs4QUJzQUl3QTFBQXEzTVNRZ0hBMEFBeTByQVRJZUJCOEJEZ1FqSWk0Q0x3RStCaFlpQmhRV01qWTBKeklYQmhVVUZqTXlOeFlWRkFZaUpqUTJBWk15WTB4Rk1TUUpDUVlYVDFhR1JVZUhYRWNSRVFNTUtTNUlUV1NEcEhaMnBIYklDaEljSFJVZURnWTdVanM3QXJ3aE5VQkFOUkVRRENsblQwRStXRmdmSHdZV1BqbEZNaUprZHFSMmRxUVNCZzRlRlIwY0Vnb3BPenRTT3dBQ0FBRC9uQU1pQXIwQUlRQWxBQWkxSkNJWkF3SXRLd0U3QVRZek1oOEJOell5RnhZVUR3RVhGaFVVQmlNaUx3RUJJUkVCSnlZMU5EWVhBUmNCQVVzREF3TUhGZzllUWl0K0t5d3NRVjBTSFJVWkR6NytnLzd6QVhjL0VCV0Mvc2VBQVR3Q3ZBRVJYVUVyS3l4OExFSmVEaGdWSFJSQi9vTUJFQUY5UHc0V0R4M1gvc1dFQVR3QUFnQUFBQUFDdkFNZ0FBVUFDQUFJdFFjR0JBQUNMU3NSSVJFaEVTRUpBU0VCTEFHUS9VUUJrQUVzL3RRRElQNXcvbkFESVA3VUFBQUNBQUFBQUFLOEF5QUFHZ0FzQUFpMUl4c05BQUl0S3hNZUJCVVVEZ1FYTGdRMU5ENEVOQUVlQkJVVUJpTWhORDRFTk1nSUcwVTFLeXM5UVMwTEdRZ2JSVFVySVRFNU1TQUJHQWdiUlRVclB5WCsxQ0V4T1RFZ0F5QUVFRGhBYURndVhVZFNSbHd1QkJBNFFHZzRLRkJBUWtGQ1R2NzlCQkE0UUdnNFptSW9VRUJDUVVKT0FBQUFBZ0FBQUFBRElBTWdBQU1BREFBSXRRa0VBZ0FDTFNzUk14RWpFeUVWSVFjWElUVWpaR1RJQVN3QkxNakkvbkRJQXlEODRBTWdaTXZGWkFBQUFRQUFBQUFCa0FNZ0FBb0FCck1HQUFFdEt4TXpCek1ETXdFRE16Y2pscFpreUphVy90Umtoa0xJQXlESS90VCsxQUVzeUFBQUFBQUNBQUFBQUFNZ0F5QUFCUUFQQUFpMUNnWUVBQUl0S3hFaEZTRVZJUlVoRVJRR0l5RWlKalVCTEFIMC9PQURJQjBWL1VRVkhRTWdaR1JrL2o0VkhSMFZBQUFBQUFFQUFBQUFBcndESUFBd0FBYXpKUUFCTFNzU01oWVZGQVlIRlRZN0FUSTJQUUV1QVRVME5qSVdGUlFHQnhVVUJpc0JJZ2NlQVJVVUJpSW1OVFEyTnpVdUFUVTBXSHhZTnkwYkY4Z1ZIUzAzV0h4WU55MVlQc2dTRUNZdVdIeFlOeTB0TndNZ1dENHhUUTkyQ1IwVk93OU5NVDVZV0Q0eFRRODdQbGdRRWtnc1BsaFlQakZORDlvUFRURStBQUFBQUFJQUFBQUFBeUFESUFBR0FBMEFDTFVLQndRQUFpMHJFU0VIRndjbkJ5RVhOeEVoTnljQmtKYVdaSmFXQWZTV2x2NXdscFlESUphV1pKYVdscGIrY0phV0FBQUFBZ0FBQUFBRElBTWdBQVlBRFFBSXRRc0hBd0FDTFNzVEZ6Y1JJVGNuQVNFSEZ3Y25CMlNXbHY1d2xwWUJrQUdRbHBaa2xwWURJSmFXL25DV2x2N1VscFprbHBZQUFBQUFBd0FBQUFBRElBTWdBQWNBUmdCVkFBcTNVVWNuQ0FRQUF5MHJFaUFXRUFZZ0poQWxJZ2NYRmdZSEJpSUdGeFlHTGdFSEJoNEJCeWNpQnhZWEhnRVhIZ0VIRmpNeU5qYzJKaU1pTGdJM1BnTW5KajRCTlRRbUp5WStBemNtRnc0QkZ4WTJGeDREUHdFMUp1b0JUT3JxL3JUcUFaQlFTUllXRFJZS0t4RUZCZ29PRndZVEdTQUhPd29HQVJJSlRnMGxOaEE2TUV1REtRSVhIUjR3TVJzQkFSOGVFUTBOQlJSRUFRRURDd1lUQXpuQ0l6a0ZBellJQXdrSEVBa1dFQU1nNnY2MDZ1b0JUSVlzRXc4akNRUU9GeFFJQ1FnRUVrTkdBU0lLSGpZRENRMFdhU0FXUXpvVUdBY1RLUjRQTENFb0N4SU5HUW9WRndZRkN3MEhFZ0lUYlFvZkRBZ0JCZ01VRFFZTEZnTW1BQUFDQUFBQUFBTWdBeUFBQndBTEFBaTFDZ2dFQUFJdEt3RVhBU2NISndFWEFTRVZJUUsvWWY1d1pNaGtBU3hrL25BRElQemdBeUJrL25Ca3kyUUJMMlQrY0dRQUFCQUFBQUFBQXJ3Q3ZBQURBQWNBQ3dBUEFCTUFGd0FiQUI4QUl3QW5BQ3NBTHdBekFEY0FPd0EvQUNWQUlqNDhPamcyTkRJd0xpd3FLQ1lrSWlBZUhCb1lGaFFTRUE0TUNnZ0dCQUlBRUMwckVUTVZJemN6RlNNM014VWpOek1WSXdVekZTTTNNeFVqTnpNVkl6Y3pGU01GTXhVak56TVZJemN6RlNNM014VWpCVE1WSXpjekZTTTNNeFVqTnpNVkkyUmt5R1JreUdSa3lHUmsvYWhrWk1oa1pNaGtaTWhrWlAyb1pHVElaR1RJWkdUSVpHVDlxR1JreUdSa3lHUmt5R1JrQXJ4a1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtBQWtBQUFBQUF5QURJQUFEQUFjQUN3QVBBQk1BRndBYkFCOEFJd0FYUUJRaUlCNGNHaGdXRkJJUURnd0tDQVlFQWdBSkxTc1JNeFVqSlRNVkl5VXpGU01GTXhVakpUTVZJeVV6RlNNRk14VWpKVE1WSXlVekZTUEl5QUVzeU1nQkxNakkvYWpJeUFFc3lNZ0JMTWpJL2FqSXlBRXN5TWdCTE1qSUF5REl5TWpJeUdUSXlNakl5R1RJeU1qSXlBQUFBQVFBQUFBQUF5QURJQUFEQUFjQUN3QVBBQTFBQ2c0TUNnZ0dCQUlBQkMwckVTRVJJUUVoRVNFRklSRWhBU0VSSVFFcy90UUI5QUVzL3RUK0RBRXMvdFFCOUFFcy90UURJUDdVQVN6KzFNaisxQUVzL3RRQUFBQURBQUFBQUFLOEF5QUFEUUFaQUNFQUNyY2VHaFVPQmdBRExTc1RJVElWRVJRR0l5RWlKalVSTkJFV015RXlOeEVVSXlFaU5TUWlCaFFXTWpZMEV3S1dFeDBWL2FnVkhSZ2FBbGdhR0JQOWFoTUNPeW9kSFNvZEF5QVQvclVWSFIwVkFVc1QvaFVKQ2Y3ZUV4TzFIU29kSFNvQUFBRUFBQUFBQXJ3Q3ZBQXpBQWF6R2dBQkxTc1JJUlVqSWdZZEFTRTFOQ1lyQVRVaEZTTWlCaFVSRkJZN0FSVWhOVE15TmowQklSVVVGanNCRlNFMU16STJOUkUwSmlzQkFTd3lGUjBCTEIwVk1nRXNNaFVkSFJVeS90UXlGUjMrMUIwVk12N1VNaFVkSFJVeUFyeGtIUldXbGhVZFpHUWRGZjV3RlIxa1pCMFZscFlWSFdSa0hSVUJrQlVkQUFBQUFBRUFBQUFBQXlBQ3ZBQWxBQWF6Q3dBQkxTc0FNaFlkQVRNeUZoMEJGQVlyQVNJbU5SRTBKaUlHRlJFVUJpc0JJaVk5QVRRMk93RTFOQUVVK0xBeUZSMGRGV1FWSFhXbWRSMFZaQlVkSFJVeUFyeXdmR1FkRmNnVkhSMFZBVjVUZFhWVC9xSVZIUjBWeUJVZFpId0FBQUFCQUFBQUV3TWdBcndBRFFBR3N3d0NBUzByRURRMk1oWVZORFl5RmhRSENRRjJwSFoycEhZNy9xditxd0dpcEhaMlVsSjJkcVE3L3F3QlZBQUJBQUFBQUFNZ0Fyd0FDZ0FHc3dNQUFTMHJDUUVuRVNNMUl4VWpFU01Ca0FHUVpNakl5R1FDdlA3VUEvNXR5TWdCa0FBQUFnQUFBQUFESUFNZ0FBTUFEUUFJdFFjRUFnQUNMU3NSSVJFaEV4RTNBVE0xSnpjWEVRTWcvT0JrWkFHUVpNaGtaQU1nL09BQ3ZQN1VaUDV3Wk1oa1pBRXNBQUFDQUFBQUFBTWdBeUFBQ3dBVEFBaTFEd3dGQUFJdEt4TWhNaFVSRkNNaElqVVJOQmNSTXhjek56TVJFd0w2RXhQOUJoTmtaR1RJWkdRRElCUDlCaE1UQXZvVHlQN1VaR1FCTEFBQUF3QUFBTWdESUFKWUFCVUFJQUFyQUFxM0ppRWFGZ29BQXkwckV6SVdGejRCTXpJV0ZBWWpJaVluRGdFaklpWTBOaGNpQmhRV016STJOeTRCSVNJR0J4NEJNekkyTkNiSU4xNHpNMTQzWFd0clhUZGVNek5mTmwxcmExMHpNVEV6SFQ4cUtqOEJjeDAvS2lvL0hUTXhNUUpZUURvNlFIaWdlRUE2T2tCNG9IaGtQRkE4TkRBd05EUXdNRFE4VUR3QUFnQUFBQUFCa0FNZ0FBY0FKUUFJdFJZSUJBQUNMU3NBTWhZVUJpSW1OQVl5RmhVVUJoVVVGakkyTlRNVUJpTWlKalUwUGdFMU5DWWlCaFVqTkFFRFVqczdVanR3ZkZoa0hTb2RaRmcrUDFjeU1oMHFIV1FESUR0U096dFN2MWs5SmNjT0ZSMGRGVDVZVmtBbGNWb0tGUjBkRlQ0QUFBQUFBUUFBQUFBQ3ZBTWdBQkFBQnJNSEFBRXRLeE1oRlNNREJ6TVZJVFV6UGdJL0FTUElBZlI2NmdhaS9neDZJazVnR2dlakF5QmsvYlFNWkdSWXhPOUJEQUFBQUFBRUFBQUFBQU1nQXJ3QUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLeEVoRlNFVklSVWhGU0VWSVJjaEZTRURJUHpnQXlEODRBTWcvT0JrQWxqOXFBSzhaR1JrWkdSa1pBQUFCQUFBQUFBRElBSzhBQU1BQndBTEFBOEFEVUFLRGd3S0NBWUVBZ0FFTFNzUklSVWhGU0VWSVJVaEZTRVZJUlVoQXlEODRBTWcvT0FESVB6Z0FsajlxQUs4WkdSa1pHUmtaQUFBQUFRQUFBQUFBeUFDdkFBREFBY0FDd0FQQUExQUNnNE1DZ2dHQkFJQUJDMHJFU0VWSVJVaEZTRVZJUlVoRnlFVklRTWcvT0FESVB6Z0F5RDg0TWdDV1Ayb0FyeGtaR1JrWkdSa0FBQUNBQUFBQUFNZ0F5QUFFUUFaQUFpMUZoSUxBQUl0S3dBeUZoUUdJeUluQnhVakZTRTFBU1kxTkNRaUJoUVdNalkwQWI3UWtwSm9JQThEeVA3VUFTOERBVlZTT3p0U093TWdrdENTQXdOa3lNZ0JMdzhnYUM0N1VqczdVZ0FBQUFBQ0FBQUFBQU1nQWxnQUdBQWdBQWkxSEJrTkFBSXRLeE03QXlFeUZoVVJNeFVVQmlNaElpWTlBVE1STlRRMkZ4RXpGVE0xTXhHR0F3UUVCUUgwRlIxa0hSWDlSQlVkWkJSUVpNaGtBbGdkRmY2aWxoVWRIUldXQVY0Q0R4MWcvdFJrWkFFc0FBQUFBQU1BQUFBQUF5QURJQUFEQUFrQUR3QUt0d3dLQmdRQ0FBTXRLeEVoRVNFbE14RWhOU0UzTXhFaE5TRUJrUDV3QWZSay9uQUJMTWhrL25BQkxBTWcvbkRJL25Ca1pQNXdaQUFBQUFBRUFBRC9td0g4QXIwQUVRQWpBRDBBVUFBTlFBcE5RRElsSEJNS0FRUXRLd0UyTXpJV0ZSUUdCd1VHSXlJbU5UUTJOeUUyTXpJV0ZSUUdCd1VHSXlJbU5UUTJOeUUyTXpJV0ZSUUdEd0VlQVJVVUJpTWlKaXNCTGdFMU5EWTNGelEyT3dReUZoUUdLd0VpQmlNaUpnRlJDZ3NWSFJBTC90UVBFQlVkRmc4QmtBc0tGUjBRQy81d0R4QVZIUllQQVpBTENoVWRFQXRxRWhrZUZRRUdBY2dUSFE4TERoc1RBd1FGWkJVZEhSVmtBUVlCRlIwQ3RnY2RGUTBhQnBZTEhSVVFIUVFISFJVTkdnYklDeDBWRUIwRUJ4MFZEUm9HT0FNZEVoVWVBUUVkRkF3YUJ2UVNJQjBxSFFFZUFBUUFBQUFBQXg0RElBQUZBQ2NBU2dCUUFBMUFDazlMUlMwUUNBSUFCQzByRXpNVkl6VXpKVE0yRnhZWEZoUVBBUVlqSWlZMU5EOEJOaVluSmdZUEFRWWpJaVkxTkQ4Qk5nRTJPd0V5TmpNeUZoUVBBUVlXRnhZMlB3RTJNeklXRlJRUEFRWUhCaVluSmpRM0JUTVZJeFVqeDJUSVpBR0RBU0lXTnlvNk9wWVBIQlVkR0pZZUFSMGdWUnNzRHhzVkhSZ3JNdjdVRFFrREFRWUJGUjBPbGg0QkhTQlZHeXdQR3hVZEdDc2ZMRFJ5S1RvNkFibklaR1FESU1oa1lRSUZEQ282cER1V0dCMFZIQStXSGxVZEhnTWJMQmdkRlJ3UExEVCswUkFCSFNvT2xoNVZIUjRER3l3WUhSVWNEeXdmRUJNWktUdWtPb3hrWkFBQUFBSUFBQUFGQXg0REhRQXJBRlFBQ0xWVVRRa0JBaTByQVRZWEZoY1dGQThCQmljdUJTTW1OVFEyTXpJWEZoY1dQd0UySmljbUJnY0dJeUltTlRRM05nY2VBaGNlQVJVVUJpTWlKeVluSmc4QkJoWVhGalkzTmpNeUZoVVVCd1lIQmlZbkpqUS9BVFlDU2lNV055bzZPcFpVWWd3V0RSRUZEZ0VhSFJVT0RBOGFOek9XSGdFZElGVWJEeHdWSFJneWVoWWdHQWNQRmgwVkVBOFRIRGt1bGg0QkhTQlZHdzhiRlIwWEh5dzBjaWs2T3BaUUF4MENCUXdxT3FRN2xsUUdBUU1EQndNSURoNFZIZ2NMQWdRemxoNVZIUjRER3hnZEZSd1BOT01CQ0FzQ0JCMFFGUjBMQ1FFQ0xwWWVWUjBlQXhzWUhSVWREaDhRRXhrcE82UTZsbEFBQUFBQUJnQUFBQUFESUFLOEFBTUFCd0FMQUE4QUV3QVhBQkZBRGhZVUVoQU9EQW9JQmdRQ0FBWXRLeEVoRVNFQklSVWhGU0VWSVFVaEVTRUJJUlVoRlNFVklRRXMvdFFCa0FHUS9uQUJMUDdVL25BQkxQN1VBWkFCa1A1d0FTeisxQUs4L3RRQkxHUmtaR1QrMUFFc1pHUmtBQWdBQUFBQUF5QUN2QUFIQUFzQUV3QVhBQjhBSXdBckFDOEFGVUFTTGl3b0pDSWdIQmdXRkJBTUNnZ0VBQWd0S3hJeUZoUUdJaVkwTnlFVklRWXlGaFFHSWlZME55RVZJUVl5RmhRR0lpWTBOeUVWSVFZeUZoUUdJaVkwTnlFVklSMHFIUjBxSGNnQ1dQMm9xeW9kSFNvZHlBSlkvYWlyS2gwZEtoM0lBbGo5cUtzcUhSMHFIY2dDV1Ayb0Fyd2RLaDBkS2gxa1pCMHFIUjBxSFdSa0hTb2RIU29kWkdRZEtoMGRLaDFrQUFBQUFRQUFBQUFESUFNZ0FBTUFCck1CQUFFdEt3a0JBeVVESVA1d1pQN1VBeUQ4NEFFc1pBQUFBQUlBQUFBQUFsZ0N2QUFMQUJNQUNMVVFEQVlBQWkwckVqSVdIUUV6RVNFUk16VTBOaUlHSFFFek5UVGFwSFprL2FoazhsUTZ5QUs4ZGxKay9uQUJrR1JTRWpvcVpHUXFBQUVBQUFBQUFsZ0RJQUFSQUFhekJnQUJMU3NTTWhZZEFUTVJJUkVoTlRRbUlnWVZJelRhcEhaay9hZ0JrRHBVT21RRElIWlN5UDV3QVpESUtqbzZLbElBQUFBQUFnQUFBR1FESUFLOEFBb0FGUUFJdFE4TEJnQUNMU3NCRlNJR0ZUTUhKek0wTmdVWEl4UUdJelV5TmpVakFaQlRkV1NXbG1Td0FYYVdaTEI4VTNWa0FyeGtkVlBJeUh5d1pNaDhzR1IxVXdBQ0FBQUFBQU1nQXlBQUNnQVZBQWkxRWdzRUFBSXRLeE1oRVRNSEp6TTFJUlVqSHdFakZTRTFNeFVoRVNOa0FsaGtscFprL25Ca01wWmtBWkJrL2Foa0F5RCsxUHI2eUdReStzaGt5QUVzQUFJQUFBQUFBeUFDdkFBTEFCY0FDTFVXREFJQUFpMHJBUmNITlNFVkl6VTBOak1oQVJVaE5UTVZGQVlqSVJVbkFsakl5UDRNWkRzcEFmVCtjQUgwWkRzcC9neklBcnlXbG1Sa1pDazcvdFJrWkdRcE8yU1dBQUFDQUFELy9nTWlBeUFBR1FBakFBaTFIeG9OQUFJdEt4SWdGaFVVQnhZZkFSNEJGUlFHSXlJbUx3RW1Kd1lqSWlZUUFUSTJOVFFtSWdZVUZzMEJJczBzQ2daa0RCSThLaEVyREdRRkIwMVprYzBCWG1xUWt0Q1NrZ01nelpGV1VBWUdaQXdyRVNvOEVneGtCQWtwelFFaS9uV1FhbWlTa3RDU0FBQUFBZ0FBQUFBQ1dBTWdBQkFBR0FBSXRSVVJDUUFDTFNzU01oWVZGQTRDRHdFdUJEVTBKQ0lHRkJZeU5qU3crTEErV0ZnZkh3d3BaMDlCQVg2a2RuYWtkZ01nc0h3NGtINXVJQ0FNSzMxMWt6aDhUSGFrZG5ha0FBUUFBQUFBQXlFRElBQUlBQmNBSmdBdUFBMUFDaXNuSHhnUkR3Y0FCQzByRVNFUkZoVVVCeFVoSlRRMk93SVJJUkVoTlNzQklpWUNNaFlWRkFZUEFTNEVOVFFXSWdZVUZqSTJOQU1nQVFIODRBSHZIUlVGbHYyb0FsaVdCUlVkejN4WVN5VW1CaFEwS0NDcktoMGRLaDBESVAzakF3Z0hBKzc2RkI0QmtQMm9aQjBCYzFnK0xIMHBLQVlXUGpwS0hENE1IU29kSFNvQUFnQUFBR1FDV0FLOEFBTUFCd0FJdFFZRUFnQUNMU3NSTXhFakFUTVJJOGpJQVpESXlBSzgvYWdDV1Ayb0FBQUFBUUFBQUdRQ1dBSzhBQUlBQnJNQ0FBRXRLeEVKQVFKWS9hZ0N2UDdVL3RRQUFBQUFBUUFBQUdRQ1dBSzhBQWNBQnJNRUFBRXRLeEl5RmhRR0lpWTBzUGl3c1Bpd0FyeXcrTEN3K0FBQUFBQUNBQUFBWkFNZ0Fyd0FBZ0FGQUFpMUJRUUJBQUl0S3dFUkFTRUJFUUdRL25BQmtBR1FBcno5cUFFc0FTejlxQUFDQUFBQVpBTWdBcndBQWdBRkFBaTFCQU1DQUFJdEt4RUpBU0VSQVFHUS9uQUJrQUdRQXJ6KzFQN1VBbGorMUFBQ0FBQUFaQUs4QXJ3QUF3QUdBQWkxQmdVQ0FBSXRLeEV6RVNNVEFSSEl5TWdCOUFLOC9hZ0JMQUVzL2FnQUFBQUNBQUFBWkFLOEFyd0FBZ0FHQUFpMUJBTUNBQUl0S3hFSkFTRVJNeEVCOVA0TUFmVElBcnorMVA3VUFsajlxQUFCQUFBQVpBSllBcndBQXdBR3N3SUFBUzByRVNFUklRSlkvYWdDdlAyb0FBRUFBQUFBQXlBRElBQUxBQWF6QmdBQkxTc1RJUlV6RVNNVklUVWpFVFBJQVpESXlQNXd5TWdESU1qK2NNaklBWkFBQUFBREFBQUFBd01nQXJ3QUF3QUhBQXNBQ3JjS0NBWUVBZ0FETFNzUklSVWhGU0VWSVJVaEZTRURJUHpnQXlEODRBTWcvT0FDdkdURlpNaGtBQUFDQUFEL25BSllBc0FBRUFBOEFBaTFMeFVKQVFJdEt3RTJNeklXSFFJVUJpSW1QUUkwTmdjN0FUSTJNeklXSFFJVUZqSTJQUUUwTmpJV0hRRVVCZ2NWTXpJV0ZTRTBOanNCTlM0QlBRSTBOZ0VXRGdncE96dFNPeTdVQkFNQkJnSVZIWFdtZFIwcUhZOXJNaWs3L25BN0tUSnJqeFFDdkFRN0tRVElLVHM3S2NnQ0lUckJBUjBWQVRKVGRYVlRNaFVkSFJVeWJxWVNhanNwS1R0cUVxWnVNZ0lQSFFBQUFBQUJBQUFCTEFNZ0FmUUFBd0FHc3dJQUFTMHJFU0VWSVFNZy9PQUI5TWdBQUFJQUFQK2NBeUFDdkFBZ0FDUUFDTFVpSVJJQUFpMHJFenNESVRJV0ZSRVVCaXNCRlRNeUZoVWhORFk3QVRVaklpWTFFVFUwTmhjUklSRWlCQU1FQlFLOEZSMGRGZnBrS1R2OXFEc3BaUG9WSFJSUUFsZ0N2QjBWL2d3VkhXUTdLU2s3WkIwVkFmUUNEeDFnL25BQmtBQUJBQUQvc2dNS0Fyd0FEd0FHc3drQUFTMHJBUVlWRkJZek1qY09BU01pSmpVME5nRVFGdXFtUVQ4bzBJS202cGdDdkQ5QnB1b1dlSmpxcG9MUUFBQUFBUUFBQUFBQ3ZBSzhBQmNBQnJNTUFBRXRLd0VYSXhVek5SY0hOU01WTXdjbk16VWpGU2MzRlRNMUl3RmVsbVNXbHBhV1pKYVdaSmFXbHBaa0FyeVdsbVNXbG1TV2xwYVdaSmFXWkpZQUFBQUJBQUFBQUFNZ0F5QUFIUUFHc3hBQUFTMHJBUkVVQmlJbU5EWXpNaGMxQkFjUkZBWWlKalEyTXpJWEVUNEVBeUJZZkZoWVBoY2IvdldGV0h4WVdENFhHd1FVV0hqa0F5RDkyajVZV0h4WUNjNElLdjV6UGxoWWZGZ0pBWmtFRGlJYUZnQUFBUUFBLzUwQ3VnSzhBQ3dBQnJNbkFBRXRLd0F5RnhZVUR3RUdJaVkwUHdFWER3RUdGQll5UHdFK0FTY3VBUWNCRGdFWEZqSS9BaGNIQmlJbU5EY0JBYUdrT3pvNitpUm5TQ1JnUlZvSEJ3NFlCL29jQVIwZFZSNys2aklCTXpTU05BbDBSWDFRNUtCUUFSWUN2RHM3cERyMEpFaG5KR0ZGWGdNSUZoQUk5eDVSSGgwQkh2N3ROSkF6TkRRTWNVVjlVS0RrVUFFUUFBQUNBQUFBQUFNZ0F5QUFBd0FJQUFpMUJnUUNBQUl0S3dFWEJ5Y0hGd0VqTlFKWXlHVElaTWorY01nRElNaGt5R1RJL25ESUFBQUFBQVFBQUFBQUF5QURJQUFNQUJRQUhnQXFBQTFBQ2lZZkdSVVJEUVFBQkMwckFUSVdGQVlqSWljMk5UUW5OZ1F5RmhRR0lpWTBCUjRCSFFFak5UUW5OZ1VXTWpjZUFSMEJJVFUwTmdJbVBsaFlQaG9oQ1VndS91SjhXRmg4V0FKeElpbklMR1g5dWtmUVJ5SXAvZ3dwQXlCMXBuVVRKeXArVmxoa2RhWjFkYWJIRVQ4bXBrSklQZ01UVkZRUlB5YW1waVkvQUFBQ0FBQUFBQU1nQXlBQUJ3QVRBQWkxRHdnRUFBSXRLd0F5RmhRR0lpWTBBeFl5Tng0QkhRRWhOVFEyQVQybWRYV21kUWxaOEZsUWIvemdid01nazg2VGs4NytuMlJrQkhOUlpHUlJjd0FBQUFNQUFBQUFBZlFESUFBTEFBOEFGd0FLdHhRUURRd0ZBQU10S3hNaE1oVVJGQ01oSWpVUk5CY1JJUkVDSWdZVUZqSTJOQk1CemhNVC9qSVRaQUVzZ1NvZEhTb2RBeUFUL1FZVEV3TDZFMlQrREFIMC9kb2RLaDBkS2dBQUF3QUFBQUFESUFNZ0FBVUFEd0FXQUFxM0VoQUxCZ01BQXkwckFUSVhFUUUyQlI0QkZSUUdJeUluQVNVWEJ5NEJOVFFCWGhvWS90ZGxBU2lBck0yUmUyTUJFUDVuN2RRMlBnTWdBLzV6QVNsbmFoUENnNUhOVVFFUTBlclVLbnBHZkFBQUFBRUFBUCtjQXJ3Q3ZBQWpBQWF6RlFJQkxTc1RORFk3QXlFeUZoUUdLd0VWTXpJV0ZTRVJCeWNSSVRRMk93RTFJeUlHSXlJbVhCc1RBd1FGQVpBVkhSMFZNbVFwTy83VU9DeisxRHNwWkRJQkJnRVZIUUtLRWlBZEtoM0lPeW4rMUdSa0FTd3BPOGdCSGdBQUFBSUFBQUFBQXlBRElBQUhBQW9BQ0xVSkNBUUFBaTByRWlBV0VBWWdKaEFsRVNYcUFVenE2djYwNmdFc0FTd0RJT3IrdE9ycUFVd2kvbkRJQUFFQUFBQUFBeUFESUFBTEFBYXpCZ0FCTFNzQk14RWhGU0VSSXhFaE5TRUJMTWdCTFA3VXlQN1VBU3dESVA3VXlQN1VBU3pJQUFBQUFnQUFBQUFDdkFNZ0FBTUFIZ0FJdFJnRUFnQUNMU3NCTXhFakF4Y0hCaFVVRmpJMk5UUW1Md0UzRng0QkZSUUdJQ1kxTkRZM0FTeGtaSUErS0Y2UzBKSTBMU1UrSmo1SXpmN2V6VWcrQXlEK2NBRUFUaDlMZW1pU2ttZzdaeU1mVGg4eGtGS1J6YzJSVXBBeEFBQUFBQU1BQUFBQUF5QURJQUFEQUJNQUZ3QUt0eFlVQ1FRQ0FBTXRLeE1oRlNFSElUSVZFUlFyQVRVaEZTTWlOUkUwRnlFUkljZ0JrUDV3dndNT0NRbGIvYWhiQ2NnQmtQNXdBeURJWkFuKzVnbkl5QWtCR2duSS90UUFBQUFBQlFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRXdBUFFBd1NFQTRNQ2dnR0JBSUFCUzByRVRNUkl3RXpFU01CTXhVakZ6TVZJeGN6RlNOa1pBSzhaR1QrRE1qSVpNaklaTWpJQXJ6OVJBSzgvVVFDV0dSa1pHUmtBQUVBQVAvaEF5QUN2QUFiQUFhekVnQUJMU3NCRmhNK0FUY1dGek1WSXljR0J5WURCZ0lISmljak5UTWZBVFlTQVVVYWFRODZEeFJEcWVjTlNpWVdZUlZURlJ3NGRMd0pBdzlXQXJ4WC9yUWxsQ1VtaG1RY3VGdEpBVGhEL3ZaRFdLNWtJZ1l4QVJzQUFRQUEvNXdESUFLOEFEa0FCck1mQWdFdEt4TTBOaklXRlJRT0FRY0dGVE1WTWpjK0FqTXlGaFFHSXlJdUFTY21JeFVqTkRjK0FqVTBKaUlHRlJRZUFSY1dGU01STXpRbkxnTElPVlk1Q1JBREErY1dCZ2NkRncwck9Ua3JEUmNkQndZVzV3TURFQWs1VmprSkVBTUQ1K2NEQXhBSkFsZ3JPVGtyRFJjZEJ3WVc1d01ERUFrNVZqa0pFQU1ENXhZR0J4MFhEU3M1T1NzTkZ4MEhCaFlDV0JZR0J4MFhBQUFBQWdBQS81d0I4UUs4QUNzQUx3QUl0UzRzRHdBQ0xTc1RNaGNXRlJRT0FRY09CQjBCSXpVMFBnRTNQZ2cxTkNjbUl5SUhCZ2NuTmpjMkV6TVZJL2QrUVRzcktpSVhDeDRJQ1dRb0tpRUNHd1FWQkE4REJ3SWNKbFJQSlJnSFpBb3hRa2hrWkFLOE96WlhObDh1SGhRTElSWW9HQmtaTmw0d0hRSVhCUlFJRXc0V0Z3NHBHU0lsR0MwTVR6RkMvVVJrQUFBQUFBUUFBQUFBQXlBRElBQWZBRE1BUndCYkFBMUFDbFJNUURnc0pBb0FCQzByQVRJV0hRRWVBUlVVQmdjdUFTTWlCeTRCSWdZSEppTWlCeVkxTkRZelBnRURPd0V5TmpNeUZoMENGQVlpSmowQ05EWUhPd0V5TmpNeUZoMENGQVlpSmowQ05EWWxPd0V5TmpNeUZoMENGQVlpSmowQ05EWUJ3bWlTS3prL01SRkxMaHNkRFZCbVVBMGRHemtvTlhaU0VZOGFCQU1CQmdJVkhSMHFIUlM2QkFNQkJnSVZIUjBxSFJRQm5nTUVBUVlDRlIwZEtoMFVBeUNTYURJUVZURXpVQTBxTkF3eFB6OHhEQ0k2VEZKMlZuTCtEQUVkRlFISUZSMGRGY2dDRHgxZ0FSMFZBV1FWSFIwVlpBSVBIUVFCSFJVQlpCVWRIUlZrQWc4ZEFBRUFBQUFBQXlBRElBQWpBQWF6Q3dBQkxTc0JGd2MxSXdjZkFUTTFGd2MxSXlJdkFRY0dLd0UxTXpjdkFTTTFNeklmQVRjMk93RUNXTWpJTXBtdkJoYkl5Qmt1SUthWkh5OWtaS2FqQTJSa0xpQ1pqUjh2TWdNZ2xwWmt2ODREWkphV1pDYSt2aVprenI4RFpDYXlzaVlBQUFBQUFRQUFBQUFESUFNZ0FCVUFCck1RQUFFdEt3RXlGemNSSVRjbUl5SUdGQll5TnhjR0l5SW1FRFlCa0tKM2QvN1ViVmw0ZkxDdytGaElkS2lsNitzRElIZDMvdFJ0VzdENHNGaElkT3NCU3VzQUFBQUFBUUFBQUFBRElBTWdBQWtBQnJNRkFBRXRLd0VoRVNjQkZ5RVJGd0VCa0FHUXB2NXdwdjV3cGdHUUF5RCtjS2IrY0tZQmtLWUJrQUFCQUFBQUFBSDBBeUFBQ1FBR3N3VUFBUzByR3dFakZUTUxBVE0xSS9yNnlNajYrc2pJQXlEKzFNaisxQUVzeUFBQkFBQUFaQU1nQWxnQUNRQUdzd1VBQVMwckFSVXpOUTBCTlNNVkpRRXN5QUVzL3RUSS90UUNXTWpJK3ZySXlQb0FBQUFBQXdBQUFBQURJQU1nQUFvQUVnQVhBQXEzRmhNT0N3VUFBeTByRVRJRUZoSVZJelFDSkNNVk1nQVZJelFtSXhVeUZoVWpvZ0VwMW4vSW9QN3NwTTRCSnNpdmZWSjJ5QU1nZjliKzE2S2tBUlNnWlA3YXpuMnZaSFpTQUFBRUFBQUFBQU1nQXlBQUNnQVRBQnNBSXdBTlFBb2dIQmNVRHdzRUFBUXRLeE15QkJJVkl6UXVBaU1WTWg0QkZTTTBKaU1WTWhZVkl6UW1Jd1l5RmhRR0lpWTBaTDRCUXJ4a1g2RGZlb2ptaG1UcXBueXdaSFZUS1ZJN08xSTdBeUM4L3I2K2V0K2dYMlNHNW9pbTZtU3dmRk4xWkR0U096dFNBQUFBQVFBQUFBQURJQU1nQUNFQUJyTVJBQUV0S3dFaE1oWWRBU0UxTkNZaUJoMEJJUkVVQmlNaElpWTlBVE1WRkJZeU5qVVJORFlCTEFHUUtUditjQjBxSFFHUU95bitEQ2s3WkIwcUhUc0RJRHNweUpZVkhSMFYrdjdVS1RzN0tjaVdGUjBkRlFJbUtUc0FBQUFBQWdBQUFBQURJQUs4QUJJQUhRQUl0Um9UQ2dBQ0xTc1RNeFVqRVNFMU14VVVCaU1oSWlZMUVUUTJJUmNITlNNaUJnYytBVE5MNGNnQmtHUXNILzQrSHl3c0Fpekl5TWhHYkJBUjRKa0N2R1QrREdSOUh5d3NId0ltSHl6SXlHUldRNWJMQUFFQUFBQUFBeUFDdkFBTUFBYXpCd0FCTFNzSkFqVWpJZ1lITkQ0Q013SDBBU3orMUdTWTBpWXRiY2lTQXJ6KzVQN0V5SnFTZHF5TFJ3QUFBQUlBQUFBQUF5QURJQUFVQUJ3QUNMVVdGUXNCQWkwckFUY1hGZ1FYRlJRSEJnY0dJaWNtSnlZOUFUWWtFeEVGRmhjV0Z4WUJmUk1USlFFT1NwTTlRRWh3U0VBOWswb0JEamorMmd4dU9ESXJBeGNKQ1E5ekhoL2d3MUV2TlRVdlVjWGVIeDV6L1Z3Q1QzcTFrMG9rSHdBRUFBQUFBQUs4QXlBQUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLd0V6RVNNRE14RWpBek1SSXdNekVTTUNXR1JreUdSa3lHUmt5R1JrQXlEODRBSzgvVVFCOVA0TUFTeisxQUFBQUFFQUFBQUFBcndESUFBTkFBYXpCd0FCTFNzQk14VXpGd2NqRVNNUkl5YzNNd0VzWk1oa1pNaGt5R1JreUFNZ3lHUmsvbkFCOUdSa0FBQUFBQVFBQUFBQUF5QURJQUFHQUFvQURnQVNBQTFBQ2hFUERRc0pCd1FBQkMwckV6TVJNd2NuTXhNekZTTVZJUlVoRlNFVkljaGt5UHI2eU1qSXlBRXMvdFFCa1A1d0F5RDlxTWpJQWxoa1pHUmtaQUFBQUFRQUFBQUFBeUFESUFBR0FBb0FEZ0FTQUExQUNoRVBEUXNKQndRQUJDMHJFek1STXdjbk14TWhGU0VWSVJVaEZUTVZJOGhreVByNnlNZ0JrUDV3QVN6KzFNaklBeUQ5cU1qSUFsaGtaR1JrWkFBQUFBY0FBQUFBQXlBQ3ZBQVBBQk1BRndBYkFCOEFJd0FuQUJOQUVDVWtJU0FkSEJrWUZSUVJFQWNBQnkwckV5RXlGaFVSRkFZaklTSW1OUkUwTmhjVk16VXpGU0UxQlJVek5UTVZJVFVGRlRNMU14VWhOVXNDaWg4c0xCLzlkaDhzTERoa1pBR1EvYWhrWkFHUS9haGtaQUdRQXJ3c0gvM2FIeXdzSHdJbUh5eGtaR1JrWk1oa1pHUmt5R1JrWkdRQUFBRUFBQUFBQXlBRElBQUpBQWF6QkFBQkxTc0JFeUVIRXljSEV5Y2hBWkJrQVN6NlpQcjZaUG9CTEFNZy90VEkvdFRJeUFFc3lBQUFDUUFBQUFBRElBTWdBQWNBRHdBWEFCOEFKd0F2QURjQVB3QkhBQmRBRkVSQVBEZzBNQ3dvSkNBY0dCUVFEQWdFQUFrdEt3QXlGaFFHSWlZMEJqSVdGQVlpSmpRa01oWVVCaUltTkFReUZoUUdJaVkwQmpJV0ZBWWlKalFrTWhZVUJpSW1OQVF5RmhRR0lpWTBKRElXRkFZaUpqUUdNaFlVQmlJbU5BRjdLaDBkS2gzZEtoMGRLaDBDRVNvZEhTb2QvdWFrZG5ha2Rxc3FIUjBxSFFMWktoMGRLaDM5eFNvZEhTb2RBaEVxSFIwcUhkMHFIUjBxSFFNZ0hTb2RIU3BISFNvZEhTb2RIU29kSFNwSGRxUjJkcVFnSFNvZEhTb2RIU29kSFNyZEhTb2RIU29kSFNvZEhTcEhIU29kSFNvQUF3QUFBQUFDdkFNZ0FBOEFFd0FaQUFxM0Z4UVJFQWNBQXkwckV5RXlGaFVSRkFZaklTSW1OUkUwTmhjUklSRUNJZ1lXTWpZaUFuZ09GQlFPL1lnT0ZCUlFBZlRkT2gwY1BCd0RJQlFPL1NRT0ZCUU9BdHdPRkdUK0RBSDAvZG95TWpJQUFBSUFBQUFBQXlBRElBQUVBQXdBQ0xVSkJRTUFBaTByRVNFSkFqWWlCaFFXTWpZMEFTd0I5UDdVL2d6eFVqczdVanNESVA0TS90UUI5TWc3VWpzN1VnQURBQUFBWkFNZ0FsZ0FCQUFLQUJJQUNyY1BDd2dGQXdBRExTc1JNd0VIQVNVekFRY25OeVFpQmhRV01qWTB5QUVzeVA3VUFWU2dBU3pJVG5mK0tpb2RIU29kQWxqKzFNZ0JMTWorMU1oT2VzZ2RLaDBkS2dBQUJBQUFBQUFESUFNZ0FBY0FEd0FYQUI4QURVQUtIQmdVRUF3SUJBQUVMU3NTSUJZUUJpQW1FQ1FpQmhRV01qWTBKRElXRkFZaUpqUTJJZ1lVRmpJMk5Pc0JTdXZyL3JickFnejRzTEQ0c1A2Q3BIWjJwSGJ5VkRvNlZEb0RJT3YrdHV2ckFVcUhzUGl3c1BoTWRxUjJkcVFTT2xRNk9sUUFBZ0FBQUFBRElBSzhBQWtBRHdBSXRRd0tDQUFDTFNzUklRY2hFU0UxTnhFaEFSY0JKemNYQWk5ay9wa0I5R1Q5UkFLOFpQNXd5R1JrQXJ4ay9neWZaUDZaQXJ4ay9uRElaR1FBQUFNQUFBQUFBeUFESUFBTEFCRUFGUUFLdHhNU0VBd0ZBQU10S3hNaE1oVVJGQ01oSWpVUk5CY0hGd2NYTnhjVklUVUpBdzRKQ2Z6eUNaWklaR1JJckU0QkxBTWdDZnp5Q1FrRERnbE9TR1JrU0t3eVpHUUFBQUFCQUFBQUFBTWdBeUFBR1FBR3N3MEFBUzByRVNFVkl6UW1Ld0VSRkJZN0FSVWhOVE15TmpVUkl5SUdGU01ESURJN0taWWRGVEwrY0RJVkhaWXBPeklESU1ncE8vM2FGUjFrWkIwVkFpWTdLUUFBQUFBQ0FBQUFBd0s4QXJ3QUF3QWRBQWkxRlFRQ0FBSXRLeEV6RVNNVElUSVhFaFVVQmlzQklnWVZGQmNXRGdFbUp5NENKeVlqWkdUSUFWNGhEbWNkRlpZVUhpOEdFaVlrQ3dJK09BZ2NMQUs4L25BQmtCLyszUndWSFI4VEg1a1VKUXdSRkFON2FBZ2NBQUlBQUFBQUFyd0N2QUFjQUNBQUNMVWZIUlFDQWkwckFUWTNGeDRCQndZVkZCWTdBVElXRlJRR0R3RUdJeUVSTWpjK0FnRXpFU01Ca0JBZkV4TVNCaThlRkpZVkhUUWFHUTRoL3FJc0hBZzRQdjV5WkdRQ21oOERBd1lsRkprZkV4OGRGUXlnU2trZkFaQWNDR2g3L3ZuK2NBQUFBZ0FBLzV3Q3ZBSzhBQjhBS2dBSXRTTWdGd0FDTFNzVElSVWpGUllYQnlZaklnWVVGakkyTlRRbk54WVZGQVlnSmpVME5qYzFJd1VBQndZaUpqUTNQZ0UzeUFFc1pESVdJaWt2YUpLUzBKSVFXeG5OL3Q3TnJJQmtBZlQrMkJRUEpoNFBDY0JiQXJ4a0JnZ0lYaENTMEpLU2FDOHBKVVE1a2MzTmtZUEdFZ01RL3FRVUR4NG1Ed21XUndBQ0FBQUFBQU1nQXJ3QUJnQU5BQWkxREFjQ0FBSXRLd0VYQnpVaE5TRUJGU0VWSVJVbkFsakl5UDJvQWxqK2NBSlkvYWpJQXJ5V2xtUmsvdFJrWkdTV0FBQUFBQUlBQUFBQUFyd0RJQUFQQUNjQUNMVWpFQWdBQWkwckFUTXlGaFV6TWhZVklUUTJPd0UwTmdNekVSUVdNalkxRVRNUkZCWXlOalVSTXhFVUl5RWlOUUVzWkNrN1pDazcvVVE3S1dRN24yUWRLaDFrSFNvZFpCUCtNaE1ESURzcE95a3BPeWs3L3RUK29oVWRIUlVCWHY2aUZSMGRGUUZlL2g4VEV3QUNBQUFBQUFLOEF5QUFFUUFWQUFpMUZCSU1BQUl0S3hNekVSUVdNalkxRVRNUkZBWXJBU0ltTlFNaEZTRmt5RHRTTzJSMlVqSm5rMlFDdlAxRUF5RCtjQ2s3T3lrQmtQNXdVbloxVS83VVpBQUFBQUFFQUFBQUFBTWdBcndBQ3dBWEFDTUFKd0FOUUFvbUpCMFlFUXdGQUFRdEt4TXpNaFVSRkNzQklqVVJOQ0V6TWhVUkZDc0JJalVSTkFVek1oVVJGQ3NCSWpVUk5BRWhGU0VKdGdrSnRna0NZYllKQ2JZSi90MjJDUW0yQ2Y3VUF5RDg0QUs4Q2Y0ZUNRa0I0Z2tKL2g0SkNRSGlDY2dKL3VZSkNRRWFDZjV3WkFBQUFBQUhBQUFBQUFNZ0Fyd0FCd0FQQUJjQUd3QWpBQ3NBTXdBVFFCQXZMQ2NrSHh3YUdCUVFEQWdFQUFjdEt4TXpNaDBCSXpVMElUTXlIUUVqTlRRRk16SWRBU00xTkFVaEZTRVZNeFVVS3dFaU5TVXpGUlFyQVNJMUpUTVZGQ3NCSWpVS3RRbklBbUsxQ2NqKzNyVUp5UDdVQXlEODRNZ0p0Z2tCTE1nSnRRb0JMTWdKdFFvQ3ZBbS92d2tKdjc4SlpBbGJXd25JWkdTL0NRbS9Xd2tKVzc4SkNRQUFBQVFBQUFBQUF5QUN2QUFEQUE4QUd3QW5BQTFBQ2lFY0ZSQUpCQUlBQkMwckVTRVZJUmN6TWhVUkZDc0JJalVSTkNFek1oVVJGQ3NCSWpVUk5DRXpNaFVSRkNzQklqVVJOQU1nL09BSnRna0p0Z2tCTmJZSkNiWUpBVFcyQ1FtMkNRSzhaR1FKL2g0SkNRSGlDUW4rNWdrSkFSb0pDZjRlQ1FrQjRna0FBQUFBQVFBQUFHUURJQUpZQUJVQUJyTU5BQUV0S3hNaE1oWWRBVGN6RVNNbkZSUUdJeUVpSmpVUk5EWXlBZlFWSFdSa1pHUWRGZjRNRlIwZEFsZ2RGWlprL3RSa2xoVWRIUlVCa0JVZEFBTUFBQUFBQXlBRElBQUhBQndBSkFBS3R5UWRFZ2tDQUFNdEt3RXpFU01uSXhFeklUVXlGeDRCRkFZSEl3WWpOVEkzUGdFMEppY21CeGNlQVJRR0R3RUJUa0pDaHNqSUFTd2xKbUovZjJJRElpWWFHRUZWVlVFWUdoa2hLaXNnR1FNZy9PRElBWkJrQ2htaDBLSVpDV1FHRVd1TWF4RUdaQU1JTjBRM0NBTUFBZ0FBQUFBQ1dBTWdBQWNBRHdBSXRROElBZ0FDTFNzQk14RWpKeU1STXdVWEhnRVVCZzhCQVU1Q1FvYkl5QUVzR1NFcUt5QVpBeUQ4NE1nQmtHUURDRGRFTndnREFBQUFBUUFBQUFBQmtBTWdBQWNBQnJNQ0FBRXRLd0V6RVNNbkl4RXpBVTVDUW9iSXlBTWcvT0RJQVpBQUFBQURBQUFBQUFLOEF5QUFEd0FUQUJjQUNyY1ZGQkVRQndBRExTc0JNeklYQVJjVkZDTWhJajBCTndFMkF4VXpOUU1WTXpVQk5WSUlCQUVtQXduOVZna0RBU1lFQVdSa1pBTWdDZjFXRTFFSkNWRVRBcW9KL3RUSXlQN1VaR1FBQUFBREFBQUFBQUx4QXlBQUNRQVNBQm9BQ3JjWEV3MEtBd0FETFNzQk1oY0hKaU1pQnljMkVqSVhCeVlqSWdjbkZqSVdGQVlpSmpRQmQ5Q3FOWTI0czQ4MXFsanFZelZJVzFWS05xeFNPenRTT3dNZ2JWSmJXMUp0L3RRK1ZTOHZWZTQ3VWpzN1VnQUFBQUlBQUFBQUF5RURJQUFaQUNFQUNMVWVHZzhBQWkwckFUSVhCeFV6TnhZVkZBWWpJaWNCQmlJbkpqUTNBU1kxTkRZQUlnWVVGakkyTkFJbklBOWh5R0VEazJjcU1QN2dIRmdjSFIwQkl4T1Qvcm9xSFIwcUhRTWdBMkhJWVE4Z2FKSVQvdDBjSEIxV0hRRWZNQ3Rva3YxMkhTb2RIU29BQUFFQUFQK3NBeEFDdkFBWEFBYXpEUUFCTFNzVEZoYytBamNYQng0Q0Z3Y3VBaWNISnpZM0ppZU5BZndiWmxJa2ovMGNabFVtanlSVFpSdjlqVFBIK1FFQ3ZBSDVIR1ZUSm8zOUcyVlRKSThtVldZYy9ZOHd4L3dCQUFBQUFRQUFBQUFDdkFNZ0FCY0FCck1PQUFFdEt4RXpFek1UTXdNekZTRVZJUlVoRlNNMUlUVWhOU0UxTTJUbkp1ZGs0ZUgrMUFFcy90UmsvdFFCTFA3VTRRTWcvdFFCTFA3VVpHUmt5TWhrWkdRQUFBQUFBd0FBLy80RElnTWdBQmtBSndBekFBcTNMaWdlR2cwQUF5MHJFaUFXRlJRSEZoOEJIZ0VWRkFZaklpWXZBU1luQmlNaUpoQWtJZ1lVRmpNeU56WS9BVFkxTkNVekZUTVZJeFVqTlNNMU04MEJJczBzQ0FWbkRCSThLaEVyREdRRkJFOWFrYzBCeHRDU2ttaGNSdzRSQXpYKzFHUmtaR1JrWkFNZ3paRllVUVFGWkF3ckVTbzhFZ3huQlFnc3pRRWlhWkxRa2p3WENBTkRXV2d1WkdSa1pHUUFBQUFEQUFELy9nTWlBeUFBR1FBbkFDc0FDcmNxS0I0YURRQURMU3NTSUJZVkZBY1dId0VlQVJVVUJpTWlKaThCSmljR0l5SW1FQ1FpQmhRV016STNOajhCTmpVMEJTRVZJYzBCSXMwc0NBVm5EQkk4S2hFckRHUUZCRTlha2MwQnh0Q1NrbWhjUnc0UkF6WCtjQUVzL3RRRElNMlJXRkVFQldRTUt4RXFQQklNWndVSUxNMEJJbW1TMEpJOEZ3Z0RRMWxvTm1RQUFRQUFBQUVabVNzSzF6VmZEenoxQUFzRElBQUFBQURQMlM5cUFBQUFBTS9aTDJvQUFQK2JBeUlESUFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVArYkFFZ0RoQUFBQUFBRElnQUJBQUFBQUFBQUFBQUFBQUFBQUFBQTRRRWdBQm9BQUFBQUFRb0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQWxnQUFBTWdBQUFCa0FBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQmtBQUFBWkFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFPRUFBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUE0UUFBQUpZQUFBRGhBQUFBbGdBQUFKWUFBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUs4QUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWZRQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUFaQUFBQU1nQUFBRElBQUFBNFFBQUFNZ0FBQURJQUFBQTRRQUFBQUFBQUFBQUFBV0FCWUFGZ0E0QUZvQWVBQ1lBTUFBNWdFT0FVd0JZZ0dJQWE0QjBnSDJBZ3dDSWdJNEFrNENaQUo2QW80Q3RnTUFBeUlEVkFOMkE4Z0Q3Z1FNQkZZRWZnU3FCT2dFL0FVc0JUNEZYZ1djQmRZR0lBWllCdUlIRmdkWUI1UUg1QWYwQ0FZSUdBZ3FDSGdJbGdpMkNNd0k0Z2o0Q1E0Sk1nbGVDWm9KekFvUUNrWUthZ3FnQ3NZTERBc3FDMGdMYUF1R0Mvb01FZ3hNREc0TW9BelVEUVlOWUEyQURad054QTN5RGlRT2RnNlNEcXdPMWc3K0R6WVBUZzltRDRRUG9BL0tFQVlRT0JCV0VIWVFsQkN5RU5ZUktCRnNFWWdSekJIcUVnWVNLQkp3RXBJU3RoTStFMkFUMGhRYUZFWVVnQlRJRlFBVkhoVTRGVm9WZ0JYSUZnUVdKaFpNRm5JV21CYklGdndYSWhlWUdCWVltQmpRR1NnWlBCbGdHWUlacWhuU0dmNGFQQnBvR3JRYXpCcmVHdlFiREJza0d6d2JWQnRrRzM0Ym5CdndIQUFjT0J4WUhJQWNzaHorSFJvZFpCMk1IYm9kN0I0aUhrQWVYQjZVSHNJZTdoOGlIM1lmd0NBK0lIZ2dvaUMrSU5ZZzhDRWVJVndoa2lIRUllSWlHaUpDSW1BaWlpSzBJdndqR0NPUUk4SWo0aVFPSkVva2NDU2NKTVlrK2lVMEpYb2xuQ1hhSmdRbVJpYVlKdGdtL2ljK0oySW5lQ2VvSjl3b0dDaEdLSEFvd2lrTUFBQUFBUUFBQU9JQWFBQVFBQUFBQUFBQ0FBQUFBQUJ6QUFBQU5ndHNBQUFBQUFBQUFBNEFyZ0FCQUFBQUFBQUFBRUlBaGdBQkFBQUFBQUFCQUFVQTFRQUJBQUFBQUFBQ0FBWUE2UUFCQUFBQUFBQURBQ1FCT2dBQkFBQUFBQUFFQUFrQmN3QUJBQUFBQUFBRkFBNEJtd0FCQUFBQUFBQUdBQXNCd2dBREFBRUVDUUFBQUlRQUFBQURBQUVFQ1FBQkFBb0F5UUFEQUFFRUNRQUNBQXdBMndBREFBRUVDUUFEQUVnQThBQURBQUVFQ1FBRUFCSUJYd0FEQUFFRUNRQUZBQndCZlFBREFBRUVDUUFHQUJZQnFnQkRBSElBWlFCaEFIUUFaUUJrQUNBQVlnQjVBQ0FBVUFBdUFFb0FMZ0FnQUU4QWJnQnZBSElBYVFBZ0FIY0FhUUIwQUdnQUlBQkdBRzhBYmdCMEFFWUFid0J5QUdjQVpRQWdBRElBTGdBd0FDQUFLQUJvQUhRQWRBQndBRG9BTHdBdkFHWUFid0J1QUhRQVpnQnZBSElBWndCbEFDNEFjd0JtQUM0QWJnQmxBSFFBS1FBQVEzSmxZWFJsWkNCaWVTQlFMa291SUU5dWIzSnBJSGRwZEdnZ1JtOXVkRVp2Y21kbElESXVNQ0FvYUhSMGNEb3ZMMlp2Ym5SbWIzSm5aUzV6Wmk1dVpYUXBBQUJKQUdNQWJ3QnVBSE1BQUVsamIyNXpBQUJwQUdNQWJ3QnVBR2tBWXdBQWFXTnZibWxqQUFCR0FHOEFiZ0IwQUVZQWJ3QnlBR2NBWlFBZ0FESUFMZ0F3QUNBQU9nQWdBRlVBYmdCMEFHa0FkQUJzQUdVQVpBQXhBQ0FBT2dBZ0FERUFMUUEzQUMwQU1nQXdBREVBTkFBQVJtOXVkRVp2Y21kbElESXVNQ0E2SUZWdWRHbDBiR1ZrTVNBNklERXROeTB5TURFMEFBQlZBRzRBZEFCcEFIUUFiQUJsQUdRQU1RQUFWVzUwYVhSc1pXUXhBQUJXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURFQUxnQXhBQ0FBQUZabGNuTnBiMjRnTVM0eExqRWdBQUJ2QUhBQVpRQnVBQzBBYVFCakFHOEFiZ0JwQUdNQUFHOXdaVzR0YVdOdmJtbGpBQUFDQUFBQUFBQUEvNE1BTWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPSUFBQUFCQUFJQkFnRURBUVFCQlFFR0FRY0JDQUVKQVFvQkN3QkVBRVVBUmdCSEFFZ0FTUUVNQVEwQkRnRVBBUkFCRVFFU0FSTUJGQUVWQVJZQkZ3RVlBUmtCR2dFYkFSd0JIUUVlQVI4QklBRWhBU0lCSXdFa0FTVUJKZ0VuQVNnQktRRXFBU3NCTEFFdEFTNEJMd0V3QVRFQk1nRXpBVFFCTlFFMkFUY0JPQUU1QVRvQk93RThBVDBCUGdFL0FVQUJRUUZDQVVNQlJBRkZBVVlCUndGSUFVa0JTZ0ZMQVV3QlRRRk9BVThCVUFGUkFWSUJVd0ZVQVZVQlZnRlhBVmdCV1FGYUFWc0JYQUZkQVY0Qlh3RmdBV0VCWWdGakFXUUJaUUZtQVdjQmFBRnBBV29CYXdGc0FXMEJiZ0Z2QVhBQmNRRnlBWE1CZEFGMUFYWUJkd0Y0QVhrQmVnRjdBWHdCZlFGK0FYOEJnQUdCQVlJQmd3R0VBWVVCaGdHSEFZZ0JpUUdLQVlzQmpBR05BWTRCandHUUFaRUJrZ0dUQVpRQmxRR1dBWmNCbUFHWkFab0Jtd0djQVowQm5nR2ZBYUFCb1FHaUFhTUJwQUdsQWFZQnB3R29BYWtBb0FHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnVBRzVBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJ4d0hJQWNrQnlnSExBY3dCelFIT0FjOEIwQUhSQWRJQjB3SFVBZFVCMWdIWEFkZ0IyUUFCTVFFeUFUTUJOQUUxQVRZQk53RTRBVGtDTVRBQ01URUNNVElDTVRNQ01UUUNNVFVDTVRZQ01UY0NNVGdDTVRrQ01XRUNNV0lDTVdNQ01XUUNNV1VDTVdZQ01qQUNNakVDTWpJQ01qTUNNalFDTWpVQ01qWUNNamNDTWpnQ01qa0NNbUVDTW1JQ01tTUNNbVFDTW1VQ01tWUNNekFDTXpFQ016SUNNek1DTXpRQ016VUNNellDTXpjQ016Z0NNemtDTTJFQ00ySUNNMk1DTTJRQ00yVUNNMllDTkRBQ05ERUNORElDTkRNQ05EUUNORFVDTkRZQ05EY0NORGdDTkRrQ05HRUNOR0lDTkdNQ05HUUNOR1VDTkdZQ05UQUNOVEVDTlRJQ05UTUNOVFFDTlRVQ05UWUNOVGNDTlRnQ05Ua0NOV0VDTldJQ05XTUNOV1FDTldVQ05XWUNOakFDTmpFQ05qSUNOak1DTmpRQ05qVUNOallDTmpjQ05qZ0NOamtDTm1FQ05tSUNObU1DTm1RQ05tVUNObVlDTnpBQ056RUNOeklDTnpNQ056UUNOelVDTnpZQ056Y0NOemdDTnprQ04yRUNOMklDTjJNQ04yUUNOMlVDTjJZQ09EQUNPREVDT0RJQ09ETUNPRFFDT0RVQ09EWUNPRGNDT0RnQ09Ea0NPR0VDT0dJQ09HTUNPR1FDT0dVQ09HWUNPVEFDT1RFQ09USUNPVE1DT1RRQ09UVUNPVFlDT1RjQ09UZ0NPVGtDT1dFQ09XSUNPV01DT1dRQ09XVUNPV1lDWVRBQ1lURUNZVElDWVRNQ1lUUUNZVFVDWVRZQ1lUY0NZVGdDWVRrQ1lXRUNZV0lDWVdNQ1lXUUNZV1lDWWpBQ1lqRUNZaklDWWpNQ1lqUUNZalVDWWpZQ1lqY0NZamdDWWprQ1ltRUNZbUlDWW1NQ1ltUUNZbVVDWW1ZQ1l6QUNZekVDWXpJQ1l6TUNZelFDWXpVQ1l6WUNZemNDWXpnQ1l6a0NZMkVDWTJJQ1kyTUNZMlFDWTJVQ1kyWUNaREFDWkRFQ1pESUNaRE1DWkRRQ1pEVUNaRFlDWkRjQ1pEZ0NaRGtDWkdFQ1pHSUNaR01DWkdRQ1pHVUFBQUVBQWYvL0FBOEFBQUFBQUFBQUFBQUFBQUN3QUN3Z3NBQlZXRVZaSUNCTHVBQU9VVXV3QmxOYVdMQTBHN0FvV1dCbUlJcFZXTEFDSldHNUNBQUlBR05qSTJJYklTR3dBRm13QUVNalJMSUFBUUJEWUVJdHNBRXNzQ0JnWmkyd0Fpd2daQ0N3d0ZDd0JDWmFzaWdCQ2tORlkwVlNXMWdoSXlFYmlsZ2dzRkJRV0NHd1FGa2JJTEE0VUZnaHNEaFpXU0N4QVFwRFJXTkZZV1N3S0ZCWUliRUJDa05GWTBVZ3NEQlFXQ0d3TUZrYklMREFVRmdnWmlDS2ltRWdzQXBRV0dBYklMQWdVRmdoc0FwZ0d5Q3dObEJZSWJBMllCdGdXVmxaRzdBQksxbFpJN0FBVUZobFdWa3RzQU1zSUVVZ3NBUWxZV1Fnc0FWRFVGaXdCU05Dc0FZalFoc2hJVm13QVdBdHNBUXNJeUVqSVNCa3NRVmlRaUN3QmlOQ3NRRUtRMFZqc0FwRHNBQmdSYkFES2lFZ3NBWkRJSW9naXJBQks3RXdCU1dLVVZoZ1VCdGhVbGxZSTFraElMQkFVMWl3QVNzYkliQkFXU093QUZCWVpWa3RzQVVzc0FkREs3SUFBZ0JEWUVJdHNBWXNzQWNqUWlNZ3NBQWpRbUd3QW1KbXNBRmpzQUZnc0FVcUxiQUhMQ0FnUlNDd0MwTmp1QVFBWWlDd0FGQllzRUJnV1dhd0FXTmdSTEFCWUMyd0NDeXlCd3NBUTBWQ0tpR3lBQUVBUTJCQ0xiQUpMTEFBUXlORXNnQUJBRU5nUWkyd0Npd2dJRVVnc0FFckk3QUFRN0FFSldBZ1JZb2pZU0JrSUxBZ1VGZ2hzQUFic0RCUVdMQWdHN0JBV1ZranNBQlFXR1Zac0FNbEkyRkVSTEFCWUMyd0N5d2dJRVVnc0FFckk3QUFRN0FFSldBZ1JZb2pZU0Jrc0NSUVdMQUFHN0JBV1NPd0FGQllaVm13QXlVallVUkVzQUZnTGJBTUxDQ3dBQ05Dc2dzS0EwVllJUnNqSVZrcUlTMndEU3l4QWdKRnNHUmhSQzJ3RGl5d0FXQWdJTEFNUTBxd0FGQllJTEFNSTBKWnNBMURTckFBVWxnZ3NBMGpRbGt0c0E4c0lMQVFZbWF3QVdNZ3VBUUFZNG9qWWJBT1EyQWdpbUFnc0E0alFpTXRzQkFzUzFSWXNRUmtSRmtrc0ExbEkzZ3RzQkVzUzFGWVMxTllzUVJrUkZrYklWa2tzQk5sSTNndHNCSXNzUUFQUTFWWXNROFBRN0FCWVVLd0R5dFpzQUJEc0FJbFFyRU1BaVZDc1EwQ0pVS3dBUllqSUxBREpWQllzUUVBUTJDd0JDVkNpb29naWlOaHNBNHFJU093QVdFZ2lpTmhzQTRxSVJ1eEFRQkRZTEFDSlVLd0FpVmhzQTRxSVZtd0RFTkhzQTFEUjJDd0FtSWdzQUJRV0xCQVlGbG1zQUZqSUxBTFEyTzRCQUJpSUxBQVVGaXdRR0JaWnJBQlkyQ3hBQUFUSTBTd0FVT3dBRDZ5QVFFQlEyQkNMYkFUTEFDeEFBSkZWRml3RHlOQ0lFV3dDeU5Dc0FvanNBQmdRaUJnc0FGaHRSQVFBUUFPQUVKQ2ltQ3hFZ1lyc0hJckd5SlpMYkFVTExFQUV5c3RzQlVzc1FFVEt5MndGaXl4QWhNckxiQVhMTEVERXlzdHNCZ3NzUVFUS3kyd0dTeXhCUk1yTGJBYUxMRUdFeXN0c0Jzc3NRY1RLeTJ3SEN5eENCTXJMYkFkTExFSkV5c3RzQjRzQUxBTks3RUFBa1ZVV0xBUEkwSWdSYkFMSTBLd0NpT3dBR0JDSUdDd0FXRzFFQkFCQUE0QVFrS0tZTEVTQml1d2Npc2JJbGt0c0I4c3NRQWVLeTJ3SUN5eEFSNHJMYkFoTExFQ0hpc3RzQ0lzc1FNZUt5MndJeXl4QkI0ckxiQWtMTEVGSGlzdHNDVXNzUVllS3kyd0ppeXhCeDRyTGJBbkxMRUlIaXN0c0Nnc3NRa2VLeTJ3S1N3Z1BMQUJZQzJ3S2l3Z1lMQVFZQ0JESTdBQllFT3dBaVZoc0FGZ3NDa3FJUzJ3S3l5d0tpdXdLaW90c0N3c0lDQkhJQ0N3QzBOanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ0kyRTRJeUNLVlZnZ1J5QWdzQXREWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqWUNOaE9Cc2hXUzJ3TFN3QXNRQUNSVlJZc0FFV3NDd3FzQUVWTUJzaVdTMndMaXdBc0EwcnNRQUNSVlJZc0FFV3NDd3FzQUVWTUJzaVdTMndMeXdnTmJBQllDMndNQ3dBc0FGRlk3Z0VBR0lnc0FCUVdMQkFZRmxtc0FGanNBRXJzQXREWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqc0FFcnNBQVd0QUFBQUFBQVJENGpPTEV2QVJVcUxiQXhMQ0E4SUVjZ3NBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZTEFBUTJFNExiQXlMQzRYUEMyd015d2dQQ0JISUxBTFEyTzRCQUJpSUxBQVVGaXdRR0JaWnJBQlkyQ3dBRU5oc0FGRFl6Z3RzRFFzc1FJQUZpVWdMaUJIc0FBalFyQUNKVW1LaWtjalJ5TmhJRmhpR3lGWnNBRWpRckl6QVFFVkZDb3RzRFVzc0FBV3NBUWxzQVFsUnlOSEkyR3dDVU1yWllvdUl5QWdQSW80TGJBMkxMQUFGckFFSmJBRUpTQXVSeU5ISTJFZ3NBUWpRckFKUXlzZ3NHQlFXQ0N3UUZGWXN3SWdBeUFic3dJbUF4cFpRa0lqSUxBSVF5Q0tJMGNqUnlOaEkwWmdzQVJEc0FKaUlMQUFVRml3UUdCWlpyQUJZMkFnc0FFcklJcUtZU0N3QWtOZ1pDT3dBME5oWkZCWXNBSkRZUnV3QTBOZ1diQURKYkFDWWlDd0FGQllzRUJnV1dhd0FXTmhJeUFnc0FRbUkwWmhPQnNqc0FoRFJyQUNKYkFJUTBjalJ5TmhZQ0N3QkVPd0FtSWdzQUJRV0xCQVlGbG1zQUZqWUNNZ3NBRXJJN0FFUTJDd0FTdXdCU1Zoc0FVbHNBSmlJTEFBVUZpd1FHQlpackFCWTdBRUptRWdzQVFsWUdRanNBTWxZR1JRV0NFYkl5RlpJeUFnc0FRbUkwWmhPRmt0c0Rjc3NBQVdJQ0Fnc0FVbUlDNUhJMGNqWVNNOE9DMndPQ3l3QUJZZ3NBZ2pRaUFnSUVZalI3QUJLeU5oT0Myd09TeXdBQmF3QXlXd0FpVkhJMGNqWWJBQVZGZ3VJRHdqSVJ1d0FpV3dBaVZISTBjallTQ3dCU1d3QkNWSEkwY2pZYkFHSmJBRkpVbXdBaVZodVFnQUNBQmpZeU1nV0dJYklWbGp1QVFBWWlDd0FGQllzRUJnV1dhd0FXTmdJeTRqSUNBOGlqZ2pJVmt0c0Rvc3NBQVdJTEFJUXlBdVJ5TkhJMkVnWUxBZ1lHYXdBbUlnc0FCUVdMQkFZRmxtc0FGakl5QWdQSW80TGJBN0xDTWdMa2F3QWlWR1VsZ2dQRmt1c1NzQkZDc3RzRHdzSXlBdVJyQUNKVVpRV0NBOFdTNnhLd0VVS3kyd1BTd2pJQzVHc0FJbFJsSllJRHhaSXlBdVJyQUNKVVpRV0NBOFdTNnhLd0VVS3kyd1BpeXdOU3NqSUM1R3NBSWxSbEpZSUR4WkxyRXJBUlFyTGJBL0xMQTJLNG9nSUR5d0JDTkNpamdqSUM1R3NBSWxSbEpZSUR4WkxyRXJBUlFyc0FSRExyQXJLeTJ3UUN5d0FCYXdCQ1d3QkNZZ0xrY2pSeU5oc0FsREt5TWdQQ0F1SXppeEt3RVVLeTJ3UVN5eENBUWxRckFBRnJBRUpiQUVKU0F1UnlOSEkyRWdzQVFqUXJBSlF5c2dzR0JRV0NDd1FGRllzd0lnQXlBYnN3SW1BeHBaUWtJaklFZXdCRU93QW1JZ3NBQlFXTEJBWUZsbXNBRmpZQ0N3QVNzZ2lvcGhJTEFDUTJCa0k3QURRMkZrVUZpd0FrTmhHN0FEUTJCWnNBTWxzQUppSUxBQVVGaXdRR0JaWnJBQlkyR3dBaVZHWVRnaklEd2pPQnNoSUNCR0kwZXdBU3NqWVRnaFdiRXJBUlFyTGJCQ0xMQTFLeTZ4S3dFVUt5MndReXl3TmlzaEl5QWdQTEFFSTBJak9MRXJBUlFyc0FSRExyQXJLeTJ3UkN5d0FCVWdSN0FBSTBLeUFBRUJGUlFUTHJBeEtpMndSU3l3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckF4S2kyd1JpeXhBQUVVRTdBeUtpMndSeXl3TkNvdHNFZ3NzQUFXUlNNZ0xpQkdpaU5oT0xFckFSUXJMYkJKTExBSUkwS3dTQ3N0c0Vvc3NnQUFRU3N0c0Vzc3NnQUJRU3N0c0V3c3NnRUFRU3N0c0Uwc3NnRUJRU3N0c0U0c3NnQUFRaXN0c0U4c3NnQUJRaXN0c0ZBc3NnRUFRaXN0c0ZFc3NnRUJRaXN0c0ZJc3NnQUFQaXN0c0ZNc3NnQUJQaXN0c0ZRc3NnRUFQaXN0c0ZVc3NnRUJQaXN0c0ZZc3NnQUFRQ3N0c0Zjc3NnQUJRQ3N0c0Znc3NnRUFRQ3N0c0Zrc3NnRUJRQ3N0c0Zvc3NnQUFReXN0c0Zzc3NnQUJReXN0c0Z3c3NnRUFReXN0c0Ywc3NnRUJReXN0c0Y0c3NnQUFQeXN0c0Y4c3NnQUJQeXN0c0dBc3NnRUFQeXN0c0dFc3NnRUJQeXN0c0dJc3NEY3JMckVyQVJRckxiQmpMTEEzSzdBN0t5MndaQ3l3Tnl1d1BDc3RzR1Vzc0FBV3NEY3JzRDByTGJCbUxMQTRLeTZ4S3dFVUt5MndaeXl3T0N1d095c3RzR2dzc0RncnNEd3JMYkJwTExBNEs3QTlLeTJ3YWl5d09Tc3VzU3NCRkNzdHNHc3NzRGtyc0RzckxiQnNMTEE1SzdBOEt5MndiU3l3T1N1d1BTc3RzRzRzc0RvckxyRXJBUlFyTGJCdkxMQTZLN0E3S3kyd2NDeXdPaXV3UENzdHNIRXNzRG9yc0QwckxiQnlMTE1KQkFJRFJWZ2hHeU1oV1VJcnNBaGxzQU1rVUhpd0FSVXdMUUJMdUFESVVsaXhBUUdPV2JBQnVRZ0FDQUJqY0xFQUJVS3hBQUFxc1FBRlFyRUFDQ3F4QUFWQ3NRQUlLckVBQlVLNUFBQUFDU3F4QUFWQ3VRQUFBQWtxc1FNQVJMRWtBWWhSV0xCQWlGaXhBMlJFc1NZQmlGRll1Z2lBQUFFRVFJaGpWRml4QXdCRVdWbFpXYkVBRENxNEFmK0ZzQVNOc1FJQVJBQT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLnR0ZlxuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMudHRmXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQURxSUFBOEFBQUFBYlh3QUFSbVpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJXQUFBQUJvQUFBQWNhL0FCcEU5VEx6SUFBQUYwQUFBQVJnQUFBR0EwQmxGaVkyMWhjQUFBQWJ3QUFBQkNBQUFCUWdBUDVJbGpkblFnQUFBQ0FBQUFBQW9BQUFBS0FBQUFBR1p3WjIwQUFBSU1BQUFGa2dBQUMyeStiK1k1WjJGemNBQUFCNkFBQUFBSUFBQUFDQUFBQUJCbmJIbG1BQUFIcUFBQUs0TUFBRklZU09YdXJtaGxZV1FBQURNc0FBQUFNQUFBQURZQjg3dEZhR2hsWVFBQU0xd0FBQUFlQUFBQUpBYU1CQUZvYlhSNEFBQXpmQUFBQUdNQUFBT0dtcDRBR214dlkyRUFBRFBnQUFBQnhnQUFBY2FqdW85RWJXRjRjQUFBTmFnQUFBQWVBQUFBSUFHY0M5WnVZVzFsQUFBMXlBQUFBV2tBQUFKOGp2WVF4WEJ2YzNRQUFEYzBBQUFDN0FBQUJHUHRFRFArY0hKbGNBQUFPaUFBQUFCbEFBQUFlOTFyQTRWNG5HTmdZR0JrQUlJenRvdk9nK2p6Ti9XellEUUFUUFVHL2dBQWVKeGpZR0g2eHppQmdaV0JnWW1EeVlDQmdhRUFRak0yTUtnem5BZUtNckF5TThDQkFJTEpFSkRtbXNKdzRBSERnM3ZNQ2tDdUI1Qk1CZEtNU0VvVUdCZ0I5U1FKNWdBQWVKeGpZR0JnWm9CZ0dRWkdCaEN3QWZJWXdYd1dCZ1VnelFLRVFQNkRlLy8vQTBtRy8vOFZtS0VxR1JqWkdHQk1Ca1ltSU1IRWdBb1lHWVk5QUFBYmVRZDVBQUFBQUFBQUFBQUFBQUFBQUFCNG5LMVdhWFBVUmhBZDdlRVRIOEVIQ1VwZ3hIZ2RzeG90NWpJR0ZtT2tYUy9nSE9zcmtTQ0g1RjA3OThVbmZvTitUV3RKcXNnM2ZscGV6eDdZWUNkVlZDaHErMDNyYWFiN2RVL0xKTFFrc1JmV0l5azNYNHJKclUwYTJua1MwZzJibHFMNFVLWjdJZVZLeWQ4allrUzBXbXJmZGh3U0VZbEExVHJDRWtIc2UyUnBrdkdoUnprdDI1SmVOYW13K0tTelpJMEY5Vlo5KzJub0tNZE9RMG5OWnVqUWVtUkxXbVcwR2tVeTY1S1NOaTNCMVZ0Sld1Ym55OHg4MVF3bGdrZ1RTV1BOTUlaSDhyTXhSaXVNVm1JN2pxTElKc3VOSWtXaUdSNUVrVWQ1TGJGUG9aUWdvR0xRREttb2ZCcFNQc0tQeUlvOUttaUZ1R1E3Sys3N2twOTBENmV4Z0VSY3AzelpnVGVRcVV5eGM3WmNMS1ZiWWR5MGsrMG9WQkdlcmUrRWVHQnpRcjFUUFNwcUdnN2Nqc2gxWlJuQ1V2a0s4aW8vb2R6K0lWa3RuRTNGc2tmRFduS0E0MEhyWlVIc1M5NkIxdU9JS1hITkJEaWlPOFBqSXFqN1pXY2c5S2crTHZ4WWR4ZkxSUWdCc28xbFBWVUpGOEdvSkd4V2txU05JUHRSVXI2a2tscjNpUEZUWHFjRnZDWHMxNmtkZmVtTU5nbDF4c2Z5OWRDeGxST1ZIWThtZEpiTDFhbWQxRHlhMUNCS1NXZUN4L3c2Z1BJam11RFZObFlUV0hrMGhXMm1qU1FTQ3JSd0xrMEdzVXhqU1pNUXphTnB2YmtiWm9WMkxWcWdpUVAxM0tQMzlPWld1TG5UZGRvTy9EUEdmMVpuWWlyWUM3T3BxWUNzeEtjcGx4c1ViZXRuWi9obkFqOWt6YU1TK1ZJenpGZzhaT3VuS0M0ZlczWVVYdXRqdS91Y1gwSGZzeWRDSmczRTM0RDNlS2xPS1dBbXhJeUNXbWlsdFk1bFdhWldNMXBrSWxmZkRXbEsrYkpPNDJqSU1lZ2IrekxHOFg5TlQxdGlVdmgrR21kbmgxeDY1dHFYSU5Nc2NwdHhQWnJUbWNWMkhqcXpQYWV6UE52M2RWWmcrNEhPaW16UDYyeUlyYTJ6WWJZZjZteUU3VWM2RzJWN1FRdWFjTjhoa0lzSTVBSTJrQWlFcllOQTJGNUNJR3dWQW1HN2dFRFlsaEFJMjBVRXd2WmpCTUoyQ1lHd3ZheGwxZlJUV2VQWTZWZ0dLRUljR00xeFJ5NXpVN21heWk2VmNWMDBPclVoVDVGYkphdUs1OVMvTXRBdkhubURHbGp6cE10a3pTMmI1Q3BIVlRuKzZJcVdOMDJjeStCWTliYzN4L1U1OFZEMmkvay9CZitycmFuVjdJbzFoMHl1SW04RWVuS2M2TnBrMWFOcnVuS3U2dEgxLzZLaXcxcWczMEFweEh4SlZtU0RieVlrZkpTbURkWEFWUTR4cnpIdmNGMnZXOWJjTE02L2lSRXlqKzdIZjBPaDBjQTlTQ3RLeW1xS3ZWWmVQNWFWN2g1VXdKNWdTWXI1TXE5dmhTOXlNaS90RjduRi9Qbkk1d0UzZ2tHcERGdHQ0R29GYjk2VG1JZE1kNHJuZ3JpdEtCOGtiVHpPQllrTkhQT0FlZk9kQkNIaFE2STJVRHVGRXphUUY0dzVCZnVkY0lqcWpySUNiaSswTDZLUmltL3RpaDA1bzVJSkFyL043Z2g3ZlJaS2ZvczFrUEFVRjNzYXFDcWtXVFZ1R3NHbGtYSkROZmd3cnRadEl4a24wRk5VN0lZVldjVkhqeVB1T1NYSDBwZDhxSVRWbzZPZjFXNmhUdXJjWG1VVXQrK2RYZ1JCdnpReGYzZmZUTEZmeXJ0YXlRcXJ0b0dwVzQwcW1Xdk40dUpWQis3bVVmZTk0K3dUT1d1YWJyb25ibnBmMDRxYjRtQnVGa1Q3TmdkbHFaQUw2dnFndy9ycWNuTXB0SG9GbDZTNzNRTU1Dd3pvZDJqRnh2L1ZmUncrejVXcXd1ZzRVbThuNnNYb3N4ajkvQVBPMzFFOUFYcDVERkt1SWVXNTd1WEVweHYzY0taQ1YzRVg2NmY0TnpCcnJka1p1Z2JjMEhRRDVpR3JWb2V1Y2dQZnFiNU9qelMzSXowRWZLdzdRandBMkFTd0dIeWlPNWJ4ZkFwZ1BKOHh4d2Y0bkRrTW1zeGhzTVVjQnR2TVdRUFlZUTZEWGVZdzJHTU9neStZc3c3d0pYTVloTXhoRURHSHdSUG1CQUJQbWNQZ0srWXcrSm81REw1aHpuMkFiNW5ESUdZT2c0UTVEUFkxM1JySTNPSUYzUVZxRzFRRk9qRDloTVU5TEE0MXJRN1kzL0hDc0w4M2lOay9HTVRVSHpYZEhsQi80b1doL213UVUzOHhpS20vYXJvem9QN0dDMFA5M1NDbS9tRVFVNS9wRjZPRlhQOHZJOStsa1FQS0x6U2Y4L2ZFK3dja2ZFQUJBQUFBQVFBQi8vOEFEM2ljblh3TGxCdmxsV2I5VlpKS3BmZXJWUDNRVzkxU3ExdnVka3N0cWQyeTFiYkJ1TEhCajhZMkFrTW5rRXBzVElBT0Q1c1lPeUZobG1TeTQ5QzBzNW93eVNhTUF6NU00R3c4VEV3eWJDK2VZWWFoenVhWUpYTjhKcnMrQ3dNek9ja2VrOGNrNDUwa1BuU3g5LzUvbFZScW13Mk0zVks5Ly9vZjk3LzN1L2QrdnppZTYrTTQ3bWU4ekFtY3lEbFBPMnlFNDFlTmxJUGxZTDRjelBiOS9mZS84UTFlWG42bmo3ek44WEFuSjZUNEpialRCL2U2bkR6ZVM5TEJkQVUrU1NKV1lJY1V5VVhkUXhiMGVWWFQ5SG15d0M4dFg2MlNpMnFycGFxWGxlSHRMa09VMC9BL2J5a0R2elN6Q1BqWDRqZ0NSYWkwREQvbitBc0hSMWFOaEZMUk9DbUwrWEpsSXBkeHlCTm5TZVlzdkY1ZGZIMlJYenI3ZUVuVFN2c1hGL2MvdnVKWk56N0xwYUl5UG1VV1FNYmhZWGdRbjhlSDhVRXM0SEdzdXExZGYrd3ZONVRpWGUveWVWeE9oNDNuYkt0R2dsQi9CVDZpc1JWUzc3Nmw4czNsWjlUMkhyK2tzbjhmdER6cmZ5d0ZDekczMXNMK1BYWFRzQkN0dmRkVk56dkh2ZmROV3A0ZFNndHlVYTZmODYvMzlDdmhVTURqZEFpY0hRYXVwSWlEVlZHeDV5b1RnMUU1SW1ZSHc2TWtiMC83aUVnV1BubjdWdjJsVzA2ZDBmKzdnejgxSHppdm41aWYrK05oc3BYY1AvNnQyL21sK3RzWFN2TmZlbk5nNEprN0gvakd3UHFLL25UdzBKN1lEWGRJYkl3NWNsRkljUTRZSnh1T1V4aUUwazNLbXFyOVpobHFySHYwYzZTSXR4a3lCZmN5bVhJN2JTaFRJQk1CUnlvWEdBeG1KWklOWGlEWFhiaWdmL2NDS1dvZ1hrVW9BWS9nN0tQNk9TenB5bVc1VnBRbEVaVHhkbGtMN0VuOVhIZHBtbmFsc3J3cnlxSWpTbGFXMVNsSjB6UmFxZC9YUG9LenRXd3RCNTVjMlR5dU0yK2F0RS90MktlRTFtR1F6VGY5SE4vRTN1VXV1NWVuOTNwcDI4bEZiQy9Nem90OEV3WkNOY2FLYjY0Y0t3bkdDalRBai9RZldrYXJNLzlXMUlHMDY3Q0U3UzV3SysrbGRaRDRGVlZZb3VWcksrb2cwSHRoME9FL0taQXgyaC9zQ1c2bGJORjcrOW05Mko3T25YUSs4VXR3MzVYbkUvUjdWb0FQb1I4NVN4WlVWVk5WM01COHB4TWVGTmN6MEt4NWtEYzJQek8wVDEyY3pDVzVBcFkza0lwRkEyNEhsaGRXSEhKRUVVY0ptMG9PTVYrdFRPVHQ3S3c1ditpNSsyZWF6Wm5hT3Y2NSs5ZlZZRmYvNXFaWWJGT2Q3SzdYWVlkdnpqUS9mUlN1ZjJYMjZmdnZmM3IySzNETDBVODNyNTZKRllxeG1mcnUyYW42enQzMW1WaXhFRE5raXl4UTJmSmJaTFFValRneXVZbHd0RnlxQmZQaXdhY093cDlhSFYxVnc0YlJRLzAvaGNQNlg0T3FFQ3p5NmVjVXp2VzlVQURMRVN3eW1zRkdrSnhDb0VCb3dUdGt5enZ2NkMrOFF4YU9uSm9rMzlwMlhMOTEyMjFIVGdrcFBBa1h2M0RxeUczYnlMY21qK3EzVHNJdVo3NkQ2aUtKODhJNzZEamdPMEQ0UVlDSU1SQ2dzdDk5aTF3RXdZTlpnTjBQSjJBMFFWNU0vUWoxVk1EcTViZ1M5ditxZkxxL3Q4ZERjRHlyU29KWFlDQ0RFVWMybmNsVmd0bEtPVnhWeExRTnJVTWtXcXF1SXhNRGxuMXlMQmdrbjN6UTg3QWE4UzMvekJkUkg3N2c2MWtnS2YyWHcvSDRjSno0NlVaSUVSLzUzSmY5cXI3b2kwUjg1RzZWOUFZLzg1d1dsMVU1M3YxRng4TzBUMkVZajJCQXd2RUlwMHR4RkRFNUFoV3JCQ2VVWURvbzhkK1dWRlZhM2lPcE9CRmNMMmxuSkltL1JsTFI2SExjU2pzcDBYbTVvcHhPR1pZQ0ROMzEzdGZwc3psdURPcFJ6RWQ1ck1kRXRTNmtVVGhnMm9ZVXF2QlpYMDNVcXVGS051UElabkwyckN3NnhQUVl1YVV2TE5qdDVDSzJyZlRsbmt4QkdGbWpjNDNaVE0rWFM4UkI1RGo1cXVhWW5pUXZIM0x3WHdxbG9LdU82Zjg2VkNzM0NvWFpScmsyUkx6SFNDSit3dlhRSFQ5MmRlbEJMK3NibjRoOXc1V2dHbENWTkZTaE1oRXVvK0NTeGxNSEg5MzQ3bHNiSDFXMSttd2RKSGIyYS9mVXRtK3YzZk8xMmVVWEMvVTZMWW8yTkVmTEMwQ0pJTGRCdjgrT01oVXUyOEdtWlN0aXZwYXZLVFc1SnNxMVZvbk12ZjIyZnFLMGRXdXJ0WFVyNEptV2tMcDAvSWxMbDR3VEdpSUdqclBNQjVtTGM0TlFiaktoUk4xVVZ0TllXVEZCWkJTeENreUY0RVF1bTVaaFVzQldDTEl0dVRoN3NMaGgrK0wrNWZOUTFRSXBxcmhSVzQxbXM0Rk51YWFXZkhETC9rVVZMaTBVNnRoQTFQSE5JMDJyYnJPYnVvMEV5d1RtUmhGbmhLSGJpb2ErUk4zV0QvZUZtR3dFYXdyVUlDb0gweGxISkZxR1dZV1RvTllnTlJYcW9KYmsrUEo1SEVzK3QzeSswUlFjSTNFc0R6UmVNUzR2bjRmaFU1c05QaGVPanppTWVxQmVzWm02RzBRMkQ1aEFZMmhEczQ2blFIV1AyMGF4b0FGNXlvQUhxWlRpN2FUNEExS1EzdjIxSktSVWRkKys1VCtYSkdzL0s5Q0tQUFJ6TnRiYlEvdVpRRE5BMEVIWTJWU0d1Vm9IdFZwVm9GaFFRZWxTamMwQTZKVkMvWXdFMWI5YWprdG42Z1ZOOS9UMDhVdDlQZXhsME92U3I3REp2NUpnREFBWDZiSWthZkR5anIwWmdQYkp0SitoNTdJd2Voa1JkRjBVOVlnRGtWYWxWcTJCSGhubGNZcVE0dHdCdFZRYTY0MzFDczg5cjl4TTNsbCtKbkJqK1BCUjN1OHMxWVRVZ2JsU0tabXR4dzdGMU52MnFZYzlOMjVYdlp2WEp1Y2FteGkrTStaa2hJdHhRMXdSOWRkd0lSM3ZsZDNVZnRDcEtiZTFGN1EzaWdNSk1sVmpBMHFseXc0RGtiRUpOanUvaEMzRGxrZittQ3FxRmg2VElqMTdubS95Uyt3cURQZ1M3NDkvTkU1dlluK2FvV1RZR1BZSmNaaEQvVENHWVRZblNaSkVSZUluQUFXbmlZUTlBNVhLNUJzNEJ2ei9jUlR0ZHYzZi9MM0I3VldQbHh6U2h5YTNmZjN1TFd2WFhYdTlFQmVLZGxIL1E2K251ajNZNnljdS9lQzJ5YnUvbnNrZXVYWnltNkhUM3Z1di9HdlFCL3VnMzB0dVFuVlN1WlFrdFZIU0lLVUVjWWhLclZxbWIvUVRHQWFtckNLaXdpWmRaZ3p1eUswVGNhQWNZalFpeG9XSW1NdUxxTGlnY3RNa1Z4a2hkTGZPVjJ2NVVTTDFoMzJlUitJeHg4QzFlNjRkc01kaWo3aGRjanpndmk5aXAzMVRjbXp6UitOeXdMOWhjT1BhdUJ5SzJRaXBYeld3MFIrUTQxSC9Oa2ZKam5mWk45a2o5M3NDNUc5Q0tYRmpOTjY4ZnJKMmZUTVIzU2pHWlcrZll6THJoejdOcElac2NYaktuWjNKcGZOZnNOa2RkdnVOY2x3SkNnRmgxbVpmR0VvVk5tWGQ4S3E0YlNpVmljdVJoRDg3YWUralk4RERFS0ZQRllNeENFbDJPZ2JsRXNqQ0NDR0R3YnljRVpXb2orVHlRalpENXdMZjNDdEplL1hESkhOSnNXOTErbkxEem4xdzVnVitTVnArVVNMSGordWVvMEwwK2ZCd3dCY21BZWtGTkFwaVcyZTRxWFhDV1pma3NseDRmU0NkaXNQVWt5UEJnTmRqNTBScWFPU2dhYXhnRWhDWWVHWDhnTFcyRy90b2ZBenpwWHVvMTBFM1Fncm5uaVQ0SkhRZ3o5SHpnQjAxNnBaMDZpQjAxUUxxMEttQkNJcEVOQlVKcTBYWWZEOTh6UGVqVjRudGhScFkzNjdSU1U2K3dFNnkxMXF3UXcrWGdybTNtbUtId2lCTVBqZkRnaUNDMFRycHRMb0tCOU9reWhzemNNRFk1Z3hrUlo1NHdXbWJzemxuSld4dHMzRU1qMzdDWU1ObktOcjYxV3lkbWk3b2ZCd1RpZnhsb3duNytqazJBeWtHQzlYeEpzUFdheFJiOGgxOVMwQTl6L05OZlo2ejZHTzhUcGhkSU9oY1UvWGF4Z3VkZTFnWmtuR1BQbytsckh3UFlUZzdUUmJJQXZxajdCNm1sNU53VHhvdzdqam81ZEhoWENiRW8vMkRickdWb2trQ2lzb1BxQWdWRmN5eE1jS1FBMmQwem9DeDdRZjhZTk84ZmZZY1dYSTVoWjJDN05aUHVHVEJWL1c2V3NSTzVBVFp5YnJzV3JyaGM2RlUwRDNqZDExeStmMnV3ak9GWHBMUWI3RG9MVXY4d1FIeTR6d3RpUTdUNWdTeklnRVRCZDRGczJua0lpQXBjSWpoQ09DalI2VnQzeWdFNEZsdjJ5ZFN5Q2cvUm1wUnBjSHpuM3RNRDZldXZibG41dGpXYmZrdjM4OHZIZFBEbVMwMzlXNCtkdDBXT0tiUGwyamYyZHQra2xKVEpOSzZkS21GSGN3MzZRNk9CbWxqay9hOVJCRVZFWWFEM1Mya2NFc0hydnRlV3Erd1JBQzV0SERzNERZMmZMRERyYWdEODZtSW1CZnpPSVJZSWc0aWJsZjRuVjdvSzg4S3Z4TWVVOXJ1SzlSZG5YbU9iR3o3blpQc2VFVTU0Y3ZMcVVHem9Cc0FhT1ZGczdSTE02MlcrZGNwMFhLeTdWOVRYUkFFbE9VOEhROUpCaDZNTS91ZlJpME9Kc2RlQmcxVXRwckdpU3BLekZhM1R6L25jMi9WZjc2VlhJUURuM3Y1SUh3TEtkRHFjQnJPbE9UTm1tYWNkdk5mY3ZzNjhtMzZPejBnMzNMQTArM3ZtTE45c0N4SHdYY2JJNmJEdzN0K2UrclViMC9wSjlSTWJtWmdkY0RpOGVDRjYwNFBwR2VHVm5zc2ZkWUxkdDU1T3BlZ2JTUFlMRFJrWXJiQ1lsWnBORlhsQmdtRHVrR3pGK2N4aWdVNnZrcGUzcjg0c2tZNkE3aFEvNWZZd2RuZ1kxc0VHM0h3Y3J5bGFhMklrRnJjWHdyc0h1L3JLU0d1TEkyWFp3L3V1UmVrRHlBQTNnQVd2MnZzSXFCbG5hZjc1SlgxeUl0WnN3b0srQlVPQkZ0WjQ5M0hOTzFOK3VhYkwya0lHanJ2MURUamZZMUxKV3BGdS95VmtPbXZ0TjlEeDQyK2hSWGRiT2lOMllOWU5ML0V5bXcwUVNQdXViZXJ6bTR1QVhXV1BSU1RoRXNLV0h3SGV0SlYrK1hsWG5ybytnTi9QancxM0x0SVZuZS9BVERuZlhPQjVFUjEvNksyOGwxQ3U4NEMrS1Yra0FXdkM4MFB4YUFrSzVSRkpac2ZMQ3RpdG9iNjVKd1JYdU9iYkVQREF4cjdaNmwzRXRDczgvUkFLc0RzT0lBYlJVd1MyUThxSU84bjJUR1lzYlV4VXBrbTZKeVlHSS9NcWFYWW9abVM1OUFoVDJubVVLelVmWGppU0JNa1FVaGQ4YUo1K0VnVDcrcVNjUUUwcFF2YUJacVN0WXVGRVVXN0dVRUVTTStzQ0pwTzlJQ3N6NHJzV2FmNXJPR2xDOEU4ZG9KR3d5MzRKTE1lMmhXZWRhMThGam9CUFh1dzEvT2E1V2tXYzd0U3ZlMmRldHNWR3Yxa05nK3FiVHlQMWRiZ2ZxcFBZQ3p6WU4vWGNPdTRhN2p0WEhDOWI4dm1qWTM2VkdXOE9CVGhIRFE0QWdvR3BNandnOHZNV29IWVUvR25PZ2VNMlFRZEdOUS9OR1NBcmgwaUQ1RU4xenFTbGhrZ3lFS2ZxOWp2alJMT1JPdkJzOE00TmNoOXczR1lKQ0E4bDJScTdJcG95d0NVWCtFSmR1Q0oweWZnMmZqd3M0Qmg2UDJsRW4zYXNCZTBqMXdZUHlkbzV5ZktDTmp5Z0Z3UWVHbmdZQW1LNUhyM2dpWlpzWTlJRVZjL1lwK2VTSWdxUGR2bFNpOHYyTU9tVUs3UWV3amwxRThiVVpGdXpVZk5iSWxaNmN0dGo3UXlwb3M5WjQwaVdXSkh5ODlBaVJ5TlgxdGt5VTFqVS83MW5rakFqT0haTDQrdm04aURTZ2pBMG5hYy9YOFpsVFlob1ZGUlczditTd1lXaGI1QkhPcHoyYWxQbGpZTmtaZzJyVS9Od0orOS9DL2N2bmZmUW9NREppYms5akdWd0N5UHB2OGgycHp2R01INGpseUhPSm5hSENVYUNidFpyRUpPZzM0SVlsZ25DMDR6T0p0S0VJQkpHa0RNeTJxcGpXekpYRWsvUWVhd0NTVlZiK0NaaTNEcEJEM1BkZlVYaStNVnVRbnNyL0ZWdWY0SUhXdjc1V050OXBjNFVhM1ZlWFREMklsS0xaOHpyNjIwZldlWXN4bnhDWUl6NnR2YlcwQ2M2N2c1WUlDNGxZSkJlL3FRUDI0TDNPeEF1RnZvM2V1NzVuSTV3ZG1PZU03R2RDYU5QeE1NREJiUmk5RFBhUmlreDhuTzR1SDZ2TXB4M1RFSWZGN3N4Q0RzTENiTWRBV1dvbUhYR2RIMFRwek94Z1h3dlhhZXhlbUNhV0hRQW1oWWZvWE1XYUFMVmZyRk43dkJUS2M4TjR3dStORWV3WkIzakNsa0hQQTlxTlNveGFMT0tmYXBpaE1LZzc2TjdXQ090dk5MN3p3TjgrREkwMzNOWnZpT3E5QjJYWFZIZTF3cFRySnpUczREOVkzZ3VJYUNQcThMdFRxYkIvZ2ZvUHdncWlqNkFhZXRTQmFXcjhiR1k2dFJrTkE3UUN6SjRqNDRFelNXSzBLLy9Pc1lodVRxb0ZNU0xBY0FtbEVCNmM5V2N1QlMwNmlwWWs4UWpNbUExc3lDanN5RDBnU0VoTkFGRUVzdVB6aEtFTG5VaWFadUhVOFZWV2Z3a3R1bnVBa1pYN3VsdkxYcm5QNGVQUWQySUpvY1UrY2NQbmZKblJBMmVMYVZTK1V0NnBWT1d2cVk1VHBGbThER0dyeWNORGhEMEVxV1dlQ1hzTDFna09DN2EyelljM2FXSXlYd0lQM1E5QTgraGVOS2l2aHRlUVpqL2M3VFFUZjFNNGdNUTFtR2h5YXE2YzR1S2Q3d0FJam5LWDdlMkM2cEQ5eUFZbmJrVkh1bnF4NnNUTC9iWnRRZkZBdkdFclBFc2xzOGRRUkt3d2JSSFd3VExRNnJTM2RvalBjQ2pXR0Z1QXlVMXhObTJFNUoyQXd4YXdnMUhpUDNVUmFYeEZPa21QRU8zYlNwQnJKWDIzVFRrUGNqNEluT29xa3BnS3VhOFk3Y2U4L2lPcFRDZFl2MzNEdmkxYmZFNWRtRE1GbnJCZGt5MThCM3hINFVhRDlLaEdwZTVrTWFVOVNqbXZGQldqOGVKYmZyZnNKNkdzY0krMTdEZ1FJZGlla3pjdEhROTEzWVFjNE9HaC9NcWhrZkJyMjRycjYxZ1NaM25uYmFEZG1RN1lQd0I3T2F5cjNoNkM1UndBRDR3YUtYYlRBcWlQOThicWVkNFQ4TXRBM2E0ZWtLWUNYbVlhRXFNVktHSGhZSzFiQVJ6ZFpTcTdXVVV5MXppZFlsMjRrdGdoY0I2QlhRU3dRZ1RCYlRNako2elBsMHJaeXJaR3NBWVBubXgyNEpiSHY1aVNUWkd0Q2ZENU5DNE0yYi8rRGVQWE1IUHZsQzlUMHUvRXBBNnoyVEFTa3RIWmk4NXlZVkV6bmJEay9ldFZkZFA2QSs4bWY0WGtmYk56YnRKVm8wd0Q5UnNQV216WFNzc0puUW9UWGpnL0VVMDJhYXVxR2RVTDdNam4wWVhBbEZhUjhVR3pKYytmdXc0ZnZqVW9ZdC8zKzQ5SVBqU3FoMWgvTUF6MHJVVnZoY1RpcGJtR2tDdnhTRUdTUGorWnFHYmdFMU51Q0pxK0MxWXhvUlEvYnplR2oxTmZwQk1pcFFoL0dCVk14TFphMlVzQ1dKejViTllEaWk0VERoVjc2a3NPbGJpeHJZbEJ3dmZleTZUZU1Ea3VSUXR1OTVkTlBtTDl5eU9SZ1VQSVhSbWV2VlIyamdTWE9GWW5FNTRhUFdsbDlLVjlhdnJ3UURuc0srN1JzQVlDYVRqbWhqemFaU1JtVVJLSWN2SWNkaklSZTE0a2JlS01QL055NU5mZktCVEsrQU9xVk9XSkMyQ2hZaEFuNU0xSWpGb3VMTm8wRlRBTEdRcllJZ2lGSC8zTWFSejR3VWl4dHVEY1hsWG45RGYwVC9WM0pvT2lCL1huLzFZYktXWHlMQld6ZU1qQlNQRkRmTytYcmtlR1NEL2dnSmtLUFR2cWcvL2lQOWxUOGdheTJ4QWJSNW9Pc2RwcTVrWnM1cTJqb216UnBUNktOK2Q3YmZTKzA2cWtTZlRSbTFnVkswVFJDcUliTnAzTmVjL1pzcUl5UHJOcXh5OTlMZDlQaWE4UlRwb2Z2VGcvbzVlaXlrYklISjlmc25SMi9kUEh2TkxhUHNZR2pIK28wYk5tN1RsOW5oSjI0M1RxekFKUjdFRndZdUFSa05JNFZEU1ZleUlLU1V5V0R4WTM3d2ltcU40N2xNZmt5NExKYUZNaEhLdFd5cnBXcXRGcGp2UnplaSttRjRaZ1Zmd1U3ek1TNnp6MlFqa01yZ0swYkc4R1VzT1VBUnNkNUFDOEMxWTFIWWY2dmgzWU9VbTBOajhhSmNaV1llMDl0VjR4UUNnWXpZUVRXMUNsNEZINmEycWwvUjVQaXFHdDF2TnJSUUlEZEs5MWZWaEZTek1YNjkvNkFVbCt2KzY4Y3hlQUdIOVVZekVKb3BHa2ZuOFVKM214elVqM0NKUnBzQW8rWEZ0RklMcG11Z21hRlRXaTF5RWZwbEhyTjY5SkFkWEtFTXQwaHRROWg0bUJXbHN0dnA1TVduc1JBOG9aK2poeXZqUnRkd3UySCs3dHljWDVrbkY1V29RM1JrSExBWkphSWpBYTUrUm93cUNiREtSRVE3WEt2bWNKYlhHa0kraC9tVUhHeUVXazd4d2FTcUtnbGhtbFJ5SFM3SWptdWpVVy9VTlJLME8xdyt4Ukh1VFlsMWw0T0VwRzNld1dwZ2F2WFdSd3E4RWsrc0h1OG5KSmtJZXIzMnlOV0VDRzVIV0ZqemNuYU5YYWc2QlVrTVNORkFoMUJTRFB1emtzMm5SSnpnbFlXdXVvWmtYSW1xSUhtamQ2U2lWMDFGZXNSd0llRXZwb2ZjSVcrdlMxWWNkcmRYRFBIaHUxeEpqNU00aElqWDRZNEt1VzRmejkzaDJvQWl3SGlrZ21hZVAzTWI4c2d3L2RpMkJYRGlCeW9aVXltQ0Q3UjlkcXZOWW5tSlBEZkNqWEZscmdhWWRKb2JYSjlwckoyYXJFNlVWbzhXaDRkeUE1bFVJdGJYWTdWdEFhYVVhNWFQL1VNZW0zWlBZeHlRRDNEUVpTR3Y5SStUTHZOak8yMVUxa2N1YjRmVURYanM3N1BmQVVMZ29seHhuMW93Q25YYTM1dzFIdkIrUExNZ21yUzAzZGgyZ0RVallyQjkxTGU0MWRqR25COVVkM2k1WHJBZnJ1OGwrbVNmZy9xNE5KMWtCbStETklQTEVpMm1JeHJtVzJIUVNNL0k4WjQrdnRuWEUxNCtFT2JyaGtNWjFrL1QxT2JXTUtaMjlEZkQ0ZE9HQTBuYThsTUdmZFhIOGlaeWxrWldZVzZOa0FvOWdwZURsMEtqeUVia3hqekNCUDRJb05HU2pIRVp1VVQzWUt1Zm95RWJjdysyTU5CeHVkV1M0eXBzOVhtMk5ZL0pnaHh2NjA5cTR3ZmIvTVIyUEp1cVMreUFISzBSUFdMK0V1RHl5RzlQbFF3bXlRTW5IekFZSmZEU1UwZWdlSTAyZis2R0I4Q2RPSUg3Y0VJOVlyd3ZUTitIT1EwUEQrOExVUFZNbzF1aVJCanpwNjQvcXo5TFRzRCtMUGlWVDlYMTU4Z3VTMTFkSGM1VlBnaU9uWXk4SzlDRUtETEl2emtuNkhlQlJDMTAyeld2MWQ4T3BzUEJHaWxYOGpVbHlBQWtQbTZ5cU1CY1VUMmdJb2ZNR3QvRmZJTGZZemM0TXAyVVk3Q3NsR3ZsWUppL0ZBNHZPOExNVndWQmdIMDhwN0VVRDVNNWxzK1N1UlRvQzlmM2N1bStxSXZLWENtcU5BZ043aUhROWhHTTZWVVZta2tITlR4SzBnRElFelN1bDlOcWMrWHlYTzNXTysrOEZmYytVc1c5OHZoNE9UNDlQRHhON3FPYk9KemdtK3VucHRZLytPU0R4a1pkdTJQdHhPclZFL2lCWGM3S3gwTDhGR1U2MFV5TU9hamhwSUhEU2puQ2N0YlVDTkFJQVJGb3luRCtTRk5sWkl6cEcwc1lVWU9HMHp6aG1adldEYjdxdytGdk5QZXNIL3pVelM2NjMyMjNBekNXSXVPRHlGbEJwS21UQmo5TnN1QXVIYjdnT0tGN0RtZTJmYlJQL0JiaTArOTZWTFg1dDcvYzRPRzREOGRsTmZtbjVtY2xNL2JmdzR2dElQWVB6NHQ5djNxdFpNVjJaQzhJT2dyR0orUnVqMDgya3hmbExNWk5jcFYydnBlODlQcmk0djZVWDBBOU55YVEzVVpXZC9IMVJVR0ErVUhHL0tuOW8yWWExeXdmNUJIenpNN1RzVjZHUHcxcVIxazIrU3hscEhlQW1OT2MrcU9DelVaNVZpb0RaV3BraDRyZUJPaVpFNVRVMFNKenlPQXdwYjdiRjJKNUM0K3I3WWNGMDRObDVHUFg2RGNtRVdrdUZIUHcrSTE0R1RDbnFob3hOT1NsZkkyOEM1Zy9DQlpwSGJjRCsvZjY5YVhCV05qRmVIV01qaUhhRFpKRkxmMitaL3hHVmlZRFNwVWl4WnJDVXNaVTIrRjVzdFBsUnY2RmZvNHhMTWdDNDJQbzg5M0hCMEs5Q1prNGlCYU8rOTIrL3JCZ3N6T1NIV1dlOFM4dzVrV0w4U25ZZ1dZOW1CVGlJVGxCU0R6aTZYTmNwT3cwa2pCa0tVRXhjcDdid3RxNmZldW1WUUVubGFVdzJOVktlYkJjVmFMVTBXSHRteVpWZ0drT3l5R3BHdms2dkFkdXJVNGJ2UVNIb2dOdW5xalphVUQzVlVRL2o1Qk10RFk4TmRYeXg4Qyt0UklrbnRyZFgvVDN3OEVJMkJldkpOQkcrYnF2SklzVDl4YW1wc2hmYW96V2NCdHY5d3hQUFZWdjljVGxtTCtWMkIxUENQMUZlbENjMEg4WUlQRmhYL2ZaWkNEY1c2Zy9OZlZIZEI2aGJOcWg3WEhRazd0QU5uZGRMeEdlMGlhTnR1Wkg3U3dYV01JelJxTU5aazJ0S2laNGs0T1Rod3RHdXcydWptaTBHaGtUVzdLc3NidHU5MFM5UWJ1UDlNVmxuOGZmVnlzYjdhTzlVRG9jVGZXSWpIb1RqcTBaTmE5QjB4V2o1YTBkUXR4czh5NEhBZDlTY0lLM21oRGR2SzFzdEpRMmRPS2ZpUlBPVWZJTnRHbTBjeTN1TS91Z3RlUER4VWdRK3pDZFlyZnNVL3l6UUtjVTRxSDU3bU0wZE1pMFk0d1hWRGpPOXZ0RWF1MFVpdm9RMThyclE2UEZJVUN4TWNCK0FRK0NaMmVIdUZ1RGR6ayt3TDdCNWtJdDkrenYyK1dYMk4xRzh1UHlMV2ZOTFFrZGZvZ3dpQ3BEWlFGNGFCZlhqdTNSZURmYThJREhZZkNPQWV0QTUyRjZqV2JOS2hQbm56cUlpUG5YdTZZMGZ1bmdMS1czcXJPaHFXRlZIYmJ3OElMdHRTQm1HV25UTHJJU3lNTFVyaWtrTDg5Uzhwb0dJamJjMXJuZGNWVkxyRmJNbHllcWRpWGJqcXN1M1BBQUxtVTVSUTdDMXhFNG9ORmFUVHR5U3RYYWNkVjJmZzNMQzdFNGJSaGFoUXRNd0t3bUNacUpNbkpPTU9ZRHhVSDNsRm9JZWVoS0VmM2NwVXVhV29LUFpzU1NPU00zb0tETjhiQTFNNHFJWmVGOFMxTXdTbTJEbktmaEx3K1NReTlTeFYwdjZCN29PVngrb3hicU5HNWZxT002R296VjZFS0djZ3l5VUc2eXoydm1IQ0ppTk5uV3hHTWtsOGR0Z0NCMU80ZUdEZGZYRkYwTzFSTmFPeHdjOGFoMjhmcWJIajlMNWc0c2dGMWJGRkpuSDkrend3R1hSNExEYTBNZTFTWVY0QW45Z1lVRCt4ZmhCczRhMnczUWZJY2NsSXp4bHlNKzNrOHcwR0thMEZPL1BVWGpUalFDWlpDamhOU3BJNU1MbjdrN2xmS01ISDNnK09TUjZ5aFFOZlF6bUhDWU9RcVg0MFpSUDQva2t6MUJ2Mmo0SnRnNk9UMklCRDhxSklpaWVjUDQ0R3ZOMkptUUlnVEU5WmR4MmQ3Q0lHM0xMc2YveDVIbTFzR2NJekl4bEhyVzhDMlcvMWx3aXNJdkxrVVNaQUVHTDA3dWF6YUtSd3REam1oamFrdXM0ZW53amxRcTcrWTZxM1k4QitPT0NJNFpYUjBubWpHUDJQMVdMaGFiaFVaYXduS1BhSEtFek9sUE0yZW5BUHpqdGx2R2pWaTZtY01nYWZnc3NNaDJKNE54MmYwMmdkV1haVXJhOTV0NUVxTjl6QS9IMkw3RDNvbFhrU0N1Nkxob0taMnozTTl5QWRieXkwRzYrdXVpWnBZUFR4QkwvM1g0eEduV0ljWjEweWN3WTE1cEdkNE9FeU1iTE5QdVpURmh1cUc4S2NSQWdrV1hXK1BKN3djdGw5UlhWRTAxK1BGUW43OEMrVjBMOVIrVERWdElLVGlVRHNCUFZNVTJLY2RZTUZCbGJweUluQUU1VFQyM1VZSjNrcWpQU1NPb28rZHNBaVhwb0JNM0hIL3N6aExNMmZsNm9YVG5ZeEYreVZZdjJEUWtnMnQ4ZXVxdmthcFRRcCtPT1poM253d2RxQmNLOVFPaGszZVhHSDBIKzZXZEUybjNteEdvdnFoWmVmN0laSGFlenFSRFZyeHA4aHVNdW1ZTldySFNUU0crQkFwbCtabDZBZmtKa1IyTU9LeDdBSVppYmRDNXZVakJKeExiTUxmeHZPQ3lya2tnUm9TYU9saFFPQWxFTDV6Y01EMzArdWRQWHZncXZ6Uzk0ZVNGNklOZnZYRHk4Njl6Vm45ZFFYK1Y4ZUt5QUlKQkdXYXB0b1pOSGpQc1dUTEhvbmlxRWMxVHFRNXNXVTUyMmFzNGxCZGd2RWdXS1FjVVU3R0puWU5nd3lha0tORkM2ZGYvNzM4dzlteVI1b00vQmkxd25uSXZwTmVjdy9wOWJKYzhZZk5sK3FJc24vT2YrUmVoemtWNFI1NzU5QXd4WlJEeEtMQUQ4akZOR2lRL1NrU0NrYnpTTksrSTFFZ1Q4cWRQMWFlbUxnM3NteG40NkthYlJkSFhJMTZLa1hoOGQwSy9VQ0xsaWNVSjZmNU5SM2Y4K01rZEpNb3YxUUdxWEJ5WTJUZHcyNlk1d1JrTk9IK1QySmtBNUtyL2ZHS2hQREhoK1JUYyt1U1BkNUJBdHkvdTdPZ2tKQm1KQ3NsVzZHb3dsVVdYelQyTG53ZlBlYmdJbCtDR1VjZm1rcjF5MEV2NUlNUndobkNsVXRWbWFDU2ErTTNpR1h1MFZNTURKRVh3T1F6WTlxV2xtVkg5bnloQmlmOVVwcUFWUDc3ODR1YlhOMmZBY2hXRUZNeUVjSDc0TTN1YUt1dzljUExWNEhUdTVNYVpoaERldFF0M1QrYW1MK2NZK3J2OVpzSHlUcklPUzNsQXV1bGZidHB4ejd0djNTT2tqcjkyL1BocitqZFYxWGJmVGxYZGVaL3BIOUYxRkc1alRWT0VVcHVGbFhHR2ROQmsrSWJKYStHd1hncURoL1U1TSs1a2hCdFVWR2QwaFFUR25EcStGOGJabzNTOWxOc2hzRHlPRWlSVnV3bVR5U0JiRGtibStucjBIMzJjREQzODNObkhIL29ZQ2VqN2ZuNnUyb0F5OVB0SVlkK0I4TXVQUEg1Mkp3bjg4TUs1NGNQWEdIRWQwRTlMWmc2Ukp5dlc3dEE1SFJUelFYTmlvNEcvaFhwSkdJb0NiVUt4d2lTQVVwalhiTFdPc1VaSEEwQkIvY2hDWFFPUHFMdnZYVmZpNmd4MjFsNWExamRtVUp5dW9MZEptYkZ4cWUrSml6V05HS0dSNTJYSmlrNmVScUFjdng1RGRqR0hwNGhHaEdRQ29FdU4rUndwNm1VaXBuNjRNVFFIR0dSaTFXQWoxNWc1cTc5NUZrUUo0Q25odGlXM0hzYkZ2dlY5MmVTMjVQakM3T05ueno0K3V6QyswbDhPVTNtSVJpUm1LMmcrSnMyNDlqUmFpSElCdGtsRE0zbEc4RW5TM3VWbjlrb2FJMUpycXFUL1JOSTBpZlJKR3JQajlpdjRGTWpQNk9JcFdkWVpLc2FIeFk0QjNHa3NIYzM0N1BCaDVFSXFBMjhiK1VKampRK0poaHZJVm9hbjh3NHhKemg0TVpjSGh6VkpxaUd5cWU4Ty81US9jdFdmL2RTN0pSZTlUYjVCamszZXZ5UUovajM4MG8zNmR3ZS9NcGg3VkkxOWYrKzFaUElxL2QrdWF2NFhOZU1ZSi8yV2ZQVWFlRS9Ta0RXSzVBZ01SVmt1MVJxOEVVY2JKZmtjZUxVVGNJYWhjNEJOU2xRR0V6MlJIK1cxTlh2V1NBRkIrR25VSWNZVjc4aWFOU05lSlM0Nm9qOFZoSUJrWHFRSGZQTjlycTU4bEcvU001eGg2OGl2b0o0amRFM2JhTkZ2OEVKWlZYMDJxcUdnZ3hwT1VGUjBKWStZQnc4Vm5mcmZmR1pEZldRNG83Z1RUa2tkR2s3ei9UYlo1aGRFUHBiYnRYMndSMVJkNHh0bmNFVHExUnVySHhsTlJOenA2RkJQYjI5MWJuV2NWK3dSWjlnWFZYeUYzc3hnenlyUDl2R055MWVyM2JvMHlaVzV6ZHhlMUtXN3Jscy9XUnh3R2JyVUlLcUNJb0FLalpJTWpCdnNHSnhib1lNd0xzY2N4cG5CeTg0d0R1MzBlSERyYUgvY3UrTVRPN3p4L2pWREZTUzc5aG53QXlaNjVFWExQdm1HUVI3R0E1UEhXOTdoSFo3d2pFOVBqM3N5VTlkUlBxOEhRUWtOTjJ0bzlQR0loVjNneU5aMVpKbjdXVFBXalQ1TlZrd1Naczh6WXlBL01Lbkt0VEVZR0pZL3hxVXJtbFo2NGp1T3FLYjFqcVpPUHBFY1U5V1QzeEpVZFRUMXhMSGtXSW1tNzg2OEpxQ0p6NzMwVWs1OTdZeWc1cDUvUHRlT2N4cHI4MHg3WDZLSlBGd1BCRnFqcGxCWHAwb1dUaHc2cEorNzY2WUhqd0NFYnM3Yy84elQ3N3dqcE9pNXZRQ3I0UXh5c0xyTGxOcHJtdFBCUEFFbG9CREV5U2YxZWZ4ajVDbTJkNUpoSWNQR3RKL3JCOGNRRjdsWHN1QUFhdml4YUwzT211ek9ld0RvZUVGOTR4SnVVMU5pLzlDbnUvV1dpd3N4dlJYMnVha2RDNVpzMFJCTVJYNGdLNWM0dW5STnhpVnNKMGpoSHo2clBhbi83S25YU0U3N3p0SFpnMUNKei82RC9xTVRUNUhJazZwKy9yV2ozMUVQemxwbDEwVlpvVm1VM1ZSTWlTQXhDV05oSlJ1V1A4cER1U0RDN1JmQTFneEJxQytSalV2cVI1Nzh4OE5mL01tajZvV1QxSUV1R0NIU0pmMmxsdzcvNDVNZlVSLzl5UmRQWG1ET3RuVzlDM3QzR3ZvaXlQcmNvRm95WG55d0hTbGx4b0R5ckhDOXBENlBvYndGZElzUm5RN0g2N2pPVDZOeDBrdjZPWXF1VzJ5Wlk2RnVqY2tpTHoyT0hQaXdpK29OazcvUldWU1FwbExyRUJ1a3ZQVnRVUGhxTWFrM2tzVWlqK3pCYXo0WkNMNzFCQzRvOGFoSDRXU1N6eVhodkxybnF0WVBMTGtVanhsL2wzaGExZ1RvVHBZeFU3LzY5N2xWZDJtTDRCYjlXUDliN1U4V0R6NzNIemQzMmQ4SVhmOFZsZDNVRjZrcFVadkNRbXMwNHJhT1ZBZkNRWHNVZzNQa2FEZzhTSHhianE5YlB6TS9zMzdkOFMzRU42bWY5OXc5V1JvUkZFbnkzNWRJdnZVM084Y3FsYkdkcjd5WlROeTNmQXUvL2ZEcDQxc0draDk0WGJ6NVFYdlVUbmNhcStJcFVjakkrM1Z5RDE2ejdUQm95SmxIL21XK1ZnYXpUUi9XS0MxSHc4QXpVbGU3OVNleWNud3dRbENYb04vclJpS29qZjBRQVRnRk9GYW1Qd2ZsNFBUUU5CWjdRNk9NT1UvVGFuN3dNaTBVS0tOTU00NkgwN2E3VExFOXZ0MFo2dkQ2d09CQVovV2NhS3lkNjFxcW9sQytjTnBZdDliWmJ1Vy9oR0swZkJDK0p6RmZobmxsODV0Zmdpdm5UVEhyTEdVejFyTjE2eXkydmlpY0ZzTjUrRXVENEpMaUpmVVMvTFZoRjAwSWM1WmNOT01JNDBxRk1hN0dUWVB0VXRaSHJsNi9kbkppZFhGb0lCWHJZWnhocVN0NTFiVzZ5L1o3emcrc3VFNGVvckQ2RGJiVUswZzMrazlvT0lnRll3eVM5dklyMWp2ZU1MQTRCZCtiTFd2Qk50T0lVY3B5NWczclZRYldPemxwSExkZTVGM1RZUkt1TUV6TUZ3QmRrK0VmeElYK3kxK0U3eDNrNGh0VDhkamFtSkNDTXdONG52L2Z2b2poRVpSS0pldjh0VEd1ajhrOWxQaXFtVVhDSDhjNHAzdk1OWUgwNXpRdWFrd2Jtcnl3SnVVZ2hxQ09mamZ5RnltdkRmekp3VEt1RnpHamFScGRDVTUyUFFuYmJZZjBZZFpYVFJoaHRrUjgyMkhOd20zdkhtdVlCK2E0WG9IM2I0NVg5Y3JjZi8zemRLaCt2V3RxYXRmVVNwSTM0NUpONFRXTHZwVW9EOGxqOE9VQVpZTytCVnVOREpHYXdvK3AraE9nQnhEMDRsb1FDb2QxenpmaHJIbkNhdi93RjJ4azZCdjg4WnJML1RoRzJZWkpoY3NmY0VWbUM4RGN6SFBiVVA3TjVhamI2S21TMmgzbjdvWDU0elY1QThnRkNGckpBY2dkeUFxcFVyM1FRaXJBZkVtT3R3cDF3Q2hhb1k2TDZUSDN6K2ZxQmRQT0NFWU1EZTJNYk9WOGxaUVFvMHZoRDJuUXBieWpQRUJVNUlETnBYMzc0bklya2hoemhISURicjR4Nll3VndVak1rNFdrL2taTWppZkR5U2NpZzU1Z1JIaG92ek5tK2s3d25oak5NU2JqRVo3R3J0QlhvcjVUblJqeFVCRHVJS0ozNm5vc0JKTGhjTWd4bG9pQWVaem82L1dsOVJQRm1IT3lvZDhMZmY4blNVRndERWFlZ0pmRlpjK1RXNjVOa29XWWMvOUQrdTl3VlNqZjlrZVQzRER5NmxJS2k0bURYc1lWY2d4OFljU0FNaFdadTFiSjJqa1dCQUZNRHVLcGxxS1p3aGdOSVFmMjlxTHI5dHpEdUhqNGYwYjh1WVJmK3F1OU1PNE9wM011Z0VIby9XT0Z3YXZYb0F2M3lOK0ZoSUQrVk1TZnlQbWwxbWFMZkRFK2wwZnN4Tk1yYWZaek5EU0tUdm5GODVUQnorTG5OSGkrWXUyaG42N1Z5Z2FjeHBycmFDZGVObEVGODhmQWgyWExmbmNBWS9BZ0FsZURkMTMvSmszWDR3ZmpCNGhHTUhDRy9qY2phNUM1OWhaR3dQTHVJTTB2UkVJZWhrYzY3MkJFRVFGYVFuLy9BdUJhYWQ5eFhHNTJOVUpRK3FNU1lLcG1EeUs3Zk1YdlVHR09BUzBUeG5RRzRqMUJEMXZIWWl3bXg4bVN0dXpiTGZ1WTQ4TEZ5aTlJL0cxMG83L0JOdWVZMFpmMGhDU1JmNUxNcllhZU1QckJSaDY1WXlPWnZ1bW5tYTR5MnNpeFluNGdHZXN6ZEk5STYwT2R0YlN4dFp0YlpwQnBqUVpYYkYybkpZMi9IYjcwTi9HTDFrcUQrb0hlazA2NzJEZlU4c3daQ1QrcXRCZWNkbFhGSTF3cmZ3Wi9jcUtMUytDbnZ6b0IvWlNPeVFISjhodGI3OU5YMW4xOE4rc3JVckZ1MEtQdjlCUHJIdlBZOURWVWc2OWk2QjIyeEtnR016UnZnYUlsU2dkUUtkZklBOEtEWklBV0NqRDdrUWVrRzFuNWlERnVBSFRqUUR3a0dXc1hvVFJ3eXRPVkV1Z0VjRDZ6bVA2Q2FZaDBRNUdlOGhPeWJlUEdSeEVYRE9adS8reG5ieGN5dWI2ZURidDNiK2pwNjAwUGo2UjZEUmEzNnVyOTA5ZFA5RXFxSTNqbkg5MFpkS2lDczNaMXpTbFlja0RzdDRmOHpuWU1COTl0WC9tYTdsTE5VcXg4VjdHOUx0c293M2pXZU1iMGg5cjJIUDBoMmJUbk1IY1ZvdERmQlZsSGFxUXFBTXpDRDZuTU9tMGtKK0FQQlFna1p5UHNOd3FXOTRSM1N0TE9NUDl0Q2RFUnFvWjIrYitpdUNyRTlTRmVDSHRkWm15UGV1NzVhc2pjaTVySTV0RHIzNjRjKy81ZlBGYjVkdlBDeHlvemUzZHZxVDVubVBxN1p2ZnVuYjFMUDlmWVBUYTIreGVtLzhOMFdKcmFuelQwWGFMUHo5YmxLcUpjcmhrL3QwRVE5MC9Va0k1UzVReWp6T2RUL3R1MDI0VGorNFpYNjIvRm1yRTR6SnZ3Y2YxRkF5WUpjTkdmMnI4WUJzc1JpKytKaytUcWtmMkx5d2M3ZkxuM25xTnI0SlcyL09IaTk1cUM2WDBSYkJKR1RITDVZK1RkL2svTURqeTJIUHZFN3R4akF6ZDh2SC81V1BuVjN4RitpZnd1OXZFYmNzZVcrejkrdzhCanVkMmZpQzAvdHZyVmQwbVhINEJsKzZoTkJlUWVMZ3RsQTJsblVVSEQvN0w2MDl4UDFiZmZadFJCbFczZU5obUZpSEkxWXkyRllNbHg1a0dYdUw0M09wVG84eHFjMi9mSmN3NHdqbGNOU1JrVlhNUE5sdFpsSzJXYTkzVGE5N1h6bnJidE56OStsdndkMnB0Yk52dUNRc1ZjNG9zNTBPWk9tOTNNZ2U2ek80dnc5QjFnbXRZcVR1R3FtL2FQV3RaRVdPcUlITFRoRDF0SFZIc2ZvRzd6akhqNSsycFdWZjhmTENMYU1nQjRuR05nWkdCZ1lKU2NxYzNkSXhuUGIvT1ZnWnRaQVNqQ2NQNm1maGFDL2orYldRa3N6c0hBQkJJRkFCdHFDY3Q0bkdOZ1pHQmdWdmcvbThHRHVZVUJDSmlWR0JnWlVNRkRBRXgyQTVVQUFIaWNZMVJna0dJQUFrWXVCZ1ptQmZ5WUtZSTRPUkFibWM4NGdUaHpZVFN5ZW54MklwdVB5dzUwdDlBTFk3TVQzWjlFNHhaTS8xTERqY1RHQzFGaDJnSVZhMEhJNHdzRHZPYnZJYzRkR1A3NVFyd2Y2SjBXVU1LNkJaWE53QUFBT0E4cUxBQUFBQUFXQUJZQUZnQTRBRm9BZUFDWUFNQUE1Z0VPQVV3QllnR0lBYTRCMGdIMkFnd0NJZ0k0QWs0Q1pBSjZBbzRDdGdNQUF5SURWQU4yQThnRDdnUU1CRllFZmdTcUJPZ0UvQVVzQlQ0RlhnV2NCZFlHSUFaWUJ1SUhGZ2RZQjVRSDVBZjBDQVlJR0FncUNIZ0lsZ2kyQ013STRnajRDUTRKTWdsZUNab0p6QW9RQ2tZS2FncWdDc1lMREFzcUMwZ0xhQXVHQy9vTUVneE1ERzRNb0F6VURRWU5ZQTJBRFp3TnhBM3lEaVFPZGc2U0Rxd08xZzcrRHpZUFRnOW1ENFFQb0EvS0VBWVFPQkJXRUhZUWxCQ3lFTllSS0JGc0VZZ1J6QkhxRWdZU0tCSndFcElTdGhNK0UyQVQwaFFhRkVZVWdCVElGUUFWSGhVNEZWb1ZnQlhJRmdRV0poWk1GbklXbUJiSUZ2d1hJaGVZR0JZWW1CalFHU2daUEJsZ0dZSVpxaG5TR2Y0YVBCcG9HclFhekJyZUd2UWJEQnNrR3p3YlZCdGtHMzRibkJ2d0hBQWNPQnhZSElBY3NoeitIUm9kWkIyTUhib2Q3QjRpSGtBZVhCNlVIc0llN2g4aUgzWWZ3Q0ErSUhnZ29pQytJTllnOENFZUlWd2hraUhFSWVJaUdpSkNJbUFpaWlLMEl2d2pHQ09RSThJajRpUU9KRW9rY0NTY0pNWWsraVUwSlhvbG5DWGFKZ1FtUmlhWUp0Z20vaWMrSjJJbmVDZW9KOXdvR0NoR0tIQW93aWtNQUFCNG5HTmdaR0JnZU1TUXdTREFBQUpNWUxJWWlNMjRjMEJNQUN5WUFuNEFBSGljZlpDL1NrTXhHTVZQK2crcTBzSEJ5U0dEUXgxdTJuc1JDbmUwVUxSTHU5UlYraWUzRFpUY2NtK2dkSEFUWDhJM2NQQWgzSHdBSjUvQXpVZnczR3NvRk1HRUw5OHZKeWZKbHdCbzRSVUN2KzBhVDU0RjZ2andYRUVEWDU2cnVCQ3g1eHFhSXZkY1IwczhlMjdnV0x6UktXcE56aDdMWFFVTEhPSGRjd1VuK1BSY3hRMitQZGR3S3U0OTEzRXVIanczY0NaZTBFY0dqU2tjeHdVa1p0aHhIRU5oeUpBWXdTS2x4NUMzSEIxV3BBRTFTeDZVYTB2dWxZam83ekszNlhEc0c4VG9zQ2ZlbSt5OUNqbG5pcXFtZmduME16MTFlaUZuT3psV1F5VkhOczJNM0JxM2tvUFV1a0dhTGJXTVZGZTJWODV0NGs0bm9ab1Vxc29UWmJYakdiZVlseGZseEhscW1ZeFhpZ3hEelREL1Yzbk1tSlNyeFR2WDVZK0VYZzhSb01lSTZBeHh4WU1PQ292bHhEcmoxbm9Sa3NPZ0YwVGRrSzYveDJGdkJPNm9aYXpZbEVVVmx5Z2Zrb3M2eTAxcVphallPVS81bzVxMjRQQmg2VWJid0wvdUI2anZiUUVBQUFCNG5HMlFReGRsUndBR1gzMnhiZHZKYlhmSEdNYTJidmQ5TDdZNVNTYTJqWWx0MjdhVGJmNUlNaWZicE02cFZlMXFwTkcvL0QxN1pFZi94MTl6WlNURVBNekxmTXpQQWl6SVFpek1JcU1wbzZtamFhUHBveG1qbVN6S1lpek9FaXpKVWl6Tk1pekxjaXpQQ3F6SVNxek1LcXpLYXF6T0dxekpXcXpOT3F6TGVxelBCbXpJUm16TUptektabXpPRm5RWUxBNVBJSkxJRkxaa0s3Wm1HN1psTzdabkIzWmtKNll3bFdsTVp3WXoyWmxkMkpYZDJKMDkySk85Mkp0OTJKZjkySjhET0pDRE9KaERPSlRET0p3ak9KS2VTbU5neklTak9KcGpPSmJqT0o0VE9KR1RPSmxUT0pYVE9KMHpPSk96T0p0ek9KZnpPSjhMdUpCWlhNVEZYTUpzTHVVeUx1Y0tydVFxcnVZYXJ1VTZydWNHYnVRbWJ1WVdidVUyYnVjTzd1UXU3dVllN3VVKzd1Y0I1dkFnRC9Fd2ovQW9qL0U0VC9Ea2FBNVA4VFRQOEN6UDhUd3Y4Q0l2OFRLdjhDcXY4VHB2OENadjhUYnY4Qzd2OFQ0ZjhDRWY4VEdmOENtZjhUbGY4Q1ZmOFRYZjhDM2Y4VDAvOENNLzhUTy84Q3UvOFR0LzhPZm92MU5sT2hralkyV2NqSmNKTWxFbXlXU1p1YldYcVRKTlpwQVp5MHhrTzFramEyV2RySmNOc2xFMnlXYlpJdHZMVnRrbU84aU9aU2R5blp5UnMzSk96c3NGdVNpWDVMSmNrZXZscWx5VEcrVEdjaFA1VHQ3SVcza243K1dEZkpSUDhsbSt5UGZ5VmI3SkQvSmorWWxDcDJBVXJJSlQ4QXBCSVNva2hheFFGSHFGcXRBVUJvV3h3a1N4VXpTS1Z0RXBlc1dnR0JXVFlsWXNpcjFpVld5S2crSlljYUxVS1JrbHErU1V2RkpRaWtwSktTc1ZwVjZwS2pXbFFXbXNORkh1bEkyeVZYYktYamtvUitXa25KV0xjcTljbFp2eW9EeFducWgwS2tiRnFqZ1ZyeEpVb2twU3lTcEZwVmVwS2sxbFVCbXJUTlIzNm8xNnE5NnA5K3FEK3FnK3FjL3FpL3BlZlZYZjFBL3FKNnFkcWxHMXFrN1Zxd2JWcUpwVXMycFI3VldyYWxNZFZNZXFFN1ZPemFoWk5hZm0xWUphVkV0cVdhMm85V3BWcmFrTmFtTzFpWVpPZzlGZ05UZ05Ya1BRRURVa0RWbEQwZEJycUJxYWhrSEQrQi94NjlON2VKeGo4TjdCY0NJb1lpTWpZMS9rQnNhZEhBd2NETWtGR3hsWW5UWXlNR2hCYUE0VWVpY0RBd01uTW91WndXV2pDbU5IWU1RR2g0NklqY3dwTGh2VlFMeGRIQTBNakN3T0hja2hFU0Fsa1VDd2tZRkhhd2ZqLzlZTkxMMGJtUmhjQUFmVElyZ0FBQUE9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy53b2ZmXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy53b2ZmXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGNsb25lRWxlbWVudCwgaCwgb3B0aW9ucywgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcblxudmFyIHZlcnNpb24gPSAnMTUuMS4wJzsgLy8gdHJpY2sgbGlicmFyaWVzIHRvIHRoaW5rIHdlIGFyZSByZWFjdFxuXG52YXIgRUxFTUVOVFMgPSAnYSBhYmJyIGFkZHJlc3MgYXJlYSBhcnRpY2xlIGFzaWRlIGF1ZGlvIGIgYmFzZSBiZGkgYmRvIGJpZyBibG9ja3F1b3RlIGJvZHkgYnIgYnV0dG9uIGNhbnZhcyBjYXB0aW9uIGNpdGUgY29kZSBjb2wgY29sZ3JvdXAgZGF0YSBkYXRhbGlzdCBkZCBkZWwgZGV0YWlscyBkZm4gZGlhbG9nIGRpdiBkbCBkdCBlbSBlbWJlZCBmaWVsZHNldCBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkIGhlYWRlciBoZ3JvdXAgaHIgaHRtbCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCBrZXlnZW4gbGFiZWwgbGVnZW5kIGxpIGxpbmsgbWFpbiBtYXAgbWFyayBtZW51IG1lbnVpdGVtIG1ldGEgbWV0ZXIgbmF2IG5vc2NyaXB0IG9iamVjdCBvbCBvcHRncm91cCBvcHRpb24gb3V0cHV0IHAgcGFyYW0gcGljdHVyZSBwcmUgcHJvZ3Jlc3MgcSBycCBydCBydWJ5IHMgc2FtcCBzY3JpcHQgc2VjdGlvbiBzZWxlY3Qgc21hbGwgc291cmNlIHNwYW4gc3Ryb25nIHN0eWxlIHN1YiBzdW1tYXJ5IHN1cCB0YWJsZSB0Ym9keSB0ZCB0ZXh0YXJlYSB0Zm9vdCB0aCB0aGVhZCB0aW1lIHRpdGxlIHRyIHRyYWNrIHUgdWwgdmFyIHZpZGVvIHdiciBjaXJjbGUgY2xpcFBhdGggZGVmcyBlbGxpcHNlIGcgaW1hZ2UgbGluZSBsaW5lYXJHcmFkaWVudCBtYXNrIHBhdGggcGF0dGVybiBwb2x5Z29uIHBvbHlsaW5lIHJhZGlhbEdyYWRpZW50IHJlY3Qgc3RvcCBzdmcgdGV4dCB0c3Bhbicuc3BsaXQoJyAnKTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sIT09J3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8IDB4ZWFjNztcblxudmFyIENPTVBPTkVOVF9XUkFQUEVSX0tFWSA9IHR5cGVvZiBTeW1ib2whPT0ndW5kZWZpbmVkJyA/IFN5bWJvbC5mb3IoJ19fcHJlYWN0Q29tcGF0V3JhcHBlcicpIDogJ19fcHJlYWN0Q29tcGF0V3JhcHBlcic7XG5cbi8vIGRvbid0IGF1dG9iaW5kIHRoZXNlIG1ldGhvZHMgc2luY2UgdGhleSBhbHJlYWR5IGhhdmUgZ3VhcmFudGVlZCBjb250ZXh0LlxudmFyIEFVVE9CSU5EX0JMQUNLTElTVCA9IHtcblx0Y29uc3RydWN0b3I6IDEsXG5cdHJlbmRlcjogMSxcblx0c2hvdWxkQ29tcG9uZW50VXBkYXRlOiAxLFxuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAxLFxuXHRjb21wb25lbnRXaWxsVXBkYXRlOiAxLFxuXHRjb21wb25lbnREaWRVcGRhdGU6IDEsXG5cdGNvbXBvbmVudFdpbGxNb3VudDogMSxcblx0Y29tcG9uZW50RGlkTW91bnQ6IDEsXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50OiAxLFxuXHRjb21wb25lbnREaWRVbm1vdW50OiAxXG59O1xuXG5cbnZhciBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXB8Y29sb3J8ZmlsbHxmbG9vZHxmb250fGdseXBofGhvcml6fG1hcmtlcnxvdmVybGluZXxwYWludHxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHR8dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eClbQS1aXS87XG5cblxudmFyIEJZUEFTU19IT09LID0ge307XG5cbi8qZ2xvYmFsIHByb2Nlc3MqL1xudmFyIERFViA9IHR5cGVvZiBwcm9jZXNzPT09J3VuZGVmaW5lZCcgfHwgIXByb2Nlc3MuZW52IHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nO1xuXG4vLyBhIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgbm90aGluZy4gVXNlZCB0byByZXBsYWNlIGNvbXBvbmVudHMgZm9yIHVubW91bnRDb21wb25lbnRBdE5vZGUuXG5mdW5jdGlvbiBFbXB0eUNvbXBvbmVudCgpIHsgcmV0dXJuIG51bGw7IH1cblxuXG5cbi8vIG1ha2UgcmVhY3QgdGhpbmsgd2UncmUgcmVhY3QuXG52YXIgVk5vZGUgPSBoKCdhJywgbnVsbCkuY29uc3RydWN0b3I7XG5WTm9kZS5wcm90b3R5cGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5WTm9kZS5wcm90b3R5cGUucHJlYWN0Q29tcGF0VXBncmFkZWQgPSBmYWxzZTtcblZOb2RlLnByb3RvdHlwZS5wcmVhY3RDb21wYXROb3JtYWxpemVkID0gZmFsc2U7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWTm9kZS5wcm90b3R5cGUsICd0eXBlJywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ub2RlTmFtZTsgfSxcblx0c2V0OiBmdW5jdGlvbih2KSB7IHRoaXMubm9kZU5hbWUgPSB2OyB9LFxuXHRjb25maWd1cmFibGU6dHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWTm9kZS5wcm90b3R5cGUsICdwcm9wcycsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYXR0cmlidXRlczsgfSxcblx0c2V0OiBmdW5jdGlvbih2KSB7IHRoaXMuYXR0cmlidXRlcyA9IHY7IH0sXG5cdGNvbmZpZ3VyYWJsZTp0cnVlXG59KTtcblxuXG5cbnZhciBvbGRFdmVudEhvb2sgPSBvcHRpb25zLmV2ZW50O1xub3B0aW9ucy5ldmVudCA9IGZ1bmN0aW9uIChlKSB7XG5cdGlmIChvbGRFdmVudEhvb2spIHsgZSA9IG9sZEV2ZW50SG9vayhlKTsgfVxuXHRlLnBlcnNpc3QgPSBPYmplY3Q7XG5cdGUubmF0aXZlRXZlbnQgPSBlO1xuXHRyZXR1cm4gZTtcbn07XG5cblxudmFyIG9sZFZub2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gZnVuY3Rpb24gKHZub2RlKSB7XG5cdGlmICghdm5vZGUucHJlYWN0Q29tcGF0VXBncmFkZWQpIHtcblx0XHR2bm9kZS5wcmVhY3RDb21wYXRVcGdyYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgdGFnID0gdm5vZGUubm9kZU5hbWUsXG5cdFx0XHRhdHRycyA9IHZub2RlLmF0dHJpYnV0ZXMgPSBleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpO1xuXG5cdFx0aWYgKHR5cGVvZiB0YWc9PT0nZnVuY3Rpb24nKSB7XG5cdFx0XHRpZiAodGFnW0NPTVBPTkVOVF9XUkFQUEVSX0tFWV09PT10cnVlIHx8ICh0YWcucHJvdG90eXBlICYmICdpc1JlYWN0Q29tcG9uZW50JyBpbiB0YWcucHJvdG90eXBlKSkge1xuXHRcdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gJiYgU3RyaW5nKHZub2RlLmNoaWxkcmVuKT09PScnKSB7IHZub2RlLmNoaWxkcmVuID0gdW5kZWZpbmVkOyB9XG5cdFx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbikgeyBhdHRycy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuOyB9XG5cblx0XHRcdFx0aWYgKCF2bm9kZS5wcmVhY3RDb21wYXROb3JtYWxpemVkKSB7XG5cdFx0XHRcdFx0bm9ybWFsaXplVk5vZGUodm5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhhbmRsZUNvbXBvbmVudFZOb2RlKHZub2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gJiYgU3RyaW5nKHZub2RlLmNoaWxkcmVuKT09PScnKSB7IHZub2RlLmNoaWxkcmVuID0gdW5kZWZpbmVkOyB9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4pIHsgYXR0cnMuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjsgfVxuXG5cdFx0XHRpZiAoYXR0cnMuZGVmYXVsdFZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXR0cnMudmFsdWUgJiYgYXR0cnMudmFsdWUhPT0wKSB7XG5cdFx0XHRcdFx0YXR0cnMudmFsdWUgPSBhdHRycy5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIGF0dHJzLmRlZmF1bHRWYWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0aGFuZGxlRWxlbWVudFZOb2RlKHZub2RlLCBhdHRycyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG9sZFZub2RlSG9vaykgeyBvbGRWbm9kZUhvb2sodm5vZGUpOyB9XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVDb21wb25lbnRWTm9kZSh2bm9kZSkge1xuXHR2YXIgdGFnID0gdm5vZGUubm9kZU5hbWUsXG5cdFx0YSA9IHZub2RlLmF0dHJpYnV0ZXM7XG5cblx0dm5vZGUuYXR0cmlidXRlcyA9IHt9O1xuXHRpZiAodGFnLmRlZmF1bHRQcm9wcykgeyBleHRlbmQodm5vZGUuYXR0cmlidXRlcywgdGFnLmRlZmF1bHRQcm9wcyk7IH1cblx0aWYgKGEpIHsgZXh0ZW5kKHZub2RlLmF0dHJpYnV0ZXMsIGEpOyB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnRWTm9kZSh2bm9kZSwgYSkge1xuXHR2YXIgc2hvdWxkU2FuaXRpemUsIGF0dHJzLCBpO1xuXHRpZiAoYSkge1xuXHRcdGZvciAoaSBpbiBhKSB7IGlmICgoc2hvdWxkU2FuaXRpemUgPSBDQU1FTF9QUk9QUy50ZXN0KGkpKSkgeyBicmVhazsgfSB9XG5cdFx0aWYgKHNob3VsZFNhbml0aXplKSB7XG5cdFx0XHRhdHRycyA9IHZub2RlLmF0dHJpYnV0ZXMgPSB7fTtcblx0XHRcdGZvciAoaSBpbiBhKSB7XG5cdFx0XHRcdGlmIChhLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0YXR0cnNbIENBTUVMX1BST1BTLnRlc3QoaSkgPyBpLnJlcGxhY2UoLyhbQS1aMC05XSkvLCAnLSQxJykudG9Mb3dlckNhc2UoKSA6IGkgXSA9IGFbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG5cbi8vIHByb3h5IHJlbmRlcigpIHNpbmNlIFJlYWN0IHJldHVybnMgYSBDb21wb25lbnQgcmVmZXJlbmNlLlxuZnVuY3Rpb24gcmVuZGVyJDEodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0dmFyIHByZXYgPSBwYXJlbnQgJiYgcGFyZW50Ll9wcmVhY3RDb21wYXRSZW5kZXJlZCAmJiBwYXJlbnQuX3ByZWFjdENvbXBhdFJlbmRlcmVkLmJhc2U7XG5cblx0Ly8gaWdub3JlIGltcG9zc2libGUgcHJldmlvdXMgcmVuZGVyc1xuXHRpZiAocHJldiAmJiBwcmV2LnBhcmVudE5vZGUhPT1wYXJlbnQpIHsgcHJldiA9IG51bGw7IH1cblxuXHQvLyBkZWZhdWx0IHRvIGZpcnN0IEVsZW1lbnQgY2hpbGRcblx0aWYgKCFwcmV2ICYmIHBhcmVudCkgeyBwcmV2ID0gcGFyZW50LmZpcnN0RWxlbWVudENoaWxkOyB9XG5cblx0Ly8gcmVtb3ZlIHVuYWZmZWN0ZWQgc2libGluZ3Ncblx0Zm9yICh2YXIgaT1wYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldIT09cHJldikge1xuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5jaGlsZE5vZGVzW2ldKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgb3V0ID0gcmVuZGVyKHZub2RlLCBwYXJlbnQsIHByZXYpO1xuXHRpZiAocGFyZW50KSB7IHBhcmVudC5fcHJlYWN0Q29tcGF0UmVuZGVyZWQgPSBvdXQgJiYgKG91dC5fY29tcG9uZW50IHx8IHsgYmFzZTogb3V0IH0pOyB9XG5cdGlmICh0eXBlb2YgY2FsbGJhY2s9PT0nZnVuY3Rpb24nKSB7IGNhbGxiYWNrKCk7IH1cblx0cmV0dXJuIG91dCAmJiBvdXQuX2NvbXBvbmVudCB8fCBvdXQ7XG59XG5cblxudmFyIENvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG5Db250ZXh0UHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMucHJvcHMuY29udGV4dDtcbn07XG5Db250ZXh0UHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW5bMF07XG59O1xuXG5mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIHZub2RlLCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG5cdHZhciB3cmFwID0gaChDb250ZXh0UHJvdmlkZXIsIHsgY29udGV4dDogcGFyZW50Q29tcG9uZW50LmNvbnRleHQgfSwgdm5vZGUpO1xuXHR2YXIgcmVuZGVyQ29udGFpbmVyID0gcmVuZGVyJDEod3JhcCwgY29udGFpbmVyKTtcblx0dmFyIGNvbXBvbmVudCA9IHJlbmRlckNvbnRhaW5lci5fY29tcG9uZW50IHx8IHJlbmRlckNvbnRhaW5lci5iYXNlO1xuXHRpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbChjb21wb25lbnQsIHJlbmRlckNvbnRhaW5lcik7IH1cblx0cmV0dXJuIGNvbXBvbmVudDtcbn1cblxuXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcikge1xuXHR2YXIgZXhpc3RpbmcgPSBjb250YWluZXIuX3ByZWFjdENvbXBhdFJlbmRlcmVkICYmIGNvbnRhaW5lci5fcHJlYWN0Q29tcGF0UmVuZGVyZWQuYmFzZTtcblx0aWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nLnBhcmVudE5vZGU9PT1jb250YWluZXIpIHtcblx0XHRyZW5kZXIoaChFbXB0eUNvbXBvbmVudCksIGNvbnRhaW5lciwgZXhpc3RpbmcpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG5cbnZhciBBUlIgPSBbXTtcblxuLy8gVGhpcyBBUEkgaXMgY29tcGxldGVseSB1bm5lY2Vzc2FyeSBmb3IgUHJlYWN0LCBzbyBpdCdzIGJhc2ljYWxseSBwYXNzdGhyb3VnaC5cbnZhciBDaGlsZHJlbiA9IHtcblx0bWFwOiBmdW5jdGlvbihjaGlsZHJlbiwgZm4sIGN0eCkge1xuXHRcdGlmIChjaGlsZHJlbiA9PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG5cdFx0Y2hpbGRyZW4gPSBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAoY3R4ICYmIGN0eCE9PWNoaWxkcmVuKSB7IGZuID0gZm4uYmluZChjdHgpOyB9XG5cdFx0cmV0dXJuIGNoaWxkcmVuLm1hcChmbik7XG5cdH0sXG5cdGZvckVhY2g6IGZ1bmN0aW9uKGNoaWxkcmVuLCBmbiwgY3R4KSB7XG5cdFx0aWYgKGNoaWxkcmVuID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRjaGlsZHJlbiA9IENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChjdHggJiYgY3R4IT09Y2hpbGRyZW4pIHsgZm4gPSBmbi5iaW5kKGN0eCk7IH1cblx0XHRjaGlsZHJlbi5mb3JFYWNoKGZuKTtcblx0fSxcblx0Y291bnQ6IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCB8fCAwO1xuXHR9LFxuXHRvbmx5OiBmdW5jdGlvbihjaGlsZHJlbikge1xuXHRcdGNoaWxkcmVuID0gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCE9PTEpIHsgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5vbmx5KCkgZXhwZWN0cyBvbmx5IG9uZSBjaGlsZC4nKTsgfVxuXHRcdHJldHVybiBjaGlsZHJlblswXTtcblx0fSxcblx0dG9BcnJheTogZnVuY3Rpb24oY2hpbGRyZW4pIHtcblx0XHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgeyByZXR1cm4gW107IH1cblx0XHRyZXR1cm4gQVJSLmNvbmNhdChjaGlsZHJlbik7XG5cdH1cbn07XG5cblxuLyoqIFRyYWNrIGN1cnJlbnQgcmVuZGVyKCkgY29tcG9uZW50IGZvciByZWYgYXNzaWdubWVudCAqL1xudmFyIGN1cnJlbnRDb21wb25lbnQ7XG5cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeSh0eXBlKSB7XG5cdHJldHVybiBjcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG59XG5cblxudmFyIERPTSA9IHt9O1xuZm9yICh2YXIgaT1FTEVNRU5UUy5sZW5ndGg7IGktLTsgKSB7XG5cdERPTVtFTEVNRU5UU1tpXV0gPSBjcmVhdGVGYWN0b3J5KEVMRU1FTlRTW2ldKTtcbn1cblxuZnVuY3Rpb24gdXBncmFkZVRvVk5vZGVzKGFyciwgb2Zmc2V0KSB7XG5cdGZvciAodmFyIGk9b2Zmc2V0IHx8IDA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIG9iaiA9IGFycltpXTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHR1cGdyYWRlVG9WTm9kZXMob2JqKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2JqICYmIHR5cGVvZiBvYmo9PT0nb2JqZWN0JyAmJiAhaXNWYWxpZEVsZW1lbnQob2JqKSAmJiAoKG9iai5wcm9wcyAmJiBvYmoudHlwZSkgfHwgKG9iai5hdHRyaWJ1dGVzICYmIG9iai5ub2RlTmFtZSkgfHwgb2JqLmNoaWxkcmVuKSkge1xuXHRcdFx0YXJyW2ldID0gY3JlYXRlRWxlbWVudChvYmoudHlwZSB8fCBvYmoubm9kZU5hbWUsIG9iai5wcm9wcyB8fCBvYmouYXR0cmlidXRlcywgb2JqLmNoaWxkcmVuKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0ZWxlc3NDb21wb25lbnQoYykge1xuXHRyZXR1cm4gdHlwZW9mIGM9PT0nZnVuY3Rpb24nICYmICEoYy5wcm90b3R5cGUgJiYgYy5wcm90b3R5cGUucmVuZGVyKTtcbn1cblxuXG4vLyB3cmFwcyBzdGF0ZWxlc3MgZnVuY3Rpb25hbCBjb21wb25lbnRzIGluIGEgUHJvcFR5cGVzIHZhbGlkYXRvclxuZnVuY3Rpb24gd3JhcFN0YXRlbGVzc0NvbXBvbmVudChXcmFwcGVkQ29tcG9uZW50KSB7XG5cdHJldHVybiBjcmVhdGVDbGFzcyh7XG5cdFx0ZGlzcGxheU5hbWU6IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lLFxuXHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gV3JhcHBlZENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQpO1xuXHRcdH1cblx0fSk7XG59XG5cblxuZnVuY3Rpb24gc3RhdGVsZXNzQ29tcG9uZW50SG9vayhDdG9yKSB7XG5cdHZhciBXcmFwcGVkID0gQ3RvcltDT01QT05FTlRfV1JBUFBFUl9LRVldO1xuXHRpZiAoV3JhcHBlZCkgeyByZXR1cm4gV3JhcHBlZD09PXRydWUgPyBDdG9yIDogV3JhcHBlZDsgfVxuXG5cdFdyYXBwZWQgPSB3cmFwU3RhdGVsZXNzQ29tcG9uZW50KEN0b3IpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkLCBDT01QT05FTlRfV1JBUFBFUl9LRVksIHsgY29uZmlndXJhYmxlOnRydWUsIHZhbHVlOnRydWUgfSk7XG5cdFdyYXBwZWQuZGlzcGxheU5hbWUgPSBDdG9yLmRpc3BsYXlOYW1lO1xuXHRXcmFwcGVkLnByb3BUeXBlcyA9IEN0b3IucHJvcFR5cGVzO1xuXHRXcmFwcGVkLmRlZmF1bHRQcm9wcyA9IEN0b3IuZGVmYXVsdFByb3BzO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdG9yLCBDT01QT05FTlRfV1JBUFBFUl9LRVksIHsgY29uZmlndXJhYmxlOnRydWUsIHZhbHVlOldyYXBwZWQgfSk7XG5cblx0cmV0dXJuIFdyYXBwZWQ7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCgpIHtcblx0dmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0d2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuXHR1cGdyYWRlVG9WTm9kZXMoYXJncywgMik7XG5cdHJldHVybiBub3JtYWxpemVWTm9kZShoLmFwcGx5KHZvaWQgMCwgYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKHZub2RlKSB7XG5cdHZub2RlLnByZWFjdENvbXBhdE5vcm1hbGl6ZWQgPSB0cnVlO1xuXG5cdGFwcGx5Q2xhc3NOYW1lKHZub2RlKTtcblxuXHRpZiAoaXNTdGF0ZWxlc3NDb21wb25lbnQodm5vZGUubm9kZU5hbWUpKSB7XG5cdFx0dm5vZGUubm9kZU5hbWUgPSBzdGF0ZWxlc3NDb21wb25lbnRIb29rKHZub2RlLm5vZGVOYW1lKTtcblx0fVxuXG5cdHZhciByZWYgPSB2bm9kZS5hdHRyaWJ1dGVzLnJlZixcblx0XHR0eXBlID0gcmVmICYmIHR5cGVvZiByZWY7XG5cdGlmIChjdXJyZW50Q29tcG9uZW50ICYmICh0eXBlPT09J3N0cmluZycgfHwgdHlwZT09PSdudW1iZXInKSkge1xuXHRcdHZub2RlLmF0dHJpYnV0ZXMucmVmID0gY3JlYXRlU3RyaW5nUmVmUHJveHkocmVmLCBjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXG5cdGFwcGx5RXZlbnROb3JtYWxpemF0aW9uKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50JDEoZWxlbWVudCwgcHJvcHMpIHtcblx0dmFyIGNoaWxkcmVuID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXHR3aGlsZSAoIGxlbi0tID4gMCApIGNoaWxkcmVuWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG5cdGlmICghaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHsgcmV0dXJuIGVsZW1lbnQ7IH1cblx0dmFyIGVsZW1lbnRQcm9wcyA9IGVsZW1lbnQuYXR0cmlidXRlcyB8fCBlbGVtZW50LnByb3BzO1xuXHR2YXIgbm9kZSA9IGgoXG5cdFx0ZWxlbWVudC5ub2RlTmFtZSB8fCBlbGVtZW50LnR5cGUsXG5cdFx0ZWxlbWVudFByb3BzLFxuXHRcdGVsZW1lbnQuY2hpbGRyZW4gfHwgZWxlbWVudFByb3BzICYmIGVsZW1lbnRQcm9wcy5jaGlsZHJlblxuXHQpO1xuXHQvLyBPbmx5IHByb3ZpZGUgdGhlIDNyZCBhcmd1bWVudCBpZiBuZWVkZWQuXG5cdC8vIEFyZ3VtZW50cyAzKyBvdmVyd3JpdGUgZWxlbWVudC5jaGlsZHJlbiBpbiBwcmVhY3RDbG9uZUVsZW1lbnRcblx0dmFyIGNsb25lQXJncyA9IFtub2RlLCBwcm9wc107XG5cdGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRjbG9uZUFyZ3MucHVzaChjaGlsZHJlbik7XG5cdH1cblx0ZWxzZSBpZiAocHJvcHMgJiYgcHJvcHMuY2hpbGRyZW4pIHtcblx0XHRjbG9uZUFyZ3MucHVzaChwcm9wcy5jaGlsZHJlbik7XG5cdH1cblx0cmV0dXJuIG5vcm1hbGl6ZVZOb2RlKGNsb25lRWxlbWVudC5hcHBseSh2b2lkIDAsIGNsb25lQXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcblx0cmV0dXJuIGVsZW1lbnQgJiYgKChlbGVtZW50IGluc3RhbmNlb2YgVk5vZGUpIHx8IGVsZW1lbnQuJCR0eXBlb2Y9PT1SRUFDVF9FTEVNRU5UX1RZUEUpO1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1JlZlByb3h5KG5hbWUsIGNvbXBvbmVudCkge1xuXHRyZXR1cm4gY29tcG9uZW50Ll9yZWZQcm94aWVzW25hbWVdIHx8IChjb21wb25lbnQuX3JlZlByb3hpZXNbbmFtZV0gPSBmdW5jdGlvbiAocmVzb2x2ZWQpIHtcblx0XHRpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5yZWZzKSB7XG5cdFx0XHRjb21wb25lbnQucmVmc1tuYW1lXSA9IHJlc29sdmVkO1xuXHRcdFx0aWYgKHJlc29sdmVkPT09bnVsbCkge1xuXHRcdFx0XHRkZWxldGUgY29tcG9uZW50Ll9yZWZQcm94aWVzW25hbWVdO1xuXHRcdFx0XHRjb21wb25lbnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cblxuZnVuY3Rpb24gYXBwbHlFdmVudE5vcm1hbGl6YXRpb24ocmVmKSB7XG5cdHZhciBub2RlTmFtZSA9IHJlZi5ub2RlTmFtZTtcblx0dmFyIGF0dHJpYnV0ZXMgPSByZWYuYXR0cmlidXRlcztcblxuXHRpZiAoIWF0dHJpYnV0ZXMgfHwgdHlwZW9mIG5vZGVOYW1lIT09J3N0cmluZycpIHsgcmV0dXJuOyB9XG5cdHZhciBwcm9wcyA9IHt9O1xuXHRmb3IgKHZhciBpIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRwcm9wc1tpLnRvTG93ZXJDYXNlKCldID0gaTtcblx0fVxuXHRpZiAocHJvcHMub25kb3VibGVjbGljaykge1xuXHRcdGF0dHJpYnV0ZXMub25kYmxjbGljayA9IGF0dHJpYnV0ZXNbcHJvcHMub25kb3VibGVjbGlja107XG5cdFx0ZGVsZXRlIGF0dHJpYnV0ZXNbcHJvcHMub25kb3VibGVjbGlja107XG5cdH1cblx0Ly8gZm9yICp0ZXh0dWFsIGlucHV0cyogKGluY2wgdGV4dGFyZWEpLCBub3JtYWxpemUgYG9uQ2hhbmdlYCAtPiBgb25JbnB1dGA6XG5cdGlmIChwcm9wcy5vbmNoYW5nZSAmJiAobm9kZU5hbWU9PT0ndGV4dGFyZWEnIHx8IChub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09J2lucHV0JyAmJiAhL15maWx8Y2hlfHJhZC9pLnRlc3QoYXR0cmlidXRlcy50eXBlKSkpKSB7XG5cdFx0dmFyIG5vcm1hbGl6ZWQgPSBwcm9wcy5vbmlucHV0IHx8ICdvbmlucHV0Jztcblx0XHRpZiAoIWF0dHJpYnV0ZXNbbm9ybWFsaXplZF0pIHtcblx0XHRcdGF0dHJpYnV0ZXNbbm9ybWFsaXplZF0gPSBtdWx0aWhvb2soW2F0dHJpYnV0ZXNbbm9ybWFsaXplZF0sIGF0dHJpYnV0ZXNbcHJvcHMub25jaGFuZ2VdXSk7XG5cdFx0XHRkZWxldGUgYXR0cmlidXRlc1twcm9wcy5vbmNoYW5nZV07XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gYXBwbHlDbGFzc05hbWUodm5vZGUpIHtcblx0dmFyIGEgPSB2bm9kZS5hdHRyaWJ1dGVzIHx8ICh2bm9kZS5hdHRyaWJ1dGVzID0ge30pO1xuXHRjbGFzc05hbWVEZXNjcmlwdG9yLmVudW1lcmFibGUgPSAnY2xhc3NOYW1lJyBpbiBhO1xuXHRpZiAoYS5jbGFzc05hbWUpIHsgYS5jbGFzcyA9IGEuY2xhc3NOYW1lOyB9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lRGVzY3JpcHRvcik7XG59XG5cblxudmFyIGNsYXNzTmFtZURlc2NyaXB0b3IgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xhc3M7IH0sXG5cdHNldDogZnVuY3Rpb24odikgeyB0aGlzLmNsYXNzID0gdjsgfVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kKGJhc2UsIHByb3BzKSB7XG5cdHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuXHRmb3IgKHZhciBpPTEsIG9iaiA9ICh2b2lkIDApOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICgob2JqID0gYXJndW1lbnRzJDFbaV0pKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0XHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdGJhc2Vba2V5XSA9IG9ialtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBiYXNlO1xufVxuXG5cbmZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yICh2YXIgaSBpbiBhKSB7IGlmICghKGkgaW4gYikpIHsgcmV0dXJuIHRydWU7IH0gfVxuXHRmb3IgKHZhciBpJDEgaW4gYikgeyBpZiAoYVtpJDFdIT09YltpJDFdKSB7IHJldHVybiB0cnVlOyB9IH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudCkge1xuXHRyZXR1cm4gY29tcG9uZW50ICYmIGNvbXBvbmVudC5iYXNlIHx8IGNvbXBvbmVudDtcbn1cblxuXG5mdW5jdGlvbiBGKCl7fVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzcyhvYmopIHtcblx0ZnVuY3Rpb24gY2wocHJvcHMsIGNvbnRleHQpIHtcblx0XHRiaW5kQWxsKHRoaXMpO1xuXHRcdENvbXBvbmVudCQxLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQsIEJZUEFTU19IT09LKTtcblx0XHRuZXdDb21wb25lbnRIb29rLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR9XG5cblx0b2JqID0gZXh0ZW5kKHsgY29uc3RydWN0b3I6IGNsIH0sIG9iaik7XG5cblx0Ly8gV2UgbmVlZCB0byBhcHBseSBtaXhpbnMgaGVyZSBzbyB0aGF0IGdldERlZmF1bHRQcm9wcyBpcyBjb3JyZWN0bHkgbWl4ZWRcblx0aWYgKG9iai5taXhpbnMpIHtcblx0XHRhcHBseU1peGlucyhvYmosIGNvbGxhdGVNaXhpbnMob2JqLm1peGlucykpO1xuXHR9XG5cdGlmIChvYmouc3RhdGljcykge1xuXHRcdGV4dGVuZChjbCwgb2JqLnN0YXRpY3MpO1xuXHR9XG5cdGlmIChvYmoucHJvcFR5cGVzKSB7XG5cdFx0Y2wucHJvcFR5cGVzID0gb2JqLnByb3BUeXBlcztcblx0fVxuXHRpZiAob2JqLmRlZmF1bHRQcm9wcykge1xuXHRcdGNsLmRlZmF1bHRQcm9wcyA9IG9iai5kZWZhdWx0UHJvcHM7XG5cdH1cblx0aWYgKG9iai5nZXREZWZhdWx0UHJvcHMpIHtcblx0XHRjbC5kZWZhdWx0UHJvcHMgPSBvYmouZ2V0RGVmYXVsdFByb3BzKCk7XG5cdH1cblxuXHRGLnByb3RvdHlwZSA9IENvbXBvbmVudCQxLnByb3RvdHlwZTtcblx0Y2wucHJvdG90eXBlID0gZXh0ZW5kKG5ldyBGKCksIG9iaik7XG5cblx0Y2wuZGlzcGxheU5hbWUgPSBvYmouZGlzcGxheU5hbWUgfHwgJ0NvbXBvbmVudCc7XG5cblx0cmV0dXJuIGNsO1xufVxuXG5cbi8vIEZsYXR0ZW4gYW4gQXJyYXkgb2YgbWl4aW5zIHRvIGEgbWFwIG9mIG1ldGhvZCBuYW1lIHRvIG1peGluIGltcGxlbWVudGF0aW9uc1xuZnVuY3Rpb24gY29sbGF0ZU1peGlucyhtaXhpbnMpIHtcblx0dmFyIGtleWVkID0ge307XG5cdGZvciAodmFyIGk9MDsgaTxtaXhpbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgbWl4aW4gPSBtaXhpbnNbaV07XG5cdFx0Zm9yICh2YXIga2V5IGluIG1peGluKSB7XG5cdFx0XHRpZiAobWl4aW4uaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgbWl4aW5ba2V5XT09PSdmdW5jdGlvbicpIHtcblx0XHRcdFx0KGtleWVkW2tleV0gfHwgKGtleWVkW2tleV09W10pKS5wdXNoKG1peGluW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4ga2V5ZWQ7XG59XG5cblxuLy8gYXBwbHkgYSBtYXBwaW5nIG9mIEFycmF5cyBvZiBtaXhpbiBtZXRob2RzIHRvIGEgY29tcG9uZW50IHByb3RvdHlwZVxuZnVuY3Rpb24gYXBwbHlNaXhpbnMocHJvdG8sIG1peGlucykge1xuXHRmb3IgKHZhciBrZXkgaW4gbWl4aW5zKSB7IGlmIChtaXhpbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdHByb3RvW2tleV0gPSBtdWx0aWhvb2soXG5cdFx0XHRtaXhpbnNba2V5XS5jb25jYXQocHJvdG9ba2V5XSB8fCBBUlIpLFxuXHRcdFx0a2V5PT09J2dldERlZmF1bHRQcm9wcycgfHwga2V5PT09J2dldEluaXRpYWxTdGF0ZScgfHwga2V5PT09J2dldENoaWxkQ29udGV4dCdcblx0XHQpO1xuXHR9IH1cbn1cblxuXG5mdW5jdGlvbiBiaW5kQWxsKGN0eCkge1xuXHRmb3IgKHZhciBpIGluIGN0eCkge1xuXHRcdHZhciB2ID0gY3R4W2ldO1xuXHRcdGlmICh0eXBlb2Ygdj09PSdmdW5jdGlvbicgJiYgIXYuX19ib3VuZCAmJiAhQVVUT0JJTkRfQkxBQ0tMSVNULmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHQoY3R4W2ldID0gdi5iaW5kKGN0eCkpLl9fYm91bmQgPSB0cnVlO1xuXHRcdH1cblx0fVxufVxuXG5cbmZ1bmN0aW9uIGNhbGxNZXRob2QoY3R4LCBtLCBhcmdzKSB7XG5cdGlmICh0eXBlb2YgbT09PSdzdHJpbmcnKSB7XG5cdFx0bSA9IGN0eC5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbbV07XG5cdH1cblx0aWYgKHR5cGVvZiBtPT09J2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBtLmFwcGx5KGN0eCwgYXJncyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gbXVsdGlob29rKGhvb2tzLCBza2lwRHVwbGljYXRlcykge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0dmFyIHJldDtcblx0XHRmb3IgKHZhciBpPTA7IGk8aG9va3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciByID0gY2FsbE1ldGhvZCh0aGlzJDEsIGhvb2tzW2ldLCBhcmd1bWVudHMkMSk7XG5cblx0XHRcdGlmIChza2lwRHVwbGljYXRlcyAmJiByIT1udWxsKSB7XG5cdFx0XHRcdGlmICghcmV0KSB7IHJldCA9IHt9OyB9XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiByKSB7IGlmIChyLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRyZXRba2V5XSA9IHJba2V5XTtcblx0XHRcdFx0fSB9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgciE9PSd1bmRlZmluZWQnKSB7IHJldCA9IHI7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxuXG5mdW5jdGlvbiBuZXdDb21wb25lbnRIb29rKHByb3BzLCBjb250ZXh0KSB7XG5cdHByb3BzSG9vay5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcblx0dGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gbXVsdGlob29rKFtwcm9wc0hvb2ssIHRoaXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB8fCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyddKTtcblx0dGhpcy5yZW5kZXIgPSBtdWx0aWhvb2soW3Byb3BzSG9vaywgYmVmb3JlUmVuZGVyLCB0aGlzLnJlbmRlciB8fCAncmVuZGVyJywgYWZ0ZXJSZW5kZXJdKTtcbn1cblxuXG5mdW5jdGlvbiBwcm9wc0hvb2socHJvcHMsIGNvbnRleHQpIHtcblx0aWYgKCFwcm9wcykgeyByZXR1cm47IH1cblxuXHQvLyBSZWFjdCBhbm5veWluZ2x5IHNwZWNpYWwtY2FzZXMgc2luZ2xlIGNoaWxkcmVuLCBhbmQgc29tZSByZWFjdCBjb21wb25lbnRzIGFyZSByaWRpY3Vsb3VzbHkgc3RyaWN0IGFib3V0IHRoaXMuXG5cdHZhciBjID0gcHJvcHMuY2hpbGRyZW47XG5cdGlmIChjICYmIEFycmF5LmlzQXJyYXkoYykgJiYgYy5sZW5ndGg9PT0xICYmICh0eXBlb2YgY1swXT09PSdzdHJpbmcnIHx8IHR5cGVvZiBjWzBdPT09J2Z1bmN0aW9uJyB8fCBjWzBdIGluc3RhbmNlb2YgVk5vZGUpKSB7XG5cdFx0cHJvcHMuY2hpbGRyZW4gPSBjWzBdO1xuXG5cdFx0Ly8gYnV0IGl0cyB0b3RhbGx5IHN0aWxsIGdvaW5nIHRvIGJlIGFuIEFycmF5LlxuXHRcdGlmIChwcm9wcy5jaGlsZHJlbiAmJiB0eXBlb2YgcHJvcHMuY2hpbGRyZW49PT0nb2JqZWN0Jykge1xuXHRcdFx0cHJvcHMuY2hpbGRyZW4ubGVuZ3RoID0gMTtcblx0XHRcdHByb3BzLmNoaWxkcmVuWzBdID0gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9XG5cblx0Ly8gYWRkIHByb3B0eXBlIGNoZWNraW5nXG5cdGlmIChERVYpIHtcblx0XHR2YXIgY3RvciA9IHR5cGVvZiB0aGlzPT09J2Z1bmN0aW9uJyA/IHRoaXMgOiB0aGlzLmNvbnN0cnVjdG9yLFxuXHRcdFx0cHJvcFR5cGVzID0gdGhpcy5wcm9wVHlwZXMgfHwgY3Rvci5wcm9wVHlwZXM7XG5cdFx0dmFyIGRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWU7XG5cblx0XHRpZiAocHJvcFR5cGVzKSB7XG5cdFx0XHRQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCBkaXNwbGF5TmFtZSk7XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gYmVmb3JlUmVuZGVyKHByb3BzKSB7XG5cdGN1cnJlbnRDb21wb25lbnQgPSB0aGlzO1xufVxuXG5mdW5jdGlvbiBhZnRlclJlbmRlcigpIHtcblx0aWYgKGN1cnJlbnRDb21wb25lbnQ9PT10aGlzKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdH1cbn1cblxuXG5cbmZ1bmN0aW9uIENvbXBvbmVudCQxKHByb3BzLCBjb250ZXh0LCBvcHRzKSB7XG5cdENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcblx0dGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IHt9O1xuXHR0aGlzLnJlZnMgPSB7fTtcblx0dGhpcy5fcmVmUHJveGllcyA9IHt9O1xuXHRpZiAob3B0cyE9PUJZUEFTU19IT09LKSB7XG5cdFx0bmV3Q29tcG9uZW50SG9vay5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcblx0fVxufVxuZXh0ZW5kKENvbXBvbmVudCQxLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKSwge1xuXHRjb25zdHJ1Y3RvcjogQ29tcG9uZW50JDEsXG5cblx0aXNSZWFjdENvbXBvbmVudDoge30sXG5cblx0cmVwbGFjZVN0YXRlOiBmdW5jdGlvbihzdGF0ZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdHRoaXMuc2V0U3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMkMS5zdGF0ZSkge1xuXHRcdFx0aWYgKCEoaSBpbiBzdGF0ZSkpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMkMS5zdGF0ZVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0RE9NTm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmFzZTtcblx0fSxcblxuXHRpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuYmFzZTtcblx0fVxufSk7XG5cblxuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG5cdENvbXBvbmVudCQxLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xufVxuRi5wcm90b3R5cGUgPSBDb21wb25lbnQkMS5wcm90b3R5cGU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuXG52YXIgaW5kZXggPSB7XG5cdHZlcnNpb246IHZlcnNpb24sXG5cdERPTTogRE9NLFxuXHRQcm9wVHlwZXM6IFByb3BUeXBlcyxcblx0Q2hpbGRyZW46IENoaWxkcmVuLFxuXHRyZW5kZXI6IHJlbmRlciQxLFxuXHRjcmVhdGVDbGFzczogY3JlYXRlQ2xhc3MsXG5cdGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnksXG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG5cdGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50JDEsXG5cdGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuXHR1bm1vdW50Q29tcG9uZW50QXROb2RlOiB1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuXHRDb21wb25lbnQ6IENvbXBvbmVudCQxLFxuXHRQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuXHR1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsXG5cdF9fc3ByZWFkOiBleHRlbmRcbn07XG5cbmV4cG9ydCB7IHZlcnNpb24sIERPTSwgUHJvcFR5cGVzLCBDaGlsZHJlbiwgcmVuZGVyJDEgYXMgcmVuZGVyLCBjcmVhdGVDbGFzcywgY3JlYXRlRmFjdG9yeSwgY3JlYXRlRWxlbWVudCwgY2xvbmVFbGVtZW50JDEgYXMgY2xvbmVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCwgZmluZERPTU5vZGUsIHVubW91bnRDb21wb25lbnRBdE5vZGUsIENvbXBvbmVudCQxIGFzIENvbXBvbmVudCwgUHVyZUNvbXBvbmVudCwgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgYXMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIGV4dGVuZCBhcyBfX3NwcmVhZCB9O2V4cG9ydCBkZWZhdWx0IGluZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlYWN0LWNvbXBhdC5lcy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9wcmVhY3QtY29tcGF0L2Rpc3QvcHJlYWN0LWNvbXBhdC5lcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1jb21wYXQvZGlzdC9wcmVhY3QtY29tcGF0LmVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBWaXJ0dWFsIERPTSBOb2RlICovXG5mdW5jdGlvbiBWTm9kZSgpIHt9XG5cbi8qKiBHbG9iYWwgb3B0aW9uc1xuICpcdEBwdWJsaWNcbiAqXHRAbmFtZXNwYWNlIG9wdGlvbnMge09iamVjdH1cbiAqL1xudmFyIG9wdGlvbnMgPSB7XG5cblx0LyoqIElmIGB0cnVlYCwgYHByb3BgIGNoYW5nZXMgdHJpZ2dlciBzeW5jaHJvbm91cyBjb21wb25lbnQgdXBkYXRlcy5cbiAgKlx0QG5hbWUgc3luY0NvbXBvbmVudFVwZGF0ZXNcbiAgKlx0QHR5cGUgQm9vbGVhblxuICAqXHRAZGVmYXVsdCB0cnVlXG4gICovXG5cdC8vc3luY0NvbXBvbmVudFVwZGF0ZXM6IHRydWUsXG5cblx0LyoqIFByb2Nlc3NlcyBhbGwgY3JlYXRlZCBWTm9kZXMuXG4gICpcdEBwYXJhbSB7Vk5vZGV9IHZub2RlXHRBIG5ld2x5LWNyZWF0ZWQgVk5vZGUgdG8gbm9ybWFsaXplL3Byb2Nlc3NcbiAgKi9cblx0Ly92bm9kZSh2bm9kZSkgeyB9XG5cblx0LyoqIEhvb2sgaW52b2tlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBtb3VudGVkLiAqL1xuXHQvLyBhZnRlck1vdW50KGNvbXBvbmVudCkgeyB9XG5cblx0LyoqIEhvb2sgaW52b2tlZCBhZnRlciB0aGUgRE9NIGlzIHVwZGF0ZWQgd2l0aCBhIGNvbXBvbmVudCdzIGxhdGVzdCByZW5kZXIuICovXG5cdC8vIGFmdGVyVXBkYXRlKGNvbXBvbmVudCkgeyB9XG5cblx0LyoqIEhvb2sgaW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkLiAqL1xuXHQvLyBiZWZvcmVVbm1vdW50KGNvbXBvbmVudCkgeyB9XG59O1xuXG52YXIgc3RhY2sgPSBbXTtcblxudmFyIEVNUFRZX0NISUxEUkVOID0gW107XG5cbi8qKiBKU1gvaHlwZXJzY3JpcHQgcmV2aXZlclxuKlx0QmVuY2htYXJrczogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81N2VlOGY4ZTMzMGFiMDk5MDBhMWExYTBcbiAqXHRAc2VlIGh0dHA6Ly9qYXNvbmZvcm1hdC5jb20vd3RmLWlzLWpzeFxuICpcdEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaChub2RlTmFtZSwgYXR0cmlidXRlcykge1xuXHR2YXIgY2hpbGRyZW4gPSBFTVBUWV9DSElMRFJFTixcblx0ICAgIGxhc3RTaW1wbGUsXG5cdCAgICBjaGlsZCxcblx0ICAgIHNpbXBsZSxcblx0ICAgIGk7XG5cdGZvciAoaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGktLSA+IDI7KSB7XG5cdFx0c3RhY2sucHVzaChhcmd1bWVudHNbaV0pO1xuXHR9XG5cdGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGlmICghc3RhY2subGVuZ3RoKSBzdGFjay5wdXNoKGF0dHJpYnV0ZXMuY2hpbGRyZW4pO1xuXHRcdGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuO1xuXHR9XG5cdHdoaWxlIChzdGFjay5sZW5ndGgpIHtcblx0XHRpZiAoKGNoaWxkID0gc3RhY2sucG9wKCkpICYmIGNoaWxkLnBvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGkgPSBjaGlsZC5sZW5ndGg7IGktLTspIHtcblx0XHRcdFx0c3RhY2sucHVzaChjaGlsZFtpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgY2hpbGQgPT09ICdib29sZWFuJykgY2hpbGQgPSBudWxsO1xuXG5cdFx0XHRpZiAoc2ltcGxlID0gdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmIChjaGlsZCA9PSBudWxsKSBjaGlsZCA9ICcnO2Vsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIGNoaWxkID0gU3RyaW5nKGNoaWxkKTtlbHNlIGlmICh0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnKSBzaW1wbGUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSB7XG5cdFx0XHRcdGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdICs9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIGlmIChjaGlsZHJlbiA9PT0gRU1QVFlfQ0hJTERSRU4pIHtcblx0XHRcdFx0Y2hpbGRyZW4gPSBbY2hpbGRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdFx0XHR9XG5cblx0XHRcdGxhc3RTaW1wbGUgPSBzaW1wbGU7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHAgPSBuZXcgVk5vZGUoKTtcblx0cC5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuXHRwLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cdHAuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGF0dHJpYnV0ZXM7XG5cdHAua2V5ID0gYXR0cmlidXRlcyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXR0cmlidXRlcy5rZXk7XG5cblx0Ly8gaWYgYSBcInZub2RlIGhvb2tcIiBpcyBkZWZpbmVkLCBwYXNzIGV2ZXJ5IGNyZWF0ZWQgVk5vZGUgdG8gaXRcblx0aWYgKG9wdGlvbnMudm5vZGUgIT09IHVuZGVmaW5lZCkgb3B0aW9ucy52bm9kZShwKTtcblxuXHRyZXR1cm4gcDtcbn1cblxuLyoqIENvcHkgb3duLXByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIG9udG8gYG9iamAuXG4gKlx0QHJldHVybnMgb2JqXG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSBpbiBwcm9wcykge1xuICAgIG9ialtpXSA9IHByb3BzW2ldO1xuICB9cmV0dXJuIG9iajtcbn1cblxuLyoqIENhbGwgYSBmdW5jdGlvbiBhc3luY2hyb25vdXNseSwgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqXHRAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG52YXIgZGVmZXIgPSB0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKSA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMpIHtcblx0cmV0dXJuIGgodm5vZGUubm9kZU5hbWUsIGV4dGVuZChleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpLCBwcm9wcyksIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogdm5vZGUuY2hpbGRyZW4pO1xufVxuXG4vLyBET00gcHJvcGVydGllcyB0aGF0IHNob3VsZCBOT1QgaGF2ZSBcInB4XCIgYWRkZWQgd2hlbiBudW1lcmljXG52YXIgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkL2k7XG5cbi8qKiBNYW5hZ2VkIHF1ZXVlIG9mIGRpcnR5IGNvbXBvbmVudHMgdG8gYmUgcmUtcmVuZGVyZWQgKi9cblxudmFyIGl0ZW1zID0gW107XG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXIoY29tcG9uZW50KSB7XG5cdGlmICghY29tcG9uZW50Ll9kaXJ0eSAmJiAoY29tcG9uZW50Ll9kaXJ0eSA9IHRydWUpICYmIGl0ZW1zLnB1c2goY29tcG9uZW50KSA9PSAxKSB7XG5cdFx0KG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgfHwgZGVmZXIpKHJlcmVuZGVyKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZXJlbmRlcigpIHtcblx0dmFyIHAsXG5cdCAgICBsaXN0ID0gaXRlbXM7XG5cdGl0ZW1zID0gW107XG5cdHdoaWxlIChwID0gbGlzdC5wb3AoKSkge1xuXHRcdGlmIChwLl9kaXJ0eSkgcmVuZGVyQ29tcG9uZW50KHApO1xuXHR9XG59XG5cbi8qKiBDaGVjayBpZiB0d28gbm9kZXMgYXJlIGVxdWl2YWxlbnQuXG4gKlx0QHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1NhbWVOb2RlVHlwZShub2RlLCB2bm9kZSwgaHlkcmF0aW5nKSB7XG5cdGlmICh0eXBlb2Ygdm5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2bm9kZSA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gbm9kZS5zcGxpdFRleHQgIT09IHVuZGVmaW5lZDtcblx0fVxuXHRpZiAodHlwZW9mIHZub2RlLm5vZGVOYW1lID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiAhbm9kZS5fY29tcG9uZW50Q29uc3RydWN0b3IgJiYgaXNOYW1lZE5vZGUobm9kZSwgdm5vZGUubm9kZU5hbWUpO1xuXHR9XG5cdHJldHVybiBoeWRyYXRpbmcgfHwgbm9kZS5fY29tcG9uZW50Q29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lO1xufVxuXG4vKiogQ2hlY2sgaWYgYW4gRWxlbWVudCBoYXMgYSBnaXZlbiBub3JtYWxpemVkIG5hbWUuXG4qXHRAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbipcdEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBpc05hbWVkTm9kZShub2RlLCBub2RlTmFtZSkge1xuXHRyZXR1cm4gbm9kZS5ub3JtYWxpemVkTm9kZU5hbWUgPT09IG5vZGVOYW1lIHx8IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdCBDb21wb25lbnQtc3R5bGUgYHByb3BzYCBmcm9tIGEgVk5vZGUuXG4gKiBFbnN1cmVzIGRlZmF1bHQvZmFsbGJhY2sgdmFsdWVzIGZyb20gYGRlZmF1bHRQcm9wc2A6XG4gKiBPd24tcHJvcGVydGllcyBvZiBgZGVmYXVsdFByb3BzYCBub3QgcHJlc2VudCBpbiBgdm5vZGUuYXR0cmlidXRlc2AgYXJlIGFkZGVkLlxuICogQHBhcmFtIHtWTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVQcm9wcyh2bm9kZSkge1xuXHR2YXIgcHJvcHMgPSBleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpO1xuXHRwcm9wcy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuXG5cdHZhciBkZWZhdWx0UHJvcHMgPSB2bm9kZS5ub2RlTmFtZS5kZWZhdWx0UHJvcHM7XG5cdGlmIChkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGkgaW4gZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAocHJvcHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwcm9wc1tpXSA9IGRlZmF1bHRQcm9wc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcHJvcHM7XG59XG5cbi8qKiBDcmVhdGUgYW4gZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBub2RlTmFtZS5cbiAqXHRAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqXHRAcGFyYW0ge0Jvb2xlYW59IFtpc1N2Zz1mYWxzZV1cdElmIGB0cnVlYCwgY3JlYXRlcyBhbiBlbGVtZW50IHdpdGhpbiB0aGUgU1ZHIG5hbWVzcGFjZS5cbiAqXHRAcmV0dXJucyB7RWxlbWVudH0gbm9kZVxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2RlKG5vZGVOYW1lLCBpc1N2Zykge1xuXHR2YXIgbm9kZSA9IGlzU3ZnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5vZGVOYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuXHRub2RlLm5vcm1hbGl6ZWROb2RlTmFtZSA9IG5vZGVOYW1lO1xuXHRyZXR1cm4gbm9kZTtcbn1cblxuLyoqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gbm9kZVx0XHRUaGUgbm9kZSB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuLyoqIFNldCBhIG5hbWVkIGF0dHJpYnV0ZSBvbiB0aGUgZ2l2ZW4gTm9kZSwgd2l0aCBzcGVjaWFsIGJlaGF2aW9yIGZvciBzb21lIG5hbWVzIGFuZCBldmVudCBoYW5kbGVycy5cbiAqXHRJZiBgdmFsdWVgIGlzIGBudWxsYCwgdGhlIGF0dHJpYnV0ZS9oYW5kbGVyIHdpbGwgYmUgcmVtb3ZlZC5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IG5vZGVcdEFuIGVsZW1lbnQgdG8gbXV0YXRlXG4gKlx0QHBhcmFtIHtzdHJpbmd9IG5hbWVcdFRoZSBuYW1lL2tleSB0byBzZXQsIHN1Y2ggYXMgYW4gZXZlbnQgb3IgYXR0cmlidXRlIG5hbWVcbiAqXHRAcGFyYW0ge2FueX0gb2xkXHRUaGUgbGFzdCB2YWx1ZSB0aGF0IHdhcyBzZXQgZm9yIHRoaXMgbmFtZS9ub2RlIHBhaXJcbiAqXHRAcGFyYW0ge2FueX0gdmFsdWVcdEFuIGF0dHJpYnV0ZSB2YWx1ZSwgc3VjaCBhcyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgYXMgYW4gZXZlbnQgaGFuZGxlclxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gaXNTdmdcdEFyZSB3ZSBjdXJyZW50bHkgZGlmZmluZyBpbnNpZGUgYW4gc3ZnP1xuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldEFjY2Vzc29yKG5vZGUsIG5hbWUsIG9sZCwgdmFsdWUsIGlzU3ZnKSB7XG5cdGlmIChuYW1lID09PSAnY2xhc3NOYW1lJykgbmFtZSA9ICdjbGFzcyc7XG5cblx0aWYgKG5hbWUgPT09ICdrZXknKSB7XG5cdFx0Ly8gaWdub3JlXG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJ3JlZicpIHtcblx0XHRpZiAob2xkKSBvbGQobnVsbCk7XG5cdFx0aWYgKHZhbHVlKSB2YWx1ZShub2RlKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnICYmICFpc1N2Zykge1xuXHRcdG5vZGUuY2xhc3NOYW1lID0gdmFsdWUgfHwgJyc7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb2xkID09PSAnc3RyaW5nJykge1xuXHRcdFx0bm9kZS5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgfHwgJyc7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShpIGluIHZhbHVlKSkgbm9kZS5zdHlsZVtpXSA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpIGluIHZhbHVlKSB7XG5cdFx0XHRcdG5vZGUuc3R5bGVbaV0gPSB0eXBlb2YgdmFsdWVbaV0gPT09ICdudW1iZXInICYmIElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGkpID09PSBmYWxzZSA/IHZhbHVlW2ldICsgJ3B4JyA6IHZhbHVlW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKHZhbHVlKSBub2RlLmlubmVySFRNTCA9IHZhbHVlLl9faHRtbCB8fCAnJztcblx0fSBlbHNlIGlmIChuYW1lWzBdID09ICdvJyAmJiBuYW1lWzFdID09ICduJykge1xuXHRcdHZhciB1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcblx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygyKTtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcblx0XHR9XG5cdFx0KG5vZGUuX2xpc3RlbmVycyB8fCAobm9kZS5fbGlzdGVuZXJzID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuXHR9IGVsc2UgaWYgKG5hbWUgIT09ICdsaXN0JyAmJiBuYW1lICE9PSAndHlwZScgJiYgIWlzU3ZnICYmIG5hbWUgaW4gbm9kZSkge1xuXHRcdHNldFByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlKTtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBucyA9IGlzU3ZnICYmIG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9eeGxpbmtcXDo/LywgJycpKTtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRcdGlmIChucykgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG5hbWUudG9Mb3dlckNhc2UoKSk7ZWxzZSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYgKG5zKSBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7ZWxzZSBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKiBBdHRlbXB0IHRvIHNldCBhIERPTSBwcm9wZXJ0eSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlx0SUUgJiBGRiB0aHJvdyBmb3IgY2VydGFpbiBwcm9wZXJ0eS12YWx1ZSBjb21iaW5hdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldFByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0bm9kZVtuYW1lXSA9IHZhbHVlO1xuXHR9IGNhdGNoIChlKSB7fVxufVxuXG4vKiogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlXShvcHRpb25zLmV2ZW50ICYmIG9wdGlvbnMuZXZlbnQoZSkgfHwgZSk7XG59XG5cbi8qKiBRdWV1ZSBvZiBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIG1vdW50ZWQgYW5kIGFyZSBhd2FpdGluZyBjb21wb25lbnREaWRNb3VudCAqL1xudmFyIG1vdW50cyA9IFtdO1xuXG4vKiogRGlmZiByZWN1cnNpb24gY291bnQsIHVzZWQgdG8gdHJhY2sgdGhlIGVuZCBvZiB0aGUgZGlmZiBjeWNsZS4gKi9cbnZhciBkaWZmTGV2ZWwgPSAwO1xuXG4vKiogR2xvYmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgZGlmZiBpcyBjdXJyZW50bHkgd2l0aGluIGFuIFNWRyAqL1xudmFyIGlzU3ZnTW9kZSA9IGZhbHNlO1xuXG4vKiogR2xvYmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgZGlmZiBpcyBwZXJmb3JtaW5nIGh5ZHJhdGlvbiAqL1xudmFyIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4vKiogSW52b2tlIHF1ZXVlZCBjb21wb25lbnREaWRNb3VudCBsaWZlY3ljbGUgbWV0aG9kcyAqL1xuZnVuY3Rpb24gZmx1c2hNb3VudHMoKSB7XG5cdHZhciBjO1xuXHR3aGlsZSAoYyA9IG1vdW50cy5wb3AoKSkge1xuXHRcdGlmIChvcHRpb25zLmFmdGVyTW91bnQpIG9wdGlvbnMuYWZ0ZXJNb3VudChjKTtcblx0XHRpZiAoYy5jb21wb25lbnREaWRNb3VudCkgYy5jb21wb25lbnREaWRNb3VudCgpO1xuXHR9XG59XG5cbi8qKiBBcHBseSBkaWZmZXJlbmNlcyBpbiBhIGdpdmVuIHZub2RlIChhbmQgaXQncyBkZWVwIGNoaWxkcmVuKSB0byBhIHJlYWwgRE9NIE5vZGUuXG4gKlx0QHBhcmFtIHtFbGVtZW50fSBbZG9tPW51bGxdXHRcdEEgRE9NIG5vZGUgdG8gbXV0YXRlIGludG8gdGhlIHNoYXBlIG9mIHRoZSBgdm5vZGVgXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdFx0XHRBIFZOb2RlICh3aXRoIGRlc2NlbmRhbnRzIGZvcm1pbmcgYSB0cmVlKSByZXByZXNlbnRpbmcgdGhlIGRlc2lyZWQgRE9NIHN0cnVjdHVyZVxuICpcdEByZXR1cm5zIHtFbGVtZW50fSBkb21cdFx0XHRUaGUgY3JlYXRlZC9tdXRhdGVkIGVsZW1lbnRcbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBwYXJlbnQsIGNvbXBvbmVudFJvb3QpIHtcblx0Ly8gZGlmZkxldmVsIGhhdmluZyBiZWVuIDAgaGVyZSBpbmRpY2F0ZXMgaW5pdGlhbCBlbnRyeSBpbnRvIHRoZSBkaWZmIChub3QgYSBzdWJkaWZmKVxuXHRpZiAoIWRpZmZMZXZlbCsrKSB7XG5cdFx0Ly8gd2hlbiBmaXJzdCBzdGFydGluZyB0aGUgZGlmZiwgY2hlY2sgaWYgd2UncmUgZGlmZmluZyBhbiBTVkcgb3Igd2l0aGluIGFuIFNWR1xuXHRcdGlzU3ZnTW9kZSA9IHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZDtcblxuXHRcdC8vIGh5ZHJhdGlvbiBpcyBpbmRpY2F0ZWQgYnkgdGhlIGV4aXN0aW5nIGVsZW1lbnQgdG8gYmUgZGlmZmVkIG5vdCBoYXZpbmcgYSBwcm9wIGNhY2hlXG5cdFx0aHlkcmF0aW5nID0gZG9tICE9IG51bGwgJiYgISgnX19wcmVhY3RhdHRyXycgaW4gZG9tKTtcblx0fVxuXG5cdHZhciByZXQgPSBpZGlmZihkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCwgY29tcG9uZW50Um9vdCk7XG5cblx0Ly8gYXBwZW5kIHRoZSBlbGVtZW50IGlmIGl0cyBhIG5ldyBwYXJlbnRcblx0aWYgKHBhcmVudCAmJiByZXQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSBwYXJlbnQuYXBwZW5kQ2hpbGQocmV0KTtcblxuXHQvLyBkaWZmTGV2ZWwgYmVpbmcgcmVkdWNlZCB0byAwIG1lYW5zIHdlJ3JlIGV4aXRpbmcgdGhlIGRpZmZcblx0aWYgKCEgLS1kaWZmTGV2ZWwpIHtcblx0XHRoeWRyYXRpbmcgPSBmYWxzZTtcblx0XHQvLyBpbnZva2UgcXVldWVkIGNvbXBvbmVudERpZE1vdW50IGxpZmVjeWNsZSBtZXRob2RzXG5cdFx0aWYgKCFjb21wb25lbnRSb290KSBmbHVzaE1vdW50cygpO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuLyoqIEludGVybmFscyBvZiBgZGlmZigpYCwgc2VwYXJhdGVkIHRvIGFsbG93IGJ5cGFzc2luZyBkaWZmTGV2ZWwgLyBtb3VudCBmbHVzaGluZy4gKi9cbmZ1bmN0aW9uIGlkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBjb21wb25lbnRSb290KSB7XG5cdHZhciBvdXQgPSBkb20sXG5cdCAgICBwcmV2U3ZnTW9kZSA9IGlzU3ZnTW9kZTtcblxuXHQvLyBlbXB0eSB2YWx1ZXMgKG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbnMpIHJlbmRlciBhcyBlbXB0eSBUZXh0IG5vZGVzXG5cdGlmICh2bm9kZSA9PSBudWxsIHx8IHR5cGVvZiB2bm9kZSA9PT0gJ2Jvb2xlYW4nKSB2bm9kZSA9ICcnO1xuXG5cdC8vIEZhc3QgY2FzZTogU3RyaW5ncyAmIE51bWJlcnMgY3JlYXRlL3VwZGF0ZSBUZXh0IG5vZGVzLlxuXHRpZiAodHlwZW9mIHZub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygdm5vZGUgPT09ICdudW1iZXInKSB7XG5cblx0XHQvLyB1cGRhdGUgaWYgaXQncyBhbHJlYWR5IGEgVGV4dCBub2RlOlxuXHRcdGlmIChkb20gJiYgZG9tLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkICYmIGRvbS5wYXJlbnROb2RlICYmICghZG9tLl9jb21wb25lbnQgfHwgY29tcG9uZW50Um9vdCkpIHtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvKiBCcm93c2VyIHF1aXJrIHRoYXQgY2FuJ3QgYmUgY292ZXJlZDogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvY29tbWl0L2ZkNGYyMWY1YzQ1ZGZkNzUxNTFiZDI3YjRjMjE3ZDgwMDNhYTVlYjkgKi9cblx0XHRcdGlmIChkb20ubm9kZVZhbHVlICE9IHZub2RlKSB7XG5cdFx0XHRcdGRvbS5ub2RlVmFsdWUgPSB2bm9kZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaXQgd2Fzbid0IGEgVGV4dCBub2RlOiByZXBsYWNlIGl0IHdpdGggb25lIGFuZCByZWN5Y2xlIHRoZSBvbGQgRWxlbWVudFxuXHRcdFx0b3V0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUpO1xuXHRcdFx0aWYgKGRvbSkge1xuXHRcdFx0XHRpZiAoZG9tLnBhcmVudE5vZGUpIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChvdXQsIGRvbSk7XG5cdFx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b3V0WydfX3ByZWFjdGF0dHJfJ10gPSB0cnVlO1xuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdC8vIElmIHRoZSBWTm9kZSByZXByZXNlbnRzIGEgQ29tcG9uZW50LCBwZXJmb3JtIGEgY29tcG9uZW50IGRpZmY6XG5cdHZhciB2bm9kZU5hbWUgPSB2bm9kZS5ub2RlTmFtZTtcblx0aWYgKHR5cGVvZiB2bm9kZU5hbWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYnVpbGRDb21wb25lbnRGcm9tVk5vZGUoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwpO1xuXHR9XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlzU3ZnTW9kZSA9IHZub2RlTmFtZSA9PT0gJ3N2ZycgPyB0cnVlIDogdm5vZGVOYW1lID09PSAnZm9yZWlnbk9iamVjdCcgPyBmYWxzZSA6IGlzU3ZnTW9kZTtcblxuXHQvLyBJZiB0aGVyZSdzIG5vIGV4aXN0aW5nIGVsZW1lbnQgb3IgaXQncyB0aGUgd3JvbmcgdHlwZSwgY3JlYXRlIGEgbmV3IG9uZTpcblx0dm5vZGVOYW1lID0gU3RyaW5nKHZub2RlTmFtZSk7XG5cdGlmICghZG9tIHx8ICFpc05hbWVkTm9kZShkb20sIHZub2RlTmFtZSkpIHtcblx0XHRvdXQgPSBjcmVhdGVOb2RlKHZub2RlTmFtZSwgaXNTdmdNb2RlKTtcblxuXHRcdGlmIChkb20pIHtcblx0XHRcdC8vIG1vdmUgY2hpbGRyZW4gaW50byB0aGUgcmVwbGFjZW1lbnQgbm9kZVxuXHRcdFx0d2hpbGUgKGRvbS5maXJzdENoaWxkKSB7XG5cdFx0XHRcdG91dC5hcHBlbmRDaGlsZChkb20uZmlyc3RDaGlsZCk7XG5cdFx0XHR9IC8vIGlmIHRoZSBwcmV2aW91cyBFbGVtZW50IHdhcyBtb3VudGVkIGludG8gdGhlIERPTSwgcmVwbGFjZSBpdCBpbmxpbmVcblx0XHRcdGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcblxuXHRcdFx0Ly8gcmVjeWNsZSB0aGUgb2xkIGVsZW1lbnQgKHNraXBzIG5vbi1FbGVtZW50IG5vZGUgdHlwZXMpXG5cdFx0XHRyZWNvbGxlY3ROb2RlVHJlZShkb20sIHRydWUpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBmYyA9IG91dC5maXJzdENoaWxkLFxuXHQgICAgcHJvcHMgPSBvdXRbJ19fcHJlYWN0YXR0cl8nXSxcblx0ICAgIHZjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuXG5cdGlmIChwcm9wcyA9PSBudWxsKSB7XG5cdFx0cHJvcHMgPSBvdXRbJ19fcHJlYWN0YXR0cl8nXSA9IHt9O1xuXHRcdGZvciAodmFyIGEgPSBvdXQuYXR0cmlidXRlcywgaSA9IGEubGVuZ3RoOyBpLS07KSB7XG5cdFx0XHRwcm9wc1thW2ldLm5hbWVdID0gYVtpXS52YWx1ZTtcblx0XHR9XG5cdH1cblxuXHQvLyBPcHRpbWl6YXRpb246IGZhc3QtcGF0aCBmb3IgZWxlbWVudHMgY29udGFpbmluZyBhIHNpbmdsZSBUZXh0Tm9kZTpcblx0aWYgKCFoeWRyYXRpbmcgJiYgdmNoaWxkcmVuICYmIHZjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZjaGlsZHJlblswXSA9PT0gJ3N0cmluZycgJiYgZmMgIT0gbnVsbCAmJiBmYy5zcGxpdFRleHQgIT09IHVuZGVmaW5lZCAmJiBmYy5uZXh0U2libGluZyA9PSBudWxsKSB7XG5cdFx0aWYgKGZjLm5vZGVWYWx1ZSAhPSB2Y2hpbGRyZW5bMF0pIHtcblx0XHRcdGZjLm5vZGVWYWx1ZSA9IHZjaGlsZHJlblswXTtcblx0XHR9XG5cdH1cblx0Ly8gb3RoZXJ3aXNlLCBpZiB0aGVyZSBhcmUgZXhpc3Rpbmcgb3IgbmV3IGNoaWxkcmVuLCBkaWZmIHRoZW06XG5cdGVsc2UgaWYgKHZjaGlsZHJlbiAmJiB2Y2hpbGRyZW4ubGVuZ3RoIHx8IGZjICE9IG51bGwpIHtcblx0XHRcdGlubmVyRGlmZk5vZGUob3V0LCB2Y2hpbGRyZW4sIGNvbnRleHQsIG1vdW50QWxsLCBoeWRyYXRpbmcgfHwgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCk7XG5cdFx0fVxuXG5cdC8vIEFwcGx5IGF0dHJpYnV0ZXMvcHJvcHMgZnJvbSBWTm9kZSB0byB0aGUgRE9NIEVsZW1lbnQ6XG5cdGRpZmZBdHRyaWJ1dGVzKG91dCwgdm5vZGUuYXR0cmlidXRlcywgcHJvcHMpO1xuXG5cdC8vIHJlc3RvcmUgcHJldmlvdXMgU1ZHIG1vZGU6IChpbiBjYXNlIHdlJ3JlIGV4aXRpbmcgYW4gU1ZHIG5hbWVzcGFjZSlcblx0aXNTdmdNb2RlID0gcHJldlN2Z01vZGU7XG5cblx0cmV0dXJuIG91dDtcbn1cblxuLyoqIEFwcGx5IGNoaWxkIGFuZCBhdHRyaWJ1dGUgY2hhbmdlcyBiZXR3ZWVuIGEgVk5vZGUgYW5kIGEgRE9NIE5vZGUgdG8gdGhlIERPTS5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IGRvbVx0XHRcdEVsZW1lbnQgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGNvbXBhcmVkICYgbXV0YXRlZFxuICpcdEBwYXJhbSB7QXJyYXl9IHZjaGlsZHJlblx0XHRBcnJheSBvZiBWTm9kZXMgdG8gY29tcGFyZSB0byBgZG9tLmNoaWxkTm9kZXNgXG4gKlx0QHBhcmFtIHtPYmplY3R9IGNvbnRleHRcdFx0XHRJbXBsaWNpdGx5IGRlc2NlbmRhbnQgY29udGV4dCBvYmplY3QgKGZyb20gbW9zdCByZWNlbnQgYGdldENoaWxkQ29udGV4dCgpYClcbiAqXHRAcGFyYW0ge0Jvb2xlYW59IG1vdW50QWxsXG4gKlx0QHBhcmFtIHtCb29sZWFufSBpc0h5ZHJhdGluZ1x0SWYgYHRydWVgLCBjb25zdW1lcyBleHRlcm5hbGx5IGNyZWF0ZWQgZWxlbWVudHMgc2ltaWxhciB0byBoeWRyYXRpb25cbiAqL1xuZnVuY3Rpb24gaW5uZXJEaWZmTm9kZShkb20sIHZjaGlsZHJlbiwgY29udGV4dCwgbW91bnRBbGwsIGlzSHlkcmF0aW5nKSB7XG5cdHZhciBvcmlnaW5hbENoaWxkcmVuID0gZG9tLmNoaWxkTm9kZXMsXG5cdCAgICBjaGlsZHJlbiA9IFtdLFxuXHQgICAga2V5ZWQgPSB7fSxcblx0ICAgIGtleWVkTGVuID0gMCxcblx0ICAgIG1pbiA9IDAsXG5cdCAgICBsZW4gPSBvcmlnaW5hbENoaWxkcmVuLmxlbmd0aCxcblx0ICAgIGNoaWxkcmVuTGVuID0gMCxcblx0ICAgIHZsZW4gPSB2Y2hpbGRyZW4gPyB2Y2hpbGRyZW4ubGVuZ3RoIDogMCxcblx0ICAgIGosXG5cdCAgICBjLFxuXHQgICAgZixcblx0ICAgIHZjaGlsZCxcblx0ICAgIGNoaWxkO1xuXG5cdC8vIEJ1aWxkIHVwIGEgbWFwIG9mIGtleWVkIGNoaWxkcmVuIGFuZCBhbiBBcnJheSBvZiB1bmtleWVkIGNoaWxkcmVuOlxuXHRpZiAobGVuICE9PSAwKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIF9jaGlsZCA9IG9yaWdpbmFsQ2hpbGRyZW5baV0sXG5cdFx0XHQgICAgcHJvcHMgPSBfY2hpbGRbJ19fcHJlYWN0YXR0cl8nXSxcblx0XHRcdCAgICBrZXkgPSB2bGVuICYmIHByb3BzID8gX2NoaWxkLl9jb21wb25lbnQgPyBfY2hpbGQuX2NvbXBvbmVudC5fX2tleSA6IHByb3BzLmtleSA6IG51bGw7XG5cdFx0XHRpZiAoa2V5ICE9IG51bGwpIHtcblx0XHRcdFx0a2V5ZWRMZW4rKztcblx0XHRcdFx0a2V5ZWRba2V5XSA9IF9jaGlsZDtcblx0XHRcdH0gZWxzZSBpZiAocHJvcHMgfHwgKF9jaGlsZC5zcGxpdFRleHQgIT09IHVuZGVmaW5lZCA/IGlzSHlkcmF0aW5nID8gX2NoaWxkLm5vZGVWYWx1ZS50cmltKCkgOiB0cnVlIDogaXNIeWRyYXRpbmcpKSB7XG5cdFx0XHRcdGNoaWxkcmVuW2NoaWxkcmVuTGVuKytdID0gX2NoaWxkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICh2bGVuICE9PSAwKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bGVuOyBpKyspIHtcblx0XHRcdHZjaGlsZCA9IHZjaGlsZHJlbltpXTtcblx0XHRcdGNoaWxkID0gbnVsbDtcblxuXHRcdFx0Ly8gYXR0ZW1wdCB0byBmaW5kIGEgbm9kZSBiYXNlZCBvbiBrZXkgbWF0Y2hpbmdcblx0XHRcdHZhciBrZXkgPSB2Y2hpbGQua2V5O1xuXHRcdFx0aWYgKGtleSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChrZXllZExlbiAmJiBrZXllZFtrZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjaGlsZCA9IGtleWVkW2tleV07XG5cdFx0XHRcdFx0a2V5ZWRba2V5XSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRrZXllZExlbi0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhdHRlbXB0IHRvIHBsdWNrIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlIGZyb20gdGhlIGV4aXN0aW5nIGNoaWxkcmVuXG5cdFx0XHRlbHNlIGlmICghY2hpbGQgJiYgbWluIDwgY2hpbGRyZW5MZW4pIHtcblx0XHRcdFx0XHRmb3IgKGogPSBtaW47IGogPCBjaGlsZHJlbkxlbjsgaisrKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2hpbGRyZW5bal0gIT09IHVuZGVmaW5lZCAmJiBpc1NhbWVOb2RlVHlwZShjID0gY2hpbGRyZW5bal0sIHZjaGlsZCwgaXNIeWRyYXRpbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkID0gYztcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGlmIChqID09PSBjaGlsZHJlbkxlbiAtIDEpIGNoaWxkcmVuTGVuLS07XG5cdFx0XHRcdFx0XHRcdGlmIChqID09PSBtaW4pIG1pbisrO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gbW9ycGggdGhlIG1hdGNoZWQvZm91bmQvY3JlYXRlZCBET00gY2hpbGQgdG8gbWF0Y2ggdmNoaWxkIChkZWVwKVxuXHRcdFx0Y2hpbGQgPSBpZGlmZihjaGlsZCwgdmNoaWxkLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cblx0XHRcdGYgPSBvcmlnaW5hbENoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICYmIGNoaWxkICE9PSBkb20gJiYgY2hpbGQgIT09IGYpIHtcblx0XHRcdFx0aWYgKGYgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGRvbS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hpbGQgPT09IGYubmV4dFNpYmxpbmcpIHtcblx0XHRcdFx0XHRyZW1vdmVOb2RlKGYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvbS5pbnNlcnRCZWZvcmUoY2hpbGQsIGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gcmVtb3ZlIHVudXNlZCBrZXllZCBjaGlsZHJlbjpcblx0aWYgKGtleWVkTGVuKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiBrZXllZCkge1xuXHRcdFx0aWYgKGtleWVkW2ldICE9PSB1bmRlZmluZWQpIHJlY29sbGVjdE5vZGVUcmVlKGtleWVkW2ldLCBmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gcmVtb3ZlIG9ycGhhbmVkIHVua2V5ZWQgY2hpbGRyZW46XG5cdHdoaWxlIChtaW4gPD0gY2hpbGRyZW5MZW4pIHtcblx0XHRpZiAoKGNoaWxkID0gY2hpbGRyZW5bY2hpbGRyZW5MZW4tLV0pICE9PSB1bmRlZmluZWQpIHJlY29sbGVjdE5vZGVUcmVlKGNoaWxkLCBmYWxzZSk7XG5cdH1cbn1cblxuLyoqIFJlY3Vyc2l2ZWx5IHJlY3ljbGUgKG9yIGp1c3QgdW5tb3VudCkgYSBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMuXG4gKlx0QHBhcmFtIHtOb2RlfSBub2RlXHRcdFx0XHRcdFx0RE9NIG5vZGUgdG8gc3RhcnQgdW5tb3VudC9yZW1vdmFsIGZyb21cbiAqXHRAcGFyYW0ge0Jvb2xlYW59IFt1bm1vdW50T25seT1mYWxzZV1cdElmIGB0cnVlYCwgb25seSB0cmlnZ2VycyB1bm1vdW50IGxpZmVjeWNsZSwgc2tpcHMgcmVtb3ZhbFxuICovXG5mdW5jdGlvbiByZWNvbGxlY3ROb2RlVHJlZShub2RlLCB1bm1vdW50T25seSkge1xuXHR2YXIgY29tcG9uZW50ID0gbm9kZS5fY29tcG9uZW50O1xuXHRpZiAoY29tcG9uZW50KSB7XG5cdFx0Ly8gaWYgbm9kZSBpcyBvd25lZCBieSBhIENvbXBvbmVudCwgdW5tb3VudCB0aGF0IGNvbXBvbmVudCAoZW5kcyB1cCByZWN1cnNpbmcgYmFjayBoZXJlKVxuXHRcdHVubW91bnRDb21wb25lbnQoY29tcG9uZW50KTtcblx0fSBlbHNlIHtcblx0XHQvLyBJZiB0aGUgbm9kZSdzIFZOb2RlIGhhZCBhIHJlZiBmdW5jdGlvbiwgaW52b2tlIGl0IHdpdGggbnVsbCBoZXJlLlxuXHRcdC8vICh0aGlzIGlzIHBhcnQgb2YgdGhlIFJlYWN0IHNwZWMsIGFuZCBzbWFydCBmb3IgdW5zZXR0aW5nIHJlZmVyZW5jZXMpXG5cdFx0aWYgKG5vZGVbJ19fcHJlYWN0YXR0cl8nXSAhPSBudWxsICYmIG5vZGVbJ19fcHJlYWN0YXR0cl8nXS5yZWYpIG5vZGVbJ19fcHJlYWN0YXR0cl8nXS5yZWYobnVsbCk7XG5cblx0XHRpZiAodW5tb3VudE9ubHkgPT09IGZhbHNlIHx8IG5vZGVbJ19fcHJlYWN0YXR0cl8nXSA9PSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG5vZGUpO1xuXHRcdH1cblxuXHRcdHJlbW92ZUNoaWxkcmVuKG5vZGUpO1xuXHR9XG59XG5cbi8qKiBSZWNvbGxlY3QvdW5tb3VudCBhbGwgY2hpbGRyZW4uXG4gKlx0LSB3ZSB1c2UgLmxhc3RDaGlsZCBoZXJlIGJlY2F1c2UgaXQgY2F1c2VzIGxlc3MgcmVmbG93IHRoYW4gLmZpcnN0Q2hpbGRcbiAqXHQtIGl0J3MgYWxzbyBjaGVhcGVyIHRoYW4gYWNjZXNzaW5nIHRoZSAuY2hpbGROb2RlcyBMaXZlIE5vZGVMaXN0XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcblx0bm9kZSA9IG5vZGUubGFzdENoaWxkO1xuXHR3aGlsZSAobm9kZSkge1xuXHRcdHZhciBuZXh0ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG5cdFx0cmVjb2xsZWN0Tm9kZVRyZWUobm9kZSwgdHJ1ZSk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cblxuLyoqIEFwcGx5IGRpZmZlcmVuY2VzIGluIGF0dHJpYnV0ZXMgZnJvbSBhIFZOb2RlIHRvIHRoZSBnaXZlbiBET00gRWxlbWVudC5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IGRvbVx0XHRFbGVtZW50IHdpdGggYXR0cmlidXRlcyB0byBkaWZmIGBhdHRyc2AgYWdhaW5zdFxuICpcdEBwYXJhbSB7T2JqZWN0fSBhdHRyc1x0XHRUaGUgZGVzaXJlZCBlbmQtc3RhdGUga2V5LXZhbHVlIGF0dHJpYnV0ZSBwYWlyc1xuICpcdEBwYXJhbSB7T2JqZWN0fSBvbGRcdFx0XHRDdXJyZW50L3ByZXZpb3VzIGF0dHJpYnV0ZXMgKGZyb20gcHJldmlvdXMgVk5vZGUgb3IgZWxlbWVudCdzIHByb3AgY2FjaGUpXG4gKi9cbmZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKGRvbSwgYXR0cnMsIG9sZCkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyByZW1vdmUgYXR0cmlidXRlcyBubyBsb25nZXIgcHJlc2VudCBvbiB0aGUgdm5vZGUgYnkgc2V0dGluZyB0aGVtIHRvIHVuZGVmaW5lZFxuXHRmb3IgKG5hbWUgaW4gb2xkKSB7XG5cdFx0aWYgKCEoYXR0cnMgJiYgYXR0cnNbbmFtZV0gIT0gbnVsbCkgJiYgb2xkW25hbWVdICE9IG51bGwpIHtcblx0XHRcdHNldEFjY2Vzc29yKGRvbSwgbmFtZSwgb2xkW25hbWVdLCBvbGRbbmFtZV0gPSB1bmRlZmluZWQsIGlzU3ZnTW9kZSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gYWRkIG5ldyAmIHVwZGF0ZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcblx0Zm9yIChuYW1lIGluIGF0dHJzKSB7XG5cdFx0aWYgKG5hbWUgIT09ICdjaGlsZHJlbicgJiYgbmFtZSAhPT0gJ2lubmVySFRNTCcgJiYgKCEobmFtZSBpbiBvbGQpIHx8IGF0dHJzW25hbWVdICE9PSAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnY2hlY2tlZCcgPyBkb21bbmFtZV0gOiBvbGRbbmFtZV0pKSkge1xuXHRcdFx0c2V0QWNjZXNzb3IoZG9tLCBuYW1lLCBvbGRbbmFtZV0sIG9sZFtuYW1lXSA9IGF0dHJzW25hbWVdLCBpc1N2Z01vZGUpO1xuXHRcdH1cblx0fVxufVxuXG4vKiogUmV0YWlucyBhIHBvb2wgb2YgQ29tcG9uZW50cyBmb3IgcmUtdXNlLCBrZXllZCBvbiBjb21wb25lbnQgbmFtZS5cbiAqXHROb3RlOiBzaW5jZSBjb21wb25lbnQgbmFtZXMgYXJlIG5vdCB1bmlxdWUgb3IgZXZlbiBuZWNlc3NhcmlseSBhdmFpbGFibGUsIHRoZXNlIGFyZSBwcmltYXJpbHkgYSBmb3JtIG9mIHNoYXJkaW5nLlxuICpcdEBwcml2YXRlXG4gKi9cbnZhciBjb21wb25lbnRzID0ge307XG5cbi8qKiBSZWNsYWltIGEgY29tcG9uZW50IGZvciBsYXRlciByZS11c2UgYnkgdGhlIHJlY3ljbGVyLiAqL1xuZnVuY3Rpb24gY29sbGVjdENvbXBvbmVudChjb21wb25lbnQpIHtcblx0dmFyIG5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcblx0KGNvbXBvbmVudHNbbmFtZV0gfHwgKGNvbXBvbmVudHNbbmFtZV0gPSBbXSkpLnB1c2goY29tcG9uZW50KTtcbn1cblxuLyoqIENyZWF0ZSBhIGNvbXBvbmVudC4gTm9ybWFsaXplcyBkaWZmZXJlbmNlcyBiZXR3ZWVuIFBGQydzIGFuZCBjbGFzc2Z1bCBDb21wb25lbnRzLiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIHByb3BzLCBjb250ZXh0KSB7XG5cdHZhciBsaXN0ID0gY29tcG9uZW50c1tDdG9yLm5hbWVdLFxuXHQgICAgaW5zdDtcblxuXHRpZiAoQ3Rvci5wcm90b3R5cGUgJiYgQ3Rvci5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0aW5zdCA9IG5ldyBDdG9yKHByb3BzLCBjb250ZXh0KTtcblx0XHRDb21wb25lbnQuY2FsbChpbnN0LCBwcm9wcywgY29udGV4dCk7XG5cdH0gZWxzZSB7XG5cdFx0aW5zdCA9IG5ldyBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpO1xuXHRcdGluc3QuY29uc3RydWN0b3IgPSBDdG9yO1xuXHRcdGluc3QucmVuZGVyID0gZG9SZW5kZXI7XG5cdH1cblxuXHRpZiAobGlzdCkge1xuXHRcdGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aDsgaS0tOykge1xuXHRcdFx0aWYgKGxpc3RbaV0uY29uc3RydWN0b3IgPT09IEN0b3IpIHtcblx0XHRcdFx0aW5zdC5uZXh0QmFzZSA9IGxpc3RbaV0ubmV4dEJhc2U7XG5cdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGluc3Q7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cblxuLyoqIFNldCBhIGNvbXBvbmVudCdzIGBwcm9wc2AgKGdlbmVyYWxseSBkZXJpdmVkIGZyb20gSlNYIGF0dHJpYnV0ZXMpLlxuICpcdEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICpcdEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqXHRAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnJlbmRlclN5bmM9ZmFsc2VdXHRJZiBgdHJ1ZWAgYW5kIHtAbGluayBvcHRpb25zLnN5bmNDb21wb25lbnRVcGRhdGVzfSBpcyBgdHJ1ZWAsIHRyaWdnZXJzIHN5bmNocm9ub3VzIHJlbmRlcmluZy5cbiAqXHRAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnJlbmRlcj10cnVlXVx0XHRcdElmIGBmYWxzZWAsIG5vIHJlbmRlciB3aWxsIGJlIHRyaWdnZXJlZC5cbiAqL1xuZnVuY3Rpb24gc2V0Q29tcG9uZW50UHJvcHMoY29tcG9uZW50LCBwcm9wcywgb3B0cywgY29udGV4dCwgbW91bnRBbGwpIHtcblx0aWYgKGNvbXBvbmVudC5fZGlzYWJsZSkgcmV0dXJuO1xuXHRjb21wb25lbnQuX2Rpc2FibGUgPSB0cnVlO1xuXG5cdGlmIChjb21wb25lbnQuX19yZWYgPSBwcm9wcy5yZWYpIGRlbGV0ZSBwcm9wcy5yZWY7XG5cdGlmIChjb21wb25lbnQuX19rZXkgPSBwcm9wcy5rZXkpIGRlbGV0ZSBwcm9wcy5rZXk7XG5cblx0aWYgKCFjb21wb25lbnQuYmFzZSB8fCBtb3VudEFsbCkge1xuXHRcdGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbE1vdW50KSBjb21wb25lbnQuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdH0gZWxzZSBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcblx0XHRjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcywgY29udGV4dCk7XG5cdH1cblxuXHRpZiAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBjb21wb25lbnQuY29udGV4dCkge1xuXHRcdGlmICghY29tcG9uZW50LnByZXZDb250ZXh0KSBjb21wb25lbnQucHJldkNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcblx0XHRjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG5cdH1cblxuXHRpZiAoIWNvbXBvbmVudC5wcmV2UHJvcHMpIGNvbXBvbmVudC5wcmV2UHJvcHMgPSBjb21wb25lbnQucHJvcHM7XG5cdGNvbXBvbmVudC5wcm9wcyA9IHByb3BzO1xuXG5cdGNvbXBvbmVudC5fZGlzYWJsZSA9IGZhbHNlO1xuXG5cdGlmIChvcHRzICE9PSAwKSB7XG5cdFx0aWYgKG9wdHMgPT09IDEgfHwgb3B0aW9ucy5zeW5jQ29tcG9uZW50VXBkYXRlcyAhPT0gZmFsc2UgfHwgIWNvbXBvbmVudC5iYXNlKSB7XG5cdFx0XHRyZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCAxLCBtb3VudEFsbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVucXVldWVSZW5kZXIoY29tcG9uZW50KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29tcG9uZW50Ll9fcmVmKSBjb21wb25lbnQuX19yZWYoY29tcG9uZW50KTtcbn1cblxuLyoqIFJlbmRlciBhIENvbXBvbmVudCwgdHJpZ2dlcmluZyBuZWNlc3NhcnkgbGlmZWN5Y2xlIGV2ZW50cyBhbmQgdGFraW5nIEhpZ2gtT3JkZXIgQ29tcG9uZW50cyBpbnRvIGFjY291bnQuXG4gKlx0QHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudFxuICpcdEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqXHRAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJ1aWxkPWZhbHNlXVx0XHRJZiBgdHJ1ZWAsIGNvbXBvbmVudCB3aWxsIGJ1aWxkIGFuZCBzdG9yZSBhIERPTSBub2RlIGlmIG5vdCBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBvbmUuXG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudCwgb3B0cywgbW91bnRBbGwsIGlzQ2hpbGQpIHtcblx0aWYgKGNvbXBvbmVudC5fZGlzYWJsZSkgcmV0dXJuO1xuXG5cdHZhciBwcm9wcyA9IGNvbXBvbmVudC5wcm9wcyxcblx0ICAgIHN0YXRlID0gY29tcG9uZW50LnN0YXRlLFxuXHQgICAgY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0LFxuXHQgICAgcHJldmlvdXNQcm9wcyA9IGNvbXBvbmVudC5wcmV2UHJvcHMgfHwgcHJvcHMsXG5cdCAgICBwcmV2aW91c1N0YXRlID0gY29tcG9uZW50LnByZXZTdGF0ZSB8fCBzdGF0ZSxcblx0ICAgIHByZXZpb3VzQ29udGV4dCA9IGNvbXBvbmVudC5wcmV2Q29udGV4dCB8fCBjb250ZXh0LFxuXHQgICAgaXNVcGRhdGUgPSBjb21wb25lbnQuYmFzZSxcblx0ICAgIG5leHRCYXNlID0gY29tcG9uZW50Lm5leHRCYXNlLFxuXHQgICAgaW5pdGlhbEJhc2UgPSBpc1VwZGF0ZSB8fCBuZXh0QmFzZSxcblx0ICAgIGluaXRpYWxDaGlsZENvbXBvbmVudCA9IGNvbXBvbmVudC5fY29tcG9uZW50LFxuXHQgICAgc2tpcCA9IGZhbHNlLFxuXHQgICAgcmVuZGVyZWQsXG5cdCAgICBpbnN0LFxuXHQgICAgY2Jhc2U7XG5cblx0Ly8gaWYgdXBkYXRpbmdcblx0aWYgKGlzVXBkYXRlKSB7XG5cdFx0Y29tcG9uZW50LnByb3BzID0gcHJldmlvdXNQcm9wcztcblx0XHRjb21wb25lbnQuc3RhdGUgPSBwcmV2aW91c1N0YXRlO1xuXHRcdGNvbXBvbmVudC5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuXHRcdGlmIChvcHRzICE9PSAyICYmIGNvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgJiYgY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpID09PSBmYWxzZSkge1xuXHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuXHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudFdpbGxVcGRhdGUocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcblx0XHR9XG5cdFx0Y29tcG9uZW50LnByb3BzID0gcHJvcHM7XG5cdFx0Y29tcG9uZW50LnN0YXRlID0gc3RhdGU7XG5cdFx0Y29tcG9uZW50LmNvbnRleHQgPSBjb250ZXh0O1xuXHR9XG5cblx0Y29tcG9uZW50LnByZXZQcm9wcyA9IGNvbXBvbmVudC5wcmV2U3RhdGUgPSBjb21wb25lbnQucHJldkNvbnRleHQgPSBjb21wb25lbnQubmV4dEJhc2UgPSBudWxsO1xuXHRjb21wb25lbnQuX2RpcnR5ID0gZmFsc2U7XG5cblx0aWYgKCFza2lwKSB7XG5cdFx0cmVuZGVyZWQgPSBjb21wb25lbnQucmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCk7XG5cblx0XHQvLyBjb250ZXh0IHRvIHBhc3MgdG8gdGhlIGNoaWxkLCBjYW4gYmUgdXBkYXRlZCB2aWEgKGdyYW5kLSlwYXJlbnQgY29tcG9uZW50XG5cdFx0aWYgKGNvbXBvbmVudC5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdGNvbnRleHQgPSBleHRlbmQoZXh0ZW5kKHt9LCBjb250ZXh0KSwgY29tcG9uZW50LmdldENoaWxkQ29udGV4dCgpKTtcblx0XHR9XG5cblx0XHR2YXIgY2hpbGRDb21wb25lbnQgPSByZW5kZXJlZCAmJiByZW5kZXJlZC5ub2RlTmFtZSxcblx0XHQgICAgdG9Vbm1vdW50LFxuXHRcdCAgICBiYXNlO1xuXG5cdFx0aWYgKHR5cGVvZiBjaGlsZENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gc2V0IHVwIGhpZ2ggb3JkZXIgY29tcG9uZW50IGxpbmtcblxuXHRcdFx0dmFyIGNoaWxkUHJvcHMgPSBnZXROb2RlUHJvcHMocmVuZGVyZWQpO1xuXHRcdFx0aW5zdCA9IGluaXRpYWxDaGlsZENvbXBvbmVudDtcblxuXHRcdFx0aWYgKGluc3QgJiYgaW5zdC5jb25zdHJ1Y3RvciA9PT0gY2hpbGRDb21wb25lbnQgJiYgY2hpbGRQcm9wcy5rZXkgPT0gaW5zdC5fX2tleSkge1xuXHRcdFx0XHRzZXRDb21wb25lbnRQcm9wcyhpbnN0LCBjaGlsZFByb3BzLCAxLCBjb250ZXh0LCBmYWxzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b1VubW91bnQgPSBpbnN0O1xuXG5cdFx0XHRcdGNvbXBvbmVudC5fY29tcG9uZW50ID0gaW5zdCA9IGNyZWF0ZUNvbXBvbmVudChjaGlsZENvbXBvbmVudCwgY2hpbGRQcm9wcywgY29udGV4dCk7XG5cdFx0XHRcdGluc3QubmV4dEJhc2UgPSBpbnN0Lm5leHRCYXNlIHx8IG5leHRCYXNlO1xuXHRcdFx0XHRpbnN0Ll9wYXJlbnRDb21wb25lbnQgPSBjb21wb25lbnQ7XG5cdFx0XHRcdHNldENvbXBvbmVudFByb3BzKGluc3QsIGNoaWxkUHJvcHMsIDAsIGNvbnRleHQsIGZhbHNlKTtcblx0XHRcdFx0cmVuZGVyQ29tcG9uZW50KGluc3QsIDEsIG1vdW50QWxsLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0YmFzZSA9IGluc3QuYmFzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2Jhc2UgPSBpbml0aWFsQmFzZTtcblxuXHRcdFx0Ly8gZGVzdHJveSBoaWdoIG9yZGVyIGNvbXBvbmVudCBsaW5rXG5cdFx0XHR0b1VubW91bnQgPSBpbml0aWFsQ2hpbGRDb21wb25lbnQ7XG5cdFx0XHRpZiAodG9Vbm1vdW50KSB7XG5cdFx0XHRcdGNiYXNlID0gY29tcG9uZW50Ll9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW5pdGlhbEJhc2UgfHwgb3B0cyA9PT0gMSkge1xuXHRcdFx0XHRpZiAoY2Jhc2UpIGNiYXNlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0XHRiYXNlID0gZGlmZihjYmFzZSwgcmVuZGVyZWQsIGNvbnRleHQsIG1vdW50QWxsIHx8ICFpc1VwZGF0ZSwgaW5pdGlhbEJhc2UgJiYgaW5pdGlhbEJhc2UucGFyZW50Tm9kZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGluaXRpYWxCYXNlICYmIGJhc2UgIT09IGluaXRpYWxCYXNlICYmIGluc3QgIT09IGluaXRpYWxDaGlsZENvbXBvbmVudCkge1xuXHRcdFx0dmFyIGJhc2VQYXJlbnQgPSBpbml0aWFsQmFzZS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKGJhc2VQYXJlbnQgJiYgYmFzZSAhPT0gYmFzZVBhcmVudCkge1xuXHRcdFx0XHRiYXNlUGFyZW50LnJlcGxhY2VDaGlsZChiYXNlLCBpbml0aWFsQmFzZSk7XG5cblx0XHRcdFx0aWYgKCF0b1VubW91bnQpIHtcblx0XHRcdFx0XHRpbml0aWFsQmFzZS5fY29tcG9uZW50ID0gbnVsbDtcblx0XHRcdFx0XHRyZWNvbGxlY3ROb2RlVHJlZShpbml0aWFsQmFzZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRvVW5tb3VudCkge1xuXHRcdFx0dW5tb3VudENvbXBvbmVudCh0b1VubW91bnQpO1xuXHRcdH1cblxuXHRcdGNvbXBvbmVudC5iYXNlID0gYmFzZTtcblx0XHRpZiAoYmFzZSAmJiAhaXNDaGlsZCkge1xuXHRcdFx0dmFyIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudCxcblx0XHRcdCAgICB0ID0gY29tcG9uZW50O1xuXHRcdFx0d2hpbGUgKHQgPSB0Ll9wYXJlbnRDb21wb25lbnQpIHtcblx0XHRcdFx0KGNvbXBvbmVudFJlZiA9IHQpLmJhc2UgPSBiYXNlO1xuXHRcdFx0fVxuXHRcdFx0YmFzZS5fY29tcG9uZW50ID0gY29tcG9uZW50UmVmO1xuXHRcdFx0YmFzZS5fY29tcG9uZW50Q29uc3RydWN0b3IgPSBjb21wb25lbnRSZWYuY29uc3RydWN0b3I7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFpc1VwZGF0ZSB8fCBtb3VudEFsbCkge1xuXHRcdG1vdW50cy51bnNoaWZ0KGNvbXBvbmVudCk7XG5cdH0gZWxzZSBpZiAoIXNraXApIHtcblx0XHQvLyBFbnN1cmUgdGhhdCBwZW5kaW5nIGNvbXBvbmVudERpZE1vdW50KCkgaG9va3Mgb2YgY2hpbGQgY29tcG9uZW50c1xuXHRcdC8vIGFyZSBjYWxsZWQgYmVmb3JlIHRoZSBjb21wb25lbnREaWRVcGRhdGUoKSBob29rIGluIHRoZSBwYXJlbnQuXG5cdFx0Ly8gTm90ZTogZGlzYWJsZWQgYXMgaXQgY2F1c2VzIGR1cGxpY2F0ZSBob29rcywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0L2lzc3Vlcy83NTBcblx0XHQvLyBmbHVzaE1vdW50cygpO1xuXG5cdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUpIHtcblx0XHRcdGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUocHJldmlvdXNQcm9wcywgcHJldmlvdXNTdGF0ZSwgcHJldmlvdXNDb250ZXh0KTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuYWZ0ZXJVcGRhdGUpIG9wdGlvbnMuYWZ0ZXJVcGRhdGUoY29tcG9uZW50KTtcblx0fVxuXG5cdGlmIChjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyAhPSBudWxsKSB7XG5cdFx0d2hpbGUgKGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucG9wKCkuY2FsbChjb21wb25lbnQpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghZGlmZkxldmVsICYmICFpc0NoaWxkKSBmbHVzaE1vdW50cygpO1xufVxuXG4vKiogQXBwbHkgdGhlIENvbXBvbmVudCByZWZlcmVuY2VkIGJ5IGEgVk5vZGUgdG8gdGhlIERPTS5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IGRvbVx0VGhlIERPTSBub2RlIHRvIG11dGF0ZVxuICpcdEBwYXJhbSB7Vk5vZGV9IHZub2RlXHRBIENvbXBvbmVudC1yZWZlcmVuY2luZyBWTm9kZVxuICpcdEByZXR1cm5zIHtFbGVtZW50fSBkb21cdFRoZSBjcmVhdGVkL211dGF0ZWQgZWxlbWVudFxuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RnJvbVZOb2RlKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsKSB7XG5cdHZhciBjID0gZG9tICYmIGRvbS5fY29tcG9uZW50LFxuXHQgICAgb3JpZ2luYWxDb21wb25lbnQgPSBjLFxuXHQgICAgb2xkRG9tID0gZG9tLFxuXHQgICAgaXNEaXJlY3RPd25lciA9IGMgJiYgZG9tLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWUsXG5cdCAgICBpc093bmVyID0gaXNEaXJlY3RPd25lcixcblx0ICAgIHByb3BzID0gZ2V0Tm9kZVByb3BzKHZub2RlKTtcblx0d2hpbGUgKGMgJiYgIWlzT3duZXIgJiYgKGMgPSBjLl9wYXJlbnRDb21wb25lbnQpKSB7XG5cdFx0aXNPd25lciA9IGMuY29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lO1xuXHR9XG5cblx0aWYgKGMgJiYgaXNPd25lciAmJiAoIW1vdW50QWxsIHx8IGMuX2NvbXBvbmVudCkpIHtcblx0XHRzZXRDb21wb25lbnRQcm9wcyhjLCBwcm9wcywgMywgY29udGV4dCwgbW91bnRBbGwpO1xuXHRcdGRvbSA9IGMuYmFzZTtcblx0fSBlbHNlIHtcblx0XHRpZiAob3JpZ2luYWxDb21wb25lbnQgJiYgIWlzRGlyZWN0T3duZXIpIHtcblx0XHRcdHVubW91bnRDb21wb25lbnQob3JpZ2luYWxDb21wb25lbnQpO1xuXHRcdFx0ZG9tID0gb2xkRG9tID0gbnVsbDtcblx0XHR9XG5cblx0XHRjID0gY3JlYXRlQ29tcG9uZW50KHZub2RlLm5vZGVOYW1lLCBwcm9wcywgY29udGV4dCk7XG5cdFx0aWYgKGRvbSAmJiAhYy5uZXh0QmFzZSkge1xuXHRcdFx0Yy5uZXh0QmFzZSA9IGRvbTtcblx0XHRcdC8vIHBhc3NpbmcgZG9tL29sZERvbSBhcyBuZXh0QmFzZSB3aWxsIHJlY3ljbGUgaXQgaWYgdW51c2VkLCBzbyBieXBhc3MgcmVjeWNsaW5nIG9uIEwyMjk6XG5cdFx0XHRvbGREb20gPSBudWxsO1xuXHRcdH1cblx0XHRzZXRDb21wb25lbnRQcm9wcyhjLCBwcm9wcywgMSwgY29udGV4dCwgbW91bnRBbGwpO1xuXHRcdGRvbSA9IGMuYmFzZTtcblxuXHRcdGlmIChvbGREb20gJiYgZG9tICE9PSBvbGREb20pIHtcblx0XHRcdG9sZERvbS5fY29tcG9uZW50ID0gbnVsbDtcblx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKG9sZERvbSwgZmFsc2UpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKiBSZW1vdmUgYSBjb21wb25lbnQgZnJvbSB0aGUgRE9NIGFuZCByZWN5Y2xlIGl0LlxuICpcdEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnRcdFRoZSBDb21wb25lbnQgaW5zdGFuY2UgdG8gdW5tb3VudFxuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGlmIChvcHRpb25zLmJlZm9yZVVubW91bnQpIG9wdGlvbnMuYmVmb3JlVW5tb3VudChjb21wb25lbnQpO1xuXG5cdHZhciBiYXNlID0gY29tcG9uZW50LmJhc2U7XG5cblx0Y29tcG9uZW50Ll9kaXNhYmxlID0gdHJ1ZTtcblxuXHRpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxVbm1vdW50KSBjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblxuXHRjb21wb25lbnQuYmFzZSA9IG51bGw7XG5cblx0Ly8gcmVjdXJzaXZlbHkgdGVhciBkb3duICYgcmVjb2xsZWN0IGhpZ2gtb3JkZXIgY29tcG9uZW50IGNoaWxkcmVuOlxuXHR2YXIgaW5uZXIgPSBjb21wb25lbnQuX2NvbXBvbmVudDtcblx0aWYgKGlubmVyKSB7XG5cdFx0dW5tb3VudENvbXBvbmVudChpbm5lcik7XG5cdH0gZWxzZSBpZiAoYmFzZSkge1xuXHRcdGlmIChiYXNlWydfX3ByZWFjdGF0dHJfJ10gJiYgYmFzZVsnX19wcmVhY3RhdHRyXyddLnJlZikgYmFzZVsnX19wcmVhY3RhdHRyXyddLnJlZihudWxsKTtcblxuXHRcdGNvbXBvbmVudC5uZXh0QmFzZSA9IGJhc2U7XG5cblx0XHRyZW1vdmVOb2RlKGJhc2UpO1xuXHRcdGNvbGxlY3RDb21wb25lbnQoY29tcG9uZW50KTtcblxuXHRcdHJlbW92ZUNoaWxkcmVuKGJhc2UpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudC5fX3JlZikgY29tcG9uZW50Ll9fcmVmKG51bGwpO1xufVxuXG4vKiogQmFzZSBDb21wb25lbnQgY2xhc3MuXG4gKlx0UHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoIHRyaWdnZXIgcmVuZGVyaW5nLlxuICpcdEBwdWJsaWNcbiAqXG4gKlx0QGV4YW1wbGVcbiAqXHRjbGFzcyBNeUZvbyBleHRlbmRzIENvbXBvbmVudCB7XG4gKlx0XHRyZW5kZXIocHJvcHMsIHN0YXRlKSB7XG4gKlx0XHRcdHJldHVybiA8ZGl2IC8+O1xuICpcdFx0fVxuICpcdH1cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG5cdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblxuXHQvKiogQHB1YmxpY1xuICAqXHRAdHlwZSB7b2JqZWN0fVxuICAqL1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG5cdC8qKiBAcHVibGljXG4gICpcdEB0eXBlIHtvYmplY3R9XG4gICovXG5cdHRoaXMucHJvcHMgPSBwcm9wcztcblxuXHQvKiogQHB1YmxpY1xuICAqXHRAdHlwZSB7b2JqZWN0fVxuICAqL1xuXHR0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZSB8fCB7fTtcbn1cblxuZXh0ZW5kKENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuXHQvKiogUmV0dXJucyBhIGBib29sZWFuYCBpbmRpY2F0aW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHJlLXJlbmRlciB3aGVuIHJlY2VpdmluZyB0aGUgZ2l2ZW4gYHByb3BzYCBhbmQgYHN0YXRlYC5cbiAgKlx0QHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAqXHRAcGFyYW0ge29iamVjdH0gbmV4dFN0YXRlXG4gICpcdEBwYXJhbSB7b2JqZWN0fSBuZXh0Q29udGV4dFxuICAqXHRAcmV0dXJucyB7Qm9vbGVhbn0gc2hvdWxkIHRoZSBjb21wb25lbnQgcmUtcmVuZGVyXG4gICpcdEBuYW1lIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAqXHRAZnVuY3Rpb25cbiAgKi9cblxuXHQvKiogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBieSBjb3B5aW5nIHByb3BlcnRpZXMgZnJvbSBgc3RhdGVgIHRvIGB0aGlzLnN0YXRlYC5cbiAgKlx0QHBhcmFtIHtvYmplY3R9IHN0YXRlXHRcdEEgaGFzaCBvZiBzdGF0ZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXNcbiAgKlx0QHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcdEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgY29tcG9uZW50IHN0YXRlIGlzIHVwZGF0ZWRcbiAgKi9cblx0c2V0U3RhdGU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlLCBjYWxsYmFjaykge1xuXHRcdHZhciBzID0gdGhpcy5zdGF0ZTtcblx0XHRpZiAoIXRoaXMucHJldlN0YXRlKSB0aGlzLnByZXZTdGF0ZSA9IGV4dGVuZCh7fSwgcyk7XG5cdFx0ZXh0ZW5kKHMsIHR5cGVvZiBzdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXRlKHMsIHRoaXMucHJvcHMpIDogc3RhdGUpO1xuXHRcdGlmIChjYWxsYmFjaykgKHRoaXMuX3JlbmRlckNhbGxiYWNrcyA9IHRoaXMuX3JlbmRlckNhbGxiYWNrcyB8fCBbXSkucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fSxcblxuXG5cdC8qKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnQuXG4gICpcdEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHRcdEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyByZS1yZW5kZXJlZC5cbiAgKlx0QHByaXZhdGVcbiAgKi9cblx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKGNhbGxiYWNrKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSAodGhpcy5fcmVuZGVyQ2FsbGJhY2tzID0gdGhpcy5fcmVuZGVyQ2FsbGJhY2tzIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcblx0XHRyZW5kZXJDb21wb25lbnQodGhpcywgMik7XG5cdH0sXG5cblxuXHQvKiogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICAqXHRWaXJ0dWFsIERPTSBpcyBnZW5lcmFsbHkgY29uc3RydWN0ZWQgdmlhIFtKU1hdKGh0dHA6Ly9qYXNvbmZvcm1hdC5jb20vd3RmLWlzLWpzeCkuXG4gICpcdEBwYXJhbSB7b2JqZWN0fSBwcm9wc1x0XHRQcm9wcyAoZWc6IEpTWCBhdHRyaWJ1dGVzKSByZWNlaXZlZCBmcm9tIHBhcmVudCBlbGVtZW50L2NvbXBvbmVudFxuICAqXHRAcGFyYW0ge29iamVjdH0gc3RhdGVcdFx0VGhlIGNvbXBvbmVudCdzIGN1cnJlbnQgc3RhdGVcbiAgKlx0QHBhcmFtIHtvYmplY3R9IGNvbnRleHRcdFx0Q29udGV4dCBvYmplY3QgKGlmIGEgcGFyZW50IGNvbXBvbmVudCBoYXMgcHJvdmlkZWQgY29udGV4dClcbiAgKlx0QHJldHVybnMgVk5vZGVcbiAgKi9cblx0cmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7fVxufSk7XG5cbi8qKiBSZW5kZXIgSlNYIGludG8gYSBgcGFyZW50YCBFbGVtZW50LlxuICpcdEBwYXJhbSB7Vk5vZGV9IHZub2RlXHRcdEEgKEpTWCkgVk5vZGUgdG8gcmVuZGVyXG4gKlx0QHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcdFx0RE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG9cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IFttZXJnZV1cdEF0dGVtcHQgdG8gcmUtdXNlIGFuIGV4aXN0aW5nIERPTSB0cmVlIHJvb3RlZCBhdCBgbWVyZ2VgXG4gKlx0QHB1YmxpY1xuICpcbiAqXHRAZXhhbXBsZVxuICpcdC8vIHJlbmRlciBhIGRpdiBpbnRvIDxib2R5PjpcbiAqXHRyZW5kZXIoPGRpdiBpZD1cImhlbGxvXCI+aGVsbG8hPC9kaXY+LCBkb2N1bWVudC5ib2R5KTtcbiAqXG4gKlx0QGV4YW1wbGVcbiAqXHQvLyByZW5kZXIgYSBcIlRoaW5nXCIgY29tcG9uZW50IGludG8gI2ZvbzpcbiAqXHRjb25zdCBUaGluZyA9ICh7IG5hbWUgfSkgPT4gPHNwYW4+eyBuYW1lIH08L3NwYW4+O1xuICpcdHJlbmRlcig8VGhpbmcgbmFtZT1cIm9uZVwiIC8+LCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZm9vJykpO1xuICovXG5mdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgbWVyZ2UpIHtcbiAgcmV0dXJuIGRpZmYobWVyZ2UsIHZub2RlLCB7fSwgZmFsc2UsIHBhcmVudCwgZmFsc2UpO1xufVxuXG52YXIgcHJlYWN0ID0ge1xuXHRoOiBoLFxuXHRjcmVhdGVFbGVtZW50OiBoLFxuXHRjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcblx0Q29tcG9uZW50OiBDb21wb25lbnQsXG5cdHJlbmRlcjogcmVuZGVyLFxuXHRyZXJlbmRlcjogcmVyZW5kZXIsXG5cdG9wdGlvbnM6IG9wdGlvbnNcbn07XG5cbmV4cG9ydCB7IGgsIGggYXMgY3JlYXRlRWxlbWVudCwgY2xvbmVFbGVtZW50LCBDb21wb25lbnQsIHJlbmRlciwgcmVyZW5kZXIsIG9wdGlvbnMgfTtleHBvcnQgZGVmYXVsdCBwcmVhY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QuZXNtLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5lc20uanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QuZXNtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8pIHtcbiAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gdG8gJiYgdG8uc3BsaXQoJy8nKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLycpIHx8IFtdO1xuXG4gIHZhciBpc1RvQWJzID0gdG8gJiYgaXNBYnNvbHV0ZSh0byk7XG4gIHZhciBpc0Zyb21BYnMgPSBmcm9tICYmIGlzQWJzb2x1dGUoZnJvbSk7XG4gIHZhciBtdXN0RW5kQWJzID0gaXNUb0FicyB8fCBpc0Zyb21BYnM7XG5cbiAgaWYgKHRvICYmIGlzQWJzb2x1dGUodG8pKSB7XG4gICAgLy8gdG8gaXMgYWJzb2x1dGVcbiAgICBmcm9tUGFydHMgPSB0b1BhcnRzO1xuICB9IGVsc2UgaWYgKHRvUGFydHMubGVuZ3RoKSB7XG4gICAgLy8gdG8gaXMgcmVsYXRpdmUsIGRyb3AgdGhlIGZpbGVuYW1lXG4gICAgZnJvbVBhcnRzLnBvcCgpO1xuICAgIGZyb21QYXJ0cyA9IGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cyk7XG4gIH1cblxuICBpZiAoIWZyb21QYXJ0cy5sZW5ndGgpIHJldHVybiAnLyc7XG5cbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSB2b2lkIDA7XG4gIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3QgPSBmcm9tUGFydHNbZnJvbVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJyB8fCBsYXN0ID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IGZyb21QYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11c3RFbmRBYnMpIGZvciAoOyB1cC0tOyB1cCkge1xuICAgIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuICB9aWYgKG11c3RFbmRBYnMgJiYgZnJvbVBhcnRzWzBdICE9PSAnJyAmJiAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKSkgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMjMgMjdcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCI+PGcgaWQ9XFxcIk1WUFxcXCIgc3Ryb2tlPVxcXCJub25lXFxcIiBzdHJva2Utd2lkdGg9XFxcIjFcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIGZpbGwtcnVsZT1cXFwiZXZlbm9kZFxcXCI+PGcgaWQ9XFxcImxpbmtTdGF0dXMyXFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtODk5LjAwMDAwMCwgLTYzOC4wMDAwMDApXFxcIiBmaWxsPVxcXCIjMUIyNDM3XFxcIj48ZyBpZD1cXFwiR3JvdXAtNlxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoNjU1LjAwMDAwMCwgNjMxLjAwMDAwMClcXFwiPjxwYXRoIGQ9XFxcIk0yNTUuNDUyLDYuOTk5MiBMMjQ0LDE1LjgxNTIgTDI0NCwyNC40NjgyIEwyNTUuNDUyLDMzLjI4NDIgTDI2Ni45MDQsMjQuNDY4MiBMMjY2LjkwNCwxNS44MTUyIEwyNTUuNDUyLDYuOTk5MiBaIE0yNTkuODc0LDE4LjEzNzIgTDI1Ni4yMjQsMTUuMzI4MiBMMjU2LjIyNCw5LjcwMzIgTDI2NC43NjEsMTYuMjc0MiBMMjYxLjI2MSwxOC45NzAyIEwyNTguOTY1LDIwLjczOTIgTDI1OC45NjMsMjAuNzM3MiBMMjU1LjQ1MiwyMy40NDEyIEwyNTIuNCwyMS4wOTIyIEwyNTEuMDMxLDIyLjE0NjIgTDI1NC42NzksMjQuOTU2MiBMMjU0LjY3OSwzMC41ODEyIEwyNDYuMTQyLDI0LjAwOTIgTDI0OS43OTYsMjEuMTk2MiBMMjUxLjk0MSwxOS41NDQyIEwyNTEuOTQxLDE5LjU0NTIgTDI1NS40NTIsMTYuODQyMiBMMjU4LjUwNCwxOS4xOTEyIEwyNTkuODc0LDE4LjEzNzIgWiBNMjQ4LjU2MiwxOC4xMzcyIEwyNDYuMTQyLDE2LjI3NDIgTDI1NC42NzksOS43MDMyIEwyNTQuNjc5LDE1LjMyODIgTDI0OS43OTYsMTkuMDg3MiBMMjQ4LjQyNywyMC4xNDEyIEwyNDguMzgxLDIwLjE3NzIgTDI0Ny42NTIsMjAuNzM4MiBMMjQ1LjU0NiwyMi4zNTkyIEwyNDUuNTQ2LDE3LjkyMzIgTDI0Ny4xOTMsMTkuMTkwMiBMMjQ4LjU2MiwxOC4xMzcyIFogTTI1Ni4yMjQsMjQuOTU2MiBMMjYxLjEwOCwyMS4xOTYyIEwyNjMuMDgxLDE5LjY3NjIgTDI2NS4zNTgsMTcuOTIzMiBMMjY1LjM1OCwyMi4zNTkyIEwyNjMuNzExLDIxLjA5MjIgTDI2Mi4zNDIsMjIuMTQ2MiBMMjY0Ljc2MSwyNC4wMDkyIEwyNTYuMjI0LDMwLjU4MTIgTDI1Ni4yMjQsMjQuOTU2MiBaXFxcIiBpZD1cXFwiUGFnZS0xXFxcIj48L3BhdGg+PC9nPjwvZz48L2c+PC9zdmc+XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvc3ZnLWlubGluZS1sb2FkZXI/cmVtb3ZlVGFncz10cnVlJnJlbW92ZVNWR1RhZ0F0dHJzPXRydWUhLi9pbWFnZXMvY3ViZS5zdmdcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9zdmctaW5saW5lLWxvYWRlci9pbmRleC5qcz9yZW1vdmVUYWdzPXRydWUmcmVtb3ZlU1ZHVGFnQXR0cnM9dHJ1ZSEuL2ltYWdlcy9jdWJlLnN2Z1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmFkc0xpc3RfX3NlbGYtLTFDT2o5IC5hZHNMaXN0X19yb3ctLTJlTTVme2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdztwYWRkaW5nOjEwcHh9LmFkc0xpc3RfX3NlbGYtLTFDT2o5IC5hZHNMaXN0X19idXR0b24tLW8tQ244e21hcmdpbi1sZWZ0OmF1dG99XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2Fkc0xpc3Quc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSwyQ0FBVyxvQkFBb0Isb0JBQW9CLGFBQWEsOEJBQThCLDZCQUE2Qix1QkFBdUIsbUJBQW1CLFlBQVksQ0FBQyw4Q0FBYyxnQkFBZ0IsQ0FBQ1wiLFwiZmlsZVwiOlwiYWRzTGlzdC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxmIC5yb3d7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93O3BhZGRpbmc6MTBweH0uc2VsZiAuYnV0dG9ue21hcmdpbi1sZWZ0OmF1dG99XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJhZHNMaXN0X19zZWxmLS0xQ09qOVwiLFxuXHRcInJvd1wiOiBcImFkc0xpc3RfX3Jvdy0tMmVNNWZcIixcblx0XCJidXR0b25cIjogXCJhZHNMaXN0X19idXR0b24tLW8tQ244XCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2Fkc0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2Fkc0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmJ1dHRvbl9fc2VsZi0tMUhCVnN7Ym9yZGVyOm5vbmU7b3V0bGluZTpub25lO2ZvbnQtZmFtaWx5OlBUIFNhbnM7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7YmFja2dyb3VuZC1jb2xvcjojMjYzZmZmO2xldHRlci1zcGFjaW5nOi4wMWVtfS5idXR0b25fX3NlbGYtLTFIQlZzLmJ1dHRvbl9fcHJpbWFyeS0tMm1yS3Z7Zm9udC13ZWlnaHQ6MzAwO2NvbG9yOiNmZmY7Zm9udC1zaXplOjE1cHg7Ym9yZGVyLXJhZGl1czozcHg7cGFkZGluZzoxM3B4IDI1cHghaW1wb3J0YW50fS5idXR0b25fX3NlbGYtLTFIQlZzLmJ1dHRvbl9fc2Vjb25kYXJ5LS0ySW1veHtmbG9hdDpyaWdodDtiYWNrZ3JvdW5kLWNvbG9yOiNjZmQ5ZmE7Ym9yZGVyLXJhZGl1czo1MHB4O2NvbG9yOiMyNjNmZmY7aGVpZ2h0OjIwcHg7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NzAwOy13ZWJraXQtYm94LXNoYWRvdzowIDVweCAxMnB4IHJnYmEoMTg0LDE4OCwyMDYsLjUpO2JveC1zaGFkb3c6MCA1cHggMTJweCByZ2JhKDE4NCwxODgsMjA2LC41KX0uYnV0dG9uX19zZWxmLS0xSEJWcy5idXR0b25fX3NlY29uZGFyeS0tMkltb3g6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojODk5MzlmO29wYWNpdHk6LjQ7Y3Vyc29yOm5vdC1hbGxvd2VkO2NvbG9yOiNmZmZ9LmJ1dHRvbl9fc2VsZi0tMUhCVnMuYnV0dG9uX19zZWNvbmRhcnktLTJJbW94Om5vdChbZGlzYWJsZWRdKTpob3Zlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0ycHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0ycHgpfS5idXR0b25fX3NlbGYtLTFIQlZzOmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6Izg5OTM5ZjtvcGFjaXR5Oi40O2N1cnNvcjpub3QtYWxsb3dlZDtjb2xvcjojZmZmfS5idXR0b25fX3NlbGYtLTFIQlZzOm5vdChbZGlzYWJsZWRdKTpob3ZlcntjdXJzb3I6cG9pbnRlcjtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZjstd2Via2l0LWJveC1zaGFkb3c6MCA1cHggMTVweCByZ2JhKDUwLDkzLDI1NSwuNDUpO2JveC1zaGFkb3c6MCA1cHggMTVweCByZ2JhKDUwLDkzLDI1NSwuNDUpOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTFweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTFweCl9LmJ1dHRvbl9fc2VsZi0tMUhCVnM6YWN0aXZle2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZn1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYnV0dG9uLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEscUJBQU0sWUFBWSxhQUFhLG9CQUFzQixtQ0FBbUMsa0NBQWtDLHlCQUF5QixvQkFBcUIsQ0FBQyw0Q0FBYyxnQkFBZ0IsV0FBVyxlQUFlLGtCQUFrQiwyQkFBNEIsQ0FBQyw4Q0FBZ0IsWUFBWSx5QkFBeUIsbUJBQW1CLGNBQWMsWUFBWSxrQkFBa0IsZUFBZSxnQkFBZ0IsbURBQXNELDBDQUE2QyxDQUFDLHVEQUF5Qix5QkFBeUIsV0FBWSxtQkFBbUIsVUFBVSxDQUFDLG9FQUFzQyxtQ0FBbUMsMEJBQTBCLENBQUMsOEJBQWUseUJBQXlCLFdBQVksbUJBQW1CLFVBQVUsQ0FBQywyQ0FBNEIsZUFBZSxXQUFXLHlCQUF5QixrREFBcUQsMENBQTZDLG1DQUFtQywwQkFBMEIsQ0FBQyw0QkFBYSx3QkFBd0IsQ0FBQ1wiLFwiZmlsZVwiOlwiYnV0dG9uLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7Ym9yZGVyOm5vbmU7b3V0bGluZTpub25lO2ZvbnQtZmFtaWx5OidQVCBTYW5zJzstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtiYWNrZ3JvdW5kLWNvbG9yOiMyNjNmZmY7bGV0dGVyLXNwYWNpbmc6MC4wMWVtfS5zZWxmLnByaW1hcnl7Zm9udC13ZWlnaHQ6MzAwO2NvbG9yOiNmZmY7Zm9udC1zaXplOjE1cHg7Ym9yZGVyLXJhZGl1czozcHg7cGFkZGluZzoxM3B4IDI1cHggIWltcG9ydGFudH0uc2VsZi5zZWNvbmRhcnl7ZmxvYXQ6cmlnaHQ7YmFja2dyb3VuZC1jb2xvcjojY2ZkOWZhO2JvcmRlci1yYWRpdXM6NTBweDtjb2xvcjojMjYzZmZmO2hlaWdodDoyMHB4O3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjcwMDstd2Via2l0LWJveC1zaGFkb3c6MHB4IDVweCAxMnB4IHJnYmEoMTg0LDE4OCwyMDYsMC41KTtib3gtc2hhZG93OjBweCA1cHggMTJweCByZ2JhKDE4NCwxODgsMjA2LDAuNSl9LnNlbGYuc2Vjb25kYXJ5OmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6Izg5OTM5ZjtvcGFjaXR5OjAuNDtjdXJzb3I6bm90LWFsbG93ZWQ7Y29sb3I6I2ZmZn0uc2VsZi5zZWNvbmRhcnk6bm90KFtkaXNhYmxlZF0pOmhvdmVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTJweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTJweCl9LnNlbGY6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojODk5MzlmO29wYWNpdHk6MC40O2N1cnNvcjpub3QtYWxsb3dlZDtjb2xvcjojZmZmfS5zZWxmOm5vdChbZGlzYWJsZWRdKTpob3ZlcntjdXJzb3I6cG9pbnRlcjtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZjstd2Via2l0LWJveC1zaGFkb3c6MHB4IDVweCAxNXB4IHJnYmEoNTAsOTMsMjU1LDAuNDUpO2JveC1zaGFkb3c6MHB4IDVweCAxNXB4IHJnYmEoNTAsOTMsMjU1LDAuNDUpOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTFweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTFweCl9LnNlbGY6YWN0aXZle2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImJ1dHRvbl9fc2VsZi0tMUhCVnNcIixcblx0XCJwcmltYXJ5XCI6IFwiYnV0dG9uX19wcmltYXJ5LS0ybXJLdlwiLFxuXHRcInNlY29uZGFyeVwiOiBcImJ1dHRvbl9fc2Vjb25kYXJ5LS0ySW1veFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2J1dHRvbi5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaWNvbl9fc2VsZi0tMWh0Tkh7Zm9udC1zaXplOi44ZW19XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2ljb24uc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxtQkFBTSxjQUFlLENBQUNcIixcImZpbGVcIjpcImljb24uc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntmb250LXNpemU6MC44ZW19XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJpY29uX19zZWxmLS0xaHROSFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pY29uLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pY29uLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5pbnB1dF9fc2VsZi0tU3RhNlV7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbToyMHB4O21hcmdpbi10b3A6MjBweDt3aWR0aDoxMDAlO2ZvbnQtZmFtaWx5OlBUIFNhbnM7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50O3RyYW5zaXRpb246bm9uZSFpbXBvcnRhbnR9LmlucHV0X19zZWxmLS1TdGE2VSAuaW5wdXRfX2lucHV0LS0xaDZLTXtmb250LXNpemU6MTRweDtwYWRkaW5nOjE1cHg7d2lkdGg6Y2FsYygxMDAlIC0gMzBweCk7YmFja2dyb3VuZC1jb2xvcjojZjVmN2ZhO2JvcmRlcjoxcHggc29saWQgI2VlZjFmMjtib3JkZXItcmFkaXVzOjNweDstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmlucHV0X19zZWxmLS1TdGE2VSAuaW5wdXRfX2lucHV0LS0xaDZLTTpmb2N1c3tvdXRsaW5lOm5vbmU7Ym9yZGVyOjFweCBzb2xpZCAjMjYzZmZmO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9faW5wdXQtLTFoNktNOi1tb3otcGxhY2Vob2xkZXJ7Ym94LXNoYWRvdzpub25lIWltcG9ydGFudH0uaW5wdXRfX3NlbGYtLVN0YTZVLmlucHV0X19pbnZhbGlkLS0zVm1ob3ttYXJnaW4tYm90dG9tOmNhbGMoMzBweCAtIDFlbSl9LmlucHV0X19zZWxmLS1TdGE2VS5pbnB1dF9faW52YWxpZC0tM1ZtaG8+LmlucHV0X19pbnB1dC0tMWg2S017LXdlYmtpdC1ib3gtc2hhZG93OjAgMCA1cHggMXB4IHJlZDtib3gtc2hhZG93OjAgMCA1cHggMXB4IHJlZH0uaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9fcGxhY2Vob2xkZXItLTI2Szh5e3Bvc2l0aW9uOmFic29sdXRlO3RvcDoyMHB4O2xlZnQ6MTRweDtjb2xvcjojODk5MzlmO2ZvbnQtc2l6ZToxNHB4Oy13ZWJraXQtdHJhbnNpdGlvbjouMnM7dHJhbnNpdGlvbjouMnN9LmlucHV0X19zZWxmLS1TdGE2VSAuaW5wdXRfX2lucHV0LS0xaDZLTTpkaXNhYmxlZH4uaW5wdXRfX3BsYWNlaG9sZGVyLS0yNks4eSwuaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9faW5wdXQtLTFoNktNOmZvY3Vzfi5pbnB1dF9fcGxhY2Vob2xkZXItLTI2Szh5LC5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19pbnB1dC0tMWg2S006dmFsaWR+LmlucHV0X19wbGFjZWhvbGRlci0tMjZLOHl7Y29sb3I6IzFiMjQzNztmb250LXNpemU6MTFweDt0b3A6LTE2cHg7bGVmdDowfS5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19lcnJvci0tM21Vbzh7ZGlzcGxheTpibG9jaztjb2xvcjpyZWQ7aGVpZ2h0OjFlbTtmb250LXNpemU6LjhlbTtmb250LXdlaWdodDo2MDB9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsb0JBQU0sa0JBQWtCLG1CQUFtQixnQkFBZ0IsV0FBVyxvQkFBc0IsbUNBQW1DLGtDQUFrQyxrQ0FBbUMseUJBQTBCLENBQUMseUNBQWEsZUFBZSxhQUFhLHdCQUF3Qix5QkFBeUIseUJBQXlCLGtCQUFrQix3QkFBd0IsZUFBZSxDQUFDLCtDQUFtQixhQUFhLHlCQUF5QixxQkFBcUIsQ0FBQywwREFBOEIseUJBQTBCLENBQUMsMENBQWMsOEJBQThCLENBQUMsK0RBQXFCLG1DQUFtQywwQkFBMEIsQ0FBQywrQ0FBbUIsa0JBQWtCLFNBQVMsVUFBVSxjQUFjLGVBQWUsdUJBQXdCLGNBQWUsQ0FBQyxpT0FBeUcsY0FBYyxlQUFlLFVBQVUsTUFBUSxDQUFDLHlDQUFhLGNBQWMsVUFBVSxXQUFXLGVBQWdCLGVBQWUsQ0FBQ1wiLFwiZmlsZVwiOlwiaW5wdXQuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tYm90dG9tOjIwcHg7bWFyZ2luLXRvcDoyMHB4O3dpZHRoOjEwMCU7Zm9udC1mYW1pbHk6J1BUIFNhbnMnOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtdHJhbnNpdGlvbjpub25lICFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lICFpbXBvcnRhbnR9LnNlbGYgLmlucHV0e2ZvbnQtc2l6ZToxNHB4O3BhZGRpbmc6MTVweDt3aWR0aDpjYWxjKDEwMCUgLSAzMHB4KTtiYWNrZ3JvdW5kLWNvbG9yOiNmNWY3ZmE7Ym9yZGVyOjFweCBzb2xpZCAjZWVmMWYyO2JvcmRlci1yYWRpdXM6M3B4Oy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uc2VsZiAuaW5wdXQ6Zm9jdXN7b3V0bGluZTpub25lO2JvcmRlcjoxcHggc29saWQgIzI2M2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnNlbGYgLmlucHV0Oi1tb3otcGxhY2Vob2xkZXJ7Ym94LXNoYWRvdzpub25lICFpbXBvcnRhbnR9LnNlbGYuaW52YWxpZHttYXJnaW4tYm90dG9tOmNhbGMoMzBweCAtIDFlbSl9LnNlbGYuaW52YWxpZD4uaW5wdXR7LXdlYmtpdC1ib3gtc2hhZG93OjAgMCA1cHggMXB4IHJlZDtib3gtc2hhZG93OjAgMCA1cHggMXB4IHJlZH0uc2VsZiAucGxhY2Vob2xkZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjIwcHg7bGVmdDoxNHB4O2NvbG9yOiM4OTkzOWY7Zm9udC1zaXplOjE0cHg7LXdlYmtpdC10cmFuc2l0aW9uOjAuMnM7dHJhbnNpdGlvbjowLjJzfS5zZWxmIC5pbnB1dDpmb2N1cyB+IC5wbGFjZWhvbGRlciwuc2VsZiAuaW5wdXQ6dmFsaWQgfiAucGxhY2Vob2xkZXIsLnNlbGYgLmlucHV0OmRpc2FibGVkIH4gLnBsYWNlaG9sZGVye2NvbG9yOiMxYjI0Mzc7Zm9udC1zaXplOjExcHg7dG9wOi0xNnB4O2xlZnQ6MHB4fS5zZWxmIC5lcnJvcntkaXNwbGF5OmJsb2NrO2NvbG9yOnJlZDtoZWlnaHQ6MWVtO2ZvbnQtc2l6ZTowLjhlbTtmb250LXdlaWdodDo2MDB9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJpbnB1dF9fc2VsZi0tU3RhNlVcIixcblx0XCJpbnB1dFwiOiBcImlucHV0X19pbnB1dC0tMWg2S01cIixcblx0XCJpbnZhbGlkXCI6IFwiaW5wdXRfX2ludmFsaWQtLTNWbWhvXCIsXG5cdFwicGxhY2Vob2xkZXJcIjogXCJpbnB1dF9fcGxhY2Vob2xkZXItLTI2Szh5XCIsXG5cdFwiZXJyb3JcIjogXCJpbnB1dF9fZXJyb3ItLTNtVW84XCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubGFiZWxfX3NlbGYtLTMzcEJ1e2ZvbnQtc2l6ZToxNXB4O3RleHQtYWxpZ246bGVmdDtmb250LWZhbWlseTpQVCBTYW5zOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2NvbG9yOiM4OTkzOWZ9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsb0JBQU0sZUFBZSxnQkFBZ0Isb0JBQXNCLG1DQUFtQyxrQ0FBa0MsYUFBYSxDQUFDXCIsXCJmaWxlXCI6XCJsYWJlbC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme2ZvbnQtc2l6ZToxNXB4O3RleHQtYWxpZ246bGVmdDtmb250LWZhbWlseTonUFQgU2Fucyc7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7Y29sb3I6Izg5OTM5Zn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImxhYmVsX19zZWxmLS0zM3BCdVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGFiZWwuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmxpbmtfX3NlbGYtLTJsTGFMe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47bWluLXdpZHRoOjc1JTtmb250LXdlaWdodDozMDB9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX190aXRsZS0tM1docXV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMyNjNmZmY7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc2l6ZToxLjJlbTstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19oZWFkZXItLURiVVFQey13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19zdW1tYXJ5LS0zLVYyQ3tjb2xvcjojNTQ1NDU0fS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXMyLS1JWDJTSntvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7bGluZS1oZWlnaHQ6MS4yZW07bWF4LWhlaWdodDoyLjRlbTt0ZXh0LWFsaWduOmp1c3RpZnl9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19zdW1tYXJ5LS0zLVYyQy5saW5rX19saW5lczItLUlYMlNKOmJlZm9yZXtjb250ZW50OlxcXCIuLi5cXFwiO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7Ym90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXMyLS1JWDJTSjphZnRlcntjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7d2lkdGg6MWVtO2hlaWdodDoxZW07bWFyZ2luLXRvcDouMmVtO2JhY2tncm91bmQtY29sb3I6I2ZmZn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX3N1bW1hcnktLTMtVjJDLmxpbmtfX2xpbmVzOC0tM0JYajh7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2xpbmUtaGVpZ2h0OjEuMmVtO21heC1oZWlnaHQ6OS42ZW07dGV4dC1hbGlnbjpqdXN0aWZ5fS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXM4LS0zQlhqODpiZWZvcmV7Y29udGVudDpcXFwiLi4uXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2JhY2tncm91bmQtY29sb3I6I2ZmZn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX3N1bW1hcnktLTMtVjJDLmxpbmtfX2xpbmVzOC0tM0JYajg6YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3dpZHRoOjFlbTtoZWlnaHQ6MWVtO21hcmdpbi10b3A6LjJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19mb290ZXItLTNsSTkwey13ZWJraXQtYm94LWFsaWduOmVuZDstbXMtZmxleC1hbGlnbjplbmQ7YWxpZ24taXRlbXM6ZmxleC1lbmQ7LXdlYmtpdC1ib3gtcGFjazpqdXN0aWZ5Oy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX2xpbmstLTItQVoxe2Rpc3BsYXk6YmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMwMDY2MjE7Zm9udC1zaXplOi44ZW07LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowO291dGxpbmU6bm9uZX0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX2xpbmstLTItQVoxOmxpbmssLmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19saW5rLS0yLUFaMTp2aXNpdGVke3RleHQtZGVjb3JhdGlvbjpub25lfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsbUJBQU0sb0JBQW9CLG9CQUFvQixhQUFhLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLHNCQUFzQixjQUFjLGVBQWUsQ0FBQyx1Q0FBYSxtQkFBbUIsZ0JBQWdCLHVCQUF1QixjQUFjLGdCQUFnQixnQkFBZ0Isb0JBQW9CLGFBQWEsQ0FBQyx3Q0FBYyx5QkFBeUIsc0JBQXNCLDZCQUE2QixDQUFDLHlDQUFlLGFBQWEsQ0FBQyw2REFBc0IsZ0JBQWdCLGtCQUFrQixrQkFBa0IsaUJBQWlCLGtCQUFrQixDQUFDLG9FQUE2QixjQUFjLGtCQUFrQixRQUFRLFNBQVMscUJBQXFCLENBQUMsbUVBQTRCLFdBQVcsa0JBQWtCLFFBQVEsVUFBVSxXQUFXLGdCQUFpQixxQkFBcUIsQ0FBQyw2REFBc0IsZ0JBQWdCLGtCQUFrQixrQkFBa0IsaUJBQWlCLGtCQUFrQixDQUFDLG9FQUE2QixjQUFjLGtCQUFrQixRQUFRLFNBQVMscUJBQXFCLENBQUMsbUVBQTRCLFdBQVcsa0JBQWtCLFFBQVEsVUFBVSxXQUFXLGdCQUFpQixxQkFBcUIsQ0FBQyx3Q0FBYyxzQkFBc0IsbUJBQW1CLHFCQUFxQix5QkFBeUIsc0JBQXNCLDZCQUE2QixDQUFDLHNDQUFZLGNBQWMsbUJBQW1CLGdCQUFnQix1QkFBdUIsY0FBYyxlQUFnQixvQkFBb0IsY0FBYyxZQUFZLENBQUMsQUFBc0MseUZBQW9CLG9CQUFvQixDQUFDXCIsXCJmaWxlXCI6XCJsaW5rLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttaW4td2lkdGg6NzUlO2ZvbnQtd2VpZ2h0OjMwMH0uc2VsZiAudGl0bGV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMyNjNmZmY7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc2l6ZToxLjJlbTstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9LnNlbGYgLmhlYWRlcnstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5zZWxmIC5zdW1tYXJ5e2NvbG9yOiM1NDU0NTR9LnNlbGYgLnN1bW1hcnkubGluZXMye292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTtsaW5lLWhlaWdodDoxLjJlbTttYXgtaGVpZ2h0OjIuNGVtO3RleHQtYWxpZ246anVzdGlmeX0uc2VsZiAuc3VtbWFyeS5saW5lczI6YmVmb3Jle2NvbnRlbnQ6Jy4uLic7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnNlbGYgLnN1bW1hcnkubGluZXMyOmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt3aWR0aDoxZW07aGVpZ2h0OjFlbTttYXJnaW4tdG9wOjAuMmVtO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uc2VsZiAuc3VtbWFyeS5saW5lczh7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2xpbmUtaGVpZ2h0OjEuMmVtO21heC1oZWlnaHQ6OS42ZW07dGV4dC1hbGlnbjpqdXN0aWZ5fS5zZWxmIC5zdW1tYXJ5LmxpbmVzODpiZWZvcmV7Y29udGVudDonLi4uJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uc2VsZiAuc3VtbWFyeS5saW5lczg6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3dpZHRoOjFlbTtoZWlnaHQ6MWVtO21hcmdpbi10b3A6MC4yZW07YmFja2dyb3VuZC1jb2xvcjojZmZmfS5zZWxmIC5mb290ZXJ7LXdlYmtpdC1ib3gtYWxpZ246ZW5kOy1tcy1mbGV4LWFsaWduOmVuZDthbGlnbi1pdGVtczpmbGV4LWVuZDstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5zZWxmIC5saW5re2Rpc3BsYXk6YmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMwMDY2MjE7Zm9udC1zaXplOjAuOGVtOy1tcy1mbGV4LW5lZ2F0aXZlOjA7ZmxleC1zaHJpbms6MDtvdXRsaW5lOm5vbmV9LnNlbGYgLmxpbms6bGlua3t0ZXh0LWRlY29yYXRpb246bm9uZX0uc2VsZiAubGluazp2aXNpdGVke3RleHQtZGVjb3JhdGlvbjpub25lfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwibGlua19fc2VsZi0tMmxMYUxcIixcblx0XCJ0aXRsZVwiOiBcImxpbmtfX3RpdGxlLS0zV2hxdVwiLFxuXHRcImhlYWRlclwiOiBcImxpbmtfX2hlYWRlci0tRGJVUVBcIixcblx0XCJzdW1tYXJ5XCI6IFwibGlua19fc3VtbWFyeS0tMy1WMkNcIixcblx0XCJsaW5lczJcIjogXCJsaW5rX19saW5lczItLUlYMlNKXCIsXG5cdFwibGluZXM4XCI6IFwibGlua19fbGluZXM4LS0zQlhqOFwiLFxuXHRcImZvb3RlclwiOiBcImxpbmtfX2Zvb3Rlci0tM2xJOTBcIixcblx0XCJsaW5rXCI6IFwibGlua19fbGluay0tMi1BWjFcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubGlua0xpc3RfX3NlbGYtLVk4UU9xIC5saW5rTGlzdF9fcm93LS1MeHByWHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzoxMHB4fS5saW5rTGlzdF9fc2VsZi0tWThRT3EgLmxpbmtMaXN0X19idXR0b24tLWVsejFYe21hcmdpbi1sZWZ0OmF1dG99XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsNkNBQVcsb0JBQW9CLG9CQUFvQixhQUFhLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQixZQUFZLENBQUMsZ0RBQWMsZ0JBQWdCLENBQUNcIixcImZpbGVcIjpcImxpbmtMaXN0LnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGYgLnJvd3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzoxMHB4fS5zZWxmIC5idXR0b257bWFyZ2luLWxlZnQ6YXV0b31cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImxpbmtMaXN0X19zZWxmLS1ZOFFPcVwiLFxuXHRcInJvd1wiOiBcImxpbmtMaXN0X19yb3ctLUx4cHJYXCIsXG5cdFwiYnV0dG9uXCI6IFwibGlua0xpc3RfX2J1dHRvbi0tZWx6MVhcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGlua0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5sb2FkZXJfX3NlbGYtLTJVOWFze2JvcmRlcjoxcHggc29saWQgI2VlZjFmMjtib3JkZXItdG9wOjFweCBzb2xpZCAjMjYzZmZmO2JvcmRlci1yYWRpdXM6NTAlO3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7LXdlYmtpdC1hbmltYXRpb246bG9hZGVyX19zcGluLS0xV3NtMiAycyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOmxvYWRlcl9fc3Bpbi0tMVdzbTIgMnMgbGluZWFyIGluZmluaXRlfUAtd2Via2l0LWtleWZyYW1lcyBsb2FkZXJfX3NwaW4tLTFXc20yezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxdHVybik7dHJhbnNmb3JtOnJvdGF0ZSgxdHVybil9fUBrZXlmcmFtZXMgbG9hZGVyX19zcGluLS0xV3NtMnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMXR1cm4pO3RyYW5zZm9ybTpyb3RhdGUoMXR1cm4pfX1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEscUJBQU0seUJBQXlCLDZCQUE2QixrQkFBa0IsV0FBVyxZQUFZLHlEQUEwQyxnREFBaUMsQ0FBQyx1Q0FBd0IsR0FBRywrQkFBK0Isc0JBQXNCLENBQUMsR0FBSyxnQ0FBaUMsdUJBQXdCLENBQUMsQ0FBQywrQkFBZ0IsR0FBRywrQkFBK0Isc0JBQXNCLENBQUMsR0FBSyxnQ0FBaUMsdUJBQXdCLENBQUMsQ0FBQ1wiLFwiZmlsZVwiOlwibG9hZGVyLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7Ym9yZGVyOjFweCBzb2xpZCAjZWVmMWYyO2JvcmRlci10b3A6MXB4IHNvbGlkICMyNjNmZmY7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDstd2Via2l0LWFuaW1hdGlvbjpzcGluIDJzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246c3BpbiAycyBsaW5lYXIgaW5maW5pdGV9QC13ZWJraXQta2V5ZnJhbWVzIHNwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9MTAwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgc3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJsb2FkZXJfX3NlbGYtLTJVOWFzXCIsXG5cdFwic3BpblwiOiBcImxvYWRlcl9fc3Bpbi0tMVdzbTJcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sb2FkZXIuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnBhcGVyX19zZWxmLS0xcXROaXstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6MTtmbGV4OjE7YmFja2dyb3VuZC1jb2xvcjojZmZmOy13ZWJraXQtYm94LXNoYWRvdzowIDVweCAyMHB4IDAgcmdiYSgxOSwzOCwxMTAsLjA4KTtib3gtc2hhZG93OjAgNXB4IDIwcHggMCByZ2JhKDE5LDM4LDExMCwuMDgpO21hcmdpbi10b3A6MjBweDtib3JkZXItcmFkaXVzOjNweH1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxvQkFBTSxtQkFBbUIsV0FBVyxPQUFPLHNCQUFzQixvREFBeUQsNENBQWlELGdCQUFnQixpQkFBaUIsQ0FBQ1wiLFwiZmlsZVwiOlwicGFwZXIuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZnstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6MTtmbGV4OjE7YmFja2dyb3VuZC1jb2xvcjojZmZmOy13ZWJraXQtYm94LXNoYWRvdzowcHggNXB4IDIwcHggMHB4IHJnYmEoMTksMzgsMTEwLDAuMDgpO2JveC1zaGFkb3c6MHB4IDVweCAyMHB4IDBweCByZ2JhKDE5LDM4LDExMCwwLjA4KTttYXJnaW4tdG9wOjIwcHg7Ym9yZGVyLXJhZGl1czozcHh9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJwYXBlcl9fc2VsZi0tMXF0TmlcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3BhcGVyLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50ZXh0V2l0aExhYmVsX19zZWxmLS0zU2VCS3twYWRkaW5nOjFlbX0udGV4dFdpdGhMYWJlbF9fc2VsZi0tM1NlQksgLnRleHRXaXRoTGFiZWxfX3RleHQtLTJsTUZ6e21hcmdpbi10b3A6NXB4O2ZvbnQtc2l6ZToxNXB4O2NvbG9yOiMxYjI0Mzc7dGV4dC1hbGlnbjpsZWZ0O292ZXJmbG93OmhpZGRlbjt3b3JkLXdyYXA6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3RleHRXaXRoTGFiZWwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSw0QkFBTSxXQUFXLENBQUMsd0RBQVksZUFBZSxlQUFlLGNBQWMsZ0JBQWdCLGdCQUFnQixpQkFBaUIsc0JBQXNCLENBQUNcIixcImZpbGVcIjpcInRleHRXaXRoTGFiZWwuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntwYWRkaW5nOjFlbX0uc2VsZiAudGV4dHttYXJnaW4tdG9wOjVweDtmb250LXNpemU6MTVweDtjb2xvcjojMWIyNDM3O3RleHQtYWxpZ246bGVmdDtvdmVyZmxvdzpoaWRkZW47d29yZC13cmFwOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwidGV4dFdpdGhMYWJlbF9fc2VsZi0tM1NlQktcIixcblx0XCJ0ZXh0XCI6IFwidGV4dFdpdGhMYWJlbF9fdGV4dC0tMmxNRnpcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudG9vbHRpcF9fc2VsZi0tMmg4cDN7cG9zaXRpb246cmVsYXRpdmV9LnRvb2x0aXBfX3NlbGYtLTJoOHAzIC50b29sdGlwX190ZXh0LS0xY3o0ZXt2aXNpYmlsaXR5OmhpZGRlbjt3aWR0aDoxMjBweDtiYWNrZ3JvdW5kLWNvbG9yOiMxYjI0Mzc7Y29sb3I6I2ZmZjt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjVweCAwO2JvcmRlci1yYWRpdXM6NnB4O3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtdHJhbnNpdGlvbi1kZWxheTowczt0cmFuc2l0aW9uLWRlbGF5OjBzfS50b29sdGlwX19zZWxmLS0yaDhwMzpob3ZlciAudG9vbHRpcF9fdGV4dC0tMWN6NGV7dmlzaWJpbGl0eTp2aXNpYmxlOy13ZWJraXQtdHJhbnNpdGlvbi1kZWxheTouNXM7dHJhbnNpdGlvbi1kZWxheTouNXN9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxzQkFBTSxpQkFBaUIsQ0FBQyw0Q0FBWSxrQkFBa0IsWUFBWSx5QkFBeUIsV0FBVyxrQkFBa0IsY0FBYyxrQkFBa0Isa0JBQWtCLDRCQUE0QixtQkFBbUIsQ0FBQyxrREFBa0IsbUJBQW1CLDZCQUE4QixvQkFBcUIsQ0FBQ1wiLFwiZmlsZVwiOlwidG9vbHRpcC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme3Bvc2l0aW9uOnJlbGF0aXZlfS5zZWxmIC50ZXh0e3Zpc2liaWxpdHk6aGlkZGVuO3dpZHRoOjEyMHB4O2JhY2tncm91bmQtY29sb3I6IzFiMjQzNztjb2xvcjojZmZmO3RleHQtYWxpZ246Y2VudGVyO3BhZGRpbmc6NXB4IDA7Ym9yZGVyLXJhZGl1czo2cHg7cG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5OjBzO3RyYW5zaXRpb24tZGVsYXk6MHN9LnNlbGY6aG92ZXIgLnRleHR7dmlzaWJpbGl0eTp2aXNpYmxlOy13ZWJraXQtdHJhbnNpdGlvbi1kZWxheTowLjVzO3RyYW5zaXRpb24tZGVsYXk6MC41c31cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcInRvb2x0aXBfX3NlbGYtLTJoOHAzXCIsXG5cdFwidGV4dFwiOiBcInRvb2x0aXBfX3RleHQtLTFjejRlXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLlN0YXR1c19fc2VsZi0tMmp0d297d2lkdGg6MTAwdnc7aGVpZ2h0OjEwMHZoO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOnN0YXJ0Oy1tcy1mbGV4LWFsaWduOnN0YXJ0O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7YmFja2dyb3VuZC1jb2xvcjojZjVmN2ZhfS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2ludHJvZHVjdGlvbi0tMVJ5c0h7cGFkZGluZy1ib3R0b206MzBweDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZWVmMWYyfS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2ludHJvZHVjdGlvbi0tMVJ5c0ggaDJ7Zm9udC1zaXplOjE1cHg7Zm9udC13ZWlnaHQ6MzAwfS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2ludHJvZHVjdGlvbi0tMVJ5c0ggcHtmb250LXNpemU6MTVweDtjb2xvcjojODk5MzlmOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWR9LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19faW5mby0tMkF4Mmh7cGFkZGluZy10b3A6MzBweH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LlN0YXR1c19fc2VsZi0tMmp0d297LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1ib3gtcGFjazpzdGFydDstbXMtZmxleC1wYWNrOnN0YXJ0O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfX0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19wcmV2aWV3LS0xSVVWMHt3aWR0aDozMDBweDtoZWlnaHQ6MjUwcHg7bWFyZ2luLXJpZ2h0OjMwcHg7bWFyZ2luLXRvcDowO3BhZGRpbmc6MTBweDstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6YXV0bztmbGV4OmF1dG87LXdlYmtpdC1ib3gtZmxleDowOy1tcy1mbGV4LXBvc2l0aXZlOjA7ZmxleC1ncm93OjA7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX3ByZXZpZXctLTFJVVYwe3dpZHRoOmNhbGMoMTAwdncgLSAyMHB4KTtoZWlnaHQ6dW5zZXQ7bWFyZ2luOjA7bWFyZ2luLWJvdHRvbToyMHB4fX0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19wcmV2aWV3LXRpdGxlLS0yTVNhantjb2xvcjojODk5MzlmO21hcmdpbi1ib3R0b206MjBweDttYXJnaW4tdG9wOjE1MHB4fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MTIwMHB4KXsuU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19wcmV2aWV3LXRpdGxlLS0yTVNhanttYXJnaW4tdG9wOjEwcHh9fS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2xvYWRlci0tMkZrc1B7d2lkdGg6MTAwJTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19jb250ZW50LS0xUnVZN3t0ZXh0LWFsaWduOmNlbnRlcjttYXgtd2lkdGg6MzV2dztwYWRkaW5nOjMwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2NvbnRlbnQtLTFSdVk3e21heC13aWR0aDpjYWxjKDEwMHZ3IC0gMjBweCk7bWFyZ2luOjB9fS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2xhYmVsLS1sR1FwWXt3aWR0aDoxMDAlO3BhZGRpbmc6MDttYXJnaW4tdG9wOi0xZW19LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fbGFiZWwtLWxHUXBZOm50aC1jaGlsZCgyKXtwYWRkaW5nLXRvcDoxNXB4O3BhZGRpbmctYm90dG9tOjEwcHg7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2VlZjFmMn0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19saW5rLWxhYmVsLS0yY2M1ZHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3d9LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fbGluay0tMldhdVV7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO2NvbG9yOiMyNjNmZmY7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fYWRkLWJvb2ttYXJrLS1INl9KS3std2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6YXV0bztmbGV4OmF1dG87LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9hcHBzL2xpbmtzL3NyYy9wYWdlcy9TdGF0dXMvU3RhdHVzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEscUJBQU0sWUFBWSxhQUFhLG9CQUFvQixvQkFBb0IsYUFBYSw4QkFBOEIsNkJBQTZCLHVCQUF1QixtQkFBbUIsd0JBQXdCLHFCQUFxQix1QkFBdUIsd0JBQXdCLHFCQUFxQix1QkFBdUIsd0JBQXdCLENBQUMsa0RBQW9CLG9CQUFvQiwrQkFBK0IsQ0FBQyxxREFBdUIsZUFBZSxlQUFlLENBQUMsb0RBQXNCLGVBQWUsY0FBYyxrQ0FBa0MsQ0FBQywwQ0FBWSxnQkFBZ0IsQ0FBQyxxQ0FBc0MscUJBQU0sNEJBQTRCLDZCQUE2QiwwQkFBMEIsc0JBQXNCLHVCQUF1QixvQkFBb0IsMkJBQTJCLHlCQUF5QixzQkFBc0Isa0JBQWtCLENBQUMsQ0FBQyw2Q0FBZSxZQUFZLGFBQWEsa0JBQWtCLGFBQWEsYUFBYSxtQkFBbUIsY0FBYyxVQUFVLG1CQUFtQixvQkFBb0IsWUFBWSxvQkFBb0IsY0FBYyxvQkFBb0Isb0JBQW9CLGFBQWEseUJBQXlCLHNCQUFzQixrQkFBa0IsQ0FBQyxxQ0FBc0MsNkNBQWUseUJBQXlCLGFBQWEsU0FBUyxrQkFBa0IsQ0FBQyxDQUFDLG1EQUFxQixjQUFjLG1CQUFtQixnQkFBZ0IsQ0FBQyxxQ0FBc0MsbURBQXFCLGVBQWUsQ0FBQyxDQUFDLDRDQUFjLFdBQVcsb0JBQW9CLG9CQUFvQixhQUFhLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQix3QkFBd0IscUJBQXFCLHVCQUF1Qix5QkFBeUIsc0JBQXNCLGtCQUFrQixDQUFDLDZDQUFlLGtCQUFrQixlQUFlLFlBQVksQ0FBQyxxQ0FBc0MsNkNBQWUsNkJBQTZCLFFBQVEsQ0FBQyxDQUFDLDJDQUFhLFdBQVcsVUFBVSxlQUFlLENBQUMsd0RBQTBCLGlCQUFpQixvQkFBb0IsK0JBQStCLENBQUMsZ0RBQWtCLG9CQUFvQixvQkFBb0IsYUFBYSw4QkFBOEIsNkJBQTZCLHVCQUF1QixrQkFBa0IsQ0FBQywwQ0FBWSxnQkFBZ0IsdUJBQXVCLG1CQUFtQixjQUFjLG9CQUFvQixDQUFDLGtEQUFvQixtQkFBbUIsY0FBYyxVQUFVLG9CQUFvQixhQUFhLENBQUNcIixcImZpbGVcIjpcIlN0YXR1cy5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpzdGFydDstbXMtZmxleC1hbGlnbjpzdGFydDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2JhY2tncm91bmQtY29sb3I6I2Y1ZjdmYX0uc2VsZiAuaW50cm9kdWN0aW9ue3BhZGRpbmctYm90dG9tOjMwcHg7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2VlZjFmMn0uc2VsZiAuaW50cm9kdWN0aW9uIGgye2ZvbnQtc2l6ZToxNXB4O2ZvbnQtd2VpZ2h0OjMwMH0uc2VsZiAuaW50cm9kdWN0aW9uIHB7Zm9udC1zaXplOjE1cHg7Y29sb3I6Izg5OTM5Zjstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkfS5zZWxmIC5pbmZve3BhZGRpbmctdG9wOjMwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZnstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWJveC1wYWNrOnN0YXJ0Oy1tcy1mbGV4LXBhY2s6c3RhcnQ7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9fS5zZWxmIC5wcmV2aWV3e3dpZHRoOjMwMHB4O2hlaWdodDoyNTBweDttYXJnaW4tcmlnaHQ6MzBweDttYXJnaW4tdG9wOjA7cGFkZGluZzoxMHB4Oy13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDphdXRvO2ZsZXg6YXV0bzstd2Via2l0LWJveC1mbGV4OjA7LW1zLWZsZXgtcG9zaXRpdmU6MDtmbGV4LWdyb3c6MDstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjA7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmIC5wcmV2aWV3e3dpZHRoOmNhbGMoMTAwdncgLSAyMHB4KTtoZWlnaHQ6dW5zZXQ7bWFyZ2luOjA7bWFyZ2luLWJvdHRvbToyMHB4fX0uc2VsZiAucHJldmlldy10aXRsZXtjb2xvcjojODk5MzlmO21hcmdpbi1ib3R0b206MjBweDttYXJnaW4tdG9wOjE1MHB4fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLnByZXZpZXctdGl0bGV7bWFyZ2luLXRvcDoxMHB4fX0uc2VsZiAubG9hZGVye3dpZHRoOjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LnNlbGYgLmNvbnRlbnR7dGV4dC1hbGlnbjpjZW50ZXI7bWF4LXdpZHRoOjM1dnc7cGFkZGluZzozMHB4fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLmNvbnRlbnR7bWF4LXdpZHRoOmNhbGMoMTAwdncgLSAyMHB4KTttYXJnaW46MH19LnNlbGYgLmxhYmVse3dpZHRoOjEwMCU7cGFkZGluZzowO21hcmdpbi10b3A6LTFlbX0uc2VsZiAubGFiZWw6bnRoLWNoaWxkKDIpe3BhZGRpbmctdG9wOjE1cHg7cGFkZGluZy1ib3R0b206MTBweDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZWVmMWYyfS5zZWxmIC5saW5rLWxhYmVse2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd30uc2VsZiAubGlua3tvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7Y29sb3I6IzI2M2ZmZjt0ZXh0LWRlY29yYXRpb246bm9uZX0uc2VsZiAuYWRkLWJvb2ttYXJrey13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDphdXRvO2ZsZXg6YXV0bzstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJTdGF0dXNfX3NlbGYtLTJqdHdvXCIsXG5cdFwiaW50cm9kdWN0aW9uXCI6IFwiU3RhdHVzX19pbnRyb2R1Y3Rpb24tLTFSeXNIXCIsXG5cdFwiaW5mb1wiOiBcIlN0YXR1c19faW5mby0tMkF4MmhcIixcblx0XCJwcmV2aWV3XCI6IFwiU3RhdHVzX19wcmV2aWV3LS0xSVVWMFwiLFxuXHRcInByZXZpZXctdGl0bGVcIjogXCJTdGF0dXNfX3ByZXZpZXctdGl0bGUtLTJNU2FqXCIsXG5cdFwicHJldmlld1RpdGxlXCI6IFwiU3RhdHVzX19wcmV2aWV3LXRpdGxlLS0yTVNhalwiLFxuXHRcImxvYWRlclwiOiBcIlN0YXR1c19fbG9hZGVyLS0yRmtzUFwiLFxuXHRcImNvbnRlbnRcIjogXCJTdGF0dXNfX2NvbnRlbnQtLTFSdVk3XCIsXG5cdFwibGFiZWxcIjogXCJTdGF0dXNfX2xhYmVsLS1sR1FwWVwiLFxuXHRcImxpbmstbGFiZWxcIjogXCJTdGF0dXNfX2xpbmstbGFiZWwtLTJjYzVkXCIsXG5cdFwibGlua0xhYmVsXCI6IFwiU3RhdHVzX19saW5rLWxhYmVsLS0yY2M1ZFwiLFxuXHRcImxpbmtcIjogXCJTdGF0dXNfX2xpbmstLTJXYXVVXCIsXG5cdFwiYWRkLWJvb2ttYXJrXCI6IFwiU3RhdHVzX19hZGQtYm9va21hcmstLUg2X0pLXCIsXG5cdFwiYWRkQm9va21hcmtcIjogXCJTdGF0dXNfX2FkZC1ib29rbWFyay0tSDZfSktcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvU3RhdHVzL1N0YXR1cy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvU3RhdHVzL1N0YXR1cy5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJALXdlYmtpdC1rZXlmcmFtZXMgc3RlcHNfX3dhaXRpbmctLVpINDZtezAle29wYWNpdHk6LjV9NTAle29wYWNpdHk6MX10b3tvcGFjaXR5Oi41fX0uc3RlcHNfX3NlbGYtLTNLeUhte3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttYXJnaW4tdG9wOjMwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5zdGVwc19fc2VsZi0tM0t5SG17LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd319LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3Byb2dyZXNzLWNvdGFpbmVyLS0xbTJsUHtwb3NpdGlvbjpyZWxhdGl2ZX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fcHJvZ3Jlc3MtLTMyZmFCe3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjtsZWZ0OjA7dG9wOjIwcHg7ei1pbmRleDoxO3dpZHRoOjEwMCU7aGVpZ2h0OjEycHg7Ym9yZGVyLXJhZGl1czoxZW07YmFja2dyb3VuZC1jb2xvcjojZWVmMWYyfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MTIwMHB4KXsuc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fcHJvZ3Jlc3MtLTMyZmFCe3dpZHRoOjFlbTtoZWlnaHQ6MTAwJTt0b3A6MDtsZWZ0OjIwcHh9fS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19wcm9ncmVzcy0tMzJmYUIgLnN0ZXBzX19wcm9ncmVzc0ZpbGwtLVc3Ums1ey13ZWJraXQtdHJhbnNpdGlvbjptYXgtd2lkdGggMXMgZWFzZS1pbjt0cmFuc2l0aW9uOm1heC13aWR0aCAxcyBlYXNlLWluO2JhY2tncm91bmQtY29sb3I6IzA5ZDU3Y31AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3Byb2dyZXNzLS0zMmZhQiAuc3RlcHNfX3Byb2dyZXNzRmlsbC0tVzdSazV7LXdlYmtpdC10cmFuc2l0aW9uOm1heC1oZWlnaHQgMXMgZWFzZS1pbjt0cmFuc2l0aW9uOm1heC1oZWlnaHQgMXMgZWFzZS1pbn19LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXBzLWNvbnRhaW5lci0tMUZ4Tld7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwcy1jb250YWluZXItLTFGeE5Xey13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1ufX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt6LWluZGV4OjI7bWFyZ2luLXRvcDpjYWxjKDIwcHggKyAuNWVtIC0gMS41ZW0pfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MTIwMHB4KXsuc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlJ7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzttYXJnaW4tdG9wOjA7bWFyZ2luLWxlZnQ6Y2FsYygyMHB4ICsgLjVlbSAtIDEuNWVtKX19LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSLnN0ZXBzX19kaXNhYmxlZC0tZ1ZSSXF7b3BhY2l0eToxO2N1cnNvcjpub3QtYWxsb3dlZH0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlIuc3RlcHNfX25vdHN0YXJ0ZWQtLTNFaFEte29wYWNpdHk6LjV9LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSLnN0ZXBzX193YWl0aW5nLS1aSDQ2bXtvcGFjaXR5Oi41Oy13ZWJraXQtYW5pbWF0aW9uOnN0ZXBzX193YWl0aW5nLS1aSDQ2bSAxcyBlYXNlLWluLW91dCBpbmZpbml0ZTthbmltYXRpb246c3RlcHNfX3dhaXRpbmctLVpINDZtIDFzIGVhc2UtaW4tb3V0IGluZmluaXRlfS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUi5zdGVwc19fZG9uZS0tMkN2TUQgLnN0ZXBzX19pY29uLS0yYm81cywuc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlIuc3RlcHNfX2RvbmUtLTJDdk1EIHBhdGh7Y29sb3I6I2ZmZjtmaWxsOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMDlkNTdjfS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUiAuc3RlcHNfX2ljb24tLTJibzVzey1tcy1mbGV4LWl0ZW0tYWxpZ246Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyO3dpZHRoOjNlbTtoZWlnaHQ6M2VtO2JhY2tncm91bmQtY29sb3I6I2VlZjFmMjtib3JkZXItcmFkaXVzOjNlbTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSIC5zdGVwc19fY29udGVudC0tMWFLbHp7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSIC5zdGVwc19fY29udGVudC0tMWFLbHp7LXdlYmtpdC1ib3gtYWxpZ246c3RhcnQ7LW1zLWZsZXgtYWxpZ246c3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydDtwYWRkaW5nLWxlZnQ6MjBweH19LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX2ljb24tLTJibzVze2ZvbnQtc2l6ZToxZW19XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL2FwcHMvbGlua3Mvc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL3N0ZXBzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEseUNBQTJCLEdBQUcsVUFBVyxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUssVUFBVyxDQUFDLENBQUMsb0JBQU0sa0JBQWtCLFdBQVcsb0JBQW9CLG9CQUFvQixhQUFhLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLHNCQUFzQixlQUFlLENBQUMscUNBQXNDLG9CQUFNLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLGtCQUFrQixDQUFDLENBQUMscURBQXlCLGlCQUFpQixDQUFDLDRDQUFnQixrQkFBa0IsZ0JBQWdCLE9BQU8sU0FBUyxVQUFVLFdBQVcsWUFBWSxrQkFBa0Isd0JBQXdCLENBQUMscUNBQXNDLDRDQUFnQixVQUFVLFlBQVksTUFBTSxTQUFTLENBQUMsQ0FBQyx3RUFBOEIsd0NBQXdDLGdDQUFnQyx3QkFBd0IsQ0FBQyxxQ0FBc0Msd0VBQThCLHlDQUF5QyxnQ0FBZ0MsQ0FBQyxDQUFDLG1EQUF1QixvQkFBb0Isb0JBQW9CLGFBQWEsOEJBQThCLDZCQUE2Qix1QkFBdUIsbUJBQW1CLHlCQUF5QixzQkFBc0IsNkJBQTZCLENBQUMscUNBQXNDLG1EQUF1Qiw0QkFBNEIsNkJBQTZCLDBCQUEwQixxQkFBcUIsQ0FBQyxDQUFDLHdDQUFZLG9CQUFvQixvQkFBb0IsYUFBYSw0QkFBNEIsNkJBQTZCLDBCQUEwQixzQkFBc0IsVUFBVSxvQ0FBcUMsQ0FBQyxxQ0FBc0Msd0NBQVksOEJBQThCLDZCQUE2Qix1QkFBdUIsbUJBQW1CLGFBQWEscUNBQXNDLENBQUMsQ0FBQywrREFBcUIsVUFBVSxrQkFBa0IsQ0FBQyxpRUFBdUIsVUFBVyxDQUFDLDhEQUFvQixXQUFZLGdFQUFrRCx1REFBeUMsQ0FBQywrSUFBNkMsV0FBVyxVQUFXLHdCQUF3QixDQUFDLDREQUFrQiwyQkFBMkIsa0JBQWtCLFVBQVUsV0FBVyx5QkFBeUIsa0JBQWtCLG9CQUFvQixvQkFBb0IsYUFBYSx3QkFBd0IscUJBQXFCLHVCQUF1Qix5QkFBeUIsc0JBQXNCLGtCQUFrQixDQUFDLCtEQUFxQixvQkFBb0Isb0JBQW9CLGFBQWEsNEJBQTRCLDZCQUE2QiwwQkFBMEIsc0JBQXNCLHlCQUF5QixzQkFBc0Isa0JBQWtCLENBQUMscUNBQXNDLCtEQUFxQix3QkFBd0IscUJBQXFCLHVCQUF1QixpQkFBaUIsQ0FBQyxDQUFDLHdDQUFZLGFBQWEsQ0FBQ1wiLFwiZmlsZVwiOlwic3RlcHMuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCJALXdlYmtpdC1rZXlmcmFtZXMgd2FpdGluZ3swJXtvcGFjaXR5OjAuNX01MCV7b3BhY2l0eToxfTEwMCV7b3BhY2l0eTowLjV9fS5zZWxme3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttYXJnaW4tdG9wOjMwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZnstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93fX0uc2VsZiAucHJvZ3Jlc3MtY290YWluZXJ7cG9zaXRpb246cmVsYXRpdmV9LnNlbGYgLnByb2dyZXNze3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjtsZWZ0OjA7dG9wOjIwcHg7ei1pbmRleDoxO3dpZHRoOjEwMCU7aGVpZ2h0OjEycHg7Ym9yZGVyLXJhZGl1czoxZW07YmFja2dyb3VuZC1jb2xvcjojZWVmMWYyfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLnByb2dyZXNze3dpZHRoOjFlbTtoZWlnaHQ6MTAwJTt0b3A6MDtsZWZ0OjIwcHh9fS5zZWxmIC5wcm9ncmVzcyAucHJvZ3Jlc3NGaWxsey13ZWJraXQtdHJhbnNpdGlvbjptYXgtd2lkdGggMXMgZWFzZS1pbjt0cmFuc2l0aW9uOm1heC13aWR0aCAxcyBlYXNlLWluO2JhY2tncm91bmQtY29sb3I6IzA5ZDU3Y31AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmIC5wcm9ncmVzcyAucHJvZ3Jlc3NGaWxsey13ZWJraXQtdHJhbnNpdGlvbjptYXgtaGVpZ2h0IDFzIGVhc2UtaW47dHJhbnNpdGlvbjptYXgtaGVpZ2h0IDFzIGVhc2UtaW59fS5zZWxmIC5zdGVwcy1jb250YWluZXJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZiAuc3RlcHMtY29udGFpbmVyey13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1ufX0uc2VsZiAuc3RlcHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uO3otaW5kZXg6MjttYXJnaW4tdG9wOmNhbGMoMjBweCArIDAuNWVtIC0gMS41ZW0pfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLnN0ZXB7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzttYXJnaW4tdG9wOjA7bWFyZ2luLWxlZnQ6Y2FsYygyMHB4ICsgMC41ZW0gLSAxLjVlbSl9fS5zZWxmIC5zdGVwLmRpc2FibGVke29wYWNpdHk6MTtjdXJzb3I6bm90LWFsbG93ZWR9LnNlbGYgLnN0ZXAubm90c3RhcnRlZHtvcGFjaXR5OjAuNX0uc2VsZiAuc3RlcC53YWl0aW5ne29wYWNpdHk6MC41Oy13ZWJraXQtYW5pbWF0aW9uOndhaXRpbmcgMXMgZWFzZS1pbi1vdXQgaW5maW5pdGU7YW5pbWF0aW9uOndhaXRpbmcgMXMgZWFzZS1pbi1vdXQgaW5maW5pdGV9LnNlbGYgLnN0ZXAuZG9uZSAuaWNvbiwuc2VsZiAuc3RlcC5kb25lIHBhdGh7Y29sb3I6I2ZmZjtmaWxsOndoaXRlO2JhY2tncm91bmQtY29sb3I6IzA5ZDU3Y30uc2VsZiAuc3RlcCAuaWNvbnstbXMtZmxleC1pdGVtLWFsaWduOmNlbnRlcjthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDozZW07aGVpZ2h0OjNlbTtiYWNrZ3JvdW5kLWNvbG9yOiNlZWYxZjI7Ym9yZGVyLXJhZGl1czozZW07ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5zZWxmIC5zdGVwIC5jb250ZW50e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZiAuc3RlcCAuY29udGVudHstd2Via2l0LWJveC1hbGlnbjpzdGFydDstbXMtZmxleC1hbGlnbjpzdGFydDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O3BhZGRpbmctbGVmdDoyMHB4fX0uc2VsZiAuaWNvbntmb250LXNpemU6MWVtfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwic3RlcHNfX3NlbGYtLTNLeUhtXCIsXG5cdFwicHJvZ3Jlc3MtY290YWluZXJcIjogXCJzdGVwc19fcHJvZ3Jlc3MtY290YWluZXItLTFtMmxQXCIsXG5cdFwicHJvZ3Jlc3NDb3RhaW5lclwiOiBcInN0ZXBzX19wcm9ncmVzcy1jb3RhaW5lci0tMW0ybFBcIixcblx0XCJwcm9ncmVzc1wiOiBcInN0ZXBzX19wcm9ncmVzcy0tMzJmYUJcIixcblx0XCJwcm9ncmVzc0ZpbGxcIjogXCJzdGVwc19fcHJvZ3Jlc3NGaWxsLS1XN1JrNVwiLFxuXHRcInN0ZXBzLWNvbnRhaW5lclwiOiBcInN0ZXBzX19zdGVwcy1jb250YWluZXItLTFGeE5XXCIsXG5cdFwic3RlcHNDb250YWluZXJcIjogXCJzdGVwc19fc3RlcHMtY29udGFpbmVyLS0xRnhOV1wiLFxuXHRcInN0ZXBcIjogXCJzdGVwc19fc3RlcC0tM0JFZlJcIixcblx0XCJkaXNhYmxlZFwiOiBcInN0ZXBzX19kaXNhYmxlZC0tZ1ZSSXFcIixcblx0XCJub3RzdGFydGVkXCI6IFwic3RlcHNfX25vdHN0YXJ0ZWQtLTNFaFEtXCIsXG5cdFwid2FpdGluZ1wiOiBcInN0ZXBzX193YWl0aW5nLS1aSDQ2bVwiLFxuXHRcImRvbmVcIjogXCJzdGVwc19fZG9uZS0tMkN2TURcIixcblx0XCJpY29uXCI6IFwic3RlcHNfX2ljb24tLTJibzVzXCIsXG5cdFwiY29udGVudFwiOiBcInN0ZXBzX19jb250ZW50LS0xYUtselwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9zdGVwcy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLldoaXRlbGlzdF9fc2VsZi0tMUJrTXp7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O21hcmdpbi10b3A6MTBweDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5XaGl0ZWxpc3RfX3NlbGYtLTFCa016IC5XaGl0ZWxpc3RfX3BhcGVyLS0yWkNzdXt3aWR0aDo3MCU7cGFkZGluZzoxMHB4fVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9hcHBzL2xpbmtzL3NyYy9wYWdlcy9XaGl0ZWxpc3Quc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSx3QkFBTSxXQUFXLFlBQVksb0JBQW9CLG9CQUFvQixhQUFhLGdCQUFnQiw0QkFBNEIsNkJBQTZCLDBCQUEwQixzQkFBc0Isd0JBQXdCLHFCQUFxQix1QkFBdUIseUJBQXlCLHNCQUFzQixrQkFBa0IsQ0FBQyxpREFBYSxVQUFVLFlBQVksQ0FBQ1wiLFwiZmlsZVwiOlwiV2hpdGVsaXN0LnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O21hcmdpbi10b3A6MTBweDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5zZWxmIC5wYXBlcnt3aWR0aDo3MCU7cGFkZGluZzoxMHB4fVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwiV2hpdGVsaXN0X19zZWxmLS0xQmtNelwiLFxuXHRcInBhcGVyXCI6IFwiV2hpdGVsaXN0X19wYXBlci0tMlpDc3VcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuL3NyYy9wYWdlcy9XaGl0ZWxpc3Quc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1QVCtTYW5zOjQwMCw3MDApO1wiLCBcIlwiXSk7XG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohIG5vcm1hbGl6ZS5jc3MgdjcuMC4wIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL2h0bWx7bGluZS1oZWlnaHQ6MS4xNTstbXMtdGV4dC1zaXplLWFkanVzdDoxMDAlOy13ZWJraXQtdGV4dC1zaXplLWFkanVzdDoxMDAlfWJvZHl7bWFyZ2luOjB9YXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLG5hdixzZWN0aW9ue2Rpc3BsYXk6YmxvY2t9aDF7Zm9udC1zaXplOjJlbTttYXJnaW46LjY3ZW0gMH1maWdjYXB0aW9uLGZpZ3VyZSxtYWlue2Rpc3BsYXk6YmxvY2t9ZmlndXJle21hcmdpbjoxZW0gNDBweH1ocnstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MDtvdmVyZmxvdzp2aXNpYmxlfXByZXtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXA6b2JqZWN0c31hYmJyW3RpdGxlXXtib3JkZXItYm90dG9tOm5vbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTstd2Via2l0LXRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkfWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OmluaGVyaXQ7Zm9udC13ZWlnaHQ6Ym9sZGVyfWNvZGUsa2JkLHNhbXB7Zm9udC1mYW1pbHk6bW9ub3NwYWNlLG1vbm9zcGFjZTtmb250LXNpemU6MWVtfWRmbntmb250LXN0eWxlOml0YWxpY31tYXJre2JhY2tncm91bmQtY29sb3I6I2ZmMDtjb2xvcjojMDAwfXNtYWxse2ZvbnQtc2l6ZTo4MCV9c3ViLHN1cHtmb250LXNpemU6NzUlO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9c3Vie2JvdHRvbTotLjI1ZW19c3Vwe3RvcDotLjVlbX1hdWRpbyx2aWRlb3tkaXNwbGF5OmlubGluZS1ibG9ja31hdWRpbzpub3QoW2NvbnRyb2xzXSl7ZGlzcGxheTpub25lO2hlaWdodDowfWltZ3tib3JkZXItc3R5bGU6bm9uZX1zdmc6bm90KDpyb290KXtvdmVyZmxvdzpoaWRkZW59YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMDAlO2xpbmUtaGVpZ2h0OjEuMTU7bWFyZ2luOjB9YnV0dG9uLGlucHV0e292ZXJmbG93OnZpc2libGV9YnV0dG9uLHNlbGVjdHt0ZXh0LXRyYW5zZm9ybTpub25lfVt0eXBlPXJlc2V0XSxbdHlwZT1zdWJtaXRdLGJ1dHRvbixodG1sIFt0eXBlPWJ1dHRvbl17LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbn1bdHlwZT1idXR0b25dOjotbW96LWZvY3VzLWlubmVyLFt0eXBlPXJlc2V0XTo6LW1vei1mb2N1cy1pbm5lcixbdHlwZT1zdWJtaXRdOjotbW96LWZvY3VzLWlubmVyLGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcntib3JkZXItc3R5bGU6bm9uZTtwYWRkaW5nOjB9W3R5cGU9YnV0dG9uXTotbW96LWZvY3VzcmluZyxbdHlwZT1yZXNldF06LW1vei1mb2N1c3JpbmcsW3R5cGU9c3VibWl0XTotbW96LWZvY3VzcmluZyxidXR0b246LW1vei1mb2N1c3Jpbmd7b3V0bGluZToxcHggZG90dGVkIEJ1dHRvblRleHR9ZmllbGRzZXR7cGFkZGluZzouMzVlbSAuNzVlbSAuNjI1ZW19bGVnZW5key13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtjb2xvcjppbmhlcml0O2Rpc3BsYXk6dGFibGU7bWF4LXdpZHRoOjEwMCU7cGFkZGluZzowO3doaXRlLXNwYWNlOm5vcm1hbH1wcm9ncmVzc3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX10ZXh0YXJlYXtvdmVyZmxvdzphdXRvfVt0eXBlPWNoZWNrYm94XSxbdHlwZT1yYWRpb117LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MH1bdHlwZT1udW1iZXJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFt0eXBlPW51bWJlcl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b257aGVpZ2h0OmF1dG99W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6dGV4dGZpZWxkO291dGxpbmUtb2Zmc2V0Oi0ycHh9W3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtY2FuY2VsLWJ1dHRvbixbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfTo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbjtmb250OmluaGVyaXR9ZGV0YWlscyxtZW51e2Rpc3BsYXk6YmxvY2t9c3VtbWFyeXtkaXNwbGF5Omxpc3QtaXRlbX1jYW52YXN7ZGlzcGxheTppbmxpbmUtYmxvY2t9W2hpZGRlbl0sdGVtcGxhdGV7ZGlzcGxheTpub25lfWJvZHl7Zm9udC1mYW1pbHk6UFQgU2FucyxzYW5zLXNlcmlmfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9hcHBzL2xpbmtzL3N0eWxlcy9hbGwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSw0RUFBNEUsQUFBdUUsS0FBSyxpQkFBaUIsMEJBQTBCLDZCQUE2QixDQUFDLEtBQUssUUFBUSxDQUFDLHdDQUF3QyxhQUFhLENBQUMsR0FBRyxjQUFjLGNBQWUsQ0FBQyx1QkFBdUIsYUFBYSxDQUFDLE9BQU8sZUFBZSxDQUFDLEdBQUcsK0JBQStCLHVCQUF1QixTQUFTLGdCQUFnQixDQUFDLElBQUksZ0NBQWlDLGFBQWEsQ0FBQyxFQUFFLDZCQUE2QixvQ0FBb0MsQ0FBQyxZQUFZLG1CQUFtQiwwQkFBMEIseUNBQXlDLGdDQUFnQyxDQUFDLFNBQVMsb0JBQW1CLEFBQVUsa0JBQWtCLENBQTNCLEFBQTRCLGNBQWMsZ0NBQWlDLGFBQWEsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEtBQUssc0JBQXNCLFVBQVUsQ0FBQyxNQUFNLGFBQWEsQ0FBQyxRQUFRLGNBQWMsY0FBYyxrQkFBa0IsdUJBQXVCLENBQUMsSUFBSSxhQUFjLENBQUMsSUFBSSxTQUFVLENBQUMsWUFBWSxvQkFBb0IsQ0FBQyxzQkFBc0IsYUFBYSxRQUFRLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxlQUFlLGVBQWUsQ0FBQyxzQ0FBc0MsdUJBQXVCLGVBQWUsaUJBQWlCLFFBQVEsQ0FBQyxhQUFhLGdCQUFnQixDQUFDLGNBQWMsbUJBQW1CLENBQUMscURBQTJELHlCQUF5QixDQUFDLHdIQUE4SCxrQkFBa0IsU0FBUyxDQUFDLDRHQUFrSCw2QkFBNkIsQ0FBQyxTQUFTLDBCQUE2QixDQUFDLE9BQU8sOEJBQThCLHNCQUFzQixjQUFjLGNBQWMsZUFBZSxVQUFVLGtCQUFrQixDQUFDLFNBQVMscUJBQXFCLHVCQUF1QixDQUFDLFNBQVMsYUFBYSxDQUFDLDZCQUFpQyw4QkFBOEIsc0JBQXNCLFNBQVMsQ0FBQyxrRkFBc0YsV0FBVyxDQUFDLGNBQWdCLDZCQUE2QixtQkFBbUIsQ0FBQyxxRkFBeUYsdUJBQXVCLENBQUMsNkJBQTZCLDBCQUEwQixZQUFZLENBQUMsYUFBYSxhQUFhLENBQUMsUUFBUSxpQkFBaUIsQ0FBQyxPQUFPLG9CQUFvQixDQUFDLEFBQXNCLGtCQUFTLFlBQVksQ0FBQyxLQUFLLDhCQUFpQyxDQUFDXCIsXCJmaWxlXCI6XCJhbGwuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiEgbm9ybWFsaXplLmNzcyB2Ny4wLjAgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovQGltcG9ydCB1cmwoXFxcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1QVCtTYW5zOjQwMCw3MDBcXFwiKTtodG1se2xpbmUtaGVpZ2h0OjEuMTU7LW1zLXRleHQtc2l6ZS1hZGp1c3Q6MTAwJTstd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6MTAwJX1ib2R5e21hcmdpbjowfWFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOjAuNjdlbSAwfWZpZ2NhcHRpb24sZmlndXJlLG1haW57ZGlzcGxheTpibG9ja31maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhyey13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2hlaWdodDowO292ZXJmbG93OnZpc2libGV9cHJle2ZvbnQtZmFtaWx5Om1vbm9zcGFjZSwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXA6b2JqZWN0c31hYmJyW3RpdGxlXXtib3JkZXItYm90dG9tOm5vbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTstd2Via2l0LXRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkfWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OmluaGVyaXR9YixzdHJvbmd7Zm9udC13ZWlnaHQ6Ym9sZGVyfWNvZGUsa2JkLHNhbXB7Zm9udC1mYW1pbHk6bW9ub3NwYWNlLCBtb25vc3BhY2U7Zm9udC1zaXplOjFlbX1kZm57Zm9udC1zdHlsZTppdGFsaWN9bWFya3tiYWNrZ3JvdW5kLWNvbG9yOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1Yntib3R0b206LTAuMjVlbX1zdXB7dG9wOi0wLjVlbX1hdWRpbyx2aWRlb3tkaXNwbGF5OmlubGluZS1ibG9ja31hdWRpbzpub3QoW2NvbnRyb2xzXSl7ZGlzcGxheTpub25lO2hlaWdodDowfWltZ3tib3JkZXItc3R5bGU6bm9uZX1zdmc6bm90KDpyb290KXtvdmVyZmxvdzpoaWRkZW59YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMDAlO2xpbmUtaGVpZ2h0OjEuMTU7bWFyZ2luOjB9YnV0dG9uLGlucHV0e292ZXJmbG93OnZpc2libGV9YnV0dG9uLHNlbGVjdHt0ZXh0LXRyYW5zZm9ybTpub25lfWJ1dHRvbixodG1sIFt0eXBlPVxcXCJidXR0b25cXFwiXSxbdHlwZT1cXFwicmVzZXRcXFwiXSxbdHlwZT1cXFwic3VibWl0XFxcIl17LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbn1idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXItc3R5bGU6bm9uZTtwYWRkaW5nOjB9YnV0dG9uOi1tb3otZm9jdXNyaW5nLFt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxbdHlwZT1cXFwicmVzZXRcXFwiXTotbW96LWZvY3VzcmluZyxbdHlwZT1cXFwic3VibWl0XFxcIl06LW1vei1mb2N1c3Jpbmd7b3V0bGluZToxcHggZG90dGVkIEJ1dHRvblRleHR9ZmllbGRzZXR7cGFkZGluZzowLjM1ZW0gMC43NWVtIDAuNjI1ZW19bGVnZW5key13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtjb2xvcjppbmhlcml0O2Rpc3BsYXk6dGFibGU7bWF4LXdpZHRoOjEwMCU7cGFkZGluZzowO3doaXRlLXNwYWNlOm5vcm1hbH1wcm9ncmVzc3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX10ZXh0YXJlYXtvdmVyZmxvdzphdXRvfVt0eXBlPVxcXCJjaGVja2JveFxcXCJdLFt0eXBlPVxcXCJyYWRpb1xcXCJdey13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjB9W3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbntoZWlnaHQ6YXV0b31bdHlwZT1cXFwic2VhcmNoXFxcIl17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDtvdXRsaW5lLW9mZnNldDotMnB4fVt0eXBlPVxcXCJzZWFyY2hcXFwiXTo6LXdlYmtpdC1zZWFyY2gtY2FuY2VsLWJ1dHRvbixbdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmV9Ojotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2ZvbnQ6aW5oZXJpdH1kZXRhaWxzLG1lbnV7ZGlzcGxheTpibG9ja31zdW1tYXJ5e2Rpc3BsYXk6bGlzdC1pdGVtfWNhbnZhc3tkaXNwbGF5OmlubGluZS1ibG9ja310ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9W2hpZGRlbl17ZGlzcGxheTpub25lfWJvZHl7Zm9udC1mYW1pbHk6J1BUIFNhbnMnLCBzYW5zLXNlcmlmfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuL3N0eWxlcy9hbGwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zdHlsZXMvYWxsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciB1dGY4ID0ge1xuXHRcdCd2ZXJzaW9uJzogJzIuMS4yJyxcblx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gdmFsdWVFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYVR5cGUgPSB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSk7XG4gIHZhciBiVHlwZSA9IHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiKTtcblxuICBpZiAoYVR5cGUgIT09IGJUeXBlKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGFUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBhVmFsdWUgPSBhLnZhbHVlT2YoKTtcbiAgICB2YXIgYlZhbHVlID0gYi52YWx1ZU9mKCk7XG5cbiAgICBpZiAoYVZhbHVlICE9PSBhIHx8IGJWYWx1ZSAhPT0gYikgcmV0dXJuIHZhbHVlRXF1YWwoYVZhbHVlLCBiVmFsdWUpO1xuXG4gICAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlRXF1YWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXZWIzID0gcmVxdWlyZSgnLi9saWIvd2ViMycpO1xuXG4vLyBkb250IG92ZXJyaWRlIGdsb2JhbCB2YXJpYWJsZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuV2ViMyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuV2ViMyA9IFdlYjM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViMztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFt7XCJjb25zdGFudFwiOnRydWUsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX293bmVyXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcIm5hbWVcIjpcIm5hbWVcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwib19uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6dHJ1ZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJvd25lclwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcImNvbnRlbnRcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6dHJ1ZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJhZGRyXCIsXCJvdXRwdXRzXCI6W3tcIm5hbWVcIjpcIlwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcInJlc2VydmVcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6dHJ1ZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJzdWJSZWdpc3RyYXJcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwiX25ld093bmVyXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcIm5hbWVcIjpcInRyYW5zZmVyXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcIl9yZWdpc3RyYXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwic2V0U3ViUmVnaXN0cmFyXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W10sXCJuYW1lXCI6XCJSZWdpc3RyYXJcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwiX2FcIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wibmFtZVwiOlwiX3ByaW1hcnlcIixcInR5cGVcIjpcImJvb2xcIn1dLFwibmFtZVwiOlwic2V0QWRkcmVzc1wiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfY29udGVudFwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJzZXRDb250ZW50XCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcImRpc293blwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJfd2lubmVyXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcIm5hbWVcIjpcIkF1Y3Rpb25FbmRlZFwiLFwidHlwZVwiOlwiZXZlbnRcIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJfYmlkZGVyXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcIl92YWx1ZVwiLFwidHlwZVwiOlwidWludDI1NlwifV0sXCJuYW1lXCI6XCJOZXdCaWRcIixcInR5cGVcIjpcImV2ZW50XCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwibmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJDaGFuZ2VkXCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIm5hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJhZGRyXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcIm5hbWVcIjpcIlByaW1hcnlDaGFuZ2VkXCIsXCJ0eXBlXCI6XCJldmVudFwifV1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW3tcImNvbnN0YW50XCI6dHJ1ZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJvd25lclwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfcmVmdW5kXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcIm5hbWVcIjpcImRpc293blwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcImFkZHJcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwicmVzZXJ2ZVwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfbmV3T3duZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwidHJhbnNmZXJcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwiX2FcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwic2V0QWRkclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJuYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcIkNoYW5nZWRcIixcInR5cGVcIjpcImV2ZW50XCJ9XVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL0lDQVBSZWdpc3RyYXIuanNvblxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFt7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcImZyb21cIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwidG9cIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjpcInVpbnQyNTZcIn1dLFwibmFtZVwiOlwidHJhbnNmZXJcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJuYW1lXCI6XCJpbmRpcmVjdElkXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcImljYXBUcmFuc2ZlclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJkZXBvc2l0XCIsXCJvdXRwdXRzXCI6W10sXCJwYXlhYmxlXCI6dHJ1ZSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDI1NlwifV0sXCJuYW1lXCI6XCJBbm9ueW1vdXNEZXBvc2l0XCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImZyb21cIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDI1NlwifV0sXCJuYW1lXCI6XCJEZXBvc2l0XCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImZyb21cIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDI1NlwifV0sXCJuYW1lXCI6XCJUcmFuc2ZlclwiLFwidHlwZVwiOlwiZXZlbnRcIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJmcm9tXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwidG9cIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wiaW5kZXhlZFwiOmZhbHNlLFwibmFtZVwiOlwiaW5kaXJlY3RJZFwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDI1NlwifV0sXCJuYW1lXCI6XCJJY2FwVHJhbnNmZXJcIixcInR5cGVcIjpcImV2ZW50XCJ9XVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvU21hcnRFeGNoYW5nZS5qc29uXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvblxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZUFkZHJlc3MgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgYWRkcmVzcyB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogYWRkcmVzc1xuICogYWRkcmVzc1tdXG4gKiBhZGRyZXNzWzRdXG4gKiBhZGRyZXNzW11bXVxuICogYWRkcmVzc1szXVtdXG4gKiBhZGRyZXNzW11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEludDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dEFkZHJlc3M7XG59O1xuXG5Tb2xpZGl0eVR5cGVBZGRyZXNzLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlQWRkcmVzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVBZGRyZXNzO1xuXG5Tb2xpZGl0eVR5cGVBZGRyZXNzLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL2FkZHJlc3MoXFxbKFswLTldKilcXF0pPy8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVBZGRyZXNzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2FkZHJlc3MuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9hZGRyZXNzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlQm9vbCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyBib29sIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBib29sXG4gKiBib29sW11cbiAqIGJvb2xbNF1cbiAqIGJvb2xbXVtdXG4gKiBib29sWzNdW11cbiAqIGJvb2xbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUJvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0Qm9vbDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dEJvb2w7XG59O1xuXG5Tb2xpZGl0eVR5cGVCb29sLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlQm9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVCb29sO1xuXG5Tb2xpZGl0eVR5cGVCb29sLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15ib29sKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUJvb2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYm9vbC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Jvb2wuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVCeXRlcyBpcyBhIHByb3RvdHlwZSB0aGF0IHJlcHJlc2VudHMgdGhlIGJ5dGVzIHR5cGUuXG4gKiBJdCBtYXRjaGVzOlxuICogYnl0ZXNcbiAqIGJ5dGVzW11cbiAqIGJ5dGVzWzRdXG4gKiBieXRlc1tdW11cbiAqIGJ5dGVzWzNdW11cbiAqIGJ5dGVzW11bNl1bXSwgLi4uXG4gKiBieXRlczMyXG4gKiBieXRlczhbNF1cbiAqIGJ5dGVzWzNdW11cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEJ5dGVzO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0Qnl0ZXM7XG59O1xuXG5Tb2xpZGl0eVR5cGVCeXRlcy5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZUJ5dGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUJ5dGVzO1xuXG5Tb2xpZGl0eVR5cGVCeXRlcy5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9eYnl0ZXMoWzAtOV17MSx9KShcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVCeXRlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9ieXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2J5dGVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGNvZGVyLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG52YXIgU29saWRpdHlUeXBlQm9vbCA9IHJlcXVpcmUoJy4vYm9vbCcpO1xudmFyIFNvbGlkaXR5VHlwZUludCA9IHJlcXVpcmUoJy4vaW50Jyk7XG52YXIgU29saWRpdHlUeXBlVUludCA9IHJlcXVpcmUoJy4vdWludCcpO1xudmFyIFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcyA9IHJlcXVpcmUoJy4vZHluYW1pY2J5dGVzJyk7XG52YXIgU29saWRpdHlUeXBlU3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbnZhciBTb2xpZGl0eVR5cGVSZWFsID0gcmVxdWlyZSgnLi9yZWFsJyk7XG52YXIgU29saWRpdHlUeXBlVVJlYWwgPSByZXF1aXJlKCcuL3VyZWFsJyk7XG52YXIgU29saWRpdHlUeXBlQnl0ZXMgPSByZXF1aXJlKCcuL2J5dGVzJyk7XG5cbnZhciBpc0R5bmFtaWMgPSBmdW5jdGlvbiAoc29saWRpdHlUeXBlLCB0eXBlKSB7XG4gICByZXR1cm4gc29saWRpdHlUeXBlLmlzRHluYW1pY1R5cGUodHlwZSkgfHxcbiAgICAgICAgICBzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkodHlwZSk7XG59O1xuXG4vKipcbiAqIFNvbGlkaXR5Q29kZXIgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGFueSB0eXBlXG4gKi9cbnZhciBTb2xpZGl0eUNvZGVyID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdGhpcy5fdHlwZXMgPSB0eXBlcztcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHR5cGUgdG8gU29saWRpdHlUeXBlXG4gKlxuICogQG1ldGhvZCBfcmVxdWlyZVR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJucyB7U29saWRpdHlUeXBlfVxuICogQHRocm93cyB7RXJyb3J9IHRocm93cyBpZiBubyBtYXRjaGluZyB0eXBlIGlzIGZvdW5kXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLl9yZXF1aXJlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZSA9IHRoaXMuX3R5cGVzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pc1R5cGUodHlwZSk7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoIXNvbGlkaXR5VHlwZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBzb2xpZGl0eSB0eXBlITogJyArIHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzb2xpZGl0eVR5cGU7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBwbGFpbiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFyYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gcGxhaW4gcGFyYW1cbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBwbGFpbiBwYXJhbVxuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJhbSkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZVBhcmFtcyhbdHlwZV0sIFtwYXJhbV0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVBhcmFtc1xuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtc1xuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGxpc3Qgb2YgcGFyYW1zXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZVBhcmFtcyA9IGZ1bmN0aW9uICh0eXBlcywgcGFyYW1zKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZXMgPSB0aGlzLmdldFNvbGlkaXR5VHlwZXModHlwZXMpO1xuXG4gICAgdmFyIGVuY29kZWRzID0gc29saWRpdHlUeXBlcy5tYXAoZnVuY3Rpb24gKHNvbGlkaXR5VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHNvbGlkaXR5VHlwZS5lbmNvZGUocGFyYW1zW2luZGV4XSwgdHlwZXNbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gc29saWRpdHlUeXBlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICB2YXIgc3RhdGljUGFydExlbmd0aCA9IHNvbGlkaXR5VHlwZS5zdGF0aWNQYXJ0TGVuZ3RoKHR5cGVzW2luZGV4XSk7XG4gICAgICAgIHZhciByb3VuZGVkU3RhdGljUGFydExlbmd0aCA9IE1hdGguZmxvb3IoKHN0YXRpY1BhcnRMZW5ndGggKyAzMSkgLyAzMikgKiAzMjtcblxuICAgICAgICByZXR1cm4gYWNjICsgKGlzRHluYW1pYyhzb2xpZGl0eVR5cGVzW2luZGV4XSwgdHlwZXNbaW5kZXhdKSA/XG4gICAgICAgICAgICAzMiA6XG4gICAgICAgICAgICByb3VuZGVkU3RhdGljUGFydExlbmd0aCk7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5lbmNvZGVNdWx0aVdpdGhPZmZzZXQodHlwZXMsIHNvbGlkaXR5VHlwZXMsIGVuY29kZWRzLCBkeW5hbWljT2Zmc2V0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVNdWx0aVdpdGhPZmZzZXQgPSBmdW5jdGlvbiAodHlwZXMsIHNvbGlkaXR5VHlwZXMsIGVuY29kZWRzLCBkeW5hbWljT2Zmc2V0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICBpZiAoaXNEeW5hbWljKHNvbGlkaXR5VHlwZXNbaV0sIHR5cGVzW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGYuZm9ybWF0SW5wdXRJbnQoZHluYW1pY09mZnNldCkuZW5jb2RlKCk7XG4gICAgICAgICAgICB2YXIgZSA9IHNlbGYuZW5jb2RlV2l0aE9mZnNldCh0eXBlc1tpXSwgc29saWRpdHlUeXBlc1tpXSwgZW5jb2RlZHNbaV0sIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgZHluYW1pY09mZnNldCArPSBlLmxlbmd0aCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkb24ndCBhZGQgbGVuZ3RoIHRvIGR5bmFtaWNPZmZzZXQuIGl0J3MgYWxyZWFkeSBjb3VudGVkXG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IG5lc3RlZCBhcnJheXNcbiAgICB9KTtcblxuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICAgICAgaWYgKGlzRHluYW1pYyhzb2xpZGl0eVR5cGVzW2ldLCB0eXBlc1tpXSkpIHtcbiAgICAgICAgICAgIHZhciBlID0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICBkeW5hbWljT2Zmc2V0ICs9IGUubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFRPRE86IHJlZmFjdG9yIHdob2xlIGVuY29kaW5nIVxuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZW5jb2RlV2l0aE9mZnNldCA9IGZ1bmN0aW9uICh0eXBlLCBzb2xpZGl0eVR5cGUsIGVuY29kZWQsIG9mZnNldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc29saWRpdHlUeXBlLmlzRHluYW1pY0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gb2Zmc2V0IHdhcyBhbHJlYWR5IHNldFxuICAgICAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzb2xpZGl0eVR5cGUubmVzdGVkTmFtZSh0eXBlKTtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gc29saWRpdHlUeXBlLnN0YXRpY1BhcnRMZW5ndGgobmVzdGVkTmFtZSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZW5jb2RlZFswXTtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNMZW5ndGggPSAyOyAvLyBpbiBpbnRcbiAgICAgICAgICAgICAgICBpZiAoc29saWRpdHlUeXBlLmlzRHluYW1pY0FycmF5KG5lc3RlZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNMZW5ndGggKz0gKyhlbmNvZGVkW2kgLSAxXSlbMF0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmLmZvcm1hdElucHV0SW50KG9mZnNldCArIGkgKiBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgcHJldmlvdXNMZW5ndGggKiAzMikuZW5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGxlbmd0aCwgc2tpcCBpdFxuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsT2Zmc2V0ID0gcmVzdWx0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNlbGYuZW5jb2RlV2l0aE9mZnNldChuZXN0ZWROYW1lLCBzb2xpZGl0eVR5cGUsIGVuY29kZWRbaSArIDFdLCBvZmZzZXQgKyAgYWRkaXRpb25hbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcblxuICAgIH0gZWxzZSBpZiAoc29saWRpdHlUeXBlLmlzU3RhdGljQXJyYXkodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNvbGlkaXR5VHlwZS5uZXN0ZWROYW1lKHR5cGUpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGUuc3RhdGljUGFydExlbmd0aChuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG5cbiAgICAgICAgICAgIGlmIChzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkobmVzdGVkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNMZW5ndGggPSAwOyAvLyBpbiBpbnRcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgbGVuZ3RoIG9mIHByZXZpb3VzIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTGVuZ3RoICs9ICsoZW5jb2RlZFtpIC0gMV0gfHwgW10pWzBdIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZi5mb3JtYXRJbnB1dEludChvZmZzZXQgKyBpICogbmVzdGVkU3RhdGljUGFydExlbmd0aCArIHByZXZpb3VzTGVuZ3RoICogMzIpLmVuY29kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxPZmZzZXQgPSByZXN1bHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KG5lc3RlZE5hbWUsIHNvbGlkaXR5VHlwZSwgZW5jb2RlZFtpXSwgb2Zmc2V0ICsgYWRkaXRpb25hbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGJ5dGVzIHRvIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbSA9IGZ1bmN0aW9uICh0eXBlLCBieXRlcykge1xuICAgIHJldHVybiB0aGlzLmRlY29kZVBhcmFtcyhbdHlwZV0sIGJ5dGVzKVswXTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbVxuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbXMgPSBmdW5jdGlvbiAodHlwZXMsIGJ5dGVzKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZXMgPSB0aGlzLmdldFNvbGlkaXR5VHlwZXModHlwZXMpO1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5nZXRPZmZzZXRzKHR5cGVzLCBzb2xpZGl0eVR5cGVzKTtcblxuICAgIHJldHVybiBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLmRlY29kZShieXRlcywgb2Zmc2V0c1tpbmRleF0sICB0eXBlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9KTtcbn07XG5cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmdldE9mZnNldHMgPSBmdW5jdGlvbiAodHlwZXMsIHNvbGlkaXR5VHlwZXMpIHtcbiAgICB2YXIgbGVuZ3RocyA9ICBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLnN0YXRpY1BhcnRMZW5ndGgodHlwZXNbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3Rocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgLy8gc3VtIHdpdGggbGVuZ3RoIG9mIHByZXZpb3VzIGVsZW1lbnRcbiAgICAgICAgbGVuZ3Roc1tpXSArPSBsZW5ndGhzW2kgLSAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuZ3Rocy5tYXAoZnVuY3Rpb24gKGxlbmd0aCwgaW5kZXgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGxlbmd0aCwgc28gdGhlIGxlbmd0aCBpcyBzdW0gb2YgcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgdmFyIHN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGVzW2luZGV4XS5zdGF0aWNQYXJ0TGVuZ3RoKHR5cGVzW2luZGV4XSk7XG4gICAgICAgIHJldHVybiBsZW5ndGggLSBzdGF0aWNQYXJ0TGVuZ3RoO1xuICAgIH0pO1xufTtcblxuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZ2V0U29saWRpdHlUeXBlcyA9IGZ1bmN0aW9uICh0eXBlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1aXJlVHlwZSh0eXBlKTtcbiAgICB9KTtcbn07XG5cbnZhciBjb2RlciA9IG5ldyBTb2xpZGl0eUNvZGVyKFtcbiAgICBuZXcgU29saWRpdHlUeXBlQWRkcmVzcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVCb29sKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUludCgpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVVSW50KCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVCeXRlcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVTdHJpbmcoKSxcbiAgICBuZXcgU29saWRpdHlUeXBlUmVhbCgpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVVUmVhbCgpXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb2RlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9jb2Rlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2NvZGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0RHluYW1pY0J5dGVzO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzO1xufTtcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcztcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15ieXRlcyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvZHluYW1pY2J5dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvZHluYW1pY2J5dGVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGZvcm1hdHRlcnMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjID0gcmVxdWlyZSgnLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgU29saWRpdHlQYXJhbSA9IHJlcXVpcmUoJy4vcGFyYW0nKTtcblxuXG4vKipcbiAqIEZvcm1hdHMgaW5wdXQgdmFsdWUgdG8gYnl0ZSByZXByZXNlbnRhdGlvbiBvZiBpbnRcbiAqIElmIHZhbHVlIGlzIG5lZ2F0aXZlLCByZXR1cm4gaXQncyB0d28ncyBjb21wbGVtZW50XG4gKiBJZiB0aGUgdmFsdWUgaXMgZmxvYXRpbmcgcG9pbnQsIHJvdW5kIGl0IGRvd25cbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0SW50XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfSB2YWx1ZSB0aGF0IG5lZWRzIHRvIGJlIGZvcm1hdHRlZFxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dEludCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIEJpZ051bWJlci5jb25maWcoYy5FVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREUpO1xuICAgIHZhciByZXN1bHQgPSB1dGlscy5wYWRMZWZ0KHV0aWxzLnRvVHdvc0NvbXBsZW1lbnQodmFsdWUpLnRvU3RyaW5nKDE2KSwgNjQpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShyZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IGJ5dGVzXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dEJ5dGVzXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXRCeXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB1dGlscy50b0hleCh2YWx1ZSkuc3Vic3RyKDIpO1xuICAgIHZhciBsID0gTWF0aC5mbG9vcigocmVzdWx0Lmxlbmd0aCArIDYzKSAvIDY0KTtcbiAgICByZXN1bHQgPSB1dGlscy5wYWRSaWdodChyZXN1bHQsIGwgKiA2NCk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgaW5wdXQgYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdER5bmFtaWNJbnB1dEJ5dGVzXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXREeW5hbWljQnl0ZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbHMudG9IZXgodmFsdWUpLnN1YnN0cigyKTtcbiAgICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCAvIDI7XG4gICAgdmFyIGwgPSBNYXRoLmZsb29yKChyZXN1bHQubGVuZ3RoICsgNjMpIC8gNjQpO1xuICAgIHJlc3VsdCA9IHV0aWxzLnBhZFJpZ2h0KHJlc3VsdCwgbCAqIDY0KTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0oZm9ybWF0SW5wdXRJbnQobGVuZ3RoKS52YWx1ZSArIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgaW5wdXQgdmFsdWUgdG8gYnl0ZSByZXByZXNlbnRhdGlvbiBvZiBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0U3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXRTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbHMuZnJvbVV0ZjgodmFsdWUpLnN1YnN0cigyKTtcbiAgICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCAvIDI7XG4gICAgdmFyIGwgPSBNYXRoLmZsb29yKChyZXN1bHQubGVuZ3RoICsgNjMpIC8gNjQpO1xuICAgIHJlc3VsdCA9IHV0aWxzLnBhZFJpZ2h0KHJlc3VsdCwgbCAqIDY0KTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0oZm9ybWF0SW5wdXRJbnQobGVuZ3RoKS52YWx1ZSArIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgaW5wdXQgdmFsdWUgdG8gYnl0ZSByZXByZXNlbnRhdGlvbiBvZiBib29sXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dEJvb2xcbiAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXRCb29sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICsgKHZhbHVlID8gICcxJyA6ICcwJyk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgaW5wdXQgdmFsdWUgdG8gYnl0ZSByZXByZXNlbnRhdGlvbiBvZiByZWFsXG4gKiBWYWx1ZXMgYXJlIG11bHRpcGxpZWQgYnkgMl5tIGFuZCBlbmNvZGVkIGFzIGludGVnZXJzXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dFJlYWxcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ9XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0UmVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXRJbnB1dEludChuZXcgQmlnTnVtYmVyKHZhbHVlKS50aW1lcyhuZXcgQmlnTnVtYmVyKDIpLnBvdygxMjgpKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGlucHV0IHZhbHVlIGlzIG5lZ2F0aXZlXG4gKlxuICogQG1ldGhvZCBzaWduZWRJc05lZ2F0aXZlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgaXMgaGV4IGZvcm1hdFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgc2lnbmVkSXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJpZ051bWJlcih2YWx1ZS5zdWJzdHIoMCwgMSksIDE2KS50b1N0cmluZygyKS5zdWJzdHIoMCwgMSkpID09PSAnMSc7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgdG8gaW50XG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRJbnRcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gcGFyYW1cbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIGZvcm1hdHRlZCB0byBiaWcgbnVtYmVyXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRJbnQgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJhbS5zdGF0aWNQYXJ0KCkgfHwgXCIwXCI7XG5cbiAgICAvLyBjaGVjayBpZiBpdCdzIG5lZ2F0aXZlIG51bWJlclxuICAgIC8vIGl0IGl0IGlzLCByZXR1cm4gdHdvJ3MgY29tcGxlbWVudFxuICAgIGlmIChzaWduZWRJc05lZ2F0aXZlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWx1ZSwgMTYpLm1pbnVzKG5ldyBCaWdOdW1iZXIoJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNikpLm1pbnVzKDEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWx1ZSwgMTYpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIHRvIHVpbnRcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFVJbnRcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX1cbiAqIEByZXR1cm5zIHtCaWdOdW1lYmVyfSByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gdWludFxuICovXG52YXIgZm9ybWF0T3V0cHV0VUludCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcmFtLnN0YXRpY1BhcnQoKSB8fCBcIjBcIjtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWx1ZSwgMTYpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIHRvIHJlYWxcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFJlYWxcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX1cbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGlucHV0IGJ5dGVzIGZvcm1hdHRlZCB0byByZWFsXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRSZWFsID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIGZvcm1hdE91dHB1dEludChwYXJhbSkuZGl2aWRlZEJ5KG5ldyBCaWdOdW1iZXIoMikucG93KDEyOCkpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIHRvIHVyZWFsXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRVUmVhbFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfVxuICogQHJldHVybnMge0JpZ051bWJlcn0gaW5wdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIHVyZWFsXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRVUmVhbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBmb3JtYXRPdXRwdXRVSW50KHBhcmFtKS5kaXZpZGVkQnkobmV3IEJpZ051bWJlcigyKS5wb3coMTI4KSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgYm9vbFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0Qm9vbFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfVxuICogQHJldHVybnMge0Jvb2xlYW59IHJpZ2h0LWFsaWduZWQgaW5wdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIGJvb2xcbiAqL1xudmFyIGZvcm1hdE91dHB1dEJvb2wgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW0uc3RhdGljUGFydCgpID09PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScgPyB0cnVlIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dEJ5dGVzXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IGxlZnQtYWxpZ25lZCBoZXggcmVwcmVzZW50YXRpb24gb2Ygc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0eXBlIG5hbWVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCBzdHJpbmdcbiAqL1xudmFyIGZvcm1hdE91dHB1dEJ5dGVzID0gZnVuY3Rpb24gKHBhcmFtLCBuYW1lKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBuYW1lLm1hdGNoKC9eYnl0ZXMoWzAtOV0qKS8pO1xuICAgIHZhciBzaXplID0gcGFyc2VJbnQobWF0Y2hlc1sxXSk7XG4gICAgcmV0dXJuICcweCcgKyBwYXJhbS5zdGF0aWNQYXJ0KCkuc2xpY2UoMCwgMiAqIHNpemUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IGJ5dGVzXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXNcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gbGVmdC1hbGlnbmVkIGhleCByZXByZXNlbnRhdGlvbiBvZiBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCBzdHJpbmdcbiAqL1xudmFyIGZvcm1hdE91dHB1dER5bmFtaWNCeXRlcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBsZW5ndGggPSAobmV3IEJpZ051bWJlcihwYXJhbS5keW5hbWljUGFydCgpLnNsaWNlKDAsIDY0KSwgMTYpKS50b051bWJlcigpICogMjtcbiAgICByZXR1cm4gJzB4JyArIHBhcmFtLmR5bmFtaWNQYXJ0KCkuc3Vic3RyKDY0LCBsZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0U3RyaW5nXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IGxlZnQtYWxpZ25lZCBoZXggcmVwcmVzZW50YXRpb24gb2Ygc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmdcbiAqL1xudmFyIGZvcm1hdE91dHB1dFN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBsZW5ndGggPSAobmV3IEJpZ051bWJlcihwYXJhbS5keW5hbWljUGFydCgpLnNsaWNlKDAsIDY0KSwgMTYpKS50b051bWJlcigpICogMjtcbiAgICByZXR1cm4gdXRpbHMudG9VdGY4KHBhcmFtLmR5bmFtaWNQYXJ0KCkuc3Vic3RyKDY0LCBsZW5ndGgpKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRBZGRyZXNzXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IHJpZ2h0LWFsaWduZWQgaW5wdXQgYnl0ZXNcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFkZHJlc3NcbiAqL1xudmFyIGZvcm1hdE91dHB1dEFkZHJlc3MgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJhbS5zdGF0aWNQYXJ0KCk7XG4gICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIDQwLCB2YWx1ZS5sZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0SW5wdXRJbnQ6IGZvcm1hdElucHV0SW50LFxuICAgIGZvcm1hdElucHV0Qnl0ZXM6IGZvcm1hdElucHV0Qnl0ZXMsXG4gICAgZm9ybWF0SW5wdXREeW5hbWljQnl0ZXM6IGZvcm1hdElucHV0RHluYW1pY0J5dGVzLFxuICAgIGZvcm1hdElucHV0U3RyaW5nOiBmb3JtYXRJbnB1dFN0cmluZyxcbiAgICBmb3JtYXRJbnB1dEJvb2w6IGZvcm1hdElucHV0Qm9vbCxcbiAgICBmb3JtYXRJbnB1dFJlYWw6IGZvcm1hdElucHV0UmVhbCxcbiAgICBmb3JtYXRPdXRwdXRJbnQ6IGZvcm1hdE91dHB1dEludCxcbiAgICBmb3JtYXRPdXRwdXRVSW50OiBmb3JtYXRPdXRwdXRVSW50LFxuICAgIGZvcm1hdE91dHB1dFJlYWw6IGZvcm1hdE91dHB1dFJlYWwsXG4gICAgZm9ybWF0T3V0cHV0VVJlYWw6IGZvcm1hdE91dHB1dFVSZWFsLFxuICAgIGZvcm1hdE91dHB1dEJvb2w6IGZvcm1hdE91dHB1dEJvb2wsXG4gICAgZm9ybWF0T3V0cHV0Qnl0ZXM6IGZvcm1hdE91dHB1dEJ5dGVzLFxuICAgIGZvcm1hdE91dHB1dER5bmFtaWNCeXRlczogZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzLFxuICAgIGZvcm1hdE91dHB1dFN0cmluZzogZm9ybWF0T3V0cHV0U3RyaW5nLFxuICAgIGZvcm1hdE91dHB1dEFkZHJlc3M6IGZvcm1hdE91dHB1dEFkZHJlc3Ncbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvZm9ybWF0dGVycy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Zvcm1hdHRlcnMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVJbnQgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgaW50IHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBpbnRcbiAqIGludFtdXG4gKiBpbnRbNF1cbiAqIGludFtdW11cbiAqIGludFszXVtdXG4gKiBpbnRbXVs2XVtdLCAuLi5cbiAqIGludDMyXG4gKiBpbnQ2NFtdXG4gKiBpbnQ4WzRdXG4gKiBpbnQyNTZbXVtdXG4gKiBpbnRbM11bXVxuICogaW50NjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUludCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRJbnQ7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRJbnQ7XG59O1xuXG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlSW50O1xuXG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXmludChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVJbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvaW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBwYXJhbS5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xuXG4vKipcbiAqIFNvbGlkaXR5UGFyYW0gb2JqZWN0IHByb3RvdHlwZS5cbiAqIFNob3VsZCBiZSB1c2VkIHdoZW4gZW5jb2RpbmcsIGRlY29kaW5nIHNvbGlkaXR5IGJ5dGVzXG4gKi9cbnZhciBTb2xpZGl0eVBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgfHwgJyc7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7IC8vIG9mZnNldCBpbiBieXRlc1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBnZXQgbGVuZ3RoIG9mIHBhcmFtcydzIGR5bmFtaWMgcGFydFxuICogXG4gKiBAbWV0aG9kIGR5bmFtaWNQYXJ0TGVuZ3RoXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgZHluYW1pYyBwYXJ0IChpbiBieXRlcylcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuZHluYW1pY1BhcnRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHluYW1pY1BhcnQoKS5sZW5ndGggLyAyO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgY29weSBvZiBzb2xpZGl0eSBwYXJhbSB3aXRoIGRpZmZlcmVudCBvZmZzZXRcbiAqXG4gKiBAbWV0aG9kIHdpdGhPZmZzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgbGVuZ3RoIGluIGJ5dGVzXG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX0gbmV3IHNvbGlkaXR5IHBhcmFtIHdpdGggYXBwbGllZCBvZmZzZXRcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUud2l0aE9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0odGhpcy52YWx1ZSwgb2Zmc2V0KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gY29tYmluZSBzb2xpZGl0eSBwYXJhbXMgdG9nZXRoZXJcbiAqIGVnLiB3aGVuIGFwcGVuZGluZyBhbiBhcnJheVxuICpcbiAqIEBtZXRob2QgY29tYmluZVxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBwYXJhbSB3aXRoIHdoaWNoIHdlIHNob3VsZCBjb21iaW5lXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IHJlc3VsdCBvZiBjb21iaW5hdGlvblxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKHRoaXMudmFsdWUgKyBwYXJhbS52YWx1ZSk7IFxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIHBhcmFtIGhhcyBkeW5hbWljIHNpemUuXG4gKiBJZiBpdCBoYXMsIGl0IHJldHVybnMgdHJ1ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0R5bmFtaWNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5pc0R5bmFtaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gdHJhbnNmb3JtIG9mZnNldCB0byBieXRlc1xuICpcbiAqIEBtZXRob2Qgb2Zmc2V0QXNCeXRlc1xuICogQHJldHVybnMge1N0cmluZ30gYnl0ZXMgcmVwcmVzZW50YXRpb24gb2Ygb2Zmc2V0XG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLm9mZnNldEFzQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzRHluYW1pYygpID8gJycgOiB1dGlscy5wYWRMZWZ0KHV0aWxzLnRvVHdvc0NvbXBsZW1lbnQodGhpcy5vZmZzZXQpLnRvU3RyaW5nKDE2KSwgNjQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGdldCBzdGF0aWMgcGFydCBvZiBwYXJhbVxuICpcbiAqIEBtZXRob2Qgc3RhdGljUGFydFxuICogQHJldHVybnMge1N0cmluZ30gb2Zmc2V0IGlmIGl0IGlzIGEgZHluYW1pYyBwYXJhbSwgb3RoZXJ3aXNlIHZhbHVlXG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLnN0YXRpY1BhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRHluYW1pYygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlOyBcbiAgICB9IFxuICAgIHJldHVybiB0aGlzLm9mZnNldEFzQnl0ZXMoKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgZHluYW1pYyBwYXJ0IG9mIHBhcmFtXG4gKlxuICogQG1ldGhvZCBkeW5hbWljUGFydFxuICogQHJldHVybnMge1N0cmluZ30gcmV0dXJucyBhIHZhbHVlIGlmIGl0IGlzIGEgZHluYW1pYyBwYXJhbSwgb3RoZXJ3aXNlIGVtcHR5IHN0cmluZ1xuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5keW5hbWljUGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0R5bmFtaWMoKSA/IHRoaXMudmFsdWUgOiAnJztcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byBlbmNvZGUgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGVuY29kZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRpY1BhcnQoKSArIHRoaXMuZHluYW1pY1BhcnQoKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byBlbmNvZGUgYXJyYXkgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBlbmNvZGVMaXN0XG4gKiBAcGFyYW0ge0FycmF5W1NvbGlkaXR5UGFyYW1dfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblNvbGlkaXR5UGFyYW0uZW5jb2RlTGlzdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBcbiAgICAvLyB1cGRhdGluZyBvZmZzZXRzXG4gICAgdmFyIHRvdGFsT2Zmc2V0ID0gcGFyYW1zLmxlbmd0aCAqIDMyO1xuICAgIHZhciBvZmZzZXRQYXJhbXMgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICBpZiAoIXBhcmFtLmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IHRvdGFsT2Zmc2V0O1xuICAgICAgICB0b3RhbE9mZnNldCArPSBwYXJhbS5keW5hbWljUGFydExlbmd0aCgpO1xuICAgICAgICByZXR1cm4gcGFyYW0ud2l0aE9mZnNldChvZmZzZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gZW5jb2RlIGV2ZXJ5dGhpbmchXG4gICAgcmV0dXJuIG9mZnNldFBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHBhcmFtLmR5bmFtaWNQYXJ0KCk7XG4gICAgfSwgb2Zmc2V0UGFyYW1zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwYXJhbSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcGFyYW0uc3RhdGljUGFydCgpO1xuICAgIH0sICcnKSk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVBhcmFtO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvcGFyYW0uanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9wYXJhbS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVJlYWwgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgcmVhbCB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogcmVhbFxuICogcmVhbFtdXG4gKiByZWFsWzRdXG4gKiByZWFsW11bXVxuICogcmVhbFszXVtdXG4gKiByZWFsW11bNl1bXSwgLi4uXG4gKiByZWFsMzJcbiAqIHJlYWw2NFtdXG4gKiByZWFsOFs0XVxuICogcmVhbDI1NltdW11cbiAqIHJlYWxbM11bXVxuICogcmVhbDY0W11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVSZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFJlYWw7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRSZWFsO1xufTtcblxuU29saWRpdHlUeXBlUmVhbC5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZVJlYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlUmVhbDtcblxuU29saWRpdHlUeXBlUmVhbC5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9yZWFsKFswLTldKik/KFxcWyhbMC05XSopXFxdKT8vKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlUmVhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9yZWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvcmVhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG52YXIgU29saWRpdHlUeXBlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFN0cmluZztcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFN0cmluZztcbn07XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVTdHJpbmc7XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9ec3RyaW5nKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5Tb2xpZGl0eVR5cGVTdHJpbmcucHJvdG90eXBlLmlzRHluYW1pY1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVN0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9zdHJpbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVBhcmFtID0gcmVxdWlyZSgnLi9wYXJhbScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZSBwcm90b3R5cGUgaXMgdXNlZCB0byBlbmNvZGUvZGVjb2RlIHNvbGlkaXR5IHBhcmFtcyBvZiBjZXJ0YWluIHR5cGVcbiAqL1xudmFyIFNvbGlkaXR5VHlwZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGNvbmZpZy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBjb25maWcub3V0cHV0Rm9ybWF0dGVyO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhpcyBTb2xpZGl0eVR5cGUgZG8gbWF0Y2ggZ2l2ZW4gbmFtZVxuICpcbiAqIEBtZXRob2QgaXNUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiB0eXBlIG1hdGNoIHRoaXMgU29saWRpdHlUeXBlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IFwidGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyd3JpdHRlbiBmb3IgdHlwZSBcIiArIG5hbWU7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGF0IGlzIHRoZSBsZW5ndGggb2Ygc3RhdGljIHBhcnQgaW4gZ2l2ZW4gdHlwZVxuICpcbiAqIEBtZXRob2Qgc3RhdGljUGFydExlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoIG9mIHN0YXRpYyBwYXJ0IGluIGJ5dGVzXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuc3RhdGljUGFydExlbmd0aCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gSWYgbmFtZSBpc24ndCBhbiBhcnJheSB0aGVuIHRyZWF0IGl0IGxpa2UgYSBzaW5nbGUgZWxlbWVudCBhcnJheS5cbiAgICByZXR1cm4gKHRoaXMubmVzdGVkVHlwZXMobmFtZSkgfHwgWydbMV0nXSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgLy8gdGhlIGxlbmd0aCBvZiB0aGUgbmVzdGVkIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodHlwZS5zbGljZSgxLCAtMSksIDEwKSB8fCAxO1xuICAgICAgICB9KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICogY3VycmVudDtcbiAgICAgICAgLy8gYWxsIGJhc2ljIHR5cGVzIGFyZSAzMiBieXRlcyBsb25nXG4gICAgICAgIH0sIDMyKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHR5cGUgaXMgZHluYW1pYyBhcnJheVxuICogZWc6XG4gKiBcInR5cGVbXVwiID0+IHRydWVcbiAqIFwidHlwZVs0XVwiID0+IGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0R5bmFtaWNBcnJheVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgdGhlIHR5cGUgaXMgZHluYW1pYyBhcnJheVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmlzRHluYW1pY0FycmF5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbmVzdGVkVHlwZXMgPSB0aGlzLm5lc3RlZFR5cGVzKG5hbWUpO1xuICAgIHJldHVybiAhIW5lc3RlZFR5cGVzICYmICFuZXN0ZWRUeXBlc1tuZXN0ZWRUeXBlcy5sZW5ndGggLSAxXS5tYXRjaCgvWzAtOV17MSx9L2cpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdHlwZSBpcyBzdGF0aWMgYXJyYXlcbiAqIGVnOlxuICogXCJ0eXBlW11cIiA9PiBmYWxzZVxuICogXCJ0eXBlWzRdXCIgPT4gdHJ1ZVxuICpcbiAqIEBtZXRob2QgaXNTdGF0aWNBcnJheVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgdGhlIHR5cGUgaXMgc3RhdGljIGFycmF5XG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuaXNTdGF0aWNBcnJheSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG5lc3RlZFR5cGVzID0gdGhpcy5uZXN0ZWRUeXBlcyhuYW1lKTtcbiAgICByZXR1cm4gISFuZXN0ZWRUeXBlcyAmJiAhIW5lc3RlZFR5cGVzW25lc3RlZFR5cGVzLmxlbmd0aCAtIDFdLm1hdGNoKC9bMC05XXsxLH0vZyk7XG59O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gbGVuZ3RoIG9mIHN0YXRpYyBhcnJheVxuICogZWcuXG4gKiBcImludFszMl1cIiA9PiAzMlxuICogXCJpbnQyNTZbMTRdXCIgPT4gMTRcbiAqIFwiaW50WzJdWzNdXCIgPT4gM1xuICogXCJpbnRcIiA9PiAxXG4gKiBcImludFsxXVwiID0+IDFcbiAqIFwiaW50W11cIiA9PiAxXG4gKlxuICogQG1ldGhvZCBzdGF0aWNBcnJheUxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge051bWJlcn0gc3RhdGljIGFycmF5IGxlbmd0aFxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLnN0YXRpY0FycmF5TGVuZ3RoID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbmVzdGVkVHlwZXMgPSB0aGlzLm5lc3RlZFR5cGVzKG5hbWUpO1xuICAgIGlmIChuZXN0ZWRUeXBlcykge1xuICAgICAgIHJldHVybiBwYXJzZUludChuZXN0ZWRUeXBlc1tuZXN0ZWRUeXBlcy5sZW5ndGggLSAxXS5tYXRjaCgvWzAtOV17MSx9L2cpIHx8IDEpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiBuZXN0ZWQgdHlwZVxuICogZWcuXG4gKiBcImludFszMl1cIiA9PiBcImludFwiXG4gKiBcImludDI1NlsxNF1cIiA9PiBcImludDI1NlwiXG4gKiBcImludFsyXVszXVwiID0+IFwiaW50WzJdXCJcbiAqIFwiaW50XCIgPT4gXCJpbnRcIlxuICogXCJpbnRbXVwiID0+IFwiaW50XCJcbiAqXG4gKiBAbWV0aG9kIG5lc3RlZE5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG5lc3RlZCBuYW1lXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUubmVzdGVkTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gcmVtb3ZlIGxhc3QgW10gaW4gbmFtZVxuICAgIHZhciBuZXN0ZWRUeXBlcyA9IHRoaXMubmVzdGVkVHlwZXMobmFtZSk7XG4gICAgaWYgKCFuZXN0ZWRUeXBlcykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZS5zdWJzdHIoMCwgbmFtZS5sZW5ndGggLSBuZXN0ZWRUeXBlc1tuZXN0ZWRUeXBlcy5sZW5ndGggLSAxXS5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIHRydWUgaWYgdHlwZSBoYXMgZHluYW1pYyBzaXplIGJ5IGRlZmF1bHRcbiAqIHN1Y2ggdHlwZXMgYXJlIFwic3RyaW5nXCIsIFwiYnl0ZXNcIlxuICpcbiAqIEBtZXRob2QgaXNEeW5hbWljVHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgaXMgZHluYW1pYywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuaXNEeW5hbWljVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gYXJyYXkgb2YgbmVzdGVkIHR5cGVzXG4gKiBlZy5cbiAqIFwiaW50WzJdWzNdW11cIiA9PiBbXCJbMl1cIiwgXCJbM11cIiwgXCJbXVwiXVxuICogXCJpbnRbXSA9PiBbXCJbXVwiXVxuICogXCJpbnRcIiA9PiBudWxsXG4gKlxuICogQG1ldGhvZCBuZXN0ZWRUeXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBuZXN0ZWQgdHlwZXNcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5uZXN0ZWRUeXBlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gcmV0dXJuIGxpc3Qgb2Ygc3RyaW5ncyBlZy4gXCJbXVwiLCBcIlszXVwiLCBcIltdXCIsIFwiWzJdXCJcbiAgICByZXR1cm4gbmFtZS5tYXRjaCgvKFxcW1swLTldKlxcXSkvZyk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSB0aGUgdmFsdWVcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIHZhbHVlXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLmlzRHluYW1pY0FycmF5KG5hbWUpKSB7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNlbGYubmVzdGVkTmFtZShuYW1lKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZi5mb3JtYXRJbnB1dEludChsZW5ndGgpLmVuY29kZSgpKTtcblxuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuZW5jb2RlKHYsIG5lc3RlZE5hbWUpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGljQXJyYXkobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBzZWxmLnN0YXRpY0FycmF5TGVuZ3RoKG5hbWUpOyAgICAgICAgICAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc2VsZi5uZXN0ZWROYW1lKG5hbWUpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5lbmNvZGUodmFsdWVbaV0sIG5lc3RlZE5hbWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9pbnB1dEZvcm1hdHRlcih2YWx1ZSwgbmFtZSkuZW5jb2RlKCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSB2YWx1ZSBmcm9tIGJ5dGVzXG4gKlxuICogQG1ldGhvZCBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBpbiBieXRlc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdHlwZSBuYW1lXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZWNvZGVkIHZhbHVlXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGJ5dGVzLCBvZmZzZXQsIG5hbWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc0R5bmFtaWNBcnJheShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFycmF5T2Zmc2V0ID0gcGFyc2VJbnQoJzB4JyArIGJ5dGVzLnN1YnN0cihvZmZzZXQgKiAyLCA2NCkpOyAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCcweCcgKyBieXRlcy5zdWJzdHIoYXJyYXlPZmZzZXQgKiAyLCA2NCkpOyAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBhcnJheVN0YXJ0ID0gYXJyYXlPZmZzZXQgKyAzMjsgLy8gYXJyYXkgc3RhcnRzIGFmdGVyIGxlbmd0aDsgLy8gaW4gYnl0ZXNcblxuICAgICAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzZWxmLm5lc3RlZE5hbWUobmFtZSk7XG4gICAgICAgICAgICB2YXIgbmVzdGVkU3RhdGljUGFydExlbmd0aCA9IHNlbGYuc3RhdGljUGFydExlbmd0aChuZXN0ZWROYW1lKTsgIC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBNYXRoLmZsb29yKChuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgMzEpIC8gMzIpICogMzI7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICogcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGg7IGkgKz0gcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLmRlY29kZShieXRlcywgYXJyYXlTdGFydCArIGksIG5lc3RlZE5hbWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcblxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRpY0FycmF5KG5hbWUpKSB7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gc2VsZi5zdGF0aWNBcnJheUxlbmd0aChuYW1lKTsgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgYXJyYXlTdGFydCA9IG9mZnNldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gYnl0ZXNcblxuICAgICAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzZWxmLm5lc3RlZE5hbWUobmFtZSk7XG4gICAgICAgICAgICB2YXIgbmVzdGVkU3RhdGljUGFydExlbmd0aCA9IHNlbGYuc3RhdGljUGFydExlbmd0aChuZXN0ZWROYW1lKTsgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aCA9IE1hdGguZmxvb3IoKG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggKyAzMSkgLyAzMikgKiAzMjtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggKiByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aDsgaSArPSByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuZGVjb2RlKGJ5dGVzLCBhcnJheVN0YXJ0ICsgaSwgbmVzdGVkTmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0R5bmFtaWNUeXBlKG5hbWUpKSB7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHluYW1pY09mZnNldCA9IHBhcnNlSW50KCcweCcgKyBieXRlcy5zdWJzdHIob2Zmc2V0ICogMiwgNjQpKTsgICAgICAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCcweCcgKyBieXRlcy5zdWJzdHIoZHluYW1pY09mZnNldCAqIDIsIDY0KSk7ICAgICAgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciByb3VuZGVkTGVuZ3RoID0gTWF0aC5mbG9vcigobGVuZ3RoICsgMzEpIC8gMzIpOyAgICAgICAgICAgICAgICAgICAgIC8vIGluIGludFxuICAgICAgICAgICAgdmFyIHBhcmFtID0gbmV3IFNvbGlkaXR5UGFyYW0oYnl0ZXMuc3Vic3RyKGR5bmFtaWNPZmZzZXQgKiAyLCAoIDEgKyByb3VuZGVkTGVuZ3RoKSAqIDY0KSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fb3V0cHV0Rm9ybWF0dGVyKHBhcmFtLCBuYW1lKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5zdGF0aWNQYXJ0TGVuZ3RoKG5hbWUpO1xuICAgIHZhciBwYXJhbSA9IG5ldyBTb2xpZGl0eVBhcmFtKGJ5dGVzLnN1YnN0cihvZmZzZXQgKiAyLCBsZW5ndGggKiAyKSk7XG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEZvcm1hdHRlcihwYXJhbSwgbmFtZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdHlwZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVVJbnQgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgdWludCB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogdWludFxuICogdWludFtdXG4gKiB1aW50WzRdXG4gKiB1aW50W11bXVxuICogdWludFszXVtdXG4gKiB1aW50W11bNl1bXSwgLi4uXG4gKiB1aW50MzJcbiAqIHVpbnQ2NFtdXG4gKiB1aW50OFs0XVxuICogdWludDI1NltdW11cbiAqIHVpbnRbM11bXVxuICogdWludDY0W11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVVSW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEludDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFVJbnQ7XG59O1xuXG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlVUludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVVSW50O1xuXG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL151aW50KFswLTldKik/KFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVVJbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdWludC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3VpbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVVUmVhbCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyB1cmVhbCB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogdXJlYWxcbiAqIHVyZWFsW11cbiAqIHVyZWFsWzRdXG4gKiB1cmVhbFtdW11cbiAqIHVyZWFsWzNdW11cbiAqIHVyZWFsW11bNl1bXSwgLi4uXG4gKiB1cmVhbDMyXG4gKiB1cmVhbDY0W11cbiAqIHVyZWFsOFs0XVxuICogdXJlYWwyNTZbXVtdXG4gKiB1cmVhbFszXVtdXG4gKiB1cmVhbDY0W11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVVUmVhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRSZWFsO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0VVJlYWw7XG59O1xuXG5Tb2xpZGl0eVR5cGVVUmVhbC5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZVVSZWFsO1xuXG5Tb2xpZGl0eVR5cGVVUmVhbC5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9edXJlYWwoWzAtOV0qKT8oXFxbKFswLTldKilcXF0pKiQvKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlVVJlYWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdXJlYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91cmVhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8vIGdvIGVudiBkb2Vzbid0IGhhdmUgYW5kIG5lZWQgWE1MSHR0cFJlcXVlc3RcbmlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5YTUxIdHRwUmVxdWVzdCA9IHt9O1xufSBlbHNlIHtcbiAgICBleHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3Q7IC8vIGpzaGludCBpZ25vcmU6bGluZVxufVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvYnJvd3Nlci14aHIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9icm93c2VyLXhoci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGNvbmZpZy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbi8qKlxuICogVXRpbHNcbiAqIFxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnNcbiAqIFxuICogQGNsYXNzIFt1dGlsc10gY29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbi8vLyByZXF1aXJlZCB0byBkZWZpbmUgRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFXG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5cbnZhciBFVEhfVU5JVFMgPSBbXG4gICAgJ3dlaScsXG4gICAgJ2t3ZWknLFxuICAgICdNd2VpJyxcbiAgICAnR3dlaScsXG4gICAgJ3N6YWJvJyxcbiAgICAnZmlubmV5JyxcbiAgICAnZmVtdG9ldGhlcicsXG4gICAgJ3BpY29ldGhlcicsXG4gICAgJ25hbm9ldGhlcicsXG4gICAgJ21pY3JvZXRoZXInLFxuICAgICdtaWxsaWV0aGVyJyxcbiAgICAnbmFubycsXG4gICAgJ21pY3JvJyxcbiAgICAnbWlsbGknLFxuICAgICdldGhlcicsXG4gICAgJ2dyYW5kJyxcbiAgICAnTWV0aGVyJyxcbiAgICAnR2V0aGVyJyxcbiAgICAnVGV0aGVyJyxcbiAgICAnUGV0aGVyJyxcbiAgICAnRWV0aGVyJyxcbiAgICAnWmV0aGVyJyxcbiAgICAnWWV0aGVyJyxcbiAgICAnTmV0aGVyJyxcbiAgICAnRGV0aGVyJyxcbiAgICAnVmV0aGVyJyxcbiAgICAnVWV0aGVyJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRVRIX1BBRERJTkc6IDMyLFxuICAgIEVUSF9TSUdOQVRVUkVfTEVOR1RIOiA0LFxuICAgIEVUSF9VTklUUzogRVRIX1VOSVRTLFxuICAgIEVUSF9CSUdOVU1CRVJfUk9VTkRJTkdfTU9ERTogeyBST1VORElOR19NT0RFOiBCaWdOdW1iZXIuUk9VTkRfRE9XTiB9LFxuICAgIEVUSF9QT0xMSU5HX1RJTUVPVVQ6IDEwMDAvMixcbiAgICBkZWZhdWx0QmxvY2s6ICdsYXRlc3QnLFxuICAgIGRlZmF1bHRBY2NvdW50OiB1bmRlZmluZWRcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9jb25maWcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIHNoYTMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIENyeXB0b0pTID0gcmVxdWlyZSgnY3J5cHRvLWpzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJ2NyeXB0by1qcy9zaGEzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgJiYgdmFsdWUuc3Vic3RyKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigyKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGEzKHZhbHVlLCB7XG4gICAgICAgIG91dHB1dExlbmd0aDogMjU2XG4gICAgfSkudG9TdHJpbmcoKTtcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9zaGEzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvc2hhMy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSB1dGlscy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG4vKipcbiAqIFV0aWxzXG4gKlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnNcbiAqXG4gKiBAY2xhc3MgW3V0aWxzXSB1dGlsc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJy4vc2hhMy5qcycpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG5cbnZhciB1bml0TWFwID0ge1xuICAgICdub2V0aGVyJzogICAgICAnMCcsXG4gICAgJ3dlaSc6ICAgICAgICAgICcxJyxcbiAgICAna3dlaSc6ICAgICAgICAgJzEwMDAnLFxuICAgICdLd2VpJzogICAgICAgICAnMTAwMCcsXG4gICAgJ2JhYmJhZ2UnOiAgICAgICcxMDAwJyxcbiAgICAnZmVtdG9ldGhlcic6ICAgJzEwMDAnLFxuICAgICdtd2VpJzogICAgICAgICAnMTAwMDAwMCcsXG4gICAgJ013ZWknOiAgICAgICAgICcxMDAwMDAwJyxcbiAgICAnbG92ZWxhY2UnOiAgICAgJzEwMDAwMDAnLFxuICAgICdwaWNvZXRoZXInOiAgICAnMTAwMDAwMCcsXG4gICAgJ2d3ZWknOiAgICAgICAgICcxMDAwMDAwMDAwJyxcbiAgICAnR3dlaSc6ICAgICAgICAgJzEwMDAwMDAwMDAnLFxuICAgICdzaGFubm9uJzogICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ25hbm9ldGhlcic6ICAgICcxMDAwMDAwMDAwJyxcbiAgICAnbmFubyc6ICAgICAgICAgJzEwMDAwMDAwMDAnLFxuICAgICdzemFibyc6ICAgICAgICAnMTAwMDAwMDAwMDAwMCcsXG4gICAgJ21pY3JvZXRoZXInOiAgICcxMDAwMDAwMDAwMDAwJyxcbiAgICAnbWljcm8nOiAgICAgICAgJzEwMDAwMDAwMDAwMDAnLFxuICAgICdmaW5uZXknOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ21pbGxpZXRoZXInOiAgICAnMTAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ21pbGxpJzogICAgICAgICAnMTAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2V0aGVyJzogICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAna2V0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdncmFuZCc6ICAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ21ldGhlcic6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnZ2V0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICd0ZXRoZXInOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcGFkTGVmdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFyYWN0ZXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIHBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGFycywgc2lnbikge1xuICAgIHJldHVybiBuZXcgQXJyYXkoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSkuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSArIHN0cmluZztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcGFkUmlnaHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gYmUgcGFkZGVkXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhcmFjdGVycyB0aGF0IHJlc3VsdCBzdHJpbmcgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduLCBieSBkZWZhdWx0IDBcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJpZ2h0IGFsaWduZWQgc3RyaW5nXG4gKi9cbnZhciBwYWRSaWdodCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgcmV0dXJuIHN0cmluZyArIChuZXcgQXJyYXkoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSkuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgdG9VdGY4ID0gZnVuY3Rpb24oaGV4KSB7XG4vLyBGaW5kIHRlcm1pbmF0aW9uXG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwLCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICBpID0gMjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsOyBpKz0yKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmOC5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xudmFyIHRvQXNjaWkgPSBmdW5jdGlvbihoZXgpIHtcbi8vIEZpbmQgdGVybWluYXRpb25cbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDAsIGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgIGkgPSAyO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkrPTIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xudmFyIGZyb21VdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgc3RyID0gdXRmOC5lbmNvZGUoc3RyKTtcbiAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCIweFwiICsgaGV4O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xudmFyIGZyb21Bc2NpaSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBoZXggPSBcIlwiO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgIH1cblxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBmdWxsIGZ1bmN0aW9uL2V2ZW50IG5hbWUgZnJvbSBqc29uIGFiaVxuICpcbiAqIEBtZXRob2QgdHJhbnNmb3JtVG9GdWxsTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGpzb24tYWJpXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZ1bGwgZm5jdGlvbi9ldmVudCBuYW1lXG4gKi9cbnZhciB0cmFuc2Zvcm1Ub0Z1bGxOYW1lID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICBpZiAoanNvbi5uYW1lLmluZGV4T2YoJygnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGpzb24ubmFtZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZU5hbWUgPSBqc29uLmlucHV0cy5tYXAoZnVuY3Rpb24oaSl7cmV0dXJuIGkudHlwZTsgfSkuam9pbigpO1xuICAgIHJldHVybiBqc29uLm5hbWUgKyAnKCcgKyB0eXBlTmFtZSArICcpJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgZGlzcGxheSBuYW1lIG9mIGNvbnRyYWN0IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBleHRyYWN0RGlzcGxheU5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIGZ1bmN0aW9uL2V2ZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBkaXNwbGF5IG5hbWUgZm9yIGZ1bmN0aW9uL2V2ZW50IGVnLiBtdWx0aXBseSh1aW50MjU2KSAtPiBtdWx0aXBseVxuICovXG52YXIgZXh0cmFjdERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gbmFtZS5pbmRleE9mKCcoJyk7XG4gICAgcmV0dXJuIGxlbmd0aCAhPT0gLTEgPyBuYW1lLnN1YnN0cigwLCBsZW5ndGgpIDogbmFtZTtcbn07XG5cbi8vLyBAcmV0dXJucyBvdmVybG9hZGVkIHBhcnQgb2YgZnVuY3Rpb24vZXZlbnQgbmFtZVxudmFyIGV4dHJhY3RUeXBlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8vIFRPRE86IG1ha2UgaXQgaW52dWxuZXJhYmxlXG4gICAgdmFyIGxlbmd0aCA9IG5hbWUuaW5kZXhPZignKCcpO1xuICAgIHJldHVybiBsZW5ndGggIT09IC0xID8gbmFtZS5zdWJzdHIobGVuZ3RoICsgMSwgbmFtZS5sZW5ndGggLSAxIC0gKGxlbmd0aCArIDEpKS5yZXBsYWNlKCcgJywgJycpIDogXCJcIjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIGluIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgdG9EZWNpbWFsXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgdG9EZWNpbWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKHZhbHVlKS50b051bWJlcigpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgZnJvbURlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBmcm9tRGVjaW1hbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBudW1iZXIgPSB0b0JpZ051bWJlcih2YWx1ZSk7XG4gICAgdmFyIHJlc3VsdCA9IG51bWJlci50b1N0cmluZygxNik7XG5cbiAgICByZXR1cm4gbnVtYmVyLmxlc3NUaGFuKDApID8gJy0weCcgKyByZXN1bHQuc3Vic3RyKDEpIDogJzB4JyArIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQXV0byBjb252ZXJ0cyBhbnkgZ2l2ZW4gdmFsdWUgaW50byBpdCdzIGhleCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBBbmQgZXZlbiBzdHJpbmdpZnlzIG9iamVjdHMgYmVmb3JlLlxuICpcbiAqIEBtZXRob2QgdG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ8T2JqZWN0fVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgdG9IZXggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogOCAqL1xuXG4gICAgaWYgKGlzQm9vbGVhbih2YWwpKVxuICAgICAgICByZXR1cm4gZnJvbURlY2ltYWwoK3ZhbCk7XG5cbiAgICBpZiAoaXNCaWdOdW1iZXIodmFsKSlcbiAgICAgICAgcmV0dXJuIGZyb21EZWNpbWFsKHZhbCk7XG5cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmcm9tVXRmOChKU09OLnN0cmluZ2lmeSh2YWwpKTtcblxuICAgIC8vIGlmIGl0cyBhIG5lZ2F0aXZlIG51bWJlciwgcGFzcyBpdCB0aHJvdWdoIGZyb21EZWNpbWFsXG4gICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgaWYgKHZhbC5pbmRleE9mKCctMHgnKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmcm9tRGVjaW1hbCh2YWwpO1xuICAgICAgICBlbHNlIGlmKHZhbC5pbmRleE9mKCcweCcpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgZWxzZSBpZiAoIWlzRmluaXRlKHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUFzY2lpKHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb21EZWNpbWFsKHZhbCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdmFsdWUgb2YgdW5pdCBpbiBXZWlcbiAqXG4gKiBAbWV0aG9kIGdldFZhbHVlT2ZVbml0XG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pdCB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSB2YWx1ZSBvZiB0aGUgdW5pdCAoaW4gV2VpKVxuICogQHRocm93cyBlcnJvciBpZiB0aGUgdW5pdCBpcyBub3QgY29ycmVjdDp3XG4gKi9cbnZhciBnZXRWYWx1ZU9mVW5pdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdW5pdCA9IHVuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiAnZXRoZXInO1xuICAgIHZhciB1bml0VmFsdWUgPSB1bml0TWFwW3VuaXRdO1xuICAgIGlmICh1bml0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBkb2VzblxcJ3QgZXhpc3RzLCBwbGVhc2UgdXNlIHRoZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB1bml0cycgKyBKU09OLnN0cmluZ2lmeSh1bml0TWFwLCBudWxsLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHVuaXRWYWx1ZSwgMTApO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBvZiB3ZWkgYW5kIGNvbnZlcnRzIGl0IHRvIGFueSBvdGhlciBldGhlciB1bml0LlxuICpcbiAqIFBvc3NpYmxlIHVuaXRzIGFyZTpcbiAqICAgU0kgU2hvcnQgICBTSSBGdWxsICAgICAgICBFZmZpZ3kgICAgICAgT3RoZXJcbiAqIC0ga3dlaSAgICAgICBmZW10b2V0aGVyICAgICBiYWJiYWdlXG4gKiAtIG13ZWkgICAgICAgcGljb2V0aGVyICAgICAgbG92ZWxhY2VcbiAqIC0gZ3dlaSAgICAgICBuYW5vZXRoZXIgICAgICBzaGFubm9uICAgICAgbmFub1xuICogLSAtLSAgICAgICAgIG1pY3JvZXRoZXIgICAgIHN6YWJvICAgICAgICBtaWNyb1xuICogLSAtLSAgICAgICAgIG1pbGxpZXRoZXIgICAgIGZpbm5leSAgICAgICBtaWxsaVxuICogLSBldGhlciAgICAgIC0tICAgICAgICAgICAgIC0tXG4gKiAtIGtldGhlciAgICAgICAgICAgICAgICAgICAgLS0gICAgICAgICAgIGdyYW5kXG4gKiAtIG1ldGhlclxuICogLSBnZXRoZXJcbiAqIC0gdGV0aGVyXG4gKlxuICogQG1ldGhvZCBmcm9tV2VpXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG51bWJlciBjYW4gYmUgYSBudW1iZXIsIG51bWJlciBzdHJpbmcgb3IgYSBIRVggb2YgYSBkZWNpbWFsXG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pdCB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSBXaGVuIGdpdmVuIGEgQmlnTnVtYmVyIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiovXG52YXIgZnJvbVdlaSA9IGZ1bmN0aW9uKG51bWJlciwgdW5pdCkge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IHRvQmlnTnVtYmVyKG51bWJlcikuZGl2aWRlZEJ5KGdldFZhbHVlT2ZVbml0KHVuaXQpKTtcblxuICAgIHJldHVybiBpc0JpZ051bWJlcihudW1iZXIpID8gcmV0dXJuVmFsdWUgOiByZXR1cm5WYWx1ZS50b1N0cmluZygxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIGEgdW5pdCBhbmQgY29udmVydHMgaXQgdG8gd2VpLlxuICpcbiAqIFBvc3NpYmxlIHVuaXRzIGFyZTpcbiAqICAgU0kgU2hvcnQgICBTSSBGdWxsICAgICAgICBFZmZpZ3kgICAgICAgT3RoZXJcbiAqIC0ga3dlaSAgICAgICBmZW10b2V0aGVyICAgICBiYWJiYWdlXG4gKiAtIG13ZWkgICAgICAgcGljb2V0aGVyICAgICAgbG92ZWxhY2VcbiAqIC0gZ3dlaSAgICAgICBuYW5vZXRoZXIgICAgICBzaGFubm9uICAgICAgbmFub1xuICogLSAtLSAgICAgICAgIG1pY3JvZXRoZXIgICAgIHN6YWJvICAgICAgICBtaWNyb1xuICogLSAtLSAgICAgICAgIG1pY3JvZXRoZXIgICAgIHN6YWJvICAgICAgICBtaWNyb1xuICogLSAtLSAgICAgICAgIG1pbGxpZXRoZXIgICAgIGZpbm5leSAgICAgICBtaWxsaVxuICogLSBldGhlciAgICAgIC0tICAgICAgICAgICAgIC0tXG4gKiAtIGtldGhlciAgICAgICAgICAgICAgICAgICAgLS0gICAgICAgICAgIGdyYW5kXG4gKiAtIG1ldGhlclxuICogLSBnZXRoZXJcbiAqIC0gdGV0aGVyXG4gKlxuICogQG1ldGhvZCB0b1dlaVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJpZ051bWJlcn0gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgZnJvbSwgZGVmYXVsdCBldGhlclxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gV2hlbiBnaXZlbiBhIEJpZ051bWJlciBvYmplY3QgaXQgcmV0dXJucyBvbmUgYXMgd2VsbCwgb3RoZXJ3aXNlIGEgbnVtYmVyXG4qL1xudmFyIHRvV2VpID0gZnVuY3Rpb24obnVtYmVyLCB1bml0KSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gdG9CaWdOdW1iZXIobnVtYmVyKS50aW1lcyhnZXRWYWx1ZU9mVW5pdCh1bml0KSk7XG5cbiAgICByZXR1cm4gaXNCaWdOdW1iZXIobnVtYmVyKSA/IHJldHVyblZhbHVlIDogcmV0dXJuVmFsdWUudG9TdHJpbmcoMTApO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBpbnB1dCBhbmQgdHJhbnNmb3JtcyBpdCBpbnRvIGFuIGJpZ251bWJlclxuICpcbiAqIEBtZXRob2QgdG9CaWdOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCaWdOdW1iZXJ9IGEgbnVtYmVyLCBzdHJpbmcsIEhFWCBzdHJpbmcgb3IgQmlnTnVtYmVyXG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9IEJpZ051bWJlclxuKi9cbnZhciB0b0JpZ051bWJlciA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6NSAqL1xuICAgIG51bWJlciA9IG51bWJlciB8fCAwO1xuICAgIGlmIChpc0JpZ051bWJlcihudW1iZXIpKVxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuXG4gICAgaWYgKGlzU3RyaW5nKG51bWJlcikgJiYgKG51bWJlci5pbmRleE9mKCcweCcpID09PSAwIHx8IG51bWJlci5pbmRleE9mKCctMHgnKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobnVtYmVyLnJlcGxhY2UoJzB4JywnJyksIDE2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihudW1iZXIudG9TdHJpbmcoMTApLCAxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuZCBpbnB1dCB0cmFuc2Zvcm1zIGl0IGludG8gYmlnbnVtYmVyIGFuZCBpZiBpdCBpcyBuZWdhdGl2ZSB2YWx1ZSwgaW50byB0d28ncyBjb21wbGVtZW50XG4gKlxuICogQG1ldGhvZCB0b1R3b3NDb21wbGVtZW50XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8QmlnTnVtYmVyfVxuICogQHJldHVybiB7QmlnTnVtYmVyfVxuICovXG52YXIgdG9Ud29zQ29tcGxlbWVudCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICB2YXIgYmlnTnVtYmVyID0gdG9CaWdOdW1iZXIobnVtYmVyKS5yb3VuZCgpO1xuICAgIGlmIChiaWdOdW1iZXIubGVzc1RoYW4oMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIsIDE2KS5wbHVzKGJpZ051bWJlcikucGx1cygxKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpZ051bWJlcjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgc3RyaWN0bHkgYW4gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgaXNTdHJpY3RBZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiovXG52YXIgaXNTdHJpY3RBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gL14weFswLTlhLWZdezQwfSQvaS50ZXN0KGFkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc0FkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cbnZhciBpc0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezQwfSQvaS50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGl0IGhhcyB0aGUgYmFzaWMgcmVxdWlyZW1lbnRzIG9mIGFuIGFkZHJlc3NcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoL14oMHgpP1swLTlhLWZdezQwfSQvLnRlc3QoYWRkcmVzcykgfHwgL14oMHgpP1swLTlBLUZdezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhbGwgc21hbGwgY2FwcyBvciBhbGwgYWxsIGNhcHMsIHJldHVybiB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjaGVjayBlYWNoIGNhc2VcbiAgICAgICAgcmV0dXJuIGlzQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc0NoZWNrc3VtQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xudmFyIGlzQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAvLyBDaGVjayBlYWNoIGNhc2VcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKCcweCcsJycpO1xuICAgIHZhciBhZGRyZXNzSGFzaCA9IHNoYTMoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDA7IGkrKyApIHtcbiAgICAgICAgLy8gdGhlIG50aCBsZXR0ZXIgc2hvdWxkIGJlIHVwcGVyY2FzZSBpZiB0aGUgbnRoIGRpZ2l0IG9mIGNhc2VtYXAgaXMgMVxuICAgICAgICBpZiAoKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPiA3ICYmIGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkgfHwgKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPD0gNyAmJiBhZGRyZXNzW2ldLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3NbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLyoqXG4gKiBNYWtlcyBhIGNoZWNrc3VtIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRvQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuKi9cbnZhciB0b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSAndW5kZWZpbmVkJykgcmV0dXJuICcnO1xuXG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCcweCcsJycpO1xuICAgIHZhciBhZGRyZXNzSGFzaCA9IHNoYTMoYWRkcmVzcyk7XG4gICAgdmFyIGNoZWNrc3VtQWRkcmVzcyA9ICcweCc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIC8vIElmIGl0aCBjaGFyYWN0ZXIgaXMgOSB0byBmIHRoZW4gbWFrZSBpdCB1cHBlcmNhc2VcbiAgICAgICAgaWYgKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPiA3KSB7XG4gICAgICAgICAgY2hlY2tzdW1BZGRyZXNzICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3M7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgZ2l2ZW4gc3RyaW5nIHRvIHZhbGlkIDIwIGJ5dGVzLWxlbmd0aCBhZGRyZXMgd2l0aCAweCBwcmVmaXhcbiAqXG4gKiBAbWV0aG9kIHRvQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIGFkZHJlc3NcbiAqL1xudmFyIHRvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgaWYgKGlzU3RyaWN0QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG5cbiAgICBpZiAoL15bMC05YS1mXXs0MH0kLy50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgYWRkcmVzcztcbiAgICB9XG5cbiAgICByZXR1cm4gJzB4JyArIHBhZExlZnQodG9IZXgoYWRkcmVzcykuc3Vic3RyKDIpLCA0MCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgQmlnTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzQmlnTnVtYmVyXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0JpZ051bWJlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgQmlnTnVtYmVyIHx8XG4gICAgICAgIChvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yICYmIG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQmlnTnVtYmVyJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgc3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTdHJpbmcnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBmdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0Z1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIE9iamV0LCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9PSBudWxsICYmICEob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdib29sZWFuJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0FycmF5XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBBcnJheTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIHN0cmluZyBpcyB2YWxpZCBqc29uIG9iamVjdFxuICpcbiAqIEBtZXRob2QgaXNKc29uXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0pzb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhSlNPTi5wYXJzZShzdHIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIEV0aGVyZXVtIGJsb2NrIGhlYWRlciBibG9vbS5cbiAqXG4gKiBAbWV0aG9kIGlzQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggZW5jb2RlZCBibG9vbSBmaWx0ZXJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0Jsb29tID0gZnVuY3Rpb24gKGJsb29tKSB7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NTEyfSQvaS50ZXN0KGJsb29tKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NTEyfSQvLnRlc3QoYmxvb20pIHx8IC9eKDB4KT9bMC05QS1GXXs1MTJ9JC8udGVzdChibG9vbSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIGxvZyB0b3BpYy5cbiAqXG4gKiBAbWV0aG9kIGlzVG9waWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggZW5jb2RlZCB0b3BpY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzVG9waWMgPSBmdW5jdGlvbiAodG9waWMpIHtcbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs2NH0kL2kudGVzdCh0b3BpYykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoL14oMHgpP1swLTlhLWZdezY0fSQvLnRlc3QodG9waWMpIHx8IC9eKDB4KT9bMC05QS1GXXs2NH0kLy50ZXN0KHRvcGljKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFkTGVmdDogcGFkTGVmdCxcbiAgICBwYWRSaWdodDogcGFkUmlnaHQsXG4gICAgdG9IZXg6IHRvSGV4LFxuICAgIHRvRGVjaW1hbDogdG9EZWNpbWFsLFxuICAgIGZyb21EZWNpbWFsOiBmcm9tRGVjaW1hbCxcbiAgICB0b1V0Zjg6IHRvVXRmOCxcbiAgICB0b0FzY2lpOiB0b0FzY2lpLFxuICAgIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgICB0cmFuc2Zvcm1Ub0Z1bGxOYW1lOiB0cmFuc2Zvcm1Ub0Z1bGxOYW1lLFxuICAgIGV4dHJhY3REaXNwbGF5TmFtZTogZXh0cmFjdERpc3BsYXlOYW1lLFxuICAgIGV4dHJhY3RUeXBlTmFtZTogZXh0cmFjdFR5cGVOYW1lLFxuICAgIHRvV2VpOiB0b1dlaSxcbiAgICBmcm9tV2VpOiBmcm9tV2VpLFxuICAgIHRvQmlnTnVtYmVyOiB0b0JpZ051bWJlcixcbiAgICB0b1R3b3NDb21wbGVtZW50OiB0b1R3b3NDb21wbGVtZW50LFxuICAgIHRvQWRkcmVzczogdG9BZGRyZXNzLFxuICAgIGlzQmlnTnVtYmVyOiBpc0JpZ051bWJlcixcbiAgICBpc1N0cmljdEFkZHJlc3M6IGlzU3RyaWN0QWRkcmVzcyxcbiAgICBpc0FkZHJlc3M6IGlzQWRkcmVzcyxcbiAgICBpc0NoZWNrc3VtQWRkcmVzczogaXNDaGVja3N1bUFkZHJlc3MsXG4gICAgdG9DaGVja3N1bUFkZHJlc3M6IHRvQ2hlY2tzdW1BZGRyZXNzLFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzSnNvbjogaXNKc29uLFxuICAgIGlzQmxvb206IGlzQmxvb20sXG4gICAgaXNUb3BpYzogaXNUb3BpYyxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy91dGlscy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInZlcnNpb25cIjpcIjAuMTkuMVwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi92ZXJzaW9uLmpzb25cbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi92ZXJzaW9uLmpzb25cbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgd2ViMy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEplZmZyZXkgV2lsY2tlIDxqZWZmQGV0aGRldi5jb20+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBNYXJpYW4gT2FuY2VhIDxtYXJpYW5AZXRoZGV2LmNvbT5cbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiAgIEdhdiBXb29kIDxnQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIFJlcXVlc3RNYW5hZ2VyID0gcmVxdWlyZSgnLi93ZWIzL3JlcXVlc3RtYW5hZ2VyJyk7XG52YXIgSWJhbiA9IHJlcXVpcmUoJy4vd2ViMy9pYmFuJyk7XG52YXIgRXRoID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvZXRoJyk7XG52YXIgREIgPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9kYicpO1xudmFyIFNoaCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL3NoaCcpO1xudmFyIE5ldCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL25ldCcpO1xudmFyIFBlcnNvbmFsID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvcGVyc29uYWwnKTtcbnZhciBTd2FybSA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL3N3YXJtJyk7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuL3dlYjMvc2V0dGluZ3MnKTtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uLmpzb24nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXRpbHMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi91dGlscy9zaGEzJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi93ZWIzL2V4dGVuZCcpO1xudmFyIEJhdGNoID0gcmVxdWlyZSgnLi93ZWIzL2JhdGNoJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuL3dlYjMvcHJvcGVydHknKTtcbnZhciBIdHRwUHJvdmlkZXIgPSByZXF1aXJlKCcuL3dlYjMvaHR0cHByb3ZpZGVyJyk7XG52YXIgSXBjUHJvdmlkZXIgPSByZXF1aXJlKCcuL3dlYjMvaXBjcHJvdmlkZXInKTtcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxuXG5cbmZ1bmN0aW9uIFdlYjMgKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSBuZXcgUmVxdWVzdE1hbmFnZXIocHJvdmlkZXIpO1xuICAgIHRoaXMuY3VycmVudFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5ldGggPSBuZXcgRXRoKHRoaXMpO1xuICAgIHRoaXMuZGIgPSBuZXcgREIodGhpcyk7XG4gICAgdGhpcy5zaGggPSBuZXcgU2hoKHRoaXMpO1xuICAgIHRoaXMubmV0ID0gbmV3IE5ldCh0aGlzKTtcbiAgICB0aGlzLnBlcnNvbmFsID0gbmV3IFBlcnNvbmFsKHRoaXMpO1xuICAgIHRoaXMuYnp6ID0gbmV3IFN3YXJtKHRoaXMpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICB0aGlzLnZlcnNpb24gPSB7XG4gICAgICAgIGFwaTogdmVyc2lvbi52ZXJzaW9uXG4gICAgfTtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHtcbiAgICAgICAgSHR0cFByb3ZpZGVyOiBIdHRwUHJvdmlkZXIsXG4gICAgICAgIElwY1Byb3ZpZGVyOiBJcGNQcm92aWRlclxuICAgIH07XG4gICAgdGhpcy5fZXh0ZW5kID0gZXh0ZW5kKHRoaXMpO1xuICAgIHRoaXMuX2V4dGVuZCh7XG4gICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMoKVxuICAgIH0pO1xufVxuXG4vLyBleHBvc2UgcHJvdmlkZXJzIG9uIHRoZSBjbGFzc1xuV2ViMy5wcm92aWRlcnMgPSB7XG4gICAgSHR0cFByb3ZpZGVyOiBIdHRwUHJvdmlkZXIsXG4gICAgSXBjUHJvdmlkZXI6IElwY1Byb3ZpZGVyXG59O1xuXG5XZWIzLnByb3RvdHlwZS5zZXRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnNldFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyO1xufTtcblxuV2ViMy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoa2VlcElzU3luY2luZykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnJlc2V0KGtlZXBJc1N5bmNpbmcpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbn07XG5cbldlYjMucHJvdG90eXBlLkJpZ051bWJlciA9IEJpZ051bWJlcjtcbldlYjMucHJvdG90eXBlLnRvSGV4ID0gdXRpbHMudG9IZXg7XG5XZWIzLnByb3RvdHlwZS50b0FzY2lpID0gdXRpbHMudG9Bc2NpaTtcbldlYjMucHJvdG90eXBlLnRvVXRmOCA9IHV0aWxzLnRvVXRmODtcbldlYjMucHJvdG90eXBlLmZyb21Bc2NpaSA9IHV0aWxzLmZyb21Bc2NpaTtcbldlYjMucHJvdG90eXBlLmZyb21VdGY4ID0gdXRpbHMuZnJvbVV0Zjg7XG5XZWIzLnByb3RvdHlwZS50b0RlY2ltYWwgPSB1dGlscy50b0RlY2ltYWw7XG5XZWIzLnByb3RvdHlwZS5mcm9tRGVjaW1hbCA9IHV0aWxzLmZyb21EZWNpbWFsO1xuV2ViMy5wcm90b3R5cGUudG9CaWdOdW1iZXIgPSB1dGlscy50b0JpZ051bWJlcjtcbldlYjMucHJvdG90eXBlLnRvV2VpID0gdXRpbHMudG9XZWk7XG5XZWIzLnByb3RvdHlwZS5mcm9tV2VpID0gdXRpbHMuZnJvbVdlaTtcbldlYjMucHJvdG90eXBlLmlzQWRkcmVzcyA9IHV0aWxzLmlzQWRkcmVzcztcbldlYjMucHJvdG90eXBlLmlzQ2hlY2tzdW1BZGRyZXNzID0gdXRpbHMuaXNDaGVja3N1bUFkZHJlc3M7XG5XZWIzLnByb3RvdHlwZS50b0NoZWNrc3VtQWRkcmVzcyA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzO1xuV2ViMy5wcm90b3R5cGUuaXNJQkFOID0gdXRpbHMuaXNJQkFOO1xuV2ViMy5wcm90b3R5cGUucGFkTGVmdCA9IHV0aWxzLnBhZExlZnQ7XG5XZWIzLnByb3RvdHlwZS5wYWRSaWdodCA9IHV0aWxzLnBhZFJpZ2h0O1xuXG5cbldlYjMucHJvdG90eXBlLnNoYTMgPSBmdW5jdGlvbihzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gJzB4JyArIHNoYTMoc3RyaW5nLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBkaXJlY3QgaWNhcCB0byBhZGRyZXNzXG4gKi9cbldlYjMucHJvdG90eXBlLmZyb21JQ0FQID0gZnVuY3Rpb24gKGljYXApIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKGljYXApO1xuICAgIHJldHVybiBpYmFuLmFkZHJlc3MoKTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi5ub2RlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3dlYjNfY2xpZW50VmVyc2lvbidcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi5uZXR3b3JrJyxcbiAgICAgICAgICAgIGdldHRlcjogJ25ldF92ZXJzaW9uJyxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi5ldGhlcmV1bScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfcHJvdG9jb2xWZXJzaW9uJyxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi53aGlzcGVyJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3NoaF92ZXJzaW9uJyxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuV2ViMy5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50UHJvdmlkZXIgJiYgdGhpcy5jdXJyZW50UHJvdmlkZXIuaXNDb25uZWN0ZWQoKSk7XG59O1xuXG5XZWIzLnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEJhdGNoKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWIzO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGFsbGV2ZW50cy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgc2hhMyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NoYTMnKTtcbnZhciBTb2xpZGl0eUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciB3YXRjaGVzID0gcmVxdWlyZSgnLi9tZXRob2RzL3dhdGNoZXMnKTtcblxudmFyIEFsbFNvbGlkaXR5RXZlbnRzID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBqc29uLCBhZGRyZXNzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSByZXF1ZXN0TWFuYWdlcjtcbiAgICB0aGlzLl9qc29uID0ganNvbjtcbiAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbn07XG5cbkFsbFNvbGlkaXR5RXZlbnRzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIFsnZnJvbUJsb2NrJywgJ3RvQmxvY2snXS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbZl0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJlc3VsdFtmXSA9IGZvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihvcHRpb25zW2ZdKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fYWRkcmVzcztcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5BbGxTb2xpZGl0eUV2ZW50cy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwgJyc7XG4gICAgZGF0YS50b3BpY3MgPSBkYXRhLnRvcGljcyB8fCBbXTtcblxuICAgIHZhciBldmVudFRvcGljID0gZGF0YS50b3BpY3NbMF0uc2xpY2UoMik7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5fanNvbi5maWx0ZXIoZnVuY3Rpb24gKGopIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50VG9waWMgPT09IHNoYTModXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqKSk7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoIW1hdGNoKSB7IC8vIGNhbm5vdCBmaW5kIG1hdGNoaW5nIGV2ZW50P1xuICAgICAgICBjb25zb2xlLndhcm4oJ2Nhbm5vdCBmaW5kIGV2ZW50IGZvciBsb2cnKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50ID0gbmV3IFNvbGlkaXR5RXZlbnQodGhpcy5fcmVxdWVzdE1hbmFnZXIsIG1hdGNoLCB0aGlzLl9hZGRyZXNzKTtcbiAgICByZXR1cm4gZXZlbnQuZGVjb2RlKGRhdGEpO1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUob3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIodGhpcy5fcmVxdWVzdE1hbmFnZXIsIG8sIHdhdGNoZXMuZXRoKCksIGZvcm1hdHRlciwgY2FsbGJhY2spO1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmF0dGFjaFRvQ29udHJhY3QgPSBmdW5jdGlvbiAoY29udHJhY3QpIHtcbiAgICB2YXIgZXhlY3V0ZSA9IHRoaXMuZXhlY3V0ZS5iaW5kKHRoaXMpO1xuICAgIGNvbnRyYWN0LmFsbEV2ZW50cyA9IGV4ZWN1dGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFsbFNvbGlkaXR5RXZlbnRzO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9hbGxldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2FsbGV2ZW50cy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgYmF0Y2guanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEpzb25ycGMgPSByZXF1aXJlKCcuL2pzb25ycGMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG52YXIgQmF0Y2ggPSBmdW5jdGlvbiAod2ViMykge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcbiAgICB0aGlzLnJlcXVlc3RzID0gW107XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gYWRkIGNyZWF0ZSBuZXcgcmVxdWVzdCB0byBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBqc29ucnBjIHJlcXVldCBvYmplY3RcbiAqL1xuQmF0Y2gucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgdGhpcy5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGV4ZWN1dGUgYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgZXhlY3V0ZVxuICovXG5CYXRjaC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVxdWVzdHMgPSB0aGlzLnJlcXVlc3RzO1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIuc2VuZEJhdGNoKHJlcXVlc3RzLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICAgICAgICByZXF1ZXN0cy5tYXAoZnVuY3Rpb24gKHJlcXVlc3QsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tpbmRleF0gfHwge307XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0c1tpbmRleF0uY2FsbGJhY2spIHtcblxuICAgICAgICAgICAgICAgIGlmICghSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdHNbaW5kZXhdLmNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVxdWVzdHNbaW5kZXhdLmNhbGxiYWNrKG51bGwsIChyZXF1ZXN0c1tpbmRleF0uZm9ybWF0ID8gcmVxdWVzdHNbaW5kZXhdLmZvcm1hdChyZXN1bHQucmVzdWx0KSA6IHJlc3VsdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvYmF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2JhdGNoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGNvbnRyYWN0LmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIFNvbGlkaXR5RXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgU29saWRpdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24nKTtcbnZhciBBbGxFdmVudHMgPSByZXF1aXJlKCcuL2FsbGV2ZW50cycpO1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZW5jb2RlIGNvbnN0cnVjdG9yIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlQ29uc3RydWN0b3JQYXJhbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICogQHBhcmFtIHtBcnJheX0gY29uc3RydWN0b3IgcGFyYW1zXG4gKi9cbnZhciBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtcyA9IGZ1bmN0aW9uIChhYmksIHBhcmFtcykge1xuICAgIHJldHVybiBhYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicgJiYganNvbi5pbnB1dHMubGVuZ3RoID09PSBwYXJhbXMubGVuZ3RoO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4ganNvbi5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnR5cGU7XG4gICAgICAgIH0pO1xuICAgIH0pLm1hcChmdW5jdGlvbiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmVuY29kZVBhcmFtcyh0eXBlcywgcGFyYW1zKTtcbiAgICB9KVswXSB8fCAnJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgZnVuY3Rpb25zIHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYWRkRnVuY3Rpb25zVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgYWRkRnVuY3Rpb25zVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIGNvbnRyYWN0LmFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb2xpZGl0eUZ1bmN0aW9uKGNvbnRyYWN0Ll9ldGgsIGpzb24sIGNvbnRyYWN0LmFkZHJlc3MpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgZi5hdHRhY2hUb0NvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgZXZlbnRzIHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYWRkRXZlbnRzVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgYWRkRXZlbnRzVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBldmVudHMgPSBjb250cmFjdC5hYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdldmVudCc7XG4gICAgfSk7XG5cbiAgICB2YXIgQWxsID0gbmV3IEFsbEV2ZW50cyhjb250cmFjdC5fZXRoLl9yZXF1ZXN0TWFuYWdlciwgZXZlbnRzLCBjb250cmFjdC5hZGRyZXNzKTtcbiAgICBBbGwuYXR0YWNoVG9Db250cmFjdChjb250cmFjdCk7XG5cbiAgICBldmVudHMubWFwKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29saWRpdHlFdmVudChjb250cmFjdC5fZXRoLl9yZXF1ZXN0TWFuYWdlciwganNvbiwgY29udHJhY3QuYWRkcmVzcyk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmF0dGFjaFRvQ29udHJhY3QoY29udHJhY3QpO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIGNvbnRyYWN0IGdldHMgcHJvcGVybHkgZGVwbG95ZWQgb24gdGhlIGJsb2NrY2hhaW4uXG4gKlxuICogQG1ldGhvZCBjaGVja0ZvckNvbnRyYWN0QWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRyYWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge1VuZGVmaW5lZH1cbiAqL1xudmFyIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzID0gZnVuY3Rpb24oY29udHJhY3QsIGNhbGxiYWNrKXtcbiAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICBjYWxsYmFja0ZpcmVkID0gZmFsc2U7XG5cbiAgICAvLyB3YWl0IGZvciByZWNlaXB0XG4gICAgdmFyIGZpbHRlciA9IGNvbnRyYWN0Ll9ldGguZmlsdGVyKCdsYXRlc3QnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYgKCFlICYmICFjYWxsYmFja0ZpcmVkKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHdhdGNoaW5nIGFmdGVyIDUwIGJsb2NrcyAodGltZW91dClcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDUwKSB7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXIuc3RvcFdhdGNoaW5nKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0NvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkblxcJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzJykpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCB0cmFuc2FjdGlvbiBjb3VsZG5cXCd0IGJlIGZvdW5kIGFmdGVyIDUwIGJsb2NrcycpO1xuXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjb250cmFjdC5fZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdChjb250cmFjdC50cmFuc2FjdGlvbkhhc2gsIGZ1bmN0aW9uKGUsIHJlY2VpcHQpe1xuICAgICAgICAgICAgICAgICAgICBpZihyZWNlaXB0ICYmICFjYWxsYmFja0ZpcmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0Ll9ldGguZ2V0Q29kZShyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcywgZnVuY3Rpb24oZSwgY29kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2tGaXJlZCB8fCAhY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnN0b3BXYXRjaGluZyhmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0ZpcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvZGUubGVuZ3RoID4gMykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDb250cmFjdCBjb2RlIGRlcGxveWVkIScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0LmFkZHJlc3MgPSByZWNlaXB0LmNvbnRyYWN0QWRkcmVzcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2ggZXZlbnRzIGFuZCBtZXRob2RzIGFnYWluIGFmdGVyIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRnVuY3Rpb25zVG9Db250cmFjdChjb250cmFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50c1RvQ29udHJhY3QoY29udHJhY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgY2FsbGJhY2sgZm9yIHRoZSBzZWNvbmQgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRyYWN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY29udHJhY3QgY29kZSBjb3VsZG5cXCd0IGJlIHN0b3JlZCwgcGxlYXNlIGNoZWNrIHlvdXIgZ2FzIGFtb3VudC4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRyYWN0IGNvZGUgY291bGRuXFwndCBiZSBzdG9yZWQsIHBsZWFzZSBjaGVjayB5b3VyIGdhcyBhbW91bnQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgQ29udHJhY3RGYWN0b3J5IGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBDb250cmFjdEZhY3RvcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKGV0aCwgYWJpKSB7XG4gICAgdGhpcy5ldGggPSBldGg7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgY29udHJhY3Qgb24gYSBibG9ja2NoYWluXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5ld1xuICAgICAqIEBwYXJhbSB7QW55fSBjb250cmFjdCBjb25zdHJ1Y3RvciBwYXJhbTEgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSB7QW55fSBjb250cmFjdCBjb25zdHJ1Y3RvciBwYXJhbTIgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250cmFjdCB0cmFuc2FjdGlvbiBvYmplY3QgKHJlcXVpcmVkKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0NvbnRyYWN0fSByZXR1cm5zIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5uZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDcgKi9cbiAgICAgICAgXG4gICAgICAgIHZhciBjb250cmFjdCA9IG5ldyBDb250cmFjdCh0aGlzLmV0aCwgdGhpcy5hYmkpO1xuXG4gICAgICAgIC8vIHBhcnNlIGFyZ3VtZW50c1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9OyAvLyByZXF1aXJlZCFcbiAgICAgICAgdmFyIGNhbGxiYWNrO1xuXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3QgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh1dGlscy5pc09iamVjdChsYXN0KSAmJiAhdXRpbHMuaXNBcnJheShsYXN0KSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy52YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvckFiaSA9IGFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbi50eXBlID09PSAnY29uc3RydWN0b3InICYmIGpzb24uaW5wdXRzLmxlbmd0aCA9PT0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICB9KVswXSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RvckFiaS5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ5dGVzID0gZW5jb2RlQ29uc3RydWN0b3JQYXJhbXModGhpcy5hYmksIGFyZ3MpO1xuICAgICAgICBvcHRpb25zLmRhdGEgKz0gYnl0ZXM7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBjb250cmFjdCBhZGRyZXNzIGFkbiBjaGVjayBpZiB0aGUgY29kZSB3YXMgZGVwbG95ZWRcbiAgICAgICAgICAgIHRoaXMuZXRoLnNlbmRUcmFuc2FjdGlvbihvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBoYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAgICAgICAgICAgICBjb250cmFjdC50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgY2FsbGJhY2sgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRyYWN0KTtcblxuICAgICAgICAgICAgICAgICAgICBjaGVja0ZvckNvbnRyYWN0QWRkcmVzcyhjb250cmFjdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLmV0aC5zZW5kVHJhbnNhY3Rpb24ob3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgIGNvbnRyYWN0LnRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICBjaGVja0ZvckNvbnRyYWN0QWRkcmVzcyhjb250cmFjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgfTtcblxuICAgIHRoaXMubmV3LmdldERhdGEgPSB0aGlzLmdldERhdGEuYmluZCh0aGlzKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgbmV3IENvbnRyYWN0RmFjdG9yeVxuICpcbiAqIEBtZXRob2QgY29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICogQHJldHVybnMge0NvbnRyYWN0RmFjdG9yeX0gbmV3IGNvbnRyYWN0IGZhY3RvcnlcbiAqL1xuLy92YXIgY29udHJhY3QgPSBmdW5jdGlvbiAoYWJpKSB7XG4gICAgLy9yZXR1cm4gbmV3IENvbnRyYWN0RmFjdG9yeShhYmkpO1xuLy99O1xuXG5cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhY2Nlc3MgdG8gZXhpc3RpbmcgY29udHJhY3Qgb24gYSBibG9ja2NoYWluXG4gKlxuICogQG1ldGhvZCBhdFxuICogQHBhcmFtIHtBZGRyZXNzfSBjb250cmFjdCBhZGRyZXNzIChyZXF1aXJlZClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHtvcHRpb25hbClcbiAqIEByZXR1cm5zIHtDb250cmFjdH0gcmV0dXJucyBjb250cmFjdCBpZiBubyBjYWxsYmFjayB3YXMgcGFzc2VkLFxuICogb3RoZXJ3aXNlIGNhbGxzIGNhbGxiYWNrIGZ1bmN0aW9uIChlcnIsIGNvbnRyYWN0KVxuICovXG5Db250cmFjdEZhY3RvcnkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGFkZHJlc3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHRoaXMuZXRoLCB0aGlzLmFiaSwgYWRkcmVzcyk7XG5cbiAgICAvLyB0aGlzIGZ1bmN0aW9ucyBhcmUgbm90IHBhcnQgb2YgcHJvdG90eXBlLFxuICAgIC8vIGJlY2F1c2Ugd2UgZG9udCB3YW50IHRvIHNwb2lsIHRoZSBpbnRlcmZhY2VcbiAgICBhZGRGdW5jdGlvbnNUb0NvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICBhZGRFdmVudHNUb0NvbnRyYWN0KGNvbnRyYWN0KTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBjb250cmFjdCk7XG4gICAgfVxuICAgIHJldHVybiBjb250cmFjdDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSwgd2hpY2ggaXMgZGF0YSB0byBkZXBsb3kgcGx1cyBjb25zdHJ1Y3RvciBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGdldERhdGFcbiAqL1xuQ29udHJhY3RGYWN0b3J5LnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0ge307IC8vIHJlcXVpcmVkIVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIHZhciBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh1dGlscy5pc09iamVjdChsYXN0KSAmJiAhdXRpbHMuaXNBcnJheShsYXN0KSkge1xuICAgICAgICBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgICB9XG5cbiAgICB2YXIgYnl0ZXMgPSBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtcyh0aGlzLmFiaSwgYXJncyk7XG4gICAgb3B0aW9ucy5kYXRhICs9IGJ5dGVzO1xuXG4gICAgcmV0dXJuIG9wdGlvbnMuZGF0YTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgbmV3IGNvbnRyYWN0IGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBDb250cmFjdFxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKiBAcGFyYW0ge0FkZHJlc3N9IGNvbnRyYWN0IGFkZHJlc3NcbiAqL1xudmFyIENvbnRyYWN0ID0gZnVuY3Rpb24gKGV0aCwgYWJpLCBhZGRyZXNzKSB7XG4gICAgdGhpcy5fZXRoID0gZXRoO1xuICAgIHRoaXMudHJhbnNhY3Rpb25IYXNoID0gbnVsbDtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMuYWJpID0gYWJpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250cmFjdEZhY3Rvcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9jb250cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvY29udHJhY3QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGVycm9ycy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBJbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIFNvbGlkaXR5IGZ1bmN0aW9uJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgaW5wdXQgcGFyYW1ldGVycyB0byBSUEMgbWV0aG9kJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkQ29ubmVjdGlvbjogZnVuY3Rpb24gKGhvc3Qpe1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdDT05ORUNUSU9OIEVSUk9SOiBDb3VsZG5cXCd0IGNvbm5lY3QgdG8gbm9kZSAnKyBob3N0ICsnLicpO1xuICAgIH0sXG4gICAgSW52YWxpZFByb3ZpZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1Byb3ZpZGVyIG5vdCBzZXQgb3IgaW52YWxpZCcpO1xuICAgIH0sXG4gICAgSW52YWxpZFJlc3BvbnNlOiBmdW5jdGlvbiAocmVzdWx0KXtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAhIXJlc3VsdCAmJiAhIXJlc3VsdC5lcnJvciAmJiAhIXJlc3VsdC5lcnJvci5tZXNzYWdlID8gcmVzdWx0LmVycm9yLm1lc3NhZ2UgOiAnSW52YWxpZCBKU09OIFJQQyByZXNwb25zZTogJyArIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSxcbiAgICBDb25uZWN0aW9uVGltZW91dDogZnVuY3Rpb24gKG1zKXtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignQ09OTkVDVElPTiBUSU1FT1VUOiB0aW1lb3V0IG9mICcgKyBtcyArICcgbXMgYWNoaXZlZCcpO1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9lcnJvcnMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Vycm9ycy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgZXZlbnQuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjb2RlciA9IHJlcXVpcmUoJy4uL3NvbGlkaXR5L2NvZGVyJyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHNoYTMgPSByZXF1aXJlKCcuLi91dGlscy9zaGEzJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciB3YXRjaGVzID0gcmVxdWlyZSgnLi9tZXRob2RzL3dhdGNoZXMnKTtcblxuLyoqXG4gKiBUaGlzIHByb3RvdHlwZSBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgZXZlbnQgZmlsdGVyc1xuICovXG52YXIgU29saWRpdHlFdmVudCA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwganNvbiwgYWRkcmVzcykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5fcGFyYW1zID0ganNvbi5pbnB1dHM7XG4gICAgdGhpcy5fbmFtZSA9IHV0aWxzLnRyYW5zZm9ybVRvRnVsbE5hbWUoanNvbik7XG4gICAgdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5fYW5vbnltb3VzID0ganNvbi5hbm9ueW1vdXM7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBmaWx0ZXJlZCBwYXJhbSB0eXBlc1xuICpcbiAqIEBtZXRob2QgdHlwZXNcbiAqIEBwYXJhbSB7Qm9vbH0gZGVjaWRlIGlmIHJldHVybmVkIHR5cGVkIHNob3VsZCBiZSBpbmRleGVkXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgdHlwZXNcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUudHlwZXMgPSBmdW5jdGlvbiAoaW5kZXhlZCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpLmluZGV4ZWQgPT09IGluZGV4ZWQ7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpLnR5cGU7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBldmVudCBkaXNwbGF5IG5hbWVcbiAqXG4gKiBAbWV0aG9kIGRpc3BsYXlOYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGV2ZW50IGRpc3BsYXkgbmFtZVxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZXZlbnQgdHlwZSBuYW1lXG4gKlxuICogQG1ldGhvZCB0eXBlTmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBldmVudCB0eXBlIG5hbWVcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUudHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmV4dHJhY3RUeXBlTmFtZSh0aGlzLl9uYW1lKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGV2ZW50IHNpZ25hdHVyZVxuICpcbiAqIEBtZXRob2Qgc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGV2ZW50IHNpZ25hdHVyZVxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS5zaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNoYTModGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBpbmRleGVkIHBhcmFtcyBhbmQgb3B0aW9ucyB0byBvbmUgZmluYWwgb2JqZWN0XG4gKiBcbiAqIEBtZXRob2QgZW5jb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5kZXhlZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlcnl0aGluZyBjb21iaW5lZCB0b2dldGhlciBhbmQgZW5jb2RlZFxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoaW5kZXhlZCwgb3B0aW9ucykge1xuICAgIGluZGV4ZWQgPSBpbmRleGVkIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIFsnZnJvbUJsb2NrJywgJ3RvQmxvY2snXS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbZl0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJlc3VsdFtmXSA9IGZvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihvcHRpb25zW2ZdKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC50b3BpY3MgPSBbXTtcblxuICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fYWRkcmVzcztcbiAgICBpZiAoIXRoaXMuX2Fub255bW91cykge1xuICAgICAgICByZXN1bHQudG9waWNzLnB1c2goJzB4JyArIHRoaXMuc2lnbmF0dXJlKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleGVkVG9waWNzID0gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS5pbmRleGVkID09PSB0cnVlO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleGVkW2kubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcweCcgKyBjb2Rlci5lbmNvZGVQYXJhbShpLnR5cGUsIHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcweCcgKyBjb2Rlci5lbmNvZGVQYXJhbShpLnR5cGUsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC50b3BpY3MgPSByZXN1bHQudG9waWNzLmNvbmNhdChpbmRleGVkVG9waWNzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBpbmRleGVkIHBhcmFtcyBhbmQgb3B0aW9uc1xuICpcbiAqIEBtZXRob2QgZGVjb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQgb2JqZWN0IHdpdGggZGVjb2RlZCBpbmRleGVkICYmIG5vdCBpbmRleGVkIHBhcmFtc1xuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuIFxuICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCAnJztcbiAgICBkYXRhLnRvcGljcyA9IGRhdGEudG9waWNzIHx8IFtdO1xuXG4gICAgdmFyIGFyZ1RvcGljcyA9IHRoaXMuX2Fub255bW91cyA/IGRhdGEudG9waWNzIDogZGF0YS50b3BpY3Muc2xpY2UoMSk7XG4gICAgdmFyIGluZGV4ZWREYXRhID0gYXJnVG9waWNzLm1hcChmdW5jdGlvbiAodG9waWNzKSB7IHJldHVybiB0b3BpY3Muc2xpY2UoMik7IH0pLmpvaW4oXCJcIik7XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBjb2Rlci5kZWNvZGVQYXJhbXModGhpcy50eXBlcyh0cnVlKSwgaW5kZXhlZERhdGEpOyBcblxuICAgIHZhciBub3RJbmRleGVkRGF0YSA9IGRhdGEuZGF0YS5zbGljZSgyKTtcbiAgICB2YXIgbm90SW5kZXhlZFBhcmFtcyA9IGNvZGVyLmRlY29kZVBhcmFtcyh0aGlzLnR5cGVzKGZhbHNlKSwgbm90SW5kZXhlZERhdGEpO1xuICAgIFxuICAgIHZhciByZXN1bHQgPSBmb3JtYXR0ZXJzLm91dHB1dExvZ0Zvcm1hdHRlcihkYXRhKTtcbiAgICByZXN1bHQuZXZlbnQgPSB0aGlzLmRpc3BsYXlOYW1lKCk7XG4gICAgcmVzdWx0LmFkZHJlc3MgPSBkYXRhLmFkZHJlc3M7XG5cbiAgICByZXN1bHQuYXJncyA9IHRoaXMuX3BhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycmVudCkge1xuICAgICAgICBhY2NbY3VycmVudC5uYW1lXSA9IGN1cnJlbnQuaW5kZXhlZCA/IGluZGV4ZWRQYXJhbXMuc2hpZnQoKSA6IG5vdEluZGV4ZWRQYXJhbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICBkZWxldGUgcmVzdWx0LmRhdGE7XG4gICAgZGVsZXRlIHJlc3VsdC50b3BpY3M7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgbmV3IGZpbHRlciBvYmplY3QgZnJvbSBldmVudFxuICpcbiAqIEBtZXRob2QgZXhlY3V0ZVxuICogQHBhcmFtIHtPYmplY3R9IGluZGV4ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGZpbHRlciBvYmplY3RcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChpbmRleGVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgaW5kZXhlZCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUoaW5kZXhlZCwgb3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIodGhpcy5fcmVxdWVzdE1hbmFnZXIsIG8sIHdhdGNoZXMuZXRoKCksIGZvcm1hdHRlciwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBhdHRhY2ggZXZlbnQgdG8gY29udHJhY3Qgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBhdHRhY2hUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fVxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV4ZWN1dGUgPSB0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lKCk7XG4gICAgaWYgKCFjb250cmFjdFtkaXNwbGF5TmFtZV0pIHtcbiAgICAgICAgY29udHJhY3RbZGlzcGxheU5hbWVdID0gZXhlY3V0ZTtcbiAgICB9XG4gICAgY29udHJhY3RbZGlzcGxheU5hbWVdW3RoaXMudHlwZU5hbWUoKV0gPSB0aGlzLmV4ZWN1dGUuYmluZCh0aGlzLCBjb250cmFjdCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5RXZlbnQ7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9ldmVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscy91dGlscycpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4vbWV0aG9kJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8vIFRPRE86IHJlZmFjdG9yLCBzbyB0aGUgaW5wdXQgcGFyYW1zIGFyZSBub3QgYWx0ZXJlZC5cbi8vIGl0J3MgbmVjZXNzYXJ5IHRvIG1ha2Ugc2FtZSAnZXh0ZW5zaW9uJyB3b3JrIHdpdGggbXVsdGlwbGUgcHJvdmlkZXJzXG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG4gICAgdmFyIGV4ID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXG4gICAgICAgIHZhciBleHRlbmRlZE9iamVjdDtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKCF3ZWIzW2V4dGVuc2lvbi5wcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICB3ZWIzW2V4dGVuc2lvbi5wcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZGVkT2JqZWN0ID0gd2ViM1tleHRlbnNpb24ucHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0ZW5kZWRPYmplY3QgPSB3ZWIzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbi5tZXRob2RzKSB7XG4gICAgICAgICAgICBleHRlbnNpb24ubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3QoZXh0ZW5kZWRPYmplY3QpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcih3ZWIzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb24ucHJvcGVydGllcykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5hdHRhY2hUb09iamVjdChleHRlbmRlZE9iamVjdCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkuc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZXguZm9ybWF0dGVycyA9IGZvcm1hdHRlcnM7IFxuICAgIGV4LnV0aWxzID0gdXRpbHM7XG4gICAgZXguTWV0aG9kID0gTWV0aG9kO1xuICAgIGV4LlByb3BlcnR5ID0gUHJvcGVydHk7XG5cbiAgICByZXR1cm4gZXg7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2V4dGVuZC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXh0ZW5kLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgZmlsdGVyLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiAgIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqICAgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxuLyoqXG4qIENvbnZlcnRzIGEgZ2l2ZW4gdG9waWMgdG8gYSBoZXggc3RyaW5nLCBidXQgYWxzbyBhbGxvd3MgbnVsbCB2YWx1ZXMuXG4qXG4qIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4qIEByZXR1cm4ge1N0cmluZ31cbiovXG52YXIgdG9Ub3BpYyA9IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXG4gICAgaWYodmFsdWUuaW5kZXhPZignMHgnKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHV0aWxzLmZyb21VdGY4KHZhbHVlKTtcbn07XG5cbi8vLyBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uIG9wdGlvbnMgb2JqZWN0LCB0byB2ZXJpZnkgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzICYmIGxhenkgbG9hZCBkeW5hbWljIG9uZXNcbi8vLyBAcGFyYW0gc2hvdWxkIGJlIHN0cmluZyBvciBvYmplY3Rcbi8vLyBAcmV0dXJucyBvcHRpb25zIHN0cmluZyBvciBvYmplY3RcbnZhciBnZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICh1dGlscy5pc1N0cmluZyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIG1ha2Ugc3VyZSB0b3BpY3MsIGdldCBjb252ZXJ0ZWQgdG8gaGV4XG4gICAgb3B0aW9ucy50b3BpY3MgPSBvcHRpb25zLnRvcGljcyB8fCBbXTtcbiAgICBvcHRpb25zLnRvcGljcyA9IG9wdGlvbnMudG9waWNzLm1hcChmdW5jdGlvbih0b3BpYyl7XG4gICAgICAgIHJldHVybiAodXRpbHMuaXNBcnJheSh0b3BpYykpID8gdG9waWMubWFwKHRvVG9waWMpIDogdG9Ub3BpYyh0b3BpYyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3BpY3M6IG9wdGlvbnMudG9waWNzLFxuICAgICAgICBmcm9tOiBvcHRpb25zLmZyb20sXG4gICAgICAgIHRvOiBvcHRpb25zLnRvLFxuICAgICAgICBhZGRyZXNzOiBvcHRpb25zLmFkZHJlc3MsXG4gICAgICAgIGZyb21CbG9jazogZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKG9wdGlvbnMuZnJvbUJsb2NrKSxcbiAgICAgICAgdG9CbG9jazogZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKG9wdGlvbnMudG9CbG9jaylcbiAgICB9O1xufTtcblxuLyoqXG5BZGRzIHRoZSBjYWxsYmFjayBhbmQgc2V0cyB1cCB0aGUgbWV0aG9kcywgdG8gaXRlcmF0ZSBvdmVyIHRoZSByZXN1bHRzLlxuXG5AbWV0aG9kIGdldExvZ3NBdFN0YXJ0XG5AcGFyYW0ge09iamVjdH0gc2VsZlxuQHBhcmFtIHtmdW5jaXRvbn1cbiovXG52YXIgZ2V0TG9nc0F0U3RhcnQgPSBmdW5jdGlvbihzZWxmLCBjYWxsYmFjayl7XG4gICAgLy8gY2FsbCBnZXRGaWx0ZXJMb2dzIGZvciB0aGUgZmlyc3Qgd2F0Y2ggY2FsbGJhY2sgc3RhcnRcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHNlbGYub3B0aW9ucykpIHtcbiAgICAgICAgc2VsZi5nZXQoZnVuY3Rpb24gKGVyciwgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHNlbmQgYWxsIHRoZSByZXNwb25zZXMgdG8gYWxsIHRoZSB3YXRjaGVzIGFnYWluLi4uIGp1c3QgdG8gc2VsZiBvbmVcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih1dGlscy5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuQWRkcyB0aGUgY2FsbGJhY2sgYW5kIHNldHMgdXAgdGhlIG1ldGhvZHMsIHRvIGl0ZXJhdGUgb3ZlciB0aGUgcmVzdWx0cy5cblxuQG1ldGhvZCBwb2xsRmlsdGVyXG5AcGFyYW0ge09iamVjdH0gc2VsZlxuKi9cbnZhciBwb2xsRmlsdGVyID0gZnVuY3Rpb24oc2VsZikge1xuXG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uIChlcnJvciwgbWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHV0aWxzLmlzQXJyYXkobWVzc2FnZXMpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobWVzc2FnZSkgOiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe1xuICAgICAgICBtZXRob2Q6IHNlbGYuaW1wbGVtZW50YXRpb24ucG9sbC5jYWxsLFxuICAgICAgICBwYXJhbXM6IFtzZWxmLmZpbHRlcklkXSxcbiAgICB9LCBzZWxmLmZpbHRlcklkLCBvbk1lc3NhZ2UsIHNlbGYuc3RvcFdhdGNoaW5nLmJpbmQoc2VsZikpO1xuXG59O1xuXG52YXIgRmlsdGVyID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBvcHRpb25zLCBtZXRob2RzLCBmb3JtYXR0ZXIsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0ge307XG4gICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHJlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KGltcGxlbWVudGF0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb247XG4gICAgdGhpcy5maWx0ZXJJZCA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmdldExvZ3NDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBvbGxGaWx0ZXJzID0gW107XG4gICAgdGhpcy5mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbi5uZXdGaWx0ZXIodGhpcy5vcHRpb25zLCBmdW5jdGlvbihlcnJvciwgaWQpe1xuICAgICAgICBpZihlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYil7XG4gICAgICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJJZCA9IGlkO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZ2V0IHBlbmRpbmcgY2FsbGJhY2tzIGFzIGEgY29uc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIG9mIGNhbGxpbmcgZ2V0KCkgd2l0aCBmaWx0ZXJJZCB1bmFzc2lnbmVkLlxuICAgICAgICAgICAgc2VsZi5nZXRMb2dzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKXtcbiAgICAgICAgICAgICAgICBzZWxmLmdldChjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuZ2V0TG9nc0NhbGxiYWNrcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBnZXQgZmlsdGVyIGxvZ3MgZm9yIHRoZSBhbHJlYWR5IGV4aXN0aW5nIHdhdGNoIGNhbGxzXG4gICAgICAgICAgICBzZWxmLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKXtcbiAgICAgICAgICAgICAgICBnZXRMb2dzQXRTdGFydChzZWxmLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKHNlbGYuY2FsbGJhY2tzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcG9sbEZpbHRlcihzZWxmKTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgdG8gd2F0Y2ggaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLndhdGNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cbiAgICBpZih0aGlzLmZpbHRlcklkKSB7XG4gICAgICAgIGdldExvZ3NBdFN0YXJ0KHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgICAgcG9sbEZpbHRlcih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuc3RvcFdhdGNoaW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5zdG9wUG9sbGluZyh0aGlzLmZpbHRlcklkKTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIC8vIHJlbW92ZSBmaWx0ZXIgYXN5bmNcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbXBsZW1lbnRhdGlvbi51bmluc3RhbGxGaWx0ZXIodGhpcy5maWx0ZXJJZCwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkKTtcbiAgICB9XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIGZpbHRlcklkIGlzIG5vdCBzZXQgeWV0LCBjYWxsIGl0IGJhY2tcbiAgICAgICAgICAgIC8vIHdoZW4gbmV3RmlsdGVyKCkgYXNzaWducyBpdC5cbiAgICAgICAgICAgIHRoaXMuZ2V0TG9nc0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24uZ2V0TG9ncyh0aGlzLmZpbHRlcklkLCBmdW5jdGlvbihlcnIsIHJlcyl7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcy5tYXAoZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobG9nKSA6IGxvZztcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsdGVyIElEIEVycm9yOiBmaWx0ZXIoKS5nZXQoKSBjYW5cXCd0IGJlIGNoYWluZWQgc3luY2hyb25vdXMsIHBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIHRoZSBnZXQoKSBtZXRob2QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ3MgPSB0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCk7XG4gICAgICAgIHJldHVybiBsb2dzLm1hcChmdW5jdGlvbiAobG9nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXR0ZXIgPyBzZWxmLmZvcm1hdHRlcihsb2cpIDogbG9nO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2ZpbHRlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmb3JtYXR0ZXJzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbmZpZycpO1xudmFyIEliYW4gPSByZXF1aXJlKCcuL2liYW4nKTtcblxuLyoqXG4gKiBTaG91bGQgdGhlIGZvcm1hdCBvdXRwdXQgdG8gYSBiaWcgbnVtYmVyXG4gKlxuICogQG1ldGhvZCBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ9XG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBvYmplY3RcbiAqL1xudmFyIG91dHB1dEJpZ051bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICByZXR1cm4gdXRpbHMudG9CaWdOdW1iZXIobnVtYmVyKTtcbn07XG5cbnZhciBpc1ByZWRlZmluZWRCbG9ja051bWJlciA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgIHJldHVybiBibG9ja051bWJlciA9PT0gJ2xhdGVzdCcgfHwgYmxvY2tOdW1iZXIgPT09ICdwZW5kaW5nJyB8fCBibG9ja051bWJlciA9PT0gJ2VhcmxpZXN0Jztcbn07XG5cbnZhciBpbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgIGlmIChibG9ja051bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuZGVmYXVsdEJsb2NrO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihibG9ja051bWJlcik7XG59O1xuXG52YXIgaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgIGlmIChibG9ja051bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChpc1ByZWRlZmluZWRCbG9ja051bWJlcihibG9ja051bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMudG9IZXgoYmxvY2tOdW1iZXIpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBpbnB1dCBvZiBhIHRyYW5zYWN0aW9uIGFuZCBjb252ZXJ0cyBhbGwgdmFsdWVzIHRvIEhFWFxuICpcbiAqIEBtZXRob2QgaW5wdXRDYWxsRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gb3B0aW9uc1xuICogQHJldHVybnMgb2JqZWN0XG4qL1xudmFyIGlucHV0Q2FsbEZvcm1hdHRlciA9IGZ1bmN0aW9uIChvcHRpb25zKXtcblxuICAgIG9wdGlvbnMuZnJvbSA9IG9wdGlvbnMuZnJvbSB8fCBjb25maWcuZGVmYXVsdEFjY291bnQ7XG5cbiAgICBpZiAob3B0aW9ucy5mcm9tKSB7XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLmZyb20pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRvKSB7IC8vIGl0IG1pZ2h0IGJlIGNvbnRyYWN0IGNyZWF0aW9uXG4gICAgICAgIG9wdGlvbnMudG8gPSBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy50byk7XG4gICAgfVxuXG4gICAgWydnYXNQcmljZScsICdnYXMnLCAndmFsdWUnLCAnbm9uY2UnXS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgICBvcHRpb25zW2tleV0gPSB1dGlscy5mcm9tRGVjaW1hbChvcHRpb25zW2tleV0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIGlucHV0IG9mIGEgdHJhbnNhY3Rpb24gYW5kIGNvbnZlcnRzIGFsbCB2YWx1ZXMgdG8gSEVYXG4gKlxuICogQG1ldGhvZCBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gb3B0aW9uc1xuICogQHJldHVybnMgb2JqZWN0XG4qL1xudmFyIGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucyl7XG5cbiAgICBvcHRpb25zLmZyb20gPSBvcHRpb25zLmZyb20gfHwgY29uZmlnLmRlZmF1bHRBY2NvdW50O1xuICAgIG9wdGlvbnMuZnJvbSA9IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLmZyb20pO1xuXG4gICAgaWYgKG9wdGlvbnMudG8pIHsgLy8gaXQgbWlnaHQgYmUgY29udHJhY3QgY3JlYXRpb25cbiAgICAgICAgb3B0aW9ucy50byA9IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLnRvKTtcbiAgICB9XG5cbiAgICBbJ2dhc1ByaWNlJywgJ2dhcycsICd2YWx1ZScsICdub25jZSddLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHV0aWxzLmZyb21EZWNpbWFsKG9wdGlvbnNba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgdHJhbnNhY3Rpb24gdG8gaXRzIHByb3BlciB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdHhcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4qL1xudmFyIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyID0gZnVuY3Rpb24gKHR4KXtcbiAgICBpZih0eC5ibG9ja051bWJlciAhPT0gbnVsbClcbiAgICAgICAgdHguYmxvY2tOdW1iZXIgPSB1dGlscy50b0RlY2ltYWwodHguYmxvY2tOdW1iZXIpO1xuICAgIGlmKHR4LnRyYW5zYWN0aW9uSW5kZXggIT09IG51bGwpXG4gICAgICAgIHR4LnRyYW5zYWN0aW9uSW5kZXggPSB1dGlscy50b0RlY2ltYWwodHgudHJhbnNhY3Rpb25JbmRleCk7XG4gICAgdHgubm9uY2UgPSB1dGlscy50b0RlY2ltYWwodHgubm9uY2UpO1xuICAgIHR4LmdhcyA9IHV0aWxzLnRvRGVjaW1hbCh0eC5nYXMpO1xuICAgIHR4Lmdhc1ByaWNlID0gdXRpbHMudG9CaWdOdW1iZXIodHguZ2FzUHJpY2UpO1xuICAgIHR4LnZhbHVlID0gdXRpbHMudG9CaWdOdW1iZXIodHgudmFsdWUpO1xuICAgIHJldHVybiB0eDtcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgdHJhbnNhY3Rpb24gcmVjZWlwdCB0byBpdHMgcHJvcGVyIHZhbHVlc1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjZWlwdFxuICogQHJldHVybnMge09iamVjdH1cbiovXG52YXIgb3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyID0gZnVuY3Rpb24gKHJlY2VpcHQpe1xuICAgIGlmKHJlY2VpcHQuYmxvY2tOdW1iZXIgIT09IG51bGwpXG4gICAgICAgIHJlY2VpcHQuYmxvY2tOdW1iZXIgPSB1dGlscy50b0RlY2ltYWwocmVjZWlwdC5ibG9ja051bWJlcik7XG4gICAgaWYocmVjZWlwdC50cmFuc2FjdGlvbkluZGV4ICE9PSBudWxsKVxuICAgICAgICByZWNlaXB0LnRyYW5zYWN0aW9uSW5kZXggPSB1dGlscy50b0RlY2ltYWwocmVjZWlwdC50cmFuc2FjdGlvbkluZGV4KTtcbiAgICByZWNlaXB0LmN1bXVsYXRpdmVHYXNVc2VkID0gdXRpbHMudG9EZWNpbWFsKHJlY2VpcHQuY3VtdWxhdGl2ZUdhc1VzZWQpO1xuICAgIHJlY2VpcHQuZ2FzVXNlZCA9IHV0aWxzLnRvRGVjaW1hbChyZWNlaXB0Lmdhc1VzZWQpO1xuXG4gICAgaWYodXRpbHMuaXNBcnJheShyZWNlaXB0LmxvZ3MpKSB7XG4gICAgICAgIHJlY2VpcHQubG9ncyA9IHJlY2VpcHQubG9ncy5tYXAoZnVuY3Rpb24obG9nKXtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRMb2dGb3JtYXR0ZXIobG9nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY2VpcHQ7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIGJsb2NrIHRvIGl0cyBwcm9wZXIgdmFsdWVzXG4gKlxuICogQG1ldGhvZCBvdXRwdXRCbG9ja0Zvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IGJsb2NrXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbnZhciBvdXRwdXRCbG9ja0Zvcm1hdHRlciA9IGZ1bmN0aW9uKGJsb2NrKSB7XG5cbiAgICAvLyB0cmFuc2Zvcm0gdG8gbnVtYmVyXG4gICAgYmxvY2suZ2FzTGltaXQgPSB1dGlscy50b0RlY2ltYWwoYmxvY2suZ2FzTGltaXQpO1xuICAgIGJsb2NrLmdhc1VzZWQgPSB1dGlscy50b0RlY2ltYWwoYmxvY2suZ2FzVXNlZCk7XG4gICAgYmxvY2suc2l6ZSA9IHV0aWxzLnRvRGVjaW1hbChibG9jay5zaXplKTtcbiAgICBibG9jay50aW1lc3RhbXAgPSB1dGlscy50b0RlY2ltYWwoYmxvY2sudGltZXN0YW1wKTtcbiAgICBpZihibG9jay5udW1iZXIgIT09IG51bGwpXG4gICAgICAgIGJsb2NrLm51bWJlciA9IHV0aWxzLnRvRGVjaW1hbChibG9jay5udW1iZXIpO1xuXG4gICAgYmxvY2suZGlmZmljdWx0eSA9IHV0aWxzLnRvQmlnTnVtYmVyKGJsb2NrLmRpZmZpY3VsdHkpO1xuICAgIGJsb2NrLnRvdGFsRGlmZmljdWx0eSA9IHV0aWxzLnRvQmlnTnVtYmVyKGJsb2NrLnRvdGFsRGlmZmljdWx0eSk7XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheShibG9jay50cmFuc2FjdGlvbnMpKSB7XG4gICAgICAgIGJsb2NrLnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgaWYoIXV0aWxzLmlzU3RyaW5nKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcihpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSBsb2dcbiAqXG4gKiBAbWV0aG9kIG91dHB1dExvZ0Zvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IGxvZyBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvZ1xuKi9cbnZhciBvdXRwdXRMb2dGb3JtYXR0ZXIgPSBmdW5jdGlvbihsb2cpIHtcbiAgICBpZihsb2cuYmxvY2tOdW1iZXIgIT09IG51bGwpXG4gICAgICAgIGxvZy5ibG9ja051bWJlciA9IHV0aWxzLnRvRGVjaW1hbChsb2cuYmxvY2tOdW1iZXIpO1xuICAgIGlmKGxvZy50cmFuc2FjdGlvbkluZGV4ICE9PSBudWxsKVxuICAgICAgICBsb2cudHJhbnNhY3Rpb25JbmRleCA9IHV0aWxzLnRvRGVjaW1hbChsb2cudHJhbnNhY3Rpb25JbmRleCk7XG4gICAgaWYobG9nLmxvZ0luZGV4ICE9PSBudWxsKVxuICAgICAgICBsb2cubG9nSW5kZXggPSB1dGlscy50b0RlY2ltYWwobG9nLmxvZ0luZGV4KTtcblxuICAgIHJldHVybiBsb2c7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIGlucHV0IG9mIGEgd2hpc3BlciBwb3N0IGFuZCBjb252ZXJ0cyBhbGwgdmFsdWVzIHRvIEhFWFxuICpcbiAqIEBtZXRob2QgaW5wdXRQb3N0Rm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbnZhciBpbnB1dFBvc3RGb3JtYXR0ZXIgPSBmdW5jdGlvbihwb3N0KSB7XG5cbiAgICAvLyBwb3N0LnBheWxvYWQgPSB1dGlscy50b0hleChwb3N0LnBheWxvYWQpO1xuICAgIHBvc3QudHRsID0gdXRpbHMuZnJvbURlY2ltYWwocG9zdC50dGwpO1xuICAgIHBvc3Qud29ya1RvUHJvdmUgPSB1dGlscy5mcm9tRGVjaW1hbChwb3N0LndvcmtUb1Byb3ZlKTtcbiAgICBwb3N0LnByaW9yaXR5ID0gdXRpbHMuZnJvbURlY2ltYWwocG9zdC5wcmlvcml0eSk7XG5cbiAgICAvLyBmYWxsYmFja1xuICAgIGlmICghdXRpbHMuaXNBcnJheShwb3N0LnRvcGljcykpIHtcbiAgICAgICAgcG9zdC50b3BpY3MgPSBwb3N0LnRvcGljcyA/IFtwb3N0LnRvcGljc10gOiBbXTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgdGhlIGZvbGxvd2luZyBvcHRpb25zXG4gICAgcG9zdC50b3BpY3MgPSBwb3N0LnRvcGljcy5tYXAoZnVuY3Rpb24odG9waWMpe1xuICAgICAgICAvLyBjb252ZXJ0IG9ubHkgaWYgbm90IGhleFxuICAgICAgICByZXR1cm4gKHRvcGljLmluZGV4T2YoJzB4JykgPT09IDApID8gdG9waWMgOiB1dGlscy5mcm9tVXRmOCh0b3BpYyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcG9zdDtcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgcmVjZWl2ZWQgcG9zdCBtZXNzYWdlXG4gKlxuICogQG1ldGhvZCBvdXRwdXRQb3N0Rm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbnZhciBvdXRwdXRQb3N0Rm9ybWF0dGVyID0gZnVuY3Rpb24ocG9zdCl7XG5cbiAgICBwb3N0LmV4cGlyeSA9IHV0aWxzLnRvRGVjaW1hbChwb3N0LmV4cGlyeSk7XG4gICAgcG9zdC5zZW50ID0gdXRpbHMudG9EZWNpbWFsKHBvc3Quc2VudCk7XG4gICAgcG9zdC50dGwgPSB1dGlscy50b0RlY2ltYWwocG9zdC50dGwpO1xuICAgIHBvc3Qud29ya1Byb3ZlZCA9IHV0aWxzLnRvRGVjaW1hbChwb3N0LndvcmtQcm92ZWQpO1xuICAgIC8vIHBvc3QucGF5bG9hZFJhdyA9IHBvc3QucGF5bG9hZDtcbiAgICAvLyBwb3N0LnBheWxvYWQgPSB1dGlscy50b0FzY2lpKHBvc3QucGF5bG9hZCk7XG5cbiAgICAvLyBpZiAodXRpbHMuaXNKc29uKHBvc3QucGF5bG9hZCkpIHtcbiAgICAvLyAgICAgcG9zdC5wYXlsb2FkID0gSlNPTi5wYXJzZShwb3N0LnBheWxvYWQpO1xuICAgIC8vIH1cblxuICAgIC8vIGZvcm1hdCB0aGUgZm9sbG93aW5nIG9wdGlvbnNcbiAgICBpZiAoIXBvc3QudG9waWNzKSB7XG4gICAgICAgIHBvc3QudG9waWNzID0gW107XG4gICAgfVxuICAgIHBvc3QudG9waWNzID0gcG9zdC50b3BpY3MubWFwKGZ1bmN0aW9uKHRvcGljKXtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRvQXNjaWkodG9waWMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvc3Q7XG59O1xuXG52YXIgaW5wdXRBZGRyZXNzRm9ybWF0dGVyID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKGFkZHJlc3MpO1xuICAgIGlmIChpYmFuLmlzVmFsaWQoKSAmJiBpYmFuLmlzRGlyZWN0KCkpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBpYmFuLmFkZHJlc3MoKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzU3RyaWN0QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gJzB4JyArIGFkZHJlc3M7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZGRyZXNzJyk7XG59O1xuXG5cbnZhciBvdXRwdXRTeW5jaW5nRm9ybWF0dGVyID0gZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgICByZXN1bHQuc3RhcnRpbmdCbG9jayA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQuc3RhcnRpbmdCbG9jayk7XG4gICAgcmVzdWx0LmN1cnJlbnRCbG9jayA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQuY3VycmVudEJsb2NrKTtcbiAgICByZXN1bHQuaGlnaGVzdEJsb2NrID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5oaWdoZXN0QmxvY2spO1xuICAgIGlmIChyZXN1bHQua25vd25TdGF0ZXMpIHtcbiAgICAgICAgcmVzdWx0Lmtub3duU3RhdGVzID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5rbm93blN0YXRlcyk7XG4gICAgICAgIHJlc3VsdC5wdWxsZWRTdGF0ZXMgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0LnB1bGxlZFN0YXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyOiBpbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcixcbiAgICBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyOiBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLFxuICAgIGlucHV0Q2FsbEZvcm1hdHRlcjogaW5wdXRDYWxsRm9ybWF0dGVyLFxuICAgIGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXI6IGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIsXG4gICAgaW5wdXRBZGRyZXNzRm9ybWF0dGVyOiBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIsXG4gICAgaW5wdXRQb3N0Rm9ybWF0dGVyOiBpbnB1dFBvc3RGb3JtYXR0ZXIsXG4gICAgb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyOiBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXIsXG4gICAgb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXI6IG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLFxuICAgIG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlcjogb3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyLFxuICAgIG91dHB1dEJsb2NrRm9ybWF0dGVyOiBvdXRwdXRCbG9ja0Zvcm1hdHRlcixcbiAgICBvdXRwdXRMb2dGb3JtYXR0ZXI6IG91dHB1dExvZ0Zvcm1hdHRlcixcbiAgICBvdXRwdXRQb3N0Rm9ybWF0dGVyOiBvdXRwdXRQb3N0Rm9ybWF0dGVyLFxuICAgIG91dHB1dFN5bmNpbmdGb3JtYXR0ZXI6IG91dHB1dFN5bmNpbmdGb3JtYXR0ZXJcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Zvcm1hdHRlcnMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Zvcm1hdHRlcnMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZnVuY3Rpb24uanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGNvZGVyID0gcmVxdWlyZSgnLi4vc29saWRpdHkvY29kZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NoYTMnKTtcblxuLyoqXG4gKiBUaGlzIHByb3RvdHlwZSBzaG91bGQgYmUgdXNlZCB0byBjYWxsL3NlbmRUcmFuc2FjdGlvbiB0byBzb2xpZGl0eSBmdW5jdGlvbnNcbiAqL1xudmFyIFNvbGlkaXR5RnVuY3Rpb24gPSBmdW5jdGlvbiAoZXRoLCBqc29uLCBhZGRyZXNzKSB7XG4gICAgdGhpcy5fZXRoID0gZXRoO1xuICAgIHRoaXMuX2lucHV0VHlwZXMgPSBqc29uLmlucHV0cy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkudHlwZTtcbiAgICB9KTtcbiAgICB0aGlzLl9vdXRwdXRUeXBlcyA9IGpzb24ub3V0cHV0cy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkudHlwZTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb25zdGFudCA9IGpzb24uY29uc3RhbnQ7XG4gICAgdGhpcy5fcGF5YWJsZSA9IGpzb24ucGF5YWJsZTtcbiAgICB0aGlzLl9uYW1lID0gdXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqc29uKTtcbiAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbn07XG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gYXJncy5wb3AoKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4dHJhY3REZWZhdWx0QmxvY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoICYmICF1dGlscy5pc09iamVjdChhcmdzW2FyZ3MubGVuZ3RoIC0xXSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIoYXJncy5wb3AoKSk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgY29ycmVjdFxuICpcbiAqIEBtZXRob2QgdmFsaWRhdGVBcmdzXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBub3RcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRBcmdzID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgIC8vIGZpbHRlciB0aGUgb3B0aW9ucyBvYmplY3QgYnV0IG5vdCBhcmd1bWVudHMgdGhhdCBhcmUgYXJyYXlzXG4gICAgICByZXR1cm4gISh1dGlscy5pc09iamVjdChhKSA9PT0gdHJ1ZSAmJiB1dGlscy5pc0FycmF5KGEpID09PSBmYWxzZSk7XG4gICAgfSk7XG4gICAgaWYgKGlucHV0QXJncy5sZW5ndGggIT09IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3MoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBwYXlsb2FkIGZyb20gYXJndW1lbnRzXG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IHNvbGlkaXR5IGZ1bmN0aW9uIHBhcmFtc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbmFsIHBheWxvYWQgb3B0aW9uc1xuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS50b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gdGhpcy5faW5wdXRUeXBlcy5sZW5ndGggJiYgdXRpbHMuaXNPYmplY3QoYXJnc1thcmdzLmxlbmd0aCAtMV0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVBcmdzKGFyZ3MpO1xuICAgIG9wdGlvbnMudG8gPSB0aGlzLl9hZGRyZXNzO1xuICAgIG9wdGlvbnMuZGF0YSA9ICcweCcgKyB0aGlzLnNpZ25hdHVyZSgpICsgY29kZXIuZW5jb2RlUGFyYW1zKHRoaXMuX2lucHV0VHlwZXMsIGFyZ3MpO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKlxuICogQG1ldGhvZCBzaWduYXR1cmVcbiAqIEByZXR1cm4ge1N0cmluZ30gZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnNpZ25hdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2hhMyh0aGlzLl9uYW1lKS5zbGljZSgwLCA4KTtcbn07XG5cblxuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudW5wYWNrT3V0cHV0ID0gZnVuY3Rpb24gKG91dHB1dCkge1xuICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvdXRwdXQgPSBvdXRwdXQubGVuZ3RoID49IDIgPyBvdXRwdXQuc2xpY2UoMikgOiBvdXRwdXQ7XG4gICAgdmFyIHJlc3VsdCA9IGNvZGVyLmRlY29kZVBhcmFtcyh0aGlzLl9vdXRwdXRUeXBlcywgb3V0cHV0KTtcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBjb250cmFjdCBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGNhbGxcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBDb250cmFjdCBmdW5jdGlvbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IElmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIHRoZSBjb250cmFjdCBmdW5jdGlvblxuICogICBjYWxsIHdpbGwgYmUgYXN5bmNocm9ub3VzLCBhbmQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgcGFzc2VkIHRoZVxuICogICBlcnJvciBhbmQgcmVzdWx0LlxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXQgYnl0ZXNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChhKSB7cmV0dXJuIGEgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIGRlZmF1bHRCbG9jayA9IHRoaXMuZXh0cmFjdERlZmF1bHRCbG9jayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9ldGguY2FsbChwYXlsb2FkLCBkZWZhdWx0QmxvY2spO1xuICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tPdXRwdXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fZXRoLmNhbGwocGF5bG9hZCwgZGVmYXVsdEJsb2NrLCBmdW5jdGlvbiAoZXJyb3IsIG91dHB1dCkge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG5cbiAgICAgICAgdmFyIHVucGFja2VkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVucGFja2VkID0gc2VsZi51bnBhY2tPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHVucGFja2VkKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc2VuZFRyYW5zYWN0aW9uIHRvIHNvbGlkaXR5IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBzZW5kVHJhbnNhY3Rpb25cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtyZXR1cm4gYSAhPT0gdW5kZWZpbmVkOyB9KTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgaWYgKHBheWxvYWQudmFsdWUgPiAwICYmICF0aGlzLl9wYXlhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2V0aC5zZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlc3RpbWF0ZUdhcyBvZiBzb2xpZGl0eSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgZXN0aW1hdGVHYXNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZXN0aW1hdGVHYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy50b1BheWxvYWQoYXJncyk7XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGguZXN0aW1hdGVHYXMocGF5bG9hZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXRoLmVzdGltYXRlR2FzKHBheWxvYWQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBlbmNvZGVkIGRhdGEgb2YgdGhlIGNhbGxcbiAqXG4gKiBAbWV0aG9kIGdldERhdGFcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGVuY29kZWQgZGF0YVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZ1bmN0aW9uIGRpc3BsYXkgbmFtZVxuICpcbiAqIEBtZXRob2QgZGlzcGxheU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZGlzcGxheSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZnVuY3Rpb24gdHlwZSBuYW1lXG4gKlxuICogQG1ldGhvZCB0eXBlTmFtZVxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5leHRyYWN0VHlwZU5hbWUodGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHJwYyByZXF1ZXN0cyBmcm9tIHNvbGlkaXR5IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnVucGFja091dHB1dC5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLl9jb25zdGFudCA/ICdldGhfY2FsbCcgOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcGFyYW1zOiBbcGF5bG9hZF0sXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgfTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBleGVjdXRlIGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBleGVjdXRlXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uID0gIXRoaXMuX2NvbnN0YW50O1xuXG4gICAgLy8gc2VuZCB0cmFuc2FjdGlvblxuICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgLy8gY2FsbFxuICAgIHJldHVybiB0aGlzLmNhbGwuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gYXR0YWNoIGZ1bmN0aW9uIHRvIGNvbnRyYWN0XG4gKlxuICogQG1ldGhvZCBhdHRhY2hUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV4ZWN1dGUgPSB0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmNhbGwgPSB0aGlzLmNhbGwuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLnNlbmRUcmFuc2FjdGlvbiA9IHRoaXMuc2VuZFRyYW5zYWN0aW9uLmJpbmQodGhpcyk7XG4gICAgZXhlY3V0ZS5lc3RpbWF0ZUdhcyA9IHRoaXMuZXN0aW1hdGVHYXMuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmdldERhdGEgPSB0aGlzLmdldERhdGEuYmluZCh0aGlzKTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lKCk7XG4gICAgaWYgKCFjb250cmFjdFtkaXNwbGF5TmFtZV0pIHtcbiAgICAgICAgY29udHJhY3RbZGlzcGxheU5hbWVdID0gZXhlY3V0ZTtcbiAgICB9XG4gICAgY29udHJhY3RbZGlzcGxheU5hbWVdW3RoaXMudHlwZU5hbWUoKV0gPSBleGVjdXRlOyAvLyBjaXJjdWxhciEhISFcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlGdW5jdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Z1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGh0dHBwcm92aWRlci5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBNYXJpYW4gT2FuY2VhIDxtYXJpYW5AZXRoZGV2LmNvbT5cbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuLy8gd29ya2Fyb3VuZCB0byB1c2UgaHR0cHByb3ZpZGVyIGluIGRpZmZlcmVudCBlbnZzXG5cbi8vIGJyb3dzZXJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICBYTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDsgLy8ganNoaW50IGlnbm9yZTogbGluZVxuLy8gbm9kZVxufSBlbHNlIHtcbiAgICBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0JykuWE1MSHR0cFJlcXVlc3Q7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcbn1cblxudmFyIFhIUjIgPSByZXF1aXJlKCd4aHIyJyk7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcblxuLyoqXG4gKiBIdHRwUHJvdmlkZXIgc2hvdWxkIGJlIHVzZWQgdG8gc2VuZCBycGMgY2FsbHMgb3ZlciBodHRwXG4gKi9cbnZhciBIdHRwUHJvdmlkZXIgPSBmdW5jdGlvbiAoaG9zdCwgdGltZW91dCkge1xuICAgIHRoaXMuaG9zdCA9IGhvc3QgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODU0NSc7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCAwO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHByZXBhcmUgbmV3IFhNTEh0dHBSZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBwcmVwYXJlUmVxdWVzdFxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlIGlmIHJlcXVlc3Qgc2hvdWxkIGJlIGFzeW5jXG4gKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH0gb2JqZWN0XG4gKi9cbkh0dHBQcm92aWRlci5wcm90b3R5cGUucHJlcGFyZVJlcXVlc3QgPSBmdW5jdGlvbiAoYXN5bmMpIHtcbiAgICB2YXIgcmVxdWVzdDtcblxuICAgIGlmIChhc3luYykge1xuICAgICAgcmVxdWVzdCA9IG5ldyBYSFIyKCk7XG4gICAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfWVsc2Uge1xuICAgICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub3BlbignUE9TVCcsIHRoaXMuaG9zdCwgYXN5bmMpO1xuICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHJldHVybiByZXF1ZXN0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3luYyByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMucHJlcGFyZVJlcXVlc3QoZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5zZW5kKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcblxuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gbWFrZSBhc3luYyByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kQXN5bmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gZW5kIHdpdGggKGVyciwgcmVzdWx0KVxuICovXG5IdHRwUHJvdmlkZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5wcmVwYXJlUmVxdWVzdCh0cnVlKTtcblxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgJiYgcmVxdWVzdC50aW1lb3V0ICE9PSAxKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhlcnJvcnMuQ29ubmVjdGlvblRpbWVvdXQodGhpcy50aW1lb3V0KSk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3Quc2VuZChKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHRyaWVzIHRvIG1ha2UgSHR0cCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBpc0Nvbm5lY3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHJlcXVlc3QgaGF2ZW4ndCBmYWlsZWQuIE90aGVyd2lzZSBmYWxzZVxuICovXG5IdHRwUHJvdmlkZXIucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGlkOiA5OTk5OTk5OTk5LFxuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2Q6ICduZXRfbGlzdGVuaW5nJyxcbiAgICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdHRwUHJvdmlkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9odHRwcHJvdmlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2h0dHBwcm92aWRlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgaWJhbi5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5cbnZhciBwYWRMZWZ0ID0gZnVuY3Rpb24gKHN0cmluZywgYnl0ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gc3RyaW5nO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgYnl0ZXMgKiAyKSB7XG4gICAgICAgIHJlc3VsdCA9ICcwJyArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJlcGFyZSBhbiBJQkFOIGZvciBtb2QgOTcgY29tcHV0YXRpb24gYnkgbW92aW5nIHRoZSBmaXJzdCA0IGNoYXJzIHRvIHRoZSBlbmQgYW5kIHRyYW5zZm9ybWluZyB0aGUgbGV0dGVycyB0b1xuICogbnVtYmVycyAoQSA9IDEwLCBCID0gMTEsIC4uLiwgWiA9IDM1KSwgYXMgc3BlY2lmaWVkIGluIElTTzEzNjE2LlxuICpcbiAqIEBtZXRob2QgaXNvMTM2MTZQcmVwYXJlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhbiB0aGUgSUJBTlxuICogQHJldHVybnMge1N0cmluZ30gdGhlIHByZXBhcmVkIElCQU5cbiAqL1xudmFyIGlzbzEzNjE2UHJlcGFyZSA9IGZ1bmN0aW9uIChpYmFuKSB7XG4gICAgdmFyIEEgPSAnQScuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgWiA9ICdaJy5jaGFyQ29kZUF0KDApO1xuXG4gICAgaWJhbiA9IGliYW4udG9VcHBlckNhc2UoKTtcbiAgICBpYmFuID0gaWJhbi5zdWJzdHIoNCkgKyBpYmFuLnN1YnN0cigwLDQpO1xuXG4gICAgcmV0dXJuIGliYW4uc3BsaXQoJycpLm1hcChmdW5jdGlvbihuKXtcbiAgICAgICAgdmFyIGNvZGUgPSBuLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChjb2RlID49IEEgJiYgY29kZSA8PSBaKXtcbiAgICAgICAgICAgIC8vIEEgPSAxMCwgQiA9IDExLCAuLi4gWiA9IDM1XG4gICAgICAgICAgICByZXR1cm4gY29kZSAtIEEgKyAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgfSkuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIE1PRCA5NyAxMCBvZiB0aGUgcGFzc2VkIElCQU4gYXMgc3BlY2lmaWVkIGluIElTTzcwNjQuXG4gKlxuICogQG1ldGhvZCBtb2Q5NzEwXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhblxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xudmFyIG1vZDk3MTAgPSBmdW5jdGlvbiAoaWJhbikge1xuICAgIHZhciByZW1haW5kZXIgPSBpYmFuLFxuICAgICAgICBibG9jaztcblxuICAgIHdoaWxlIChyZW1haW5kZXIubGVuZ3RoID4gMil7XG4gICAgICAgIGJsb2NrID0gcmVtYWluZGVyLnNsaWNlKDAsIDkpO1xuICAgICAgICByZW1haW5kZXIgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyByZW1haW5kZXIuc2xpY2UoYmxvY2subGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VJbnQocmVtYWluZGVyLCAxMCkgJSA5Nztcbn07XG5cbi8qKlxuICogVGhpcyBwcm90b3R5cGUgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGliYW4gb2JqZWN0IGZyb20gaWJhbiBjb3JyZWN0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuXG4gKi9cbnZhciBJYmFuID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICB0aGlzLl9pYmFuID0gaWJhbjtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGliYW4gb2JqZWN0IGZyb20gZXRoZXJldW0gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgZnJvbUFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtJYmFufSB0aGUgSUJBTiBvYmplY3RcbiAqL1xuSWJhbi5mcm9tQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgdmFyIGFzQm4gPSBuZXcgQmlnTnVtYmVyKGFkZHJlc3MsIDE2KTtcbiAgICB2YXIgYmFzZTM2ID0gYXNCbi50b1N0cmluZygzNik7XG4gICAgdmFyIHBhZGRlZCA9IHBhZExlZnQoYmFzZTM2LCAxNSk7XG4gICAgcmV0dXJuIEliYW4uZnJvbUJiYW4ocGFkZGVkLnRvVXBwZXJDYXNlKCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXNzZWQgQkJBTiB0byBhbiBJQkFOIGZvciB0aGlzIGNvdW50cnkgc3BlY2lmaWNhdGlvbi5cbiAqIFBsZWFzZSBub3RlIHRoYXQgPGk+XCJnZW5lcmF0aW9uIG9mIHRoZSBJQkFOIHNoYWxsIGJlIHRoZSBleGNsdXNpdmUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGJhbmsvYnJhbmNoIHNlcnZpY2luZyB0aGUgYWNjb3VudFwiPC9pPi5cbiAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIHByZWZlcnJlZCBhbGdvcml0aG0gZGVzY3JpYmVkIGluIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9CYW5rX0FjY291bnRfTnVtYmVyI0dlbmVyYXRpbmdfSUJBTl9jaGVja19kaWdpdHNcbiAqXG4gKiBAbWV0aG9kIGZyb21CYmFuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmJhbiB0aGUgQkJBTiB0byBjb252ZXJ0IHRvIElCQU5cbiAqIEByZXR1cm5zIHtJYmFufSB0aGUgSUJBTiBvYmplY3RcbiAqL1xuSWJhbi5mcm9tQmJhbiA9IGZ1bmN0aW9uIChiYmFuKSB7XG4gICAgdmFyIGNvdW50cnlDb2RlID0gJ1hFJztcblxuICAgIHZhciByZW1haW5kZXIgPSBtb2Q5NzEwKGlzbzEzNjE2UHJlcGFyZShjb3VudHJ5Q29kZSArICcwMCcgKyBiYmFuKSk7XG4gICAgdmFyIGNoZWNrRGlnaXQgPSAoJzAnICsgKDk4IC0gcmVtYWluZGVyKSkuc2xpY2UoLTIpO1xuXG4gICAgcmV0dXJuIG5ldyBJYmFuKGNvdW50cnlDb2RlICsgY2hlY2tEaWdpdCArIGJiYW4pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgSUJBTiBvYmplY3QgZm9yIGdpdmVuIGluc3RpdHV0aW9uIGFuZCBpZGVudGlmaWVyXG4gKlxuICogQG1ldGhvZCBjcmVhdGVJbmRpcmVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMsIHJlcXVpcmVkIG9wdGlvbnMgYXJlIFwiaW5zdGl0dXRpb25cIiBhbmQgXCJpZGVudGlmaWVyXCJcbiAqIEByZXR1cm4ge0liYW59IHRoZSBJQkFOIG9iamVjdFxuICovXG5JYmFuLmNyZWF0ZUluZGlyZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gSWJhbi5mcm9tQmJhbignRVRIJyArIG9wdGlvbnMuaW5zdGl0dXRpb24gKyBvcHRpb25zLmlkZW50aWZpZXIpO1xufTtcblxuLyoqXG4gKiBUaG9zIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjaGVjayBpZiBnaXZlbiBzdHJpbmcgaXMgdmFsaWQgaWJhbiBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuIHN0cmluZ1xuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyB2YWxpZCBJQkFOXG4gKi9cbkliYW4uaXNWYWxpZCA9IGZ1bmN0aW9uIChpYmFuKSB7XG4gICAgdmFyIGkgPSBuZXcgSWJhbihpYmFuKTtcbiAgICByZXR1cm4gaS5pc1ZhbGlkKCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgaWJhbiBpcyBjb3JyZWN0XG4gKlxuICogQG1ldGhvZCBpc1ZhbGlkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbkliYW4ucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIC9eWEVbMC05XXsyfShFVEhbMC05QS1aXXsxM318WzAtOUEtWl17MzAsMzF9KSQvLnRlc3QodGhpcy5faWJhbikgJiZcbiAgICAgICAgbW9kOTcxMChpc28xMzYxNlByZXBhcmUodGhpcy5faWJhbikpID09PSAxO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIGliYW4gbnVtYmVyIGlzIGRpcmVjdFxuICpcbiAqIEBtZXRob2QgaXNEaXJlY3RcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuSWJhbi5wcm90b3R5cGUuaXNEaXJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2liYW4ubGVuZ3RoID09PSAzNCB8fCB0aGlzLl9pYmFuLmxlbmd0aCA9PT0gMzU7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgaWJhbiBudW1iZXIgaWYgaW5kaXJlY3RcbiAqXG4gKiBAbWV0aG9kIGlzSW5kaXJlY3RcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuSWJhbi5wcm90b3R5cGUuaXNJbmRpcmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWJhbi5sZW5ndGggPT09IDIwO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBpYmFuIGNoZWNrc3VtXG4gKiBVc2VzIHRoZSBtb2QtOTctMTAgY2hlY2tzdW1taW5nIHByb3RvY29sIChJU08vSUVDIDcwNjQ6MjAwMylcbiAqXG4gKiBAbWV0aG9kIGNoZWNrc3VtXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBjaGVja3N1bVxuICovXG5JYmFuLnByb3RvdHlwZS5jaGVja3N1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWJhbi5zdWJzdHIoMiwgMik7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGluc3RpdHV0aW9uIGlkZW50aWZpZXJcbiAqIGVnLiBYUkVHXG4gKlxuICogQG1ldGhvZCBpbnN0aXR1dGlvblxuICogQHJldHVybnMge1N0cmluZ30gaW5zdGl0dXRpb24gaWRlbnRpZmllclxuICovXG5JYmFuLnByb3RvdHlwZS5pbnN0aXR1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luZGlyZWN0KCkgPyB0aGlzLl9pYmFuLnN1YnN0cig3LCA0KSA6ICcnO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBjbGllbnQgaWRlbnRpZmllciB3aXRoaW4gaW5zdGl0dXRpb25cbiAqIGVnLiBHQVZPRllPUktcbiAqXG4gKiBAbWV0aG9kIGNsaWVudFxuICogQHJldHVybnMge1N0cmluZ30gY2xpZW50IGlkZW50aWZpZXJcbiAqL1xuSWJhbi5wcm90b3R5cGUuY2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5kaXJlY3QoKSA/IHRoaXMuX2liYW4uc3Vic3RyKDExKSA6ICcnO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBjbGllbnQgZGlyZWN0IGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGNsaWVudCBkaXJlY3QgYWRkcmVzc1xuICovXG5JYmFuLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzRGlyZWN0KCkpIHtcbiAgICAgICAgdmFyIGJhc2UzNiA9IHRoaXMuX2liYW4uc3Vic3RyKDQpO1xuICAgICAgICB2YXIgYXNCbiA9IG5ldyBCaWdOdW1iZXIoYmFzZTM2LCAzNik7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGFzQm4udG9TdHJpbmcoMTYpLCAyMCk7XG4gICAgfSBcblxuICAgIHJldHVybiAnJztcbn07XG5cbkliYW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pYmFuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJYmFuO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9pYmFuLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9pYmFuLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgaXBjcHJvdmlkZXIuanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbnZhciBJcGNQcm92aWRlciA9IGZ1bmN0aW9uIChwYXRoLCBuZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIFxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldC5jb25uZWN0KHtwYXRoOiB0aGlzLnBhdGh9KTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICAgICAgY29uc29sZS5lcnJvcignSVBDIENvbm5lY3Rpb24gRXJyb3InLCBlKTtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTsgXG5cblxuICAgIC8vIExJU1RFTiBGT1IgQ09OTkVDVElPTiBSRVNQT05TRVNcbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDYgKi9cblxuICAgICAgICBfdGhpcy5fcGFyc2VSZXNwb25zZShkYXRhLnRvU3RyaW5nKCkpLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0KXtcblxuICAgICAgICAgICAgdmFyIGlkID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBpZCB3aGljaCBtYXRjaGVzIHRoZSByZXR1cm5lZCBpZFxuICAgICAgICAgICAgaWYodXRpbHMuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24obG9hZCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2xvYWQuaWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBsb2FkLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3VsdC5pZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmKF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXShudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG5XaWxsIHBhcnNlIHRoZSByZXNwb25zZSBhbmQgbWFrZSBhbiBhcnJheSBvdXQgb2YgaXQuXG5cbkBtZXRob2QgX3BhcnNlUmVzcG9uc2VcbkBwYXJhbSB7U3RyaW5nfSBkYXRhXG4qL1xuSXBjUHJvdmlkZXIucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHJldHVyblZhbHVlcyA9IFtdO1xuICAgIFxuICAgIC8vIERFLUNIVU5LRVJcbiAgICB2YXIgZGVjaHVua2VkRGF0YSA9IGRhdGFcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcey9nLCd9fC0tfHsnKSAvLyB9e1xuICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFxbXFx7L2csJ31dfC0tfFt7JykgLy8gfV1be1xuICAgICAgICAucmVwbGFjZSgvXFx9W1xcblxccl0/XFxbXFx7L2csJ318LS18W3snKSAvLyB9W3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcey9nLCd9XXwtLXx7JykgLy8gfV17XG4gICAgICAgIC5zcGxpdCgnfC0tfCcpO1xuXG4gICAgZGVjaHVua2VkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpe1xuXG4gICAgICAgIC8vIHByZXBlbmQgdGhlIGxhc3QgY2h1bmtcbiAgICAgICAgaWYoX3RoaXMubGFzdENodW5rKVxuICAgICAgICAgICAgZGF0YSA9IF90aGlzLmxhc3RDaHVuayArIGRhdGE7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVuayA9IGRhdGE7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRpbWVvdXQgdG8gY2FuY2VsIGFsbCByZXF1ZXN0c1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMubGFzdENodW5rVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGltZW91dCgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgICAgICB9LCAxMDAwICogMTUpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYW5jZWwgdGltZW91dCBhbmQgc2V0IGNodW5rIHRvIG51bGxcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBudWxsO1xuXG4gICAgICAgIGlmKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVyblZhbHVlcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufTtcblxuXG4vKipcbkdldCB0aGUgYWRkcyBhIGNhbGxiYWNrIHRvIHRoZSByZXNwb25zZUNhbGxiYWNrcyBvYmplY3QsXG53aGljaCB3aWxsIGJlIGNhbGxlZCBpZiBhIHJlc3BvbnNlIG1hdGNoaW5nIHRoZSByZXNwb25zZSBJZCB3aWxsIGFycml2ZS5cblxuQG1ldGhvZCBfYWRkUmVzcG9uc2VDYWxsYmFja1xuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fYWRkUmVzcG9uc2VDYWxsYmFjayA9IGZ1bmN0aW9uKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gcGF5bG9hZC5pZCB8fCBwYXlsb2FkWzBdLmlkO1xuICAgIHZhciBtZXRob2QgPSBwYXlsb2FkLm1ldGhvZCB8fCBwYXlsb2FkWzBdLm1ldGhvZDtcblxuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0ubWV0aG9kID0gbWV0aG9kO1xufTtcblxuLyoqXG5UaW1lb3V0IGFsbCByZXF1ZXN0cyB3aGVuIHRoZSBlbmQvZXJyb3IgZXZlbnQgaXMgZmlyZWRcblxuQG1ldGhvZCBfdGltZW91dFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fdGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIga2V5IGluIHRoaXMucmVzcG9uc2VDYWxsYmFja3MpIHtcbiAgICAgICAgaWYodGhpcy5yZXNwb25zZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3Nba2V5XShlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24oJ29uIElQQycpKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpcyBzdGlsbCB2YWxpZC5cblxuQG1ldGhvZCBpc0Nvbm5lY3RlZFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyB0cnkgcmVjb25uZWN0LCB3aGVuIGNvbm5lY3Rpb24gaXMgZ29uZVxuICAgIGlmKCFfdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICBfdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IF90aGlzLnBhdGh9KTtcblxuICAgIHJldHVybiAhIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZTtcbn07XG5cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcblxuICAgIGlmKHRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB0cnkgcmVjb25uZWN0LCB3aGVuIGNvbm5lY3Rpb24gaXMgZ29uZVxuICAgICAgICBpZighdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IHRoaXMucGF0aH0pO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jb25uZWN0aW9uLndyaXRlU3luYyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShkYXRhKTsgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgdHJpZWQgdG8gc2VuZCBcIicrIHBheWxvYWQubWV0aG9kICsnXCIgc3luY2hyb25vdXNseS4gU3luY2hyb25vdXMgcmVxdWVzdHMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQQyBwcm92aWRlci4nKTtcbiAgICB9XG59O1xuXG5JcGNQcm92aWRlci5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24gKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICBpZighdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCh7cGF0aDogdGhpcy5wYXRofSk7XG5cblxuICAgIHRoaXMuY29ubmVjdGlvbi53cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgdGhpcy5fYWRkUmVzcG9uc2VDYWxsYmFjayhwYXlsb2FkLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElwY1Byb3ZpZGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9pcGNwcm92aWRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaXBjcHJvdmlkZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBqc29ucnBjLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiAgIEFhcm9uIEt1bWF2aXMgPGFhcm9uQGt1bWF2aXMubWU+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuLy8gSW5pdGlhbGl6ZSBKc29ucnBjIGFzIGEgc2ltcGxlIG9iamVjdCB3aXRoIHV0aWxpdHkgZnVuY3Rpb25zLlxudmFyIEpzb25ycGMgPSB7XG4gICAgbWVzc2FnZUlkOiAwXG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gdmFsaWQganNvbiBjcmVhdGUgcGF5bG9hZCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHRvUGF5bG9hZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIG9mIGpzb25ycGMgY2FsbCwgcmVxdWlyZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcywgYW4gYXJyYXkgb2YgbWV0aG9kIHBhcmFtcywgb3B0aW9uYWxcbiAqIEByZXR1cm5zIHtPYmplY3R9IHZhbGlkIGpzb25ycGMgcGF5bG9hZCBvYmplY3RcbiAqL1xuSnNvbnJwYy50b1BheWxvYWQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICBpZiAoIW1ldGhvZClcbiAgICAgICAgY29uc29sZS5lcnJvcignanNvbnJwYyBtZXRob2Qgc2hvdWxkIGJlIHNwZWNpZmllZCEnKTtcblxuICAgIC8vIGFkdmFuY2UgbWVzc2FnZSBJRFxuICAgIEpzb25ycGMubWVzc2FnZUlkKys7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgaWQ6IEpzb25ycGMubWVzc2FnZUlkLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMgfHwgW11cbiAgICB9O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIGpzb25ycGMgcmVzcG9uc2UgaXMgdmFsaWRcbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRSZXNwb25zZVxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiByZXNwb25zZSBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbkpzb25ycGMuaXNWYWxpZFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVzcG9uc2UpID8gcmVzcG9uc2UuZXZlcnkodmFsaWRhdGVTaW5nbGVNZXNzYWdlKSA6IHZhbGlkYXRlU2luZ2xlTWVzc2FnZShyZXNwb25zZSk7XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVNpbmdsZU1lc3NhZ2UobWVzc2FnZSl7XG4gICAgICByZXR1cm4gISFtZXNzYWdlICYmXG4gICAgICAgICFtZXNzYWdlLmVycm9yICYmXG4gICAgICAgIG1lc3NhZ2UuanNvbnJwYyA9PT0gJzIuMCcgJiZcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2UuaWQgPT09ICdudW1iZXInICYmXG4gICAgICAgIG1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQ7IC8vIG9ubHkgdW5kZWZpbmVkIGlzIG5vdCB2YWxpZCBqc29uIG9iamVjdFxuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgYmF0Y2ggcGF5bG9hZCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHRvQmF0Y2hQYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlcywgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIG1ldGhvZCAocmVxdWlyZWQpIGFuZCBwYXJhbXMgKG9wdGlvbmFsKSBmaWVsZHNcbiAqIEByZXR1cm5zIHtBcnJheX0gYmF0Y2ggcGF5bG9hZFxuICovXG5Kc29ucnBjLnRvQmF0Y2hQYXlsb2FkID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzLm1hcChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gSnNvbnJwYy50b1BheWxvYWQobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2UucGFyYW1zKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnJwYztcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvanNvbnJwYy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvanNvbnJwYy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBtZXRob2QuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG52YXIgTWV0aG9kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5jYWxsID0gb3B0aW9ucy5jYWxsO1xuICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwgMDtcbiAgICB0aGlzLmlucHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLm91dHB1dEZvcm1hdHRlciA9IG9wdGlvbnMub3V0cHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBudWxsO1xufTtcblxuTWV0aG9kLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChybSkge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBybTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIG5hbWUgb2YgdGhlIGpzb25ycGMgbWV0aG9kIGJhc2VkIG9uIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgZ2V0Q2FsbFxuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG5hbWUgb2YganNvbnJwYyBtZXRob2RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5nZXRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNGdW5jdGlvbih0aGlzLmNhbGwpID8gdGhpcy5jYWxsKGFyZ3MpIDogdGhpcy5jYWxsO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBleHRyYWN0IGNhbGxiYWNrIGZyb20gYXJyYXkgb2YgYXJndW1lbnRzLiBNb2RpZmllcyBpbnB1dCBwYXJhbVxuICpcbiAqIEBtZXRob2QgZXh0cmFjdENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufE51bGx9IGNhbGxiYWNrLCBpZiBleGlzdHNcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MucG9wKCk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgY29ycmVjdFxuICogXG4gKiBAbWV0aG9kIHZhbGlkYXRlQXJnc1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgbm90XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IHRoaXMucGFyYW1zKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IGlucHV0IGFyZ3Mgb2YgbWV0aG9kXG4gKiBcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5mb3JtYXRJbnB1dCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKCF0aGlzLmlucHV0Rm9ybWF0dGVyKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyLm1hcChmdW5jdGlvbiAoZm9ybWF0dGVyLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyID8gZm9ybWF0dGVyKGFyZ3NbaW5kZXhdKSA6IGFyZ3NbaW5kZXhdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBvdXRwdXQocmVzdWx0KSBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciAmJiByZXN1bHQgPyB0aGlzLm91dHB1dEZvcm1hdHRlcihyZXN1bHQpIDogcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIHBheWxvYWQgZnJvbSBnaXZlbiBpbnB1dCBhcmdzXG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBjYWxsID0gdGhpcy5nZXRDYWxsKGFyZ3MpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmZvcm1hdElucHV0KGFyZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVBcmdzKHBhcmFtcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2Q6IGNhbGwsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xufTtcblxuTWV0aG9kLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuYnVpbGRDYWxsKCk7XG4gICAgZnVuYy5jYWxsID0gdGhpcy5jYWxsOyAvLyBUT0RPISEhIHRoYXQncyB1Z2x5LiBmaWx0ZXIuanMgdXNlcyBpdFxuICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLnNwbGl0KCcuJyk7XG4gICAgaWYgKG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICBvYmpbbmFtZVswXV0gPSBvYmpbbmFtZVswXV0gfHwge307XG4gICAgICAgIG9ialtuYW1lWzBdXVtuYW1lWzFdXSA9IGZ1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gZnVuYzsgXG4gICAgfVxufTtcblxuTWV0aG9kLnByb3RvdHlwZS5idWlsZENhbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcztcbiAgICB2YXIgc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBtZXRob2QudG9QYXlsb2FkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAocGF5bG9hZC5jYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5yZXF1ZXN0TWFuYWdlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsYmFjayhlcnIsIG1ldGhvZC5mb3JtYXRPdXRwdXQocmVzdWx0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kLmZvcm1hdE91dHB1dChtZXRob2QucmVxdWVzdE1hbmFnZXIuc2VuZChwYXlsb2FkKSk7XG4gICAgfTtcbiAgICBzZW5kLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gc2VuZDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgcHVyZSBKU09OUlBDIHJlcXVlc3Qgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFxuICogQHBhcmFtIHsuLi59IHBhcmFtc1xuICogQHJldHVybiB7T2JqZWN0fSBqc29ucnBjIHJlcXVlc3RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcGF5bG9hZC5mb3JtYXQgPSB0aGlzLmZvcm1hdE91dHB1dC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXRob2Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGRiLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xuXG52YXIgREIgPSBmdW5jdGlvbiAod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7IFxuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcih3ZWIzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG59O1xuXG52YXIgbWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHV0U3RyaW5nID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdwdXRTdHJpbmcnLFxuICAgICAgICBjYWxsOiAnZGJfcHV0U3RyaW5nJyxcbiAgICAgICAgcGFyYW1zOiAzXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0U3RyaW5nID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRTdHJpbmcnLFxuICAgICAgICBjYWxsOiAnZGJfZ2V0U3RyaW5nJyxcbiAgICAgICAgcGFyYW1zOiAyXG4gICAgfSk7XG5cbiAgICB2YXIgcHV0SGV4ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdwdXRIZXgnLFxuICAgICAgICBjYWxsOiAnZGJfcHV0SGV4JyxcbiAgICAgICAgcGFyYW1zOiAzXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0SGV4ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRIZXgnLFxuICAgICAgICBjYWxsOiAnZGJfZ2V0SGV4JyxcbiAgICAgICAgcGFyYW1zOiAyXG4gICAgfSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBwdXRTdHJpbmcsIGdldFN0cmluZywgcHV0SGV4LCBnZXRIZXhcbiAgICBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEQjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZGIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZGIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZXRoLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuLi9mb3JtYXR0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlscycpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcbnZhciBjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgQ29udHJhY3QgPSByZXF1aXJlKCcuLi9jb250cmFjdCcpO1xudmFyIHdhdGNoZXMgPSByZXF1aXJlKCcuL3dhdGNoZXMnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuLi9maWx0ZXInKTtcbnZhciBJc1N5bmNpbmcgPSByZXF1aXJlKCcuLi9zeW5jaW5nJyk7XG52YXIgbmFtZXJlZyA9IHJlcXVpcmUoJy4uL25hbWVyZWcnKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnLi4vaWJhbicpO1xudmFyIHRyYW5zZmVyID0gcmVxdWlyZSgnLi4vdHJhbnNmZXInKTtcblxudmFyIGJsb2NrQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiA6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIjtcbn07XG5cbnZhciB0cmFuc2FjdGlvbkZyb21CbG9ja0NhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JyA6ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgnO1xufTtcblxudmFyIHVuY2xlQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgnIDogJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc7XG59O1xuXG52YXIgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50Q2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnIDogJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic7XG59O1xuXG52YXIgdW5jbGVDb3VudENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tIYXNoJyA6ICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInO1xufTtcblxuZnVuY3Rpb24gRXRoKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcblxuICAgIHByb3BlcnRpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgcC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG5cblxuICAgIHRoaXMuaWJhbiA9IEliYW47XG4gICAgdGhpcy5zZW5kSUJBTlRyYW5zYWN0aW9uID0gdHJhbnNmZXIuYmluZChudWxsLCB0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0aC5wcm90b3R5cGUsICdkZWZhdWx0QmxvY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjLmRlZmF1bHRCbG9jaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBjLmRlZmF1bHRCbG9jayA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0aC5wcm90b3R5cGUsICdkZWZhdWx0QWNjb3VudCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGMuZGVmYXVsdEFjY291bnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgYy5kZWZhdWx0QWNjb3VudCA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdldEJhbGFuY2UgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldEJhbGFuY2UnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldEJhbGFuY2UnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0U3RvcmFnZUF0ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRTdG9yYWdlQXQnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCB1dGlscy50b0hleCwgZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBnZXRDb2RlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRDb2RlJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRDb2RlJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCbG9jaycsXG4gICAgICAgIGNhbGw6IGJsb2NrQ2FsbCxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciwgZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gISF2YWw7IH1dLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRVbmNsZSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VW5jbGUnLFxuICAgICAgICBjYWxsOiB1bmNsZUNhbGwsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsIHV0aWxzLnRvSGV4XSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyLFxuXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0Q29tcGlsZXJzID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRDb21waWxlcnMnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldENvbXBpbGVycycsXG4gICAgICAgIHBhcmFtczogMFxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgY2FsbDogZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50Q2FsbCxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0QmxvY2tVbmNsZUNvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCbG9ja1VuY2xlQ291bnQnLFxuICAgICAgICBjYWxsOiB1bmNsZUNvdW50Q2FsbCxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb25Gcm9tQmxvY2sgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uRnJvbUJsb2NrJyxcbiAgICAgICAgY2FsbDogdHJhbnNhY3Rpb25Gcm9tQmxvY2tDYWxsLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCB1dGlscy50b0hleF0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgIH0pO1xuXG4gICAgdmFyIGdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRUcmFuc2FjdGlvbkNvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIHNlbmRSYXdUcmFuc2FjdGlvbiA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgICAgICAgY2FsbDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzZW5kVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBzaWduVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2lnblRyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBzaWduID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduJyxcbiAgICAgICAgY2FsbDogJ2V0aF9zaWduJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGNhbGwgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2NhbGwnLFxuICAgICAgICBjYWxsOiAnZXRoX2NhbGwnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgZXN0aW1hdGVHYXMgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2VzdGltYXRlR2FzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0Q2FsbEZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgY29tcGlsZVNvbGlkaXR5ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLnNvbGlkaXR5JyxcbiAgICAgICAgY2FsbDogJ2V0aF9jb21waWxlU29saWRpdHknLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBjb21waWxlTExMID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLmxsbCcsXG4gICAgICAgIGNhbGw6ICdldGhfY29tcGlsZUxMTCcsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIGNvbXBpbGVTZXJwZW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLnNlcnBlbnQnLFxuICAgICAgICBjYWxsOiAnZXRoX2NvbXBpbGVTZXJwZW50JyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgc3VibWl0V29yayA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3VibWl0V29yaycsXG4gICAgICAgIGNhbGw6ICdldGhfc3VibWl0V29yaycsXG4gICAgICAgIHBhcmFtczogM1xuICAgIH0pO1xuXG4gICAgdmFyIGdldFdvcmsgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFdvcmsnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldFdvcmsnLFxuICAgICAgICBwYXJhbXM6IDBcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGdldEJhbGFuY2UsXG4gICAgICAgIGdldFN0b3JhZ2VBdCxcbiAgICAgICAgZ2V0Q29kZSxcbiAgICAgICAgZ2V0QmxvY2ssXG4gICAgICAgIGdldFVuY2xlLFxuICAgICAgICBnZXRDb21waWxlcnMsXG4gICAgICAgIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCxcbiAgICAgICAgZ2V0QmxvY2tVbmNsZUNvdW50LFxuICAgICAgICBnZXRUcmFuc2FjdGlvbixcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb25Gcm9tQmxvY2ssXG4gICAgICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdCxcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb25Db3VudCxcbiAgICAgICAgY2FsbCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHNlbmRSYXdUcmFuc2FjdGlvbixcbiAgICAgICAgc2lnblRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgIHNpZ24sXG4gICAgICAgIGNvbXBpbGVTb2xpZGl0eSxcbiAgICAgICAgY29tcGlsZUxMTCxcbiAgICAgICAgY29tcGlsZVNlcnBlbnQsXG4gICAgICAgIHN1Ym1pdFdvcmssXG4gICAgICAgIGdldFdvcmtcbiAgICBdO1xufTtcblxuXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2NvaW5iYXNlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9jb2luYmFzZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbWluaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9taW5pbmcnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc2hyYXRlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9oYXNocmF0ZScsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdzeW5jaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9zeW5jaW5nJyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2dhc1ByaWNlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9nYXNQcmljZScsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2FjY291bnRzJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9hY2NvdW50cydcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnYmxvY2tOdW1iZXInLFxuICAgICAgICAgICAgZ2V0dGVyOiAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3Byb3RvY29sVmVyc2lvbicsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfcHJvdG9jb2xWZXJzaW9uJ1xuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5FdGgucHJvdG90eXBlLmNvbnRyYWN0ID0gZnVuY3Rpb24gKGFiaSkge1xuICAgIHZhciBmYWN0b3J5ID0gbmV3IENvbnRyYWN0KHRoaXMsIGFiaSk7XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5FdGgucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmaWwsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcih0aGlzLl9yZXF1ZXN0TWFuYWdlciwgZmlsLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXJzLm91dHB1dExvZ0Zvcm1hdHRlciwgY2FsbGJhY2ssIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjayk7XG59O1xuXG5FdGgucHJvdG90eXBlLm5hbWVyZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QobmFtZXJlZy5nbG9iYWwuYWJpKS5hdChuYW1lcmVnLmdsb2JhbC5hZGRyZXNzKTtcbn07XG5cbkV0aC5wcm90b3R5cGUuaWNhcE5hbWVyZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QobmFtZXJlZy5pY2FwLmFiaSkuYXQobmFtZXJlZy5pY2FwLmFkZHJlc3MpO1xufTtcblxuRXRoLnByb3RvdHlwZS5pc1N5bmNpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IElzU3luY2luZyh0aGlzLl9yZXF1ZXN0TWFuYWdlciwgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2V0aC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9ldGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBldGguanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlscycpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcblxudmFyIE5ldCA9IGZ1bmN0aW9uICh3ZWIzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHByb3BlcnRpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHsgXG4gICAgICAgIHAuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIHAuc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufTtcblxuLy8vIEByZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyB3ZWIzLmV0aCBhcGkgcHJvcGVydGllc1xudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdsaXN0ZW5pbmcnLFxuICAgICAgICAgICAgZ2V0dGVyOiAnbmV0X2xpc3RlbmluZydcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAncGVlckNvdW50JyxcbiAgICAgICAgICAgIGdldHRlcjogJ25ldF9wZWVyQ291bnQnLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL25ldC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9uZXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZXRoLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi4vZm9ybWF0dGVycycpO1xuXG5mdW5jdGlvbiBQZXJzb25hbCh3ZWIzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIG1ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG5cbiAgICBwcm9wZXJ0aWVzKCkuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgIHAuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIHAuc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufVxuXG52YXIgbWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3QWNjb3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnbmV3QWNjb3VudCcsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9uZXdBY2NvdW50JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgaW1wb3J0UmF3S2V5ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdpbXBvcnRSYXdLZXknLFxuXHRcdGNhbGw6ICdwZXJzb25hbF9pbXBvcnRSYXdLZXknLFxuXHRcdHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgdmFyIHNpZ24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NpZ24nLFxuXHRcdGNhbGw6ICdwZXJzb25hbF9zaWduJyxcblx0XHRwYXJhbXM6IDMsXG5cdFx0aW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBlY1JlY292ZXIgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2VjUmVjb3ZlcicsXG5cdFx0Y2FsbDogJ3BlcnNvbmFsX2VjUmVjb3ZlcicsXG5cdFx0cGFyYW1zOiAyXG4gICAgfSk7XG5cbiAgICB2YXIgdW5sb2NrQWNjb3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAndW5sb2NrQWNjb3VudCcsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF91bmxvY2tBY2NvdW50JyxcbiAgICAgICAgcGFyYW1zOiAzLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIHNlbmRUcmFuc2FjdGlvbiA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgY2FsbDogJ3BlcnNvbmFsX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgbG9ja0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2xvY2tBY2NvdW50JyxcbiAgICAgICAgY2FsbDogJ3BlcnNvbmFsX2xvY2tBY2NvdW50JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyXVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3QWNjb3VudCxcbiAgICAgICAgaW1wb3J0UmF3S2V5LFxuICAgICAgICB1bmxvY2tBY2NvdW50LFxuICAgICAgICBlY1JlY292ZXIsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHNlbmRUcmFuc2FjdGlvbixcbiAgICAgICAgbG9ja0FjY291bnRcbiAgICBdO1xufTtcblxudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdsaXN0QWNjb3VudHMnLFxuICAgICAgICAgICAgZ2V0dGVyOiAncGVyc29uYWxfbGlzdEFjY291bnRzJ1xuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGVyc29uYWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3BlcnNvbmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3BlcnNvbmFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgc2hoLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuLi9mb3JtYXR0ZXJzJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyJyk7XG52YXIgd2F0Y2hlcyA9IHJlcXVpcmUoJy4vd2F0Y2hlcycpO1xuXG52YXIgU2hoID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7IFxuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG59O1xuXG5TaGgucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmaWwsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIodGhpcy5fcmVxdWVzdE1hbmFnZXIsIGZpbCwgd2F0Y2hlcy5zaGgoKSwgZm9ybWF0dGVycy5vdXRwdXRQb3N0Rm9ybWF0dGVyLCBjYWxsYmFjayk7XG59O1xuXG52YXIgbWV0aG9kcyA9IGZ1bmN0aW9uICgpIHsgXG5cbiAgICB2YXIgcG9zdCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncG9zdCcsIFxuICAgICAgICBjYWxsOiAnc2hoX3Bvc3QnLCBcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRQb3N0Rm9ybWF0dGVyXVxuICAgIH0pO1xuXG4gICAgdmFyIG5ld0lkZW50aXR5ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICduZXdJZGVudGl0eScsXG4gICAgICAgIGNhbGw6ICdzaGhfbmV3SWRlbnRpdHknLFxuICAgICAgICBwYXJhbXM6IDBcbiAgICB9KTtcblxuICAgIHZhciBoYXNJZGVudGl0eSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnaGFzSWRlbnRpdHknLFxuICAgICAgICBjYWxsOiAnc2hoX2hhc0lkZW50aXR5JyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgbmV3R3JvdXAgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0dyb3VwJyxcbiAgICAgICAgY2FsbDogJ3NoaF9uZXdHcm91cCcsXG4gICAgICAgIHBhcmFtczogMFxuICAgIH0pO1xuXG4gICAgdmFyIGFkZFRvR3JvdXAgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2FkZFRvR3JvdXAnLFxuICAgICAgICBjYWxsOiAnc2hoX2FkZFRvR3JvdXAnLFxuICAgICAgICBwYXJhbXM6IDBcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHBvc3QsXG4gICAgICAgIG5ld0lkZW50aXR5LFxuICAgICAgICBoYXNJZGVudGl0eSxcbiAgICAgICAgbmV3R3JvdXAsXG4gICAgICAgIGFkZFRvR3JvdXBcbiAgICBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaGg7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvc2hoLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3NoaC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBienouanNcbiAqIEBhdXRob3IgQWxleCBCZXJlZ3N6YXN6aSA8YWxleEBydGZzLmh1PlxuICogQGRhdGUgMjAxNlxuICpcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2Jsb2Ivc3dhcm0vaW50ZXJuYWwvd2ViM2V4dC93ZWIzZXh0LmdvI0wzM1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZSgnLi4vbWV0aG9kJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuLi9wcm9wZXJ0eScpO1xuXG5mdW5jdGlvbiBTd2FybSh3ZWIzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIG1ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG5cbiAgICBwcm9wZXJ0aWVzKCkuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgIHAuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIHAuc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufVxuXG52YXIgbWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmxvY2tOZXR3b3JrUmVhZCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnYmxvY2tOZXR3b3JrUmVhZCcsXG4gICAgICAgIGNhbGw6ICdienpfYmxvY2tOZXR3b3JrUmVhZCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIHN5bmNFbmFibGVkID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzeW5jRW5hYmxlZCcsXG4gICAgICAgIGNhbGw6ICdienpfc3luY0VuYWJsZWQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzd2FwRW5hYmxlZCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3dhcEVuYWJsZWQnLFxuICAgICAgICBjYWxsOiAnYnp6X3N3YXBFbmFibGVkJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgZG93bmxvYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2Rvd25sb2FkJyxcbiAgICAgICAgY2FsbDogJ2J6el9kb3dubG9hZCcsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIHVwbG9hZCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAndXBsb2FkJyxcbiAgICAgICAgY2FsbDogJ2J6el91cGxvYWQnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciByZXRyaWV2ZSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncmV0cmlldmUnLFxuICAgICAgICBjYWxsOiAnYnp6X3JldHJpZXZlJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgc3RvcmUgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3N0b3JlJyxcbiAgICAgICAgY2FsbDogJ2J6el9zdG9yZScsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGdldCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0JyxcbiAgICAgICAgY2FsbDogJ2J6el9nZXQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBwdXQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICAgIGNhbGw6ICdienpfcHV0JyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgbW9kaWZ5ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdtb2RpZnknLFxuICAgICAgICBjYWxsOiAnYnp6X21vZGlmeScsXG4gICAgICAgIHBhcmFtczogNCxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBudWxsLCBudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgYmxvY2tOZXR3b3JrUmVhZCxcbiAgICAgICAgc3luY0VuYWJsZWQsXG4gICAgICAgIHN3YXBFbmFibGVkLFxuICAgICAgICBkb3dubG9hZCxcbiAgICAgICAgdXBsb2FkLFxuICAgICAgICByZXRyaWV2ZSxcbiAgICAgICAgc3RvcmUsXG4gICAgICAgIGdldCxcbiAgICAgICAgcHV0LFxuICAgICAgICBtb2RpZnlcbiAgICBdO1xufTtcblxudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdoaXZlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2J6el9oaXZlJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmZvJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2J6el9pbmZvJ1xuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3dhcm07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3N3YXJtLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3N3YXJtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgd2F0Y2hlcy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcblxuLy8vIEByZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyB3ZWIzLmV0aC5maWx0ZXIgYXBpIG1ldGhvZHNcbnZhciBldGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0ZpbHRlckNhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xhdGVzdCc6XG4gICAgICAgICAgICAgICAgYXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2V0aF9uZXdCbG9ja0ZpbHRlcic7XG4gICAgICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICAgICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnZXRoX25ld0ZpbHRlcic7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG5ld0ZpbHRlciA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnbmV3RmlsdGVyJyxcbiAgICAgICAgY2FsbDogbmV3RmlsdGVyQ2FsbCxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgdW5pbnN0YWxsRmlsdGVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICd1bmluc3RhbGxGaWx0ZXInLFxuICAgICAgICBjYWxsOiAnZXRoX3VuaW5zdGFsbEZpbHRlcicsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIGdldExvZ3MgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldExvZ3MnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldEZpbHRlckxvZ3MnLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBwb2xsID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdwb2xsJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRGaWx0ZXJDaGFuZ2VzJyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBuZXdGaWx0ZXIsXG4gICAgICAgIHVuaW5zdGFsbEZpbHRlcixcbiAgICAgICAgZ2V0TG9ncyxcbiAgICAgICAgcG9sbFxuICAgIF07XG59O1xuXG4vLy8gQHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIHdlYjMuc2hoLndhdGNoIGFwaSBtZXRob2RzXG52YXIgc2hoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdGaWx0ZXIgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0ZpbHRlcicsXG4gICAgICAgIGNhbGw6ICdzaGhfbmV3RmlsdGVyJyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgdW5pbnN0YWxsRmlsdGVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICd1bmluc3RhbGxGaWx0ZXInLFxuICAgICAgICBjYWxsOiAnc2hoX3VuaW5zdGFsbEZpbHRlcicsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIGdldExvZ3MgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldExvZ3MnLFxuICAgICAgICBjYWxsOiAnc2hoX2dldE1lc3NhZ2VzJyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgcG9sbCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncG9sbCcsXG4gICAgICAgIGNhbGw6ICdzaGhfZ2V0RmlsdGVyQ2hhbmdlcycsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3RmlsdGVyLFxuICAgICAgICB1bmluc3RhbGxGaWx0ZXIsXG4gICAgICAgIGdldExvZ3MsXG4gICAgICAgIHBvbGxcbiAgICBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXRoOiBldGgsXG4gICAgc2hoOiBzaGhcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvd2F0Y2hlcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy93YXRjaGVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBuYW1lcmVnLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBnbG9iYWxSZWdpc3RyYXJBYmkgPSByZXF1aXJlKCcuLi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb24nKTtcbnZhciBpY2FwUmVnaXN0cmFyQWJpPSByZXF1aXJlKCcuLi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uJyk7XG5cbnZhciBnbG9iYWxOYW1lcmVnQWRkcmVzcyA9ICcweGM2ZDlkMmNkNDQ5YTc1NGM0OTQyNjRlMTgwOWM1MGUzNGQ2NDU2MmInO1xudmFyIGljYXBOYW1lcmVnQWRkcmVzcyA9ICcweGExYTExMWJjMDc0YzljZmE3ODFmMGMzOGU2M2JkNTFjOTFiOGFmMDAnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnbG9iYWw6IHtcbiAgICAgICAgYWJpOiBnbG9iYWxSZWdpc3RyYXJBYmksXG4gICAgICAgIGFkZHJlc3M6IGdsb2JhbE5hbWVyZWdBZGRyZXNzXG4gICAgfSxcbiAgICBpY2FwOiB7XG4gICAgICAgIGFiaTogaWNhcFJlZ2lzdHJhckFiaSxcbiAgICAgICAgYWRkcmVzczogaWNhcE5hbWVyZWdBZGRyZXNzXG4gICAgfVxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbmFtZXJlZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbmFtZXJlZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBwcm9wZXJ0eS5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZnJvemVtYW4uZGU+XG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbnZhciBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuZ2V0dGVyID0gb3B0aW9ucy5nZXR0ZXI7XG4gICAgdGhpcy5zZXR0ZXIgPSBvcHRpb25zLnNldHRlcjtcbiAgICB0aGlzLm91dHB1dEZvcm1hdHRlciA9IG9wdGlvbnMub3V0cHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMuaW5wdXRGb3JtYXR0ZXIgPSBvcHRpb25zLmlucHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBudWxsO1xufTtcblxuUHJvcGVydHkucHJvdG90eXBlLnNldFJlcXVlc3RNYW5hZ2VyID0gZnVuY3Rpb24gKHJtKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJtO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBpbnB1dCBhcmdzIG9mIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLmZvcm1hdElucHV0ID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyID8gdGhpcy5pbnB1dEZvcm1hdHRlcihhcmcpIDogYXJnO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBvdXRwdXQocmVzdWx0KSBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5mb3JtYXRPdXRwdXQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0Rm9ybWF0dGVyICYmIHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHRoaXMub3V0cHV0Rm9ybWF0dGVyKHJlc3VsdCkgOiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGV4dHJhY3QgY2FsbGJhY2sgZnJvbSBhcnJheSBvZiBhcmd1bWVudHMuIE1vZGlmaWVzIGlucHV0IHBhcmFtXG4gKlxuICogQG1ldGhvZCBleHRyYWN0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7RnVuY3Rpb258TnVsbH0gY2FsbGJhY2ssIGlmIGV4aXN0c1xuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcblxuXG4vKipcbiAqIFNob3VsZCBhdHRhY2ggZnVuY3Rpb24gdG8gbWV0aG9kXG4gKlxuICogQG1ldGhvZCBhdHRhY2hUb09iamVjdFxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHByb3RvID0ge1xuICAgICAgICBnZXQ6IHRoaXMuYnVpbGRHZXQoKSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH07XG5cbiAgICB2YXIgbmFtZXMgPSB0aGlzLm5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgbmFtZSA9IG5hbWVzWzBdO1xuICAgIGlmIChuYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG9ialtuYW1lc1swXV0gPSBvYmpbbmFtZXNbMF1dIHx8IHt9O1xuICAgICAgICBvYmogPSBvYmpbbmFtZXNbMF1dO1xuICAgICAgICBuYW1lID0gbmFtZXNbMV07XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgcHJvdG8pO1xuICAgIG9ialthc3luY0dldHRlck5hbWUobmFtZSldID0gdGhpcy5idWlsZEFzeW5jR2V0KCk7XG59O1xuXG52YXIgYXN5bmNHZXR0ZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gJ2dldCcgKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbn07XG5cblByb3BlcnR5LnByb3RvdHlwZS5idWlsZEdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydHkgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eS5mb3JtYXRPdXRwdXQocHJvcGVydHkucmVxdWVzdE1hbmFnZXIuc2VuZCh7XG4gICAgICAgICAgICBtZXRob2Q6IHByb3BlcnR5LmdldHRlclxuICAgICAgICB9KSk7XG4gICAgfTtcbn07XG5cblByb3BlcnR5LnByb3RvdHlwZS5idWlsZEFzeW5jR2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXM7XG4gICAgdmFyIGdldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBwcm9wZXJ0eS5yZXF1ZXN0TWFuYWdlci5zZW5kQXN5bmMoe1xuICAgICAgICAgICAgbWV0aG9kOiBwcm9wZXJ0eS5nZXR0ZXJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHByb3BlcnR5LmZvcm1hdE91dHB1dChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBnZXQucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBnZXQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIHB1cmUgSlNPTlJQQyByZXF1ZXN0IHdoaWNoIGNhbiBiZSB1c2VkIGluIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RcbiAqIEBwYXJhbSB7Li4ufSBwYXJhbXNcbiAqIEByZXR1cm4ge09iamVjdH0ganNvbnJwYyByZXF1ZXN0XG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICBtZXRob2Q6IHRoaXMuZ2V0dGVyLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICBjYWxsYmFjazogdGhpcy5leHRyYWN0Q2FsbGJhY2soQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICB9O1xuICAgIHBheWxvYWQuZm9ybWF0ID0gdGhpcy5mb3JtYXRPdXRwdXQuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvcGVydHk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3Byb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgcmVxdWVzdG1hbmFnZXIuanNcbiAqIEBhdXRob3IgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAYXV0aG9yIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgSnNvbnJwYyA9IHJlcXVpcmUoJy4vanNvbnJwYycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjID0gcmVxdWlyZSgnLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuLyoqXG4gKiBJdCdzIHJlc3BvbnNpYmxlIGZvciBwYXNzaW5nIG1lc3NhZ2VzIHRvIHByb3ZpZGVyc1xuICogSXQncyBhbHNvIHJlc3BvbnNpYmxlIGZvciBwb2xsaW5nIHRoZSBldGhlcmV1bSBub2RlIGZvciBpbmNvbWluZyBtZXNzYWdlc1xuICogRGVmYXVsdCBwb2xsIHRpbWVvdXQgaXMgMSBzZWNvbmRcbiAqIFNpbmdsZXRvblxuICovXG52YXIgUmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5wb2xscyA9IHt9O1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN5bmNocm9ub3VzbHkgc2VuZCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvUGF5bG9hZChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnByb3ZpZGVyLnNlbmQocGF5bG9hZCk7XG5cbiAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBhc3luY2hyb25vdXNseSBzZW5kIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHNlbmRBc3luY1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUHJvdmlkZXIoKSk7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvUGF5bG9hZChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFzeW5jaHJvbm91c2x5IHNlbmQgYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZEJhdGNoXG4gKiBAcGFyYW0ge0FycmF5fSBiYXRjaCBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZEJhdGNoID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgIH1cblxuICAgIHZhciBwYXlsb2FkID0gSnNvbnJwYy50b0JhdGNoUGF5bG9hZChkYXRhKTtcblxuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgfSk7IFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBzZXQgcHJvdmlkZXIgb2YgcmVxdWVzdCBtYW5hZ2VyXG4gKlxuICogQG1ldGhvZCBzZXRQcm92aWRlclxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZXRQcm92aWRlciA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdGhpcy5wcm92aWRlciA9IHA7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN0YXJ0IHBvbGxpbmdcbiAqXG4gKiBAbWV0aG9kIHN0YXJ0UG9sbGluZ1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb2xsSWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1bmluc3RhbGxcbiAqXG4gKiBAdG9kbyBjbGVhbnVwIG51bWJlciBvZiBwYXJhbXNcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChkYXRhLCBwb2xsSWQsIGNhbGxiYWNrLCB1bmluc3RhbGwpIHtcbiAgICB0aGlzLnBvbGxzW3BvbGxJZF0gPSB7ZGF0YTogZGF0YSwgaWQ6IHBvbGxJZCwgY2FsbGJhY2s6IGNhbGxiYWNrLCB1bmluc3RhbGw6IHVuaW5zdGFsbH07XG5cblxuICAgIC8vIHN0YXJ0IHBvbGxpbmdcbiAgICBpZiAoIXRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN0b3AgcG9sbGluZyBmb3IgZmlsdGVyIHdpdGggZ2l2ZW4gaWRcbiAqXG4gKiBAbWV0aG9kIHN0b3BQb2xsaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gcG9sbElkXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSWQpIHtcbiAgICBkZWxldGUgdGhpcy5wb2xsc1twb2xsSWRdO1xuXG4gICAgLy8gc3RvcCBwb2xsaW5nXG4gICAgaWYoT2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoID09PSAwICYmIHRoaXMudGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcmVzZXQgdGhlIHBvbGxpbmcgbWVjaGFuaXNtIG9mIHRoZSByZXF1ZXN0IG1hbmFnZXJcbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChrZWVwSXNTeW5jaW5nKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wb2xscykge1xuICAgICAgICAvLyByZW1vdmUgYWxsIHBvbGxzLCBleGNlcHQgc3luYyBwb2xscyxcbiAgICAgICAgLy8gdGhleSBuZWVkIHRvIGJlIHJlbW92ZWQgbWFudWFsbHkgYnkgY2FsbGluZyBzeW5jaW5nLnN0b3BXYXRjaGluZygpXG4gICAgICAgIGlmKCFrZWVwSXNTeW5jaW5nIHx8IGtleS5pbmRleE9mKCdzeW5jUG9sbF8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9sbHNba2V5XS51bmluc3RhbGwoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvbGxzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdG9wIHBvbGxpbmdcbiAgICBpZihPYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGggPT09IDAgJiYgdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwb2xsIGZvciBjaGFuZ2VzIG9uIGZpbHRlciB3aXRoIGdpdmVuIGlkXG4gKlxuICogQG1ldGhvZCBwb2xsXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDYgKi9cbiAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucG9sbC5iaW5kKHRoaXMpLCBjLkVUSF9QT0xMSU5HX1RJTUVPVVQpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2xsc0RhdGEgPSBbXTtcbiAgICB2YXIgcG9sbHNJZHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wb2xscykge1xuICAgICAgICBwb2xsc0RhdGEucHVzaCh0aGlzLnBvbGxzW2tleV0uZGF0YSk7XG4gICAgICAgIHBvbGxzSWRzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAocG9sbHNEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvQmF0Y2hQYXlsb2FkKHBvbGxzRGF0YSk7XG4gICAgXG4gICAgLy8gbWFwIHRoZSByZXF1ZXN0IGlkIHRvIHRoZXkgcG9sbCBpZFxuICAgIHZhciBwb2xsc0lkTWFwID0ge307XG4gICAgcGF5bG9hZC5mb3JFYWNoKGZ1bmN0aW9uKGxvYWQsIGluZGV4KXtcbiAgICAgICAgcG9sbHNJZE1hcFtsb2FkLmlkXSA9IHBvbGxzSWRzW2luZGV4XTtcbiAgICB9KTtcblxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0cykge1xuXG5cbiAgICAgICAgLy8gVE9ETzogY29uc29sZSBsb2c/XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHBvbGxzSWRNYXBbcmVzdWx0LmlkXTtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmaWx0ZXIgaXMgc3RpbGwgaW5zdGFsbGVkIGFmdGVyIGFycml2YWwgb2YgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGlmIChzZWxmLnBvbGxzW2lkXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayA9IHNlbGYucG9sbHNbaWRdLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7IFxuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0TWFuYWdlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcmVxdWVzdG1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3JlcXVlc3RtYW5hZ2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG52YXIgU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0QmxvY2sgPSAnbGF0ZXN0JztcbiAgICB0aGlzLmRlZmF1bHRBY2NvdW50ID0gdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3NldHRpbmdzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgc3luY2luZy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xuXG52YXIgY291bnQgPSAxO1xuXG4vKipcbkFkZHMgdGhlIGNhbGxiYWNrIGFuZCBzZXRzIHVwIHRoZSBtZXRob2RzLCB0byBpdGVyYXRlIG92ZXIgdGhlIHJlc3VsdHMuXG5cbkBtZXRob2QgcG9sbFN5bmNpbmdcbkBwYXJhbSB7T2JqZWN0fSBzZWxmXG4qL1xudmFyIHBvbGxTeW5jaW5nID0gZnVuY3Rpb24oc2VsZikge1xuXG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uIChlcnJvciwgc3luYykge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodXRpbHMuaXNPYmplY3Qoc3luYykgJiYgc3luYy5zdGFydGluZ0Jsb2NrKVxuICAgICAgICAgICAgc3luYyA9IGZvcm1hdHRlcnMub3V0cHV0U3luY2luZ0Zvcm1hdHRlcihzeW5jKTtcblxuICAgICAgICBzZWxmLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHNlbGYubGFzdFN5bmNTdGF0ZSAhPT0gc3luYykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdHJ1ZSBmaXJzdCBzbyB0aGUgYXBwIGNhbiBzdG9wIGFueXRoaW5nLCBiZWZvcmUgcmVjZWl2aW5nIHRoZSBzeW5jIGRhdGFcbiAgICAgICAgICAgICAgICBpZighc2VsZi5sYXN0U3luY1N0YXRlICYmIHV0aWxzLmlzT2JqZWN0KHN5bmMpKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjYWxsIG9uIHRoZSBuZXh0IENQVSBjeWNsZSwgc28gdGhlIGFjdGlvbnMgb2YgdGhlIHN5bmMgc3RvcCBjYW4gYmUgcHJvY2Vzc2VzIGZpcnN0XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3luYyk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0U3luY1N0YXRlID0gc3luYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNlbGYucmVxdWVzdE1hbmFnZXIuc3RhcnRQb2xsaW5nKHtcbiAgICAgICAgbWV0aG9kOiAnZXRoX3N5bmNpbmcnLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgIH0sIHNlbGYucG9sbElkLCBvbk1lc3NhZ2UsIHNlbGYuc3RvcFdhdGNoaW5nLmJpbmQoc2VsZikpO1xuXG59O1xuXG52YXIgSXNTeW5jaW5nID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSByZXF1ZXN0TWFuYWdlcjtcbiAgICB0aGlzLnBvbGxJZCA9ICdzeW5jUG9sbF8nKyBjb3VudCsrO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5hZGRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgdGhpcy5sYXN0U3luY1N0YXRlID0gZmFsc2U7XG4gICAgcG9sbFN5bmNpbmcodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbklzU3luY2luZy5wcm90b3R5cGUuYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZihjYWxsYmFjaylcbiAgICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Jc1N5bmNpbmcucHJvdG90eXBlLnN0b3BXYXRjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyLnN0b3BQb2xsaW5nKHRoaXMucG9sbElkKTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc1N5bmNpbmc7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3N5bmNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3N5bmNpbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIHRyYW5zZmVyLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBJYmFuID0gcmVxdWlyZSgnLi9pYmFuJyk7XG52YXIgZXhjaGFuZ2VBYmkgPSByZXF1aXJlKCcuLi9jb250cmFjdHMvU21hcnRFeGNoYW5nZS5qc29uJyk7XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gbWFrZSBJYmFuIHRyYW5zZmVyXG4gKlxuICogQG1ldGhvZCB0cmFuc2ZlclxuICogQHBhcmFtIHtTdHJpbmd9IGZyb21cbiAqIEBwYXJhbSB7U3RyaW5nfSB0byBpYmFuXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSB0byBiZSB0cmFuZmVyZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgdHJhbnNmZXIgPSBmdW5jdGlvbiAoZXRoLCBmcm9tLCB0bywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGliYW4gPSBuZXcgSWJhbih0byk7IFxuICAgIGlmICghaWJhbi5pc1ZhbGlkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGliYW4gYWRkcmVzcycpO1xuICAgIH1cblxuICAgIGlmIChpYmFuLmlzRGlyZWN0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVyVG9BZGRyZXNzKGV0aCwgZnJvbSwgaWJhbi5hZGRyZXNzKCksIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIFxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGFkZHJlc3MgPSBldGguaWNhcE5hbWVyZWcoKS5hZGRyKGliYW4uaW5zdGl0dXRpb24oKSk7XG4gICAgICAgIHJldHVybiBkZXBvc2l0KGV0aCwgZnJvbSwgYWRkcmVzcywgdmFsdWUsIGliYW4uY2xpZW50KCkpO1xuICAgIH1cblxuICAgIGV0aC5pY2FwTmFtZXJlZygpLmFkZHIoaWJhbi5pbnN0aXR1dGlvbigpLCBmdW5jdGlvbiAoZXJyLCBhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBkZXBvc2l0KGV0aCwgZnJvbSwgYWRkcmVzcywgdmFsdWUsIGliYW4uY2xpZW50KCksIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICBcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gdHJhbnNmZXIgZnVuZHMgdG8gY2VydGFpbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCB0cmFuc2ZlclRvQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGZyb21cbiAqIEBwYXJhbSB7U3RyaW5nfSB0b1xuICogQHBhcmFtIHtWYWx1ZX0gdmFsdWUgdG8gYmUgdHJhbmZlcmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjaywgY2FsbGJhY2tcbiAqL1xudmFyIHRyYW5zZmVyVG9BZGRyZXNzID0gZnVuY3Rpb24gKGV0aCwgZnJvbSwgdG8sIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldGguc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgYWRkcmVzczogdG8sXG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVwb3NpdCBmdW5kcyB0byBnZW5lcmljIEV4Y2hhbmdlIGNvbnRyYWN0IChtdXN0IGltcGxlbWVudCBkZXBvc2l0KGJ5dGVzMzIpIG1ldGhvZCEpXG4gKlxuICogQG1ldGhvZCBkZXBvc2l0XG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSB0byBiZSB0cmFuc2ZlcmVkXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xpZW50IHVuaXF1ZSBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjaywgY2FsbGJhY2tcbiAqL1xudmFyIGRlcG9zaXQgPSBmdW5jdGlvbiAoZXRoLCBmcm9tLCB0bywgdmFsdWUsIGNsaWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgYWJpID0gZXhjaGFuZ2VBYmk7XG4gICAgcmV0dXJuIGV0aC5jb250cmFjdChhYmkpLmF0KHRvKS5kZXBvc2l0KGNsaWVudCwge1xuICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zZmVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy90cmFuc2Zlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvdHJhbnNmZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gWE1MSHR0cFJlcXVlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMveGhyMi9saWIvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3hocjIvbGliL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9hZHNMaXN0LnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9hZHNMaXN0LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9hZHNMaXN0LnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2Fkc0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vYnV0dG9uLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9idXR0b24uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2J1dHRvbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYnV0dG9uLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9pY29uLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9pY29uLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9pY29uLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2ljb24uc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vaW5wdXQuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2lucHV0LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9pbnB1dC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGFiZWwuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xhYmVsLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9sYWJlbC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGluay5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGluay5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGluay5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmsuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xpbmtMaXN0LnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rTGlzdC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGlua0xpc3Quc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGlua0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGlua0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xvYWRlci5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbG9hZGVyLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9sb2FkZXIuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xvYWRlci5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vcGFwZXIuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3BhcGVyLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9wYXBlci5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9wYXBlci5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9wYXBlci5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdGV4dFdpdGhMYWJlbC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdGV4dFdpdGhMYWJlbC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdGV4dFdpdGhMYWJlbC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90ZXh0V2l0aExhYmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3RleHRXaXRoTGFiZWwuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3Rvb2x0aXAuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3Rvb2x0aXAuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3Rvb2x0aXAuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdG9vbHRpcC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90b29sdGlwLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpUHo0S1BITjJaeUIzYVdSMGFEMGlNVFF4Y0hnaUlHaGxhV2RvZEQwaU1UTXhjSGdpSUhacFpYZENiM2c5SWpBZ01DQXhOREVnTVRNeElpQjJaWEp6YVc5dVBTSXhMakVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lQZ29nSUNBZ1BDRXRMU0JIWlc1bGNtRjBiM0k2SUZOclpYUmphQ0EwTmk0eUlDZzBORFE1TmlrZ0xTQm9kSFJ3T2k4dmQzZDNMbUp2YUdWdGFXRnVZMjlrYVc1bkxtTnZiUzl6YTJWMFkyZ2dMUzArQ2lBZ0lDQThkR2wwYkdVK1IzSnZkWEFnTXp3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBnb2dJQ0FnSUNBZ0lEeGphWEpqYkdVZ2FXUTlJbkJoZEdndE1TSWdZM2c5SWpZd0xqYzROakV6TWpnaUlHTjVQU0kxT1M0M09EWXhNekk0SWlCeVBTSTBOUzQzT0RZeE16STRJajQ4TDJOcGNtTnNaVDRLSUNBZ0lDQWdJQ0E4Wm1sc2RHVnlJSGc5SWkwek5TNDFKU0lnZVQwaUxUTXdMakFsSWlCM2FXUjBhRDBpTVRjeExqQWxJaUJvWldsbmFIUTlJakUzTVM0d0pTSWdabWxzZEdWeVZXNXBkSE05SW05aWFtVmpkRUp2ZFc1a2FXNW5RbTk0SWlCcFpEMGlabWxzZEdWeUxUSWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOFptVlBabVp6WlhRZ1pIZzlJakFpSUdSNVBTSTFJaUJwYmowaVUyOTFjbU5sUVd4d2FHRWlJSEpsYzNWc2REMGljMmhoWkc5M1QyWm1jMlYwVDNWMFpYSXhJajQ4TDJabFQyWm1jMlYwUGdvZ0lDQWdJQ0FnSUNBZ0lDQThabVZIWVhWemMybGhia0pzZFhJZ2MzUmtSR1YyYVdGMGFXOXVQU0l4TUNJZ2FXNDlJbk5vWVdSdmQwOW1abk5sZEU5MWRHVnlNU0lnY21WemRXeDBQU0p6YUdGa2IzZENiSFZ5VDNWMFpYSXhJajQ4TDJabFIyRjFjM05wWVc1Q2JIVnlQZ29nSUNBZ0lDQWdJQ0FnSUNBOFptVkRiMnh2Y2sxaGRISnBlQ0IyWVd4MVpYTTlJakFnTUNBd0lEQWdNQzR3TXpVeU9UUXhNVGMySUNBZ01DQXdJREFnTUNBd0xqZ3pOVEk1TkRFeE9DQWdJREFnTUNBd0lEQWdNQzQwT0RZeU56UTFNU0FnTUNBd0lEQWdNQzQwTlNBd0lpQjBlWEJsUFNKdFlYUnlhWGdpSUdsdVBTSnphR0ZrYjNkQ2JIVnlUM1YwWlhJeElqNDhMMlpsUTI5c2IzSk5ZWFJ5YVhnK0NpQWdJQ0FnSUNBZ1BDOW1hV3gwWlhJK0NpQWdJQ0E4TDJSbFpuTStDaUFnSUNBOFp5QnBaRDBpVFZaUUlpQnpkSEp2YTJVOUltNXZibVVpSUhOMGNtOXJaUzEzYVdSMGFEMGlNU0lnWm1sc2JEMGlibTl1WlNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lqNEtJQ0FnSUNBZ0lDQThaeUJwWkQwaVkzSmxZWFJsVG1WM1FXUkRiMjVtYVhKdFlYUnBiMjRpSUhSeVlXNXpabTl5YlQwaWRISmhibk5zWVhSbEtDMDNNell1TURBd01EQXdMQ0F0TXpZeExqQXdNREF3TUNraVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4WnlCcFpEMGlSM0p2ZFhBdE1pSWdkSEpoYm5ObWIzSnRQU0owY21GdWMyeGhkR1VvTnpReExqQXdNREF3TUN3Z016WXlMakF3TURBd01Da2lQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQR2NnYVdROUlrZHliM1Z3TFRNaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhqYVhKamJHVWdhV1E5SWs5MllXd3RNaUlnWm1sc2JDMXZjR0ZqYVhSNVBTSXdMaklpSUdacGJHdzlJaU13T1VRMU4wTWlJR040UFNJeE1ETWlJR041UFNJek15SWdjajBpTXpNaVBqd3ZZMmx5WTJ4bFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhqYVhKamJHVWdhV1E5SWs5MllXd3RNaUlnWm1sc2JDMXZjR0ZqYVhSNVBTSXdMaklpSUdacGJHdzlJaU13T1VRMU4wTWlJR040UFNJek15SWdZM2s5SWpjeklpQnlQU0l6TXlJK1BDOWphWEpqYkdVK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQR2NnYVdROUlrOTJZV3dpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4ZFhObElHWnBiR3c5SW1Kc1lXTnJJaUJtYVd4c0xXOXdZV05wZEhrOUlqRWlJR1pwYkhSbGNqMGlkWEpzS0NObWFXeDBaWEl0TWlraUlIaHNhVzVyT21oeVpXWTlJaU53WVhSb0xURWlQand2ZFhObFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGRYTmxJR1pwYkd3OUlpTXdPVVExTjBNaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdlR3hwYm1zNmFISmxaajBpSTNCaGRHZ3RNU0krUEM5MWMyVStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSnViM1Z1WHpjME56TXdNbDlqWXlJZ2RISmhibk5tYjNKdFBTSjBjbUZ1YzJ4aGRHVW9Nell1TURBd01EQXdMQ0EwTWk0d01EQXdNREFwSWlCbWFXeHNMWEoxYkdVOUltNXZibnBsY204aUlHWnBiR3c5SWlOR1JrWkdSa1lpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y0dGMGFDQmtQU0pOTVRNdU9UVTJNRFEwTERBdU1UQTVPRGt3TVRFZ1F6RTJMamN3TXpJNU5qY3NMVE11TURRd05qSXpNekZsTFRFMElERTVMakEyTlRrek5ERXNNQzQ1T0Rrd01UQTVPRGtnTWpBdU9ESTBNVGMxT0N3eUxqZzFOekUwTWpnMklFd3lOQzQ0T1RBeE1EazVMRGN1TVRReU9EVTNNVFFnUXpJekxqY3pOakkyTXpjc09DNDBOakUxTXpnME5pQXlNaTQ0TlRjeE5ESTVMRGt1TXprMU5qQTBOQ0F5TWk0MU1qYzBOekkxTERrdU9ETTFNVFkwT0RRZ1F6SXhMamt5TXpBM05qa3NPUzR4TnpVNE1qUXhPQ0F5TUM0ME16azFOakEwTERjdU5EY3lOVEkzTkRjZ01UZ3VPVFUyTURRMExEVXVPRGM1TVRJd09EZ2dRekUzTGpVNE1qUXhOellzTkM0ek9UVTJNRFEwSURFMUxqY3hOREk0TlRjc015NDJPREV6TVRnMk9DQXhNeTQzTXpZeU5qTTNMRE11TnpreE1qQTROemtnUXpFeExqZzJPREV6TVRrc015NDVNREV3T1RnNUlERXdMakUyTkRnek5USXNOQzQzT0RBeU1UazNPQ0E1TGpJNE5UY3hOREk1TERVdU9UZzVNREV3T1RrZ1F6VXVPVGc1TURFd09Ua3NNVEF1TlRRNU5EVXdOU0E1TGpJNE5UY3hOREk1TERFMExqWXhOVE00TkRZZ09TNHlPRFUzTVRReU9Td3hOQzQyTnpBek1qazNJRXd5TkM0NE16VXhOalE0TERNeUxqWXpOek0yTWpZZ1F6SXpMalk0TVRNeE9EY3NNek11T1RVMk1EUTBJREl5TGpnMU56RTBNamtzTXpRdU9UUTFNRFUwT1NBeU1pNDBOekkxTWpjMUxETTFMak15T1RZM01ETWdRekl3TGpnM09URXlNRGtzTXpNdU16VXhOalE0TkNBeE1DNHpPRFEyTVRVMExESXhMalF5T0RVM01UUWdOaTR5TURnM09URXlNU3d4Tmk0MU9UTTBNRFkySUVNMUxqSXhPVGM0TURJeUxERTFMalE1TkRVd05UVWdNeTR4TXpFNE5qZ3hNeXd4TVM0MU9UTTBNRFkySURRdU9ETTFNVFkwT0RRc05pNDNOVGd5TkRFM05pQkROaTQwT0RNMU1UWTBPQ3d5TGpBek1qazJOekF6SURFd0xqYzJPVEl6TURnc01DNHlNVGszT0RBeU1pQXhNeTQ1TlRZd05EUXNNQzR4TURrNE9UQXhNU0JhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRJekxqQTNOamt5TXpFc01UWXVNekU0TmpneE15QkRNalF1TkRVd05UUTVOU3d4TkM0M01qVXlOelEzSURJNExqazFOakEwTkN3NUxqUTFNRFUwT1RRMUlETXhMamMxT0RJME1UZ3NOaTR6TnpNMk1qWXpOeUJETXpJdU9EVTNNVFF5T1N3MUxqRTJORGd6TlRFMklETTBMakk0TlRjeE5ETXNOQzQwTlRBMU5EazBOU0F6TlM0NU9Ea3dNVEVzTkM0ek9UVTJNRFEwSUVNek55NHpNRGMyT1RJekxEUXVNelF3TmpVNU16UWdNemd1TmpneE16RTROeXcwTGpjeU5USTNORGN6SURNNUxqY3lOVEkzTkRjc05TNDBNemsxTmpBME5DQkRNell1TlRrek5EQTJOaXcxTGpZMU9UTTBNRFkySURNMUxqQTFORGswTlRFc055NDFNamMwTnpJMU15QXpOU3czTGpVNE1qUXhOelU0SUV3eU55NDJNemN6TmpJMkxERTJMak14T0RZNE1UTWdUREl6TGpBM05qa3lNekVzTVRZdU16RTROamd4TXlCYUlpQnBaRDBpVTJoaGNHVWlQand2Y0dGMGFENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRUTXVNRGMyT1RJek1EZ3NNVGt1TkRVd05UUTVOU0JETUM0NU9Ea3dNVEE1T0Rrc01UY3VNRE15T1RZM0lEQXVNVFkwT0RNMU1UWTFMREV6TGpjNU1USXdPRGdnTUM0M01UUXlPRFUzTVRRc01UQXVNVFkwT0RNMU1pQkRNUzR4TlRNNE5EWXhOU3czTGpBek1qazJOekF6SURNdU56TTJNall6TnpRc05DNHdOalU1TXpRd055QTJMalkwT0RNMU1UWTFMREl1TnpRM01qVXlOelVnUXpVdU5qVTVNelF3TmpZc015NDNPVEV5TURnM09TQTBMamd6TlRFMk5EZzBMRFV1TURVME9UUTFNRFVnTkM0eU9EVTNNVFF5T1N3MkxqVTVNelF3TmpVNUlFTXlMalEzTWpVeU56UTNMREV4TGpVNU16UXdOallnTkM0M01qVXlOelEzTXl3eE5TNDRNalF4TnpVNElEVXVOelk1TWpNd056Y3NNVFl1T1RjNE1ESXlJRU14TUM0eU56UTNNalV6TERJeUxqRTVOemd3TWpJZ01qSXVNVFF5T0RVM01Td3pOUzQ0TWpReE56VTRJREl5TGpJMU1qYzBOek1zTXpVdU9UTTBNRFkxT1NCTU1qSXVOVEkzTkRjeU5Td3pOaTR5TmpNM016WXpJRXd5TWk0M05EY3lOVEkzTERNMkxqQTBNemsxTmlCRE1qSXVPVEV5TURnM09Td3pOUzQ0TnpreE1qQTVJRE0zTGpRM01qVXlOelVzTVRrdU1EWTFPVE0wTVNBME1DNDNNVFF5T0RVM0xERTFMalF6T1RVMk1EUWdRelF6TGpRMk1UVXpPRFVzTVRJdU16QTNOamt5TXlBME15NHdOelk1TWpNeExEY3VOak0zTXpZeU5qUWdOREF1T0RJME1UYzFPQ3cxTGpVME9UUTFNRFUxSUVNek9TNDJNVFV6T0RRMkxEUXVNemsxTmpBME5DQXpOeTQ0TURJeE9UYzRMRE11TnpNMk1qWXpOelFnTXpZdU1EUXpPVFUyTERNdU9UQXhNRGs0T1NCRE16UXVNak13TnpZNU1pd3pMamsxTmpBME16azJJRE15TGpZek56TTJNallzTkM0M09EQXlNVGszT0NBek1TNDBNamcxTnpFMExEWXVNRFF6T1RVMk1EUWdRekk0TGpVeE5qUTRNelVzT1M0eU16QTNOamt5TXlBeU15NDJNall6TnpNMkxERTBMamc1TURFd09Ua2dNakl1TlRJM05EY3lOU3d4Tmk0eE5UTTRORFl5SUVNeU1TNDFNemcwTmpFMUxERTBMamswTlRBMU5Ea2dNVGN1TVRrM09EQXlNaXc1TGpZM01ETXlPVFkzSURFMExqazBOVEExTkRrc055NHhPVGM0TURJeUlFTXhOQzR5TXpBM05qa3lMRFl1TkRJNE5UY3hORE1nTVRNdU1ESXhPVGM0TERVdU5qQTBNemsxTmlBeE1DNDNOamt5TXpBNExEVXVNemcwTmpFMU16Z2dRekV4TGpVNU16UXdOallzTkM0M09EQXlNVGszT0NBeE1pNDJPVEl6TURjM0xEUXVORFV3TlRRNU5EVWdNVE11TnpreE1qQTRPQ3cwTGpNME1EWTFPVE0wSUVNeE5TNHdOVFE1TkRVeExEUXVNamcxTnpFME1qa2dNVFl1T1RJek1EYzJPU3cwTGpVd05UUTVORFV4SURFNExqVXhOalE0TXpVc05pNHlOak0zTXpZeU5pQkRNakF1TXpnME5qRTFOQ3c0TGpJME1UYzFPREkwSURJeUxqSTFNamMwTnpNc01UQXVORE01TlRZd05DQXlNaTR5TlRJM05EY3pMREV3TGpRek9UVTJNRFFnVERJeUxqUTNNalV5TnpVc01UQXVOalU1TXpRd055Qk1Nakl1TmpreU16QTNOeXd4TUM0ME16azFOakEwSUVNeU1pNDJPVEl6TURjM0xERXdMalF6T1RVMk1EUWdNalVzTnk0NE1ESXhPVGM0SURJNExqRTROamd4TXpJc05DNHhOelU0TWpReE9DQkRNekF1T1RNME1EWTFPU3d4TGpBNU9Ea3dNVEVnTXpRdU1qTXdOelk1TWl3d0lETTJMalE0TXpVeE5qVXNNQ0JETXpndU56TTJNall6Tnl3d0lEUXpMalEyTVRVek9EVXNNUzR6TnpNMk1qWXpOeUEwTlM0ME9UUTFNRFUxTERZdU5qUTRNelV4TmpVZ1F6UTJMamN3TXpJNU5qY3NPUzQ0TXpVeE5qUTROQ0EwTmk0eE5UTTRORFl5TERFMExqQTJOVGt6TkRFZ05EUXVNVGMxT0RJME1pd3hOaTR6TVRnMk9ERXpJRU16T0M0MU56RTBNamcyTERJeUxqZzFOekUwTWprZ01qUXVNVGMxT0RJME1pd3pPUzR5T0RVM01UUXpJREl5TGpNd056WTVNak1zTkRFdU5EZ3pOVEUyTlNCRE1qQXVNemcwTmpFMU5Dd3pPUzR5T0RVM01UUXpJRFV1TWpjME56STFNamNzTWpFdU9USXpNRGMyT1NBekxqQTNOamt5TXpBNExERTVMalExTURVME9UVWdXaUlnYVdROUlsTm9ZWEJsSWo0OEwzQmhkR2crQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh3WVhSb0lHUTlJazAwTnk0NU5qY3dNek1zTVRndU5EWXhOVE00TlNCRE5ETXVOVGN4TkRJNE5pd3lNeTQwTURZMU9UTTBJREk1TGpFM05UZ3lORElzTkRBdU16STVOamN3TXlBeU55NDVNVEl3T0RjNUxEUXhMamMxT0RJME1UZ2dUREl6TGpBeU1UazNPQ3cwTVM0M05UZ3lOREU0SUVNeU5TNDFORGswTlRBMUxETTRMamM1TVRJd09EZ2dNemt1TWpnMU56RTBNeXd5TXk0eE16RTROamd4SURRMExqY3lOVEkzTkRjc01UWXVPREV6TVRnMk9DQkRORFl1T0RZNE1UTXhPU3d4TkM0ek9UVTJNRFEwSURRM0xqUXhOelU0TWpRc01UQWdORFl1TURrNE9UQXhNU3cyTGpVNU16UXdOalU1SUVNME5TNDBNemsxTmpBMExEVWdORFF1TmpFMU16ZzBOaXd6TGpZNE1UTXhPRFk0SURRekxqWXlOak0zTXpZc01pNDNORGN5TlRJM05TQkRORFl1TURRek9UVTJMRE11TnpreE1qQTROemtnTkRjdU9URXlNRGczT1N3MUxqUTVORFV3TlRRNUlEUTVMakF4TURrNE9TdzNMamt4TWpBNE56a3hJRXcwT1M0d05qVTVNelF4TERndU1ESXhPVGM0TURJZ1F6UTVMakF4TURrNE9TdzNMamsyTnpBek1qazNJRFV4TGpneE16RTROamdzTVRRdU1ERXdPVGc1SURRM0xqazJOekF6TXl3eE9DNDBOakUxTXpnMUlGb2lJR2xrUFNKVGFHRndaU0krUEM5d1lYUm9QZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0FnSUNBZ1BDOW5QZ29nSUNBZ0lDQWdJRHd2Wno0S0lDQWdJRHd2Wno0S1BDOXpkbWMrXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ltYWdlcy9oZWFydC5zdmdcbi8vIG1vZHVsZSBpZCA9IC4vaW1hZ2VzL2hlYXJ0LnN2Z1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHB1dHRpbmcgaGlzdG9yeSBvbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUm91dGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjogX2V4dGVuZHMoe30sIHRoaXMuY29udGV4dC5yb3V0ZXIsIHtcbiAgICAgICAgaGlzdG9yeTogdGhpcy5wcm9wcy5oaXN0b3J5LFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2g6IHRoaXMuc3RhdGUubWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcHV0ZU1hdGNoID0gZnVuY3Rpb24gY29tcHV0ZU1hdGNoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6ICcvJyxcbiAgICAgIHVybDogJy8nLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzRXhhY3Q6IHBhdGhuYW1lID09PSAnLydcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICBoaXN0b3J5ID0gX3Byb3BzLmhpc3Rvcnk7XG5cblxuICAgIGludmFyaWFudChjaGlsZHJlbiA9PSBudWxsIHx8IFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMSwgJ0EgPFJvdXRlcj4gbWF5IGhhdmUgb25seSBvbmUgY2hpbGQgZWxlbWVudCcpO1xuXG4gICAgLy8gRG8gdGhpcyBoZXJlIHNvIHdlIGNhbiBzZXRTdGF0ZSB3aGVuIGEgPFJlZGlyZWN0PiBjaGFuZ2VzIHRoZVxuICAgIC8vIGxvY2F0aW9uIGluIGNvbXBvbmVudFdpbGxNb3VudC4gVGhpcyBoYXBwZW5zIGUuZy4gd2hlbiBkb2luZ1xuICAgIC8vIHNlcnZlciByZW5kZXJpbmcgdXNpbmcgYSA8U3RhdGljUm91dGVyPi5cbiAgICB0aGlzLnVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgbWF0Y2g6IF90aGlzMi5jb21wdXRlTWF0Y2goaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyh0aGlzLnByb3BzLmhpc3RvcnkgPT09IG5leHRQcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PicpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVubGlzdGVuKCk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHJldHVybiBjaGlsZHJlbiA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZXIucHJvcFR5cGVzID0ge1xuICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblJvdXRlci5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdFxufTtcblJvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSb3V0ZXIgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG5cbnZhciBCcm93c2VyUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJyb3dzZXJSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcm93c2VyUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxCcm93c2VyUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gQnJvd3NlclJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQnJvd3NlclJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmb3JjZVJlZnJlc2g6IFByb3BUeXBlcy5ib29sLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgd2luZG93LmxvY2F0aW9uLmhhc2guXG4gKi9cblxudmFyIEhhc2hSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSGFzaFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSGFzaFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhc2hSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPEhhc2hSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgSGFzaFJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBIYXNoUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5IYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBoYXNoVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnaGFzaGJhbmcnLCAnbm9zbGFzaCcsICdzbGFzaCddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEhhc2hSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcblxudmFyIGlzTW9kaWZpZWRFdmVudCA9IGZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG52YXIgTGluayA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhMaW5rLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaW5rKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluayk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNsaWNrKSBfdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uQ2xpY2sgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBpZ25vcmUgcmlnaHQgY2xpY2tzXG4gICAgICAhX3RoaXMucHJvcHMudGFyZ2V0ICYmIC8vIGxldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBpZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICAgICAgKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHZhciBoaXN0b3J5ID0gX3RoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgcmVwbGFjZSA9IF90aGlzJHByb3BzLnJlcGxhY2UsXG4gICAgICAgICAgICAgIHRvID0gX3RoaXMkcHJvcHMudG87XG5cblxuICAgICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICByZXBsYWNlID0gX3Byb3BzLnJlcGxhY2UsXG4gICAgICAgIHRvID0gX3Byb3BzLnRvLFxuICAgICAgICBpbm5lclJlZiA9IF9wcm9wcy5pbm5lclJlZixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ3JlcGxhY2UnLCAndG8nLCAnaW5uZXJSZWYnXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxMaW5rPiBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIHZhciBocmVmID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5LmNyZWF0ZUhyZWYodHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHsgcGF0aG5hbWU6IHRvIH0gOiB0byk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCBocmVmOiBocmVmLCByZWY6IGlubmVyUmVmIH0pKTtcbiAgfTtcblxuICByZXR1cm4gTGluaztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTGluay5wcm9wVHlwZXMgPSB7XG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHJlcGxhY2U6IFByb3BUeXBlcy5ib29sLFxuICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWQsXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pXG59O1xuTGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIHJlcGxhY2U6IGZhbHNlXG59O1xuTGluay5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBjcmVhdGVIcmVmOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IExpbms7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHN0b3JlcyBsb2NhdGlvbiBpbiBtZW1vcnkuXG4gKi9cblxudmFyIE1lbW9yeVJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNZW1vcnlSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1lbW9yeVJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbW9yeVJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxNZW1vcnlSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgTWVtb3J5Um91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gTWVtb3J5Um91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5NZW1vcnlSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBpbml0aWFsRW50cmllczogUHJvcFR5cGVzLmFycmF5LFxuICBpbml0aWFsSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBNZW1vcnlSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IE1lbW9yeVJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCBwYXRoVG9SZWdleHAgZnJvbSAncGF0aC10by1yZWdleHAnO1xuXG52YXIgcGF0dGVybkNhY2hlID0ge307XG52YXIgY2FjaGVMaW1pdCA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQgPSAwO1xuXG52YXIgY29tcGlsZVBhdGggPSBmdW5jdGlvbiBjb21waWxlUGF0aChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleSA9ICcnICsgb3B0aW9ucy5lbmQgKyBvcHRpb25zLnN0cmljdCArIG9wdGlvbnMuc2Vuc2l0aXZlO1xuICB2YXIgY2FjaGUgPSBwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldIHx8IChwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldID0ge30pO1xuXG4gIGlmIChjYWNoZVtwYXR0ZXJuXSkgcmV0dXJuIGNhY2hlW3BhdHRlcm5dO1xuXG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZSA9IHBhdGhUb1JlZ2V4cChwYXR0ZXJuLCBrZXlzLCBvcHRpb25zKTtcbiAgdmFyIGNvbXBpbGVkUGF0dGVybiA9IHsgcmU6IHJlLCBrZXlzOiBrZXlzIH07XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0dGVybl0gPSBjb21waWxlZFBhdHRlcm47XG4gICAgY2FjaGVDb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVkUGF0dGVybjtcbn07XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBVUkwgcGF0aG5hbWUgdG8gYSBwYXRoIHBhdHRlcm4uXG4gKi9cbnZhciBtYXRjaFBhdGggPSBmdW5jdGlvbiBtYXRjaFBhdGgocGF0aG5hbWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMgPSB7IHBhdGg6IG9wdGlvbnMgfTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGF0aCA9IF9vcHRpb25zLnBhdGgsXG4gICAgICBwYXRoID0gX29wdGlvbnMkcGF0aCA9PT0gdW5kZWZpbmVkID8gJy8nIDogX29wdGlvbnMkcGF0aCxcbiAgICAgIF9vcHRpb25zJGV4YWN0ID0gX29wdGlvbnMuZXhhY3QsXG4gICAgICBleGFjdCA9IF9vcHRpb25zJGV4YWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJGV4YWN0LFxuICAgICAgX29wdGlvbnMkc3RyaWN0ID0gX29wdGlvbnMuc3RyaWN0LFxuICAgICAgc3RyaWN0ID0gX29wdGlvbnMkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHN0cmljdCxcbiAgICAgIF9vcHRpb25zJHNlbnNpdGl2ZSA9IF9vcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIHNlbnNpdGl2ZSA9IF9vcHRpb25zJHNlbnNpdGl2ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRzZW5zaXRpdmU7XG5cbiAgdmFyIF9jb21waWxlUGF0aCA9IGNvbXBpbGVQYXRoKHBhdGgsIHsgZW5kOiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pLFxuICAgICAgcmUgPSBfY29tcGlsZVBhdGgucmUsXG4gICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgdmFyIG1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSk7XG5cbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG5cbiAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuXG4gIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLCAvLyB0aGUgcGF0aCBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2hcbiAgICB1cmw6IHBhdGggPT09ICcvJyAmJiB1cmwgPT09ICcnID8gJy8nIDogdXJsLCAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICBpc0V4YWN0OiBpc0V4YWN0LCAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICBtZW1vW2tleS5uYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSlcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG52YXIgaXNFbXB0eUNoaWxkcmVuID0gZnVuY3Rpb24gaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIHNpbmdsZSBwYXRoIGFuZCByZW5kZXJpbmcuXG4gKi9cblxudmFyIFJvdXRlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMsIF90aGlzLmNvbnRleHQucm91dGVyKVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUm91dGUucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHRoaXMuY29udGV4dC5yb3V0ZXIucm91dGUubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2g6IHRoaXMuc3RhdGUubWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2goX3JlZiwgcm91dGVyKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICAgIGV4YWN0ID0gX3JlZi5leGFjdCxcbiAgICAgICAgc2Vuc2l0aXZlID0gX3JlZi5zZW5zaXRpdmU7XG5cbiAgICBpZiAoY29tcHV0ZWRNYXRjaCkgcmV0dXJuIGNvbXB1dGVkTWF0Y2g7IC8vIDxTd2l0Y2g+IGFscmVhZHkgY29tcHV0ZWQgdGhlIG1hdGNoIGZvciB1c1xuXG4gICAgaW52YXJpYW50KHJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGU+IG9yIHdpdGhSb3V0ZXIoKSBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIHZhciByb3V0ZSA9IHJvdXRlci5yb3V0ZTtcblxuICAgIHZhciBwYXRobmFtZSA9IChsb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbikucGF0aG5hbWU7XG5cbiAgICByZXR1cm4gcGF0aCA/IG1hdGNoUGF0aChwYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBzdHJpY3Q6IHN0cmljdCwgZXhhY3Q6IGV4YWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9KSA6IHJvdXRlLm1hdGNoO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMucmVuZGVyKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5yZW5kZXIgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgcmVuZGVyPiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgIHdhcm5pbmcoIShuZXh0UHJvcHMubG9jYXRpb24gJiYgIXRoaXMucHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbWF0Y2g6IHRoaXMuY29tcHV0ZU1hdGNoKG5leHRQcm9wcywgbmV4dENvbnRleHQucm91dGVyKVxuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5zdGF0ZS5tYXRjaDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wcy5jb21wb25lbnQsXG4gICAgICAgIHJlbmRlciA9IF9wcm9wcy5yZW5kZXI7XG4gICAgdmFyIF9jb250ZXh0JHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXIsXG4gICAgICAgIGhpc3RvcnkgPSBfY29udGV4dCRyb3V0ZXIuaGlzdG9yeSxcbiAgICAgICAgcm91dGUgPSBfY29udGV4dCRyb3V0ZXIucm91dGUsXG4gICAgICAgIHN0YXRpY0NvbnRleHQgPSBfY29udGV4dCRyb3V0ZXIuc3RhdGljQ29udGV4dDtcblxuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMucHJvcHMubG9jYXRpb24gfHwgcm91dGUubG9jYXRpb247XG4gICAgdmFyIHByb3BzID0geyBtYXRjaDogbWF0Y2gsIGxvY2F0aW9uOiBsb2NhdGlvbiwgaGlzdG9yeTogaGlzdG9yeSwgc3RhdGljQ29udGV4dDogc3RhdGljQ29udGV4dCB9O1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudCA/IC8vIGNvbXBvbmVudCBwcm9wIGdldHMgZmlyc3QgcHJpb3JpdHksIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSA6IG51bGwgOiByZW5kZXIgPyAvLyByZW5kZXIgcHJvcCBpcyBuZXh0LCBvbmx5IGNhbGxlZCBpZiB0aGVyZSdzIGEgbWF0Y2hcbiAgICBtYXRjaCA/IHJlbmRlcihwcm9wcykgOiBudWxsIDogY2hpbGRyZW4gPyAvLyBjaGlsZHJlbiBjb21lIGxhc3QsIGFsd2F5cyBjYWxsZWRcbiAgICB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihwcm9wcykgOiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbCA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZS5wcm9wVHlwZXMgPSB7XG4gIGNvbXB1dGVkTWF0Y2g6IFByb3BUeXBlcy5vYmplY3QsIC8vIHByaXZhdGUsIGZyb20gPFN3aXRjaD5cbiAgcGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICBjb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5ub2RlXSksXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGUuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KVxufTtcblJvdXRlLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSb3V0ZSBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGUnO1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcbmltcG9ydCBMaW5rIGZyb20gJy4vTGluayc7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWYuYXJpYUN1cnJlbnQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG8nLCAnZXhhY3QnLCAnc3RyaWN0JywgJ2xvY2F0aW9uJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnc3R5bGUnLCAnaXNBY3RpdmUnLCAnYXJpYUN1cnJlbnQnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiAodHlwZW9mIHRvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0bykpID09PSAnb2JqZWN0JyA/IHRvLnBhdGhuYW1lIDogdG8sXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZjIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWYyLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoID0gX3JlZjIubWF0Y2g7XG5cbiAgICAgIHZhciBpc0FjdGl2ZSA9ICEhKGdldElzQWN0aXZlID8gZ2V0SXNBY3RpdmUobWF0Y2gsIGxvY2F0aW9uKSA6IG1hdGNoKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe1xuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNsYXNzTmFtZTogaXNBY3RpdmUgPyBbY2xhc3NOYW1lLCBhY3RpdmVDbGFzc05hbWVdLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5qb2luKCcgJykgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGUsXG4gICAgICAgICdhcmlhLWN1cnJlbnQnOiBpc0FjdGl2ZSAmJiBhcmlhQ3VycmVudFxuICAgICAgfSwgcmVzdCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5OYXZMaW5rLnByb3BUeXBlcyA9IHtcbiAgdG86IExpbmsucHJvcFR5cGVzLnRvLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBhY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBpc0FjdGl2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGFyaWFDdXJyZW50OiBQcm9wVHlwZXMub25lT2YoWydwYWdlJywgJ3N0ZXAnLCAnbG9jYXRpb24nLCAndHJ1ZSddKVxufTtcblxuTmF2TGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZScsXG4gIGFyaWFDdXJyZW50OiAndHJ1ZSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5hdkxpbms7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHByb21wdGluZyB0aGUgdXNlciBiZWZvcmUgbmF2aWdhdGluZyBhd2F5XG4gKiBmcm9tIGEgc2NyZWVuIHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxudmFyIFByb21wdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQcm9tcHQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFByb21wdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvbXB0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHRoaXMudW5ibG9jaygpO1xuXG4gICAgdGhpcy51bmJsb2NrID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5LmJsb2NrKG1lc3NhZ2UpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykge1xuICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICB0aGlzLnVuYmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8UHJvbXB0PiBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIGlmICh0aGlzLnByb3BzLndoZW4pIHRoaXMuZW5hYmxlKHRoaXMucHJvcHMubWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLndoZW4pIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy53aGVuIHx8IHRoaXMucHJvcHMubWVzc2FnZSAhPT0gbmV4dFByb3BzLm1lc3NhZ2UpIHRoaXMuZW5hYmxlKG5leHRQcm9wcy5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUHJvbXB0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Qcm9tcHQucHJvcFR5cGVzID0ge1xuICB3aGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgbWVzc2FnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKS5pc1JlcXVpcmVkXG59O1xuUHJvbXB0LmRlZmF1bHRQcm9wcyA9IHtcbiAgd2hlbjogdHJ1ZVxufTtcblByb21wdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgYmxvY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBQcm9tcHQgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1Byb21wdCc7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJleHBvcnQgdmFyIGFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxuZXhwb3J0IHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHJlc29sdmVQYXRobmFtZSBmcm9tICdyZXNvbHZlLXBhdGhuYW1lJztcbmltcG9ydCB2YWx1ZUVxdWFsIGZyb20gJ3ZhbHVlLWVxdWFsJztcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuZXhwb3J0IHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gcmVzb2x2ZVBhdGhuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG5leHBvcnQgdmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmIHZhbHVlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0xvY2F0aW9uVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgIHdhcm5pbmcocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJleHBvcnQgdmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbmV4cG9ydCB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIGdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5leHBvcnQgdmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0hpc3RvcnksIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UsIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICFzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmIChpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCB7IGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgZW50cnkua2V5IHx8IGNyZWF0ZUtleSgpKTtcbiAgfSk7XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuXG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIGhpc3RvcnkuZW50cmllc1toaXN0b3J5LmluZGV4XSA9IGxvY2F0aW9uO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChoaXN0b3J5LmluZGV4ICsgbiwgMCwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aCAtIDEpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgIHZhciBsb2NhdGlvbiA9IGhpc3RvcnkuZW50cmllc1tuZXh0SW5kZXhdO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChvaykge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNaW1pYyB0aGUgYmVoYXZpb3Igb2YgRE9NIGhpc3RvcmllcyBieVxuICAgICAgICAvLyBjYXVzaW5nIGEgcmVuZGVyIGFmdGVyIGEgY2FuY2VsbGVkIFBPUC5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGNhbkdvID0gZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBoaXN0b3J5LmluZGV4ICsgbjtcbiAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgJiYgbmV4dEluZGV4IDwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBlbnRyaWVzLmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBlbnRyaWVzW2luZGV4XSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgZW50cmllczogZW50cmllcyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY2FuR286IGNhbkdvLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTWVtb3J5SGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICdoaXN0b3J5JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgdXBkYXRpbmcgdGhlIGxvY2F0aW9uIHByb2dyYW1tYXRpY2FsbHlcbiAqIHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlZGlyZWN0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZWRpcmVjdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXJlY3QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBSZWRpcmVjdC5wcm90b3R5cGUuaXNTdGF0aWMgPSBmdW5jdGlvbiBpc1N0YXRpYygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJvdXRlciAmJiB0aGlzLmNvbnRleHQucm91dGVyLnN0YXRpY0NvbnRleHQ7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8UmVkaXJlY3Q+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgaWYgKHRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIHByZXZUbyA9IGNyZWF0ZUxvY2F0aW9uKHByZXZQcm9wcy50byk7XG4gICAgdmFyIG5leHRUbyA9IGNyZWF0ZUxvY2F0aW9uKHRoaXMucHJvcHMudG8pO1xuXG4gICAgaWYgKGxvY2F0aW9uc0FyZUVxdWFsKHByZXZUbywgbmV4dFRvKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1lvdSB0cmllZCB0byByZWRpcmVjdCB0byB0aGUgc2FtZSByb3V0ZSB5b3VcXCdyZSBjdXJyZW50bHkgb246ICcgKyAoJ1wiJyArIG5leHRUby5wYXRobmFtZSArIG5leHRUby5zZWFyY2ggKyAnXCInKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiBwZXJmb3JtKCkge1xuICAgIHZhciBoaXN0b3J5ID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5O1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBwdXNoID0gX3Byb3BzLnB1c2gsXG4gICAgICAgIHRvID0gX3Byb3BzLnRvO1xuXG5cbiAgICBpZiAocHVzaCkge1xuICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICB9XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUmVkaXJlY3Q7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJlZGlyZWN0LnByb3BUeXBlcyA9IHtcbiAgcHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGZyb206IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxufTtcblJlZGlyZWN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgcHVzaDogZmFsc2Vcbn07XG5SZWRpcmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSZWRpcmVjdCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBjcmVhdGVQYXRoLCBwYXJzZVBhdGggfSBmcm9tICdoaXN0b3J5L1BhdGhVdGlscyc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxudmFyIG5vcm1hbGl6ZUxvY2F0aW9uID0gZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24ob2JqZWN0KSB7XG4gIHZhciBfb2JqZWN0JHBhdGhuYW1lID0gb2JqZWN0LnBhdGhuYW1lLFxuICAgICAgcGF0aG5hbWUgPSBfb2JqZWN0JHBhdGhuYW1lID09PSB1bmRlZmluZWQgPyAnLycgOiBfb2JqZWN0JHBhdGhuYW1lLFxuICAgICAgX29iamVjdCRzZWFyY2ggPSBvYmplY3Quc2VhcmNoLFxuICAgICAgc2VhcmNoID0gX29iamVjdCRzZWFyY2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRzZWFyY2gsXG4gICAgICBfb2JqZWN0JGhhc2ggPSBvYmplY3QuaGFzaCxcbiAgICAgIGhhc2ggPSBfb2JqZWN0JGhhc2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRoYXNoO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxudmFyIGFkZEJhc2VuYW1lID0gZnVuY3Rpb24gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSkgKyBsb2NhdGlvbi5wYXRobmFtZVxuICB9KTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHZhciBiYXNlID0gYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKTtcblxuICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlKSAhPT0gMCkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyKGJhc2UubGVuZ3RoKVxuICB9KTtcbn07XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKGxvY2F0aW9uKSA6IG5vcm1hbGl6ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbn07XG5cbnZhciBjcmVhdGVVUkwgPSBmdW5jdGlvbiBjcmVhdGVVUkwobG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufTtcblxudmFyIHN0YXRpY0hhbmRsZXIgPSBmdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdZb3UgY2Fubm90ICVzIHdpdGggPFN0YXRpY1JvdXRlcj4nLCBtZXRob2ROYW1lKTtcbiAgfTtcbn07XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgdG9wLWxldmVsIEFQSSBmb3IgYSBcInN0YXRpY1wiIDxSb3V0ZXI+LCBzby1jYWxsZWQgYmVjYXVzZSBpdFxuICogY2FuJ3QgYWN0dWFsbHkgY2hhbmdlIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBJbnN0ZWFkLCBpdCBqdXN0IHJlY29yZHNcbiAqIGxvY2F0aW9uIGNoYW5nZXMgaW4gYSBjb250ZXh0IG9iamVjdC4gVXNlZnVsIG1haW5seSBpbiB0ZXN0aW5nIGFuZFxuICogc2VydmVyLXJlbmRlcmluZyBzY2VuYXJpb3MuXG4gKi9cblxudmFyIFN0YXRpY1JvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdGF0aWNSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRpY1JvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRpY1JvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1NsYXNoKF90aGlzLnByb3BzLmJhc2VuYW1lICsgY3JlYXRlVVJMKHBhdGgpKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wcy5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9ICdQVVNIJztcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZVJlcGxhY2UgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzMi5iYXNlbmFtZSxcbiAgICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMyLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IHtcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5jb250ZXh0XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8U3RhdGljUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IFN0YXRpY1JvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGJhc2VuYW1lID0gX3Byb3BzLmJhc2VuYW1lLFxuICAgICAgICBjb250ZXh0ID0gX3Byb3BzLmNvbnRleHQsXG4gICAgICAgIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnYmFzZW5hbWUnLCAnY29udGV4dCcsICdsb2NhdGlvbiddKTtcblxuICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgY3JlYXRlSHJlZjogdGhpcy5jcmVhdGVIcmVmLFxuICAgICAgYWN0aW9uOiAnUE9QJyxcbiAgICAgIGxvY2F0aW9uOiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpLFxuICAgICAgcHVzaDogdGhpcy5oYW5kbGVQdXNoLFxuICAgICAgcmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgZ286IHN0YXRpY0hhbmRsZXIoJ2dvJyksXG4gICAgICBnb0JhY2s6IHN0YXRpY0hhbmRsZXIoJ2dvQmFjaycpLFxuICAgICAgZ29Gb3J3YXJkOiBzdGF0aWNIYW5kbGVyKCdnb0ZvcndhcmQnKSxcbiAgICAgIGxpc3RlbjogdGhpcy5oYW5kbGVMaXN0ZW4sXG4gICAgICBibG9jazogdGhpcy5oYW5kbGVCbG9ja1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBoaXN0b3J5OiBoaXN0b3J5IH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5TdGF0aWNSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG59O1xuU3RhdGljUm91dGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgYmFzZW5hbWU6ICcnLFxuICBsb2NhdGlvbjogJy8nXG59O1xuU3RhdGljUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxTd2l0Y2g+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcblxuICAgIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgICAgY2hpbGQgPSB2b2lkIDA7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHJldHVybjtcblxuICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICBwYXRoUHJvcCA9IF9lbGVtZW50JHByb3BzLnBhdGgsXG4gICAgICAgICAgZXhhY3QgPSBfZWxlbWVudCRwcm9wcy5leGFjdCxcbiAgICAgICAgICBzdHJpY3QgPSBfZWxlbWVudCRwcm9wcy5zdHJpY3QsXG4gICAgICAgICAgc2Vuc2l0aXZlID0gX2VsZW1lbnQkcHJvcHMuc2Vuc2l0aXZlLFxuICAgICAgICAgIGZyb20gPSBfZWxlbWVudCRwcm9wcy5mcm9tO1xuXG4gICAgICB2YXIgcGF0aCA9IHBhdGhQcm9wIHx8IGZyb207XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gZWxlbWVudDtcbiAgICAgICAgbWF0Y2ggPSBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIGV4YWN0OiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgbG9jYXRpb246IGxvY2F0aW9uLCBjb21wdXRlZE1hdGNoOiBtYXRjaCB9KSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3dpdGNoLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBTd2l0Y2ggZnJvbSAncmVhY3Qtcm91dGVyL2VzL1N3aXRjaCc7XG5cbmV4cG9ydCBkZWZhdWx0IFN3aXRjaDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoJztcblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL21hdGNoUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcblxuLyoqXG4gKiBBIHB1YmxpYyBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRvIGFjY2VzcyB0aGUgaW1wZXJhdGl2ZSBBUElcbiAqL1xudmFyIHdpdGhSb3V0ZXIgPSBmdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvbmVudCkge1xuICB2YXIgQyA9IGZ1bmN0aW9uIEMocHJvcHMpIHtcbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudFJlZiA9IHByb3BzLndyYXBwZWRDb21wb25lbnRSZWYsXG4gICAgICAgIHJlbWFpbmluZ1Byb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbJ3dyYXBwZWRDb21wb25lbnRSZWYnXSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwgeyByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyb3V0ZUNvbXBvbmVudFByb3BzKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHJlbWFpbmluZ1Byb3BzLCByb3V0ZUNvbXBvbmVudFByb3BzLCB7IHJlZjogd3JhcHBlZENvbXBvbmVudFJlZiB9KSk7XG4gICAgICB9IH0pO1xuICB9O1xuXG4gIEMuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgKENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSkgKyAnKSc7XG4gIEMuV3JhcHBlZENvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgQy5wcm9wVHlwZXMgPSB7XG4gICAgd3JhcHBlZENvbXBvbmVudFJlZjogUHJvcFR5cGVzLmZ1bmNcbiAgfTtcblxuICByZXR1cm4gaG9pc3RTdGF0aWNzKEMsIENvbXBvbmVudCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgd2l0aFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvd2l0aFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCBfQnJvd3NlclJvdXRlciBmcm9tICcuL0Jyb3dzZXJSb3V0ZXInO1xuZXhwb3J0IHsgX0Jyb3dzZXJSb3V0ZXIgYXMgQnJvd3NlclJvdXRlciB9O1xuaW1wb3J0IF9IYXNoUm91dGVyIGZyb20gJy4vSGFzaFJvdXRlcic7XG5leHBvcnQgeyBfSGFzaFJvdXRlciBhcyBIYXNoUm91dGVyIH07XG5pbXBvcnQgX0xpbmsgZnJvbSAnLi9MaW5rJztcbmV4cG9ydCB7IF9MaW5rIGFzIExpbmsgfTtcbmltcG9ydCBfTWVtb3J5Um91dGVyIGZyb20gJy4vTWVtb3J5Um91dGVyJztcbmV4cG9ydCB7IF9NZW1vcnlSb3V0ZXIgYXMgTWVtb3J5Um91dGVyIH07XG5pbXBvcnQgX05hdkxpbmsgZnJvbSAnLi9OYXZMaW5rJztcbmV4cG9ydCB7IF9OYXZMaW5rIGFzIE5hdkxpbmsgfTtcbmltcG9ydCBfUHJvbXB0IGZyb20gJy4vUHJvbXB0JztcbmV4cG9ydCB7IF9Qcm9tcHQgYXMgUHJvbXB0IH07XG5pbXBvcnQgX1JlZGlyZWN0IGZyb20gJy4vUmVkaXJlY3QnO1xuZXhwb3J0IHsgX1JlZGlyZWN0IGFzIFJlZGlyZWN0IH07XG5pbXBvcnQgX1JvdXRlIGZyb20gJy4vUm91dGUnO1xuZXhwb3J0IHsgX1JvdXRlIGFzIFJvdXRlIH07XG5pbXBvcnQgX1JvdXRlciBmcm9tICcuL1JvdXRlcic7XG5leHBvcnQgeyBfUm91dGVyIGFzIFJvdXRlciB9O1xuaW1wb3J0IF9TdGF0aWNSb3V0ZXIgZnJvbSAnLi9TdGF0aWNSb3V0ZXInO1xuZXhwb3J0IHsgX1N0YXRpY1JvdXRlciBhcyBTdGF0aWNSb3V0ZXIgfTtcbmltcG9ydCBfU3dpdGNoIGZyb20gJy4vU3dpdGNoJztcbmV4cG9ydCB7IF9Td2l0Y2ggYXMgU3dpdGNoIH07XG5pbXBvcnQgX21hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5leHBvcnQgeyBfbWF0Y2hQYXRoIGFzIG1hdGNoUGF0aCB9O1xuaW1wb3J0IF93aXRoUm91dGVyIGZyb20gJy4vd2l0aFJvdXRlcic7XG5leHBvcnQgeyBfd2l0aFJvdXRlciBhcyB3aXRoUm91dGVyIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcy9iaW5kJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9idXR0b24uc2Nzcyc7XG5cbmNvbnN0IGN4ID0gY2xhc3NuYW1lcy5iaW5kKHN0eWxlKTtcblxudHlwZSBUQnV0dG9uUHJvcHMgPSBKU1guSFRNTEF0dHJpYnV0ZXMgJiB7XG4gIHNlY29uZGFyeT86IGJvb2xlYW47XG59O1xuXG5jb25zdCBCdXR0b24gPSAoeyBjbGFzczogY2xhc3NOYW1lLCBzZWNvbmRhcnkgPSBmYWxzZSwgLi4ucmVzdFByb3BzIH06IFRCdXR0b25Qcm9wcykgPT4gKFxuICA8YnV0dG9uIGNsYXNzPXtjeChzdHlsZS5zZWxmLCBjbGFzc05hbWUsIHsgcHJpbWFyeTogIXNlY29uZGFyeSwgc2Vjb25kYXJ5IH0pfSB7Li4ucmVzdFByb3BzfSAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0J1dHRvbi50c3giLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuaW1wb3J0IEJ1dHRvbiBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvQnV0dG9uJztcblxuY29uc3QgSG9tZSA9ICgpID0+IChcbiAgPGRpdj5cbiAgICA8TGluayB0bz1cIi93aGl0ZWxpc3RcIj48QnV0dG9uPldoaXRlbGlzdDwvQnV0dG9uPjwvTGluaz5cbiAgICA8TGluayB0bz1cIi9zdGF0dXNcIj48QnV0dG9uPlN0YXR1czwvQnV0dG9uPjwvTGluaz5cbiAgICA8TGluayB0bz1cIi9saW5rbGlzdFwiPjxCdXR0b24+TGlua0xpc3Q8L0J1dHRvbj48L0xpbms+XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgSG9tZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wYWdlcy9Ib21lLnRzeCIsImltcG9ydCAqIGFzIFdlYjMgZnJvbSAnd2ViMyc7XG5cbmxldCB3ZWIzO1xuXG5pZiAodHlwZW9mIHdpbmRvdy53ZWIzICE9PSAndW5kZWZpbmVkJykge1xuICB3ZWIzID0gbmV3IFdlYjMod2luZG93LndlYjMuY3VycmVudFByb3ZpZGVyKTtcbn0gZWxzZSB7XG4gIHdlYjMgPSBuZXcgV2ViMygpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB3ZWIzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL3V0aWxzL3NyYy93ZWIzLnRzIiwiXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuZXhwb3J0IGNvbnN0IG1vYmlsZU9yVGFibGV0ID0gKCkgPT4ge1xuICB2YXIgY2hlY2sgPSBmYWxzZTtcbiAgKGZ1bmN0aW9uKGEpe2lmKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm98YW5kcm9pZHxpcGFkfHBsYXlib29rfHNpbGsvaS50ZXN0KGEpfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KGEuc3Vic3RyKDAsNCkpKSBjaGVjayA9IHRydWU7fSkobmF2aWdhdG9yLnVzZXJBZ2VudHx8bmF2aWdhdG9yLnZlbmRvcnx8d2luZG93Lm9wZXJhKTtcbiAgcmV0dXJuIGNoZWNrO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvdXRpbHMvc3JjL3VzZXJBZ2VudC50cyIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgeyBJTGluayB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9saW5rLnNjc3MnO1xuXG5jb25zdCBjeCA9IGNsYXNzbmFtZXMuYmluZChzdHlsZSk7XG5cbmludGVyZmFjZSBJTGlua1Byb3BzIHtcbiAgbGluazogSUxpbms7XG4gIGNsYXNzPzogc3RyaW5nO1xuICBsaW5lcz86IG51bWJlcjtcbiAgc3R5bGU/OiBzdHJpbmcgfCB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgc3RyaW5nfTtcbn1cblxuY29uc3Qgc3RvcFByb3BhZ2F0aW9uID0gKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbmNvbnN0IExpbmsgPSAoeyBjbGFzczogY2xhc3NOYW1lLCBsaW5rLCBsaW5lcyA9IDIsIHN0eWxlOiBleHRlcm5hbFN0eWxlIH06IElMaW5rUHJvcHMpID0+IHtcbiAgaWYgKCEobGluZXMgPT09IDIgfHwgbGluZXMgPT09IDgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDIgYW5kIDggbGluZXMgbGlua3MgYXJlIGF2YWlsYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPXtjbGFzc25hbWVzKHN0eWxlLnNlbGYsIGNsYXNzTmFtZSl9IHN0eWxlPXtleHRlcm5hbFN0eWxlfT5cbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnRpdGxlfT57bGluay50aXRsZX08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9e2N4KCdzdW1tYXJ5JywgeyBsaW5lczI6IGxpbmVzID09PSAyLCBsaW5lczg6IGxpbmVzID09PSA4IH0pfT57bGluay5zdW1tYXJ5fTwvZGl2PlxuICAgICAgPGFcbiAgICAgICAgY2xhc3M9e3N0eWxlLmxpbmt9XG4gICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgIGhyZWY9e2xpbmsudGFyZ2V0fVxuICAgICAgICBvbkNsaWNrPXtzdG9wUHJvcGFnYXRpb259XG4gICAgICA+XG4gICAgICAgIHtsaW5rLnRhcmdldH1cbiAgICAgIDwvYT5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExpbms7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGluay50c3giLCJpbXBvcnQgeyBoLCBGdW5jdGlvbmFsQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vcGFwZXIuc2Nzcyc7XG5cbmNvbnN0IFBhcGVyOiBGdW5jdGlvbmFsQ29tcG9uZW50PEpTWC5IVE1MQXR0cmlidXRlcz4gPSAoeyBjbGFzczogY2xhc3NOYW1lLCAuLi5yZXN0UHJvcHMgfSkgPT4gKFxuICA8ZGl2IHsuLi5yZXN0UHJvcHN9IGNsYXNzPXtjbGFzc25hbWVzKGNsYXNzTmFtZSwgc3R5bGUuc2VsZil9IC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBQYXBlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9QYXBlci50c3giLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vbG9hZGVyLnNjc3MnO1xuXG5pbnRlcmZhY2UgSUxvYWRlclByb3BzIHtcbiAgY2xhc3M/OiBzdHJpbmc7XG59XG5cbmNvbnN0IExvYWRlciA9ICh7IGNsYXNzOiBjbGFzc05hbWV9OiBJTG9hZGVyUHJvcHMpID0+IHtcbiAgcmV0dXJuIDxkaXYgY2xhc3M9e2NsYXNzbmFtZXMoc3R5bGUuc2VsZiwgY2xhc3NOYW1lKX0gLz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2FkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTG9hZGVyLnRzeCIsImltcG9ydCB7IGgsIEZ1bmN0aW9uYWxDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2xhYmVsLnNjc3MnO1xuXG5jb25zdCBMYWJlbDogRnVuY3Rpb25hbENvbXBvbmVudDx7fT4gPSAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIDxwIGNsYXNzPXtzdHlsZS5zZWxmfT57cHJvcHMuY2hpbGRyZW59PC9wPjtcbiAgfVxuXG4gIHJldHVybiA8cCBjbGFzcz17c3R5bGUuc2VsZn0gLz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYWJlbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9MYWJlbC50c3giLCJpbXBvcnQgeyBoLCBGdW5jdGlvbmFsQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vdGV4dFdpdGhMYWJlbC5zY3NzJztcblxuaW1wb3J0IExhYmVsIGZyb20gJy4vTGFiZWwnO1xuXG5pbnRlcmZhY2UgSVRleHRXaXRoTGFiZWxQcm9wcyB7XG4gIGxhYmVsOiBzdHJpbmcgfEpTWC5FbGVtZW50O1xuICB0ZXh0Pzogc3RyaW5nIHwgbnVtYmVyO1xuICBjbGFzcz86IHN0cmluZztcbn1cblxuY29uc3QgVGV4dFdpdGhMYWJlbDogRnVuY3Rpb25hbENvbXBvbmVudDxJVGV4dFdpdGhMYWJlbFByb3BzPiA9ICh7IGxhYmVsLCB0ZXh0LCBjbGFzczogY2xhc3NOYW1lLCBjaGlsZHJlbiB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz17Y2xhc3NuYW1lcyhzdHlsZS5zZWxmLCBjbGFzc05hbWUpfT5cbiAgICAgIDxMYWJlbD57bGFiZWx9PC9MYWJlbD5cbiAgICAgIDxwIGNsYXNzPXtzdHlsZS50ZXh0fT57dGV4dCB8fCBjaGlsZHJlbn08L3A+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0V2l0aExhYmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1RleHRXaXRoTGFiZWwudHN4IiwiaW1wb3J0IHsgaCwgRnVuY3Rpb25hbENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IGdldFN2Z0NvbnRlbnRSZWd4cCA9IC88c3ZnW14+XSo+KC4qKTxcXC9zdmc+LztcblxuaW50ZXJmYWNlIElTdmdQcm9wcyB7XG4gIGNsYXNzPzogc3RyaW5nO1xuICBzdmc6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyIHwgc3RyaW5nO1xuICB2aWV3Qm94OiBzdHJpbmc7XG59XG5cbmNvbnN0IFN2ZyA9ICh7IHN2Zywgc2l6ZSwgdmlld0JveCwgY2xhc3M6IGNsYXNzTmFtZSB9OiBJU3ZnUHJvcHMpID0+IHtcbiAgbGV0IHN2Z0NvbnRlbnQ7XG4gIGNvbnN0IHJlZ2V4cFJlc3VsdCA9IGdldFN2Z0NvbnRlbnRSZWd4cC5leGVjKHN2Zyk7XG4gIGlmIChyZWdleHBSZXN1bHQpIHtcbiAgICBzdmdDb250ZW50ID0gcmVnZXhwUmVzdWx0WzFdO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzcz17Y2xhc3NOYW1lfVxuICAgICAgc3R5bGU9e3sgd2lkdGg6IHNpemUgfX1cbiAgICAgIGFsdD17bmFtZX1cbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogc3ZnQ29udGVudCB9fVxuICAgICAgdmlld0JveD17dmlld0JveH1cbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgIC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTdmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvU3ZnLnRzeCIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCAnb3Blbi1pY29uaWMvZm9udC9jc3Mvb3Blbi1pY29uaWMubWluLmNzcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vaWNvbi5zY3NzJztcblxuaW50ZXJmYWNlIElJY29uUHJvcHMge1xuICBuYW1lOiBzdHJpbmc7XG4gIGNsYXNzPzogc3RyaW5nO1xufVxuXG5jb25zdCBJY29uID0gKHsgbmFtZSwgY2xhc3M6IGNsYXNzTmFtZSwgLi4ucmVzdFByb3BzIH06IElJY29uUHJvcHMpID0+IChcbiAgPHNwYW4gY2xhc3M9e2NsYXNzbmFtZXMoc3R5bGUuc2VsZiwgY2xhc3NOYW1lLCAnb2knKX0gZGF0YS1nbHlwaD17bmFtZX0gYXJpYS1oaWRkZW49XCJ0cnVlXCIgey4uLnJlc3RQcm9wc30gLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvSWNvbi50c3giLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vdG9vbHRpcC5zY3NzJztcblxuaW50ZXJmYWNlIElUb29sdGlwUHJvcHMge1xuICB0ZXh0Pzogc3RyaW5nO1xuICBjaGlsZHJlbj86IEpTWC5FbGVtZW50O1xuICBjbGFzcz86IHN0cmluZztcbiAgc3R5bGU/OiBzdHJpbmcgfCB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IHN0cmluZyB9O1xufVxuXG5jb25zdCBUb29sdGlwID0gKHsgY2xhc3M6IGNsYXNzTmFtZSwgc3R5bGU6IGV4dGVybmFsU3R5bGUsIHRleHQsIGNoaWxkcmVuIH06IElUb29sdGlwUHJvcHMpID0+IChcbiAgPGRpdiBzdHlsZT17ZXh0ZXJuYWxTdHlsZX0gY2xhc3M9e2NsYXNzbmFtZXMoc3R5bGUuc2VsZiwgY2xhc3NOYW1lKX0+XG4gICAge2NoaWxkcmVufVxuICAgIHt0ZXh0ICYmIDxkaXYgY2xhc3M9e3N0eWxlLnRleHR9Pnt0ZXh0fTwvZGl2Pn1cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1Rvb2x0aXAudHN4IiwiaW1wb3J0IHsgaCwgRnVuY3Rpb25hbENvbXBvbmVudCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcy9iaW5kJztcblxuaW1wb3J0IFN2ZyBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvU3ZnJztcbmltcG9ydCBJY29uIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9JY29uJztcbmltcG9ydCBUb29sdGlwIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9Ub29sdGlwJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9zdGVwcy5zY3NzJztcbmNvbnN0IGN4ID0gY2xhc3NuYW1lcy5iaW5kKHN0eWxlKTtcblxuY29uc3QgY3ViZVN2ZyA9IHJlcXVpcmUoJyEhc3ZnLWlubGluZS1sb2FkZXI/cmVtb3ZlVGFncz10cnVlJnJlbW92ZVNWR1RhZ0F0dHJzPXRydWUhLi4vLi4vLi4vLi4vaW1hZ2VzL2N1YmUuc3ZnJyk7XG5cbmludGVyZmFjZSBJU3RlcFByb3BzIHtcbiAgaWNvbjogSlNYLkVsZW1lbnQ7XG4gIHN0YXRlOiAnZGlzYWJsZWQnIHwgJ25vdHN0YXJ0ZWQnIHwgJ3dhaXRpbmcnIHwgJ2RvbmUnO1xufVxuXG5jb25zdCBTdGVwOiBGdW5jdGlvbmFsQ29tcG9uZW50PElTdGVwUHJvcHM+ID0gKHsgaWNvbiwgc3RhdGUsIGNoaWxkcmVuIH0pID0+IChcbiAgPGRpdiBjbGFzcz17Y3goc3R5bGUuc3RlcCwgeyBbc3RhdGVdOiB0cnVlIH0pfT5cbiAgICA8ZGl2IGNsYXNzPXtzdHlsZS5pY29ufT57aWNvbn08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPXtzdHlsZS5jb250ZW50fT57Y2hpbGRyZW59PC9kaXY+XG4gIDwvZGl2PlxuKTtcblxuY29uc3QgUHJvZ3Jlc3MgPSAoeyBzdGVwMFN0YXRlLCBzdGVwMVN0YXRlLCBzdGVwMlN0YXRlLFxuICBzdGVwMFJlZiwgc3RlcDFSZWYsIHN0ZXAyUmVmIH0pID0+IHtcblxuICBjb25zdCBsYXN0RG9uZVN0ZXAgPSBbc3RlcDJTdGF0ZSwgc3RlcDFTdGF0ZSwgc3RlcDBTdGF0ZV0uaW5kZXhPZignZG9uZScpO1xuICBjb25zdCBsYXN0RG9uZUVsZW1lbnQgPSBbc3RlcDJSZWYsIHN0ZXAxUmVmLCBzdGVwMFJlZl1bbGFzdERvbmVTdGVwXTtcblxuICBjb25zdCBmaWxsU3R5bGUgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIG1heFdpZHRoOiAwLFxuICAgIG1heEhlaWdodDogMCxcbiAgfTtcblxuICBpZiAobGFzdERvbmVFbGVtZW50KSB7XG4gICAgY29uc3Qgcm93RGlyZWN0aW9uID0gc3RlcDBSZWYuYmFzZS5vZmZzZXRUb3AgPT09IHN0ZXAxUmVmLmJhc2Uub2Zmc2V0VG9wO1xuXG4gICAgZmlsbFN0eWxlLndpZHRoID0gZmlsbFN0eWxlLm1heFdpZHRoID0gcm93RGlyZWN0aW9uXG4gICAgICA/IGxhc3REb25lRWxlbWVudC5iYXNlLm9mZnNldExlZnQgKyBsYXN0RG9uZUVsZW1lbnQuYmFzZS5vZmZzZXRXaWR0aCAvIDJcbiAgICAgIDogJzEwMCUnO1xuXG4gICAgZmlsbFN0eWxlLmhlaWdodCA9IGZpbGxTdHlsZS5tYXhIZWlnaHQgPSAhcm93RGlyZWN0aW9uXG4gICAgICA/IGxhc3REb25lRWxlbWVudC5iYXNlLm9mZnNldFRvcCArIGxhc3REb25lRWxlbWVudC5iYXNlLm9mZnNldEhlaWdodCAvIDJcbiAgICAgIDogJzEwMCUnO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPXtzdHlsZS5wcm9ncmVzc0NvdGFpbmVyfT5cbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnByb2dyZXNzfT5cbiAgICAgICAgPGRpdiBjbGFzcz17c3R5bGUucHJvZ3Jlc3NGaWxsfSBzdHlsZT17ZmlsbFN0eWxlfSAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5pbnRlcmZhY2UgSVN0ZXBzUHJvcHMge1xuICBjb250ZXh0OiBzdHJpbmc7XG4gIGxpbmtJZDogc3RyaW5nO1xuICBsaW5rPzogYW55O1xuICBibG9ja2NoYWluU3RhdGU6IHtcbiAgICB3ZWIzQXZhaWxhYmxlOiBib29sZWFuO1xuICAgIGJsb2NrTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICAgIGN1cnJlbnRCbG9ja051bWJlcjogbnVtYmVyIHwgbnVsbDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RlcHMgZXh0ZW5kcyBDb21wb25lbnQ8SVN0ZXBzUHJvcHMsIHt9PiB7XG5cbiAgc3RlcDBSZWY6IEpTWC5FbGVtZW50IHwgdW5kZWZpbmVkO1xuICBzdGVwMVJlZjogSlNYLkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gIHN0ZXAyUmVmOiBKU1guRWxlbWVudCB8IHVuZGVmaW5lZDtcblxuICByZW5kZXIoeyBjb250ZXh0LCBsaW5rSWQsIGxpbmssIGJsb2NrY2hhaW5TdGF0ZSB9OiBJU3RlcHNQcm9wcykge1xuICAgIGxldCBzdGVwMFN0YXRlO1xuICAgIGxldCBzdGVwMFJlYXNvbjtcblxuICAgIGlmIChsaW5rKSB7XG4gICAgICBzdGVwMFN0YXRlID0gJ2RvbmUnO1xuICAgIH0gZWxzZSBpZiAoYmxvY2tjaGFpblN0YXRlLndlYjNBdmFpbGFibGUpIHtcbiAgICAgIGlmIChibG9ja2NoYWluU3RhdGUuYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgc3RlcDBTdGF0ZSA9ICdkb25lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAwU3RhdGUgPSAnd2FpdGluZyc7XG4gICAgICAgIHN0ZXAwUmVhc29uID0gJ1dhaXRpbmcgZm9yIGJsb2NrY2hhaW4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwMFN0YXRlID0gJ2Rpc2FibGVkJztcbiAgICAgIHN0ZXAwUmVhc29uID0gJ1dlYiBpcyB1bmF2YWlsYWJsZSc7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RlcDFTdGF0ZSA9IHN0ZXAwU3RhdGUgPT09ICd3YWl0aW5nJ1xuICAgICAgPyAnbm90c3RhcnRlZCdcbiAgICAgIDogbGluayA/ICdkb25lJyA6ICd3YWl0aW5nJztcblxuICAgIGNvbnN0IHN0ZXAyU3RhdGUgPSBzdGVwMVN0YXRlID09PSAnd2FpdGluZycgfHwgc3RlcDFTdGF0ZSA9PT0gJ25vdHN0YXJ0ZWQnXG4gICAgICA/ICdub3RzdGFydGVkJ1xuICAgICAgOiBsaW5rICYmIGxpbmsud2hpdGVsaXN0ZWQgPyAnZG9uZScgOiAnd2FpdGluZyc7XG5cbiAgICBjb25zdCBbbmV0d29ya10gPSBjb250ZXh0LnNwbGl0KCc6Jyk7XG4gICAgY29uc3QgbmV0d29ya1ByZWZpeCA9IG5ldHdvcmsgIT09ICdldGgnID8gYCR7bmV0d29ya30uYCA6ICcnO1xuICAgIGNvbnN0IFssIHR4XSA9IGxpbmtJZC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IGV0aGVyc2NhblVybCA9IGxpbmsgPyBgaHR0cHM6Ly8ke25ldHdvcmtQcmVmaXh9ZXRoZXJzY2FuLmlvL3R4LyR7dHh9YCA6ICcnO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgICAgICA8UHJvZ3Jlc3NcbiAgICAgICAgICBzdGVwMFN0YXRlPXtzdGVwMFN0YXRlfVxuICAgICAgICAgIHN0ZXAxU3RhdGU9e3N0ZXAxU3RhdGV9XG4gICAgICAgICAgc3RlcDJTdGF0ZT17c3RlcDJTdGF0ZX1cbiAgICAgICAgICBzdGVwMFJlZj17dGhpcy5zdGVwMFJlZn1cbiAgICAgICAgICBzdGVwMVJlZj17dGhpcy5zdGVwMVJlZn1cbiAgICAgICAgICBzdGVwMlJlZj17dGhpcy5zdGVwMlJlZn1cbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBjbGFzcz17c3R5bGUuc3RlcHNDb250YWluZXJ9PlxuICAgICAgICAgIDxTdGVwXG4gICAgICAgICAgICByZWY9e3RoaXMuX29uUmVmKCdzdGVwMFJlZicpfVxuICAgICAgICAgICAgc3RhdGU9e3N0ZXAwU3RhdGV9XG4gICAgICAgICAgICBpY29uPXs8VG9vbHRpcCB0ZXh0PXtzdGVwMFJlYXNvbn0+PEljb24gY2xhc3M9e3N0eWxlLmljb259IG5hbWU9XCJleWVcIiAvPjwvVG9vbHRpcD59XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHA+VmlzaWJsZSBvbiBibG9ja2NoYWluPC9wPlxuICAgICAgICAgICAgPGEgaHJlZj17ZXRoZXJzY2FuVXJsfSB0YXJnZXQ9XCJfYmxhbmtcIj5FdGhlcnNjYW4gPEljb24gbmFtZT1cImV4dGVybmFsLWxpbmtcIiAvPjwvYT5cbiAgICAgICAgICA8L1N0ZXA+XG4gICAgICAgICAgPFN0ZXBcbiAgICAgICAgICAgIHJlZj17dGhpcy5fb25SZWYoJ3N0ZXAxUmVmJyl9XG4gICAgICAgICAgICBzdGF0ZT17c3RlcDFTdGF0ZX1cbiAgICAgICAgICAgIGljb249ezxTdmcgc3ZnPXtjdWJlU3ZnfSBzaXplPVwiMS4yZW1cIiB2aWV3Qm94PVwiMCAwIDIzIDI3XCIgLz59XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHA+VXNlcmZlZWRzIEFkZHJlc3M8L3A+XG4gICAgICAgICAgICA8c3Bhbj5WaXNpYmxlIHRvIHB1Ymxpc2hlcjwvc3Bhbj5cbiAgICAgICAgICA8L1N0ZXA+XG4gICAgICAgICAgPFN0ZXBcbiAgICAgICAgICAgIHJlZj17dGhpcy5fb25SZWYoJ3N0ZXAyUmVmJyl9XG4gICAgICAgICAgICBzdGF0ZT17c3RlcDJTdGF0ZX1cbiAgICAgICAgICAgIGljb249ezxJY29uIGNsYXNzPXtzdHlsZS5pY29ufSBuYW1lPVwiY2hlY2tcIiAvPn1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8cD5QdXQgb24gd2hpdGVsaXN0PC9wPlxuICAgICAgICAgICAgPHNwYW4+QWxsIHNldCE8L3NwYW4+XG4gICAgICAgICAgPC9TdGVwPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBfb25SZWYgPSAobmFtZSkgPT4gKHJlZikgPT4gdGhpc1tuYW1lXSA9IHJlZjtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9TdGVwcy50c3giLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5pbXBvcnQgd2ViMyBmcm9tICdAdXNlcmZlZWRzL3V0aWxzL3NyYy93ZWIzJztcblxuaW1wb3J0IHsgbW9iaWxlT3JUYWJsZXQgfSBmcm9tICdAdXNlcmZlZWRzL3V0aWxzL3NyYy91c2VyQWdlbnQnO1xuaW1wb3J0IFN2ZyBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvU3ZnJztcbmltcG9ydCBMaW5rIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9MaW5rJztcbmltcG9ydCBQYXBlciBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvUGFwZXInO1xuaW1wb3J0IExvYWRlciBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvTG9hZGVyJztcbmltcG9ydCBCdXR0b24gZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0J1dHRvbic7XG5pbXBvcnQgVGV4dFdpdGhMYWJlbCBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvVGV4dFdpdGhMYWJlbCc7XG5cbmltcG9ydCBTdGVwcyBmcm9tICcuL2NvbXBvbmVudHMvU3RlcHMnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL1N0YXR1cy5zY3NzJztcblxuY29uc3QgaGVhcnRTdmcgPSByZXF1aXJlKCcuLi8uLi8uLi9pbWFnZXMvaGVhcnQuc3ZnJyk7XG5cbmNvbnN0IGdldFRyYW5zYWN0aW9uUmVjZWlwdCA9ICh0eDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd2ViMy5ldGguZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4LCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgZ2V0QmxvY2tOdW1iZXI6ICgpID0+IFByb21pc2U8bnVtYmVyPiA9ICgpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3ZWIzLmV0aC5nZXRCbG9ja051bWJlcigoZXJyb3IsIGN1cnJlbnRCbG9ja051bWJlcikgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGN1cnJlbnRCbG9ja051bWJlcik7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3Qgd2FpdCA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG5pbnRlcmZhY2UgSVN0YXR1c1Byb3BzIHtcbiAgbG9jYXRpb246IGFueTtcbn1cblxuaW50ZXJmYWNlIElTdGF0dXNTdGF0ZSB7XG4gIG1vYmlsZU9yVGFibGV0OiBib29sZWFuO1xuICBsaW5rPzogYW55O1xuICBsaW5rSWQ6IHN0cmluZztcbiAgY29udGV4dDogc3RyaW5nO1xuICBhbGdvcml0aG06IHN0cmluZztcbiAgd2hpdGVsaXN0OiBzdHJpbmc7XG4gIHB1Ymxpc2hlck5vdGU6IHN0cmluZztcbiAgbG9jYXRpb246IHN0cmluZztcbiAgYmxvY2tjaGFpbjoge1xuICAgIHdlYjNBdmFpbGFibGU6IGJvb2xlYW47XG4gICAgYmxvY2tOdW1iZXI6IG51bWJlciB8IG51bGw7XG4gICAgY3VycmVudEJsb2NrTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0dXMgZXh0ZW5kcyBDb21wb25lbnQ8SVN0YXR1c1Byb3BzLCBJU3RhdHVzU3RhdGU+IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHByb3BzLmxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gcGFyYW1zLmdldCgnY29udGV4dCcpIHx8ICcnO1xuICAgIGNvbnN0IGFsZ29yaXRobSA9IHBhcmFtcy5nZXQoJ2FsZ29yaXRobScpIHx8ICcnO1xuICAgIGNvbnN0IHdoaXRlbGlzdCA9IHBhcmFtcy5nZXQoJ3doaXRlbGlzdCcpIHx8ICcnO1xuICAgIGNvbnN0IGxpbmtJZCA9IHBhcmFtcy5nZXQoJ2xpbmtJZCcpIHx8ICcnO1xuICAgIGNvbnN0IHB1Ymxpc2hlck5vdGUgPSBwYXJhbXMuZ2V0KCdwdWJsaXNoZXJOb3RlJykgfHwgJyc7XG4gICAgY29uc3QgbG9jYXRpb24gPSBwYXJhbXMuZ2V0KCdsb2NhdGlvbicpIHx8ICcnO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1vYmlsZU9yVGFibGV0OiBtb2JpbGVPclRhYmxldCgpLFxuICAgICAgbGlua0lkLFxuICAgICAgY29udGV4dCxcbiAgICAgIGFsZ29yaXRobSxcbiAgICAgIHdoaXRlbGlzdCxcbiAgICAgIHB1Ymxpc2hlck5vdGUsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGJsb2NrY2hhaW46IHtcbiAgICAgICAgd2ViM0F2YWlsYWJsZTogZmFsc2UsXG4gICAgICAgIGJsb2NrTnVtYmVyOiBudWxsLFxuICAgICAgICBjdXJyZW50QmxvY2tOdW1iZXI6IG51bGwsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0aGlzLl9vYnNlcnZlQmxvY2tjaGFpblN0YXRlKGxpbmtJZCk7XG5cbiAgICBjb25zdCBzZXRUaW1lb3V0Rm9yRmV0Y2ggPSAodGltZW91dDogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fZmV0Y2hMaW5rcyhjb250ZXh0LCBhbGdvcml0aG0sIHdoaXRlbGlzdClcbiAgICAgICAgICAudGhlbih0aGlzLl9maW5kTGlua0J5SWQobGlua0lkKSlcbiAgICAgICAgICAudGhlbigobGluaykgPT4gbGluayAmJiAhbGluay53aGl0ZWxpc3RlZCAmJiBzZXRUaW1lb3V0Rm9yRmV0Y2goNTAwMCkpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfTtcblxuICAgIHNldFRpbWVvdXRGb3JGZXRjaCgwKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuY29udGV4dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBtb2JpbGVPclRhYmxldCwgbGlua0lkLCBjb250ZXh0LCBsaW5rLCBibG9ja2NoYWluLCBsb2NhdGlvbiB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz17c3R5bGUuc2VsZn0+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHAgY2xhc3M9e3N0eWxlLnByZXZpZXdUaXRsZX0+TGluayBwcmV2aWV3OjwvcD5cbiAgICAgICAgICA8UGFwZXIgY2xhc3M9e3N0eWxlLnByZXZpZXd9PlxuICAgICAgICAgICAge2xpbmsgJiYgPExpbmsgbGluaz17bGlua30gLz59XG4gICAgICAgICAgICB7IWxpbmsgJiYgPGRpdiBjbGFzcz17c3R5bGUubG9hZGVyfT48TG9hZGVyIC8+PC9kaXY+fVxuICAgICAgICAgIDwvUGFwZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8UGFwZXIgY2xhc3M9e3N0eWxlLmNvbnRlbnR9PlxuICAgICAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLmludHJvZHVjdGlvbn0+XG4gICAgICAgICAgICA8aW1nIHNyYz17aGVhcnRTdmd9IC8+XG4gICAgICAgICAgICA8aDI+WW91ciBsaW5rIGhhcyBiZWVuIHN1Y2Nlc2Z1bGx5IHN1Ym1pdGVkITwvaDI+XG4gICAgICAgICAgICA8cD5JbiBvcmRlciB0byB0cmFjayBpdHMgcHJvZ3Jlc3MgcGxlYXNlIHNhdmUgdGhlIGxpbms8L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz17c3R5bGUuaW5mb30+XG4gICAgICAgICAgICA8VGV4dFdpdGhMYWJlbCBjbGFzcz17c3R5bGUubGFiZWx9IGxhYmVsPVwiTGluayBzdGF0dXM6XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLmxpbmtMYWJlbH0+XG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9e3N0eWxlLmxpbmt9IGhyZWY9e3dpbmRvdy5sb2NhdGlvbi5ocmVmfT57d2luZG93LmxvY2F0aW9uLmhyZWZ9PC9hPlxuICAgICAgICAgICAgICAgIHshbW9iaWxlT3JUYWJsZXQgJiYgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5XG4gICAgICAgICAgICAgICAgICBjbGFzcz17c3R5bGUuYWRkQm9va21hcmt9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9ib29rbWFya0l0fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIEFkZCB0byBib29rbWFya3NcbiAgICAgICAgICAgICAgICA8L0J1dHRvbj59XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9UZXh0V2l0aExhYmVsPlxuICAgICAgICAgICAgPFRleHRXaXRoTGFiZWwgY2xhc3M9e3N0eWxlLmxhYmVsfSBsYWJlbD1cIldpZGdldCBsb2NhdGlvbjpcIj5cbiAgICAgICAgICAgICAgPGEgaHJlZj17bG9jYXRpb259Pntsb2NhdGlvbn08L2E+XG4gICAgICAgICAgICA8L1RleHRXaXRoTGFiZWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPFN0ZXBzXG4gICAgICAgICAgICBsaW5rSWQ9e2xpbmtJZH1cbiAgICAgICAgICAgIGNvbnRleHQ9e2NvbnRleHR9XG4gICAgICAgICAgICBsaW5rPXtsaW5rfVxuICAgICAgICAgICAgYmxvY2tjaGFpblN0YXRlPXtibG9ja2NoYWlufVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvUGFwZXI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgLy8gVG9EbyBmaXggLSB3aGVuIG5ldHdvcmsgaXMgdW5hYWlsYWJsZVxuICBfZmV0Y2hMaW5rcyA9IGFzeW5jIChjb250ZXh0LCBhbGdvcml0aG0sIHdoaXRlbGlzdCkgPT4ge1xuICAgIGNvbnN0IGJhc2VVUkwgPSAnaHR0cHM6Ly9hcGkudXNlcmZlZWRzLmlvL3JhbmtpbmcnO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFsbExpbmtzUmVxdWVzdCA9IGZldGNoKGAke2Jhc2VVUkx9LyR7Y29udGV4dH0vJHthbGdvcml0aG19L2AsIHsgY2FjaGU6ICduby1zdG9yZScgfSlcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG4gICAgICBjb25zdCB3aGl0ZWxpc3RlZExpbmtzUmVxdWVzdCA9IGZldGNoKGAke2Jhc2VVUkx9LyR7Y29udGV4dH0vJHthbGdvcml0aG19Lz93aGl0ZWxpc3Q9JHt3aGl0ZWxpc3R9YCxcbiAgICAgICAgeyBjYWNoZTogJ25vLXN0b3JlJyB9KVxuICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKTtcblxuICAgICAgY29uc3QgW2FsbExpbmtzLCB3aGl0ZWxpc3RlZExpbmtzXSA9IGF3YWl0IFByb21pc2UuYWxsKFthbGxMaW5rc1JlcXVlc3QsXG4gICAgICAgIHdoaXRlbGlzdGVkTGlua3NSZXF1ZXN0XSk7XG4gICAgICBjb25zdCBsaW5rcyA9IGFsbExpbmtzLml0ZW1zLm1hcCgobGluaykgPT4ge1xuICAgICAgICBjb25zdCB3aGl0ZWxpc3RlZCA9IHdoaXRlbGlzdGVkTGlua3MuaXRlbXMuZmluZCgoYSkgPT4gbGluay5pZCA9PT0gYS5pZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5saW5rLFxuICAgICAgICAgIHdoaXRlbGlzdGVkOiAhIXdoaXRlbGlzdGVkLFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBsaW5rcztcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgX29ic2VydmVCbG9ja2NoYWluU3RhdGUgPSBhc3luYyAobGlua0lkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXdlYjMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdGUoeyBibG9ja2NoYWluOiB7IC4uLnRoaXMuc3RhdGUuYmxvY2tjaGFpbiwgd2ViM0F2YWlsYWJsZTogZmFsc2UgfX0pO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHsgYmxvY2tjaGFpbjogeyAuLi50aGlzLnN0YXRlLmJsb2NrY2hhaW4sIHdlYjNBdmFpbGFibGU6IHRydWUgfX0pO1xuXG4gICAgY29uc3QgWywgdHhdID0gbGlua0lkLnNwbGl0KCc6Jyk7XG5cbiAgICBsZXQgcmVjZWlwdDtcbiAgICBkbyB7XG4gICAgICByZWNlaXB0ID0gYXdhaXQgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4KTtcbiAgICAgIGF3YWl0IHdhaXQoMTAwMCk7XG4gICAgfSB3aGlsZSAoIXJlY2VpcHQpO1xuXG4gICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gYXdhaXQgZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGJsb2NrY2hhaW46IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZS5ibG9ja2NoYWluLFxuICAgICAgICBibG9ja051bWJlcjogcmVjZWlwdC5ibG9ja051bWJlcixcbiAgICAgICAgY3VycmVudEJsb2NrTnVtYmVyLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIF9maW5kTGlua0J5SWQgPSAobGlua0lkKSA9PiAobGlua3MpID0+IHtcbiAgICBjb25zdCBsaW5rID0gbGlua3MuZmluZCgobCkgPT4gbC5pZCA9PT0gbGlua0lkKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgbGluayB9KTtcblxuICAgIHJldHVybiBsaW5rO1xuICB9XG5cbiAgX2Jvb2ttYXJrSXQgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBib29rbWFya1VSTCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgIGNvbnN0IGJvb2ttYXJrVGl0bGUgPSBkb2N1bWVudC50aXRsZTtcbiAgICBpZiAoIXRoaXMuc3RhdGUubW9iaWxlT3JUYWJsZXQpIHtcbiAgICAgIC8vIE90aGVyIGJyb3dzZXJzIChtYWlubHkgV2ViS2l0IC0gQ2hyb21lL1NhZmFyaSlcbiAgICAgIGNvbnN0IGNvbW1hbmRLZXkgPSAvTWFjL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA/ICdDTUQnIDogJ0N0cmwnO1xuICAgICAgYWxlcnQoYFBsZWFzZSBwcmVzcyAkeyhjb21tYW5kS2V5KX0gRCB0byBhZGQgdGhpcyBwYWdlIHRvIHlvdXIgYm9va21hcmtzLmApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BhZ2VzL1N0YXR1cy9pbmRleC50c3giLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2lucHV0LnNjc3MnO1xuXG5jb25zdCBjeCA9IGNsYXNzbmFtZXMuYmluZChzdHlsZSk7XG5cbnR5cGUgVElucHV0UHJvcHMgPSBKU1guSFRNTEF0dHJpYnV0ZXMgJiB7XG4gIHBsYWNlaG9sZGVyOiBzdHJpbmc7XG4gIG11bHRpbGluZT86IGJvb2xlYW47XG4gIGVycm9yTWVzc2FnZT86IHN0cmluZztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0IGV4dGVuZHMgQ29tcG9uZW50PFRJbnB1dFByb3BzLCB7fT4ge1xuXG4gIGlucHV0OiB7XG4gICAgZm9jdXMoKTogdm9pZDtcbiAgfSB8IHVuZGVmaW5lZDtcblxuICByZW5kZXIoeyBjbGFzczogY2xhc3NOYW1lLCBwbGFjZWhvbGRlciwgZXJyb3JNZXNzYWdlLCB2YWx1ZSwgbXVsdGlsaW5lLCBkaXNhYmxlZCA9IGZhbHNlLCAuLi5yZXN0UHJvcHMgfVxuICAgIDogVElucHV0UHJvcHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz17Y3goc3R5bGUuc2VsZiwgY2xhc3NOYW1lLCB7IGludmFsaWQ6ICEhZXJyb3JNZXNzYWdlIH0pfT5cbiAgICAgICAgeyFtdWx0aWxpbmUgPyAoXG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICByZWY9e3RoaXMuX29uSW5wdXRSZWZ9XG4gICAgICAgICAgICBjbGFzcz17c3R5bGUuaW5wdXR9XG4gICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgey4uLnJlc3RQcm9wc31cbiAgICAgICAgICAvPlxuICAgICAgICApIDogKFxuICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgcmVmPXt0aGlzLl9vbklucHV0UmVmfVxuICAgICAgICAgICAgY2xhc3M9e3N0eWxlLmlucHV0fVxuICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgIHJvd3M9ezN9XG4gICAgICAgICAgICB7Li4ucmVzdFByb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIDxzcGFuIGNsYXNzPXtzdHlsZS5wbGFjZWhvbGRlcn0gb25DbGljaz17dGhpcy5fb25QbGFjZWhvbGRlckNsaWNrfT57cGxhY2Vob2xkZXJ9PC9zcGFuPlxuICAgICAgICB7ZXJyb3JNZXNzYWdlICYmIDxzcGFuIGNsYXNzPXtzdHlsZS5lcnJvcn0+e2Vycm9yTWVzc2FnZX08L3NwYW4+fVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIF9vbklucHV0UmVmID0gKHJlZikgPT4gdGhpcy5pbnB1dCA9IHJlZjtcblxuICBfb25QbGFjZWhvbGRlckNsaWNrID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvSW5wdXQudHN4IiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9hZHNMaXN0LnNjc3MnO1xuXG5jb25zdCBub29wID0gKCkgPT4gbnVsbDtcblxuaW50ZXJmYWNlIElBZFByb3BzIHtcbiAgYWQ6IGFueTtcbiAgb25DbGljayhpdGVtOiBhbnkpOiB2b2lkO1xufVxuXG5jb25zdCBBZCA9ICh7IGFkLCBvbkNsaWNrIH06IElBZFByb3BzKSA9PiAoXG4gIDxkaXYgY2xhc3M9e3N0eWxlLnJvd30+XG4gICAgPGRpdj5cbiAgICAgIDxkaXY+VVJMOiA8YSBocmVmPXthZC50YXJnZXR9PnthZC50YXJnZXR9PC9hPjwvZGl2PlxuICAgICAgPGRpdj5zY29yZToge3dlYjMuZnJvbVdlaShhZC5zY29yZSwgJ2V0aGVyJyl9PC9kaXY+XG4gICAgICA8ZGl2PnthZC50aXRsZX08L2Rpdj5cbiAgICAgIDxkaXY+e2FkLnN1bW1hcnl9PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz17c3R5bGUuYnV0dG9ufT5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgb25DbGljaz17b25DbGljay5iaW5kKG51bGwsIGFkKX1cbiAgICAgICAgZGlzYWJsZWQ9e2FkLndoaXRlbGlzdGVkfVxuICAgICAgPlxuICAgICAgICBBZGQgdG8gd2hpdGVsaXN0XG4gICAgICA8L0J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4pO1xuXG5pbnRlcmZhY2UgSUFkc0xpc3RQcm9wcyB7XG4gIGFkczogYW55W107XG4gIG9uSXRlbUNsaWNrPzogKGl0ZW06IGFueSkgPT4gdm9pZDtcbn1cblxuY29uc3QgQWRzTGlzdCA9ICh7IGFkcyA9IFtdLCBvbkl0ZW1DbGljayA9IG5vb3AgfTogSUFkc0xpc3RQcm9wcykgPT4gKFxuICA8ZGl2IGNsYXNzPXtzdHlsZS5zZWxmfT5cbiAgICB7YWRzLm1hcCgoYWQpID0+ICg8QWQgYWQ9e2FkfSBvbkNsaWNrPXtvbkl0ZW1DbGlja30gLz4pKX1cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBBZHNMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0Fkc0xpc3QudHN4IiwiaW1wb3J0IHsgaCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnQHVzZXJmZWVkcy9jb3JlJztcblxuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSc7XG5cbmltcG9ydCBJbnB1dCBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvSW5wdXQnO1xuaW1wb3J0IFBhcGVyIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9QYXBlcic7XG5pbXBvcnQgQWRzTGlzdCBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvQWRzTGlzdCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vV2hpdGVsaXN0LnNjc3MnO1xuXG5pbnRlcmZhY2UgSVdoaXRlbGlzdFByb3BzIHtcbiAgbG9jYXRpb246IGFueTtcbn1cblxuaW50ZXJmYWNlIElXaGl0ZWxpc3RTdGF0ZSB7XG4gIGxpbmtzOiBhbnlbXTtcbiAgZmV0Y2hpbmc6IGJvb2xlYW47XG4gIGNvbnRleHQ6IHN0cmluZztcbiAgYWxnb3JpdGhtOiBzdHJpbmc7XG4gIHdoaXRlbGlzdDogc3RyaW5nO1xuICBjb250ZXh0RnJvbVBhcmFtczogYm9vbGVhbjtcbiAgd2hpdGVsaXN0RnJvbVBhcmFtczogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3JlYXRvciBleHRlbmRzIENvbXBvbmVudDxJV2hpdGVsaXN0UHJvcHMsIElXaGl0ZWxpc3RTdGF0ZT4ge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwcm9wcy5sb2NhdGlvbi5zZWFyY2gpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxpbmtzOiBbXSxcbiAgICAgIGZldGNoaW5nOiBmYWxzZSxcbiAgICAgIGNvbnRleHQ6IHBhcmFtcy5nZXQoJ2NvbnRleHQnKSB8fCAnJyxcbiAgICAgIGFsZ29yaXRobTogcGFyYW1zLmdldCgnYWxnb3JpdGhtJykgfHwgJ2xpbmtzJyxcbiAgICAgIHdoaXRlbGlzdDogcGFyYW1zLmdldCgnd2hpdGVsaXN0JykgfHwgJycsXG4gICAgICBjb250ZXh0RnJvbVBhcmFtczogcGFyYW1zLmhhcygnY29udGV4dCcpLFxuICAgICAgd2hpdGVsaXN0RnJvbVBhcmFtczogcGFyYW1zLmhhcygnd2hpdGVsaXN0JyksXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5jb250ZXh0RnJvbVBhcmFtcykge1xuICAgICAgdGhpcy5fZmV0Y2hMaW5rcygpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz17c3R5bGUuc2VsZn0+XG4gICAgICAgIDxQYXBlciBjbGFzcz17c3R5bGUucGFwZXJ9PlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJVc2VyZmVlZCBJRFwiXG4gICAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5jb250ZXh0fVxuICAgICAgICAgICAgb25JbnB1dD17dGhpcy5fb25Db250ZXh0Q2hhbmdlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUuY29udGV4dEZyb21QYXJhbXN9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiV2hpdGVsaXN0IElEXCJcbiAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLndoaXRlbGlzdH1cbiAgICAgICAgICAgIG9uSW5wdXQ9e3RoaXMuX29uV2hpdGVsaXN0Q2hhbmdlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUud2hpdGVsaXN0RnJvbVBhcmFtc31cbiAgICAgICAgICAvPlxuXG4gICAgICAgICAgPEFkc0xpc3QgYWRzPXt0aGlzLnN0YXRlLmxpbmtzfSBvbkl0ZW1DbGljaz17dGhpcy5fb25MaW5rQ2xpY2t9IC8+XG4gICAgICAgIDwvUGFwZXI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgX29uQ29udGV4dENoYW5nZSA9IChlKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGNvbnRleHQ6IGUudGFyZ2V0LnZhbHVlIH0pO1xuICAgIHRoaXMuX2ZldGNoTGlua3MoKTtcbiAgfVxuXG4gIF9vbldoaXRlbGlzdENoYW5nZSA9IChlKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHdoaXRlbGlzdDogZS50YXJnZXQudmFsdWUgfSk7XG4gICAgdGhpcy5fZmV0Y2hMaW5rcygpO1xuICB9XG5cbiAgX2ZldGNoTGlua3MgPSBkZWJvdW5jZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBhbGdvcml0aG0sIHdoaXRlbGlzdCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBmZXRjaGluZzogdHJ1ZSB9KTtcblxuICAgIGNvbnN0IGJhc2VVUkwgPSAnaHR0cHM6Ly9hcGkudXNlcmZlZWRzLmlvL3JhbmtpbmcnO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFsbExpbmtzUmVxdWVzdCA9IGZldGNoKGAke2Jhc2VVUkx9LyR7Y29udGV4dH0vJHthbGdvcml0aG19L2ApXG4gICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpO1xuICAgICAgY29uc3Qgd2hpdGVsaXN0ZWRMaW5rc1JlcXVlc3QgPSBmZXRjaChgJHtiYXNlVVJMfS8ke2NvbnRleHR9LyR7YWxnb3JpdGhtfS8/d2hpdGVsaXN0PSR7d2hpdGVsaXN0fWApXG4gICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpO1xuXG4gICAgICBjb25zdCBbYWxsTGlua3MsIHdoaXRlbGlzdGVkTGlua3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBhbGxMaW5rc1JlcXVlc3QsXG4gICAgICAgIHdoaXRlbGlzdGVkTGlua3NSZXF1ZXN0LFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IGxpbmtzID0gYWxsTGlua3MuaXRlbXMubWFwKChsaW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IHdoaXRlbGlzdGVkID0gISF3aGl0ZWxpc3RlZExpbmtzLml0ZW1zLmZpbmQoKGEpID0+IGxpbmsuaWQgPT09IGEuaWQpO1xuXG4gICAgICAgIHJldHVybiB7IC4uLmxpbmssIHdoaXRlbGlzdGVkIH07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsaW5rcywgZmV0Y2hpbmc6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmZXRjaGluZzogZmFsc2UgfSk7XG4gICAgfVxuICB9LCA1MDApO1xuXG4gIF9vbkxpbmtDbGljayA9IChsaW5rKSA9PiB7XG4gICAgY29uc3QgW18sIGFkZHJlc3NdID0gdGhpcy5zdGF0ZS53aGl0ZWxpc3Quc3BsaXQoJzonKTtcbiAgICBjb25zdCBjbGFpbSA9IHtcbiAgICAgIGNsYWltOiB7IHRhcmdldDogbGluay5pZCB9LFxuICAgICAgY3JlZGl0czogW3tcbiAgICAgICAgdHlwZTogJ2ludGVyZmFjZScsXG4gICAgICAgIHZhbHVlOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgIH1dLFxuICAgIH07XG5cbiAgICBjb3JlLmV0aGVyZXVtLmNsYWltcy5zZW5kQ2xhaW0oYWRkcmVzcywgY2xhaW0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnRzeCIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2xpbmtMaXN0LnNjc3MnO1xuXG5jb25zdCBub29wID0gKCkgPT4gbnVsbDtcblxuaW50ZXJmYWNlIElMaW5rUHJvcHMge1xuICBsaW5rOiBhbnk7XG59XG5cbmNvbnN0IExpbmsgPSAoeyBsaW5rIH06IElMaW5rUHJvcHMpID0+IChcbiAgPGRpdiBjbGFzcz17c3R5bGUucm93fT5cbiAgICA8ZGl2PlxuICAgICAgPGRpdj5VUkw6IDxhIGhyZWY9e2xpbmsudGFyZ2V0fT57bGluay50YXJnZXR9PC9hPjwvZGl2PlxuICAgICAgPGRpdj57bGluay5zdW1tYXJ5fTwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbik7XG5cbmludGVyZmFjZSBJTGlua0xpc3RQcm9wcyB7XG4gIGxpbmtzOiBhbnlbXTtcbiAgb25JdGVtQ2xpY2s/OiAoaXRlbTogYW55KSA9PiB2b2lkO1xufVxuXG5jb25zdCBMaW5rTGlzdCA9ICh7IGxpbmtzID0gW119OiBJTGlua0xpc3RQcm9wcykgPT4gKFxuICA8ZGl2IGNsYXNzPXtzdHlsZS5zZWxmfT5cbiAgICB7bGlua3MubWFwKChsaW5rKSA9PiAoPExpbmsgbGluaz17bGlua30gLz4pKX1cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBMaW5rTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9MaW5rTGlzdC50c3giLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSc7XG5cbmltcG9ydCBJbnB1dCBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvSW5wdXQnO1xuaW1wb3J0IFBhcGVyIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9QYXBlcic7XG5pbXBvcnQgTGlua0xpc3RDb21wb25lbnQgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0xpbmtMaXN0JztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9XaGl0ZWxpc3Quc2Nzcyc7XG5cbmludGVyZmFjZSBJTGlua0xpc3RQcm9wcyB7XG4gIGxvY2F0aW9uOiBhbnk7XG59XG5cbmludGVyZmFjZSBJTGlua0xpc3RTdGF0ZSB7XG4gIGxpbmtzOiBhbnlbXTtcbiAgZmV0Y2hpbmc6IGJvb2xlYW47XG4gIGNvbnRleHQ6IHN0cmluZztcbiAgY29udGV4dEZyb21QYXJhbXM6IGJvb2xlYW47XG4gIGFsZ29yaXRobTogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rTGlzdCBleHRlbmRzIENvbXBvbmVudDxJTGlua0xpc3RQcm9wcywgSUxpbmtMaXN0U3RhdGU+IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocHJvcHMubG9jYXRpb24uc2VhcmNoKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsaW5rczogW10sXG4gICAgICBmZXRjaGluZzogZmFsc2UsXG4gICAgICBjb250ZXh0OiBwYXJhbXMuZ2V0KCdjb250ZXh0JykgfHwgJycsXG4gICAgICBhbGdvcml0aG06IHBhcmFtcy5nZXQoJ2FsZ29yaXRobScpIHx8ICdsaW5rcycsXG4gICAgICBjb250ZXh0RnJvbVBhcmFtczogcGFyYW1zLmhhcygnY29udGV4dCcpLFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuY29udGV4dEZyb21QYXJhbXMpIHtcbiAgICAgIHRoaXMuX2ZldGNoTGlua3MoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgICAgICA8UGFwZXIgY2xhc3M9e3N0eWxlLnBhcGVyfT5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQWR2ZXJ0aXNlciBJRFwiXG4gICAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5jb250ZXh0fVxuICAgICAgICAgICAgb25JbnB1dD17dGhpcy5fb25Db250ZXh0Q2hhbmdlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUuY29udGV4dEZyb21QYXJhbXN9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8TGlua0xpc3RDb21wb25lbnQgbGlua3M9e3RoaXMuc3RhdGUubGlua3N9IC8+XG4gICAgICAgIDwvUGFwZXI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgX29uQ29udGV4dENoYW5nZSA9IChlKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGNvbnRleHQ6IGUudGFyZ2V0LnZhbHVlIH0pO1xuICAgIHRoaXMuX2ZldGNoTGlua3MoKTtcbiAgfVxuXG4gIF9mZXRjaExpbmtzID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgY29udGV4dCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBmZXRjaGluZzogdHJ1ZSB9KTtcbiAgICBjb25zdCBmZXRjaFVybCA9ICdodHRwczovL2FwaS51c2VyZmVlZHMuaW8vcmFua2luZyc7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsTGlua3NSZXF1ZXN0ID0gZmV0Y2goYCR7ZmV0Y2hVcmx9LyR7Y29udGV4dH0vYXV0aG9yZWQvP3R5cGU9bGlua2ApXG4gICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpO1xuXG4gICAgICBjb25zdCBbYWxsTGlua3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FsbExpbmtzUmVxdWVzdF0pO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGlua3M6IGFsbExpbmtzLml0ZW1zLCBmZXRjaGluZzogZmFsc2UgfSk7XG5cbiAgICAgIHJldHVybiBhbGxMaW5rcztcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZmV0Y2hpbmc6IGZhbHNlIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCA1MDApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BhZ2VzL0xpbmtMaXN0LnRzeCIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHtcbiAgSGFzaFJvdXRlciBhcyBSb3V0ZXIsXG4gIFJvdXRlLFxufSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuaW1wb3J0IEhvbWUgZnJvbSAnLi9wYWdlcy9Ib21lJztcbmltcG9ydCBTdGF0dXMgZnJvbSAnLi9wYWdlcy9TdGF0dXMnO1xuaW1wb3J0IFdoaXRlbGlzdCBmcm9tICcuL3BhZ2VzL1doaXRlbGlzdCc7XG5pbXBvcnQgTGlua0xpc3QgZnJvbSAnLi9wYWdlcy9MaW5rTGlzdCc7XG5cbmNvbnN0IEFwcCA9ICgpID0+IChcbiAgPFJvdXRlcj5cbiAgICA8ZGl2PlxuICAgICAgPFJvdXRlIGV4YWN0IHBhdGg9XCIvXCIgY29tcG9uZW50PXtIb21lfSAvPlxuICAgICAgPFJvdXRlIHBhdGg9XCIvc3RhdHVzXCIgY29tcG9uZW50PXtTdGF0dXN9IC8+XG4gICAgICA8Um91dGUgcGF0aD1cIi93aGl0ZWxpc3RcIiBjb21wb25lbnQ9e1doaXRlbGlzdH0gLz5cbiAgICAgIDxSb3V0ZSBwYXRoPVwiL2xpbmtsaXN0XCIgY29tcG9uZW50PXtMaW5rTGlzdH0gLz5cbiAgICA8L2Rpdj5cbiAgPC9Sb3V0ZXI+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBBcHA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXBwLnRzeCIsImltcG9ydCB7IGgsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgJ25vcm1hbGl6ZS5jc3MnO1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJztcbmltcG9ydCAnLi4vc3R5bGVzL2FsbC5zY3NzJztcblxuY29uc3Qgcm9vdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yb290Jyk7XG5cbmlmIChyb290KSB7XG4gIHJlbmRlcig8QXBwIC8+LCByb290KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC50c3giLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL1N0YXR1cy5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vU3RhdHVzLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9TdGF0dXMuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvU3RhdHVzL1N0YXR1cy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL3NyYy9wYWdlcy9TdGF0dXMvU3RhdHVzLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9zdGVwcy5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vc3RlcHMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3N0ZXBzLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL3N0ZXBzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL3N0ZXBzLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9XaGl0ZWxpc3Quc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL1doaXRlbGlzdC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vV2hpdGVsaXN0LnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL3NyYy9wYWdlcy9XaGl0ZWxpc3Quc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2FsbC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vYWxsLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9hbGwuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHlsZXMvYWxsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3R5bGVzL2FsbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=