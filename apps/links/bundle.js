/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/apps/links/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@userfeeds/core/index.js":
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
  ethereum: {
    claims: __webpack_require__("../../node_modules/@userfeeds/core/src/ethereumClaims.js"),
  },
  utils: __webpack_require__("../../node_modules/@userfeeds/core/src/utils/index.js"),
};


/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/ethereumClaims.js":
/***/ (function(module, exports, __webpack_require__) {

const { getCurrentNetworkName } = __webpack_require__("../../node_modules/@userfeeds/core/src/utils/index.js");
const {
  payableAbi,
  notpayableAbi,
  getContractAddress,
} = __webpack_require__("../../node_modules/@userfeeds/core/src/utils/contract.js");

function sendPayableClaim(address, claim, value) {
  const contract = web3.eth.contract(payableAbi)
    .at(getContractAddress(getCurrentNetworkName(), true));

  return new Promise((resolve, reject) => {
    contract.post(
      address,
      JSON.stringify(claim),
      { value: web3.toWei(value, 'ether') },
      (errror, result) => {
        if (errror) {
          return reject(errror);
        }
        return resolve(result);
      },
    );
  });
}

function sendNotpayableClaim(address, claim) {
  const contract = web3.eth.contract(notpayableAbi)
    .at(getContractAddress(getCurrentNetworkName(), false));

  return new Promise((resolve, reject) => {
    contract.post(
      JSON.stringify(claim),
      (errror, result) => {
        if (errror) {
          return reject(errror);
        }
        return resolve(result);
      },
    );
  });
}

function sendClaim(address, claim, value) {
  const payable = value !== undefined;

  return payable
    ? sendPayableClaim(address, claim, value)
    : sendNotpayableClaim(address, claim);
}

module.exports = {
  sendClaim,
  sendPayableClaim,
  sendNotpayableClaim,
};



/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/utils/contract.js":
/***/ (function(module, exports) {


const payableContractAddressMapping = {
  ropsten: '0xa845c686a696c3d33988917c387d8ab939c66226',
  rinkeby: '0x0a48ac8263d9d79768d10cf9d7e82a19c49f0002',
};

const notpayableContractAddressMapping = {
  ropsten: '0x5c3fe6b94b57c1e294000403340f12f083e71b83',
  rinkeby: '0x09dcdf34e0c28b106fdfe51009cb71ae92bf8bbc',
};

function getContractAddress(networkName, payable = true) {
  let contract;
  if (payable) {
    contract = payableContractAddressMapping[networkName];
  } else {
    contract = notpayableContractAddressMapping[networkName];
  }

  if (!contract) {
    throw new Error('Contract is not available');
  }

  return contract;
}

const payableAbi = [{
  constant: false,
  inputs: [
    { name: 'userfeed', type: 'address' },
    { name: 'data', type: 'string' },
  ],
  name: 'post',
  outputs: [],
  payable: true,
  type: 'function',
}, {
  anonymous: false,
  inputs: [
    { name: 'sender', type: 'address', indexed: false },
    { name: 'userfeed', type: 'address', indexed: false },
    { name: 'data', type: 'string', indexed: false },
  ],
  name: 'Claim',
  type: 'event',
}];

const notpayableAbi = [{
  constant: false,
  inputs: [
    { name: 'data', type: 'string' },
  ],
  name: 'post',
  outputs: [],
  payable: false,
  type: 'function',
}, {
  anonymous: false,
  inputs: [
    { name: 'sender', type: 'address', indexed: false },
    { name: 'data', type: 'string', indexed: false },
  ],
  name: 'Claim',
  type: 'event'
}];

module.exports = {
  payableAbi,
  notpayableAbi,
  getContractAddress,
};


/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/utils/index.js":
/***/ (function(module, exports) {


const networkMapping = {
  '1': 'ethereum',
  '3': 'ropsten',
  '4': 'rinkeby',
  '42': 'kovan',
};

function getCurrentNetworkName() {
  if (!web3) {
    throw new Error('web3 not available');
  }

  return networkMapping[web3.version.network];
}

module.exports = {
  getCurrentNetworkName,
};



/***/ }),

/***/ "../../node_modules/base64-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ "../../node_modules/bignumber.js/bignumber.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! bignumber.js v2.0.7 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (global) {
    'use strict';

    /*
      bignumber.js v2.0.7
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2015 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var BigNumber, crypto, parseNumeric,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32


    /*
     * Create and return a BigNumber constructor.
     */
    function another(configObj) {
        var div,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 100,                     // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 ) raise( id, tooManyDigits, x.s * n );

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = another;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    CRYPTO = !!( v && crypto && typeof crypto == 'object' );
                    if ( v && !CRYPTO && ERRORS ) raise( 2, 'crypto unavailable', crypto );
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if ( crypto && crypto.getRandomValues ) {

                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = crypto.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if ( crypto && crypto.randomBytes ) {

                        // buffer
                        a = crypto.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                crypto.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else if (ERRORS) {
                        raise( 14, 'crypto unavailable', crypto );
                    }
                }

                // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
                if (!i) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc.unshift(1);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x.unshift(carry);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.shift() );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz.unshift(0);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod.unshift(0);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.shift();
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix = /^(-?)0([xbo])/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on ±Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ sd % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is ±Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.shift(), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return ±Infinity if either ±Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] %= BASE;
            }

            if (a) {
                xc.unshift(a);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be ±0 if k < 0, or ±Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, ±Infinity or ±0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return ±Infinity if either is ±Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return ±0 if either is ±0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.shift();
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            var x = this;

            // Ensure zero has correct sign.
            return +x || ( x.s ? x.s * 0 : NaN );
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is not 0, round to POW_PRECISION using ROUNDING_MODE.
         *
         * n {number} Integer, -9007199254740992 to 9007199254740992 inclusive.
         * (Performs 54 loop iterations for n of 9007199254740992.)
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         */
        P.toPower = P.pow = function (n) {
            var k, y,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            // Pass ±Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) ) {
                return new BigNumber( Math.pow( +x, n ) );
            }

            // Truncating each coefficient array to a length of k after each multiplication equates
            // to truncating significant digits to POW_PRECISION + [28, 41], i.e. there will be a
            // minimum of 28 guard digits retained. (Using + 1.5 would give [9, 21] guard digits.)
            k = POW_PRECISION ? mathceil( POW_PRECISION / LOG_BASE + 2 ) : 0;
            y = new BigNumber(ONE);

            for ( ; ; ) {

                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if ( k && y.c.length > k ) y.c.length = k;
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;

                x = x.times(x);
                if ( k && x.c && x.c.length > k ) x.c.length = k;
            }

            if ( n < 0 ) y = ONE.div(y);
            return k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };



        /*
         * Return as toString, but do not accept a base argument.
         */
        P.valueOf = P.toJSON = function () {
            return this.toString();
        };


        // Aliases for BigDecimal methods.
        //P.add = P.plus;         // P.add included above
        //P.subtract = P.minus;   // P.sub included above
        //P.multiply = P.times;   // P.mul included above
        //P.divide = P.div;
        //P.remainder = P.mod;
        //P.compareTo = P.cmp;
        //P.negate = P.neg;


        if ( configObj != null ) BigNumber.config(configObj);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


    BigNumber = another();

    // AMD.
    if ( true ) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return BigNumber; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

    // Node and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = BigNumber;
        if ( !crypto ) try { crypto = require('crypto'); } catch (e) {}

    // Browser.
    } else {
        global.BigNumber = BigNumber;
    }
})(this);


/***/ }),

/***/ "../../node_modules/buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("../../node_modules/base64-js/index.js")
var ieee754 = __webpack_require__("../../node_modules/ieee754/index.js")
var isArray = __webpack_require__("../../node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/classnames/bind.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(this && this[arg] || arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(this, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(this && this[key] || key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),

/***/ "../../node_modules/classnames/index.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),

/***/ "../../node_modules/crypto-js/aes.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/cipher-core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;

	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }
	            this._mode = modeCreator.call(mode, this, iv && iv.words);
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ "../../node_modules/crypto-js/core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/enc-base64.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/enc-utf16.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/evpkdf.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/format-hex.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/hmac.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ "../../node_modules/crypto-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"), __webpack_require__("../../node_modules/crypto-js/lib-typedarrays.js"), __webpack_require__("../../node_modules/crypto-js/enc-utf16.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/sha256.js"), __webpack_require__("../../node_modules/crypto-js/sha224.js"), __webpack_require__("../../node_modules/crypto-js/sha512.js"), __webpack_require__("../../node_modules/crypto-js/sha384.js"), __webpack_require__("../../node_modules/crypto-js/sha3.js"), __webpack_require__("../../node_modules/crypto-js/ripemd160.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"), __webpack_require__("../../node_modules/crypto-js/pbkdf2.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"), __webpack_require__("../../node_modules/crypto-js/mode-cfb.js"), __webpack_require__("../../node_modules/crypto-js/mode-ctr.js"), __webpack_require__("../../node_modules/crypto-js/mode-ctr-gladman.js"), __webpack_require__("../../node_modules/crypto-js/mode-ofb.js"), __webpack_require__("../../node_modules/crypto-js/mode-ecb.js"), __webpack_require__("../../node_modules/crypto-js/pad-ansix923.js"), __webpack_require__("../../node_modules/crypto-js/pad-iso10126.js"), __webpack_require__("../../node_modules/crypto-js/pad-iso97971.js"), __webpack_require__("../../node_modules/crypto-js/pad-zeropadding.js"), __webpack_require__("../../node_modules/crypto-js/pad-nopadding.js"), __webpack_require__("../../node_modules/crypto-js/format-hex.js"), __webpack_require__("../../node_modules/crypto-js/aes.js"), __webpack_require__("../../node_modules/crypto-js/tripledes.js"), __webpack_require__("../../node_modules/crypto-js/rc4.js"), __webpack_require__("../../node_modules/crypto-js/rabbit.js"), __webpack_require__("../../node_modules/crypto-js/rabbit-legacy.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/lib-typedarrays.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/md5.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-cfb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ctr-gladman.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ctr.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ecb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ofb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-ansix923.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-iso10126.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-iso97971.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-nopadding.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-zeropadding.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pbkdf2.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rabbit-legacy.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rabbit.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rc4.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/ripemd160.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha1.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha224.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha256.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha256.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha3.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha384.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"), __webpack_require__("../../node_modules/crypto-js/sha512.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha512.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/tripledes.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/x64-core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/normalize.css/normalize.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}[hidden],template{display:none}", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/open-iconic/font/css/open-iconic.min.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, "@font-face{font-family:Icons;src:url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.eot") + ");src:url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.eot") + "?#iconic-sm) format(\"embedded-opentype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.woff") + ") format(\"woff\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.ttf") + ") format(\"truetype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.otf") + ") format(\"opentype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.svg") + "#iconic-sm) format(\"svg\");font-weight:400;font-style:normal}.oi[data-glyph].oi-text-replace{font-size:0;line-height:0}.oi[data-glyph].oi-text-replace:before{width:1em;text-align:center}.oi[data-glyph]:before{font-family:Icons;display:inline-block;speak:none;line-height:1;vertical-align:baseline;font-weight:400;font-style:normal;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.oi[data-glyph]:empty:before{width:1em;text-align:center;box-sizing:content-box}.oi[data-glyph].oi-align-left:before{text-align:left}.oi[data-glyph].oi-align-right:before{text-align:right}.oi[data-glyph].oi-align-center:before{text-align:center}.oi[data-glyph].oi-flip-horizontal:before{-webkit-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1)}.oi[data-glyph].oi-flip-vertical:before{-webkit-transform:scaleY(-1);-ms-transform:scaleX(-1);transform:scaleY(-1)}.oi[data-glyph].oi-flip-horizontal-vertical:before{-webkit-transform:scale(-1);-ms-transform:scaleX(-1);transform:scale(-1)}.oi[data-glyph=account-login]:before{content:\"\\E000\"}.oi[data-glyph=account-logout]:before{content:\"\\E001\"}.oi[data-glyph=action-redo]:before{content:\"\\E002\"}.oi[data-glyph=action-undo]:before{content:\"\\E003\"}.oi[data-glyph=align-center]:before{content:\"\\E004\"}.oi[data-glyph=align-left]:before{content:\"\\E005\"}.oi[data-glyph=align-right]:before{content:\"\\E006\"}.oi[data-glyph=aperture]:before{content:\"\\E007\"}.oi[data-glyph=arrow-bottom]:before{content:\"\\E008\"}.oi[data-glyph=arrow-circle-bottom]:before{content:\"\\E009\"}.oi[data-glyph=arrow-circle-left]:before{content:\"\\E00A\"}.oi[data-glyph=arrow-circle-right]:before{content:\"\\E00B\"}.oi[data-glyph=arrow-circle-top]:before{content:\"\\E00C\"}.oi[data-glyph=arrow-left]:before{content:\"\\E00D\"}.oi[data-glyph=arrow-right]:before{content:\"\\E00E\"}.oi[data-glyph=arrow-thick-bottom]:before{content:\"\\E00F\"}.oi[data-glyph=arrow-thick-left]:before{content:\"\\E010\"}.oi[data-glyph=arrow-thick-right]:before{content:\"\\E011\"}.oi[data-glyph=arrow-thick-top]:before{content:\"\\E012\"}.oi[data-glyph=arrow-top]:before{content:\"\\E013\"}.oi[data-glyph=audio-spectrum]:before{content:\"\\E014\"}.oi[data-glyph=audio]:before{content:\"\\E015\"}.oi[data-glyph=badge]:before{content:\"\\E016\"}.oi[data-glyph=ban]:before{content:\"\\E017\"}.oi[data-glyph=bar-chart]:before{content:\"\\E018\"}.oi[data-glyph=basket]:before{content:\"\\E019\"}.oi[data-glyph=battery-empty]:before{content:\"\\E01A\"}.oi[data-glyph=battery-full]:before{content:\"\\E01B\"}.oi[data-glyph=beaker]:before{content:\"\\E01C\"}.oi[data-glyph=bell]:before{content:\"\\E01D\"}.oi[data-glyph=bluetooth]:before{content:\"\\E01E\"}.oi[data-glyph=bold]:before{content:\"\\E01F\"}.oi[data-glyph=bolt]:before{content:\"\\E020\"}.oi[data-glyph=book]:before{content:\"\\E021\"}.oi[data-glyph=bookmark]:before{content:\"\\E022\"}.oi[data-glyph=box]:before{content:\"\\E023\"}.oi[data-glyph=briefcase]:before{content:\"\\E024\"}.oi[data-glyph=british-pound]:before{content:\"\\E025\"}.oi[data-glyph=browser]:before{content:\"\\E026\"}.oi[data-glyph=brush]:before{content:\"\\E027\"}.oi[data-glyph=bug]:before{content:\"\\E028\"}.oi[data-glyph=bullhorn]:before{content:\"\\E029\"}.oi[data-glyph=calculator]:before{content:\"\\E02A\"}.oi[data-glyph=calendar]:before{content:\"\\E02B\"}.oi[data-glyph=camera-slr]:before{content:\"\\E02C\"}.oi[data-glyph=caret-bottom]:before{content:\"\\E02D\"}.oi[data-glyph=caret-left]:before{content:\"\\E02E\"}.oi[data-glyph=caret-right]:before{content:\"\\E02F\"}.oi[data-glyph=caret-top]:before{content:\"\\E030\"}.oi[data-glyph=cart]:before{content:\"\\E031\"}.oi[data-glyph=chat]:before{content:\"\\E032\"}.oi[data-glyph=check]:before{content:\"\\E033\"}.oi[data-glyph=chevron-bottom]:before{content:\"\\E034\"}.oi[data-glyph=chevron-left]:before{content:\"\\E035\"}.oi[data-glyph=chevron-right]:before{content:\"\\E036\"}.oi[data-glyph=chevron-top]:before{content:\"\\E037\"}.oi[data-glyph=circle-check]:before{content:\"\\E038\"}.oi[data-glyph=circle-x]:before{content:\"\\E039\"}.oi[data-glyph=clipboard]:before{content:\"\\E03A\"}.oi[data-glyph=clock]:before{content:\"\\E03B\"}.oi[data-glyph=cloud-download]:before{content:\"\\E03C\"}.oi[data-glyph=cloud-upload]:before{content:\"\\E03D\"}.oi[data-glyph=cloud]:before{content:\"\\E03E\"}.oi[data-glyph=cloudy]:before{content:\"\\E03F\"}.oi[data-glyph=code]:before{content:\"\\E040\"}.oi[data-glyph=cog]:before{content:\"\\E041\"}.oi[data-glyph=collapse-down]:before{content:\"\\E042\"}.oi[data-glyph=collapse-left]:before{content:\"\\E043\"}.oi[data-glyph=collapse-right]:before{content:\"\\E044\"}.oi[data-glyph=collapse-up]:before{content:\"\\E045\"}.oi[data-glyph=command]:before{content:\"\\E046\"}.oi[data-glyph=comment-square]:before{content:\"\\E047\"}.oi[data-glyph=compass]:before{content:\"\\E048\"}.oi[data-glyph=contrast]:before{content:\"\\E049\"}.oi[data-glyph=copywriting]:before{content:\"\\E04A\"}.oi[data-glyph=credit-card]:before{content:\"\\E04B\"}.oi[data-glyph=crop]:before{content:\"\\E04C\"}.oi[data-glyph=dashboard]:before{content:\"\\E04D\"}.oi[data-glyph=data-transfer-download]:before{content:\"\\E04E\"}.oi[data-glyph=data-transfer-upload]:before{content:\"\\E04F\"}.oi[data-glyph=delete]:before{content:\"\\E050\"}.oi[data-glyph=dial]:before{content:\"\\E051\"}.oi[data-glyph=document]:before{content:\"\\E052\"}.oi[data-glyph=dollar]:before{content:\"\\E053\"}.oi[data-glyph=double-quote-sans-left]:before{content:\"\\E054\"}.oi[data-glyph=double-quote-sans-right]:before{content:\"\\E055\"}.oi[data-glyph=double-quote-serif-left]:before{content:\"\\E056\"}.oi[data-glyph=double-quote-serif-right]:before{content:\"\\E057\"}.oi[data-glyph=droplet]:before{content:\"\\E058\"}.oi[data-glyph=eject]:before{content:\"\\E059\"}.oi[data-glyph=elevator]:before{content:\"\\E05A\"}.oi[data-glyph=ellipses]:before{content:\"\\E05B\"}.oi[data-glyph=envelope-closed]:before{content:\"\\E05C\"}.oi[data-glyph=envelope-open]:before{content:\"\\E05D\"}.oi[data-glyph=euro]:before{content:\"\\E05E\"}.oi[data-glyph=excerpt]:before{content:\"\\E05F\"}.oi[data-glyph=expand-down]:before{content:\"\\E060\"}.oi[data-glyph=expand-left]:before{content:\"\\E061\"}.oi[data-glyph=expand-right]:before{content:\"\\E062\"}.oi[data-glyph=expand-up]:before{content:\"\\E063\"}.oi[data-glyph=external-link]:before{content:\"\\E064\"}.oi[data-glyph=eye]:before{content:\"\\E065\"}.oi[data-glyph=eyedropper]:before{content:\"\\E066\"}.oi[data-glyph=file]:before{content:\"\\E067\"}.oi[data-glyph=fire]:before{content:\"\\E068\"}.oi[data-glyph=flag]:before{content:\"\\E069\"}.oi[data-glyph=flash]:before{content:\"\\E06A\"}.oi[data-glyph=folder]:before{content:\"\\E06B\"}.oi[data-glyph=fork]:before{content:\"\\E06C\"}.oi[data-glyph=fullscreen-enter]:before{content:\"\\E06D\"}.oi[data-glyph=fullscreen-exit]:before{content:\"\\E06E\"}.oi[data-glyph=globe]:before{content:\"\\E06F\"}.oi[data-glyph=graph]:before{content:\"\\E070\"}.oi[data-glyph=grid-four-up]:before{content:\"\\E071\"}.oi[data-glyph=grid-three-up]:before{content:\"\\E072\"}.oi[data-glyph=grid-two-up]:before{content:\"\\E073\"}.oi[data-glyph=hard-drive]:before{content:\"\\E074\"}.oi[data-glyph=header]:before{content:\"\\E075\"}.oi[data-glyph=headphones]:before{content:\"\\E076\"}.oi[data-glyph=heart]:before{content:\"\\E077\"}.oi[data-glyph=home]:before{content:\"\\E078\"}.oi[data-glyph=image]:before{content:\"\\E079\"}.oi[data-glyph=inbox]:before{content:\"\\E07A\"}.oi[data-glyph=infinity]:before{content:\"\\E07B\"}.oi[data-glyph=info]:before{content:\"\\E07C\"}.oi[data-glyph=italic]:before{content:\"\\E07D\"}.oi[data-glyph=justify-center]:before{content:\"\\E07E\"}.oi[data-glyph=justify-left]:before{content:\"\\E07F\"}.oi[data-glyph=justify-right]:before{content:\"\\E080\"}.oi[data-glyph=key]:before{content:\"\\E081\"}.oi[data-glyph=laptop]:before{content:\"\\E082\"}.oi[data-glyph=layers]:before{content:\"\\E083\"}.oi[data-glyph=lightbulb]:before{content:\"\\E084\"}.oi[data-glyph=link-broken]:before{content:\"\\E085\"}.oi[data-glyph=link-intact]:before{content:\"\\E086\"}.oi[data-glyph=list-rich]:before{content:\"\\E087\"}.oi[data-glyph=list]:before{content:\"\\E088\"}.oi[data-glyph=location]:before{content:\"\\E089\"}.oi[data-glyph=lock-locked]:before{content:\"\\E08A\"}.oi[data-glyph=lock-unlocked]:before{content:\"\\E08B\"}.oi[data-glyph=loop-circular]:before{content:\"\\E08C\"}.oi[data-glyph=loop-square]:before{content:\"\\E08D\"}.oi[data-glyph=loop]:before{content:\"\\E08E\"}.oi[data-glyph=magnifying-glass]:before{content:\"\\E08F\"}.oi[data-glyph=map-marker]:before{content:\"\\E090\"}.oi[data-glyph=map]:before{content:\"\\E091\"}.oi[data-glyph=media-pause]:before{content:\"\\E092\"}.oi[data-glyph=media-play]:before{content:\"\\E093\"}.oi[data-glyph=media-record]:before{content:\"\\E094\"}.oi[data-glyph=media-skip-backward]:before{content:\"\\E095\"}.oi[data-glyph=media-skip-forward]:before{content:\"\\E096\"}.oi[data-glyph=media-step-backward]:before{content:\"\\E097\"}.oi[data-glyph=media-step-forward]:before{content:\"\\E098\"}.oi[data-glyph=media-stop]:before{content:\"\\E099\"}.oi[data-glyph=medical-cross]:before{content:\"\\E09A\"}.oi[data-glyph=menu]:before{content:\"\\E09B\"}.oi[data-glyph=microphone]:before{content:\"\\E09C\"}.oi[data-glyph=minus]:before{content:\"\\E09D\"}.oi[data-glyph=monitor]:before{content:\"\\E09E\"}.oi[data-glyph=moon]:before{content:\"\\E09F\"}.oi[data-glyph=move]:before{content:\"\\E0A0\"}.oi[data-glyph=musical-note]:before{content:\"\\E0A1\"}.oi[data-glyph=paperclip]:before{content:\"\\E0A2\"}.oi[data-glyph=pencil]:before{content:\"\\E0A3\"}.oi[data-glyph=people]:before{content:\"\\E0A4\"}.oi[data-glyph=person]:before{content:\"\\E0A5\"}.oi[data-glyph=phone]:before{content:\"\\E0A6\"}.oi[data-glyph=pie-chart]:before{content:\"\\E0A7\"}.oi[data-glyph=pin]:before{content:\"\\E0A8\"}.oi[data-glyph=play-circle]:before{content:\"\\E0A9\"}.oi[data-glyph=plus]:before{content:\"\\E0AA\"}.oi[data-glyph=power-standby]:before{content:\"\\E0AB\"}.oi[data-glyph=print]:before{content:\"\\E0AC\"}.oi[data-glyph=project]:before{content:\"\\E0AD\"}.oi[data-glyph=pulse]:before{content:\"\\E0AE\"}.oi[data-glyph=puzzle-piece]:before{content:\"\\E0AF\"}.oi[data-glyph=question-mark]:before{content:\"\\E0B0\"}.oi[data-glyph=rain]:before{content:\"\\E0B1\"}.oi[data-glyph=random]:before{content:\"\\E0B2\"}.oi[data-glyph=reload]:before{content:\"\\E0B3\"}.oi[data-glyph=resize-both]:before{content:\"\\E0B4\"}.oi[data-glyph=resize-height]:before{content:\"\\E0B5\"}.oi[data-glyph=resize-width]:before{content:\"\\E0B6\"}.oi[data-glyph=rss-alt]:before{content:\"\\E0B7\"}.oi[data-glyph=rss]:before{content:\"\\E0B8\"}.oi[data-glyph=script]:before{content:\"\\E0B9\"}.oi[data-glyph=share-boxed]:before{content:\"\\E0BA\"}.oi[data-glyph=share]:before{content:\"\\E0BB\"}.oi[data-glyph=shield]:before{content:\"\\E0BC\"}.oi[data-glyph=signal]:before{content:\"\\E0BD\"}.oi[data-glyph=signpost]:before{content:\"\\E0BE\"}.oi[data-glyph=sort-ascending]:before{content:\"\\E0BF\"}.oi[data-glyph=sort-descending]:before{content:\"\\E0C0\"}.oi[data-glyph=spreadsheet]:before{content:\"\\E0C1\"}.oi[data-glyph=star]:before{content:\"\\E0C2\"}.oi[data-glyph=sun]:before{content:\"\\E0C3\"}.oi[data-glyph=tablet]:before{content:\"\\E0C4\"}.oi[data-glyph=tag]:before{content:\"\\E0C5\"}.oi[data-glyph=tags]:before{content:\"\\E0C6\"}.oi[data-glyph=target]:before{content:\"\\E0C7\"}.oi[data-glyph=task]:before{content:\"\\E0C8\"}.oi[data-glyph=terminal]:before{content:\"\\E0C9\"}.oi[data-glyph=text]:before{content:\"\\E0CA\"}.oi[data-glyph=thumb-down]:before{content:\"\\E0CB\"}.oi[data-glyph=thumb-up]:before{content:\"\\E0CC\"}.oi[data-glyph=timer]:before{content:\"\\E0CD\"}.oi[data-glyph=transfer]:before{content:\"\\E0CE\"}.oi[data-glyph=trash]:before{content:\"\\E0CF\"}.oi[data-glyph=underline]:before{content:\"\\E0D0\"}.oi[data-glyph=vertical-align-bottom]:before{content:\"\\E0D1\"}.oi[data-glyph=vertical-align-center]:before{content:\"\\E0D2\"}.oi[data-glyph=vertical-align-top]:before{content:\"\\E0D3\"}.oi[data-glyph=video]:before{content:\"\\E0D4\"}.oi[data-glyph=volume-high]:before{content:\"\\E0D5\"}.oi[data-glyph=volume-low]:before{content:\"\\E0D6\"}.oi[data-glyph=volume-off]:before{content:\"\\E0D7\"}.oi[data-glyph=warning]:before{content:\"\\E0D8\"}.oi[data-glyph=wifi]:before{content:\"\\E0D9\"}.oi[data-glyph=wrench]:before{content:\"\\E0DA\"}.oi[data-glyph=x]:before{content:\"\\E0DB\"}.oi[data-glyph=yen]:before{content:\"\\E0DC\"}.oi[data-glyph=zoom-in]:before{content:\"\\E0DD\"}.oi[data-glyph=zoom-out]:before{content:\"\\E0DE\"}", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "../../node_modules/fbjs/lib/emptyFunction.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "../../node_modules/fbjs/lib/invariant.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "../../node_modules/history/DOMUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),

/***/ "../../node_modules/history/LocationUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _resolvePathname = __webpack_require__("../../node_modules/resolve-pathname/index.js");

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__("../../node_modules/value-equal/index.js");

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),

/***/ "../../node_modules/history/PathUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),

/***/ "../../node_modules/history/createBrowserHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__("../../node_modules/invariant/browser.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__("../../node_modules/history/DOMUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),

/***/ "../../node_modules/history/createHashHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__("../../node_modules/invariant/browser.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__("../../node_modules/history/DOMUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),

/***/ "../../node_modules/history/createMemoryHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),

/***/ "../../node_modules/history/createTransitionManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {

                }
            }
        }
    }

    return targetComponent;
};


/***/ }),

/***/ "../../node_modules/ieee754/index.js":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../../node_modules/invariant/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "../../node_modules/isarray/index.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../../node_modules/lodash.debounce/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/normalize.css/normalize.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/normalize.css/normalize.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css", function() {
			var newContent = require("!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../node_modules/open-iconic/font/css/open-iconic.min.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/open-iconic/font/css/open-iconic.min.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./open-iconic.min.css", function() {
			var newContent = require("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./open-iconic.min.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.eot":
/***/ (function(module, exports) {

module.exports = "data:application/vnd.ms-fontobject;base64,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KyNhOC2wOSywABawAyWwAiVHI0cjYbAAVFguIDwjIRuwAiWwAiVHI0cjYSCwBSWwBCVHI0cjYbAGJbAFJUmwAiVhuQgACABjYyMgWGIbIVljuAQAYiCwAFBYsEBgWWawAWNgIy4jICA8ijgjIVktsDossAAWILAIQyAuRyNHI2EgYLAgYGawAmIgsABQWLBAYFlmsAFjIyAgPIo4LbA7LCMgLkawAiVGUlggPFkusSsBFCstsDwsIyAuRrACJUZQWCA8WS6xKwEUKy2wPSwjIC5GsAIlRlJYIDxZIyAuRrACJUZQWCA8WS6xKwEUKy2wPiywNSsjIC5GsAIlRlJYIDxZLrErARQrLbA/LLA2K4ogIDywBCNCijgjIC5GsAIlRlJYIDxZLrErARQrsARDLrArKy2wQCywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixKwEUKy2wQSyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbErARQrLbBCLLA1Ky6xKwEUKy2wQyywNishIyAgPLAEI0IjOLErARQrsARDLrArKy2wRCywABUgR7AAI0KyAAEBFRQTLrAxKi2wRSywABUgR7AAI0KyAAEBFRQTLrAxKi2wRiyxAAEUE7AyKi2wRyywNCotsEgssAAWRSMgLiBGiiNhOLErARQrLbBJLLAII0KwSCstsEossgAAQSstsEsssgABQSstsEwssgEAQSstsE0ssgEBQSstsE4ssgAAQistsE8ssgABQistsFAssgEAQistsFEssgEBQistsFIssgAAPistsFMssgABPistsFQssgEAPistsFUssgEBPistsFYssgAAQCstsFcssgABQCstsFgssgEAQCstsFkssgEBQCstsFossgAAQystsFsssgABQystsFwssgEAQystsF0ssgEBQystsF4ssgAAPystsF8ssgABPystsGAssgEAPystsGEssgEBPystsGIssDcrLrErARQrLbBjLLA3K7A7Ky2wZCywNyuwPCstsGUssAAWsDcrsD0rLbBmLLA4Ky6xKwEUKy2wZyywOCuwOystsGgssDgrsDwrLbBpLLA4K7A9Ky2waiywOSsusSsBFCstsGsssDkrsDsrLbBsLLA5K7A8Ky2wbSywOSuwPSstsG4ssDorLrErARQrLbBvLLA6K7A7Ky2wcCywOiuwPCstsHEssDorsD0rLbByLLMJBAIDRVghGyMhWUIrsAhlsAMkUHiwARUwLQBLuADIUlixAQGOWbABuQgACABjcLEABUKxAAAqsQAFQrEACCqxAAVCsQAIKrEABUK5AAAACSqxAAVCuQAAAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWbEADCq4Af+FsASNsQIARAA="

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.otf":
/***/ (function(module, exports) {

module.exports = "data:font/opentype;base64,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VgFYAVoBXAFeAWABYgFkAWYBaAFqAWwBbgFwAXIBdAF2AXgBegF8AX4BgAGCAYQBhgGIAYoBjAGOAZABkgGUAZYBmAGaAZwBngGgAaIBpAGmAasB7QH2AfsxMjM0NTY3ODkxMDExMTIxMzE0MTUxNjE3MTgxOTFhMWIxYzFkMWUxZjIwMjEyMjIzMjQyNTI2MjcyODI5MmEyYjJjMmQyZTJmMzAzMTMyMzMzNDM1MzYzNzM4MzkzYTNiM2MzZDNlM2Y0MDQxNDI0MzQ0NDU0NjQ3NDg0OTRhNGI0YzRkNGU0ZjUwNTE1MjUzNTQ1NTU2NTc1ODU5NWE1YjVjNWQ1ZTVmNjA2MTYyNjM2NDY1NjY2NzY4Njk2YTZiNmM2ZDZlNmY3MDcxNzI3Mzc0NzU3Njc3Nzg3OTdhN2I3YzdkN2U3ZjgwODE4MjgzODQ4NTg2ODc4ODg5OGE4YjhjOGQ4ZThmOTA5MTkyOTM5NDk1OTY5Nzk4OTk5YTliOWM5ZDllOWZhMGExYTJhM2E0YTVhNmE3YThhOWFhYWJhY2FkYWZiMGIxYjJiM2I0YjViNmI3YjhiOWJhYmJiY2JkYmViZmMwYzFjMmMzYzRjNWM2YzdjOGM5Y2FjYmNjY2RjZWNmZDBkMWQyZDNkNGQ1ZDZkN2Q4ZDlkYWRiZGNkZGRlMS4xLjFDcmVhdGVkIGJ5IFAuSi4gT25vcmkgd2l0aCBGb250Rm9yZ2UgMi4wIChodHRwOi8vZm9udGZvcmdlLnNmLm5ldClVbnRpdGxlZDFJY29ucwAAAAGHAYgBiQGKAYsBjAGNAY4BjwGQAEIAQwBEAEUARgBHAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIX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"

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.svg":
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiID4KPCEtLQoyMDE0LTctMTogQ3JlYXRlZC4KLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPG1ldGFkYXRhPgpDcmVhdGVkIGJ5IEZvbnRGb3JnZSAyMDEyMDczMSBhdCBUdWUgSnVsICAxIDIwOjM5OjIyIDIwMTQKIEJ5IFAuSi4gT25vcmkKQ3JlYXRlZCBieSBQLkouIE9ub3JpIHdpdGggRm9udEZvcmdlIDIuMCAoaHR0cDovL2ZvbnRmb3JnZS5zZi5uZXQpCjwvbWV0YWRhdGE+CjxkZWZzPgo8Zm9udCBpZD0ib3Blbi1pY29uaWMiIGhvcml6LWFkdi14PSI4MDAiID4KICA8Zm9udC1mYWNlIAogICAgZm9udC1mYW1pbHk9Ikljb25zIgogICAgZm9udC13ZWlnaHQ9IjQwMCIKICAgIGZvbnQtc3RyZXRjaD0ibm9ybWFsIgogICAgdW5pdHMtcGVyLWVtPSI4MDAiCiAgICBwYW5vc2UtMT0iMiAwIDUgMyAwIDAgMCAwIDAgMCIKICAgIGFzY2VudD0iODAwIgogICAgZGVzY2VudD0iMCIKICAgIGJib3g9Ii0wLjUgLTEwMSA4MDIgODAwLjEyNiIKICAgIHVuZGVybGluZS10aGlja25lc3M9IjUwIgogICAgdW5kZXJsaW5lLXBvc2l0aW9uPSItMTAwIgogICAgdW5pY29kZS1yYW5nZT0iVStFMDAwLUUwREUiCiAgLz4KICAgIDxtaXNzaW5nLWdseXBoIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iIiB1bmljb2RlPSImI3hlMDAwOyIgCmQ9Ik0zMDAgNzAwaDUwMHYtNzAwaC01MDB2MTAwaDQwMHY1MDBoLTQwMHYxMDB6TTQwMCA1MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNDAwdjEwMGg0MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxIiB1bmljb2RlPSImI3hlMDAxOyIgCmQ9Ik0zMDAgNzAwaDUwMHYtNzAwaC01MDB2MTAwaDQwMHY1MDBoLTQwMHYxMDB6TTIwMCA1MDB2LTEwMGg0MDB2LTEwMGgtNDAwdi0xMDBsLTIwMCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIiIHVuaWNvZGU9IiYjeGUwMDI7IiAKZD0iTTM1MCA3MDBjMTkzIDAgMzUwIC0xNTcgMzUwIC0zNTB2LTUwaDEwMGwtMjAwIC0yMDBsLTIwMCAyMDBoMTAwdjUwYzAgMTM4IC0xMTIgMjUwIC0yNTAgMjUwcy0yNTAgLTExMiAtMjUwIC0yNTBjMCAxOTMgMTU3IDM1MCAzNTAgMzUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzIiB1bmljb2RlPSImI3hlMDAzOyIgCmQ9Ik00NTAgNzAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgMTM4IC0xMTIgMjUwIC0yNTAgMjUwcy0yNTAgLTExMiAtMjUwIC0yNTB2LTUwaDEwMGwtMjAwIC0yMDBsLTIwMCAyMDBoMTAwdjUwYzAgMTkzIDE1NyAzNTAgMzUwIDM1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNCIgdW5pY29kZT0iJiN4ZTAwNDsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTEwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0xMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1IiB1bmljb2RlPSImI3hlMDA1OyIgCmQ9Ik0wIDcwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNiIgdW5pY29kZT0iJiN4ZTAwNjsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTIwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0yMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3IiB1bmljb2RlPSImI3hlMDA3OyIgCmQ9Ik00MDAgNzAwYzc1IDAgMTQ2IC0yMyAyMDYgLTU5bC03NSAtMjI1bC0zMjIgMjM0YzU3IDMxIDEyMiA1MCAxOTEgNTB6TTEyNSA1ODhsMTkxIC0xMzhsLTMxMCAtMjIyYy00IDI0IC02IDQ3IC02IDcyYzAgMTE0IDQ5IDIxNSAxMjUgMjg4ek02ODggNTc1YzY5IC03MiAxMTIgLTE2OCAxMTIgLTI3NWMwIC0zNSAtOCAtNjggLTE2IC0xMDBoLTIxOHpNMjE2IDI1M2wxMTIgLTM0N2MtMTI4IDIzIC0yMzIgMTA5IC0yODcgMjIyek0zNzIgMTAwCmgzNzJjLTY0IC0xMDkgLTE3NyAtMTg1IC0zMTAgLTE5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOCIgdW5pY29kZT0iJiN4ZTAwODsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjAwIDgwMGgxMDB2LTUwMGgyMDBsLTI0NyAtMzAwbC0yNTMgMzAwaDIwMHY1MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjkiIHVuaWNvZGU9IiYjeGUwMDk7IiAKZD0iTTQwMCA4MDBjMjIxIDAgNDAwIC0xNzkgNDAwIC00MDBzLTE3OSAtNDAwIC00MDAgLTQwMHMtNDAwIDE3OSAtNDAwIDQwMHMxNzkgNDAwIDQwMCA0MDB6TTMwMCA3MDB2LTMwMGgtMjAwbDMwMCAtMzAwbDMwMCAzMDBoLTIwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYSIgdW5pY29kZT0iJiN4ZTAwYTsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGwtMzAwIC0zMDBsMzAwIC0zMDB2MjAwaDMwMHYyMDBoLTMwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImIiIHVuaWNvZGU9IiYjeGUwMGI7IiAKZD0iTTQwMCA4MDBjMjIxIDAgNDAwIC0xNzkgNDAwIC00MDBzLTE3OSAtNDAwIC00MDAgLTQwMHMtNDAwIDE3OSAtNDAwIDQwMHMxNzkgNDAwIDQwMCA0MDB6TTQwMCA3MDB2LTIwMGgtMzAwdi0yMDBoMzAwdi0yMDBsMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYyIgdW5pY29kZT0iJiN4ZTAwYzsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGwtMzAwIC0zMDBoMjAwdi0zMDBoMjAwdjMwMGgyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQiIHVuaWNvZGU9IiYjeGUwMGQ7IiAKZD0iTTMwMCA2MDB2LTIwMGg1MDB2LTEwMGgtNTAwdi0yMDBsLTMwMCAyNDd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImUiIHVuaWNvZGU9IiYjeGUwMGU7IiAKZD0iTTUwMCA2MDBsMzAwIC0yNDdsLTMwMCAtMjUzdjIwMGgtNTAwdjEwMGg1MDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmIiB1bmljb2RlPSImI3hlMDBmOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yMDAgODAwaDIwMHYtNTAwaDIwMGwtMjk3IC0zMDBsLTMwMyAzMDBoMjAwdjUwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTAiIHVuaWNvZGU9IiYjeGUwMTA7IiAKZD0iTTMwMCA3MDB2LTIwMGg1MDB2LTIwMGgtNTAwdi0yMDBsLTMwMCAyOTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjExIiB1bmljb2RlPSImI3hlMDExOyIgCmQ9Ik01MDAgNzAwbDMwMCAtMjk3bC0zMDAgLTMwM3YyMDBoLTUwMHYyMDBoNTAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTIiIHVuaWNvZGU9IiYjeGUwMTI7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTI5NyA4MDBsMzAzIC0zMDBoLTIwMHYtNTAwaC0yMDB2NTAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjEzIiB1bmljb2RlPSImI3hlMDEzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yNDcgODAwbDI1MyAtMzAwaC0yMDB2LTUwMGgtMTAwdjUwMGgtMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxNCIgdW5pY29kZT0iJiN4ZTAxNDsiIApkPSJNNDAwIDgwMGgxMDB2LTgwMGgtMTAwdjgwMHpNMjAwIDcwMGgxMDB2LTYwMGgtMTAwdjYwMHpNNjAwIDYwMGgxMDB2LTQwMGgtMTAwdjQwMHpNMCA1MDBoMTAwdi0yMDBoLTEwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE1IiB1bmljb2RlPSImI3hlMDE1OyIgCmQ9Ik0xMTYgNjAwbDcyIC03MmMtNTQgLTU0IC04OCAtMTI2IC04OCAtMjA5czM0IC0xNTkgODggLTIxM2wtNzIgLTcyYy03MiA3MiAtMTE2IDE3NSAtMTE2IDI4NXM0NCAyMDkgMTE2IDI4MXpNNjg0IDYwMGM3MiAtNzIgMTE2IC0xNzEgMTE2IC0yODFzLTQ0IC0yMTMgLTExNiAtMjg1bC03MiA3MmM1NCA1NCA4OCAxMzAgODggMjEzcy0zNCAxNTUgLTg4IDIwOXpNMjU5IDQ2MGw2OSAtNzJjLTE4IC0xOCAtMjggLTQxIC0yOCAtNjkKczEwIC01NCAyOCAtNzJsLTY5IC03MmMtMzYgMzYgLTU5IDg5IC01OSAxNDRzMjMgMTA1IDU5IDE0MXpNNTQxIDQ1OWMzNiAtMzYgNTkgLTg1IDU5IC0xNDBzLTIzIC0xMDggLTU5IC0xNDRsLTY5IDcyYzE4IDE4IDI4IDQ0IDI4IDcycy0xMCA1MSAtMjggNjl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE2IiB1bmljb2RlPSImI3hlMDE2OyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0yMDAgODAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDBzOTAgMjAwIDIwMCAyMDB6TTEwMCAzMTljMzEgLTExIDY1IC0xOSAxMDAgLTE5czY4IDggMTAwIDE5di0zMTlsLTEwMCAxMDBsLTEwMCAtMTAwdjMxOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTciIHVuaWNvZGU9IiYjeGUwMTc7IiAKZD0iTTQwMCA4MDBjMjIwIDAgNDAwIC0xODAgNDAwIC00MDBzLTE4MCAtNDAwIC00MDAgLTQwMHMtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6TTQwMCA3MDBjLTE2NiAwIC0zMDAgLTEzNCAtMzAwIC0zMDBjMCAtNjYgMjEgLTEyNiA1NiAtMTc1bDQxOSA0MTljLTQ5IDM1IC0xMDkgNTYgLTE3NSA1NnpNNjQ0IDU3NWwtNDE5IC00MTljNDkgLTM1IDEwOSAtNTYgMTc1IC01NmMxNjYgMCAzMDAgMTM0IDMwMCAzMDAKYzAgNjYgLTIxIDEyNiAtNTYgMTc1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxOCIgdW5pY29kZT0iJiN4ZTAxODsiIApkPSJNMCA3MDBoMTAwdi02MDBoNzAwdi0xMDBoLTgwMHY3MDB6TTUwMCA3MDBoMjAwdi01MDBoLTIwMHY1MDB6TTIwMCA1MDBoMjAwdi0zMDBoLTIwMHYzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE5IiB1bmljb2RlPSImI3hlMDE5OyIgCmQ9Ik0zOTcgODAwYzEzIDEgMjMgLTQgMzQgLTEzYzIgLTIgMjE0IC0yNTQgMjQxIC0yODdoMTI4di0xMDBoLTEwMHYtMzY2YzAgLTE4IC0xNiAtMzQgLTM0IC0zNGgtNTMyYy0xOCAwIC0zNCAxNiAtMzQgMzR2MzY2aC0xMDB2MTAwaDEyOGwyMzQgMjgxYzkgMTEgMjIgMTggMzUgMTl6TTQwMCA2NzJsLTE0NCAtMTcyaDI4OHpNMjUwIDMwMGMtMjggMCAtNTAgLTIyIC01MCAtNTB2LTEwMGMwIC0yOCAyMiAtNTAgNTAgLTUwczUwIDIyIDUwIDUwCnYxMDBjMCAyOCAtMjIgNTAgLTUwIDUwek01NTAgMzAwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtMTAwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MTAwYzAgMjggLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWEiIHVuaWNvZGU9IiYjeGUwMWE7IiAKZD0iTTkgNzAwaDY4MmM2IDAgOSAtNCA5IC0xMHYtMTkwaDEwMHYtMjAwaC0xMDB2LTE5MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2NTgyYzAgNiAzIDkgOSA5ek0xMDAgNjAwdi00MDBoNTAwdjQwMGgtNTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxYiIgdW5pY29kZT0iJiN4ZTAxYjsiIApkPSJNOSA3MDBoNjgyYzYgMCA5IC00IDkgLTEwdi0xOTBoMTAwdi0yMDBoLTEwMHYtMTkxYzAgLTYgLTMgLTkgLTkgLTloLTY4MmMtNiAwIC05IDMgLTkgOXY1ODJjMCA2IDMgOSA5IDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjFjIiB1bmljb2RlPSImI3hlMDFjOyIgCmQ9Ik05MiA2NTBjMCAyMyAxOSA1MCA0NSA1MGgzaDVoNWg1MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTB2LTE0MWM5IC0xNyAxMjAgLTIzMSAxNjYgLTMwOWMxNiAtMjYgMzQgLTYxIDM0IC0xMDZjMCAtMzkgLTE1IC03NyAtNDEgLTEwM2gtM2MtMjYgLTI1IC02MiAtNDEgLTEwMCAtNDFoLTUxMmMtMzkgMCAtNzcgMTUgLTEwMyA0MXMtNDEgNjQgLTQxIDEwM2MwIDQ2IDE4IDgwIDM0IDEwNgpjNDYgNzggMTU3IDI5MiAxNjYgMzA5djE0MWgtNTBjLTIgMCAtNiAtMSAtOCAtMWMtMjggMCAtNTAgMjMgLTUwIDUxek01MDAgNjAwaC0yMDB2LTE2MmwtNiAtMTBzLTYzIC0xMjMgLTExOSAtMjI4aDQ1MGMtNTYgMTA1IC0xMTkgMjI4IC0xMTkgMjI4bC02IDEwdjE2MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWQiIHVuaWNvZGU9IiYjeGUwMWQ7IiAKZD0iTTQwMCA4MDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMGMwIC0xMDQgNTIgLTE5OCAxMzQgLTI2NmM0MSAtMzQgNjYgLTgyIDY2IC0xMzRoLTgwMGMwIDUyIDI1IDEwMCA2NiAxMzRjODIgNjggMTM0IDE2MiAxMzQgMjY2YzAgMTEwIDkwIDIwMCAyMDAgMjAwek0zMDAgMTAwaDIwMGMwIC01NSAtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWUiIHVuaWNvZGU9IiYjeGUwMWU7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTE1MCA4MDBoNTBsMzUwIC0yNTBsLTIyNSAtMTQ3bDIyNSAtMTUzbC0zNTAgLTI1MGgtNTB2MjUwbC03NSAtNzVsLTc1IDc1bDE1MCAxNTBsLTE1MCAxNTBsNzUgNzVsNzUgLTc1djI1MHpNMjUwIDY1MHYtMjAwbDE1MCAxMDB6TTI1MCAzNTB2LTIwMGwxNTAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxZiIgdW5pY29kZT0iJiN4ZTAxZjsiIApkPSJNMCA4MDBoNTAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBjMCAtNDcgLTE3IC05MSAtNDQgLTEyNWM4NSAtNDAgMTQ0IC0xMjUgMTQ0IC0yMjVjMCAtMTM4IC0xMTIgLTI1MCAtMjUwIC0yNTBoLTU1MHYxMDBjNTUgMCAxMDAgNDUgMTAwIDEwMHY0MDBjMCA1NSAtNDUgMTAwIC0xMDAgMTAwdjEwMHpNMzAwIDcwMHYtMjAwaDEwMGM1NSAwIDEwMCA0NSAxMDAgMTAwcy00NSAxMDAgLTEwMCAxMDBoLTEwMHpNMzAwIDQwMHYtMzAwaDE1MApjODMgMCAxNTAgNjcgMTUwIDE1MHMtNjcgMTUwIC0xNTAgMTUwaC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIwIiB1bmljb2RlPSImI3hlMDIwOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0zMDAgODAwdi0zMDBoMjAwbC0zMDAgLTUwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjEiIHVuaWNvZGU9IiYjeGUwMjE7IiAKZD0iTTEwMCA4MDBoMzAwdi0zMDBsMTAwIDEwMGwxMDAgLTEwMHYzMDBoNTBjMjggMCA1MCAtMjIgNTAgLTUwdi01NTBoLTU1MGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGg1NTB2LTEwMGgtNTUwYy04MyAwIC0xNTAgNjcgLTE1MCAxNTB2NTUwbDMgMTljOCAzOSAzOSA3MCA3OCA3OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjIiIHVuaWNvZGU9IiYjeGUwMjI7IiBob3Jpei1hZHYteD0iNDAwIiAKZD0iTTAgODAwaDQwMHYtODAwbC0yMDAgMjAwbC0yMDAgLTIwMHY4MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIzIiB1bmljb2RlPSImI3hlMDIzOyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA2MDBoMzAwdi0xMDNoMjAzdjEwM2gyOTd2LTU5MWMwIC02IC0zIC05IC05IC05aC03ODJjLTYgMCAtOSAzIC05IDl2NTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNCIgdW5pY29kZT0iJiN4ZTAyNDsiIApkPSJNMzAwIDgwMGgyMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwdi0xMDBoMTkxYzYgMCA5IC0zIDkgLTl2LTI0MWMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjI0MWMwIDYgMyA5IDkgOWgxOTF2MTAwYzAgNTUgNDUgMTAwIDEwMCAxMDB6TTMwMCA3MDB2LTEwMGgyMDB2MTAwaC0yMDB6TTAgMjA5YzE2IC02IDMyIC05IDUwIC05aDcwMGMxOCAwIDM0IDMgNTAgOXYtMjAwYzAgLTYgLTMgLTkgLTkgLTloLTc4MgpjLTYgMCAtOSAzIC05IDl2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNSIgdW5pY29kZT0iJiN4ZTAyNTsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGM1OCAwIDExMCAtMTYgMTQ3IC01M3M1MyAtODkgNTMgLTE0N2gtMTAwYzAgMzkgLTExIDYxIC0yNSA3NXMtMzYgMjUgLTc1IDI1Yy0zNSAwIC01NSAtMTAgLTcyIC0zMXMtMjggLTU1IC0yOCAtOTRjMCAtNTEgMjAgLTEwNyAyOCAtMTc1aDE3MnYtMTAwaC0xNzhjLTE0IC02MCAtNDkgLTEyNyAtMTEzIC0yMDBoNDkxdi0xMDBoLTYwMHYxMjJsMTYgMTJjNjkgNjkgOTUgMTIxIDEwNiAxNjZoLTEyMnYxMDBoMTI1CmMtOCA1MCAtMjUgMTA2IC0yNSAxNzVjMCA1OCAxNiAxMTQgNTAgMTU2YzM0IDQzIDg4IDY5IDE1MCA2OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjYiIHVuaWNvZGU9IiYjeGUwMjY7IiAKZD0iTTM0IDcwMGg0aDNoNGg1aDcwMGMyOCAwIDUwIC0yMiA1MCAtNTB2LTcwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjcwMHYyYzAgMjAgMTUgNDIgMzQgNDh6TTE1MCA2MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHpNMzUwIDYwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGgzMDBjMjggMCA1MCAyMiA1MCA1MApzLTIyIDUwIC01MCA1MGgtMzAwek0xMDAgNDAwdi00MDBoNjAwdjQwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNyIgdW5pY29kZT0iJiN4ZTAyNzsiIApkPSJNNzQ0IDc5N2w2IC0zbDQ0IC00NGM0IC00IDMgLTggMCAtMTJsLTI2NiAtMzc1bC0xNSAtMTNsLTI1IC0xMmMtMjMgNzIgLTc4IDEyNyAtMTUwIDE1MGwxMiAyNWwxMyAxNWwzNzUgMjY2ek0yNjYgNDAwYzc0IDAgMTM0IC02MCAxMzQgLTEzNGMwIC0xNDcgLTExOSAtMjY2IC0yNjYgLTI2NmMtNDggMCAtOTUgMTIgLTEzNCAzNGM4MCA0NiAxMzQgMTMzIDEzNCAyMzJjMCA3NCA1OCAxMzQgMTMyIDEzNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjgiIHVuaWNvZGU9IiYjeGUwMjg7IiAKZD0iTTkgNDUxYzAgMjMgMTkgNTAgNDYgNTBjOCAwIDE5IC0zIDI2IC03bDEzMSAtNjZsMjkgMjJjLTc5IDgxIC0xIDI1MCAxMTggMjUwczE5NyAtMTY3IDExOSAtMjUwbDI4IC0yMmwxMzEgNjZjNiA0IDEyIDcgMjEgN2MyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTcgLTEyIC0zNyAtMjcgLTQ1bC0xMTUgLTU2YzkgLTE2IDE5IC0zMyAyNSAtNTBoNjhjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTAKYzAgLTIzIC0yIC00NSAtNiAtNjZsNzggLTQwYzIxIC01IDM3IC0yOCAzNyAtNDljMCAtMjggLTIyIC01MCAtNTAgLTUwYy0xMCAwIC0yMyA1IC0zMSAxMWwtNjUgMzVjLTI0IC00NiAtNjIgLTg2IC0xMDMgLTExMGMtMzUgMTkgLTYwIDQ1IC02MCA3MnYxMzV2NHY1djZ2NXY1djg3YzAgMjggLTIyIDUwIC01MCA1MGMtMjQgMCAtNDUgLTE3IC01MCAtNDBjMSAtMyAxIC04IDEgLTExczAgLTggLTEgLTExdi04MnYtNHYtNXYtMTQ0CmMwIC0yOCAtMjQgLTUzIC01OSAtNzJjLTQxIDI1IC03OSA2NCAtMTAzIDExMGwtNjYgLTM1Yy04IC02IC0yMSAtMTEgLTMxIC0xMWMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMjEgMTYgNDQgMzcgNDlsNzggNDBjLTQgMjEgLTYgNDMgLTYgNjZoLTUwaC01Yy0yOCAwIC01MCAyMiAtNTAgNTBjMCAyNiAyMiA1MCA1MCA1MGg1aDY5YzYgMTcgMTYgMzQgMjUgNTBsLTExNiA1NmMtMTYgNyAtMjggMjcgLTI4IDQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyOSIgdW5pY29kZT0iJiN4ZTAyOTsiIApkPSJNNjAwIDcwMGg5MWM2IDAgOSAtMyA5IC05di01ODJjMCAtNiAtMyAtOSAtOSAtOWgtOTF2NjAwek0yMTAgNTAzbDI5MCAxNDd2LTUwMGwtMjUwIDEyNXYtM2MtMTUgMCAtMjUgLTggLTI4IC0yMmw3NSAtMTc4YzExIC0yNSAwIC01OCAtMjUgLTY5cy01OCAwIC02OSAyNWwtMTAzIDI3MmgtOTFjLTYgMCAtOSAzIC05IDl2MTgyYzAgNiAzIDkgOSA5aDE4MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMmEiIHVuaWNvZGU9IiYjeGUwMmE7IiAKZD0iTTkgODAwaDY4MmM2IDAgOSAtMyA5IC05di03ODJjMCAtNiAtMyAtOSAtOSAtOWgtNjgyYy02IDAgLTkgMyAtOSA5djc4MmMwIDYgMyA5IDkgOXpNMTAwIDcwMHYtMjAwaDUwMHYyMDBoLTUwMHpNMTAwIDQwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMzAwIDQwMHYtMTAwaDEwMHYxMDBoLTEwMHpNNTAwIDQwMHYtMzAwaDEwMHYzMDBoLTEwMHpNMTAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMzAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMmIiIHVuaWNvZGU9IiYjeGUwMmI7IiAKZD0iTTAgODAwaDcwMHYtMjAwaC03MDB2MjAwek0wIDUwMGg3MDB2LTQ5MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2NDkxek0xMDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek01MDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek0xMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyYyIgdW5pY29kZT0iJiN4ZTAyYzsiIApkPSJNNDA5IDgwMGgxODJjNiAwIDEwIC00IDEyIC05bDk0IC0xODJjMiAtNSA2IC05IDEyIC05aDgyYzYgMCA5IC0zIDkgLTl2LTU4MmMwIC02IC0zIC05IC05IC05aC03ODJjLTYgMCAtOSAzIC05IDl2NDQxYzAgODMgNjcgMTUwIDE1MCAxNTBoMTQxYzYgMCAxMCA0IDEyIDlsOTQgMTgyYzIgNSA2IDkgMTIgOXpNMTUwIDUwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwegpNNTAwIDUwMGMtMTEwIDAgLTIwMCAtOTAgLTIwMCAtMjAwczkwIC0yMDAgMjAwIC0yMDBzMjAwIDkwIDIwMCAyMDBzLTkwIDIwMCAtMjAwIDIwMHpNNTAwIDQwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBzLTQ1IC0xMDAgLTEwMCAtMTAwcy0xMDAgNDUgLTEwMCAxMDBzNDUgMTAwIDEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjJkIiB1bmljb2RlPSImI3hlMDJkOyIgCmQ9Ik0wIDYwMGg4MDBsLTQwMCAtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyZSIgdW5pY29kZT0iJiN4ZTAyZTsiIGhvcml6LWFkdi14PSI0MDAiIApkPSJNNDAwIDgwMHYtODAwbC00MDAgNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyZiIgdW5pY29kZT0iJiN4ZTAyZjsiIGhvcml6LWFkdi14PSI0MDAiIApkPSJNMCA4MDBsNDAwIC00MDBsLTQwMCAtNDAwdjgwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzAiIHVuaWNvZGU9IiYjeGUwMzA7IiAKZD0iTTQwMCA2MDBsNDAwIC00MDBoLTgwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzEiIHVuaWNvZGU9IiYjeGUwMzE7IiAKZD0iTTAgNTUwYzAgMjMgMjAgNTAgNDYgNTBoM2g1aDRoMjAwYzE3IDAgMzcgLTEzIDQ0IC0yOGwzOCAtNzJoNDQ0YzE0IDAgMTkgLTEyIDE1IC0yNWwtODEgLTI1MGMtNCAtMTMgLTIxIC0yNSAtMzUgLTI1aC0zNTBjLTE0IDAgLTMwIDEyIC0zNCAyNWMtMjcgODMgLTU0IDE2NyAtODEgMjUwbC0xMCAyNWgtMTUwYy0yIDAgLTUgLTEgLTcgLTFjLTI4IDAgLTUxIDIzIC01MSA1MXpNMzU4IDEwMGMyOCAwIDUwIC0yMiA1MCAtNTAKcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek02NTggMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzIiIHVuaWNvZGU9IiYjeGUwMzI7IiAKZD0iTTAgNzAwaDUwMHYtMTAwaC0zMDB2LTMwMGgtMTAwbC0xMDAgLTEwMHY1MDB6TTMwMCA1MDBoNTAwdi01MDBsLTEwMCAxMDBoLTQwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjMzIiB1bmljb2RlPSImI3hlMDMzOyIgCmQ9Ik02NDEgNzAwbDE0MyAtMTQxbC00OTMgLTQ5M2MtNzEgNzYgLTE0NiAxNDggLTIxOSAyMjJsLTcyIDcxbDE0MSAxNDFjNTAgLTUxIDEwMSAtMTAxIDE1MyAtMTUwYzExNiAxMTcgMjM0IDIzMSAzNDcgMzUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzNCIgdW5pY29kZT0iJiN4ZTAzNDsiIApkPSJNMTUwIDYwMGwyNTAgLTI1MGwyNTAgMjUwbDE1MCAtMTUwbC00MDAgLTQwMGwtNDAwIDQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzUiIHVuaWNvZGU9IiYjeGUwMzU7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTQwMCA4MDBsMTUwIC0xNTBsLTI1MCAtMjUwbDI1MCAtMjUwbC0xNTAgLTE1MGwtNDAwIDQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzYiIHVuaWNvZGU9IiYjeGUwMzY7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTE1MCA4MDBsNDAwIC00MDBsLTQwMCAtNDAwbC0xNTAgMTUwbDI1MCAyNTBsLTI1MCAyNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM3IiB1bmljb2RlPSImI3hlMDM3OyIgCmQ9Ik00MDAgNjAwbDQwMCAtNDAwbC0xNTAgLTE1MGwtMjUwIDI1MGwtMjUwIC0yNTBsLTE1MCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM4IiB1bmljb2RlPSImI3hlMDM4OyIgCmQ9Ik00MDAgODAwYzIyMSAwIDQwMCAtMTc5IDQwMCAtNDAwcy0xNzkgLTQwMCAtNDAwIC00MDBzLTQwMCAxNzkgLTQwMCA0MDBzMTc5IDQwMCA0MDAgNDAwek02MDAgNjIybC0yNTAgLTI1MGwtMTAwIDEwMGwtNzIgLTcybDE3MiAtMTcybDMyMiAzMjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM5IiB1bmljb2RlPSImI3hlMDM5OyIgCmQ9Ik00MDAgODAwYzIyMSAwIDQwMCAtMTc5IDQwMCAtNDAwcy0xNzkgLTQwMCAtNDAwIC00MDBzLTQwMCAxNzkgLTQwMCA0MDBzMTc5IDQwMCA0MDAgNDAwek0yNTAgNjIybC03MiAtNzJsMTUwIC0xNTBsLTE1MCAtMTUwbDcyIC03MmwxNTAgMTUwbDE1MCAtMTUwbDcyIDcybC0xNTAgMTUwbDE1MCAxNTBsLTcyIDcybC0xNTAgLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iM2EiIHVuaWNvZGU9IiYjeGUwM2E7IiAKZD0iTTM1MCA4MDBjMjggMCA1MCAtMjIgNTAgLTUwdi01MGg3NWMxNCAwIDI1IC0xMSAyNSAtMjV2LTc1aC0zMDB2NzVjMCAxNCAxMSAyNSAyNSAyNWg3NXY1MGMwIDI4IDIyIDUwIDUwIDUwek0yNSA3MDBoNzV2LTIwMGg1MDB2MjAwaDc1YzE0IDAgMjUgLTExIDI1IC0yNXYtNjUwYzAgLTE0IC0xMSAtMjUgLTI1IC0yNWgtNjUwYy0xNCAwIC0yNSAxMSAtMjUgMjV2NjUwYzAgMTQgMTEgMjUgMjUgMjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjNiIiB1bmljb2RlPSImI3hlMDNiOyIgCmQ9Ik00MDAgODAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwcy0xODAgLTQwMCAtNDAwIC00MDBzLTQwMCAxODAgLTQwMCA0MDBzMTgwIDQwMCA0MDAgNDAwek00MDAgNzAwYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwczMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHpNMzUwIDYwMGgxMDB2LTE4MWMyMyAtMjQgNDcgLTQ3IDcyIC02OWwtNzIgLTcyYy0yNyAzMCAtNTUgNTkgLTg0IDg4bC0xNiAxMgp2MjIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzYyIgdW5pY29kZT0iJiN4ZTAzYzsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtMTggLTMgLTM0IC05IC01MGgtMTkxdjUwYzAgODMgLTY3IDE1MCAtMTUwIDE1MHMtMTUwIC02NyAtMTUwIC0xNTB2LTUwaC0yNzJjLTE3IDMwIC0yOCA2MyAtMjggMTAwYzAgMTEwIDkwIDIwMCAyMDAgMjAwYzIzIDExNCAxMjkgMjAwIDI1MCAyMDB6TTQzNCA0MDBoM2g0YzMgMCA2IDEgOSAxYzI4IDAgNTAgLTIyIDUwIC01MHYtMQp2LTE1MGgxNTBsLTIwMCAtMjAwbC0yMDAgMjAwaDE1MHYxNTB2MmMwIDIwIDE1IDQyIDM0IDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzZCIgdW5pY29kZT0iJiN4ZTAzZDsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtMTggLTMgLTM0IC05IC01MGgtMTQxbC0yMDAgMjAwbC0yMDAgLTIwMGgtMjIyYy0xNyAzMCAtMjggNjMgLTI4IDEwMGMwIDExMCA5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAwek00NTAgMzUwbDI1MCAtMjUwaC0yMDB2LTUwYzAgLTI4IC0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwdjUwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjNlIiB1bmljb2RlPSImI3hlMDNlOyIgCmQ9Ik00NTAgNzAwYzEzOCAwIDI1MCAtMTEyIDI1MCAtMjUwdi01MGM1OCAtMjEgMTAwIC04NSAxMDAgLTE1MGMwIC04MyAtNjcgLTE1MCAtMTUwIC0xNTBoLTQ1MGMtMTEwIDAgLTIwMCA5MCAtMjAwIDIwMHM5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzZiIgdW5pY29kZT0iJiN4ZTAzZjsiIApkPSJNMjUwIDgwMGM4MiAwIDE1NCAtNDAgMjAwIC0xMDBjLTE0MyAwIC0yNzAgLTg1IC0zMjUgLTIwOWMtMzYgLTEwIC03MCAtMjUgLTEwMCAtNDdjLTE2IDMzIC0yNSA2NyAtMjUgMTA2YzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNNDUwIDYwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwaC00NTBjLTExMCAwIC0yMDAgOTAgLTIwMCAyMDAKczkwIDIwMCAyMDAgMjAwYzIzIDExNCAxMjkgMjAwIDI1MCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQwIiB1bmljb2RlPSImI3hlMDQwOyIgCmQ9Ik01MDAgNzAwaDEwMGwtMzAwIC02MDBoLTEwMHpNMTAwIDYwMGgxMDBsLTEwMCAtMjAwbDEwMCAtMjAwaC0xMDBsLTEwMCAyMDB6TTYwMCA2MDBoMTAwbDEwMCAtMjAwbC0xMDAgLTIwMGgtMTAwbDEwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQxIiB1bmljb2RlPSImI3hlMDQxOyIgCmQ9Ik0zNTAgODAwaDEwMGw1MCAtMTE5bDI4IC0xMmwxMTkgNTBsNzIgLTcybC01MCAtMTE5bDEyIC0yOGwxMTkgLTUwdi0xMDBsLTExOSAtNTBsLTEyIC0yOGw1MCAtMTE5bC03MiAtNzJsLTExOSA1MGwtMjggLTEybC01MCAtMTE5aC0xMDBsLTUwIDExOWwtMjggMTJsLTExOSAtNTBsLTcyIDcybDUwIDExOWwtMTIgMjhsLTExOSA1MHYxMDBsMTE5IDUwbDEyIDI4bC01MCAxMTlsNzIgNzJsMTE5IC01MGwyOCAxMnpNNDAwIDU1MApjLTgzIDAgLTE1MCAtNjcgLTE1MCAtMTUwczY3IC0xNTAgMTUwIC0xNTBzMTUwIDY3IDE1MCAxNTBzLTY3IDE1MCAtMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDIiIHVuaWNvZGU9IiYjeGUwNDI7IiAKZD0iTTAgODAwaDgwMHYtMjAwaC04MDB2MjAwek0yMDAgNTAwaDQwMGwtMjAwIC0yMDB6TTAgMTAwaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0MyIgdW5pY29kZT0iJiN4ZTA0MzsiIApkPSJNMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTYwMCA4MDBoMjAwdi04MDBoLTIwMHY4MDB6TTUwMCA2MDB2LTQwMGwtMjAwIDIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDQiIHVuaWNvZGU9IiYjeGUwNDQ7IiAKZD0iTTAgODAwaDIwMHYtODAwaC0yMDB2ODAwek03MDAgODAwaDEwMHYtODAwaC0xMDB2ODAwek0zMDAgNjAwbDIwMCAtMjAwbC0yMDAgLTIwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQ1IiB1bmljb2RlPSImI3hlMDQ1OyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNNDAwIDUwMGwyMDAgLTIwMGgtNDAwek0wIDIwMGg4MDB2LTIwMGgtODAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDYiIHVuaWNvZGU9IiYjeGUwNDY7IiAKZD0iTTE1MCA3MDBjODMgMCAxNTAgLTY3IDE1MCAtMTUwdi01MGgxMDB2NTBjMCA4MyA2NyAxNTAgMTUwIDE1MHMxNTAgLTY3IDE1MCAtMTUwcy02NyAtMTUwIC0xNTAgLTE1MGgtNTB2LTEwMGg1MGM4MyAwIDE1MCAtNjcgMTUwIC0xNTBzLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTB2NTBoLTEwMHYtNTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBzNjcgMTUwIDE1MCAxNTBoNTB2MTAwaC01MApjLTgzIDAgLTE1MCA2NyAtMTUwIDE1MHM2NyAxNTAgMTUwIDE1MHpNMTUwIDYwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGg1MHY1MGMwIDI4IC0yMiA1MCAtNTAgNTB6TTU1MCA2MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwdi01MGg1MGMyOCAwIDUwIDIyIDUwIDUwcy0yMiA1MCAtNTAgNTB6TTMwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTE1MCAyMDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTAKczUwIDIyIDUwIDUwdjUwaC01MHpNNTAwIDIwMHYtNTBjMCAtMjggMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwaC01MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDciIHVuaWNvZGU9IiYjeGUwNDc7IiAKZD0iTTAgNzkxYzAgNSA0IDkgOSA5aDc4MmM2IDAgOSAtNCA5IC0xMHYtNzkwbC0yMDAgMjAwaC01OTFjLTYgMCAtOSAzIC05IDl2NTgyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0OCIgdW5pY29kZT0iJiN4ZTA0ODsiIApkPSJNNDAwIDgwMGMyMjAgMCA0MDAgLTE4MCA0MDAgLTQwMHMtMTgwIC00MDAgLTQwMCAtNDAwcy00MDAgMTgwIC00MDAgNDAwczE4MCA0MDAgNDAwIDQwMHpNNDAwIDcwMGMtMTY2IDAgLTMwMCAtMTM0IC0zMDAgLTMwMHMxMzQgLTMwMCAzMDAgLTMwMHMzMDAgMTM0IDMwMCAzMDBzLTEzNCAzMDAgLTMwMCAzMDB6TTYwMCA2MDBsLTEwMCAtMzAwbC0zMDAgLTEwMGwxMDAgMzAwek00MDAgNDUwYy0yOCAwIC01MCAtMjIgLTUwIC01MApzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0OSIgdW5pY29kZT0iJiN4ZTA0OTsiIApkPSJNNDAwIDgwMGMyMjAgMCA0MDAgLTE4MCA0MDAgLTQwMHMtMTgwIC00MDAgLTQwMCAtNDAwcy00MDAgMTgwIC00MDAgNDAwczE4MCA0MDAgNDAwIDQwMHpNNDAwIDcwMHYtNjAwYzE2NiAwIDMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNGEiIHVuaWNvZGU9IiYjeGUwNGE7IiAKZD0iTTAgODAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDYwMGg1MDB2LTEwMGgtNTAwdjEwMHpNMCAzMDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAwaDYwMHYtMTAwaC02MDB2MTAwek03NTAgMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNGIiIHVuaWNvZGU9IiYjeGUwNGI7IiAKZD0iTTI1IDcwMGg3NTBjMTQgMCAyNSAtMTEgMjUgLTI1di03NWgtODAwdjc1YzAgMTQgMTEgMjUgMjUgMjV6TTAgNTAwaDgwMHYtMzc1YzAgLTE0IC0xMSAtMjUgLTI1IC0yNWgtNzUwYy0xNCAwIC0yNSAxMSAtMjUgMjV2Mzc1ek0xMDAgMzAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgMzAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0YyIgdW5pY29kZT0iJiN4ZTA0YzsiIApkPSJNMTAwIDgwMGgxMDB2LTEwMGg0NTBsMTAwIDEwMGw1MCAtNTBsLTEwMCAtMTAwdi00NTBoMTAwdi0xMDBoLTEwMHYtMTAwaC0xMDB2MTAwaC01MDB2NTAwaC0xMDB2MTAwaDEwMHYxMDB6TTIwMCA2MDB2LTM1MGwzNTAgMzUwaC0zNTB6TTYwMCA1NTBsLTM1MCAtMzUwaDM1MHYzNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRkIiB1bmljb2RlPSImI3hlMDRkOyIgCmQ9Ik00MDAgODAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwcy0xODAgLTQwMCAtNDAwIC00MDBzLTQwMCAxODAgLTQwMCA0MDBzMTgwIDQwMCA0MDAgNDAwek00MDAgNzAwYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwczMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHpNNDAwIDYwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6Ck0yMDAgNDUyYzAgMjAgMTUgNDIgMzQgNDhoM2gzaDhjMTIgMCAyOCAtNyAzNiAtMTZsOTEgLTkwbDI1IDZjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwcy00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwbDYgMjVsLTkwIDkxYy05IDggLTE2IDI0IC0xNiAzNnpNNTUwIDUwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRlIiB1bmljb2RlPSImI3hlMDRlOyIgCmQ9Ik0zMDAgODAwaDIwMHYtMzAwaDIwMGwtMzAwIC0zMDBsLTMwMCAzMDBoMjAwdjMwMHpNMCAxMDBoODAwdi0xMDBoLTgwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRmIiB1bmljb2RlPSImI3hlMDRmOyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNNDAwIDYwMGwzMDAgLTMwMGgtMjAwdi0zMDBoLTIwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTAiIHVuaWNvZGU9IiYjeGUwNTA7IiAKZD0iTTIwMCA3MDBoNjAwdi02MDBoLTYwMGwtMjAwIDMwMHpNMzUwIDYyMmwtNzIgLTcybDE1MCAtMTUwbC0xNTAgLTE1MGw3MiAtNzJsMTUwIDE1MGwxNTAgLTE1MGw3MiA3MmwtMTUwIDE1MGwxNTAgMTUwbC03MiA3MmwtMTUwIC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjUxIiB1bmljb2RlPSImI3hlMDUxOyIgCmQ9Ik00MDAgNzAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwaC0xMDBjMCAxNjYgLTEzNCAzMDAgLTMwMCAzMDBzLTMwMCAtMTM0IC0zMDAgLTMwMGgtMTAwYzAgMjIwIDE4MCA0MDAgNDAwIDQwMHpNMzQxIDQ5MWw1OSAtODhsNTkgODhjODEgLTI1IDE0MSAtMTAxIDE0MSAtMTkxYzAgLTExMCAtOTAgLTIwMCAtMjAwIC0yMDBzLTIwMCA5MCAtMjAwIDIwMGMwIDkwIDYwIDE2NiAxNDEgMTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1MiIgdW5pY29kZT0iJiN4ZTA1MjsiIApkPSJNMCA4MDBoMzAwdi00MDBoNDAwdi00MDBoLTcwMHY4MDB6TTQwMCA4MDBsMzAwIC0zMDBoLTMwMHYzMDB6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCAyMDB2LTEwMGg0MDB2MTAwaC00MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjUzIiB1bmljb2RlPSImI3hlMDUzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yMDAgNzAwaDEwMHYtMTAwaDc1YzMwIDAgNTggLTYgODEgLTIyczQ0IC00NCA0NCAtNzh2LTEwMGgtMTAwdjk0Yy00IDMgLTEzIDYgLTI1IDZoLTI1MGMtMTQgMCAtMjUgLTExIC0yNSAtMjV2LTUwYzAgLTE1IDIwIC00MCAzNCAtNDRsMjU3IC02NWM2NiAtMTYgMTA5IC03MyAxMDkgLTE0MXYtNTBjMCAtNjggLTU3IC0xMjUgLTEyNSAtMTI1aC03NXYtMTAwaC0xMDB2MTAwaC03NWMtMzAgMCAtNTggNiAtODEgMjJzLTQ0IDQ0IC00NCA3OAp2MTAwaDEwMHYtOTRjNCAtMyAxMyAtNiAyNSAtNmgyNTBjMTQgMCAyNSAxMSAyNSAyNXY1MGMwIDE1IC0yMCA0MCAtMzQgNDRsLTI1NyA2NWMtNjYgMTYgLTEwOSA3MyAtMTA5IDE0MXY1MGMwIDY4IDU3IDEyNSAxMjUgMTI1aDc1djEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTQiIHVuaWNvZGU9IiYjeGUwNTQ7IiAKZD0iTTAgNzAwaDMwMHYtMzAwbC0zMDAgLTMwMHY2MDB6TTUwMCA3MDBoMzAwdi0zMDBsLTMwMCAtMzAwdjYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTUiIHVuaWNvZGU9IiYjeGUwNTU7IiAKZD0iTTMwMCA3MDB2LTYwMGgtMzAwdjMwMHpNODAwIDcwMHYtNjAwaC0zMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1NiIgdW5pY29kZT0iJiN4ZTA1NjsiIApkPSJNMzAwIDcwMHYtMTAwYy0xMTEgMCAtMjAwIC04OSAtMjAwIC0yMDBoMjAwdi0zMDBoLTMwMHYzMDBjMCAxNjUgMTM1IDMwMCAzMDAgMzAwek04MDAgNzAwdi0xMDBjLTExMSAwIC0yMDAgLTg5IC0yMDAgLTIwMGgyMDB2LTMwMGgtMzAwdjMwMGMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjU3IiB1bmljb2RlPSImI3hlMDU3OyIgCmQ9Ik0wIDcwMGgzMDB2LTMwMGMwIC0xNjUgLTEzNSAtMzAwIC0zMDAgLTMwMHYxMDBjMTExIDAgMjAwIDg5IDIwMCAyMDBoLTIwMHYzMDB6TTUwMCA3MDBoMzAwdi0zMDBjMCAtMTY1IC0xMzUgLTMwMCAtMzAwIC0zMDB2MTAwYzExMSAwIDIwMCA4OSAyMDAgMjAwaC0yMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1OCIgdW5pY29kZT0iJiN4ZTA1ODsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGwzNCAtMzRjMTEgLTExIDI2NiAtMjcwIDI2NiAtNDg4YzAgLTE2NSAtMTM1IC0zMDAgLTMwMCAtMzAwcy0zMDAgMTM1IC0zMDAgMzAwYzAgMjE4IDI1NSA0NzcgMjY2IDQ4OHpNMTUwIDMyOGMtMjggMCAtNTAgLTIyIC01MCAtNTBjMCAtMTEwIDkwIC0yMDAgMjAwIC0yMDBjMjggMCA1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwYy01NSAwIC0xMDAgNDUgLTEwMCAxMDBjMCAyOCAtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1OSIgdW5pY29kZT0iJiN4ZTA1OTsiIApkPSJNNDAwIDgwMGw0MDAgLTUwMGgtODAwek0wIDIwMGg4MDB2LTIwMGgtODAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNWEiIHVuaWNvZGU9IiYjeGUwNWE7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTMwMCA4MDBsMzAwIC0zMDBoLTYwMHpNMCAzMDBoNjAwbC0zMDAgLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNWIiIHVuaWNvZGU9IiYjeGUwNWI7IiAKZD0iTTAgNTAwaDIwMHYtMjAwaC0yMDB2MjAwek0zMDAgNTAwaDIwMHYtMjAwaC0yMDB2MjAwek02MDAgNTAwaDIwMHYtMjAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1YyIgdW5pY29kZT0iJiN4ZTA1YzsiIApkPSJNMCA3MDBoODAwdi0xMDBsLTQwMCAtMjAwbC00MDAgMjAwdjEwMHpNMCA1MDBsNDAwIC0yMDBsNDAwIDIwMHYtNDAwaC04MDB2NDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1ZCIgdW5pY29kZT0iJiN4ZTA1ZDsiIApkPSJNNDAwIDgwMGw0MDAgLTIwMHYtNjAwaC04MDB2NjAwek00MDAgNjg4bC0zMDAgLTE1MHYtMTg4bDMwMCAtMTUwbDMwMCAxNTB2MTg4ek0yMDAgNTAwaDQwMHYtMTAwbC0yMDAgLTEwMGwtMjAwIDEwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjVlIiB1bmljb2RlPSImI3hlMDVlOyIgCmQ9Ik02MDAgNzAwYzY5IDAgMTM0IC0xOSAxOTEgLTUwbC0xNiAtMTA2Yy00OSAzNSAtMTA5IDU2IC0xNzUgNTZjLTEzMSAwIC0yNDAgLTg0IC0yODEgLTIwMGgzMzFsLTE2IC0xMDBoLTMzNGMwIC0zNiA4IC02OCAxOSAtMTAwaDI5N2wtMTYgLTEwMGgtMjIyYzU1IC02MSAxMzMgLTEwMCAyMjIgLTEwMGM3OCAwIDE0NyAzMCAyMDAgNzh2LTEyMmMtNTkgLTM1IC0xMjcgLTU2IC0yMDAgLTU2Yy0xNDcgMCAtMjc0IDgyIC0zNDQgMjAwaC0yNTYKbDE5IDEwMGgxOTdjLTggMzIgLTE2IDY2IC0xNiAxMDBoLTIwMGwyNSAxMDBoMTkxYzQ1IDE3MiAxOTggMzAwIDM4NCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjVmIiB1bmljb2RlPSImI3hlMDVmOyIgCmQ9Ik0wIDcwMGg3MDB2LTEwMGgtNzAwdjEwMHpNMCA1MDBoNTAwdi0xMDBoLTUwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMjAwIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNDAwIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjAiIHVuaWNvZGU9IiYjeGUwNjA7IiAKZD0iTTAgODAwaDgwMHYtMTAwaC04MDB2MTAwek0yMDAgNjAwaDQwMGwtMjAwIC0yMDB6TTAgMjAwaDgwMHYtMjAwaC04MDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2MSIgdW5pY29kZT0iJiN4ZTA2MTsiIApkPSJNMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTYwMCA4MDBoMjAwdi04MDBoLTIwMHY4MDB6TTIwMCA2MDBsMjAwIC0yMDBsLTIwMCAtMjAwdjQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjIiIHVuaWNvZGU9IiYjeGUwNjI7IiAKZD0iTTAgODAwaDIwMHYtODAwaC0yMDB2ODAwek03MDAgODAwaDEwMHYtODAwaC0xMDB2ODAwek02MDAgNjAwdi00MDBsLTIwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjYzIiB1bmljb2RlPSImI3hlMDYzOyIgCmQ9Ik0wIDgwMGg4MDB2LTIwMGgtODAwdjIwMHpNNDAwIDQwMGwyMDAgLTIwMGgtNDAwek0wIDEwMGg4MDB2LTEwMGgtODAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjQiIHVuaWNvZGU9IiYjeGUwNjQ7IiAKZD0iTTAgODAwaDIwMHYtMTAwaC0xMDB2LTYwMGg2MDB2MTAwaDEwMHYtMjAwaC04MDB2ODAwek00MDAgODAwaDQwMHYtNDAwbC0xNTAgMTUwbC0yNTAgLTI1MGwtMTAwIDEwMGwyNTAgMjUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2NSIgdW5pY29kZT0iJiN4ZTA2NTsiIApkPSJNNDAzIDcwMGMyNDcgMCAzOTcgLTMwMCAzOTcgLTMwMHMtMTUwIC0zMDAgLTM5NyAtMzAwYy0yNTMgMCAtNDAzIDMwMCAtNDAzIDMwMHMxNTAgMzAwIDQwMyAzMDB6TTQwMCA2MDBjLTExMCAwIC0yMDAgLTkwIC0yMDAgLTIwMHM5MCAtMjAwIDIwMCAtMjAwczIwMCA5MCAyMDAgMjAwcy05MCAyMDAgLTIwMCAyMDB6TTQwMCA1MDBjMTAgMCAxOSAtMyAyOCAtNmMtMTYgLTggLTI4IC0yNCAtMjggLTQ0YzAgLTI4IDIyIC01MCA1MCAtNTAKYzIwIDAgMzYgMTIgNDQgMjhjMyAtOSA2IC0xOCA2IC0yOGMwIC01NSAtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHM0NSAxMDAgMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjYiIHVuaWNvZGU9IiYjeGUwNjY7IiBob3Jpei1hZHYteD0iOTAwIiAKZD0iTTMzMSA3MDBoM2gzYzMgMSA3IDEgMTAgMWMxMiAwIDI5IC04IDM3IC0xN2w5NCAtOTNsNjYgNjVjNTcgNTcgMTU1IDU3IDIxMiAwYzU4IC01OCA1OCAtMTU0IDAgLTIxMmwtNjUgLTY2bDkzIC05NGMxMCAtOCAxOCAtMjUgMTggLTM4YzAgLTI4IC0yMiAtNTAgLTUwIC01MGMtMTMgMCAtMzIgOSAtNDAgMjBsLTYyIDY1bC0zODEgLTM4MWgtMjY5djI3MmwzNzUgMzgxbC02MyA2M2MtOSA4IC0xNiAyNCAtMTYgMzZjMCAyMCAxNiA0MiAzNSA0OHoKTTQ0NyA0ODFsLTMxMyAtMzE1bDEyOCAtMTMybDMxNiAzMTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjY3IiB1bmljb2RlPSImI3hlMDY3OyIgCmQ9Ik0wIDgwMGgzMDB2LTQwMGg0MDB2LTQwMGgtNzAwdjgwMHpNNDAwIDgwMGwzMDAgLTMwMGgtMzAwdjMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjgiIHVuaWNvZGU9IiYjeGUwNjg7IiAKZD0iTTIwMCA4MDBjMCAwIDIwMCAtMTAwIDIwMCAtMzAwcy0yOTggLTMwMiAtMjAwIC01MDBjMCAwIC0yMDAgMTAwIC0yMDAgMzAwczMwMCAzMDAgMjAwIDUwMHpNNTAwIDUwMGMwIDAgMjAwIC0xMDAgMjAwIC0zMDBjMCAtMTUwIC02MCAtMjAwIC0xMDAgLTIwMGgtMzAwYzAgMjAwIDMwMCAzMDAgMjAwIDUwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjkiIHVuaWNvZGU9IiYjeGUwNjk7IiAKZD0iTTAgODAwaDEwMHYtODAwaC0xMDB2ODAwek0yMDAgODAwaDMwMHYtMTAwaDMwMGwtMjAwIC0yMDNsMjAwIC0xOTdoLTQwMHYxMDBoLTIwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjZhIiB1bmljb2RlPSImI3hlMDZhOyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0xNTAgODAwaDE1MGwtMTAwIC0yMDBoMjAwbC0xNTAgLTMwMGgxNTBsLTMwMCAtMzAwbC0xMDAgMzAwaDEzNGw2NiAyMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmIiIHVuaWNvZGU9IiYjeGUwNmI7IiAKZD0iTTAgODAwaDMwMHYtMTAwaDUwMHYtMTAwaC04MDB2MjAwek0wIDUwMGg4MDB2LTQ1MGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjQ1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmMiIHVuaWNvZGU9IiYjeGUwNmM7IiAKZD0iTTE1MCA4MDBjODMgMCAxNTAgLTY3IDE1MCAtMTUwYzAgLTY2IC00MSAtMTIxIC0xMDAgLTE0MXYtMTE4YzE1IDUgMzMgOSA1MCA5aDIwMGMyOCAwIDUwIDIyIDUwIDUwdjU5Yy01OSAyMCAtMTAwIDc1IC0xMDAgMTQxYzAgODMgNjcgMTUwIDE1MCAxNTBzMTUwIC02NyAxNTAgLTE1MGMwIC02NiAtNDEgLTEyMSAtMTAwIC0xNDF2LTU5YzAgLTgyIC02OCAtMTUwIC0xNTAgLTE1MGgtMjAwYy0xNCAwIC0yNSAtNyAtMzQgLTE2CmM1MCAtMjQgODQgLTc0IDg0IC0xMzRjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBjMCA2NiA0MSAxMjEgMTAwIDE0MXYyMThjLTU5IDIwIC0xMDAgNzUgLTEwMCAxNDFjMCA4MyA2NyAxNTAgMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmQiIHVuaWNvZGU9IiYjeGUwNmQ7IiAKZD0iTTAgODAwaDQwMGwtMTUwIC0xNTBsMTUwIC0xNTBsLTEwMCAtMTAwbC0xNTAgMTUwbC0xNTAgLTE1MHY0MDB6TTUwMCA0MDBsMTUwIC0xNTBsMTUwIDE1MHYtNDAwaC00MDBsMTUwIDE1MGwtMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmUiIHVuaWNvZGU9IiYjeGUwNmU7IiAKZD0iTTEwMCA4MDBsMTUwIC0xNTBsMTUwIDE1MHYtNDAwaC00MDBsMTUwIDE1MGwtMTUwIDE1MHpNNDAwIDQwMGg0MDBsLTE1MCAtMTUwbDE1MCAtMTUwbC0xMDAgLTEwMGwtMTUwIDE1MGwtMTUwIC0xNTB2NDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2ZiIgdW5pY29kZT0iJiN4ZTA2ZjsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGMtNTYgMCAtMTA4IC0xNyAtMTUzIC00NGwyMiAtMTljMzMgLTE4IDEzIC00OCAtMTMgLTU5Yy0zMCAtMTMgLTc3IDEwIC02NSAtNDFjMTMgLTU1IC0yNyAtMyAtNDcgLTE1Yy00MiAtMjYgNDkgLTE1MiAzMSAtMTU2bC01OSAzNGMtOCAwIC0xMyAtNSAtMTYgLTEwCmMxIC0zMCAxMCAtNTcgMTkgLTg0YzI4IC0xMSA3NyAtMiAxMDAgLTI1YzQ3IC0yOCA5NyAtMTE1IDc1IC0xNTljMzQgLTEzIDY4IC0yMiAxMDYgLTIyYzEwMSAwIDE5MyA0OCAyNDcgMTI1YzMgMjQgLTggNDQgLTUwIDQ0Yy02OSAwIC0xNTYgMTMgLTE1MyA5N2MyIDQ2IDEwMSAxMDggNjYgMTQzYy0zMCAzMCAxMiAzOSAxMiA2NmMwIDM3IC02NSAzMiAtNjkgNTBzMjAgMzYgNDEgNTZjLTMwIDEwIC02MCAxOSAtOTQgMTl6TTYzMSA1OTEKYy0zOCAtMTEgLTk0IC0zNSAtODcgLTUzYzYgLTE1IDUyIC0xIDY1IC0xM2MxMSAtMTAgMTYgLTU5IDQ0IC0zMWwyMiAyMnYzYy0xMSAyNiAtMjYgNTAgLTQ0IDcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3MCIgdW5pY29kZT0iJiN4ZTA3MDsiIApkPSJNNzAzIDgwMGw5NyAtMTAwbC00MDAgLTQwMGwtMTAwIDEwMGwtMjAwIC0yMDNsLTEwMCAxMDBsMzAwIDMwM2wxMDAgLTEwMHpNMCAxMDBoODAwdi0xMDBoLTgwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjcxIiB1bmljb2RlPSImI3hlMDcxOyIgCmQ9Ik0wIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMjAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNDAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNjAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTIwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTQwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTYwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTAgMzAwaDEwMHYtMTAwaC0xMDB2MTAwek0yMDAgMzAwaDEwMAp2LTEwMGgtMTAwdjEwMHpNNDAwIDMwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNjAwIDMwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTIwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTQwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTYwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjcyIiB1bmljb2RlPSImI3hlMDcyOyIgCmQ9Ik0wIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNMzAwIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNNjAwIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTMwMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTYwMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTAgMjAwaDIwMHYtMjAwaC0yMDB2MjAwek0zMDAgMjAwaDIwMHYtMjAwaC0yMDB2MjAwek02MDAgMjAwaDIwMHYtMjAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3MyIgdW5pY29kZT0iJiN4ZTA3MzsiIApkPSJNMCA4MDBoMzAwdi0zMDBoLTMwMHYzMDB6TTUwMCA4MDBoMzAwdi0zMDBoLTMwMHYzMDB6TTAgMzAwaDMwMHYtMzAwaC0zMDB2MzAwek01MDAgMzAwaDMwMHYtMzAwaC0zMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3NCIgdW5pY29kZT0iJiN4ZTA3NDsiIApkPSJNMTkgODAwaDY2MmMxMSAwIDE5IC04IDE5IC0xOXYtMzMxYzAgLTI4IC0yMiAtNTAgLTUwIC01MGgtNjAwYy0yOCAwIC01MCAyMiAtNTAgNTB2MzMxYzAgMTEgOCAxOSAxOSAxOXpNMCAzMDljMTYgLTYgMzIgLTkgNTAgLTloNjAwYzE4IDAgMzQgMyA1MCA5di0yOTBjMCAtMTEgLTggLTE5IC0xOSAtMTloLTY2MmMtMTEgMCAtMTkgOCAtMTkgMTl2Mjkwek01NTAgMjAwYy0yOCAwIC01MCAtMjIgLTUwIC01MHMyMiAtNTAgNTAgLTUwCnM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3NSIgdW5pY29kZT0iJiN4ZTA3NTsiIApkPSJNMCA3MDBoMzAwdi0xMDBoLTUwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtMTUwaDMwMHYxNTBjMCAyOCAtMjIgNTAgLTUwIDUwaC01MHYxMDBoMzAwdi0xMDBoLTUwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtNDAwYzAgLTI4IDIyIC01MCA1MCAtNTBoNTB2LTEwMGgtMzAwdjEwMGg1MGMyOCAwIDUwIDIyIDUwIDUwdjE1MGgtMzAwdi0xNTBjMCAtMjggMjIgLTUwIDUwIC01MGg1MHYtMTAwaC0zMDB2MTAwaDUwYzI4IDAgNTAgMjIgNTAgNTAKdjQwMGMwIDI4IC0yMiA1MCAtNTAgNTBoLTUwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNzYiIHVuaWNvZGU9IiYjeGUwNzY7IiAKZD0iTTQwMCA3MDBjMTY1IDAgMzAwIC0xMzUgMzAwIC0zMDB2LTEwMGg1MGMyOCAwIDUwIC0yMiA1MCAtNTB2LTIwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTEwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjM1MGMwIDExMSAtODkgMjAwIC0yMDAgMjAwcy0yMDAgLTg5IC0yMDAgLTIwMHYtMzUwYzAgLTI4IC0yMiAtNTAgLTUwIC01MGgtMTAwYy0yOCAwIC01MCAyMiAtNTAgNTB2MjAwYzAgMjggMjIgNTAgNTAgNTBoNTB2MTAwCmMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijc3IiB1bmljb2RlPSImI3hlMDc3OyIgCmQ9Ik0wIDUwMGMwIDEwOSA5MSAyMDAgMjAwIDIwMHMyMDAgLTkxIDIwMCAtMjAwYzAgMTA5IDkxIDIwMCAyMDAgMjAwczIwMCAtOTEgMjAwIC0yMDBjMCAtNTUgLTIzIC0xMDUgLTU5IC0xNDFsLTM0MSAtMzQwbC0zNDEgMzQwYy0zNiAzNiAtNTkgODYgLTU5IDE0MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNzgiIHVuaWNvZGU9IiYjeGUwNzg7IiAKZD0iTTQwMCA3MDBsNDAwIC0zMDBsLTEwMCAzdi00MDNoLTIwMHYyMDBoLTIwMHYtMjAwaC0yMDB2NDAwaC0xMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijc5IiB1bmljb2RlPSImI3hlMDc5OyIgCmQ9Ik0wIDgwMGg4MDB2LTgwMGgtODAwdjgwMHpNMTAwIDcwMHYtMzAwbDEwMCAxMDBsNDAwIC00MDBoMTAwdjEwMGwtMjAwIDIwMGwxMDAgMTAwbDEwMCAtMTAwdjMwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3YSIgdW5pY29kZT0iJiN4ZTA3YTsiIApkPSJNMTkgODAwaDc2MmMxMSAwIDE5IC04IDE5IC0xOXYtNzYyYzAgLTExIC04IC0xOSAtMTkgLTE5aC03NjJjLTExIDAgLTE5IDggLTE5IDE5djc2MmMwIDExIDggMTkgMTkgMTl6TTEwMCA2MDB2LTMwMGgxMDBsMTAwIC0xMDBoMjAwbDEwMCAxMDBoMTAwdjMwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3YiIgdW5pY29kZT0iJiN4ZTA3YjsiIApkPSJNMjAwIDYwMGM4MCAwIDE0MiAtNTYgMjAwIC0xMjJjNTggNjYgMTE5IDEyMiAyMDAgMTIyYzEzMSAwIDIwMCAtMTAxIDIwMCAtMjAwcy02OSAtMjAwIC0yMDAgLTIwMGMtODEgMCAtMTQyIDU2IC0yMDAgMTIyYy01OCAtNjYgLTEyMSAtMTIyIC0yMDAgLTEyMmMtMTMxIDAgLTIwMCAxMDEgLTIwMCAyMDBzNjkgMjAwIDIwMCAyMDB6TTIwMCA1MDBjLTc0IDAgLTEwMCAtNTQgLTEwMCAtMTAwczI2IC0xMDAgMTAwIC0xMDAKYzQyIDAgODggNDcgMTM0IDEwMGMtNDYgNTMgLTkyIDEwMCAtMTM0IDEwMHpNNjAwIDUwMGMtNDMgMCAtODggLTQ3IC0xMzQgLTEwMGM0NiAtNTMgOTEgLTEwMCAxMzQgLTEwMGM3NCAwIDEwMCA1NCAxMDAgMTAwcy0yNiAxMDAgLTEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjdjIiB1bmljb2RlPSImI3hlMDdjOyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0zMDAgODAwYzU1IDAgMTAwIC00NSAxMDAgLTEwMHMtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHM0NSAxMDAgMTAwIDEwMHpNMTUwIDU1MGM4MyAwIDE1MCAtNjkgMTUwIC0xNTBjMCAtNjYgLTEwMCAtMjE0IC0xMDAgLTI1MGMwIC0yOCAyMiAtNTAgNTAgLTUwczUwIDIyIDUwIDUwaDEwMGMwIC04MyAtNjcgLTE1MCAtMTUwIC0xNTBzLTE1MCA2NCAtMTUwIDE1MHMxMDAgMjIyIDEwMCAyNTBzLTIyIDUwIC01MCA1MApzLTUwIC0yMiAtNTAgLTUwaC0xMDBjMCA4MyA2NyAxNTAgMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iN2QiIHVuaWNvZGU9IiYjeGUwN2Q7IiAKZD0iTTIwMCA4MDBoNTAwdi0xMDBoLTEyMmMtNzcgLTE5NyAtMTU2IC0zOTIgLTIzNCAtNTg4bC02IC0xMmgxNjJ2LTEwMGgtNTAwdjEwMGgxMjJjNzcgMTk3IDE1NiAzOTIgMjM0IDU4OGw3IDEyaC0xNjN2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3ZSIgdW5pY29kZT0iJiN4ZTA3ZTsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgNTAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDMwMGg4MDB2LTEwMGgtODAwdjEwMHpNMTAwIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iN2YiIHVuaWNvZGU9IiYjeGUwN2Y7IiAKZD0iTTAgNzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDUwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCAzMDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MCIgdW5pY29kZT0iJiN4ZTA4MDsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgNTAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDMwMGg4MDB2LTEwMGgtODAwdjEwMHpNMjAwIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODEiIHVuaWNvZGU9IiYjeGUwODE7IiAKZD0iTTU1MCA4MDBjMTM4IDAgMjUwIC0xMTIgMjUwIC0yNTBzLTExMiAtMjUwIC0yNTAgLTI1MGMtMTYgMCAtMzIgMCAtNDcgM2wtMyAtM3YtMTAwaC0yMDB2LTIwMGgtMzAwdjIwMGwzMDMgMzAzYy0zIDE1IC0zIDMxIC0zIDQ3YzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNNjAwIDcwMGMtNTUgMCAtMTAwIC00NSAtMTAwIC0xMDBzNDUgLTEwMCAxMDAgLTEwMHMxMDAgNDUgMTAwIDEwMHMtNDUgMTAwIC0xMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MiIgdW5pY29kZT0iJiN4ZTA4MjsiIApkPSJNMTM0IDYwMGgzaDRoNGg1aDUwMGMyOCAwIDUwIC0yMiA1MCAtNTB2LTM1MGgxMDB2LTE1MGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjE1MGgxMDB2MzUwdjJjMCAyMCAxNSA0MiAzNCA0OHpNMjAwIDUwMHYtMzAwaDEwMHYtMTAwaDIwMHYxMDBoMTAwdjMwMGgtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MyIgdW5pY29kZT0iJiN4ZTA4MzsiIApkPSJNMCA4MDBoNDAwdi00MDBoLTQwMHY0MDB6TTUwMCA2MDBoMTAwdi00MDBoLTQwMHYxMDBoMzAwdjMwMHpNNzAwIDQwMGgxMDB2LTQwMGgtNDAwdjEwMGgzMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4NCIgdW5pY29kZT0iJiN4ZTA4NDsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzM3IDY5NGM2IDQgMTIgNyAyMSA3YzI4IDAgNTAgLTIyIDUwIC01MGMwIC0xNyAtMTIgLTM3IC0yNyAtNDVsLTMwMCAtMTUwYy04IC02IC0yMSAtMTEgLTMxIC0xMWMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMjEgMTYgNDQgMzcgNDl6TTQzNyA1NDRjNiA0IDEyIDcgMjEgN2MyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTcgLTEyIC0zNyAtMjcgLTQ1bC00MDAgLTIwMGMtOCAtNiAtMjEgLTExIC0zMSAtMTFjLTI4IDAgLTUwIDIyIC01MCA1MApjMCAyMSAxNiA0NCAzNyA0OXpNNDM3IDM0NGM2IDQgMTIgNyAyMSA3YzI4IDAgNTAgLTIyIDUwIC01MGMwIC0xNyAtMTIgLTM3IC0yNyAtNDVsLTEwNiAtNTZjMjQgLTQgNDMgLTI2IDQzIC01MGMwIC0yOCAtMjMgLTUxIC01MSAtNTFjLTIgMCAtNiAxIC04IDFoLTIwMGMtMjYgMSAtNDggMjQgLTQ4IDUwYzAgMTYgMTIgMzYgMjYgNDR6TTE1MSAtNTBjMCAyMyAyMCA1MCA0NiA1MGgzaDRoNWgxMDBjMjggMCA1MCAtMjIgNTAgLTUwCnMtMjIgLTUwIC01MCAtNTBoLTEwMGMtMiAwIC02IC0xIC04IC0xYy0yOCAwIC01MCAyMyAtNTAgNTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijg1IiB1bmljb2RlPSImI3hlMDg1OyIgCmQ9Ik0xOTkgODAwaDEwMHYtMjAwaC0yMDB2MTAwaDEwMHYxMDB6TTU4NiA3OTdoMWMxOCAxIDM4IDEgNTYgLTNjMzYgLTggNjkgLTI2IDk3IC01NGM3OCAtNzggNzggLTIwMyAwIC0yODFsLTE1MCAtMTUwYy04IC0xMyAtMjggLTI0IC00MyAtMjRjLTI4IDAgLTUwIDIyIC01MCA1MGMwIDE1IDExIDM1IDI0IDQzbDE1MCAxNTBjNDAgNDAgMzkgMTA1IDAgMTQ0Yy00MSA0MSAtMTEwIDM0IC0xNDQgMGwtNDQgLTQ0CmMtOCAtMTMgLTI3IC0yNCAtNDIgLTI0Yy0yOCAwIC01MCAyMiAtNTAgNTBjMCAxNSAxMSAzNSAyNCA0M2w0MyA0NGMzMiAzMyA3MiA1MyAxMjggNTZ6TTIwOCA0OTBjNCA1IDE0IDE2IDIyIDE2aDNjMiAwIDYgMSA4IDFjMjggMCA1MCAtMjIgNTAgLTUwYzAgLTExIC02IC0yNyAtMTQgLTM1bC0xNTAgLTE1MGMtNDAgLTQwIC0zOSAtMTA1IDAgLTE0NGM0MSAtNDEgMTEwIC0zNCAxNDQgMGw0NCA0NGM4IDEzIDI3IDI0IDQyIDI0CmMyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTUgLTExIC0zNSAtMjQgLTQzbC00MyAtNDRjLTIyIC0yMiAtNDggLTM3IC03NSAtNDdjLTcwIC0yNSAtMTUxIC05IC0yMDcgNDdjLTc4IDc4IC03OCAyMDMgMCAyODF6TTQ5OSAyMDBoMjAwdi0xMDBoLTEwMHYtMTAwaC0xMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4NiIgdW5pY29kZT0iJiN4ZTA4NjsiIApkPSJNNTg2IDc5N2MxOCAxIDM5IDEgNTcgLTNjMzYgLTggNjkgLTI2IDk3IC01NGM3OCAtNzggNzggLTIwMyAwIC0yODFsLTE1MCAtMTUwYy02MiAtNjIgLTEzMiAtODEgLTE4MiAtNzhzLTY5IDE3IC04NCAyNXMtMjYgMjcgLTI2IDQ0YzAgMjggMjIgNTEgNTAgNTFjOCAwIDE5IC0zIDI2IC03YzAgMCAxNSAtMTEgNDEgLTEzczYyIDMgMTA2IDQ3bDE1MCAxNTBjNDAgNDAgMzkgMTA1IDAgMTQ0Yy00MSA0MSAtMTEwIDM0IC0xNDQgMApjLTggLTEzIC0yOCAtMjQgLTQzIC0yNGMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMTUgMTEgMzUgMjQgNDNjMzIgMzMgNzIgNTMgMTI4IDU2ek0zODYgNTY2YzUwIC0yIDY0IC0xNyA4NSAtMjJzMzcgLTI4IDM3IC00OWMwIC0yOCAtMjIgLTUwIC01MCAtNTBjLTEwIDAgLTIzIDUgLTMxIDExYzAgMCAtMTkgOSAtNDcgMTBzLTYzIC00IC0xMDMgLTQ0bC0xNTAgLTE1MGMtNDAgLTQwIC0zOSAtMTA1IDAgLTE0NGM0MSAtNDEgMTEwIC0zNCAxNDQgMApjOCAxMyAyNyAyNCA0MiAyNGMyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTUgLTEwIC0zNSAtMjMgLTQzYy0yMiAtMjIgLTQ4IC0zNyAtNzUgLTQ3Yy03MCAtMjUgLTE1MSAtOSAtMjA3IDQ3Yy03OCA3OCAtNzggMjAzIDAgMjgxbDE1MCAxNTBjNjAgNjAgMTI4IDc4IDE3OCA3NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODciIHVuaWNvZGU9IiYjeGUwODc7IiAKZD0iTTAgNzAwaDMwMHYtMzAwaC0zMDB2MzAwek00MDAgNzAwaDQwMHYtMTAwaC00MDB2MTAwek00MDAgNTAwaDMwMHYtMTAwaC0zMDB2MTAwek0wIDMwMGgzMDB2LTMwMGgtMzAwdjMwMHpNNDAwIDMwMGg0MDB2LTEwMGgtNDAwdjEwMHpNNDAwIDEwMGgzMDB2LTEwMGgtMzAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODgiIHVuaWNvZGU9IiYjeGUwODg7IiAKZD0iTTUwIDcwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTIwMCA3MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTUwIDUwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTIwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTUwIDMwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTAKczIyIDUwIDUwIDUwek0yMDAgMzAwaDYwMHYtMTAwaC02MDB2MTAwek01MCAxMDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0yMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4OSIgdW5pY29kZT0iJiN4ZTA4OTsiIApkPSJNODAwIDgwMGwtNDAwIC04MDBsLTEwMCAzMDBsLTMwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhhIiB1bmljb2RlPSImI3hlMDhhOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0zMDAgNzAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDB2LTEwMGgxMDB2LTQwMGgtNjAwdjQwMGgxMDB2MTAwYzAgMTEwIDkwIDIwMCAyMDAgMjAwek0zMDAgNjAwYy01NiAwIC0xMDAgLTQ0IC0xMDAgLTEwMHYtMTAwaDIwMHYxMDBjMCA1NiAtNDQgMTAwIC0xMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4YiIgdW5pY29kZT0iJiN4ZTA4YjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGMxMTAgMCAyMDAgLTkwIDIwMCAtMjAwdi0yMDBoMTAwdi00MDBoLTYwMHY0MDBoNDAwdjIwMGMwIDU2IC00NCAxMDAgLTEwMCAxMDBzLTEwMCAtNDQgLTEwMCAtMTAwaC0xMDBjMCAxMTAgOTAgMjAwIDIwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhjIiB1bmljb2RlPSImI3hlMDhjOyIgCmQ9Ik00MDAgNzAwdi0xMDBjLTExMSAwIC0yMDAgLTg5IC0yMDAgLTIwMGgxMDBsLTE1MCAtMjAwbC0xNTAgMjAwaDEwMGMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6TTY1MCA2MDBsMTUwIC0yMDBoLTEwMGMwIC0xNjUgLTEzNSAtMzAwIC0zMDAgLTMwMHYxMDBjMTExIDAgMjAwIDg5IDIwMCAyMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOGQiIHVuaWNvZGU9IiYjeGUwOGQ7IiAKZD0iTTEwMCA4MDBoNjAwdi0zMDBoMTAwbC0xNTAgLTI1MGwtMTUwIDI1MGgxMDB2MjAwaC00MDB2LTEwMGgtMTAwdjIwMHpNMTUwIDU1MGwxNTAgLTI1MGgtMTAwdi0yMDBoNDAwdjEwMGgxMDB2LTIwMGgtNjAwdjMwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4ZSIgdW5pY29kZT0iJiN4ZTA4ZTsiIApkPSJNNjAwIDcwMGwyMDAgLTE1MGwtMjAwIC0xNTB2MTAwaC01MDB2LTEwMGgtMTAwdjEwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwaDUwMHYxMDB6TTIwMCAzMDB2LTEwMGg1MDB2MTAwaDEwMHYtMTAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMGgtNTAwdi0xMDBsLTIwMCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhmIiB1bmljb2RlPSImI3hlMDhmOyIgaG9yaXotYWR2LXg9IjkwMCIgCmQ9Ik0zNTAgODAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgLTYwIC0xNyAtMTE3IC00NCAtMTY2YzUgLTMgMTIgLTggMTYgLTEybDEwMCAtMTAwYzE2IC0xNiAzMCAtNDkgMzAgLTcyYzAgLTU2IC00NiAtMTAyIC0xMDIgLTEwMmMtMjMgMCAtNTYgMTQgLTcyIDMwbC0xMDAgMTAwYy00IDMgLTkgOSAtMTIgMTNjLTQ5IC0yNiAtMTA3IC00MSAtMTY2IC00MWMtMTkzIDAgLTM1MCAxNTcgLTM1MCAzNTBzMTU3IDM1MCAzNTAgMzUwek0zNTAgMjAwCmMxNDIgMCAyNTAgMTA4IDI1MCAyNTBjMCAxMzkgLTExMSAyNTAgLTI1MCAyNTBzLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTAiIHVuaWNvZGU9IiYjeGUwOTA7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTMwMCA4MDBjMTY2IDAgMzAwIC0xMzQgMzAwIC0zMDBjMCAtMjAwIC0zMDAgLTUwMCAtMzAwIC01MDBzLTMwMCAzMDAgLTMwMCA1MDBjMCAxNjYgMTM0IDMwMCAzMDAgMzAwek0zMDAgNzAwYy0xMTAgMCAtMjAwIC05MCAtMjAwIC0yMDBzOTAgLTIwMCAyMDAgLTIwMHMyMDAgOTAgMjAwIDIwMHMtOTAgMjAwIC0yMDAgMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5MSIgdW5pY29kZT0iJiN4ZTA5MTsiIGhvcml6LWFkdi14PSI5MDAiIApkPSJNMCA4MDBoODAwdi01NDFjMSAtMyAxIC04IDEgLTExczAgLTcgLTEgLTEwdi0yMzhoLTgwMHY4MDB6TTQ5NSAyNTBjMCAyNiAyMiA1MCA1MCA1MGg1aDE1MHY0MDBoLTYwMHYtNjAwaDYwMHYxMDBoLTE1MGgtNWMtMjggMCAtNTAgMjIgLTUwIDUwek0zNTAgNjAwYzgzIDAgMTUwIC02NyAxNTAgLTE1MGMwIC0xMDAgLTE1MCAtMjUwIC0xNTAgLTI1MHMtMTUwIDE1MCAtMTUwIDI1MGMwIDgzIDY3IDE1MCAxNTAgMTUwek0zNTAgNTAwCmMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5MiIgdW5pY29kZT0iJiN4ZTA5MjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMCA3MDBoMjAwdi02MDBoLTIwMHY2MDB6TTQwMCA3MDBoMjAwdi02MDBoLTIwMHY2MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjkzIiB1bmljb2RlPSImI3hlMDkzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0wIDcwMGw2MDAgLTMwMGwtNjAwIC0zMDB2NjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5NCIgdW5pY29kZT0iJiN4ZTA5NDsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDcwMGMxNjYgMCAzMDAgLTEzNCAzMDAgLTMwMHMtMTM0IC0zMDAgLTMwMCAtMzAwcy0zMDAgMTM0IC0zMDAgMzAwczEzNCAzMDAgMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTUiIHVuaWNvZGU9IiYjeGUwOTU7IiAKZD0iTTQwMCA3MDB2LTYwMGwtNDAwIDMwMHpNNDAwIDQwMGw0MDAgMzAwdi02MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijk2IiB1bmljb2RlPSImI3hlMDk2OyIgCmQ9Ik0wIDcwMGw0MDAgLTMwMGwtNDAwIC0zMDB2NjAwek00MDAgMTAwdjYwMGw0MDAgLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTciIHVuaWNvZGU9IiYjeGUwOTc7IiAKZD0iTTAgNzAwaDIwMHYtNjAwaC0yMDB2NjAwek0yMDAgNDAwbDUwMCAzMDB2LTYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTgiIHVuaWNvZGU9IiYjeGUwOTg7IiAKZD0iTTAgNzAwbDUwMCAtMzAwbC01MDAgLTMwMHY2MDB6TTUwMCAxMDB2NjAwaDIwMHYtNjAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijk5IiB1bmljb2RlPSImI3hlMDk5OyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0wIDcwMGg2MDB2LTYwMGgtNjAwdjYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOWEiIHVuaWNvZGU9IiYjeGUwOWE7IiAKZD0iTTIwMCA4MDBoNDAwdi0yMDBoMjAwdi00MDBoLTIwMHYtMjAwaC00MDB2MjAwaC0yMDB2NDAwaDIwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjliIiB1bmljb2RlPSImI3hlMDliOyIgCmQ9Ik0wIDcwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA0MDNoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAzaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5YyIgdW5pY29kZT0iJiN4ZTA5YzsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjc4IDcwMGM3IDIgMTMgNCAyMiA0YzU1IDAgMTAwIC00NSAxMDAgLTEwMHYtNHYtMjAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwdjIwMHYyYzAgNDQgMzUgODggNzggOTh6TTM0IDUwMGg0aDNjMyAwIDYgMSA5IDFjMjggMCA1MCAtMjIgNTAgLTUwdi0xdi01MGMwIC0xMTEgODkgLTIwMCAyMDAgLTIwMHMyMDAgODkgMjAwIDIwMHY1MGMwIDI4IDIyIDUwIDUwIDUwczUwIC0yMiA1MCAtNTB2LTUwCmMwIC0xNDggLTEwOSAtMjcwIC0yNTAgLTI5NHYtMTA2aDUwYzU1IDAgMTAwIC00NSAxMDAgLTEwMGgtNDAwYzAgNTUgNDUgMTAwIDEwMCAxMDBoNTB2MTA2Yy0xNDEgMjQgLTI1MCAxNDYgLTI1MCAyOTR2NTB2MmMwIDIwIDE1IDQyIDM0IDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5ZCIgdW5pY29kZT0iJiN4ZTA5ZDsiIApkPSJNMCA1MDBoODAwdi0yMDBoLTgwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjllIiB1bmljb2RlPSImI3hlMDllOyIgCmQ9Ik0zNCA3MDBoNGgzaDRoNWg3MDBjMjggMCA1MCAtMjIgNTAgLTUwdi01MDBjMCAtMjggLTIyIC01MCAtNTAgLTUwaC0yNTB2LTEwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaC02MDBjMCA1NSA0NSAxMDAgMTAwIDEwMGgxMDB2MTAwaC0yNTBjLTI4IDAgLTUwIDIyIC01MCA1MHY1MDB2MmMwIDIwIDE1IDQyIDM0IDQ4ek0xMDAgNjAwdi00MDBoNjAwdjQwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5ZiIgdW5pY29kZT0iJiN4ZTA5ZjsiIApkPSJNMjcyIDcwMGMtMTQgLTQwIC0yMiAtODMgLTIyIC0xMjhjMCAtMjIxIDE3OSAtNDAwIDQwMCAtNDAwYzQ1IDAgODggOCAxMjggMjJjLTUzIC0xNTggLTIwMiAtMjcyIC0zNzggLTI3MmMtMjIxIDAgLTQwMCAxNzkgLTQwMCA0MDBjMCAxNzYgMTE0IDMyNSAyNzIgMzc4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhMCIgdW5pY29kZT0iJiN4ZTBhMDsiIApkPSJNMzUwIDcwMGwxNTAgLTE1MGgtMTAwdi0xNTBoMTUwdjEwMGwxNTAgLTE1MGwtMTUwIC0xNTB2MTAwaC0xNTB2LTE1MGgxMDBsLTE1MCAtMTUwbC0xNTAgMTUwaDEwMHYxNTBoLTE1MHYtMTAwbC0xNTAgMTUwbDE1MCAxNTB2LTEwMGgxNTB2MTUwaC0xMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImExIiB1bmljb2RlPSImI3hlMGExOyIgCmQ9Ik04MDAgODAwdi01NTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBzNjcgMTUwIDE1MCAxNTBjMTcgMCAzNSAtNCA1MCAtOXYyMDZjLTIwMSAtNiAtMzI3IC0yNyAtNDAwIC01MHYtMzk3YzAgLTgzIC02NyAtMTUwIC0xNTAgLTE1MHMtMTUwIDY3IC0xNTAgMTUwczY3IDE1MCAxNTAgMTUwYzE3IDAgMzUgLTQgNTAgLTl2NDA5czEwMCAxMDAgNjAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYTIiIHVuaWNvZGU9IiYjeGUwYTI7IiBob3Jpei1hZHYteD0iNzAwIiAKZD0iTTQ5OSA3MDBjNTEgMCAxMDIgLTIwIDE0MSAtNTljNzggLTc4IDc4IC0yMDMgMCAtMjgxbC0yNTAgLTI0NGMtNDggLTQ4IC0xMjcgLTQ4IC0xNzUgMHMtNDggMTI3IDAgMTc1bDk2IDk3bDY5IC02OWwtOTAgLTk0bC03IC0zYy0xMCAtMTAgLTEwIC0yOCAwIC0zOHMyOCAtMTAgMzggMGwyNTAgMjQ3YzM3IDQwIDM5IDEwMiAwIDE0MXMtMTA0IDQwIC0xNDQgMGwtMjc4IC0yNzVjLTY2IC02OSAtNjggLTE3OSAwIC0yNDcKYzY5IC02OSAxODEgLTY5IDI1MCAwbDkgMTJsMTE2IDExM2w2OSAtNjlsLTEyNSAtMTI1Yy0xMDcgLTEwNyAtMjgxIC0xMDcgLTM4OCAwcy0xMDcgMjgxIDAgMzg4bDI3OCAyNzJjMzkgMzkgOTAgNTkgMTQxIDU5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhMyIgdW5pY29kZT0iJiN4ZTBhMzsiIApkPSJNNjAwIDgwMGwyMDAgLTIwMGwtMTAwIC0xMDBsLTIwMCAyMDB6TTQwMCA2MDBsMjAwIC0yMDBsLTQwMCAtNDAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNCIgdW5pY29kZT0iJiN4ZTBhNDsiIApkPSJNNTUwIDgwMGM4MyAwIDE1MCAtOTAgMTUwIC0yMDBzLTY3IC0yMDAgLTE1MCAtMjAwYy0yMiAwIC00MCA4IC01OSAxOWM2IDI2IDkgNTIgOSA4MWMwIDg0IC0yNyAxNTggLTcyIDIxMmMyNyA1MiA3MSA4OCAxMjIgODh6TTI1MCA3MDBjODMgMCAxNTAgLTkwIDE1MCAtMjAwcy02NyAtMjAwIC0xNTAgLTIwMHMtMTUwIDkwIC0xNTAgMjAwczY3IDIwMCAxNTAgMjAwek03MjUgMzg0YzQ0IC0yMiA3NSAtNjYgNzUgLTExOHYtMTY2aC0yMDB2NjYKYzAgNTAgLTE3IDk2IC00NCAxMzRjNjYgMiAxMjYgMzMgMTY5IDg0ek03NSAyODRjNDUgLTUzIDEwNiAtODQgMTc1IC04NHMxMzAgMzEgMTc1IDg0YzQ0IC0yMiA3NSAtNjYgNzUgLTExOHYtMTY2aC01MDB2MTY2YzAgNTIgMzEgOTYgNzUgMTE4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNSIgdW5pY29kZT0iJiN4ZTBhNTsiIApkPSJNNDAwIDgwMGMxMTAgMCAyMDAgLTExMiAyMDAgLTI1MHMtOTAgLTI1MCAtMjAwIC0yNTBzLTIwMCAxMTIgLTIwMCAyNTBzOTAgMjUwIDIwMCAyNTB6TTE5MSAzMDBjNTQgLTYxIDEyOCAtMTAwIDIwOSAtMTAwczE1NSAzOSAyMDkgMTAwYzEwNiAtNSAxOTEgLTkyIDE5MSAtMjAwdi0xMDBoLTgwMHYxMDBjMCAxMDggODUgMTk1IDE5MSAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImE2IiB1bmljb2RlPSImI3hlMGE2OyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0xOSA4MDBoNDYyYzExIDAgMTkgLTggMTkgLTE5di03NjJjMCAtMTEgLTggLTE5IC0xOSAtMTloLTQ2MmMtMTEgMCAtMTkgOCAtMTkgMTl2NzYyYzAgMTEgOCAxOSAxOSAxOXpNMTAwIDcwMHYtNTAwaDMwMHY1MDBoLTMwMHpNMjUwIDE1MGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNyIgdW5pY29kZT0iJiN4ZTBhNzsiIApkPSJNMzUwIDgwMGMxNyAwIDM0IC0xIDUwIC0zdi0zOTdsLTI5NyAyOTdjNjMgNjQgMTUwIDEwMyAyNDcgMTAzek01MDAgNjk0YzE2OSAtMjUgMzAwIC0xNjggMzAwIC0zNDRjMCAtMTkzIC0xNTcgLTM1MCAtMzUwIC0zNTBjLTg1IDAgLTE2MSAzMSAtMjIyIDgxbDI3MiAyNzJ2MzQxek05MSA1NjJsMjM3IC0yMzRsLTIxMiAtMjEyYy03MCA1NSAtMTE2IDEzOCAtMTE2IDIzNGMwIDg0IDM1IDE1OCA5MSAyMTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImE4IiB1bmljb2RlPSImI3hlMGE4OyIgCmQ9Ik05MiA2NTBjMCAyMyAyMCA1MCA0NiA1MGgzaDRoNWg0MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTB2LTIwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaC0zMDB2LTMwMGwtNTYgLTEwMGwtNDQgMTAwdjMwMGgtMzAwYzAgNTUgNDUgMTAwIDEwMCAxMDBoMTAwdjIwMGgtNTBjLTIgMCAtNiAtMSAtOCAtMWMtMjggMCAtNTAgMjMgLTUwIDUxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhOSIgdW5pY29kZT0iJiN4ZTBhOTsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNMzAwIDYwMHYtNDAwbDMwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFhIiB1bmljb2RlPSImI3hlMGFhOyIgCmQ9Ik0zMDAgODAwaDIwMHYtMzAwaDMwMHYtMjAwaC0zMDB2LTMwMGgtMjAwdjMwMGgtMzAwdjIwMGgzMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYiIgdW5pY29kZT0iJiN4ZTBhYjsiIApkPSJNMzAwIDgwMGgxMDB2LTQwMGgtMTAwdjQwMHpNMTcyIDY1Nmw2MiAtNzhsLTQwIC0zMWMtNTggLTQ2IC05NCAtMTE3IC05NCAtMTk3YzAgLTEzOSAxMTEgLTI1MCAyNTAgLTI1MHMyNTAgMTExIDI1MCAyNTBjMCA4MCAtMzkgMTUxIC05NyAxOTdsLTM3IDMxbDYyIDc4bDM4IC0zMWM4MiAtNjQgMTM0IC0xNjQgMTM0IC0yNzVjMCAtMTkzIC0xNTcgLTM1MCAtMzUwIC0zNTBzLTM1MCAxNTcgLTM1MCAzNTBjMCAxMTEgNTMgMjExIDEzNCAyNzV6CiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYyIgdW5pY29kZT0iJiN4ZTBhYzsiIApkPSJNMjAwIDgwMGg0MDB2LTIwMGgtNDAwdjIwMHpNOSA1MDBoNzgyYzYgMCA5IC0zIDkgLTl2LTI4MmMwIC02IC0zIC05IC05IC05aC05MXYyMDBoLTYwMHYtMjAwaC05MWMtNiAwIC05IDMgLTkgOXYyODJjMCA2IDMgOSA5IDl6TTIwMCAzMDBoNDAwdi0zMDBoLTQwMHYzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFkIiB1bmljb2RlPSImI3hlMGFkOyIgCmQ9Ik0wIDcwMGgxMDB2LTcwMGgtMTAwdjcwMHpNNzAwIDcwMGgxMDB2LTcwMGgtMTAwdjcwMHpNMjAwIDYwMGgyMDB2LTEwMGgtMjAwdjEwMHpNMzAwIDQwMGgyMDB2LTEwMGgtMjAwdjEwMHpNNDAwIDIwMGgyMDB2LTEwMGgtMjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWUiIHVuaWNvZGU9IiYjeGUwYWU7IiAKZD0iTTMyNSA3MDBjNDIgLTE0MSA4NyAtMjgwIDEzMSAtNDE5YzI5IDc0IDU5IDE0OCA4OCAyMjJjMzAgLTU3IDU4IC0xMTQgODcgLTE3MmgxNjl2LTEwMGgtMjMxbC0xMyAyOGMtMzcgLTkyIC03NCAtMTg0IC0xMTIgLTI3NWMtMzggMTI5IC03OSAyNTcgLTExOSAzODVjLTQyIC0xMzMgLTgzIC0yNjcgLTEyNSAtNDAwYy0yOCA4OCAtNTYgMTc1IC04NCAyNjJoLTExNnYxMDBoMTg4bDkgLTM0bDMgLTZjNDIgMTM3IDgzIDI3MyAxMjUgNDA5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhZiIgdW5pY29kZT0iJiN4ZTBhZjsiIApkPSJNMjAwIDYwMGMwIDU3IDQzIDEwMCAxMDAgMTAwczEwMCAtNDMgMTAwIC0xMDBjMCAtMjggLTE4IC00OCAtMjggLTcyYy0zIC02IC0zIC0xNiAtMyAtMjhoMjMxdi0yMzFjMTIgMCAyMiAwIDI4IDNjMjQgMTAgNDQgMjggNzIgMjhjNTcgMCAxMDAgLTQzIDEwMCAtMTAwcy00MyAtMTAwIC0xMDAgLTEwMGMtMjggMCAtNDggMTggLTcyIDI4Yy02IDMgLTE2IDMgLTI4IDN2LTIzMWgtMjMxYzAgMTIgMCAyMiAzIDI4YzEwIDI0IDI4IDQ0IDI4IDcyCmMwIDU3IC00MyAxMDAgLTEwMCAxMDBzLTEwMCAtNDMgLTEwMCAtMTAwYzAgLTI4IDE4IC00OCAyOCAtNzJjMyAtNiAzIC0xNiAzIC0yOGgtMjMxdjYwMGgyMzFjMCAxMiAwIDIyIC0zIDI4Yy0xMCAyNCAtMjggNDQgLTI4IDcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiMCIgdW5pY29kZT0iJiN4ZTBiMDsiIGhvcml6LWFkdi14PSI1MDAiIApkPSJNMjQ3IDcwMGM4NCAwIDE0OCAtMjAgMTkxIC01OXM1OSAtOTMgNTkgLTE0MWMwIC0xMTcgLTY5IC0xODEgLTExOSAtMjI1cy04MSAtNjcgLTgxIC0xNTB2LTI1aC0xMDB2MjVjMCAxMTcgNjUgMTgxIDExNSAyMjVzODUgNjcgODUgMTUwYzAgMjUgLTggNDggLTI4IDY2cy01NiAzNCAtMTIyIDM0cy05NyAtMTggLTExNiAtMzdzLTI3IC00MyAtMzEgLTY5bC0xMDAgMTJjNSAzOCAxOSA4OCA1OSAxMjhzMTAzIDY2IDE4OCA2NnpNMTk3IDBoMTAwCnYtMTAwaC0xMDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiMSIgdW5pY29kZT0iJiN4ZTBiMTsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtNjkgLTQ4IC0xMjcgLTExMiAtMTQ0Yy0yMiA1NSAtNzUgOTQgLTEzOCA5NGMtMjAgMCAtMzkgLTUgLTU2IC0xMmMtMTcgNjQgLTc1IDExMiAtMTQ0IDExMnMtMTI3IC00OCAtMTQ0IC0xMTJjLTE3IDcgLTM2IDEyIC01NiAxMmMtMzcgMCAtNzEgLTEyIC05NyAtMzRjLTMzIDM2IC01MyA4MiAtNTMgMTM0CmMwIDExMCA5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAwek0zMzQgMzAwaDRoM2MzIDAgNiAxIDkgMWMyOCAwIDUwIC0yMiA1MCAtNTB2LTF2LTIwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHYyMDB2MmMwIDIwIDE1IDQyIDM0IDQ4ek0xMzQgMjAwaDRoM2MzIDAgNiAxIDkgMWMyOCAwIDUwIC0yMiA1MCAtNTB2LTF2LTEwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHYxMDB2MgpjMCAyMCAxNSA0MiAzNCA0OHpNNTM0IDIwMGgzaDRjMyAwIDYgMSA5IDFjMjggMCA1MCAtMjIgNTAgLTUwdi0xdi0xMDBjMCAtMjggLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTB2MTAwdjJjMCAyMCAxNSA0MiAzNCA0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjIiIHVuaWNvZGU9IiYjeGUwYjI7IiAKZD0iTTYwMCA4MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNTBsLTE1MyAtMTkxbDE3NSAtMjA2bDYgLTNoMjJ2MTAwbDIwMCAtMTUwbC0yMDAgLTE1MHYxMDBoLTI1Yy0zNSAwIC01NiAxMiAtNzggMzhsLTE2NiAxOTBsLTE1MyAtMTkwYy0yMiAtMjcgLTQzIC0zOCAtNzggLTM4aC0xMDB2MTAwaDEwMGwxNjYgMjA2bC0xNjMgMTkxbC0zIDNoLTEwMHYxMDBoMTAwYzM0IDAgNTYgLTEyIDc4IC0zOGwxNTMgLTE3OGwxNDEgMTc4CmMyMiAyNyA0MyAzOCA3OCAzOGg1MHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImIzIiB1bmljb2RlPSImI3hlMGIzOyIgCmQ9Ik00MDAgODAwYzExMCAwIDIwOSAtNDcgMjgxIC0xMTlsMTE5IDExOXYtMzAwaC0zMDBsMTA5IDEwOWMtNTQgNTUgLTEyNiA5MSAtMjA5IDkxYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwYzgzIDAgMTU4IDM0IDIxMiA4OGw3MiAtNzJjLTcyIC03MiAtMTc0IC0xMTYgLTI4NCAtMTE2Yy0yMjAgMCAtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImI0IiB1bmljb2RlPSImI3hlMGI0OyIgCmQ9Ik00MDAgODAwaDQwMHYtNDAwbC0xNjYgMTY2bC00MDAgLTQwMGwxNjYgLTE2NmgtNDAwdjQwMGwxNjYgLTE2Nmw0MDAgNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiNSIgdW5pY29kZT0iJiN4ZTBiNTsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjUwIDgwMGwyNTAgLTMwMGgtMjAwdi0yMDBoMjAwbC0yNTAgLTMwMGwtMjUwIDMwMGgyMDB2MjAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImI2IiB1bmljb2RlPSImI3hlMGI2OyIgCmQ9Ik0zMDAgNjAwdi0yMDBoMjAwdjIwMGwzMDAgLTI1MGwtMzAwIC0yNTB2MjAwaC0yMDB2LTIwMGwtMzAwIDI1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjciIHVuaWNvZGU9IiYjeGUwYjc7IiAKZD0iTTAgODAwYzQ0MSAwIDgwMCAtMzU5IDgwMCAtODAwaC0yMDBjMCAzMzMgLTI2NyA2MDAgLTYwMCA2MDB2MjAwek0wIDUwMGMyNzUgMCA1MDAgLTIyNSA1MDAgLTUwMGgtMjAwYzAgMTY3IC0xMzMgMzAwIC0zMDAgMzAwdjIwMHpNMCAyMDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMGgtMjAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjgiIHVuaWNvZGU9IiYjeGUwYjg7IiAKZD0iTTEwMCA4MDBjMzg2IDAgNzAwIC0zMTQgNzAwIC03MDBoLTEwMGMwIDMzMiAtMjY4IDYwMCAtNjAwIDYwMHYxMDB6TTEwMCA2MDBjMjc2IDAgNTAwIC0yMjQgNTAwIC01MDBoLTEwMGMwIDIyMiAtMTc4IDQwMCAtNDAwIDQwMHYxMDB6TTEwMCA0MDBjMTY1IDAgMzAwIC0xMzUgMzAwIC0zMDBoLTEwMGMwIDExMSAtODkgMjAwIC0yMDAgMjAwdjEwMHpNMTAwIDIwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBzLTQ1IC0xMDAgLTEwMCAtMTAwCnMtMTAwIDQ1IC0xMDAgMTAwczQ1IDEwMCAxMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiOSIgdW5pY29kZT0iJiN4ZTBiOTsiIApkPSJNMzAwIDgwMGg0MDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwdi0yMDBoLTQwMHYxNTBjMCAyOCAtMjIgNTAgLTUwIDUwcy01MCAtMjIgLTUwIC01MHYtMjUwaDQwMHYtMzAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMGgtNTAwYy01NSAwIC0xMDAgNDUgLTEwMCAxMDB2MjAwaDEwMHYtMTUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2NTUwYzAgNTUgNDUgMTAwIDEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJhIiB1bmljb2RlPSImI3hlMGJhOyIgCmQ9Ik03NSA3MDBoMjI1di0xMDBoLTIwMHYtNTAwaDQwMHYxMDBoMTAwdi0xMjVjMCAtNDEgLTM0IC03NSAtNzUgLTc1aC00NTBjLTQxIDAgLTc1IDM0IC03NSA3NXY1NTBjMCA0MSAzNCA3NSA3NSA3NXpNNjAwIDcwMGwyMDAgLTIwMGwtMjAwIC0yMDB2MTAwaC0yMDBjLTk0IDAgLTE3MyAtNjUgLTE5NCAtMTUzYzIzIDE5OSAxODkgMzUzIDM5NCAzNTN2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiYiIgdW5pY29kZT0iJiN4ZTBiYjsiIApkPSJNNTAwIDcwMGwzMDAgLTI4NGwtMzAwIC0zMTZ2MjAwaC0xMDBjLTIwMCAwIC0zNDggLTEwMiAtNDAwIC0zMDBjMCAyOTUgMTAwIDUwMCA1MDAgNTAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmMiIHVuaWNvZGU9IiYjeGUwYmM7IiAKZD0iTTM4MSA3OTFsMTkgOWwxOSAtOWMxMjcgLTUzIDI1MyAtMTA4IDM4MSAtMTYwdi0zMWMwIC0xNjYgLTY3IC0zMTMgLTE0NyAtNDE5Yy00MCAtNTMgLTgzIC05NyAtMTI1IC0xMjhzLTgyIC01MyAtMTI4IC01M3MtODYgMjIgLTEyOCA1M3MtODUgNzUgLTEyNSAxMjhjLTgwIDEwNyAtMTQ3IDI1MyAtMTQ3IDQxOXYzMWMxMjggNTIgMjU0IDEwNyAzODEgMTYwek00MDAgMTAwdjU5MWwtMjk0IC0xMjJjOCAtMTI2IDU4IC0yNDMgMTIyIC0zMjgKYzM1IC00NiA3MyAtODYgMTA2IC0xMTBzNjIgLTMxIDY2IC0zMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmQiIHVuaWNvZGU9IiYjeGUwYmQ7IiAKZD0iTTYwMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTQwMCA3MDBoMTAwdi03MDBoLTEwMHY3MDB6TTIwMCA1MDBoMTAwdi01MDBoLTEwMHY1MDB6TTAgMzAwaDEwMHYtMzAwaC0xMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiZSIgdW5pY29kZT0iJiN4ZTBiZTsiIApkPSJNMzAwIDgwMGgxMDB2LTIwMGgyMDBsMTAwIC0xMDBsLTEwMCAtMTAwaC0yMDB2LTQwMGgtMTAwdjUwMGgtMjAwbC0xMDAgMTAwbDEwMCAxMDBoMjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmYiIHVuaWNvZGU9IiYjeGUwYmY7IiAKZD0iTTIwMCA4MDBoMTAwdi02MDBoMjAwbC0yNTAgLTIwMGwtMjUwIDIwMGgyMDB2NjAwek00MDAgODAwaDIwMHYtMTAwaC0yMDB2MTAwek00MDAgNjAwaDMwMHYtMTAwaC0zMDB2MTAwek00MDAgNDAwaDQwMHYtMTAwaC00MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjMCIgdW5pY29kZT0iJiN4ZTBjMDsiIApkPSJNMjAwIDgwMGgxMDB2LTYwMGgyMDBsLTI1MCAtMjAwbC0yNTAgMjAwaDIwMHY2MDB6TTQwMCA4MDBoNDAwdi0xMDBoLTQwMHYxMDB6TTQwMCA2MDBoMzAwdi0xMDBoLTMwMHYxMDB6TTQwMCA0MDBoMjAwdi0xMDBoLTIwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImMxIiB1bmljb2RlPSImI3hlMGMxOyIgCmQ9Ik03NSA3MDBoNjUwYzQxIDAgNzUgLTM0IDc1IC03NXYtNTUwYzAgLTQxIC0zNCAtNzUgLTc1IC03NWgtNjUwYy00MSAwIC03NSAzNCAtNzUgNzV2NTUwYzAgNDEgMzQgNzUgNzUgNzV6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA2MDB2LTEwMGg0MDB2MTAwaC00MDB6TTEwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA0MDB2LTEwMGg0MDB2MTAwaC00MDB6TTEwMCAyMDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCAyMDAKdi0xMDBoNDAwdjEwMGgtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjMiIgdW5pY29kZT0iJiN4ZTBjMjsiIApkPSJNNDAwIDgwMGwxMDAgLTMwMGgzMDBsLTI1MCAtMjAwbDEwMCAtMzAwbC0yNTAgMjAwbC0yNTAgLTIwMGwxMDAgMzAwbC0yNTAgMjAwaDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzMiIHVuaWNvZGU9IiYjeGUwYzM7IiAKZD0iTTQwMCA4MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0xNTAgNzAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHpNNjUwIDcwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTQwMCA2MDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMApzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDBzOTAgMjAwIDIwMCAyMDB6TTUwIDQ1MGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTc1MCA0NTBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0xNTAgMjAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MApzMjIgNTAgNTAgNTB6TTY1MCAyMDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek00MDAgMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzQiIHVuaWNvZGU9IiYjeGUwYzQ7IiAKZD0iTTM0IDgwMGg2MzJjMTggMCAzNCAtMTYgMzQgLTM0di03MzJjMCAtMTggLTE2IC0zNCAtMzQgLTM0aC02MzJjLTE4IDAgLTM0IDE2IC0zNCAzNHY3MzJjMCAxOCAxNiAzNCAzNCAzNHpNMTAwIDcwMHYtNTAwaDUwMHY1MDBoLTUwMHpNMzUwIDE1MGMtMzggMCAtNjMgLTQyIC00NCAtNzVzNjkgLTMzIDg4IDBzLTYgNzUgLTQ0IDc1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjNSIgdW5pY29kZT0iJiN4ZTBjNTsiIApkPSJNMCA4MDBoMzAwbDUwMCAtNTAwbC0zMDAgLTMwMGwtNTAwIDUwMHYzMDB6TTIwMCA3MDBjLTU1IDAgLTEwMCAtNDUgLTEwMCAtMTAwczQ1IC0xMDAgMTAwIC0xMDBzMTAwIDQ1IDEwMCAxMDBzLTQ1IDEwMCAtMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzYiIHVuaWNvZGU9IiYjeGUwYzY7IiAKZD0iTTAgNjAwaDIwMGwzMDAgLTMwMGwtMjAwIC0yMDBsLTMwMCAzMDB2MjAwek0zNDAgNjAwaDE2MGwzMDAgLTMwMGwtMjAwIC0yMDBsLTc4IDc4bDExOSAxMjJ6TTE1MCA1MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzciIHVuaWNvZGU9IiYjeGUwYzc7IiAKZD0iTTQwMCA4MDBjMjIwIDAgNDAwIC0xODAgNDAwIC00MDBzLTE4MCAtNDAwIC00MDAgLTQwMHMtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6TTQwMCA3MDBjLTE2NiAwIC0zMDAgLTEzNCAtMzAwIC0zMDBzMTM0IC0zMDAgMzAwIC0zMDBzMzAwIDEzNCAzMDAgMzAwcy0xMzQgMzAwIC0zMDAgMzAwek00MDAgNjAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDAKczkwIDIwMCAyMDAgMjAwek00MDAgNTAwYy01NiAwIC0xMDAgLTQ0IC0xMDAgLTEwMHM0NCAtMTAwIDEwMCAtMTAwczEwMCA0NCAxMDAgMTAwcy00NCAxMDAgLTEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImM4IiB1bmljb2RlPSImI3hlMGM4OyIgCmQ9Ik0wIDcwMGg1NTlsLTEwMCAtMTAwaC0zNTl2LTUwMGg1MDB2MTU5bDEwMCAxMDB2LTM1OWgtNzAwdjcwMHpNNzAwIDcwMGwxMDAgLTEwMGwtNDAwIC00MDBsLTIwMCAyMDBsMTAwIDEwMGwxMDAgLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzkiIHVuaWNvZGU9IiYjeGUwYzk7IiAKZD0iTTkgODAwaDc4MmM2IDAgOSAtMyA5IC05di03ODJjMCAtNiAtMyAtOSAtOSAtOWgtNzgyYy02IDAgLTkgMyAtOSA5djc4MmMwIDYgMyA5IDkgOXpNMTUwIDcyMmwtNzIgLTcybDEwMCAtMTAwbC0xMDAgLTEwMGw3MiAtNzJsMTcyIDE3MnpNNDAwIDUwMHYtMTAwaDMwMHYxMDBoLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2EiIHVuaWNvZGU9IiYjeGUwY2E7IiAKZD0iTTAgODAwaDgwMHYtMjAwaC01MGMwIDU1IC00NSAxMDAgLTEwMCAxMDBoLTE1MHYtNTUwYzAgLTI4IDIyIC01MCA1MCAtNTBoNTB2LTEwMGgtNDAwdjEwMGg1MGMyOCAwIDUwIDIyIDUwIDUwdjU1MGgtMTUwYy01NSAwIC0xMDAgLTQ1IC0xMDAgLTEwMGgtNTB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYiIgdW5pY29kZT0iJiN4ZTBjYjsiIApkPSJNMCA3MDBoMTAwdi00MDBoLTEwMHY0MDB6TTIwMCA3MDBoMzUwYzIxIDAgMzkgLTEzIDQ3IC0zMWMwIDAgMTAzIC0yOTEgMTAzIC0zMTlzLTIyIC01MCAtNTAgLTUwaC0xNTBjLTI4IDAgLTUwIC0yNSAtNTAgLTUwczM5IC0xNTggNDcgLTE4NHMtNSAtNTUgLTMxIC02M3MtNTIgNSAtNjYgMzFzLTEwOSAyMTkgLTEyOCAyMzhzLTQ0IDI4IC03MiAyOHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNjIiB1bmljb2RlPSImI3hlMGNjOyIgCmQ9Ik00MDAgNjY2YzEwIDE5IDI4IDMyIDQ3IDM0bDE5IC0zYzI2IC04IDM5IC0zNyAzMSAtNjNzLTQ3IC0xNTkgLTQ3IC0xODRzMjIgLTUwIDUwIC01MGgxNTBjMjggMCA1MCAtMjIgNTAgLTUwcy0xMDMgLTMxOSAtMTAzIC0zMTljLTggLTE4IC0yNiAtMzEgLTQ3IC0zMWgtMzUwdjQwMGMyOCAwIDUzIDkgNzIgMjhzMTE0IDIxMiAxMjggMjM4ek0wIDQwMGgxMDB2LTQwMGgtMTAwdjQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2QiIHVuaWNvZGU9IiYjeGUwY2Q7IiAKZD0iTTIwMCA3MDBoMzAwdi0xMDBoLTEwMHYtNmMyNSAtNCA1MCAtOCA3MiAtMTZsLTM0IC05NGMtMjggMTEgLTU4IDE2IC04OCAxNmMtMTM5IDAgLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MHMyNTAgMTExIDI1MCAyNTBjMCAzMSAtNSA2MCAtMTYgODhsOTEgMzdjMTQgLTM4IDI1IC04MSAyNSAtMTI1YzAgLTE5MyAtMTU3IC0zNTAgLTM1MCAtMzUwcy0zNTAgMTU3IC0zNTAgMzUwYzAgMTc2IDEzMCAzMjMgMzAwIDM0N3YzCmgtMTAwdjEwMHpNNzAwIDU4NGMwIDAgLTI5NiAtMzQ4IC0zMTYgLTM2OHMtNDggLTIwIC02OCAwcy0yMCA0OCAwIDY4czM4NCAzMDAgMzg0IDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2UiIHVuaWNvZGU9IiYjeGUwY2U7IiAKZD0iTTYwMCA3MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNjAwdjEwMGg2MDB2MTAwek0yMDAgMzAwdi0xMDBoNjAwdi0xMDBoLTYwMHYtMTAwbC0yMDAgMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjZiIgdW5pY29kZT0iJiN4ZTBjZjsiIApkPSJNMzAwIDgwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaDEwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBoLTcwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwaDEwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwek0xMDAgNTAwaDEwMHYtMzUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MzUwaDEwMHYtMzUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MzUwaDEwMHYtNDgxYzAgLTExIC04IC0xOSAtMTkgLTE5aC00NjIKYy0xMSAwIC0xOSA4IC0xOSAxOXY0ODF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQwIiB1bmljb2RlPSImI3hlMGQwOyIgCmQ9Ik0xMDAgODAwaDIwMHYtNDAwYzAgLTU1IDQ1IC0xMDAgMTAwIC0xMDBzMTAwIDQ1IDEwMCAxMDB2NDAwaDEwMHYtNDAwYzAgLTExMCAtOTAgLTIwMCAtMjAwIC0yMDBoLTUwYy0xMzggMCAtMjUwIDkwIC0yNTAgMjAwdjQwMHpNMCAxMDBoNzAwdi0xMDBoLTcwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQxIiB1bmljb2RlPSImI3hlMGQxOyIgCmQ9Ik05IDcwMGgxODJjNiAwIDkgLTMgOSAtOXYtNDgyYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXY0ODJjMCA2IDMgOSA5IDl6TTYwOSA3MDBoMTgyYzYgMCA5IC0zIDkgLTl2LTQ4MmMwIC02IC0zIC05IC05IC05aC0xODJjLTYgMCAtOSAzIC05IDl2NDgyYzAgNiAzIDkgOSA5ek0zMDkgNTAwaDE4MmM2IDAgOSAtMyA5IC05di0yODJjMCAtNiAtMyAtOSAtOSAtOWgtMTgyYy02IDAgLTkgMyAtOSA5djI4MgpjMCA2IDMgOSA5IDl6TTAgMTAwaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkMiIgdW5pY29kZT0iJiN4ZTBkMjsiIApkPSJNMTAgNzAwaDE4MWM2IDAgOSAtMyA5IC05di0xOTFoLTIwMHYxOTFjMCA2IDQgOSAxMCA5ek02MTAgNzAwaDE4MWM2IDAgOSAtMyA5IC05di0xOTFoLTIwMHYxOTFjMCA2IDUgOSAxMCA5ek0zMTAgNjAwaDE4MWM2IDAgOSAtMyA5IC05di05MWgtMjAwdjkxYzAgNiA0IDkgMTAgOXpNMCA0MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMjAwaDIwMHYtMTkxYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXYxOTF6TTMwMCAyMDAKaDIwMHYtOTFjMCAtNiAtMyAtOSAtOSAtOWgtMTgxYy02IDAgLTEwIDMgLTEwIDl2OTF6TTYwMCAyMDBoMjAwdi0xOTFjMCAtNiAtMyAtOSAtOSAtOWgtMTgxYy02IDAgLTEwIDMgLTEwIDl2MTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkMyIgdW5pY29kZT0iJiN4ZTBkMzsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTkgNTAwaDE4MmM2IDAgOSAtMyA5IC05di00ODJjMCAtNiAtMyAtOSAtOSAtOWgtMTgyYy02IDAgLTkgMyAtOSA5djQ4MmMwIDYgMyA5IDkgOXpNMzA5IDUwMGgxODJjNiAwIDkgLTMgOSAtOXYtMjgyYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXYyODJjMCA2IDMgOSA5IDl6TTYwOSA1MDBoMTgyYzYgMCA5IC0zIDkgLTl2LTQ4MmMwIC02IC0zIC05IC05IC05aC0xODIKYy02IDAgLTkgMyAtOSA5djQ4MmMwIDYgMyA5IDkgOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDQiIHVuaWNvZGU9IiYjeGUwZDQ7IiAKZD0iTTUwIDYwMGg1MDBjMjggMCA1MCAtMjIgNTAgLTUwdi0xNTBsMTAwIDEwMGgxMDB2LTMwMGgtMTAwbC0xMDAgMTAwdi0xNTBjMCAtMjggLTIyIC01MCAtNTAgLTUwaC01MDBjLTI4IDAgLTUwIDIyIC01MCA1MHY0MDBjMCAyOCAyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDUiIHVuaWNvZGU9IiYjeGUwZDU7IiAKZD0iTTMzNCA4MDBoNjZ2LTgwMGgtNjZsLTEzNCAyMDBoLTIwMHY0MDBoMjAwek01MDAgNjAwdjEwMGMyNiAwIDUyIC00IDc1IC0xMGMxMzAgLTMzIDIyNSAtMTUwIDIyNSAtMjkwcy05NSAtMjU4IC0yMjUgLTI5MWgtM2MtMjMgLTYgLTQ3IC05IC03MiAtOXYxMDBjMTcgMCAzNCAyIDUwIDZjODYgMjIgMTUwIDEwMCAxNTAgMTk0cy02NCAxNzIgLTE1MCAxOTRjLTE2IDQgLTMzIDYgLTUwIDZ6TTUwMCA1MDBsMjUgLTMKYzQ0IC0xMSA3NSAtNTEgNzUgLTk3cy0zMiAtODYgLTc1IC05N2wtMjUgLTN2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkNiIgdW5pY29kZT0iJiN4ZTBkNjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzM0IDgwMGg2NnYtODAwaC02NmwtMTM0IDIwMGgtMjAwdjQwMGgyMDB6TTUwMCA1MDBsMjUgLTNjNDQgLTExIDc1IC01MSA3NSAtOTdzLTMyIC04NiAtNzUgLTk3bC0yNSAtM3YyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQ3IiB1bmljb2RlPSImI3hlMGQ3OyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0zMzQgODAwaDY2di04MDBoLTY2bC0xMzQgMjAwaC0yMDB2NDAwaDIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDgiIHVuaWNvZGU9IiYjeGUwZDg7IiAKZD0iTTMwOSA4MDBoODJjNiAwIDEwIC00IDEyIC05bDI5NCAtNjgybDMgLTE5di04MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2ODFsMyAxOWwyOTQgNjgyYzIgNSA2IDkgMTIgOXpNMzAwIDUwMHYtMjAwaDEwMHYyMDBoLTEwMHpNMzAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDkiIHVuaWNvZGU9IiYjeGUwZDk7IiAKZD0iTTM3NSA4MDBjMTM4IDAgMjY5IC0zOSAzNzggLTEwOWwtNTMgLTgyYy05MyA2MCAtMjA1IDkxIC0zMjUgOTFjLTExOSAwIC0yMjkgLTMyIC0zMjIgLTkxbC01MyA4MmMxMDkgNzAgMjM3IDEwOSAzNzUgMTA5ek0zNzUgNTAwYzc4IDAgMTU0IC0yMyAyMTYgLTYybC01MyAtODVjLTQ2IDMwIC0xMDQgNDcgLTE2MyA0N2MtNjAgMCAtMTEyIC0xNyAtMTU5IC00N2wtNTQgODVjNjIgNDAgMTM0IDYyIDIxMyA2MnpNMzc1IDIwMApjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwcy00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwczQ1IDEwMCAxMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYSIgdW5pY29kZT0iJiN4ZTBkYTsiIGhvcml6LWFkdi14PSI5MDAiIApkPSJNNTUxIDgwMGMxNiAwIDMyIDAgNDcgLTNsLTk3IC05N3YtMjAwaDIwMGw5NyA5N2MzIC0xNSAzIC0zMSAzIC00N2MwIC0xMzggLTExMiAtMjUwIC0yNTAgLTI1MGMtMzIgMCAtNjIgOCAtOTAgMTlsLTI4OCAtMjkxYy0yMCAtMjAgLTQ2IC0yOCAtNzIgLTI4cy01MiA4IC03MiAyOGMtMzkgMzkgLTM5IDEwNSAwIDE0NGwyOTEgMjg3Yy0xMSAyOCAtMTkgNTkgLTE5IDkxYzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNMTAxIDE1MApjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGIiIHVuaWNvZGU9IiYjeGUwZGI7IiAKZD0iTTE0MSA3MDBjODQgLTg0IDE2OSAtMTY3IDI1MyAtMjUwYzgyIDgzIDE2NyAxNjUgMjQ3IDI1MGwxNDMgLTE0MWwtMjUzIC0yNTNjODQgLTgyIDE2NyAtMTY2IDI1MyAtMjQ3bC0xNDMgLTE0M2MtODEgODYgLTE2NSAxNjkgLTI0NyAyNTNsLTI1MyAtMjUzbC0xNDEgMTQzYzg1IDgwIDE2NyAxNjQgMjUwIDI0N2MtODMgODQgLTE2NiAxNjkgLTI1MCAyNTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRjIiB1bmljb2RlPSImI3hlMGRjOyIgCmQ9Ik0wIDgwMGgxMDBsMjMxIC0zMDBoMzhsMjMxIDMwMGgxMDBsLTIyNSAtMzAwaDIyNXYtMTAwaC0zMDB2LTEwMGgzMDB2LTEwMGgtMzAwdi0yMDBoLTEwMHYyMDBoLTMwMHYxMDBoMzAwdjEwMGgtMzAwdjEwMGgyMjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRkIiB1bmljb2RlPSImI3hlMGRkOyIgaG9yaXotYWR2LXg9IjkwMCIgCmQ9Ik0zNTAgODAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgLTYxIC0xNyAtMTE5IC00NCAtMTY5YzQgLTIgMTAgLTYgMTMgLTlsMTAzIC0xMDBjMTYgLTE2IDMwIC00OSAzMCAtNzJjMCAtNTYgLTQ2IC0xMDIgLTEwMiAtMTAyYy0yMyAwIC01NiAxNCAtNzIgMzBsLTEwMCAxMDNjLTMgMyAtNyA5IC05IDEzYy01MCAtMjggLTEwOCAtNDQgLTE2OSAtNDRjLTE5MyAwIC0zNTAgMTU3IC0zNTAgMzUwczE1NyAzNTAgMzUwIDM1MHpNMzUwIDcwMApjLTEzOSAwIC0yNTAgLTExMSAtMjUwIC0yNTBzMTExIC0yNTAgMjUwIC0yNTBjNjIgMCAxMTkgMjMgMTYzIDYwYzcgMTEgMTkgMjUgMzEgMzFsMyAzYzM0IDQzIDUzIDk3IDUzIDE1NmMwIDEzOSAtMTExIDI1MCAtMjUwIDI1MHpNMzAwIDYwMGgxMDB2LTEwMGgxMDB2LTEwMGgtMTAwdi0xMDBoLTEwMHYxMDBoLTEwMHYxMDBoMTAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGUiIHVuaWNvZGU9IiYjeGUwZGU7IiBob3Jpei1hZHYteD0iOTAwIiAKZD0iTTM1MCA4MDBjMTkzIDAgMzUwIC0xNTcgMzUwIC0zNTBjMCAtNjEgLTE3IC0xMTkgLTQ0IC0xNjljNCAtMiAxMCAtNiAxMyAtOWwxMDMgLTEwMGMxNiAtMTYgMzAgLTQ5IDMwIC03MmMwIC01NiAtNDYgLTEwMiAtMTAyIC0xMDJjLTIzIDAgLTU2IDE0IC03MiAzMGwtMTAwIDEwM2MtMyAzIC03IDkgLTkgMTNjLTUwIC0yOCAtMTA4IC00NCAtMTY5IC00NGMtMTkzIDAgLTM1MCAxNTcgLTM1MCAzNTBzMTU3IDM1MCAzNTAgMzUwek0zNTAgNzAwCmMtMTM5IDAgLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MGM2MiAwIDExOSAyMyAxNjMgNjBjNyAxMSAxOSAyNSAzMSAzMWwzIDNjMzQgNDMgNTMgOTcgNTMgMTU2YzAgMTM5IC0xMTEgMjUwIC0yNTAgMjUwek0yMDAgNTAwaDMwMHYtMTAwaC0zMDB2MTAweiIgLz4KICA8L2ZvbnQ+CjwvZGVmcz48L3N2Zz4K"

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.ttf":
/***/ (function(module, exports) {

module.exports = "data:application/x-font-ttf;base64,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AEoALgAgAE8AbgBvAHIAaQAgAHcAaQB0AGgAIABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAKABoAHQAdABwADoALwAvAGYAbwBuAHQAZgBvAHIAZwBlAC4AcwBmAC4AbgBlAHQAKQAAQ3JlYXRlZCBieSBQLkouIE9ub3JpIHdpdGggRm9udEZvcmdlIDIuMCAoaHR0cDovL2ZvbnRmb3JnZS5zZi5uZXQpAABJAGMAbwBuAHMAAEljb25zAABpAGMAbwBuAGkAYwAAaWNvbmljAABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAFUAbgB0AGkAdABsAGUAZAAxACAAOgAgADEALQA3AC0AMgAwADEANAAARm9udEZvcmdlIDIuMCA6IFVudGl0bGVkMSA6IDEtNy0yMDE0AABVAG4AdABpAHQAbABlAGQAMQAAVW50aXRsZWQxAABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAxACAAAFZlcnNpb24gMS4xLjEgAABvAHAAZQBuAC0AaQBjAG8AbgBpAGMAAG9wZW4taWNvbmljAAACAAAAAAAA/4MAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAOIAAAABAAIBAgEDAQQBBQEGAQcBCAEJAQoBCwBEAEUARgBHAEgASQEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakAoAGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHO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UlggPFkusSsBFCstsDwsIyAuRrACJUZQWCA8WS6xKwEUKy2wPSwjIC5GsAIlRlJYIDxZIyAuRrACJUZQWCA8WS6xKwEUKy2wPiywNSsjIC5GsAIlRlJYIDxZLrErARQrLbA/LLA2K4ogIDywBCNCijgjIC5GsAIlRlJYIDxZLrErARQrsARDLrArKy2wQCywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixKwEUKy2wQSyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbErARQrLbBCLLA1Ky6xKwEUKy2wQyywNishIyAgPLAEI0IjOLErARQrsARDLrArKy2wRCywABUgR7AAI0KyAAEBFRQTLrAxKi2wRSywABUgR7AAI0KyAAEBFRQTLrAxKi2wRiyxAAEUE7AyKi2wRyywNCotsEgssAAWRSMgLiBGiiNhOLErARQrLbBJLLAII0KwSCstsEossgAAQSstsEsssgABQSstsEwssgEAQSstsE0ssgEBQSstsE4ssgAAQistsE8ssgABQistsFAssgEAQistsFEssgEBQistsFIssgAAPistsFMssgABPistsFQssgEAPistsFUssgEBPistsFYssgAAQCstsFcssgABQCstsFgssgEAQCstsFkssgEBQCstsFossgAAQystsFsssgABQystsFwssgEAQystsF0ssgEBQystsF4ssgAAPystsF8ssgABPystsGAssgEAPystsGEssgEBPystsGIssDcrLrErARQrLbBjLLA3K7A7Ky2wZCywNyuwPCstsGUssAAWsDcrsD0rLbBmLLA4Ky6xKwEUKy2wZyywOCuwOystsGgssDgrsDwrLbBpLLA4K7A9Ky2waiywOSsusSsBFCstsGsssDkrsDsrLbBsLLA5K7A8Ky2wbSywOSuwPSstsG4ssDorLrErARQrLbBvLLA6K7A7Ky2wcCywOiuwPCstsHEssDorsD0rLbByLLMJBAIDRVghGyMhWUIrsAhlsAMkUHiwARUwLQBLuADIUlixAQGOWbABuQgACABjcLEABUKxAAAqsQAFQrEACCqxAAVCsQAIKrEABUK5AAAACSqxAAVCuQAAAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWbEADCq4Af+FsASNsQIARAA="

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.woff":
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,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"

/***/ }),

/***/ "../../node_modules/preact-compat/dist/preact-compat.es.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export version */
/* unused harmony export DOM */
/* unused harmony export Children */
/* unused harmony export render */
/* unused harmony export createClass */
/* unused harmony export createFactory */
/* unused harmony export createElement */
/* unused harmony export cloneElement */
/* unused harmony export isValidElement */
/* unused harmony export findDOMNode */
/* unused harmony export unmountComponentAtNode */
/* unused harmony export Component */
/* unused harmony export PureComponent */
/* unused harmony export unstable_renderSubtreeIntoContainer */
/* unused harmony export __spread */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__("../../node_modules/prop-types/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact__ = __webpack_require__("../../node_modules/preact/dist/preact.esm.js");
/* unused harmony reexport PropTypes */



var version = '15.1.0'; // trick libraries to think we are react

var ELEMENTS = 'a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr circle clipPath defs ellipse g image line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan'.split(' ');

var REACT_ELEMENT_TYPE = (typeof Symbol!=='undefined' && Symbol.for && Symbol.for('react.element')) || 0xeac7;

var COMPONENT_WRAPPER_KEY = typeof Symbol!=='undefined' ? Symbol.for('__preactCompatWrapper') : '__preactCompatWrapper';

// don't autobind these methods since they already have guaranteed context.
var AUTOBIND_BLACKLIST = {
	constructor: 1,
	render: 1,
	shouldComponentUpdate: 1,
	componentWillReceiveProps: 1,
	componentWillUpdate: 1,
	componentDidUpdate: 1,
	componentWillMount: 1,
	componentDidMount: 1,
	componentWillUnmount: 1,
	componentDidUnmount: 1
};


var CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip|color|fill|flood|font|glyph|horiz|marker|overline|paint|stop|strikethrough|stroke|text|underline|unicode|units|v|vector|vert|word|writing|x)[A-Z]/;


var BYPASS_HOOK = {};

/*global process*/
var DEV = typeof process==='undefined' || !process.env || "production"!=='production';

// a component that renders nothing. Used to replace components for unmountComponentAtNode.
function EmptyComponent() { return null; }



// make react think we're react.
var VNode = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])('a', null).constructor;
VNode.prototype.$$typeof = REACT_ELEMENT_TYPE;
VNode.prototype.preactCompatUpgraded = false;
VNode.prototype.preactCompatNormalized = false;

Object.defineProperty(VNode.prototype, 'type', {
	get: function() { return this.nodeName; },
	set: function(v) { this.nodeName = v; },
	configurable:true
});

Object.defineProperty(VNode.prototype, 'props', {
	get: function() { return this.attributes; },
	set: function(v) { this.attributes = v; },
	configurable:true
});



var oldEventHook = __WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].event;
__WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].event = function (e) {
	if (oldEventHook) { e = oldEventHook(e); }
	e.persist = Object;
	e.nativeEvent = e;
	return e;
};


var oldVnodeHook = __WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].vnode;
__WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].vnode = function (vnode) {
	if (!vnode.preactCompatUpgraded) {
		vnode.preactCompatUpgraded = true;

		var tag = vnode.nodeName,
			attrs = vnode.attributes = extend({}, vnode.attributes);

		if (typeof tag==='function') {
			if (tag[COMPONENT_WRAPPER_KEY]===true || (tag.prototype && 'isReactComponent' in tag.prototype)) {
				if (vnode.children && String(vnode.children)==='') { vnode.children = undefined; }
				if (vnode.children) { attrs.children = vnode.children; }

				if (!vnode.preactCompatNormalized) {
					normalizeVNode(vnode);
				}
				handleComponentVNode(vnode);
			}
		}
		else {
			if (vnode.children && String(vnode.children)==='') { vnode.children = undefined; }
			if (vnode.children) { attrs.children = vnode.children; }

			if (attrs.defaultValue) {
				if (!attrs.value && attrs.value!==0) {
					attrs.value = attrs.defaultValue;
				}
				delete attrs.defaultValue;
			}

			handleElementVNode(vnode, attrs);
		}
	}

	if (oldVnodeHook) { oldVnodeHook(vnode); }
};

function handleComponentVNode(vnode) {
	var tag = vnode.nodeName,
		a = vnode.attributes;

	vnode.attributes = {};
	if (tag.defaultProps) { extend(vnode.attributes, tag.defaultProps); }
	if (a) { extend(vnode.attributes, a); }
}

function handleElementVNode(vnode, a) {
	var shouldSanitize, attrs, i;
	if (a) {
		for (i in a) { if ((shouldSanitize = CAMEL_PROPS.test(i))) { break; } }
		if (shouldSanitize) {
			attrs = vnode.attributes = {};
			for (i in a) {
				if (a.hasOwnProperty(i)) {
					attrs[ CAMEL_PROPS.test(i) ? i.replace(/([A-Z0-9])/, '-$1').toLowerCase() : i ] = a[i];
				}
			}
		}
	}
}



// proxy render() since React returns a Component reference.
function render$1(vnode, parent, callback) {
	var prev = parent && parent._preactCompatRendered && parent._preactCompatRendered.base;

	// ignore impossible previous renders
	if (prev && prev.parentNode!==parent) { prev = null; }

	// default to first Element child
	if (!prev && parent) { prev = parent.firstElementChild; }

	// remove unaffected siblings
	for (var i=parent.childNodes.length; i--; ) {
		if (parent.childNodes[i]!==prev) {
			parent.removeChild(parent.childNodes[i]);
		}
	}

	var out = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["e" /* render */])(vnode, parent, prev);
	if (parent) { parent._preactCompatRendered = out && (out._component || { base: out }); }
	if (typeof callback==='function') { callback(); }
	return out && out._component || out;
}


var ContextProvider = function () {};

ContextProvider.prototype.getChildContext = function () {
	return this.props.context;
};
ContextProvider.prototype.render = function (props) {
	return props.children[0];
};

function renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {
	var wrap = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(ContextProvider, { context: parentComponent.context }, vnode);
	var renderContainer = render$1(wrap, container);
	var component = renderContainer._component || renderContainer.base;
	if (callback) { callback.call(component, renderContainer); }
	return component;
}


function unmountComponentAtNode(container) {
	var existing = container._preactCompatRendered && container._preactCompatRendered.base;
	if (existing && existing.parentNode===container) {
		Object(__WEBPACK_IMPORTED_MODULE_1_preact__["e" /* render */])(Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(EmptyComponent), container, existing);
		return true;
	}
	return false;
}



var ARR = [];

// This API is completely unnecessary for Preact, so it's basically passthrough.
var Children = {
	map: function(children, fn, ctx) {
		if (children == null) { return null; }
		children = Children.toArray(children);
		if (ctx && ctx!==children) { fn = fn.bind(ctx); }
		return children.map(fn);
	},
	forEach: function(children, fn, ctx) {
		if (children == null) { return null; }
		children = Children.toArray(children);
		if (ctx && ctx!==children) { fn = fn.bind(ctx); }
		children.forEach(fn);
	},
	count: function(children) {
		return children && children.length || 0;
	},
	only: function(children) {
		children = Children.toArray(children);
		if (children.length!==1) { throw new Error('Children.only() expects only one child.'); }
		return children[0];
	},
	toArray: function(children) {
		if (children == null) { return []; }
		return ARR.concat(children);
	}
};


/** Track current render() component for ref assignment */
var currentComponent;


function createFactory(type) {
	return createElement.bind(null, type);
}


var DOM = {};
for (var i=ELEMENTS.length; i--; ) {
	DOM[ELEMENTS[i]] = createFactory(ELEMENTS[i]);
}

function upgradeToVNodes(arr, offset) {
	for (var i=offset || 0; i<arr.length; i++) {
		var obj = arr[i];
		if (Array.isArray(obj)) {
			upgradeToVNodes(obj);
		}
		else if (obj && typeof obj==='object' && !isValidElement(obj) && ((obj.props && obj.type) || (obj.attributes && obj.nodeName) || obj.children)) {
			arr[i] = createElement(obj.type || obj.nodeName, obj.props || obj.attributes, obj.children);
		}
	}
}

function isStatelessComponent(c) {
	return typeof c==='function' && !(c.prototype && c.prototype.render);
}


// wraps stateless functional components in a PropTypes validator
function wrapStatelessComponent(WrappedComponent) {
	return createClass({
		displayName: WrappedComponent.displayName || WrappedComponent.name,
		render: function() {
			return WrappedComponent(this.props, this.context);
		}
	});
}


function statelessComponentHook(Ctor) {
	var Wrapped = Ctor[COMPONENT_WRAPPER_KEY];
	if (Wrapped) { return Wrapped===true ? Ctor : Wrapped; }

	Wrapped = wrapStatelessComponent(Ctor);

	Object.defineProperty(Wrapped, COMPONENT_WRAPPER_KEY, { configurable:true, value:true });
	Wrapped.displayName = Ctor.displayName;
	Wrapped.propTypes = Ctor.propTypes;
	Wrapped.defaultProps = Ctor.defaultProps;

	Object.defineProperty(Ctor, COMPONENT_WRAPPER_KEY, { configurable:true, value:Wrapped });

	return Wrapped;
}


function createElement() {
	var args = [], len = arguments.length;
	while ( len-- ) args[ len ] = arguments[ len ];

	upgradeToVNodes(args, 2);
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */].apply(void 0, args));
}


function normalizeVNode(vnode) {
	vnode.preactCompatNormalized = true;

	applyClassName(vnode);

	if (isStatelessComponent(vnode.nodeName)) {
		vnode.nodeName = statelessComponentHook(vnode.nodeName);
	}

	var ref = vnode.attributes.ref,
		type = ref && typeof ref;
	if (currentComponent && (type==='string' || type==='number')) {
		vnode.attributes.ref = createStringRefProxy(ref, currentComponent);
	}

	applyEventNormalization(vnode);

	return vnode;
}


function cloneElement$1(element, props) {
	var children = [], len = arguments.length - 2;
	while ( len-- > 0 ) children[ len ] = arguments[ len + 2 ];

	if (!isValidElement(element)) { return element; }
	var elementProps = element.attributes || element.props;
	var node = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(
		element.nodeName || element.type,
		elementProps,
		element.children || elementProps && elementProps.children
	);
	// Only provide the 3rd argument if needed.
	// Arguments 3+ overwrite element.children in preactCloneElement
	var cloneArgs = [node, props];
	if (children && children.length) {
		cloneArgs.push(children);
	}
	else if (props && props.children) {
		cloneArgs.push(props.children);
	}
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["b" /* cloneElement */].apply(void 0, cloneArgs));
}


function isValidElement(element) {
	return element && ((element instanceof VNode) || element.$$typeof===REACT_ELEMENT_TYPE);
}


function createStringRefProxy(name, component) {
	return component._refProxies[name] || (component._refProxies[name] = function (resolved) {
		if (component && component.refs) {
			component.refs[name] = resolved;
			if (resolved===null) {
				delete component._refProxies[name];
				component = null;
			}
		}
	});
}


function applyEventNormalization(ref) {
	var nodeName = ref.nodeName;
	var attributes = ref.attributes;

	if (!attributes || typeof nodeName!=='string') { return; }
	var props = {};
	for (var i in attributes) {
		props[i.toLowerCase()] = i;
	}
	if (props.ondoubleclick) {
		attributes.ondblclick = attributes[props.ondoubleclick];
		delete attributes[props.ondoubleclick];
	}
	// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:
	if (props.onchange && (nodeName==='textarea' || (nodeName.toLowerCase()==='input' && !/^fil|che|rad/i.test(attributes.type)))) {
		var normalized = props.oninput || 'oninput';
		if (!attributes[normalized]) {
			attributes[normalized] = multihook([attributes[normalized], attributes[props.onchange]]);
			delete attributes[props.onchange];
		}
	}
}


function applyClassName(vnode) {
	var a = vnode.attributes || (vnode.attributes = {});
	classNameDescriptor.enumerable = 'className' in a;
	if (a.className) { a.class = a.className; }
	Object.defineProperty(a, 'className', classNameDescriptor);
}


var classNameDescriptor = {
	configurable: true,
	get: function() { return this.class; },
	set: function(v) { this.class = v; }
};

function extend(base, props) {
	var arguments$1 = arguments;

	for (var i=1, obj = (void 0); i<arguments.length; i++) {
		if ((obj = arguments$1[i])) {
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					base[key] = obj[key];
				}
			}
		}
	}
	return base;
}


function shallowDiffers(a, b) {
	for (var i in a) { if (!(i in b)) { return true; } }
	for (var i$1 in b) { if (a[i$1]!==b[i$1]) { return true; } }
	return false;
}


function findDOMNode(component) {
	return component && component.base || component;
}


function F(){}

function createClass(obj) {
	function cl(props, context) {
		bindAll(this);
		Component$1.call(this, props, context, BYPASS_HOOK);
		newComponentHook.call(this, props, context);
	}

	obj = extend({ constructor: cl }, obj);

	// We need to apply mixins here so that getDefaultProps is correctly mixed
	if (obj.mixins) {
		applyMixins(obj, collateMixins(obj.mixins));
	}
	if (obj.statics) {
		extend(cl, obj.statics);
	}
	if (obj.propTypes) {
		cl.propTypes = obj.propTypes;
	}
	if (obj.defaultProps) {
		cl.defaultProps = obj.defaultProps;
	}
	if (obj.getDefaultProps) {
		cl.defaultProps = obj.getDefaultProps();
	}

	F.prototype = Component$1.prototype;
	cl.prototype = extend(new F(), obj);

	cl.displayName = obj.displayName || 'Component';

	return cl;
}


// Flatten an Array of mixins to a map of method name to mixin implementations
function collateMixins(mixins) {
	var keyed = {};
	for (var i=0; i<mixins.length; i++) {
		var mixin = mixins[i];
		for (var key in mixin) {
			if (mixin.hasOwnProperty(key) && typeof mixin[key]==='function') {
				(keyed[key] || (keyed[key]=[])).push(mixin[key]);
			}
		}
	}
	return keyed;
}


// apply a mapping of Arrays of mixin methods to a component prototype
function applyMixins(proto, mixins) {
	for (var key in mixins) { if (mixins.hasOwnProperty(key)) {
		proto[key] = multihook(
			mixins[key].concat(proto[key] || ARR),
			key==='getDefaultProps' || key==='getInitialState' || key==='getChildContext'
		);
	} }
}


function bindAll(ctx) {
	for (var i in ctx) {
		var v = ctx[i];
		if (typeof v==='function' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {
			(ctx[i] = v.bind(ctx)).__bound = true;
		}
	}
}


function callMethod(ctx, m, args) {
	if (typeof m==='string') {
		m = ctx.constructor.prototype[m];
	}
	if (typeof m==='function') {
		return m.apply(ctx, args);
	}
}

function multihook(hooks, skipDuplicates) {
	return function() {
		var arguments$1 = arguments;
		var this$1 = this;

		var ret;
		for (var i=0; i<hooks.length; i++) {
			var r = callMethod(this$1, hooks[i], arguments$1);

			if (skipDuplicates && r!=null) {
				if (!ret) { ret = {}; }
				for (var key in r) { if (r.hasOwnProperty(key)) {
					ret[key] = r[key];
				} }
			}
			else if (typeof r!=='undefined') { ret = r; }
		}
		return ret;
	};
}


function newComponentHook(props, context) {
	propsHook.call(this, props, context);
	this.componentWillReceiveProps = multihook([propsHook, this.componentWillReceiveProps || 'componentWillReceiveProps']);
	this.render = multihook([propsHook, beforeRender, this.render || 'render', afterRender]);
}


function propsHook(props, context) {
	if (!props) { return; }

	// React annoyingly special-cases single children, and some react components are ridiculously strict about this.
	var c = props.children;
	if (c && Array.isArray(c) && c.length===1 && (typeof c[0]==='string' || typeof c[0]==='function' || c[0] instanceof VNode)) {
		props.children = c[0];

		// but its totally still going to be an Array.
		if (props.children && typeof props.children==='object') {
			props.children.length = 1;
			props.children[0] = props.children;
		}
	}

	// add proptype checking
	if (DEV) {
		var ctor = typeof this==='function' ? this : this.constructor,
			propTypes = this.propTypes || ctor.propTypes;
		var displayName = this.displayName || ctor.name;

		if (propTypes) {
			__WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.checkPropTypes(propTypes, props, 'prop', displayName);
		}
	}
}


function beforeRender(props) {
	currentComponent = this;
}

function afterRender() {
	if (currentComponent===this) {
		currentComponent = null;
	}
}



function Component$1(props, context, opts) {
	__WEBPACK_IMPORTED_MODULE_1_preact__["a" /* Component */].call(this, props, context);
	this.state = this.getInitialState ? this.getInitialState() : {};
	this.refs = {};
	this._refProxies = {};
	if (opts!==BYPASS_HOOK) {
		newComponentHook.call(this, props, context);
	}
}
extend(Component$1.prototype = new __WEBPACK_IMPORTED_MODULE_1_preact__["a" /* Component */](), {
	constructor: Component$1,

	isReactComponent: {},

	replaceState: function(state, callback) {
		var this$1 = this;

		this.setState(state, callback);
		for (var i in this$1.state) {
			if (!(i in state)) {
				delete this$1.state[i];
			}
		}
	},

	getDOMNode: function() {
		return this.base;
	},

	isMounted: function() {
		return !!this.base;
	}
});



function PureComponent(props, context) {
	Component$1.call(this, props, context);
}
F.prototype = Component$1.prototype;
PureComponent.prototype = new F();
PureComponent.prototype.isPureReactComponent = true;
PureComponent.prototype.shouldComponentUpdate = function(props, state) {
	return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);
};

var index = {
	version: version,
	DOM: DOM,
	PropTypes: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a,
	Children: Children,
	render: render$1,
	createClass: createClass,
	createFactory: createFactory,
	createElement: createElement,
	cloneElement: cloneElement$1,
	isValidElement: isValidElement,
	findDOMNode: findDOMNode,
	unmountComponentAtNode: unmountComponentAtNode,
	Component: Component$1,
	PureComponent: PureComponent,
	unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer,
	__spread: extend
};

/* harmony default export */ __webpack_exports__["a"] = (index);
//# sourceMappingURL=preact-compat.es.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/preact/dist/preact.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return h; });
/* unused harmony export createElement */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cloneElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return render; });
/* unused harmony export rerender */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return options; });
/** Virtual DOM Node */
function VNode() {}

/** Global options
 *	@public
 *	@namespace options {Object}
 */
var options = {

	/** If `true`, `prop` changes trigger synchronous component updates.
  *	@name syncComponentUpdates
  *	@type Boolean
  *	@default true
  */
	//syncComponentUpdates: true,

	/** Processes all created VNodes.
  *	@param {VNode} vnode	A newly-created VNode to normalize/process
  */
	//vnode(vnode) { }

	/** Hook invoked after a component is mounted. */
	// afterMount(component) { }

	/** Hook invoked after the DOM is updated with a component's latest render. */
	// afterUpdate(component) { }

	/** Hook invoked immediately before a component is unmounted. */
	// beforeUnmount(component) { }
};

var stack = [];

var EMPTY_CHILDREN = [];

/** JSX/hyperscript reviver
*	Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0
 *	@see http://jasonformat.com/wtf-is-jsx
 *	@public
 */
function h(nodeName, attributes) {
	var children = EMPTY_CHILDREN,
	    lastSimple,
	    child,
	    simple,
	    i;
	for (i = arguments.length; i-- > 2;) {
		stack.push(arguments[i]);
	}
	if (attributes && attributes.children != null) {
		if (!stack.length) stack.push(attributes.children);
		delete attributes.children;
	}
	while (stack.length) {
		if ((child = stack.pop()) && child.pop !== undefined) {
			for (i = child.length; i--;) {
				stack.push(child[i]);
			}
		} else {
			if (typeof child === 'boolean') child = null;

			if (simple = typeof nodeName !== 'function') {
				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
			}

			if (simple && lastSimple) {
				children[children.length - 1] += child;
			} else if (children === EMPTY_CHILDREN) {
				children = [child];
			} else {
				children.push(child);
			}

			lastSimple = simple;
		}
	}

	var p = new VNode();
	p.nodeName = nodeName;
	p.children = children;
	p.attributes = attributes == null ? undefined : attributes;
	p.key = attributes == null ? undefined : attributes.key;

	// if a "vnode hook" is defined, pass every created VNode to it
	if (options.vnode !== undefined) options.vnode(p);

	return p;
}

/** Copy own-properties from `props` onto `obj`.
 *	@returns obj
 *	@private
 */
function extend(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }return obj;
}

/** Call a function asynchronously, as soon as possible.
 *	@param {Function} callback
 */
var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

function cloneElement(vnode, props) {
	return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
}

// DOM properties that should NOT have "px" added when numeric
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

/** Managed queue of dirty components to be re-rendered */

var items = [];

function enqueueRender(component) {
	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
		(options.debounceRendering || defer)(rerender);
	}
}

function rerender() {
	var p,
	    list = items;
	items = [];
	while (p = list.pop()) {
		if (p._dirty) renderComponent(p);
	}
}

/** Check if two nodes are equivalent.
 *	@param {Element} node
 *	@param {VNode} vnode
 *	@private
 */
function isSameNodeType(node, vnode, hydrating) {
	if (typeof vnode === 'string' || typeof vnode === 'number') {
		return node.splitText !== undefined;
	}
	if (typeof vnode.nodeName === 'string') {
		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
	}
	return hydrating || node._componentConstructor === vnode.nodeName;
}

/** Check if an Element has a given normalized name.
*	@param {Element} node
*	@param {String} nodeName
 */
function isNamedNode(node, nodeName) {
	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}

/**
 * Reconstruct Component-style `props` from a VNode.
 * Ensures default/fallback values from `defaultProps`:
 * Own-properties of `defaultProps` not present in `vnode.attributes` are added.
 * @param {VNode} vnode
 * @returns {Object} props
 */
function getNodeProps(vnode) {
	var props = extend({}, vnode.attributes);
	props.children = vnode.children;

	var defaultProps = vnode.nodeName.defaultProps;
	if (defaultProps !== undefined) {
		for (var i in defaultProps) {
			if (props[i] === undefined) {
				props[i] = defaultProps[i];
			}
		}
	}

	return props;
}

/** Create an element with the given nodeName.
 *	@param {String} nodeName
 *	@param {Boolean} [isSvg=false]	If `true`, creates an element within the SVG namespace.
 *	@returns {Element} node
 */
function createNode(nodeName, isSvg) {
	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
	node.normalizedNodeName = nodeName;
	return node;
}

/** Remove a child node from its parent if attached.
 *	@param {Element} node		The node to remove
 */
function removeNode(node) {
	var parentNode = node.parentNode;
	if (parentNode) parentNode.removeChild(node);
}

/** Set a named attribute on the given Node, with special behavior for some names and event handlers.
 *	If `value` is `null`, the attribute/handler will be removed.
 *	@param {Element} node	An element to mutate
 *	@param {string} name	The name/key to set, such as an event or attribute name
 *	@param {any} old	The last value that was set for this name/node pair
 *	@param {any} value	An attribute value, such as a function to be used as an event handler
 *	@param {Boolean} isSvg	Are we currently diffing inside an svg?
 *	@private
 */
function setAccessor(node, name, old, value, isSvg) {
	if (name === 'className') name = 'class';

	if (name === 'key') {
		// ignore
	} else if (name === 'ref') {
		if (old) old(null);
		if (value) value(node);
	} else if (name === 'class' && !isSvg) {
		node.className = value || '';
	} else if (name === 'style') {
		if (!value || typeof value === 'string' || typeof old === 'string') {
			node.style.cssText = value || '';
		}
		if (value && typeof value === 'object') {
			if (typeof old !== 'string') {
				for (var i in old) {
					if (!(i in value)) node.style[i] = '';
				}
			}
			for (var i in value) {
				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
			}
		}
	} else if (name === 'dangerouslySetInnerHTML') {
		if (value) node.innerHTML = value.__html || '';
	} else if (name[0] == 'o' && name[1] == 'n') {
		var useCapture = name !== (name = name.replace(/Capture$/, ''));
		name = name.toLowerCase().substring(2);
		if (value) {
			if (!old) node.addEventListener(name, eventProxy, useCapture);
		} else {
			node.removeEventListener(name, eventProxy, useCapture);
		}
		(node._listeners || (node._listeners = {}))[name] = value;
	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
		setProperty(node, name, value == null ? '' : value);
		if (value == null || value === false) node.removeAttribute(name);
	} else {
		var ns = isSvg && name !== (name = name.replace(/^xlink\:?/, ''));
		if (value == null || value === false) {
			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
		} else if (typeof value !== 'function') {
			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
		}
	}
}

/** Attempt to set a DOM property to the given value.
 *	IE & FF throw for certain property-value combinations.
 */
function setProperty(node, name, value) {
	try {
		node[name] = value;
	} catch (e) {}
}

/** Proxy an event to hooked event handlers
 *	@private
 */
function eventProxy(e) {
	return this._listeners[e.type](options.event && options.event(e) || e);
}

/** Queue of components that have been mounted and are awaiting componentDidMount */
var mounts = [];

/** Diff recursion count, used to track the end of the diff cycle. */
var diffLevel = 0;

/** Global flag indicating if the diff is currently within an SVG */
var isSvgMode = false;

/** Global flag indicating if the diff is performing hydration */
var hydrating = false;

/** Invoke queued componentDidMount lifecycle methods */
function flushMounts() {
	var c;
	while (c = mounts.pop()) {
		if (options.afterMount) options.afterMount(c);
		if (c.componentDidMount) c.componentDidMount();
	}
}

/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.
 *	@param {Element} [dom=null]		A DOM node to mutate into the shape of the `vnode`
 *	@param {VNode} vnode			A VNode (with descendants forming a tree) representing the desired DOM structure
 *	@returns {Element} dom			The created/mutated element
 *	@private
 */
function diff(dom, vnode, context, mountAll, parent, componentRoot) {
	// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)
	if (!diffLevel++) {
		// when first starting the diff, check if we're diffing an SVG or within an SVG
		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

		// hydration is indicated by the existing element to be diffed not having a prop cache
		hydrating = dom != null && !('__preactattr_' in dom);
	}

	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

	// append the element if its a new parent
	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

	// diffLevel being reduced to 0 means we're exiting the diff
	if (! --diffLevel) {
		hydrating = false;
		// invoke queued componentDidMount lifecycle methods
		if (!componentRoot) flushMounts();
	}

	return ret;
}

/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */
function idiff(dom, vnode, context, mountAll, componentRoot) {
	var out = dom,
	    prevSvgMode = isSvgMode;

	// empty values (null, undefined, booleans) render as empty Text nodes
	if (vnode == null || typeof vnode === 'boolean') vnode = '';

	// Fast case: Strings & Numbers create/update Text nodes.
	if (typeof vnode === 'string' || typeof vnode === 'number') {

		// update if it's already a Text node:
		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
			/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */
			if (dom.nodeValue != vnode) {
				dom.nodeValue = vnode;
			}
		} else {
			// it wasn't a Text node: replace it with one and recycle the old Element
			out = document.createTextNode(vnode);
			if (dom) {
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
				recollectNodeTree(dom, true);
			}
		}

		out['__preactattr_'] = true;

		return out;
	}

	// If the VNode represents a Component, perform a component diff:
	var vnodeName = vnode.nodeName;
	if (typeof vnodeName === 'function') {
		return buildComponentFromVNode(dom, vnode, context, mountAll);
	}

	// Tracks entering and exiting SVG namespace when descending through the tree.
	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

	// If there's no existing element or it's the wrong type, create a new one:
	vnodeName = String(vnodeName);
	if (!dom || !isNamedNode(dom, vnodeName)) {
		out = createNode(vnodeName, isSvgMode);

		if (dom) {
			// move children into the replacement node
			while (dom.firstChild) {
				out.appendChild(dom.firstChild);
			} // if the previous Element was mounted into the DOM, replace it inline
			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

			// recycle the old element (skips non-Element node types)
			recollectNodeTree(dom, true);
		}
	}

	var fc = out.firstChild,
	    props = out['__preactattr_'],
	    vchildren = vnode.children;

	if (props == null) {
		props = out['__preactattr_'] = {};
		for (var a = out.attributes, i = a.length; i--;) {
			props[a[i].name] = a[i].value;
		}
	}

	// Optimization: fast-path for elements containing a single TextNode:
	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
		if (fc.nodeValue != vchildren[0]) {
			fc.nodeValue = vchildren[0];
		}
	}
	// otherwise, if there are existing or new children, diff them:
	else if (vchildren && vchildren.length || fc != null) {
			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
		}

	// Apply attributes/props from VNode to the DOM Element:
	diffAttributes(out, vnode.attributes, props);

	// restore previous SVG mode: (in case we're exiting an SVG namespace)
	isSvgMode = prevSvgMode;

	return out;
}

/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.
 *	@param {Element} dom			Element whose children should be compared & mutated
 *	@param {Array} vchildren		Array of VNodes to compare to `dom.childNodes`
 *	@param {Object} context			Implicitly descendant context object (from most recent `getChildContext()`)
 *	@param {Boolean} mountAll
 *	@param {Boolean} isHydrating	If `true`, consumes externally created elements similar to hydration
 */
function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
	var originalChildren = dom.childNodes,
	    children = [],
	    keyed = {},
	    keyedLen = 0,
	    min = 0,
	    len = originalChildren.length,
	    childrenLen = 0,
	    vlen = vchildren ? vchildren.length : 0,
	    j,
	    c,
	    f,
	    vchild,
	    child;

	// Build up a map of keyed children and an Array of unkeyed children:
	if (len !== 0) {
		for (var i = 0; i < len; i++) {
			var _child = originalChildren[i],
			    props = _child['__preactattr_'],
			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
			if (key != null) {
				keyedLen++;
				keyed[key] = _child;
			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
				children[childrenLen++] = _child;
			}
		}
	}

	if (vlen !== 0) {
		for (var i = 0; i < vlen; i++) {
			vchild = vchildren[i];
			child = null;

			// attempt to find a node based on key matching
			var key = vchild.key;
			if (key != null) {
				if (keyedLen && keyed[key] !== undefined) {
					child = keyed[key];
					keyed[key] = undefined;
					keyedLen--;
				}
			}
			// attempt to pluck a node of the same type from the existing children
			else if (!child && min < childrenLen) {
					for (j = min; j < childrenLen; j++) {
						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
							child = c;
							children[j] = undefined;
							if (j === childrenLen - 1) childrenLen--;
							if (j === min) min++;
							break;
						}
					}
				}

			// morph the matched/found/created DOM child to match vchild (deep)
			child = idiff(child, vchild, context, mountAll);

			f = originalChildren[i];
			if (child && child !== dom && child !== f) {
				if (f == null) {
					dom.appendChild(child);
				} else if (child === f.nextSibling) {
					removeNode(f);
				} else {
					dom.insertBefore(child, f);
				}
			}
		}
	}

	// remove unused keyed children:
	if (keyedLen) {
		for (var i in keyed) {
			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
		}
	}

	// remove orphaned unkeyed children:
	while (min <= childrenLen) {
		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
	}
}

/** Recursively recycle (or just unmount) a node and its descendants.
 *	@param {Node} node						DOM node to start unmount/removal from
 *	@param {Boolean} [unmountOnly=false]	If `true`, only triggers unmount lifecycle, skips removal
 */
function recollectNodeTree(node, unmountOnly) {
	var component = node._component;
	if (component) {
		// if node is owned by a Component, unmount that component (ends up recursing back here)
		unmountComponent(component);
	} else {
		// If the node's VNode had a ref function, invoke it with null here.
		// (this is part of the React spec, and smart for unsetting references)
		if (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);

		if (unmountOnly === false || node['__preactattr_'] == null) {
			removeNode(node);
		}

		removeChildren(node);
	}
}

/** Recollect/unmount all children.
 *	- we use .lastChild here because it causes less reflow than .firstChild
 *	- it's also cheaper than accessing the .childNodes Live NodeList
 */
function removeChildren(node) {
	node = node.lastChild;
	while (node) {
		var next = node.previousSibling;
		recollectNodeTree(node, true);
		node = next;
	}
}

/** Apply differences in attributes from a VNode to the given DOM Element.
 *	@param {Element} dom		Element with attributes to diff `attrs` against
 *	@param {Object} attrs		The desired end-state key-value attribute pairs
 *	@param {Object} old			Current/previous attributes (from previous VNode or element's prop cache)
 */
function diffAttributes(dom, attrs, old) {
	var name;

	// remove attributes no longer present on the vnode by setting them to undefined
	for (name in old) {
		if (!(attrs && attrs[name] != null) && old[name] != null) {
			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
		}
	}

	// add new & update changed attributes
	for (name in attrs) {
		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
		}
	}
}

/** Retains a pool of Components for re-use, keyed on component name.
 *	Note: since component names are not unique or even necessarily available, these are primarily a form of sharding.
 *	@private
 */
var components = {};

/** Reclaim a component for later re-use by the recycler. */
function collectComponent(component) {
	var name = component.constructor.name;
	(components[name] || (components[name] = [])).push(component);
}

/** Create a component. Normalizes differences between PFC's and classful Components. */
function createComponent(Ctor, props, context) {
	var list = components[Ctor.name],
	    inst;

	if (Ctor.prototype && Ctor.prototype.render) {
		inst = new Ctor(props, context);
		Component.call(inst, props, context);
	} else {
		inst = new Component(props, context);
		inst.constructor = Ctor;
		inst.render = doRender;
	}

	if (list) {
		for (var i = list.length; i--;) {
			if (list[i].constructor === Ctor) {
				inst.nextBase = list[i].nextBase;
				list.splice(i, 1);
				break;
			}
		}
	}
	return inst;
}

/** The `.render()` method for a PFC backing instance. */
function doRender(props, state, context) {
	return this.constructor(props, context);
}

/** Set a component's `props` (generally derived from JSX attributes).
 *	@param {Object} props
 *	@param {Object} [opts]
 *	@param {boolean} [opts.renderSync=false]	If `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.
 *	@param {boolean} [opts.render=true]			If `false`, no render will be triggered.
 */
function setComponentProps(component, props, opts, context, mountAll) {
	if (component._disable) return;
	component._disable = true;

	if (component.__ref = props.ref) delete props.ref;
	if (component.__key = props.key) delete props.key;

	if (!component.base || mountAll) {
		if (component.componentWillMount) component.componentWillMount();
	} else if (component.componentWillReceiveProps) {
		component.componentWillReceiveProps(props, context);
	}

	if (context && context !== component.context) {
		if (!component.prevContext) component.prevContext = component.context;
		component.context = context;
	}

	if (!component.prevProps) component.prevProps = component.props;
	component.props = props;

	component._disable = false;

	if (opts !== 0) {
		if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
			renderComponent(component, 1, mountAll);
		} else {
			enqueueRender(component);
		}
	}

	if (component.__ref) component.__ref(component);
}

/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.
 *	@param {Component} component
 *	@param {Object} [opts]
 *	@param {boolean} [opts.build=false]		If `true`, component will build and store a DOM node if not already associated with one.
 *	@private
 */
function renderComponent(component, opts, mountAll, isChild) {
	if (component._disable) return;

	var props = component.props,
	    state = component.state,
	    context = component.context,
	    previousProps = component.prevProps || props,
	    previousState = component.prevState || state,
	    previousContext = component.prevContext || context,
	    isUpdate = component.base,
	    nextBase = component.nextBase,
	    initialBase = isUpdate || nextBase,
	    initialChildComponent = component._component,
	    skip = false,
	    rendered,
	    inst,
	    cbase;

	// if updating
	if (isUpdate) {
		component.props = previousProps;
		component.state = previousState;
		component.context = previousContext;
		if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
			skip = true;
		} else if (component.componentWillUpdate) {
			component.componentWillUpdate(props, state, context);
		}
		component.props = props;
		component.state = state;
		component.context = context;
	}

	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
	component._dirty = false;

	if (!skip) {
		rendered = component.render(props, state, context);

		// context to pass to the child, can be updated via (grand-)parent component
		if (component.getChildContext) {
			context = extend(extend({}, context), component.getChildContext());
		}

		var childComponent = rendered && rendered.nodeName,
		    toUnmount,
		    base;

		if (typeof childComponent === 'function') {
			// set up high order component link

			var childProps = getNodeProps(rendered);
			inst = initialChildComponent;

			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
				setComponentProps(inst, childProps, 1, context, false);
			} else {
				toUnmount = inst;

				component._component = inst = createComponent(childComponent, childProps, context);
				inst.nextBase = inst.nextBase || nextBase;
				inst._parentComponent = component;
				setComponentProps(inst, childProps, 0, context, false);
				renderComponent(inst, 1, mountAll, true);
			}

			base = inst.base;
		} else {
			cbase = initialBase;

			// destroy high order component link
			toUnmount = initialChildComponent;
			if (toUnmount) {
				cbase = component._component = null;
			}

			if (initialBase || opts === 1) {
				if (cbase) cbase._component = null;
				base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
			}
		}

		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
			var baseParent = initialBase.parentNode;
			if (baseParent && base !== baseParent) {
				baseParent.replaceChild(base, initialBase);

				if (!toUnmount) {
					initialBase._component = null;
					recollectNodeTree(initialBase, false);
				}
			}
		}

		if (toUnmount) {
			unmountComponent(toUnmount);
		}

		component.base = base;
		if (base && !isChild) {
			var componentRef = component,
			    t = component;
			while (t = t._parentComponent) {
				(componentRef = t).base = base;
			}
			base._component = componentRef;
			base._componentConstructor = componentRef.constructor;
		}
	}

	if (!isUpdate || mountAll) {
		mounts.unshift(component);
	} else if (!skip) {
		// Ensure that pending componentDidMount() hooks of child components
		// are called before the componentDidUpdate() hook in the parent.
		// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750
		// flushMounts();

		if (component.componentDidUpdate) {
			component.componentDidUpdate(previousProps, previousState, previousContext);
		}
		if (options.afterUpdate) options.afterUpdate(component);
	}

	if (component._renderCallbacks != null) {
		while (component._renderCallbacks.length) {
			component._renderCallbacks.pop().call(component);
		}
	}

	if (!diffLevel && !isChild) flushMounts();
}

/** Apply the Component referenced by a VNode to the DOM.
 *	@param {Element} dom	The DOM node to mutate
 *	@param {VNode} vnode	A Component-referencing VNode
 *	@returns {Element} dom	The created/mutated element
 *	@private
 */
function buildComponentFromVNode(dom, vnode, context, mountAll) {
	var c = dom && dom._component,
	    originalComponent = c,
	    oldDom = dom,
	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
	    isOwner = isDirectOwner,
	    props = getNodeProps(vnode);
	while (c && !isOwner && (c = c._parentComponent)) {
		isOwner = c.constructor === vnode.nodeName;
	}

	if (c && isOwner && (!mountAll || c._component)) {
		setComponentProps(c, props, 3, context, mountAll);
		dom = c.base;
	} else {
		if (originalComponent && !isDirectOwner) {
			unmountComponent(originalComponent);
			dom = oldDom = null;
		}

		c = createComponent(vnode.nodeName, props, context);
		if (dom && !c.nextBase) {
			c.nextBase = dom;
			// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:
			oldDom = null;
		}
		setComponentProps(c, props, 1, context, mountAll);
		dom = c.base;

		if (oldDom && dom !== oldDom) {
			oldDom._component = null;
			recollectNodeTree(oldDom, false);
		}
	}

	return dom;
}

/** Remove a component from the DOM and recycle it.
 *	@param {Component} component	The Component instance to unmount
 *	@private
 */
function unmountComponent(component) {
	if (options.beforeUnmount) options.beforeUnmount(component);

	var base = component.base;

	component._disable = true;

	if (component.componentWillUnmount) component.componentWillUnmount();

	component.base = null;

	// recursively tear down & recollect high-order component children:
	var inner = component._component;
	if (inner) {
		unmountComponent(inner);
	} else if (base) {
		if (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);

		component.nextBase = base;

		removeNode(base);
		collectComponent(component);

		removeChildren(base);
	}

	if (component.__ref) component.__ref(null);
}

/** Base Component class.
 *	Provides `setState()` and `forceUpdate()`, which trigger rendering.
 *	@public
 *
 *	@example
 *	class MyFoo extends Component {
 *		render(props, state) {
 *			return <div />;
 *		}
 *	}
 */
function Component(props, context) {
	this._dirty = true;

	/** @public
  *	@type {object}
  */
	this.context = context;

	/** @public
  *	@type {object}
  */
	this.props = props;

	/** @public
  *	@type {object}
  */
	this.state = this.state || {};
}

extend(Component.prototype, {

	/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.
  *	@param {object} nextProps
  *	@param {object} nextState
  *	@param {object} nextContext
  *	@returns {Boolean} should the component re-render
  *	@name shouldComponentUpdate
  *	@function
  */

	/** Update component state by copying properties from `state` to `this.state`.
  *	@param {object} state		A hash of state properties to update with new values
  *	@param {function} callback	A function to be called once component state is updated
  */
	setState: function setState(state, callback) {
		var s = this.state;
		if (!this.prevState) this.prevState = extend({}, s);
		extend(s, typeof state === 'function' ? state(s, this.props) : state);
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		enqueueRender(this);
	},


	/** Immediately perform a synchronous re-render of the component.
  *	@param {function} callback		A function to be called after component is re-rendered.
  *	@private
  */
	forceUpdate: function forceUpdate(callback) {
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		renderComponent(this, 2);
	},


	/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
  *	Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
  *	@param {object} props		Props (eg: JSX attributes) received from parent element/component
  *	@param {object} state		The component's current state
  *	@param {object} context		Context object (if a parent component has provided context)
  *	@returns VNode
  */
	render: function render() {}
});

/** Render JSX into a `parent` Element.
 *	@param {VNode} vnode		A (JSX) VNode to render
 *	@param {Element} parent		DOM element to render into
 *	@param {Element} [merge]	Attempt to re-use an existing DOM tree rooted at `merge`
 *	@public
 *
 *	@example
 *	// render a div into <body>:
 *	render(<div id="hello">hello!</div>, document.body);
 *
 *	@example
 *	// render a "Thing" component into #foo:
 *	const Thing = ({ name }) => <span>{ name }</span>;
 *	render(<Thing name="one" />, document.querySelector('#foo'));
 */
function render(vnode, parent, merge) {
  return diff(merge, vnode, {}, false, parent, false);
}

var preact = {
	h: h,
	createElement: h,
	cloneElement: cloneElement,
	Component: Component,
	render: render,
	rerender: rerender,
	options: options
};

/* unused harmony default export */ var _unused_webpack_default_export = (preact);
//# sourceMappingURL=preact.esm.js.map


/***/ }),

/***/ "../../node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/prop-types/factoryWithThrowingShims.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__("../../node_modules/fbjs/lib/emptyFunction.js");
var invariant = __webpack_require__("../../node_modules/fbjs/lib/invariant.js");
var ReactPropTypesSecret = __webpack_require__("../../node_modules/prop-types/lib/ReactPropTypesSecret.js");

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("../../node_modules/prop-types/factoryWithThrowingShims.js")();
}


/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../../node_modules/react-router/node_modules/isarray/index.js":
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../../node_modules/react-router/node_modules/path-to-regexp/index.js":
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__("../../node_modules/react-router/node_modules/isarray/index.js")

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),

/***/ "../../node_modules/resolve-pathname/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsolute = function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
};

// About 1.5x faster than the two-arg version of Array#splice()
var spliceOne = function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }list.pop();
};

// This implementation is based heavily on node's url.parse
var resolvePathname = function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
};

module.exports = resolvePathname;

/***/ }),

/***/ "../../node_modules/style-loader/lib/addStyles.js":
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__("../../node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "../../node_modules/style-loader/lib/urls.js":
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "../../node_modules/svg-inline-loader/index.js?removeTags=true&removeSVGTagAttrs=true!./images/cube.svg":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 23 27\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"MVP\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"><g id=\"linkStatus2\" transform=\"translate(-899.000000, -638.000000)\" fill=\"#1B2437\"><g id=\"Group-6\" transform=\"translate(655.000000, 631.000000)\"><path d=\"M255.452,6.9992 L244,15.8152 L244,24.4682 L255.452,33.2842 L266.904,24.4682 L266.904,15.8152 L255.452,6.9992 Z M259.874,18.1372 L256.224,15.3282 L256.224,9.7032 L264.761,16.2742 L261.261,18.9702 L258.965,20.7392 L258.963,20.7372 L255.452,23.4412 L252.4,21.0922 L251.031,22.1462 L254.679,24.9562 L254.679,30.5812 L246.142,24.0092 L249.796,21.1962 L251.941,19.5442 L251.941,19.5452 L255.452,16.8422 L258.504,19.1912 L259.874,18.1372 Z M248.562,18.1372 L246.142,16.2742 L254.679,9.7032 L254.679,15.3282 L249.796,19.0872 L248.427,20.1412 L248.381,20.1772 L247.652,20.7382 L245.546,22.3592 L245.546,17.9232 L247.193,19.1902 L248.562,18.1372 Z M256.224,24.9562 L261.108,21.1962 L263.081,19.6762 L265.358,17.9232 L265.358,22.3592 L263.711,21.0922 L262.342,22.1462 L264.761,24.0092 L256.224,30.5812 L256.224,24.9562 Z\" id=\"Page-1\"></path></g></g></g></svg>"

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/adsList.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".adsList__self--1COj9 .adsList__row--2eM5f{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.adsList__self--1COj9 .adsList__button--o-Cn8{margin-left:auto}", "", {"version":3,"sources":["/apps/packages/components/src/adsList.scss"],"names":[],"mappings":"AAAA,2CAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,YAAY,CAAC,8CAAc,gBAAgB,CAAC","file":"adsList.scss","sourcesContent":[".self .row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.self .button{margin-left:auto}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "adsList__self--1COj9",
	"row": "adsList__row--2eM5f",
	"button": "adsList__button--o-Cn8"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/button.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".button__self--1HBVs{border:none;outline:none;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#263fff;letter-spacing:.01em}.button__self--1HBVs.button__primary--2mrKv{font-weight:300;color:#fff;font-size:15px;border-radius:3px;padding:13px 25px!important}.button__self--1HBVs.button__secondary--2Imox{float:right;background-color:#cfd9fa;border-radius:50px;color:#263fff;height:20px;width:50px;text-align:center;font-size:12px;font-weight:700;-webkit-box-shadow:0 5px 12px rgba(184,188,206,.5);box-shadow:0 5px 12px rgba(184,188,206,.5)}.button__self--1HBVs.button__secondary--2Imox:disabled{background-color:#89939f;opacity:.4;cursor:not-allowed;color:#fff}.button__self--1HBVs.button__secondary--2Imox:not([disabled]):hover{-webkit-transform:translateY(-2px);transform:translateY(-2px)}.button__self--1HBVs:disabled{background-color:#89939f;opacity:.4;cursor:not-allowed;color:#fff}.button__self--1HBVs:not([disabled]):hover{cursor:pointer;color:#fff;background-color:#263fff;-webkit-box-shadow:0 5px 15px rgba(50,93,255,.45);box-shadow:0 5px 15px rgba(50,93,255,.45);-webkit-transform:translateY(-1px);transform:translateY(-1px)}.button__self--1HBVs:active{background-color:#263fff}", "", {"version":3,"sources":["/apps/packages/components/src/button.scss"],"names":[],"mappings":"AAAA,qBAAM,YAAY,aAAa,oBAAsB,mCAAmC,kCAAkC,yBAAyB,oBAAqB,CAAC,4CAAc,gBAAgB,WAAW,eAAe,kBAAkB,2BAA4B,CAAC,8CAAgB,YAAY,yBAAyB,mBAAmB,cAAc,YAAY,WAAW,kBAAkB,eAAe,gBAAgB,mDAAsD,0CAA6C,CAAC,uDAAyB,yBAAyB,WAAY,mBAAmB,UAAU,CAAC,oEAAsC,mCAAmC,0BAA0B,CAAC,8BAAe,yBAAyB,WAAY,mBAAmB,UAAU,CAAC,2CAA4B,eAAe,WAAW,yBAAyB,kDAAqD,0CAA6C,mCAAmC,0BAA0B,CAAC,4BAAa,wBAAwB,CAAC","file":"button.scss","sourcesContent":[".self{border:none;outline:none;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#263fff;letter-spacing:0.01em}.self.primary{font-weight:300;color:#fff;font-size:15px;border-radius:3px;padding:13px 25px !important}.self.secondary{float:right;background-color:#cfd9fa;border-radius:50px;color:#263fff;height:20px;width:50px;text-align:center;font-size:12px;font-weight:700;-webkit-box-shadow:0px 5px 12px rgba(184,188,206,0.5);box-shadow:0px 5px 12px rgba(184,188,206,0.5)}.self.secondary:disabled{background-color:#89939f;opacity:0.4;cursor:not-allowed;color:#fff}.self.secondary:not([disabled]):hover{-webkit-transform:translateY(-2px);transform:translateY(-2px)}.self:disabled{background-color:#89939f;opacity:0.4;cursor:not-allowed;color:#fff}.self:not([disabled]):hover{cursor:pointer;color:#fff;background-color:#263fff;-webkit-box-shadow:0px 5px 15px rgba(50,93,255,0.45);box-shadow:0px 5px 15px rgba(50,93,255,0.45);-webkit-transform:translateY(-1px);transform:translateY(-1px)}.self:active{background-color:#263fff}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "button__self--1HBVs",
	"primary": "button__primary--2mrKv",
	"secondary": "button__secondary--2Imox"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/icon.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".icon__self--1htNH{font-size:.8em}", "", {"version":3,"sources":["/apps/packages/components/src/icon.scss"],"names":[],"mappings":"AAAA,mBAAM,cAAe,CAAC","file":"icon.scss","sourcesContent":[".self{font-size:0.8em}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "icon__self--1htNH"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/input.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".input__self--Sta6U{position:relative;margin-bottom:20px;margin-top:20px;width:100%;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-transition:none!important;transition:none!important}.input__self--Sta6U .input__input--1h6KM{font-size:15px;padding:10px;width:calc(100% - 30px);background-color:#f5f7fa;border:1px solid #eef1f2;border-radius:3px;-webkit-box-shadow:none;box-shadow:none}.input__self--Sta6U .input__input--1h6KM:focus{outline:none;border:1px solid #263fff;background-color:#fff}.input__self--Sta6U .input__input--1h6KM:-moz-placeholder{box-shadow:none!important}.input__self--Sta6U.input__invalid--3Vmho{margin-bottom:calc(30px - 1em)}.input__self--Sta6U.input__invalid--3Vmho>.input__input--1h6KM{-webkit-box-shadow:0 0 5px 1px red;box-shadow:0 0 5px 1px red}.input__self--Sta6U .input__placeholder--26K8y{position:absolute;top:10px;left:5px;color:#89939f;font-size:15px;-webkit-transition:.2s;transition:.2s}.input__self--Sta6U .input__input--1h6KM:disabled~.input__placeholder--26K8y,.input__self--Sta6U .input__input--1h6KM:focus~.input__placeholder--26K8y,.input__self--Sta6U .input__input--1h6KM:valid~.input__placeholder--26K8y{color:#1b2437;font-size:11px;top:-16px;left:0}.input__self--Sta6U .input__error--3mUo8{color:red;height:1em;font-size:.8em;font-weight:600}", "", {"version":3,"sources":["/apps/packages/components/src/input.scss"],"names":[],"mappings":"AAAA,oBAAM,kBAAkB,mBAAmB,gBAAgB,WAAW,oBAAsB,mCAAmC,kCAAkC,kCAAmC,yBAA0B,CAAC,yCAAa,eAAe,aAAa,wBAAwB,yBAAyB,yBAAyB,kBAAkB,wBAAwB,eAAe,CAAC,+CAAmB,aAAa,yBAAyB,qBAAqB,CAAC,0DAA8B,yBAA0B,CAAC,0CAAc,8BAA8B,CAAC,+DAAqB,mCAAmC,0BAA0B,CAAC,+CAAmB,kBAAkB,SAAS,SAAS,cAAc,eAAe,uBAAwB,cAAe,CAAC,iOAAyG,cAAc,eAAe,UAAU,MAAQ,CAAC,yCAAa,UAAU,WAAW,eAAgB,eAAe,CAAC","file":"input.scss","sourcesContent":[".self{position:relative;margin-bottom:20px;margin-top:20px;width:100%;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-transition:none !important;transition:none !important}.self .input{font-size:15px;padding:10px;width:calc(100% - 30px);background-color:#f5f7fa;border:1px solid #eef1f2;border-radius:3px;-webkit-box-shadow:none;box-shadow:none}.self .input:focus{outline:none;border:1px solid #263fff;background-color:#fff}.self .input:-moz-placeholder{box-shadow:none !important}.self.invalid{margin-bottom:calc(30px - 1em)}.self.invalid>.input{-webkit-box-shadow:0 0 5px 1px red;box-shadow:0 0 5px 1px red}.self .placeholder{position:absolute;top:10px;left:5px;color:#89939f;font-size:15px;-webkit-transition:0.2s;transition:0.2s}.self .input:focus ~ .placeholder,.self .input:valid ~ .placeholder,.self .input:disabled ~ .placeholder{color:#1b2437;font-size:11px;top:-16px;left:0px}.self .error{color:red;height:1em;font-size:0.8em;font-weight:600}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "input__self--Sta6U",
	"input": "input__input--1h6KM",
	"invalid": "input__invalid--3Vmho",
	"placeholder": "input__placeholder--26K8y",
	"error": "input__error--3mUo8"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/label.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".label__self--33pBu{font-size:15px;text-align:left;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#89939f}", "", {"version":3,"sources":["/apps/packages/components/src/label.scss"],"names":[],"mappings":"AAAA,oBAAM,eAAe,gBAAgB,oBAAsB,mCAAmC,kCAAkC,aAAa,CAAC","file":"label.scss","sourcesContent":[".self{font-size:15px;text-align:left;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#89939f}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "label__self--33pBu"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/link.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".link__self--2lLaL{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:75%;font-weight:300}.link__self--2lLaL .link__title--3Whqu{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#263fff;font-weight:700;font-size:1.2em;-ms-flex-negative:0;flex-shrink:0}.link__self--2lLaL .link__header--DbUQP{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.link__self--2lLaL .link__summary--3-V2C{color:#545454}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ{overflow:hidden;position:relative;line-height:1.2em;max-height:2.4em;text-align:justify}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ:before{content:\"...\";position:absolute;right:0;bottom:0;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ:after{content:\"\";position:absolute;right:0;width:1em;height:1em;margin-top:.2em;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8{overflow:hidden;position:relative;line-height:1.2em;max-height:9.6em;text-align:justify}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8:before{content:\"...\";position:absolute;right:0;bottom:0;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8:after{content:\"\";position:absolute;right:0;width:1em;height:1em;margin-top:.2em;background-color:#fff}.link__self--2lLaL .link__footer--3lI90{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.link__self--2lLaL .link__link--2-AZ1{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#006621;font-size:.8em;-ms-flex-negative:0;flex-shrink:0;outline:none}.link__self--2lLaL .link__link--2-AZ1:link,.link__self--2lLaL .link__link--2-AZ1:visited{text-decoration:none}", "", {"version":3,"sources":["/apps/packages/components/src/link.scss"],"names":[],"mappings":"AAAA,mBAAM,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,cAAc,eAAe,CAAC,uCAAa,mBAAmB,gBAAgB,uBAAuB,cAAc,gBAAgB,gBAAgB,oBAAoB,aAAa,CAAC,wCAAc,yBAAyB,sBAAsB,6BAA6B,CAAC,yCAAe,aAAa,CAAC,6DAAsB,gBAAgB,kBAAkB,kBAAkB,iBAAiB,kBAAkB,CAAC,oEAA6B,cAAc,kBAAkB,QAAQ,SAAS,qBAAqB,CAAC,mEAA4B,WAAW,kBAAkB,QAAQ,UAAU,WAAW,gBAAiB,qBAAqB,CAAC,6DAAsB,gBAAgB,kBAAkB,kBAAkB,iBAAiB,kBAAkB,CAAC,oEAA6B,cAAc,kBAAkB,QAAQ,SAAS,qBAAqB,CAAC,mEAA4B,WAAW,kBAAkB,QAAQ,UAAU,WAAW,gBAAiB,qBAAqB,CAAC,wCAAc,sBAAsB,mBAAmB,qBAAqB,yBAAyB,sBAAsB,6BAA6B,CAAC,sCAAY,cAAc,mBAAmB,gBAAgB,uBAAuB,cAAc,eAAgB,oBAAoB,cAAc,YAAY,CAAC,AAAsC,yFAAoB,oBAAoB,CAAC","file":"link.scss","sourcesContent":[".self{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:75%;font-weight:300}.self .title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#263fff;font-weight:700;font-size:1.2em;-ms-flex-negative:0;flex-shrink:0}.self .header{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.self .summary{color:#545454}.self .summary.lines2{overflow:hidden;position:relative;line-height:1.2em;max-height:2.4em;text-align:justify}.self .summary.lines2:before{content:'...';position:absolute;right:0;bottom:0;background-color:#fff}.self .summary.lines2:after{content:'';position:absolute;right:0;width:1em;height:1em;margin-top:0.2em;background-color:#fff}.self .summary.lines8{overflow:hidden;position:relative;line-height:1.2em;max-height:9.6em;text-align:justify}.self .summary.lines8:before{content:'...';position:absolute;right:0;bottom:0;background-color:#fff}.self .summary.lines8:after{content:'';position:absolute;right:0;width:1em;height:1em;margin-top:0.2em;background-color:#fff}.self .footer{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.self .link{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#006621;font-size:0.8em;-ms-flex-negative:0;flex-shrink:0;outline:none}.self .link:link{text-decoration:none}.self .link:visited{text-decoration:none}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "link__self--2lLaL",
	"title": "link__title--3Whqu",
	"header": "link__header--DbUQP",
	"summary": "link__summary--3-V2C",
	"lines2": "link__lines2--IX2SJ",
	"lines8": "link__lines8--3BXj8",
	"footer": "link__footer--3lI90",
	"link": "link__link--2-AZ1"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/linkList.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".linkList__self--Y8QOq .linkList__row--LxprX{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.linkList__self--Y8QOq .linkList__button--elz1X{margin-left:auto}", "", {"version":3,"sources":["/apps/packages/components/src/linkList.scss"],"names":[],"mappings":"AAAA,6CAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,YAAY,CAAC,gDAAc,gBAAgB,CAAC","file":"linkList.scss","sourcesContent":[".self .row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.self .button{margin-left:auto}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "linkList__self--Y8QOq",
	"row": "linkList__row--LxprX",
	"button": "linkList__button--elz1X"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/loader.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".loader__self--2U9as{border:1px solid #eef1f2;border-top:1px solid #263fff;border-radius:50%;width:40px;height:40px;-webkit-animation:loader__spin--1Wsm2 2s linear infinite;animation:loader__spin--1Wsm2 2s linear infinite}@-webkit-keyframes loader__spin--1Wsm2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes loader__spin--1Wsm2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}", "", {"version":3,"sources":["/apps/packages/components/src/loader.scss"],"names":[],"mappings":"AAAA,qBAAM,yBAAyB,6BAA6B,kBAAkB,WAAW,YAAY,yDAA0C,gDAAiC,CAAC,uCAAwB,GAAG,+BAA+B,sBAAsB,CAAC,GAAK,gCAAiC,uBAAwB,CAAC,CAAC,+BAAgB,GAAG,+BAA+B,sBAAsB,CAAC,GAAK,gCAAiC,uBAAwB,CAAC,CAAC","file":"loader.scss","sourcesContent":[".self{border:1px solid #eef1f2;border-top:1px solid #263fff;border-radius:50%;width:40px;height:40px;-webkit-animation:spin 2s linear infinite;animation:spin 2s linear infinite}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "loader__self--2U9as",
	"spin": "loader__spin--1Wsm2"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/paper.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".paper__self--1qtNi{-webkit-box-flex:1;-ms-flex:1;flex:1;background-color:#fff;-webkit-box-shadow:0 5px 20px 0 rgba(19,38,110,.08);box-shadow:0 5px 20px 0 rgba(19,38,110,.08);margin-top:20px;border-radius:3px}", "", {"version":3,"sources":["/apps/packages/components/src/paper.scss"],"names":[],"mappings":"AAAA,oBAAM,mBAAmB,WAAW,OAAO,sBAAsB,oDAAyD,4CAAiD,gBAAgB,iBAAiB,CAAC","file":"paper.scss","sourcesContent":[".self{-webkit-box-flex:1;-ms-flex:1;flex:1;background-color:#fff;-webkit-box-shadow:0px 5px 20px 0px rgba(19,38,110,0.08);box-shadow:0px 5px 20px 0px rgba(19,38,110,0.08);margin-top:20px;border-radius:3px}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "paper__self--1qtNi"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/textWithLabel.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".textWithLabel__self--3SeBK{padding:1em}.textWithLabel__self--3SeBK .textWithLabel__text--2lMFz{margin-top:5px;font-size:15px;color:#1b2437;text-align:left}", "", {"version":3,"sources":["/apps/packages/components/src/textWithLabel.scss"],"names":[],"mappings":"AAAA,4BAAM,WAAW,CAAC,wDAAY,eAAe,eAAe,cAAc,eAAe,CAAC","file":"textWithLabel.scss","sourcesContent":[".self{padding:1em}.self .text{margin-top:5px;font-size:15px;color:#1b2437;text-align:left}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "textWithLabel__self--3SeBK",
	"text": "textWithLabel__text--2lMFz"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/tooltip.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".tooltip__self--2h8p3{position:relative}.tooltip__self--2h8p3 .tooltip__text--1cz4e{visibility:hidden;width:120px;background-color:#1b2437;color:#fff;text-align:center;padding:5px 0;border-radius:6px;position:absolute;-webkit-transition-delay:0s;transition-delay:0s}.tooltip__self--2h8p3:hover .tooltip__text--1cz4e{visibility:visible;-webkit-transition-delay:.5s;transition-delay:.5s}", "", {"version":3,"sources":["/apps/packages/components/src/tooltip.scss"],"names":[],"mappings":"AAAA,sBAAM,iBAAiB,CAAC,4CAAY,kBAAkB,YAAY,yBAAyB,WAAW,kBAAkB,cAAc,kBAAkB,kBAAkB,4BAA4B,mBAAmB,CAAC,kDAAkB,mBAAmB,6BAA8B,oBAAqB,CAAC","file":"tooltip.scss","sourcesContent":[".self{position:relative}.self .text{visibility:hidden;width:120px;background-color:#1b2437;color:#fff;text-align:center;padding:5px 0;border-radius:6px;position:absolute;-webkit-transition-delay:0s;transition-delay:0s}.self:hover .text{visibility:visible;-webkit-transition-delay:0.5s;transition-delay:0.5s}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "tooltip__self--2h8p3",
	"text": "tooltip__text--1cz4e"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/Status.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".Status__self--2jtwo{width:100vw;height:100vh;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}@media screen and (max-width:1200px){.Status__self--2jtwo{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center}}.Status__self--2jtwo .Status__preview--1IUV0{width:300px;height:250px;margin-right:30px;padding:10px;-webkit-box-flex:1;-ms-flex:auto;flex:auto;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:1200px){.Status__self--2jtwo .Status__preview--1IUV0{width:calc(100vw - 20px);height:unset;margin:0;margin-bottom:20px}}.Status__self--2jtwo .Status__loader--2FksP{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.Status__self--2jtwo .Status__content--1RuY7{text-align:center;max-width:40vw;padding:10px}@media screen and (max-width:1200px){.Status__self--2jtwo .Status__content--1RuY7{max-width:calc(100vw - 20px);margin:0}}.Status__self--2jtwo .Status__label--lGQpY{width:100%;padding:0;margin-top:-1em}.Status__self--2jtwo .Status__link-label--2cc5d{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.Status__self--2jtwo .Status__link--2WauU{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.Status__self--2jtwo .Status__add-bookmark--H6_JK{-webkit-box-flex:1;-ms-flex:auto;flex:auto;-ms-flex-negative:0;flex-shrink:0}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Status/Status.scss"],"names":[],"mappings":"AAAA,qBAAM,YAAY,aAAa,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,wBAAwB,qBAAqB,uBAAuB,wBAAwB,qBAAqB,sBAAsB,CAAC,qCAAsC,qBAAM,4BAA4B,6BAA6B,0BAA0B,sBAAsB,uBAAuB,oBAAoB,2BAA2B,yBAAyB,sBAAsB,kBAAkB,CAAC,CAAC,6CAAe,YAAY,aAAa,kBAAkB,aAAa,mBAAmB,cAAc,UAAU,mBAAmB,oBAAoB,YAAY,oBAAoB,cAAc,oBAAoB,oBAAoB,aAAa,yBAAyB,sBAAsB,kBAAkB,CAAC,qCAAsC,6CAAe,yBAAyB,aAAa,SAAS,kBAAkB,CAAC,CAAC,4CAAc,WAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,6CAAe,kBAAkB,eAAe,YAAY,CAAC,qCAAsC,6CAAe,6BAA6B,QAAQ,CAAC,CAAC,2CAAa,WAAW,UAAU,eAAe,CAAC,gDAAkB,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,kBAAkB,CAAC,0CAAY,gBAAgB,uBAAuB,kBAAkB,CAAC,kDAAoB,mBAAmB,cAAc,UAAU,oBAAoB,aAAa,CAAC","file":"Status.scss","sourcesContent":[".self{width:100vw;height:100vh;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}@media screen and (max-width: 1200px){.self{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center}}.self .preview{width:300px;height:250px;margin-right:30px;padding:10px;-webkit-box-flex:1;-ms-flex:auto;flex:auto;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width: 1200px){.self .preview{width:calc(100vw - 20px);height:unset;margin:0;margin-bottom:20px}}.self .loader{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .content{text-align:center;max-width:40vw;padding:10px}@media screen and (max-width: 1200px){.self .content{max-width:calc(100vw - 20px);margin:0}}.self .label{width:100%;padding:0;margin-top:-1em}.self .link-label{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.self .link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.self .add-bookmark{-webkit-box-flex:1;-ms-flex:auto;flex:auto;-ms-flex-negative:0;flex-shrink:0}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "Status__self--2jtwo",
	"preview": "Status__preview--1IUV0",
	"loader": "Status__loader--2FksP",
	"content": "Status__content--1RuY7",
	"label": "Status__label--lGQpY",
	"link-label": "Status__link-label--2cc5d",
	"linkLabel": "Status__link-label--2cc5d",
	"link": "Status__link--2WauU",
	"add-bookmark": "Status__add-bookmark--H6_JK",
	"addBookmark": "Status__add-bookmark--H6_JK"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/components/steps.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".steps__self--3KyHm{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}@media screen and (max-width:1200px){.steps__self--3KyHm{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}}.steps__self--3KyHm .steps__progress-cotainer--1m2lP{position:relative}.steps__self--3KyHm .steps__progress--32faB{position:absolute;left:0;top:20px;z-index:1;width:100%;height:1em;border-radius:1em;background-color:#eef1f2}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__progress--32faB{width:1em;height:100%;top:0;left:20px}}.steps__self--3KyHm .steps__steps-container--1FxNW{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__steps-container--1FxNW{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}}.steps__self--3KyHm .steps__step--3BEfR{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:2;margin-top:calc(20px + .5em - 1.5em)}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__step--3BEfR{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-top:0;margin-left:calc(20px + .5em - 1.5em)}}.steps__self--3KyHm .steps__step--3BEfR.steps__disabled--gVRIq{opacity:.5;cursor:not-allowed}.steps__self--3KyHm .steps__step--3BEfR.steps__waiting--ZH46m{opacity:.5}.steps__self--3KyHm .steps__step--3BEfR.steps__done--2CvMD .steps__icon--2bo5s,.steps__self--3KyHm .steps__step--3BEfR.steps__done--2CvMD path{color:lime;fill:lime}.steps__self--3KyHm .steps__step--3BEfR .steps__icon--2bo5s{-ms-flex-item-align:center;align-self:center;width:3em;height:3em;background-color:#eef1f2;border-radius:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.steps__self--3KyHm .steps__step--3BEfR .steps__content--1aKlz{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__step--3BEfR .steps__content--1aKlz{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding-left:20px}}.steps__self--3KyHm .steps__icon--2bo5s{font-size:1em}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Status/components/steps.scss"],"names":[],"mappings":"AAAA,oBAAM,WAAW,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,qBAAqB,CAAC,qCAAsC,oBAAM,8BAA8B,6BAA6B,uBAAuB,kBAAkB,CAAC,CAAC,qDAAyB,iBAAiB,CAAC,4CAAgB,kBAAkB,OAAO,SAAS,UAAU,WAAW,WAAW,kBAAkB,wBAAwB,CAAC,qCAAsC,4CAAgB,UAAU,YAAY,MAAM,SAAS,CAAC,CAAC,mDAAuB,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,yBAAyB,sBAAsB,6BAA6B,CAAC,qCAAsC,mDAAuB,4BAA4B,6BAA6B,0BAA0B,qBAAqB,CAAC,CAAC,wCAAY,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,UAAU,oCAAqC,CAAC,qCAAsC,wCAAY,8BAA8B,6BAA6B,uBAAuB,mBAAmB,aAAa,qCAAsC,CAAC,CAAC,+DAAqB,WAAY,kBAAkB,CAAC,8DAAoB,UAAW,CAAC,+IAA6C,WAAW,SAAS,CAAC,4DAAkB,2BAA2B,kBAAkB,UAAU,WAAW,yBAAyB,kBAAkB,oBAAoB,oBAAoB,aAAa,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,+DAAqB,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,yBAAyB,sBAAsB,kBAAkB,CAAC,qCAAsC,+DAAqB,wBAAwB,qBAAqB,uBAAuB,iBAAiB,CAAC,CAAC,wCAAY,aAAa,CAAC","file":"steps.scss","sourcesContent":[".self{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}@media screen and (max-width: 1200px){.self{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}}.self .progress-cotainer{position:relative}.self .progress{position:absolute;left:0;top:20px;z-index:1;width:100%;height:1em;border-radius:1em;background-color:#eef1f2}@media screen and (max-width: 1200px){.self .progress{width:1em;height:100%;top:0;left:20px}}.self .steps-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}@media screen and (max-width: 1200px){.self .steps-container{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}}.self .step{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:2;margin-top:calc(20px + 0.5em - 1.5em)}@media screen and (max-width: 1200px){.self .step{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-top:0;margin-left:calc(20px + 0.5em - 1.5em)}}.self .step.disabled{opacity:0.5;cursor:not-allowed}.self .step.waiting{opacity:0.5}.self .step.done .icon,.self .step.done path{color:lime;fill:lime}.self .step .icon{-ms-flex-item-align:center;align-self:center;width:3em;height:3em;background-color:#eef1f2;border-radius:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .step .content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width: 1200px){.self .step .content{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding-left:20px}}.self .icon{font-size:1em}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "steps__self--3KyHm",
	"progress-cotainer": "steps__progress-cotainer--1m2lP",
	"progressCotainer": "steps__progress-cotainer--1m2lP",
	"progress": "steps__progress--32faB",
	"steps-container": "steps__steps-container--1FxNW",
	"stepsContainer": "steps__steps-container--1FxNW",
	"step": "steps__step--3BEfR",
	"disabled": "steps__disabled--gVRIq",
	"waiting": "steps__waiting--ZH46m",
	"done": "steps__done--2CvMD",
	"icon": "steps__icon--2bo5s",
	"content": "steps__content--1aKlz"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Whitelist.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".Whitelist__self--1BkMz{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:10px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.Whitelist__self--1BkMz .Whitelist__paper--2ZCsu{width:70%;padding:10px}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Whitelist.scss"],"names":[],"mappings":"AAAA,wBAAM,WAAW,YAAY,oBAAoB,oBAAoB,aAAa,gBAAgB,4BAA4B,6BAA6B,0BAA0B,sBAAsB,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,iDAAa,UAAU,YAAY,CAAC","file":"Whitelist.scss","sourcesContent":[".self{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:10px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .paper{width:70%;padding:10px}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "Whitelist__self--1BkMz",
	"paper": "Whitelist__paper--2ZCsu"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./styles/all.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=PT+Sans:400,700);", ""]);

// module
exports.push([module.i, "body{font-family:PT Sans,sans-serif}", "", {"version":3,"sources":["/apps/apps/links/styles/all.scss"],"names":[],"mappings":"AAAuE,KAAK,8BAAiC,CAAC","file":"all.scss","sourcesContent":["@import url(\"https://fonts.googleapis.com/css?family=PT+Sans:400,700\");body{font-family:'PT Sans', sans-serif}\n"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "../../node_modules/utf8/utf8.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return utf8;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/module.js")(module), __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/value-equal/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var valueEqual = function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
    return valueEqual(item, b[index]);
  });

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
};

exports.default = valueEqual;

/***/ }),

/***/ "../../node_modules/warning/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (false) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "../../node_modules/web3/index.js":
/***/ (function(module, exports, __webpack_require__) {

var Web3 = __webpack_require__("../../node_modules/web3/lib/web3.js");

// dont override global variable
if (typeof window !== 'undefined' && typeof window.Web3 === 'undefined') {
    window.Web3 = Web3;
}

module.exports = Web3;


/***/ }),

/***/ "../../node_modules/web3/lib/contracts/GlobalRegistrar.json":
/***/ (function(module, exports) {

module.exports = [{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"name","outputs":[{"name":"o_name","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"content","outputs":[{"name":"","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"reserve","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"subRegistrar","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_registrar","type":"address"}],"name":"setSubRegistrar","outputs":[],"type":"function"},{"constant":false,"inputs":[],"name":"Registrar","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_a","type":"address"},{"name":"_primary","type":"bool"}],"name":"setAddress","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_content","type":"bytes32"}],"name":"setContent","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"disown","outputs":[],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_name","type":"bytes32"},{"indexed":false,"name":"_winner","type":"address"}],"name":"AuctionEnded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_name","type":"bytes32"},{"indexed":false,"name":"_bidder","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"NewBid","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"}],"name":"Changed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"},{"indexed":true,"name":"addr","type":"address"}],"name":"PrimaryChanged","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/contracts/ICAPRegistrar.json":
/***/ (function(module, exports) {

module.exports = [{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_refund","type":"address"}],"name":"disown","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"reserve","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_a","type":"address"}],"name":"setAddr","outputs":[],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"}],"name":"Changed","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/contracts/SmartExchange.json":
/***/ (function(module, exports) {

module.exports = [{"constant":false,"inputs":[{"name":"from","type":"bytes32"},{"name":"to","type":"address"},{"name":"value","type":"uint256"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"from","type":"bytes32"},{"name":"to","type":"address"},{"name":"indirectId","type":"bytes32"},{"name":"value","type":"uint256"}],"name":"icapTransfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"to","type":"bytes32"}],"name":"deposit","outputs":[],"payable":true,"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"AnonymousDeposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"bytes32"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"bytes32"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"indirectId","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"IcapTransfer","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/solidity/address.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeAddress is a prootype that represents address type
 * It matches:
 * address
 * address[]
 * address[4]
 * address[][]
 * address[3][]
 * address[][6][], ...
 */
var SolidityTypeAddress = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputAddress;
};

SolidityTypeAddress.prototype = new SolidityType({});
SolidityTypeAddress.prototype.constructor = SolidityTypeAddress;

SolidityTypeAddress.prototype.isType = function (name) {
    return !!name.match(/address(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeAddress;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/bool.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeBool is a prootype that represents bool type
 * It matches:
 * bool
 * bool[]
 * bool[4]
 * bool[][]
 * bool[3][]
 * bool[][6][], ...
 */
var SolidityTypeBool = function () {
    this._inputFormatter = f.formatInputBool;
    this._outputFormatter = f.formatOutputBool;
};

SolidityTypeBool.prototype = new SolidityType({});
SolidityTypeBool.prototype.constructor = SolidityTypeBool;

SolidityTypeBool.prototype.isType = function (name) {
    return !!name.match(/^bool(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBool;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/bytes.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeBytes is a prototype that represents the bytes type.
 * It matches:
 * bytes
 * bytes[]
 * bytes[4]
 * bytes[][]
 * bytes[3][]
 * bytes[][6][], ...
 * bytes32
 * bytes8[4]
 * bytes[3][]
 */
var SolidityTypeBytes = function () {
    this._inputFormatter = f.formatInputBytes;
    this._outputFormatter = f.formatOutputBytes;
};

SolidityTypeBytes.prototype = new SolidityType({});
SolidityTypeBytes.prototype.constructor = SolidityTypeBytes;

SolidityTypeBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes([0-9]{1,})(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBytes;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/coder.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file coder.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");

var SolidityTypeAddress = __webpack_require__("../../node_modules/web3/lib/solidity/address.js");
var SolidityTypeBool = __webpack_require__("../../node_modules/web3/lib/solidity/bool.js");
var SolidityTypeInt = __webpack_require__("../../node_modules/web3/lib/solidity/int.js");
var SolidityTypeUInt = __webpack_require__("../../node_modules/web3/lib/solidity/uint.js");
var SolidityTypeDynamicBytes = __webpack_require__("../../node_modules/web3/lib/solidity/dynamicbytes.js");
var SolidityTypeString = __webpack_require__("../../node_modules/web3/lib/solidity/string.js");
var SolidityTypeReal = __webpack_require__("../../node_modules/web3/lib/solidity/real.js");
var SolidityTypeUReal = __webpack_require__("../../node_modules/web3/lib/solidity/ureal.js");
var SolidityTypeBytes = __webpack_require__("../../node_modules/web3/lib/solidity/bytes.js");

var isDynamic = function (solidityType, type) {
   return solidityType.isDynamicType(type) ||
          solidityType.isDynamicArray(type);
};

/**
 * SolidityCoder prototype should be used to encode/decode solidity params of any type
 */
var SolidityCoder = function (types) {
    this._types = types;
};

/**
 * This method should be used to transform type to SolidityType
 *
 * @method _requireType
 * @param {String} type
 * @returns {SolidityType}
 * @throws {Error} throws if no matching type is found
 */
SolidityCoder.prototype._requireType = function (type) {
    var solidityType = this._types.filter(function (t) {
        return t.isType(type);
    })[0];

    if (!solidityType) {
        throw Error('invalid solidity type!: ' + type);
    }

    return solidityType;
};

/**
 * Should be used to encode plain param
 *
 * @method encodeParam
 * @param {String} type
 * @param {Object} plain param
 * @return {String} encoded plain param
 */
SolidityCoder.prototype.encodeParam = function (type, param) {
    return this.encodeParams([type], [param]);
};

/**
 * Should be used to encode list of params
 *
 * @method encodeParams
 * @param {Array} types
 * @param {Array} params
 * @return {String} encoded list of params
 */
SolidityCoder.prototype.encodeParams = function (types, params) {
    var solidityTypes = this.getSolidityTypes(types);

    var encodeds = solidityTypes.map(function (solidityType, index) {
        return solidityType.encode(params[index], types[index]);
    });

    var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {
        var staticPartLength = solidityType.staticPartLength(types[index]);
        var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;

        return acc + (isDynamic(solidityTypes[index], types[index]) ?
            32 :
            roundedStaticPartLength);
    }, 0);

    var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);

    return result;
};

SolidityCoder.prototype.encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {
    var result = "";
    var self = this;

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            result += f.formatInputInt(dynamicOffset).encode();
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
        } else {
            // don't add length to dynamicOffset. it's already counted
            result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
        }

        // TODO: figure out nested arrays
    });

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
            result += e;
        }
    });
    return result;
};

// TODO: refactor whole encoding!
SolidityCoder.prototype.encodeWithOffset = function (type, solidityType, encoded, offset) {
    var self = this;
    if (solidityType.isDynamicArray(type)) {
        return (function () {
            // offset was already set
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = encoded[0];

            (function () {
                var previousLength = 2; // in int
                if (solidityType.isDynamicArray(nestedName)) {
                    for (var i = 1; i < encoded.length; i++) {
                        previousLength += +(encoded[i - 1])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                }
            })();

            // first element is length, skip it
            (function () {
                for (var i = 0; i < encoded.length - 1; i++) {
                    var additionalOffset = result / 2;
                    result += self.encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset +  additionalOffset);
                }
            })();

            return result;
        })();

    } else if (solidityType.isStaticArray(type)) {
        return (function () {
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = "";


            if (solidityType.isDynamicArray(nestedName)) {
                (function () {
                    var previousLength = 0; // in int
                    for (var i = 0; i < encoded.length; i++) {
                        // calculate length of previous item
                        previousLength += +(encoded[i - 1] || [])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                })();
            }

            (function () {
                for (var i = 0; i < encoded.length; i++) {
                    var additionalOffset = result / 2;
                    result += self.encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);
                }
            })();

            return result;
        })();
    }

    return encoded;
};

/**
 * Should be used to decode bytes to plain param
 *
 * @method decodeParam
 * @param {String} type
 * @param {String} bytes
 * @return {Object} plain param
 */
SolidityCoder.prototype.decodeParam = function (type, bytes) {
    return this.decodeParams([type], bytes)[0];
};

/**
 * Should be used to decode list of params
 *
 * @method decodeParam
 * @param {Array} types
 * @param {String} bytes
 * @return {Array} array of plain params
 */
SolidityCoder.prototype.decodeParams = function (types, bytes) {
    var solidityTypes = this.getSolidityTypes(types);
    var offsets = this.getOffsets(types, solidityTypes);

    return solidityTypes.map(function (solidityType, index) {
        return solidityType.decode(bytes, offsets[index],  types[index], index);
    });
};

SolidityCoder.prototype.getOffsets = function (types, solidityTypes) {
    var lengths =  solidityTypes.map(function (solidityType, index) {
        return solidityType.staticPartLength(types[index]);
    });

    for (var i = 1; i < lengths.length; i++) {
         // sum with length of previous element
        lengths[i] += lengths[i - 1];
    }

    return lengths.map(function (length, index) {
        // remove the current length, so the length is sum of previous elements
        var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
        return length - staticPartLength;
    });
};

SolidityCoder.prototype.getSolidityTypes = function (types) {
    var self = this;
    return types.map(function (type) {
        return self._requireType(type);
    });
};

var coder = new SolidityCoder([
    new SolidityTypeAddress(),
    new SolidityTypeBool(),
    new SolidityTypeInt(),
    new SolidityTypeUInt(),
    new SolidityTypeDynamicBytes(),
    new SolidityTypeBytes(),
    new SolidityTypeString(),
    new SolidityTypeReal(),
    new SolidityTypeUReal()
]);

module.exports = coder;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/dynamicbytes.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

var SolidityTypeDynamicBytes = function () {
    this._inputFormatter = f.formatInputDynamicBytes;
    this._outputFormatter = f.formatOutputDynamicBytes;
};

SolidityTypeDynamicBytes.prototype = new SolidityType({});
SolidityTypeDynamicBytes.prototype.constructor = SolidityTypeDynamicBytes;

SolidityTypeDynamicBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes(\[([0-9]*)\])*$/);
};

SolidityTypeDynamicBytes.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeDynamicBytes;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/formatters.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var SolidityParam = __webpack_require__("../../node_modules/web3/lib/solidity/param.js");


/**
 * Formats input value to byte representation of int
 * If value is negative, return it's two's complement
 * If the value is floating point, round it down
 *
 * @method formatInputInt
 * @param {String|Number|BigNumber} value that needs to be formatted
 * @returns {SolidityParam}
 */
var formatInputInt = function (value) {
    BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
    var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatDynamicInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputDynamicBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of string
 *
 * @method formatInputString
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputString = function (value) {
    var result = utils.fromUtf8(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of bool
 *
 * @method formatInputBool
 * @param {Boolean}
 * @returns {SolidityParam}
 */
var formatInputBool = function (value) {
    var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');
    return new SolidityParam(result);
};

/**
 * Formats input value to byte representation of real
 * Values are multiplied by 2^m and encoded as integers
 *
 * @method formatInputReal
 * @param {String|Number|BigNumber}
 * @returns {SolidityParam}
 */
var formatInputReal = function (value) {
    return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));
};

/**
 * Check if input value is negative
 *
 * @method signedIsNegative
 * @param {String} value is hex format
 * @returns {Boolean} true if it is negative, otherwise false
 */
var signedIsNegative = function (value) {
    return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';
};

/**
 * Formats right-aligned output bytes to int
 *
 * @method formatOutputInt
 * @param {SolidityParam} param
 * @returns {BigNumber} right-aligned output bytes formatted to big number
 */
var formatOutputInt = function (param) {
    var value = param.staticPart() || "0";

    // check if it's negative number
    // it it is, return two's complement
    if (signedIsNegative(value)) {
        return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);
    }
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to uint
 *
 * @method formatOutputUInt
 * @param {SolidityParam}
 * @returns {BigNumeber} right-aligned output bytes formatted to uint
 */
var formatOutputUInt = function (param) {
    var value = param.staticPart() || "0";
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to real
 *
 * @method formatOutputReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to real
 */
var formatOutputReal = function (param) {
    return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Formats right-aligned output bytes to ureal
 *
 * @method formatOutputUReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to ureal
 */
var formatOutputUReal = function (param) {
    return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Should be used to format output bool
 *
 * @method formatOutputBool
 * @param {SolidityParam}
 * @returns {Boolean} right-aligned input bytes formatted to bool
 */
var formatOutputBool = function (param) {
    return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @param {String} name type name
 * @returns {String} hex string
 */
var formatOutputBytes = function (param, name) {
    var matches = name.match(/^bytes([0-9]*)/);
    var size = parseInt(matches[1]);
    return '0x' + param.staticPart().slice(0, 2 * size);
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputDynamicBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} hex string
 */
var formatOutputDynamicBytes = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return '0x' + param.dynamicPart().substr(64, length);
};

/**
 * Should be used to format output string
 *
 * @method formatOutputString
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} ascii string
 */
var formatOutputString = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return utils.toUtf8(param.dynamicPart().substr(64, length));
};

/**
 * Should be used to format output address
 *
 * @method formatOutputAddress
 * @param {SolidityParam} right-aligned input bytes
 * @returns {String} address
 */
var formatOutputAddress = function (param) {
    var value = param.staticPart();
    return "0x" + value.slice(value.length - 40, value.length);
};

module.exports = {
    formatInputInt: formatInputInt,
    formatInputBytes: formatInputBytes,
    formatInputDynamicBytes: formatInputDynamicBytes,
    formatInputString: formatInputString,
    formatInputBool: formatInputBool,
    formatInputReal: formatInputReal,
    formatOutputInt: formatOutputInt,
    formatOutputUInt: formatOutputUInt,
    formatOutputReal: formatOutputReal,
    formatOutputUReal: formatOutputUReal,
    formatOutputBool: formatOutputBool,
    formatOutputBytes: formatOutputBytes,
    formatOutputDynamicBytes: formatOutputDynamicBytes,
    formatOutputString: formatOutputString,
    formatOutputAddress: formatOutputAddress
};


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/int.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeInt is a prootype that represents int type
 * It matches:
 * int
 * int[]
 * int[4]
 * int[][]
 * int[3][]
 * int[][6][], ...
 * int32
 * int64[]
 * int8[4]
 * int256[][]
 * int[3][]
 * int64[][6][], ...
 */
var SolidityTypeInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputInt;
};

SolidityTypeInt.prototype = new SolidityType({});
SolidityTypeInt.prototype.constructor = SolidityTypeInt;

SolidityTypeInt.prototype.isType = function (name) {
    return !!name.match(/^int([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeInt;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/param.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file param.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

/**
 * SolidityParam object prototype.
 * Should be used when encoding, decoding solidity bytes
 */
var SolidityParam = function (value, offset) {
    this.value = value || '';
    this.offset = offset; // offset in bytes
};

/**
 * This method should be used to get length of params's dynamic part
 * 
 * @method dynamicPartLength
 * @returns {Number} length of dynamic part (in bytes)
 */
SolidityParam.prototype.dynamicPartLength = function () {
    return this.dynamicPart().length / 2;
};

/**
 * This method should be used to create copy of solidity param with different offset
 *
 * @method withOffset
 * @param {Number} offset length in bytes
 * @returns {SolidityParam} new solidity param with applied offset
 */
SolidityParam.prototype.withOffset = function (offset) {
    return new SolidityParam(this.value, offset);
};

/**
 * This method should be used to combine solidity params together
 * eg. when appending an array
 *
 * @method combine
 * @param {SolidityParam} param with which we should combine
 * @param {SolidityParam} result of combination
 */
SolidityParam.prototype.combine = function (param) {
    return new SolidityParam(this.value + param.value); 
};

/**
 * This method should be called to check if param has dynamic size.
 * If it has, it returns true, otherwise false
 *
 * @method isDynamic
 * @returns {Boolean}
 */
SolidityParam.prototype.isDynamic = function () {
    return this.offset !== undefined;
};

/**
 * This method should be called to transform offset to bytes
 *
 * @method offsetAsBytes
 * @returns {String} bytes representation of offset
 */
SolidityParam.prototype.offsetAsBytes = function () {
    return !this.isDynamic() ? '' : utils.padLeft(utils.toTwosComplement(this.offset).toString(16), 64);
};

/**
 * This method should be called to get static part of param
 *
 * @method staticPart
 * @returns {String} offset if it is a dynamic param, otherwise value
 */
SolidityParam.prototype.staticPart = function () {
    if (!this.isDynamic()) {
        return this.value; 
    } 
    return this.offsetAsBytes();
};

/**
 * This method should be called to get dynamic part of param
 *
 * @method dynamicPart
 * @returns {String} returns a value if it is a dynamic param, otherwise empty string
 */
SolidityParam.prototype.dynamicPart = function () {
    return this.isDynamic() ? this.value : '';
};

/**
 * This method should be called to encode param
 *
 * @method encode
 * @returns {String}
 */
SolidityParam.prototype.encode = function () {
    return this.staticPart() + this.dynamicPart();
};

/**
 * This method should be called to encode array of params
 *
 * @method encodeList
 * @param {Array[SolidityParam]} params
 * @returns {String}
 */
SolidityParam.encodeList = function (params) {
    
    // updating offsets
    var totalOffset = params.length * 32;
    var offsetParams = params.map(function (param) {
        if (!param.isDynamic()) {
            return param;
        }
        var offset = totalOffset;
        totalOffset += param.dynamicPartLength();
        return param.withOffset(offset);
    });

    // encode everything!
    return offsetParams.reduce(function (result, param) {
        return result + param.dynamicPart();
    }, offsetParams.reduce(function (result, param) {
        return result + param.staticPart();
    }, ''));
};



module.exports = SolidityParam;



/***/ }),

/***/ "../../node_modules/web3/lib/solidity/real.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeReal is a prootype that represents real type
 * It matches:
 * real
 * real[]
 * real[4]
 * real[][]
 * real[3][]
 * real[][6][], ...
 * real32
 * real64[]
 * real8[4]
 * real256[][]
 * real[3][]
 * real64[][6][], ...
 */
var SolidityTypeReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputReal;
};

SolidityTypeReal.prototype = new SolidityType({});
SolidityTypeReal.prototype.constructor = SolidityTypeReal;

SolidityTypeReal.prototype.isType = function (name) {
    return !!name.match(/real([0-9]*)?(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeReal;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/string.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

var SolidityTypeString = function () {
    this._inputFormatter = f.formatInputString;
    this._outputFormatter = f.formatOutputString;
};

SolidityTypeString.prototype = new SolidityType({});
SolidityTypeString.prototype.constructor = SolidityTypeString;

SolidityTypeString.prototype.isType = function (name) {
    return !!name.match(/^string(\[([0-9]*)\])*$/);
};

SolidityTypeString.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeString;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/type.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityParam = __webpack_require__("../../node_modules/web3/lib/solidity/param.js");

/**
 * SolidityType prototype is used to encode/decode solidity params of certain type
 */
var SolidityType = function (config) {
    this._inputFormatter = config.inputFormatter;
    this._outputFormatter = config.outputFormatter;
};

/**
 * Should be used to determine if this SolidityType do match given name
 *
 * @method isType
 * @param {String} name
 * @return {Bool} true if type match this SolidityType, otherwise false
 */
SolidityType.prototype.isType = function (name) {
    throw "this method should be overrwritten for type " + name;
};

/**
 * Should be used to determine what is the length of static part in given type
 *
 * @method staticPartLength
 * @param {String} name
 * @return {Number} length of static part in bytes
 */
SolidityType.prototype.staticPartLength = function (name) {
    // If name isn't an array then treat it like a single element array.
    return (this.nestedTypes(name) || ['[1]'])
        .map(function (type) {
            // the length of the nested array
            return parseInt(type.slice(1, -1), 10) || 1;
        })
        .reduce(function (previous, current) {
            return previous * current;
        // all basic types are 32 bytes long
        }, 32);
};

/**
 * Should be used to determine if type is dynamic array
 * eg:
 * "type[]" => true
 * "type[4]" => false
 *
 * @method isDynamicArray
 * @param {String} name
 * @return {Bool} true if the type is dynamic array
 */
SolidityType.prototype.isDynamicArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should be used to determine if type is static array
 * eg:
 * "type[]" => false
 * "type[4]" => true
 *
 * @method isStaticArray
 * @param {String} name
 * @return {Bool} true if the type is static array
 */
SolidityType.prototype.isStaticArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should return length of static array
 * eg.
 * "int[32]" => 32
 * "int256[14]" => 14
 * "int[2][3]" => 3
 * "int" => 1
 * "int[1]" => 1
 * "int[]" => 1
 *
 * @method staticArrayLength
 * @param {String} name
 * @return {Number} static array length
 */
SolidityType.prototype.staticArrayLength = function (name) {
    var nestedTypes = this.nestedTypes(name);
    if (nestedTypes) {
       return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);
    }
    return 1;
};

/**
 * Should return nested type
 * eg.
 * "int[32]" => "int"
 * "int256[14]" => "int256"
 * "int[2][3]" => "int[2]"
 * "int" => "int"
 * "int[]" => "int"
 *
 * @method nestedName
 * @param {String} name
 * @return {String} nested name
 */
SolidityType.prototype.nestedName = function (name) {
    // remove last [] in name
    var nestedTypes = this.nestedTypes(name);
    if (!nestedTypes) {
        return name;
    }

    return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);
};

/**
 * Should return true if type has dynamic size by default
 * such types are "string", "bytes"
 *
 * @method isDynamicType
 * @param {String} name
 * @return {Bool} true if is dynamic, otherwise false
 */
SolidityType.prototype.isDynamicType = function () {
    return false;
};

/**
 * Should return array of nested types
 * eg.
 * "int[2][3][]" => ["[2]", "[3]", "[]"]
 * "int[] => ["[]"]
 * "int" => null
 *
 * @method nestedTypes
 * @param {String} name
 * @return {Array} array of nested types
 */
SolidityType.prototype.nestedTypes = function (name) {
    // return list of strings eg. "[]", "[3]", "[]", "[2]"
    return name.match(/(\[[0-9]*\])/g);
};

/**
 * Should be used to encode the value
 *
 * @method encode
 * @param {Object} value
 * @param {String} name
 * @return {String} encoded value
 */
SolidityType.prototype.encode = function (value, name) {
    var self = this;
    if (this.isDynamicArray(name)) {

        return (function () {
            var length = value.length;                          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            result.push(f.formatInputInt(length).encode());

            value.forEach(function (v) {
                result.push(self.encode(v, nestedName));
            });

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            for (var i = 0; i < length; i++) {
                result.push(self.encode(value[i], nestedName));
            }

            return result;
        })();

    }

    return this._inputFormatter(value, name).encode();
};

/**
 * Should be used to decode value from bytes
 *
 * @method decode
 * @param {String} bytes
 * @param {Number} offset in bytes
 * @param {String} name type name
 * @returns {Object} decoded value
 */
SolidityType.prototype.decode = function (bytes, offset, name) {
    var self = this;

    if (this.isDynamicArray(name)) {

        return (function () {
            var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes
            var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int
            var arrayStart = arrayOffset + 32; // array starts after length; // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);                      // in int
            var arrayStart = offset;                                        // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();
    } else if (this.isDynamicType(name)) {

        return (function () {
            var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes
            var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes
            var roundedLength = Math.floor((length + 31) / 32);                     // in int
            var param = new SolidityParam(bytes.substr(dynamicOffset * 2, ( 1 + roundedLength) * 64), 0);
            return self._outputFormatter(param, name);
        })();
    }

    var length = this.staticPartLength(name);
    var param = new SolidityParam(bytes.substr(offset * 2, length * 2));
    return this._outputFormatter(param, name);
};

module.exports = SolidityType;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/uint.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeUInt is a prootype that represents uint type
 * It matches:
 * uint
 * uint[]
 * uint[4]
 * uint[][]
 * uint[3][]
 * uint[][6][], ...
 * uint32
 * uint64[]
 * uint8[4]
 * uint256[][]
 * uint[3][]
 * uint64[][6][], ...
 */
var SolidityTypeUInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputUInt;
};

SolidityTypeUInt.prototype = new SolidityType({});
SolidityTypeUInt.prototype.constructor = SolidityTypeUInt;

SolidityTypeUInt.prototype.isType = function (name) {
    return !!name.match(/^uint([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUInt;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/ureal.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeUReal is a prootype that represents ureal type
 * It matches:
 * ureal
 * ureal[]
 * ureal[4]
 * ureal[][]
 * ureal[3][]
 * ureal[][6][], ...
 * ureal32
 * ureal64[]
 * ureal8[4]
 * ureal256[][]
 * ureal[3][]
 * ureal64[][6][], ...
 */
var SolidityTypeUReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputUReal;
};

SolidityTypeUReal.prototype = new SolidityType({});
SolidityTypeUReal.prototype.constructor = SolidityTypeUReal;

SolidityTypeUReal.prototype.isType = function (name) {
    return !!name.match(/^ureal([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUReal;


/***/ }),

/***/ "../../node_modules/web3/lib/utils/browser-xhr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// go env doesn't have and need XMLHttpRequest
if (typeof XMLHttpRequest === 'undefined') {
    exports.XMLHttpRequest = {};
} else {
    exports.XMLHttpRequest = XMLHttpRequest; // jshint ignore:line
}



/***/ }),

/***/ "../../node_modules/web3/lib/utils/config.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file config.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 * 
 * @module utils
 */

/**
 * Utility functions
 * 
 * @class [utils] config
 * @constructor
 */


/// required to define ETH_BIGNUMBER_ROUNDING_MODE
var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");

var ETH_UNITS = [
    'wei',
    'kwei',
    'Mwei',
    'Gwei',
    'szabo',
    'finney',
    'femtoether',
    'picoether',
    'nanoether',
    'microether',
    'milliether',
    'nano',
    'micro',
    'milli',
    'ether',
    'grand',
    'Mether',
    'Gether',
    'Tether',
    'Pether',
    'Eether',
    'Zether',
    'Yether',
    'Nether',
    'Dether',
    'Vether',
    'Uether'
];

module.exports = {
    ETH_PADDING: 32,
    ETH_SIGNATURE_LENGTH: 4,
    ETH_UNITS: ETH_UNITS,
    ETH_BIGNUMBER_ROUNDING_MODE: { ROUNDING_MODE: BigNumber.ROUND_DOWN },
    ETH_POLLING_TIMEOUT: 1000/2,
    defaultBlock: 'latest',
    defaultAccount: undefined
};



/***/ }),

/***/ "../../node_modules/web3/lib/utils/sha3.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file sha3.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var CryptoJS = __webpack_require__("../../node_modules/crypto-js/index.js");
var sha3 = __webpack_require__("../../node_modules/crypto-js/sha3.js");

module.exports = function (value, options) {
    if (options && options.encoding === 'hex') {
        if (value.length > 2 && value.substr(0, 2) === '0x') {
            value = value.substr(2);
        }
        value = CryptoJS.enc.Hex.parse(value);
    }

    return sha3(value, {
        outputLength: 256
    }).toString();
};



/***/ }),

/***/ "../../node_modules/web3/lib/utils/utils.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file utils.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 *
 * @module utils
 */

/**
 * Utility functions
 *
 * @class [utils] utils
 * @constructor
 */


var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var utf8 = __webpack_require__("../../node_modules/utf8/utf8.js");

var unitMap = {
    'noether':      '0',
    'wei':          '1',
    'kwei':         '1000',
    'Kwei':         '1000',
    'babbage':      '1000',
    'femtoether':   '1000',
    'mwei':         '1000000',
    'Mwei':         '1000000',
    'lovelace':     '1000000',
    'picoether':    '1000000',
    'gwei':         '1000000000',
    'Gwei':         '1000000000',
    'shannon':      '1000000000',
    'nanoether':    '1000000000',
    'nano':         '1000000000',
    'szabo':        '1000000000000',
    'microether':   '1000000000000',
    'micro':        '1000000000000',
    'finney':       '1000000000000000',
    'milliether':    '1000000000000000',
    'milli':         '1000000000000000',
    'ether':        '1000000000000000000',
    'kether':       '1000000000000000000000',
    'grand':        '1000000000000000000000',
    'mether':       '1000000000000000000000000',
    'gether':       '1000000000000000000000000000',
    'tether':       '1000000000000000000000000000000'
};

/**
 * Should be called to pad string to expected length
 *
 * @method padLeft
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padLeft = function (string, chars, sign) {
    return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
};

/**
 * Should be called to pad string to expected length
 *
 * @method padRight
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padRight = function (string, chars, sign) {
    return string + (new Array(chars - string.length + 1).join(sign ? sign : "0"));
};

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toUtf8 = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        if (code === 0)
            break;
        str += String.fromCharCode(code);
    }

    return utf8.decode(str);
};

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toAscii = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
    }

    return str;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromUtf8 = function(str) {
    str = utf8.encode(str);
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (code === 0)
            break;
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return "0x" + hex;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromAscii = function(str) {
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return "0x" + hex;
};

/**
 * Should be used to create full function/event name from json abi
 *
 * @method transformToFullName
 * @param {Object} json-abi
 * @return {String} full fnction/event name
 */
var transformToFullName = function (json) {
    if (json.name.indexOf('(') !== -1) {
        return json.name;
    }

    var typeName = json.inputs.map(function(i){return i.type; }).join();
    return json.name + '(' + typeName + ')';
};

/**
 * Should be called to get display name of contract function
 *
 * @method extractDisplayName
 * @param {String} name of function/event
 * @returns {String} display name for function/event eg. multiply(uint256) -> multiply
 */
var extractDisplayName = function (name) {
    var length = name.indexOf('(');
    return length !== -1 ? name.substr(0, length) : name;
};

/// @returns overloaded part of function/event name
var extractTypeName = function (name) {
    /// TODO: make it invulnerable
    var length = name.indexOf('(');
    return length !== -1 ? name.substr(length + 1, name.length - 1 - (length + 1)).replace(' ', '') : "";
};

/**
 * Converts value to it's decimal representation in string
 *
 * @method toDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var toDecimal = function (value) {
    return toBigNumber(value).toNumber();
};

/**
 * Converts value to it's hex representation
 *
 * @method fromDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var fromDecimal = function (value) {
    var number = toBigNumber(value);
    var result = number.toString(16);

    return number.lessThan(0) ? '-0x' + result.substr(1) : '0x' + result;
};

/**
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 *
 * @method toHex
 * @param {String|Number|BigNumber|Object}
 * @return {String}
 */
var toHex = function (val) {
    /*jshint maxcomplexity: 8 */

    if (isBoolean(val))
        return fromDecimal(+val);

    if (isBigNumber(val))
        return fromDecimal(val);

    if (typeof val === 'object')
        return fromUtf8(JSON.stringify(val));

    // if its a negative number, pass it through fromDecimal
    if (isString(val)) {
        if (val.indexOf('-0x') === 0)
            return fromDecimal(val);
        else if(val.indexOf('0x') === 0)
            return val;
        else if (!isFinite(val))
            return fromAscii(val);
    }

    return fromDecimal(val);
};

/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
var getValueOfUnit = function (unit) {
    unit = unit ? unit.toLowerCase() : 'ether';
    var unitValue = unitMap[unit];
    if (unitValue === undefined) {
        throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
    }
    return new BigNumber(unitValue, 10);
};

/**
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method fromWei
 * @param {Number|String} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert to, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var fromWei = function(number, unit) {
    var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method toWei
 * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert from, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var toWei = function(number, unit) {
    var returnValue = toBigNumber(number).times(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes an input and transforms it into an bignumber
 *
 * @method toBigNumber
 * @param {Number|String|BigNumber} a number, string, HEX string or BigNumber
 * @return {BigNumber} BigNumber
*/
var toBigNumber = function(number) {
    /*jshint maxcomplexity:5 */
    number = number || 0;
    if (isBigNumber(number))
        return number;

    if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {
        return new BigNumber(number.replace('0x',''), 16);
    }

    return new BigNumber(number.toString(10), 10);
};

/**
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 *
 * @method toTwosComplement
 * @param {Number|String|BigNumber}
 * @return {BigNumber}
 */
var toTwosComplement = function (number) {
    var bigNumber = toBigNumber(number).round();
    if (bigNumber.lessThan(0)) {
        return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
    }
    return bigNumber;
};

/**
 * Checks if the given string is strictly an address
 *
 * @method isStrictAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isStrictAddress = function (address) {
    return /^0x[0-9a-f]{40}$/i.test(address);
};

/**
 * Checks if the given string is an address
 *
 * @method isAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isAddress = function (address) {
    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        // check if it has the basic requirements of an address
        return false;
    } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        // If it's all small caps or all all caps, return true
        return true;
    } else {
        // Otherwise check each case
        return isChecksumAddress(address);
    }
};

/**
 * Checks if the given string is a checksummed address
 *
 * @method isChecksumAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isChecksumAddress = function (address) {
    // Check each case
    address = address.replace('0x','');
    var addressHash = sha3(address.toLowerCase());

    for (var i = 0; i < 40; i++ ) {
        // the nth letter should be uppercase if the nth digit of casemap is 1
        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
            return false;
        }
    }
    return true;
};



/**
 * Makes a checksum address
 *
 * @method toChecksumAddress
 * @param {String} address the given HEX adress
 * @return {String}
*/
var toChecksumAddress = function (address) {
    if (typeof address === 'undefined') return '';

    address = address.toLowerCase().replace('0x','');
    var addressHash = sha3(address);
    var checksumAddress = '0x';

    for (var i = 0; i < address.length; i++ ) {
        // If ith character is 9 to f then make it uppercase
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
};

/**
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 *
 * @method toAddress
 * @param {String} address
 * @return {String} formatted address
 */
var toAddress = function (address) {
    if (isStrictAddress(address)) {
        return address;
    }

    if (/^[0-9a-f]{40}$/.test(address)) {
        return '0x' + address;
    }

    return '0x' + padLeft(toHex(address).substr(2), 40);
};

/**
 * Returns true if object is BigNumber, otherwise false
 *
 * @method isBigNumber
 * @param {Object}
 * @return {Boolean}
 */
var isBigNumber = function (object) {
    return object instanceof BigNumber ||
        (object && object.constructor && object.constructor.name === 'BigNumber');
};

/**
 * Returns true if object is string, otherwise false
 *
 * @method isString
 * @param {Object}
 * @return {Boolean}
 */
var isString = function (object) {
    return typeof object === 'string' ||
        (object && object.constructor && object.constructor.name === 'String');
};

/**
 * Returns true if object is function, otherwise false
 *
 * @method isFunction
 * @param {Object}
 * @return {Boolean}
 */
var isFunction = function (object) {
    return typeof object === 'function';
};

/**
 * Returns true if object is Objet, otherwise false
 *
 * @method isObject
 * @param {Object}
 * @return {Boolean}
 */
var isObject = function (object) {
    return object !== null && !(object instanceof Array) && typeof object === 'object';
};

/**
 * Returns true if object is boolean, otherwise false
 *
 * @method isBoolean
 * @param {Object}
 * @return {Boolean}
 */
var isBoolean = function (object) {
    return typeof object === 'boolean';
};

/**
 * Returns true if object is array, otherwise false
 *
 * @method isArray
 * @param {Object}
 * @return {Boolean}
 */
var isArray = function (object) {
    return object instanceof Array;
};

/**
 * Returns true if given string is valid json object
 *
 * @method isJson
 * @param {String}
 * @return {Boolean}
 */
var isJson = function (str) {
    try {
        return !!JSON.parse(str);
    } catch (e) {
        return false;
    }
};

/**
 * Returns true if given string is a valid Ethereum block header bloom.
 *
 * @method isBloom
 * @param {String} hex encoded bloom filter
 * @return {Boolean}
 */
var isBloom = function (bloom) {
    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
    }
    return false;
};

/**
 * Returns true if given string is a valid log topic.
 *
 * @method isTopic
 * @param {String} hex encoded topic
 * @return {Boolean}
 */
var isTopic = function (topic) {
    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
    }
    return false;
};

module.exports = {
    padLeft: padLeft,
    padRight: padRight,
    toHex: toHex,
    toDecimal: toDecimal,
    fromDecimal: fromDecimal,
    toUtf8: toUtf8,
    toAscii: toAscii,
    fromUtf8: fromUtf8,
    fromAscii: fromAscii,
    transformToFullName: transformToFullName,
    extractDisplayName: extractDisplayName,
    extractTypeName: extractTypeName,
    toWei: toWei,
    fromWei: fromWei,
    toBigNumber: toBigNumber,
    toTwosComplement: toTwosComplement,
    toAddress: toAddress,
    isBigNumber: isBigNumber,
    isStrictAddress: isStrictAddress,
    isAddress: isAddress,
    isChecksumAddress: isChecksumAddress,
    toChecksumAddress: toChecksumAddress,
    isFunction: isFunction,
    isString: isString,
    isObject: isObject,
    isBoolean: isBoolean,
    isArray: isArray,
    isJson: isJson,
    isBloom: isBloom,
    isTopic: isTopic,
};


/***/ }),

/***/ "../../node_modules/web3/lib/version.json":
/***/ (function(module, exports) {

module.exports = {"version":"0.20.1"}

/***/ }),

/***/ "../../node_modules/web3/lib/web3.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file web3.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var RequestManager = __webpack_require__("../../node_modules/web3/lib/web3/requestmanager.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var Eth = __webpack_require__("../../node_modules/web3/lib/web3/methods/eth.js");
var DB = __webpack_require__("../../node_modules/web3/lib/web3/methods/db.js");
var Shh = __webpack_require__("../../node_modules/web3/lib/web3/methods/shh.js");
var Net = __webpack_require__("../../node_modules/web3/lib/web3/methods/net.js");
var Personal = __webpack_require__("../../node_modules/web3/lib/web3/methods/personal.js");
var Swarm = __webpack_require__("../../node_modules/web3/lib/web3/methods/swarm.js");
var Settings = __webpack_require__("../../node_modules/web3/lib/web3/settings.js");
var version = __webpack_require__("../../node_modules/web3/lib/version.json");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var extend = __webpack_require__("../../node_modules/web3/lib/web3/extend.js");
var Batch = __webpack_require__("../../node_modules/web3/lib/web3/batch.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var HttpProvider = __webpack_require__("../../node_modules/web3/lib/web3/httpprovider.js");
var IpcProvider = __webpack_require__("../../node_modules/web3/lib/web3/ipcprovider.js");
var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");



function Web3 (provider) {
    this._requestManager = new RequestManager(provider);
    this.currentProvider = provider;
    this.eth = new Eth(this);
    this.db = new DB(this);
    this.shh = new Shh(this);
    this.net = new Net(this);
    this.personal = new Personal(this);
    this.bzz = new Swarm(this);
    this.settings = new Settings();
    this.version = {
        api: version.version
    };
    this.providers = {
        HttpProvider: HttpProvider,
        IpcProvider: IpcProvider
    };
    this._extend = extend(this);
    this._extend({
        properties: properties()
    });
}

// expose providers on the class
Web3.providers = {
    HttpProvider: HttpProvider,
    IpcProvider: IpcProvider
};

Web3.prototype.setProvider = function (provider) {
    this._requestManager.setProvider(provider);
    this.currentProvider = provider;
};

Web3.prototype.reset = function (keepIsSyncing) {
    this._requestManager.reset(keepIsSyncing);
    this.settings = new Settings();
};

Web3.prototype.BigNumber = BigNumber;
Web3.prototype.toHex = utils.toHex;
Web3.prototype.toAscii = utils.toAscii;
Web3.prototype.toUtf8 = utils.toUtf8;
Web3.prototype.fromAscii = utils.fromAscii;
Web3.prototype.fromUtf8 = utils.fromUtf8;
Web3.prototype.toDecimal = utils.toDecimal;
Web3.prototype.fromDecimal = utils.fromDecimal;
Web3.prototype.toBigNumber = utils.toBigNumber;
Web3.prototype.toWei = utils.toWei;
Web3.prototype.fromWei = utils.fromWei;
Web3.prototype.isAddress = utils.isAddress;
Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
Web3.prototype.isIBAN = utils.isIBAN;
Web3.prototype.padLeft = utils.padLeft;
Web3.prototype.padRight = utils.padRight;


Web3.prototype.sha3 = function(string, options) {
    return '0x' + sha3(string, options);
};

/**
 * Transforms direct icap to address
 */
Web3.prototype.fromICAP = function (icap) {
    var iban = new Iban(icap);
    return iban.address();
};

var properties = function () {
    return [
        new Property({
            name: 'version.node',
            getter: 'web3_clientVersion'
        }),
        new Property({
            name: 'version.network',
            getter: 'net_version',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.ethereum',
            getter: 'eth_protocolVersion',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.whisper',
            getter: 'shh_version',
            inputFormatter: utils.toDecimal
        })
    ];
};

Web3.prototype.isConnected = function(){
    return (this.currentProvider && this.currentProvider.isConnected());
};

Web3.prototype.createBatch = function () {
    return new Batch(this);
};

module.exports = Web3;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/allevents.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file allevents.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var SolidityEvent = __webpack_require__("../../node_modules/web3/lib/web3/event.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

var AllSolidityEvents = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._json = json;
    this._address = address;
};

AllSolidityEvents.prototype.encode = function (options) {
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.address = this._address;

    return result;
};

AllSolidityEvents.prototype.decode = function (data) {
    data.data = data.data || '';
    data.topics = data.topics || [];

    var eventTopic = data.topics[0].slice(2);
    var match = this._json.filter(function (j) {
        return eventTopic === sha3(utils.transformToFullName(j));
    })[0];

    if (!match) { // cannot find matching event?
        console.warn('cannot find event for log');
        return data;
    }

    var event = new SolidityEvent(this._requestManager, match, this._address);
    return event.decode(data);
};

AllSolidityEvents.prototype.execute = function (options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 1)
            options = null;
    }

    var o = this.encode(options);
    var formatter = this.decode.bind(this);
    return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
};

AllSolidityEvents.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    contract.allEvents = execute;
};

module.exports = AllSolidityEvents;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/batch.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file batch.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Jsonrpc = __webpack_require__("../../node_modules/web3/lib/web3/jsonrpc.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

var Batch = function (web3) {
    this.requestManager = web3._requestManager;
    this.requests = [];
};

/**
 * Should be called to add create new request to batch request
 *
 * @method add
 * @param {Object} jsonrpc requet object
 */
Batch.prototype.add = function (request) {
    this.requests.push(request);
};

/**
 * Should be called to execute batch request
 *
 * @method execute
 */
Batch.prototype.execute = function () {
    var requests = this.requests;
    this.requestManager.sendBatch(requests, function (err, results) {
        results = results || [];
        requests.map(function (request, index) {
            return results[index] || {};
        }).forEach(function (result, index) {
            if (requests[index].callback) {

                if (!Jsonrpc.isValidResponse(result)) {
                    return requests[index].callback(errors.InvalidResponse(result));
                }

                requests[index].callback(null, (requests[index].format ? requests[index].format(result.result) : result.result));
            }
        });
    }); 
};

module.exports = Batch;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/contract.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file contract.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var SolidityEvent = __webpack_require__("../../node_modules/web3/lib/web3/event.js");
var SolidityFunction = __webpack_require__("../../node_modules/web3/lib/web3/function.js");
var AllEvents = __webpack_require__("../../node_modules/web3/lib/web3/allevents.js");

/**
 * Should be called to encode constructor params
 *
 * @method encodeConstructorParams
 * @param {Array} abi
 * @param {Array} constructor params
 */
var encodeConstructorParams = function (abi, params) {
    return abi.filter(function (json) {
        return json.type === 'constructor' && json.inputs.length === params.length;
    }).map(function (json) {
        return json.inputs.map(function (input) {
            return input.type;
        });
    }).map(function (types) {
        return coder.encodeParams(types, params);
    })[0] || '';
};

/**
 * Should be called to add functions to contract object
 *
 * @method addFunctionsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addFunctionsToContract = function (contract) {
    contract.abi.filter(function (json) {
        return json.type === 'function';
    }).map(function (json) {
        return new SolidityFunction(contract._eth, json, contract.address);
    }).forEach(function (f) {
        f.attachToContract(contract);
    });
};

/**
 * Should be called to add events to contract object
 *
 * @method addEventsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addEventsToContract = function (contract) {
    var events = contract.abi.filter(function (json) {
        return json.type === 'event';
    });

    var All = new AllEvents(contract._eth._requestManager, events, contract.address);
    All.attachToContract(contract);

    events.map(function (json) {
        return new SolidityEvent(contract._eth._requestManager, json, contract.address);
    }).forEach(function (e) {
        e.attachToContract(contract);
    });
};


/**
 * Should be called to check if the contract gets properly deployed on the blockchain.
 *
 * @method checkForContractAddress
 * @param {Object} contract
 * @param {Function} callback
 * @returns {Undefined}
 */
var checkForContractAddress = function(contract, callback){
    var count = 0,
        callbackFired = false;

    // wait for receipt
    var filter = contract._eth.filter('latest', function(e){
        if (!e && !callbackFired) {
            count++;

            // stop watching after 50 blocks (timeout)
            if (count > 50) {

                filter.stopWatching(function() {});
                callbackFired = true;

                if (callback)
                    callback(new Error('Contract transaction couldn\'t be found after 50 blocks'));
                else
                    throw new Error('Contract transaction couldn\'t be found after 50 blocks');


            } else {

                contract._eth.getTransactionReceipt(contract.transactionHash, function(e, receipt){
                    if(receipt && !callbackFired) {

                        contract._eth.getCode(receipt.contractAddress, function(e, code){
                            /*jshint maxcomplexity: 6 */

                            if(callbackFired || !code)
                                return;

                            filter.stopWatching(function() {});
                            callbackFired = true;

                            if(code.length > 3) {

                                // console.log('Contract code deployed!');

                                contract.address = receipt.contractAddress;

                                // attach events and methods again after we have
                                addFunctionsToContract(contract);
                                addEventsToContract(contract);

                                // call callback for the second time
                                if(callback)
                                    callback(null, contract);

                            } else {
                                if(callback)
                                    callback(new Error('The contract code couldn\'t be stored, please check your gas amount.'));
                                else
                                    throw new Error('The contract code couldn\'t be stored, please check your gas amount.');
                            }
                        });
                    }
                });
            }
        }
    });
};

/**
 * Should be called to create new ContractFactory instance
 *
 * @method ContractFactory
 * @param {Array} abi
 */
var ContractFactory = function (eth, abi) {
    this.eth = eth;
    this.abi = abi;

    /**
     * Should be called to create new contract on a blockchain
     *
     * @method new
     * @param {Any} contract constructor param1 (optional)
     * @param {Any} contract constructor param2 (optional)
     * @param {Object} contract transaction object (required)
     * @param {Function} callback
     * @returns {Contract} returns contract instance
     */
    this.new = function () {
        /*jshint maxcomplexity: 7 */
        
        var contract = new Contract(this.eth, this.abi);

        // parse arguments
        var options = {}; // required!
        var callback;

        var args = Array.prototype.slice.call(arguments);
        if (utils.isFunction(args[args.length - 1])) {
            callback = args.pop();
        }

        var last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
            options = args.pop();
        }

        if (options.value > 0) {
            var constructorAbi = abi.filter(function (json) {
                return json.type === 'constructor' && json.inputs.length === args.length;
            })[0] || {};

            if (!constructorAbi.payable) {
                throw new Error('Cannot send value to non-payable constructor');
            }
        }

        var bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;

        if (callback) {

            // wait for the contract address adn check if the code was deployed
            this.eth.sendTransaction(options, function (err, hash) {
                if (err) {
                    callback(err);
                } else {
                    // add the transaction hash
                    contract.transactionHash = hash;

                    // call callback for the first time
                    callback(null, contract);

                    checkForContractAddress(contract, callback);
                }
            });
        } else {
            var hash = this.eth.sendTransaction(options);
            // add the transaction hash
            contract.transactionHash = hash;
            checkForContractAddress(contract);
        }

        return contract;
    };

    this.new.getData = this.getData.bind(this);
};

/**
 * Should be called to create new ContractFactory
 *
 * @method contract
 * @param {Array} abi
 * @returns {ContractFactory} new contract factory
 */
//var contract = function (abi) {
    //return new ContractFactory(abi);
//};



/**
 * Should be called to get access to existing contract on a blockchain
 *
 * @method at
 * @param {Address} contract address (required)
 * @param {Function} callback {optional)
 * @returns {Contract} returns contract if no callback was passed,
 * otherwise calls callback function (err, contract)
 */
ContractFactory.prototype.at = function (address, callback) {
    var contract = new Contract(this.eth, this.abi, address);

    // this functions are not part of prototype,
    // because we dont want to spoil the interface
    addFunctionsToContract(contract);
    addEventsToContract(contract);

    if (callback) {
        callback(null, contract);
    }
    return contract;
};

/**
 * Gets the data, which is data to deploy plus constructor params
 *
 * @method getData
 */
ContractFactory.prototype.getData = function () {
    var options = {}; // required!
    var args = Array.prototype.slice.call(arguments);

    var last = args[args.length - 1];
    if (utils.isObject(last) && !utils.isArray(last)) {
        options = args.pop();
    }

    var bytes = encodeConstructorParams(this.abi, args);
    options.data += bytes;

    return options.data;
};

/**
 * Should be called to create new contract instance
 *
 * @method Contract
 * @param {Array} abi
 * @param {Address} contract address
 */
var Contract = function (eth, abi, address) {
    this._eth = eth;
    this.transactionHash = null;
    this.address = address;
    this.abi = abi;
};

module.exports = ContractFactory;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/errors.js":
/***/ (function(module, exports) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file errors.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

module.exports = {
    InvalidNumberOfSolidityArgs: function () {
        return new Error('Invalid number of arguments to Solidity function');
    },
    InvalidNumberOfRPCParams: function () {
        return new Error('Invalid number of input parameters to RPC method');
    },
    InvalidConnection: function (host){
        return new Error('CONNECTION ERROR: Couldn\'t connect to node '+ host +'.');
    },
    InvalidProvider: function () {
        return new Error('Provider not set or invalid');
    },
    InvalidResponse: function (result){
        var message = !!result && !!result.error && !!result.error.message ? result.error.message : 'Invalid JSON RPC response: ' + JSON.stringify(result);
        return new Error(message);
    },
    ConnectionTimeout: function (ms){
        return new Error('CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');
    }
};


/***/ }),

/***/ "../../node_modules/web3/lib/web3/event.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file event.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

/**
 * This prototype should be used to create event filters
 */
var SolidityEvent = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._params = json.inputs;
    this._name = utils.transformToFullName(json);
    this._address = address;
    this._anonymous = json.anonymous;
};

/**
 * Should be used to get filtered param types
 *
 * @method types
 * @param {Bool} decide if returned typed should be indexed
 * @return {Array} array of types
 */
SolidityEvent.prototype.types = function (indexed) {
    return this._params.filter(function (i) {
        return i.indexed === indexed;
    }).map(function (i) {
        return i.type;
    });
};

/**
 * Should be used to get event display name
 *
 * @method displayName
 * @return {String} event display name
 */
SolidityEvent.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get event type name
 *
 * @method typeName
 * @return {String} event type name
 */
SolidityEvent.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be used to get event signature
 *
 * @method signature
 * @return {String} event signature
 */
SolidityEvent.prototype.signature = function () {
    return sha3(this._name);
};

/**
 * Should be used to encode indexed params and options to one final object
 *
 * @method encode
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} everything combined together and encoded
 */
SolidityEvent.prototype.encode = function (indexed, options) {
    indexed = indexed || {};
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.topics = [];

    result.address = this._address;
    if (!this._anonymous) {
        result.topics.push('0x' + this.signature());
    }

    var indexedTopics = this._params.filter(function (i) {
        return i.indexed === true;
    }).map(function (i) {
        var value = indexed[i.name];
        if (value === undefined || value === null) {
            return null;
        }

        if (utils.isArray(value)) {
            return value.map(function (v) {
                return '0x' + coder.encodeParam(i.type, v);
            });
        }
        return '0x' + coder.encodeParam(i.type, value);
    });

    result.topics = result.topics.concat(indexedTopics);

    return result;
};

/**
 * Should be used to decode indexed params and options
 *
 * @method decode
 * @param {Object} data
 * @return {Object} result object with decoded indexed && not indexed params
 */
SolidityEvent.prototype.decode = function (data) {

    data.data = data.data || '';
    data.topics = data.topics || [];

    var argTopics = this._anonymous ? data.topics : data.topics.slice(1);
    var indexedData = argTopics.map(function (topics) { return topics.slice(2); }).join("");
    var indexedParams = coder.decodeParams(this.types(true), indexedData);

    var notIndexedData = data.data.slice(2);
    var notIndexedParams = coder.decodeParams(this.types(false), notIndexedData);

    var result = formatters.outputLogFormatter(data);
    result.event = this.displayName();
    result.address = data.address;

    result.args = this._params.reduce(function (acc, current) {
        acc[current.name] = current.indexed ? indexedParams.shift() : notIndexedParams.shift();
        return acc;
    }, {});

    delete result.data;
    delete result.topics;

    return result;
};

/**
 * Should be used to create new filter object from event
 *
 * @method execute
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} filter object
 */
SolidityEvent.prototype.execute = function (indexed, options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 2)
            options = null;
        if(arguments.length === 1) {
            options = null;
            indexed = {};
        }
    }

    var o = this.encode(indexed, options);
    var formatter = this.decode.bind(this);
    return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
};

/**
 * Should be used to attach event to contract object
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityEvent.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = this.execute.bind(this, contract);
};

module.exports = SolidityEvent;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/extend.js":
/***/ (function(module, exports, __webpack_require__) {

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

// TODO: refactor, so the input params are not altered.
// it's necessary to make same 'extension' work with multiple providers
var extend = function (web3) {
    /* jshint maxcomplexity:5 */
    var ex = function (extension) {

        var extendedObject;
        if (extension.property) {
            if (!web3[extension.property]) {
                web3[extension.property] = {};
            }
            extendedObject = web3[extension.property];
        } else {
            extendedObject = web3;
        }

        if (extension.methods) {
            extension.methods.forEach(function (method) {
                method.attachToObject(extendedObject);
                method.setRequestManager(web3._requestManager);
            });
        }

        if (extension.properties) {
            extension.properties.forEach(function (property) {
                property.attachToObject(extendedObject);
                property.setRequestManager(web3._requestManager);
            });
        }
    };

    ex.formatters = formatters; 
    ex.utils = utils;
    ex.Method = Method;
    ex.Property = Property;

    return ex;
};



module.exports = extend;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/filter.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file filter.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

/**
* Converts a given topic to a hex string, but also allows null values.
*
* @param {Mixed} value
* @return {String}
*/
var toTopic = function(value){

    if(value === null || typeof value === 'undefined')
        return null;

    value = String(value);

    if(value.indexOf('0x') === 0)
        return value;
    else
        return utils.fromUtf8(value);
};

/// This method should be called on options object, to verify deprecated properties && lazy load dynamic ones
/// @param should be string or object
/// @returns options string or object
var getOptions = function (options, type) {
    /*jshint maxcomplexity: 6 */

    if (utils.isString(options)) {
        return options;
    }

    options = options || {};


    switch(type) {
        case 'eth':

            // make sure topics, get converted to hex
            options.topics = options.topics || [];
            options.topics = options.topics.map(function(topic){
                return (utils.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);
            });

            return {
                topics: options.topics,
                from: options.from,
                to: options.to,
                address: options.address,
                fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),
                toBlock: formatters.inputBlockNumberFormatter(options.toBlock)
            };
        case 'shh':
            return options;
    }
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method getLogsAtStart
@param {Object} self
@param {function} callback
*/
var getLogsAtStart = function(self, callback){
    // call getFilterLogs for the first watch callback start
    if (!utils.isString(self.options)) {
        self.get(function (err, messages) {
            // don't send all the responses to all the watches again... just to self one
            if (err) {
                callback(err);
            }

            if(utils.isArray(messages)) {
                messages.forEach(function (message) {
                    callback(null, message);
                });
            }
        });
    }
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollFilter
@param {Object} self
*/
var pollFilter = function(self) {

    var onMessage = function (error, messages) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isArray(messages)) {
            messages.forEach(function (message) {
                message = self.formatter ? self.formatter(message) : message;
                self.callbacks.forEach(function (callback) {
                    callback(null, message);
                });
            });
        }
    };

    self.requestManager.startPolling({
        method: self.implementation.poll.call,
        params: [self.filterId],
    }, self.filterId, onMessage, self.stopWatching.bind(self));

};

var Filter = function (options, type, requestManager, methods, formatter, callback, filterCreationErrorCallback) {
    var self = this;
    var implementation = {};
    methods.forEach(function (method) {
        method.setRequestManager(requestManager);
        method.attachToObject(implementation);
    });
    this.requestManager = requestManager;
    this.options = getOptions(options, type);
    this.implementation = implementation;
    this.filterId = null;
    this.callbacks = [];
    this.getLogsCallbacks = [];
    this.pollFilters = [];
    this.formatter = formatter;
    this.implementation.newFilter(this.options, function(error, id){
        if(error) {
            self.callbacks.forEach(function(cb){
                cb(error);
            });
            if (typeof filterCreationErrorCallback === 'function') {
              filterCreationErrorCallback(error);
            }
        } else {
            self.filterId = id;

            // check if there are get pending callbacks as a consequence
            // of calling get() with filterId unassigned.
            self.getLogsCallbacks.forEach(function (cb){
                self.get(cb);
            });
            self.getLogsCallbacks = [];

            // get filter logs for the already existing watch calls
            self.callbacks.forEach(function(cb){
                getLogsAtStart(self, cb);
            });
            if(self.callbacks.length > 0)
                pollFilter(self);

            // start to watch immediately
            if(typeof callback === 'function') {
                return self.watch(callback);
            }
        }
    });

    return this;
};

Filter.prototype.watch = function (callback) {
    this.callbacks.push(callback);

    if(this.filterId) {
        getLogsAtStart(this, callback);
        pollFilter(this);
    }

    return this;
};

Filter.prototype.stopWatching = function (callback) {
    this.requestManager.stopPolling(this.filterId);
    this.callbacks = [];
    // remove filter async
    if (callback) {
        this.implementation.uninstallFilter(this.filterId, callback);
    } else {
        return this.implementation.uninstallFilter(this.filterId);
    }
};

Filter.prototype.get = function (callback) {
    var self = this;
    if (utils.isFunction(callback)) {
        if (this.filterId === null) {
            // If filterId is not set yet, call it back
            // when newFilter() assigns it.
            this.getLogsCallbacks.push(callback);
        } else {
            this.implementation.getLogs(this.filterId, function(err, res){
                if (err) {
                    callback(err);
                } else {
                    callback(null, res.map(function (log) {
                        return self.formatter ? self.formatter(log) : log;
                    }));
                }
            });
        }
    } else {
        if (this.filterId === null) {
            throw new Error('Filter ID Error: filter().get() can\'t be chained synchronous, please provide a callback for the get() method.');
        }
        var logs = this.implementation.getLogs(this.filterId);
        return logs.map(function (log) {
            return self.formatter ? self.formatter(log) : log;
        });
    }

    return this;
};

module.exports = Filter;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/formatters.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var config = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");

/**
 * Should the format output to a big number
 *
 * @method outputBigNumberFormatter
 * @param {String|Number|BigNumber}
 * @returns {BigNumber} object
 */
var outputBigNumberFormatter = function (number) {
    return utils.toBigNumber(number);
};

var isPredefinedBlockNumber = function (blockNumber) {
    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';
};

var inputDefaultBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return config.defaultBlock;
    }
    return inputBlockNumberFormatter(blockNumber);
};

var inputBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return undefined;
    } else if (isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
    }
    return utils.toHex(blockNumber);
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputCallFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputCallFormatter = function (options){

    options.from = options.from || config.defaultAccount;

    if (options.from) {
        options.from = inputAddressFormatter(options.from);
    }

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputTransactionFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputTransactionFormatter = function (options){

    options.from = options.from || config.defaultAccount;
    options.from = inputAddressFormatter(options.from);

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the output of a transaction to its proper values
 *
 * @method outputTransactionFormatter
 * @param {Object} tx
 * @returns {Object}
*/
var outputTransactionFormatter = function (tx){
    if(tx.blockNumber !== null)
        tx.blockNumber = utils.toDecimal(tx.blockNumber);
    if(tx.transactionIndex !== null)
        tx.transactionIndex = utils.toDecimal(tx.transactionIndex);
    tx.nonce = utils.toDecimal(tx.nonce);
    tx.gas = utils.toDecimal(tx.gas);
    tx.gasPrice = utils.toBigNumber(tx.gasPrice);
    tx.value = utils.toBigNumber(tx.value);
    return tx;
};

/**
 * Formats the output of a transaction receipt to its proper values
 *
 * @method outputTransactionReceiptFormatter
 * @param {Object} receipt
 * @returns {Object}
*/
var outputTransactionReceiptFormatter = function (receipt){
    if(receipt.blockNumber !== null)
        receipt.blockNumber = utils.toDecimal(receipt.blockNumber);
    if(receipt.transactionIndex !== null)
        receipt.transactionIndex = utils.toDecimal(receipt.transactionIndex);
    receipt.cumulativeGasUsed = utils.toDecimal(receipt.cumulativeGasUsed);
    receipt.gasUsed = utils.toDecimal(receipt.gasUsed);

    if(utils.isArray(receipt.logs)) {
        receipt.logs = receipt.logs.map(function(log){
            return outputLogFormatter(log);
        });
    }

    return receipt;
};

/**
 * Formats the output of a block to its proper values
 *
 * @method outputBlockFormatter
 * @param {Object} block
 * @returns {Object}
*/
var outputBlockFormatter = function(block) {

    // transform to number
    block.gasLimit = utils.toDecimal(block.gasLimit);
    block.gasUsed = utils.toDecimal(block.gasUsed);
    block.size = utils.toDecimal(block.size);
    block.timestamp = utils.toDecimal(block.timestamp);
    if(block.number !== null)
        block.number = utils.toDecimal(block.number);

    block.difficulty = utils.toBigNumber(block.difficulty);
    block.totalDifficulty = utils.toBigNumber(block.totalDifficulty);

    if (utils.isArray(block.transactions)) {
        block.transactions.forEach(function(item){
            if(!utils.isString(item))
                return outputTransactionFormatter(item);
        });
    }

    return block;
};

/**
 * Formats the output of a log
 *
 * @method outputLogFormatter
 * @param {Object} log object
 * @returns {Object} log
*/
var outputLogFormatter = function(log) {
    if(log.blockNumber)
        log.blockNumber = utils.toDecimal(log.blockNumber);
    if(log.transactionIndex)
        log.transactionIndex = utils.toDecimal(log.transactionIndex);
    if(log.logIndex)
        log.logIndex = utils.toDecimal(log.logIndex);

    return log;
};

/**
 * Formats the input of a whisper post and converts all values to HEX
 *
 * @method inputPostFormatter
 * @param {Object} transaction object
 * @returns {Object}
*/
var inputPostFormatter = function(post) {

    // post.payload = utils.toHex(post.payload);
    post.ttl = utils.fromDecimal(post.ttl);
    post.workToProve = utils.fromDecimal(post.workToProve);
    post.priority = utils.fromDecimal(post.priority);

    // fallback
    if (!utils.isArray(post.topics)) {
        post.topics = post.topics ? [post.topics] : [];
    }

    // format the following options
    post.topics = post.topics.map(function(topic){
        // convert only if not hex
        return (topic.indexOf('0x') === 0) ? topic : utils.fromUtf8(topic);
    });

    return post;
};

/**
 * Formats the output of a received post message
 *
 * @method outputPostFormatter
 * @param {Object}
 * @returns {Object}
 */
var outputPostFormatter = function(post){

    post.expiry = utils.toDecimal(post.expiry);
    post.sent = utils.toDecimal(post.sent);
    post.ttl = utils.toDecimal(post.ttl);
    post.workProved = utils.toDecimal(post.workProved);
    // post.payloadRaw = post.payload;
    // post.payload = utils.toAscii(post.payload);

    // if (utils.isJson(post.payload)) {
    //     post.payload = JSON.parse(post.payload);
    // }

    // format the following options
    if (!post.topics) {
        post.topics = [];
    }
    post.topics = post.topics.map(function(topic){
        return utils.toAscii(topic);
    });

    return post;
};

var inputAddressFormatter = function (address) {
    var iban = new Iban(address);
    if (iban.isValid() && iban.isDirect()) {
        return '0x' + iban.address();
    } else if (utils.isStrictAddress(address)) {
        return address;
    } else if (utils.isAddress(address)) {
        return '0x' + address;
    }
    throw new Error('invalid address');
};


var outputSyncingFormatter = function(result) {
    if (!result) {
        return result;
    }

    result.startingBlock = utils.toDecimal(result.startingBlock);
    result.currentBlock = utils.toDecimal(result.currentBlock);
    result.highestBlock = utils.toDecimal(result.highestBlock);
    if (result.knownStates) {
        result.knownStates = utils.toDecimal(result.knownStates);
        result.pulledStates = utils.toDecimal(result.pulledStates);
    }

    return result;
};

module.exports = {
    inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,
    inputBlockNumberFormatter: inputBlockNumberFormatter,
    inputCallFormatter: inputCallFormatter,
    inputTransactionFormatter: inputTransactionFormatter,
    inputAddressFormatter: inputAddressFormatter,
    inputPostFormatter: inputPostFormatter,
    outputBigNumberFormatter: outputBigNumberFormatter,
    outputTransactionFormatter: outputTransactionFormatter,
    outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,
    outputBlockFormatter: outputBlockFormatter,
    outputLogFormatter: outputLogFormatter,
    outputPostFormatter: outputPostFormatter,
    outputSyncingFormatter: outputSyncingFormatter
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/function.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file function.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");

/**
 * This prototype should be used to call/sendTransaction to solidity functions
 */
var SolidityFunction = function (eth, json, address) {
    this._eth = eth;
    this._inputTypes = json.inputs.map(function (i) {
        return i.type;
    });
    this._outputTypes = json.outputs.map(function (i) {
        return i.type;
    });
    this._constant = json.constant;
    this._payable = json.payable;
    this._name = utils.transformToFullName(json);
    this._address = address;
};

SolidityFunction.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

SolidityFunction.prototype.extractDefaultBlock = function (args) {
    if (args.length > this._inputTypes.length && !utils.isObject(args[args.length -1])) {
        return formatters.inputDefaultBlockNumberFormatter(args.pop()); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 *
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
SolidityFunction.prototype.validateArgs = function (args) {
    var inputArgs = args.filter(function (a) {
      // filter the options object but not arguments that are arrays
      return !( (utils.isObject(a) === true) &&
                (utils.isArray(a) === false) &&
                (utils.isBigNumber(a) === false)
              );
    });
    if (inputArgs.length !== this._inputTypes.length) {
        throw errors.InvalidNumberOfSolidityArgs();
    }
};

/**
 * Should be used to create payload from arguments
 *
 * @method toPayload
 * @param {Array} solidity function params
 * @param {Object} optional payload options
 */
SolidityFunction.prototype.toPayload = function (args) {
    var options = {};
    if (args.length > this._inputTypes.length && utils.isObject(args[args.length -1])) {
        options = args[args.length - 1];
    }
    this.validateArgs(args);
    options.to = this._address;
    options.data = '0x' + this.signature() + coder.encodeParams(this._inputTypes, args);
    return options;
};

/**
 * Should be used to get function signature
 *
 * @method signature
 * @return {String} function signature
 */
SolidityFunction.prototype.signature = function () {
    return sha3(this._name).slice(0, 8);
};


SolidityFunction.prototype.unpackOutput = function (output) {
    if (!output) {
        return;
    }

    output = output.length >= 2 ? output.slice(2) : output;
    var result = coder.decodeParams(this._outputTypes, output);
    return result.length === 1 ? result[0] : result;
};

/**
 * Calls a contract function.
 *
 * @method call
 * @param {...Object} Contract function arguments
 * @param {function} If the last argument is a function, the contract function
 *   call will be asynchronous, and the callback will be passed the
 *   error and result.
 * @return {String} output bytes
 */
SolidityFunction.prototype.call = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var defaultBlock = this.extractDefaultBlock(args);
    var payload = this.toPayload(args);


    if (!callback) {
        var output = this._eth.call(payload, defaultBlock);
        return this.unpackOutput(output);
    }

    var self = this;
    this._eth.call(payload, defaultBlock, function (error, output) {
        if (error) return callback(error, null);

        var unpacked = null;
        try {
            unpacked = self.unpackOutput(output);
        }
        catch (e) {
            error = e;
        }

        callback(error, unpacked);
    });
};

/**
 * Should be used to sendTransaction to solidity function
 *
 * @method sendTransaction
 */
SolidityFunction.prototype.sendTransaction = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (payload.value > 0 && !this._payable) {
        throw new Error('Cannot send value to non-payable function');
    }

    if (!callback) {
        return this._eth.sendTransaction(payload);
    }

    this._eth.sendTransaction(payload, callback);
};

/**
 * Should be used to estimateGas of solidity function
 *
 * @method estimateGas
 */
SolidityFunction.prototype.estimateGas = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (!callback) {
        return this._eth.estimateGas(payload);
    }

    this._eth.estimateGas(payload, callback);
};

/**
 * Return the encoded data of the call
 *
 * @method getData
 * @return {String} the encoded data
 */
SolidityFunction.prototype.getData = function () {
    var args = Array.prototype.slice.call(arguments);
    var payload = this.toPayload(args);

    return payload.data;
};

/**
 * Should be used to get function display name
 *
 * @method displayName
 * @return {String} display name of the function
 */
SolidityFunction.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get function type name
 *
 * @method typeName
 * @return {String} type name of the function
 */
SolidityFunction.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be called to get rpc requests from solidity function
 *
 * @method request
 * @returns {Object}
 */
SolidityFunction.prototype.request = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);
    var format = this.unpackOutput.bind(this);

    return {
        method: this._constant ? 'eth_call' : 'eth_sendTransaction',
        callback: callback,
        params: [payload],
        format: format
    };
};

/**
 * Should be called to execute function
 *
 * @method execute
 */
SolidityFunction.prototype.execute = function () {
    var transaction = !this._constant;

    // send transaction
    if (transaction) {
        return this.sendTransaction.apply(this, Array.prototype.slice.call(arguments));
    }

    // call
    return this.call.apply(this, Array.prototype.slice.call(arguments));
};

/**
 * Should be called to attach function to contract
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityFunction.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    execute.request = this.request.bind(this);
    execute.call = this.call.bind(this);
    execute.sendTransaction = this.sendTransaction.bind(this);
    execute.estimateGas = this.estimateGas.bind(this);
    execute.getData = this.getData.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = execute; // circular!!!!
};

module.exports = SolidityFunction;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/httpprovider.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file httpprovider.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

// workaround to use httpprovider in different envs

// browser
if (typeof window !== 'undefined' && window.XMLHttpRequest) {
  XMLHttpRequest = window.XMLHttpRequest; // jshint ignore: line
// node
} else {
  XMLHttpRequest = __webpack_require__("../../node_modules/web3/lib/utils/browser-xhr.js").XMLHttpRequest; // jshint ignore: line
}

var XHR2 = __webpack_require__("../../node_modules/xhr2/lib/browser.js"); // jshint ignore: line

/**
 * HttpProvider should be used to send rpc calls over http
 */
var HttpProvider = function (host, timeout, user, password) {
  this.host = host || 'http://localhost:8545';
  this.timeout = timeout || 0;
  this.user = user;
  this.password = password;
};

/**
 * Should be called to prepare new XMLHttpRequest
 *
 * @method prepareRequest
 * @param {Boolean} true if request should be async
 * @return {XMLHttpRequest} object
 */
HttpProvider.prototype.prepareRequest = function (async) {
  var request;

  if (async) {
    request = new XHR2();
    request.timeout = this.timeout;
  } else {
    request = new XMLHttpRequest();
  }

  request.open('POST', this.host, async);
  if (this.user && this.password) {
    var auth = 'Basic ' + new Buffer(this.user + ':' + this.password).toString('base64');
    request.setRequestHeader('Authorization', auth);
  } request.setRequestHeader('Content-Type', 'application/json');
  return request;
};

/**
 * Should be called to make sync request
 *
 * @method send
 * @param {Object} payload
 * @return {Object} result
 */
HttpProvider.prototype.send = function (payload) {
  var request = this.prepareRequest(false);

  try {
    request.send(JSON.stringify(payload));
  } catch (error) {
    throw errors.InvalidConnection(this.host);
  }

  var result = request.responseText;

  try {
    result = JSON.parse(result);
  } catch (e) {
    throw errors.InvalidResponse(request.responseText);
  }

  return result;
};

/**
 * Should be used to make async request
 *
 * @method sendAsync
 * @param {Object} payload
 * @param {Function} callback triggered on end with (err, result)
 */
HttpProvider.prototype.sendAsync = function (payload, callback) {
  var request = this.prepareRequest(true);

  request.onreadystatechange = function () {
    if (request.readyState === 4 && request.timeout !== 1) {
      var result = request.responseText;
      var error = null;

      try {
        result = JSON.parse(result);
      } catch (e) {
        error = errors.InvalidResponse(request.responseText);
      }

      callback(error, result);
    }
  };

  request.ontimeout = function () {
    callback(errors.ConnectionTimeout(this.timeout));
  };

  try {
    request.send(JSON.stringify(payload));
  } catch (error) {
    callback(errors.InvalidConnection(this.host));
  }
};

/**
 * Synchronously tries to make Http request
 *
 * @method isConnected
 * @return {Boolean} returns true if request haven't failed. Otherwise false
 */
HttpProvider.prototype.isConnected = function () {
  try {
    this.send({
      id: 9999999999,
      jsonrpc: '2.0',
      method: 'net_listening',
      params: []
    });
    return true;
  } catch (e) {
    return false;
  }
};

module.exports = HttpProvider;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../node_modules/web3/lib/web3/iban.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file iban.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");

var padLeft = function (string, bytes) {
    var result = string;
    while (result.length < bytes * 2) {
        result = '0' + result;
    }
    return result;
};

/**
 * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
 * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
 *
 * @method iso13616Prepare
 * @param {String} iban the IBAN
 * @returns {String} the prepared IBAN
 */
var iso13616Prepare = function (iban) {
    var A = 'A'.charCodeAt(0);
    var Z = 'Z'.charCodeAt(0);

    iban = iban.toUpperCase();
    iban = iban.substr(4) + iban.substr(0,4);

    return iban.split('').map(function(n){
        var code = n.charCodeAt(0);
        if (code >= A && code <= Z){
            // A = 10, B = 11, ... Z = 35
            return code - A + 10;
        } else {
            return n;
        }
    }).join('');
};

/**
 * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
 *
 * @method mod9710
 * @param {String} iban
 * @returns {Number}
 */
var mod9710 = function (iban) {
    var remainder = iban,
        block;

    while (remainder.length > 2){
        block = remainder.slice(0, 9);
        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
    }

    return parseInt(remainder, 10) % 97;
};

/**
 * This prototype should be used to create iban object from iban correct string
 *
 * @param {String} iban
 */
var Iban = function (iban) {
    this._iban = iban;
};

/**
 * This method should be used to create iban object from ethereum address
 *
 * @method fromAddress
 * @param {String} address
 * @return {Iban} the IBAN object
 */
Iban.fromAddress = function (address) {
    var asBn = new BigNumber(address, 16);
    var base36 = asBn.toString(36);
    var padded = padLeft(base36, 15);
    return Iban.fromBban(padded.toUpperCase());
};

/**
 * Convert the passed BBAN to an IBAN for this country specification.
 * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
 * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
 *
 * @method fromBban
 * @param {String} bban the BBAN to convert to IBAN
 * @returns {Iban} the IBAN object
 */
Iban.fromBban = function (bban) {
    var countryCode = 'XE';

    var remainder = mod9710(iso13616Prepare(countryCode + '00' + bban));
    var checkDigit = ('0' + (98 - remainder)).slice(-2);

    return new Iban(countryCode + checkDigit + bban);
};

/**
 * Should be used to create IBAN object for given institution and identifier
 *
 * @method createIndirect
 * @param {Object} options, required options are "institution" and "identifier"
 * @return {Iban} the IBAN object
 */
Iban.createIndirect = function (options) {
    return Iban.fromBban('ETH' + options.institution + options.identifier);
};

/**
 * Thos method should be used to check if given string is valid iban object
 *
 * @method isValid
 * @param {String} iban string
 * @return {Boolean} true if it is valid IBAN
 */
Iban.isValid = function (iban) {
    var i = new Iban(iban);
    return i.isValid();
};

/**
 * Should be called to check if iban is correct
 *
 * @method isValid
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isValid = function () {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) &&
        mod9710(iso13616Prepare(this._iban)) === 1;
};

/**
 * Should be called to check if iban number is direct
 *
 * @method isDirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isDirect = function () {
    return this._iban.length === 34 || this._iban.length === 35;
};

/**
 * Should be called to check if iban number if indirect
 *
 * @method isIndirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isIndirect = function () {
    return this._iban.length === 20;
};

/**
 * Should be called to get iban checksum
 * Uses the mod-97-10 checksumming protocol (ISO/IEC 7064:2003)
 *
 * @method checksum
 * @returns {String} checksum
 */
Iban.prototype.checksum = function () {
    return this._iban.substr(2, 2);
};

/**
 * Should be called to get institution identifier
 * eg. XREG
 *
 * @method institution
 * @returns {String} institution identifier
 */
Iban.prototype.institution = function () {
    return this.isIndirect() ? this._iban.substr(7, 4) : '';
};

/**
 * Should be called to get client identifier within institution
 * eg. GAVOFYORK
 *
 * @method client
 * @returns {String} client identifier
 */
Iban.prototype.client = function () {
    return this.isIndirect() ? this._iban.substr(11) : '';
};

/**
 * Should be called to get client direct address
 *
 * @method address
 * @returns {String} client direct address
 */
Iban.prototype.address = function () {
    if (this.isDirect()) {
        var base36 = this._iban.substr(4);
        var asBn = new BigNumber(base36, 36);
        return padLeft(asBn.toString(16), 20);
    } 

    return '';
};

Iban.prototype.toString = function () {
    return this._iban;
};

module.exports = Iban;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/ipcprovider.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file ipcprovider.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");


var IpcProvider = function (path, net) {
    var _this = this;
    this.responseCallbacks = {};
    this.path = path;
    
    this.connection = net.connect({path: this.path});

    this.connection.on('error', function(e){
        console.error('IPC Connection Error', e);
        _this._timeout();
    });

    this.connection.on('end', function(){
        _this._timeout();
    }); 


    // LISTEN FOR CONNECTION RESPONSES
    this.connection.on('data', function(data) {
        /*jshint maxcomplexity: 6 */

        _this._parseResponse(data.toString()).forEach(function(result){

            var id = null;

            // get the id which matches the returned id
            if(utils.isArray(result)) {
                result.forEach(function(load){
                    if(_this.responseCallbacks[load.id])
                        id = load.id;
                });
            } else {
                id = result.id;
            }

            // fire the callback
            if(_this.responseCallbacks[id]) {
                _this.responseCallbacks[id](null, result);
                delete _this.responseCallbacks[id];
            }
        });
    });
};

/**
Will parse the response and make an array out of it.

@method _parseResponse
@param {String} data
*/
IpcProvider.prototype._parseResponse = function(data) {
    var _this = this,
        returnValues = [];
    
    // DE-CHUNKER
    var dechunkedData = data
        .replace(/\}[\n\r]?\{/g,'}|--|{') // }{
        .replace(/\}\][\n\r]?\[\{/g,'}]|--|[{') // }][{
        .replace(/\}[\n\r]?\[\{/g,'}|--|[{') // }[{
        .replace(/\}\][\n\r]?\{/g,'}]|--|{') // }]{
        .split('|--|');

    dechunkedData.forEach(function(data){

        // prepend the last chunk
        if(_this.lastChunk)
            data = _this.lastChunk + data;

        var result = null;

        try {
            result = JSON.parse(data);

        } catch(e) {

            _this.lastChunk = data;

            // start timeout to cancel all requests
            clearTimeout(_this.lastChunkTimeout);
            _this.lastChunkTimeout = setTimeout(function(){
                _this._timeout();
                throw errors.InvalidResponse(data);
            }, 1000 * 15);

            return;
        }

        // cancel timeout and set chunk to null
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;

        if(result)
            returnValues.push(result);
    });

    return returnValues;
};


/**
Get the adds a callback to the responseCallbacks object,
which will be called if a response matching the response Id will arrive.

@method _addResponseCallback
*/
IpcProvider.prototype._addResponseCallback = function(payload, callback) {
    var id = payload.id || payload[0].id;
    var method = payload.method || payload[0].method;

    this.responseCallbacks[id] = callback;
    this.responseCallbacks[id].method = method;
};

/**
Timeout all requests when the end/error event is fired

@method _timeout
*/
IpcProvider.prototype._timeout = function() {
    for(var key in this.responseCallbacks) {
        if(this.responseCallbacks.hasOwnProperty(key)){
            this.responseCallbacks[key](errors.InvalidConnection('on IPC'));
            delete this.responseCallbacks[key];
        }
    }
};


/**
Check if the current connection is still valid.

@method isConnected
*/
IpcProvider.prototype.isConnected = function() {
    var _this = this;

    // try reconnect, when connection is gone
    if(!_this.connection.writable)
        _this.connection.connect({path: _this.path});

    return !!this.connection.writable;
};

IpcProvider.prototype.send = function (payload) {

    if(this.connection.writeSync) {
        var result;

        // try reconnect, when connection is gone
        if(!this.connection.writable)
            this.connection.connect({path: this.path});

        var data = this.connection.writeSync(JSON.stringify(payload));

        try {
            result = JSON.parse(data);
        } catch(e) {
            throw errors.InvalidResponse(data);                
        }

        return result;

    } else {
        throw new Error('You tried to send "'+ payload.method +'" synchronously. Synchronous requests are not supported by the IPC provider.');
    }
};

IpcProvider.prototype.sendAsync = function (payload, callback) {
    // try reconnect, when connection is gone
    if(!this.connection.writable)
        this.connection.connect({path: this.path});


    this.connection.write(JSON.stringify(payload));
    this._addResponseCallback(payload, callback);
};

module.exports = IpcProvider;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/jsonrpc.js":
/***/ (function(module, exports) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file jsonrpc.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Aaron Kumavis <aaron@kumavis.me>
 * @date 2015
 */

// Initialize Jsonrpc as a simple object with utility functions.
var Jsonrpc = {
    messageId: 0
};

/**
 * Should be called to valid json create payload object
 *
 * @method toPayload
 * @param {Function} method of jsonrpc call, required
 * @param {Array} params, an array of method params, optional
 * @returns {Object} valid jsonrpc payload object
 */
Jsonrpc.toPayload = function (method, params) {
    if (!method)
        console.error('jsonrpc method should be specified!');

    // advance message ID
    Jsonrpc.messageId++;

    return {
        jsonrpc: '2.0',
        id: Jsonrpc.messageId,
        method: method,
        params: params || []
    };
};

/**
 * Should be called to check if jsonrpc response is valid
 *
 * @method isValidResponse
 * @param {Object}
 * @returns {Boolean} true if response is valid, otherwise false
 */
Jsonrpc.isValidResponse = function (response) {
    return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);

    function validateSingleMessage(message){
      return !!message &&
        !message.error &&
        message.jsonrpc === '2.0' &&
        typeof message.id === 'number' &&
        message.result !== undefined; // only undefined is not valid json object
    }
};

/**
 * Should be called to create batch payload object
 *
 * @method toBatchPayload
 * @param {Array} messages, an array of objects with method (required) and params (optional) fields
 * @returns {Array} batch payload
 */
Jsonrpc.toBatchPayload = function (messages) {
    return messages.map(function (message) {
        return Jsonrpc.toPayload(message.method, message.params);
    });
};

module.exports = Jsonrpc;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/method.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file method.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

var Method = function (options) {
    this.name = options.name;
    this.call = options.call;
    this.params = options.params || 0;
    this.inputFormatter = options.inputFormatter;
    this.outputFormatter = options.outputFormatter;
    this.requestManager = null;
};

Method.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be used to determine name of the jsonrpc method based on arguments
 *
 * @method getCall
 * @param {Array} arguments
 * @return {String} name of jsonrpc method
 */
Method.prototype.getCall = function (args) {
    return utils.isFunction(this.call) ? this.call(args) : this.call;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Method.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 * 
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
Method.prototype.validateArgs = function (args) {
    if (args.length !== this.params) {
        throw errors.InvalidNumberOfRPCParams();
    }
};

/**
 * Should be called to format input args of method
 * 
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Method.prototype.formatInput = function (args) {
    if (!this.inputFormatter) {
        return args;
    }

    return this.inputFormatter.map(function (formatter, index) {
        return formatter ? formatter(args[index]) : args[index];
    });
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Method.prototype.formatOutput = function (result) {
    return this.outputFormatter && result ? this.outputFormatter(result) : result;
};

/**
 * Should create payload from given input args
 *
 * @method toPayload
 * @param {Array} args
 * @return {Object}
 */
Method.prototype.toPayload = function (args) {
    var call = this.getCall(args);
    var callback = this.extractCallback(args);
    var params = this.formatInput(args);
    this.validateArgs(params);

    return {
        method: call,
        params: params,
        callback: callback
    };
};

Method.prototype.attachToObject = function (obj) {
    var func = this.buildCall();
    func.call = this.call; // TODO!!! that's ugly. filter.js uses it
    var name = this.name.split('.');
    if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
    } else {
        obj[name[0]] = func; 
    }
};

Method.prototype.buildCall = function() {
    var method = this;
    var send = function () {
        var payload = method.toPayload(Array.prototype.slice.call(arguments));
        if (payload.callback) {
            return method.requestManager.sendAsync(payload, function (err, result) {
                payload.callback(err, method.formatOutput(result));
            });
        }
        return method.formatOutput(method.requestManager.send(payload));
    };
    send.request = this.request.bind(this);
    return send;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Method.prototype.request = function () {
    var payload = this.toPayload(Array.prototype.slice.call(arguments));
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Method;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/db.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file db.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");

var DB = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;
    
    methods().forEach(function(method) { 
        method.attachToObject(self);
        method.setRequestManager(web3._requestManager);
    });
};

var methods = function () {
    var putString = new Method({
        name: 'putString',
        call: 'db_putString',
        params: 3
    });

    var getString = new Method({
        name: 'getString',
        call: 'db_getString',
        params: 2
    });

    var putHex = new Method({
        name: 'putHex',
        call: 'db_putHex',
        params: 3
    });

    var getHex = new Method({
        name: 'getHex',
        call: 'db_getHex',
        params: 2
    });

    return [
        putString, getString, putHex, getHex
    ];
};

module.exports = DB;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/eth.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var Contract = __webpack_require__("../../node_modules/web3/lib/web3/contract.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var IsSyncing = __webpack_require__("../../node_modules/web3/lib/web3/syncing.js");
var namereg = __webpack_require__("../../node_modules/web3/lib/web3/namereg.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var transfer = __webpack_require__("../../node_modules/web3/lib/web3/transfer.js");

var blockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? "eth_getBlockByHash" : "eth_getBlockByNumber";
};

var transactionFromBlockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getTransactionByBlockHashAndIndex' : 'eth_getTransactionByBlockNumberAndIndex';
};

var uncleCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleByBlockHashAndIndex' : 'eth_getUncleByBlockNumberAndIndex';
};

var getBlockTransactionCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getBlockTransactionCountByHash' : 'eth_getBlockTransactionCountByNumber';
};

var uncleCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleCountByBlockHash' : 'eth_getUncleCountByBlockNumber';
};

function Eth(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });


    this.iban = Iban;
    this.sendIBANTransaction = transfer.bind(null, this);
}

Object.defineProperty(Eth.prototype, 'defaultBlock', {
    get: function () {
        return c.defaultBlock;
    },
    set: function (val) {
        c.defaultBlock = val;
        return val;
    }
});

Object.defineProperty(Eth.prototype, 'defaultAccount', {
    get: function () {
        return c.defaultAccount;
    },
    set: function (val) {
        c.defaultAccount = val;
        return val;
    }
});

var methods = function () {
    var getBalance = new Method({
        name: 'getBalance',
        call: 'eth_getBalance',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: formatters.outputBigNumberFormatter
    });

    var getStorageAt = new Method({
        name: 'getStorageAt',
        call: 'eth_getStorageAt',
        params: 3,
        inputFormatter: [null, utils.toHex, formatters.inputDefaultBlockNumberFormatter]
    });

    var getCode = new Method({
        name: 'getCode',
        call: 'eth_getCode',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var getBlock = new Method({
        name: 'getBlock',
        call: blockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, function (val) { return !!val; }],
        outputFormatter: formatters.outputBlockFormatter
    });

    var getUncle = new Method({
        name: 'getUncle',
        call: uncleCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputBlockFormatter,

    });

    var getCompilers = new Method({
        name: 'getCompilers',
        call: 'eth_getCompilers',
        params: 0
    });

    var getBlockTransactionCount = new Method({
        name: 'getBlockTransactionCount',
        call: getBlockTransactionCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getBlockUncleCount = new Method({
        name: 'getBlockUncleCount',
        call: uncleCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getTransaction = new Method({
        name: 'getTransaction',
        call: 'eth_getTransactionByHash',
        params: 1,
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionFromBlock = new Method({
        name: 'getTransactionFromBlock',
        call: transactionFromBlockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionReceipt = new Method({
        name: 'getTransactionReceipt',
        call: 'eth_getTransactionReceipt',
        params: 1,
        outputFormatter: formatters.outputTransactionReceiptFormatter
    });

    var getTransactionCount = new Method({
        name: 'getTransactionCount',
        call: 'eth_getTransactionCount',
        params: 2,
        inputFormatter: [null, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var sendRawTransaction = new Method({
        name: 'sendRawTransaction',
        call: 'eth_sendRawTransaction',
        params: 1,
        inputFormatter: [null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'eth_sendTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var signTransaction = new Method({
        name: 'signTransaction',
        call: 'eth_signTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var sign = new Method({
        name: 'sign',
        call: 'eth_sign',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, null]
    });

    var call = new Method({
        name: 'call',
        call: 'eth_call',
        params: 2,
        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var estimateGas = new Method({
        name: 'estimateGas',
        call: 'eth_estimateGas',
        params: 1,
        inputFormatter: [formatters.inputCallFormatter],
        outputFormatter: utils.toDecimal
    });

    var compileSolidity = new Method({
        name: 'compile.solidity',
        call: 'eth_compileSolidity',
        params: 1
    });

    var compileLLL = new Method({
        name: 'compile.lll',
        call: 'eth_compileLLL',
        params: 1
    });

    var compileSerpent = new Method({
        name: 'compile.serpent',
        call: 'eth_compileSerpent',
        params: 1
    });

    var submitWork = new Method({
        name: 'submitWork',
        call: 'eth_submitWork',
        params: 3
    });

    var getWork = new Method({
        name: 'getWork',
        call: 'eth_getWork',
        params: 0
    });

    return [
        getBalance,
        getStorageAt,
        getCode,
        getBlock,
        getUncle,
        getCompilers,
        getBlockTransactionCount,
        getBlockUncleCount,
        getTransaction,
        getTransactionFromBlock,
        getTransactionReceipt,
        getTransactionCount,
        call,
        estimateGas,
        sendRawTransaction,
        signTransaction,
        sendTransaction,
        sign,
        compileSolidity,
        compileLLL,
        compileSerpent,
        submitWork,
        getWork
    ];
};


var properties = function () {
    return [
        new Property({
            name: 'coinbase',
            getter: 'eth_coinbase'
        }),
        new Property({
            name: 'mining',
            getter: 'eth_mining'
        }),
        new Property({
            name: 'hashrate',
            getter: 'eth_hashrate',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'syncing',
            getter: 'eth_syncing',
            outputFormatter: formatters.outputSyncingFormatter
        }),
        new Property({
            name: 'gasPrice',
            getter: 'eth_gasPrice',
            outputFormatter: formatters.outputBigNumberFormatter
        }),
        new Property({
            name: 'accounts',
            getter: 'eth_accounts'
        }),
        new Property({
            name: 'blockNumber',
            getter: 'eth_blockNumber',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'protocolVersion',
            getter: 'eth_protocolVersion'
        })
    ];
};

Eth.prototype.contract = function (abi) {
    var factory = new Contract(this, abi);
    return factory;
};

Eth.prototype.filter = function (options, callback, filterCreationErrorCallback) {
    return new Filter(options, 'eth', this._requestManager, watches.eth(), formatters.outputLogFormatter, callback, filterCreationErrorCallback);
};

Eth.prototype.namereg = function () {
    return this.contract(namereg.global.abi).at(namereg.global.address);
};

Eth.prototype.icapNamereg = function () {
    return this.contract(namereg.icap.abi).at(namereg.icap.address);
};

Eth.prototype.isSyncing = function (callback) {
    return new IsSyncing(this._requestManager, callback);
};

module.exports = Eth;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/net.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file eth.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

var Net = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    properties().forEach(function(p) { 
        p.attachToObject(self);
        p.setRequestManager(web3._requestManager);
    });
};

/// @returns an array of objects describing web3.eth api properties
var properties = function () {
    return [
        new Property({
            name: 'listening',
            getter: 'net_listening'
        }),
        new Property({
            name: 'peerCount',
            getter: 'net_peerCount',
            outputFormatter: utils.toDecimal
        })
    ];
};

module.exports = Net;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/personal.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");

function Personal(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var newAccount = new Method({
        name: 'newAccount',
        call: 'personal_newAccount',
        params: 1,
        inputFormatter: [null]
    });

    var importRawKey = new Method({
        name: 'importRawKey',
		call: 'personal_importRawKey',
		params: 2
    });

    var sign = new Method({
        name: 'sign',
		call: 'personal_sign',
		params: 3,
		inputFormatter: [null, formatters.inputAddressFormatter, null]
    });

    var ecRecover = new Method({
        name: 'ecRecover',
		call: 'personal_ecRecover',
		params: 2
    });

    var unlockAccount = new Method({
        name: 'unlockAccount',
        call: 'personal_unlockAccount',
        params: 3,
        inputFormatter: [formatters.inputAddressFormatter, null, null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'personal_sendTransaction',
        params: 2,
        inputFormatter: [formatters.inputTransactionFormatter, null]
    });

    var lockAccount = new Method({
        name: 'lockAccount',
        call: 'personal_lockAccount',
        params: 1,
        inputFormatter: [formatters.inputAddressFormatter]
    });

    return [
        newAccount,
        importRawKey,
        unlockAccount,
        ecRecover,
        sign,
        sendTransaction,
        lockAccount
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'listAccounts',
            getter: 'personal_listAccounts'
        })
    ];
};


module.exports = Personal;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/shh.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file shh.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethereum.org>
 *   Marek Kotewicz <marek@ethcore.io>
 * @date 2017
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

var Shh = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });
};

Shh.prototype.newMessageFilter = function (options, callback, filterCreationErrorCallback) {
    return new Filter(options, 'shh', this._requestManager, watches.shh(), null, callback, filterCreationErrorCallback);
};

var methods = function () {

    return [
        new Method({
            name: 'version',
            call: 'shh_version',
            params: 0
        }),
        new Method({
            name: 'info',
            call: 'shh_info',
            params: 0
        }),
        new Method({
            name: 'setMaxMessageSize',
            call: 'shh_setMaxMessageSize',
            params: 1
        }),
        new Method({
            name: 'setMinPoW',
            call: 'shh_setMinPoW',
            params: 1
        }),
        new Method({
            name: 'markTrustedPeer',
            call: 'shh_markTrustedPeer',
            params: 1
        }),
        new Method({
            name: 'newKeyPair',
            call: 'shh_newKeyPair',
            params: 0
        }),
        new Method({
            name: 'addPrivateKey',
            call: 'shh_addPrivateKey',
            params: 1
        }),
        new Method({
            name: 'deleteKeyPair',
            call: 'shh_deleteKeyPair',
            params: 1
        }),
        new Method({
            name: 'hasKeyPair',
            call: 'shh_hasKeyPair',
            params: 1
        }),
        new Method({
            name: 'getPublicKey',
            call: 'shh_getPublicKey',
            params: 1
        }),
        new Method({
            name: 'getPrivateKey',
            call: 'shh_getPrivateKey',
            params: 1
        }),
        new Method({
            name: 'newSymKey',
            call: 'shh_newSymKey',
            params: 0
        }),
        new Method({
            name: 'addSymKey',
            call: 'shh_addSymKey',
            params: 1
        }),
        new Method({
            name: 'generateSymKeyFromPassword',
            call: 'shh_generateSymKeyFromPassword',
            params: 1
        }),
        new Method({
            name: 'hasSymKey',
            call: 'shh_hasSymKey',
            params: 1
        }),
        new Method({
            name: 'getSymKey',
            call: 'shh_getSymKey',
            params: 1
        }),
        new Method({
            name: 'deleteSymKey',
            call: 'shh_deleteSymKey',
            params: 1
        }),

        // subscribe and unsubscribe missing

        new Method({
            name: 'post',
            call: 'shh_post',
            params: 1,
            inputFormatter: [null]
        })
    ];
};

module.exports = Shh;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/swarm.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file bzz.js
 * @author Alex Beregszaszi <alex@rtfs.hu>
 * @date 2016
 *
 * Reference: https://github.com/ethereum/go-ethereum/blob/swarm/internal/web3ext/web3ext.go#L33
 */



var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

function Swarm(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var blockNetworkRead = new Method({
        name: 'blockNetworkRead',
        call: 'bzz_blockNetworkRead',
        params: 1,
        inputFormatter: [null]
    });

    var syncEnabled = new Method({
        name: 'syncEnabled',
        call: 'bzz_syncEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var swapEnabled = new Method({
        name: 'swapEnabled',
        call: 'bzz_swapEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var download = new Method({
        name: 'download',
        call: 'bzz_download',
        params: 2,
        inputFormatter: [null, null]
    });

    var upload = new Method({
        name: 'upload',
        call: 'bzz_upload',
        params: 2,
        inputFormatter: [null, null]
    });

    var retrieve = new Method({
        name: 'retrieve',
        call: 'bzz_retrieve',
        params: 1,
        inputFormatter: [null]
    });

    var store = new Method({
        name: 'store',
        call: 'bzz_store',
        params: 2,
        inputFormatter: [null, null]
    });

    var get = new Method({
        name: 'get',
        call: 'bzz_get',
        params: 1,
        inputFormatter: [null]
    });

    var put = new Method({
        name: 'put',
        call: 'bzz_put',
        params: 2,
        inputFormatter: [null, null]
    });

    var modify = new Method({
        name: 'modify',
        call: 'bzz_modify',
        params: 4,
        inputFormatter: [null, null, null, null]
    });

    return [
        blockNetworkRead,
        syncEnabled,
        swapEnabled,
        download,
        upload,
        retrieve,
        store,
        get,
        put,
        modify
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'hive',
            getter: 'bzz_hive'
        }),
        new Property({
            name: 'info',
            getter: 'bzz_info'
        })
    ];
};


module.exports = Swarm;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/watches.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file watches.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");

/// @returns an array of objects describing web3.eth.filter api methods
var eth = function () {
    var newFilterCall = function (args) {
        var type = args[0];

        switch(type) {
            case 'latest':
                args.shift();
                this.params = 0;
                return 'eth_newBlockFilter';
            case 'pending':
                args.shift();
                this.params = 0;
                return 'eth_newPendingTransactionFilter';
            default:
                return 'eth_newFilter';
        }
    };

    var newFilter = new Method({
        name: 'newFilter',
        call: newFilterCall,
        params: 1
    });

    var uninstallFilter = new Method({
        name: 'uninstallFilter',
        call: 'eth_uninstallFilter',
        params: 1
    });

    var getLogs = new Method({
        name: 'getLogs',
        call: 'eth_getFilterLogs',
        params: 1
    });

    var poll = new Method({
        name: 'poll',
        call: 'eth_getFilterChanges',
        params: 1
    });

    return [
        newFilter,
        uninstallFilter,
        getLogs,
        poll
    ];
};

/// @returns an array of objects describing web3.shh.watch api methods
var shh = function () {

    return [
        new Method({
            name: 'newFilter',
            call: 'shh_newMessageFilter',
            params: 1
        }),
        new Method({
            name: 'uninstallFilter',
            call: 'shh_deleteMessageFilter',
            params: 1
        }),
        new Method({
            name: 'getLogs',
            call: 'shh_getFilterMessages',
            params: 1
        }),
        new Method({
            name: 'poll',
            call: 'shh_getFilterMessages',
            params: 1
        })
    ];
};

module.exports = {
    eth: eth,
    shh: shh
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/namereg.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file namereg.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var globalRegistrarAbi = __webpack_require__("../../node_modules/web3/lib/contracts/GlobalRegistrar.json");
var icapRegistrarAbi= __webpack_require__("../../node_modules/web3/lib/contracts/ICAPRegistrar.json");

var globalNameregAddress = '0xc6d9d2cd449a754c494264e1809c50e34d64562b';
var icapNameregAddress = '0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00';

module.exports = {
    global: {
        abi: globalRegistrarAbi,
        address: globalNameregAddress
    },
    icap: {
        abi: icapRegistrarAbi,
        address: icapNameregAddress
    }
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/property.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file property.js
 * @author Fabian Vogelsteller <fabian@frozeman.de>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

var Property = function (options) {
    this.name = options.name;
    this.getter = options.getter;
    this.setter = options.setter;
    this.outputFormatter = options.outputFormatter;
    this.inputFormatter = options.inputFormatter;
    this.requestManager = null;
};

Property.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be called to format input args of method
 *
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Property.prototype.formatInput = function (arg) {
    return this.inputFormatter ? this.inputFormatter(arg) : arg;
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Property.prototype.formatOutput = function (result) {
    return this.outputFormatter && result !== null && result !== undefined ? this.outputFormatter(result) : result;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Property.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};


/**
 * Should attach function to method
 *
 * @method attachToObject
 * @param {Object}
 * @param {Function}
 */
Property.prototype.attachToObject = function (obj) {
    var proto = {
        get: this.buildGet(),
        enumerable: true
    };

    var names = this.name.split('.');
    var name = names[0];
    if (names.length > 1) {
        obj[names[0]] = obj[names[0]] || {};
        obj = obj[names[0]];
        name = names[1];
    }

    Object.defineProperty(obj, name, proto);
    obj[asyncGetterName(name)] = this.buildAsyncGet();
};

var asyncGetterName = function (name) {
    return 'get' + name.charAt(0).toUpperCase() + name.slice(1);
};

Property.prototype.buildGet = function () {
    var property = this;
    return function get() {
        return property.formatOutput(property.requestManager.send({
            method: property.getter
        }));
    };
};

Property.prototype.buildAsyncGet = function () {
    var property = this;
    var get = function (callback) {
        property.requestManager.sendAsync({
            method: property.getter
        }, function (err, result) {
            callback(err, property.formatOutput(result));
        });
    };
    get.request = this.request.bind(this);
    return get;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Property.prototype.request = function () {
    var payload = {
        method: this.getter,
        params: [],
        callback: this.extractCallback(Array.prototype.slice.call(arguments))
    };
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Property;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/requestmanager.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file requestmanager.js
 * @author Jeffrey Wilcke <jeff@ethdev.com>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Marian Oancea <marian@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @author Gav Wood <g@ethdev.com>
 * @date 2014
 */

var Jsonrpc = __webpack_require__("../../node_modules/web3/lib/web3/jsonrpc.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

/**
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 * Singleton
 */
var RequestManager = function (provider) {
    this.provider = provider;
    this.polls = {};
    this.timeout = null;
};

/**
 * Should be used to synchronously send request
 *
 * @method send
 * @param {Object} data
 * @return {Object}
 */
RequestManager.prototype.send = function (data) {
    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return null;
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    var result = this.provider.send(payload);

    if (!Jsonrpc.isValidResponse(result)) {
        throw errors.InvalidResponse(result);
    }

    return result.result;
};

/**
 * Should be used to asynchronously send request
 *
 * @method sendAsync
 * @param {Object} data
 * @param {Function} callback
 */
RequestManager.prototype.sendAsync = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    this.provider.sendAsync(payload, function (err, result) {
        if (err) {
            return callback(err);
        }
        
        if (!Jsonrpc.isValidResponse(result)) {
            return callback(errors.InvalidResponse(result));
        }

        callback(null, result.result);
    });
};

/**
 * Should be called to asynchronously send batch request
 *
 * @method sendBatch
 * @param {Array} batch data
 * @param {Function} callback
 */
RequestManager.prototype.sendBatch = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toBatchPayload(data);

    this.provider.sendAsync(payload, function (err, results) {
        if (err) {
            return callback(err);
        }

        if (!utils.isArray(results)) {
            return callback(errors.InvalidResponse(results));
        }

        callback(err, results);
    }); 
};

/**
 * Should be used to set provider of request manager
 *
 * @method setProvider
 * @param {Object}
 */
RequestManager.prototype.setProvider = function (p) {
    this.provider = p;
};

/**
 * Should be used to start polling
 *
 * @method startPolling
 * @param {Object} data
 * @param {Number} pollId
 * @param {Function} callback
 * @param {Function} uninstall
 *
 * @todo cleanup number of params
 */
RequestManager.prototype.startPolling = function (data, pollId, callback, uninstall) {
    this.polls[pollId] = {data: data, id: pollId, callback: callback, uninstall: uninstall};


    // start polling
    if (!this.timeout) {
        this.poll();
    }
};

/**
 * Should be used to stop polling for filter with given id
 *
 * @method stopPolling
 * @param {Number} pollId
 */
RequestManager.prototype.stopPolling = function (pollId) {
    delete this.polls[pollId];

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to reset the polling mechanism of the request manager
 *
 * @method reset
 */
RequestManager.prototype.reset = function (keepIsSyncing) {
    /*jshint maxcomplexity:5 */

    for (var key in this.polls) {
        // remove all polls, except sync polls,
        // they need to be removed manually by calling syncing.stopWatching()
        if(!keepIsSyncing || key.indexOf('syncPoll_') === -1) {
            this.polls[key].uninstall();
            delete this.polls[key];
        }
    }

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to poll for changes on filter with given id
 *
 * @method poll
 */
RequestManager.prototype.poll = function () {
    /*jshint maxcomplexity: 6 */
    this.timeout = setTimeout(this.poll.bind(this), c.ETH_POLLING_TIMEOUT);

    if (Object.keys(this.polls).length === 0) {
        return;
    }

    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return;
    }

    var pollsData = [];
    var pollsIds = [];
    for (var key in this.polls) {
        pollsData.push(this.polls[key].data);
        pollsIds.push(key);
    }

    if (pollsData.length === 0) {
        return;
    }

    var payload = Jsonrpc.toBatchPayload(pollsData);
    
    // map the request id to they poll id
    var pollsIdMap = {};
    payload.forEach(function(load, index){
        pollsIdMap[load.id] = pollsIds[index];
    });


    var self = this;
    this.provider.sendAsync(payload, function (error, results) {


        // TODO: console log?
        if (error) {
            return;
        }

        if (!utils.isArray(results)) {
            throw errors.InvalidResponse(results);
        }
        results.map(function (result) {
            var id = pollsIdMap[result.id];

            // make sure the filter is still installed after arrival of the request
            if (self.polls[id]) {
                result.callback = self.polls[id].callback;
                return result;
            } else
                return false;
        }).filter(function (result) {
            return !!result; 
        }).filter(function (result) {
            var valid = Jsonrpc.isValidResponse(result);
            if (!valid) {
                result.callback(errors.InvalidResponse(result));
            }
            return valid;
        }).forEach(function (result) {
            result.callback(null, result.result);
        });
    });
};

module.exports = RequestManager;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/settings.js":
/***/ (function(module, exports) {



var Settings = function () {
    this.defaultBlock = 'latest';
    this.defaultAccount = undefined;
};

module.exports = Settings;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/syncing.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file syncing.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

var count = 1;

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollSyncing
@param {Object} self
*/
var pollSyncing = function(self) {

    var onMessage = function (error, sync) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isObject(sync) && sync.startingBlock)
            sync = formatters.outputSyncingFormatter(sync);

        self.callbacks.forEach(function (callback) {
            if (self.lastSyncState !== sync) {
                
                // call the callback with true first so the app can stop anything, before receiving the sync data
                if(!self.lastSyncState && utils.isObject(sync))
                    callback(null, true);
                
                // call on the next CPU cycle, so the actions of the sync stop can be processes first
                setTimeout(function() {
                    callback(null, sync);
                }, 0);
                
                self.lastSyncState = sync;
            }
        });
    };

    self.requestManager.startPolling({
        method: 'eth_syncing',
        params: [],
    }, self.pollId, onMessage, self.stopWatching.bind(self));

};

var IsSyncing = function (requestManager, callback) {
    this.requestManager = requestManager;
    this.pollId = 'syncPoll_'+ count++;
    this.callbacks = [];
    this.addCallback(callback);
    this.lastSyncState = false;
    pollSyncing(this);

    return this;
};

IsSyncing.prototype.addCallback = function (callback) {
    if(callback)
        this.callbacks.push(callback);
    return this;
};

IsSyncing.prototype.stopWatching = function () {
    this.requestManager.stopPolling(this.pollId);
    this.callbacks = [];
};

module.exports = IsSyncing;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/transfer.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file transfer.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var exchangeAbi = __webpack_require__("../../node_modules/web3/lib/contracts/SmartExchange.json");

/**
 * Should be used to make Iban transfer
 *
 * @method transfer
 * @param {String} from
 * @param {String} to iban
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transfer = function (eth, from, to, value, callback) {
    var iban = new Iban(to); 
    if (!iban.isValid()) {
        throw new Error('invalid iban address');
    }

    if (iban.isDirect()) {
        return transferToAddress(eth, from, iban.address(), value, callback);
    }
    
    if (!callback) {
        var address = eth.icapNamereg().addr(iban.institution());
        return deposit(eth, from, address, value, iban.client());
    }

    eth.icapNamereg().addr(iban.institution(), function (err, address) {
        return deposit(eth, from, address, value, iban.client(), callback);
    });
    
};

/**
 * Should be used to transfer funds to certain address
 *
 * @method transferToAddress
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transferToAddress = function (eth, from, to, value, callback) {
    return eth.sendTransaction({
        address: to,
        from: from,
        value: value
    }, callback);
};

/**
 * Should be used to deposit funds to generic Exchange contract (must implement deposit(bytes32) method!)
 *
 * @method deposit
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be transfered
 * @param {String} client unique identifier
 * @param {Function} callback, callback
 */
var deposit = function (eth, from, to, value, client, callback) {
    var abi = exchangeAbi;
    return eth.contract(abi).at(to).deposit(client, {
        from: from,
        value: value
    }, callback);
};

module.exports = transfer;



/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../../node_modules/xhr2/lib/browser.js":
/***/ (function(module, exports) {

module.exports = XMLHttpRequest;


/***/ }),

/***/ "../../packages/components/src/adsList.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/adsList.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./adsList.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./adsList.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/button.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/button.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./button.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./button.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/icon.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/icon.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./icon.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./icon.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/input.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/input.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./input.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./input.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/label.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/label.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./label.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./label.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/link.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/link.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./link.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./link.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/linkList.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/linkList.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./linkList.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./linkList.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/loader.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/loader.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./loader.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./loader.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/paper.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/paper.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./paper.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./paper.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/textWithLabel.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/textWithLabel.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./textWithLabel.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./textWithLabel.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/tooltip.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/tooltip.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./tooltip.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./tooltip.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./images/heart.svg":
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTQxcHgiIGhlaWdodD0iMTMxcHgiIHZpZXdCb3g9IjAgMCAxNDEgMTMxIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0Ni4yICg0NDQ5NikgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+R3JvdXAgMzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxjaXJjbGUgaWQ9InBhdGgtMSIgY3g9IjYwLjc4NjEzMjgiIGN5PSI1OS43ODYxMzI4IiByPSI0NS43ODYxMzI4Ij48L2NpcmNsZT4KICAgICAgICA8ZmlsdGVyIHg9Ii0zNS41JSIgeT0iLTMwLjAlIiB3aWR0aD0iMTcxLjAlIiBoZWlnaHQ9IjE3MS4wJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTIiPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSI1IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxMCIgaW49InNoYWRvd09mZnNldE91dGVyMSIgcmVzdWx0PSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMC4wMzUyOTQxMTc2ICAgMCAwIDAgMCAwLjgzNTI5NDExOCAgIDAgMCAwIDAgMC40ODYyNzQ1MSAgMCAwIDAgMC40NSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iTVZQIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iY3JlYXRlTmV3QWRDb25maXJtYXRpb24iIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03MzYuMDAwMDAwLCAtMzYxLjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzQxLjAwMDAwMCwgMzYyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTMiPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMiIgZmlsbC1vcGFjaXR5PSIwLjIiIGZpbGw9IiMwOUQ1N0MiIGN4PSIxMDMiIGN5PSIzMyIgcj0iMzMiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMiIgZmlsbC1vcGFjaXR5PSIwLjIiIGZpbGw9IiMwOUQ1N0MiIGN4PSIzMyIgY3k9IjczIiByPSIzMyI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiMwOUQ1N0MiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJub3VuXzc0NzMwMl9jYyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzYuMDAwMDAwLCA0Mi4wMDAwMDApIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuOTU2MDQ0LDAuMTA5ODkwMTEgQzE2LjcwMzI5NjcsLTMuMDQwNjIzMzFlLTE0IDE5LjA2NTkzNDEsMC45ODkwMTA5ODkgMjAuODI0MTc1OCwyLjg1NzE0Mjg2IEwyNC44OTAxMDk5LDcuMTQyODU3MTQgQzIzLjczNjI2MzcsOC40NjE1Mzg0NiAyMi44NTcxNDI5LDkuMzk1NjA0NCAyMi41Mjc0NzI1LDkuODM1MTY0ODQgQzIxLjkyMzA3NjksOS4xNzU4MjQxOCAyMC40Mzk1NjA0LDcuNDcyNTI3NDcgMTguOTU2MDQ0LDUuODc5MTIwODggQzE3LjU4MjQxNzYsNC4zOTU2MDQ0IDE1LjcxNDI4NTcsMy42ODEzMTg2OCAxMy43MzYyNjM3LDMuNzkxMjA4NzkgQzExLjg2ODEzMTksMy45MDEwOTg5IDEwLjE2NDgzNTIsNC43ODAyMTk3OCA5LjI4NTcxNDI5LDUuOTg5MDEwOTkgQzUuOTg5MDEwOTksMTAuNTQ5NDUwNSA5LjI4NTcxNDI5LDE0LjYxNTM4NDYgOS4yODU3MTQyOSwxNC42NzAzMjk3IEwyNC44MzUxNjQ4LDMyLjYzNzM2MjYgQzIzLjY4MTMxODcsMzMuOTU2MDQ0IDIyLjg1NzE0MjksMzQuOTQ1MDU0OSAyMi40NzI1Mjc1LDM1LjMyOTY3MDMgQzIwLjg3OTEyMDksMzMuMzUxNjQ4NCAxMC4zODQ2MTU0LDIxLjQyODU3MTQgNi4yMDg3OTEyMSwxNi41OTM0MDY2IEM1LjIxOTc4MDIyLDE1LjQ5NDUwNTUgMy4xMzE4NjgxMywxMS41OTM0MDY2IDQuODM1MTY0ODQsNi43NTgyNDE3NiBDNi40ODM1MTY0OCwyLjAzMjk2NzAzIDEwLjc2OTIzMDgsMC4yMTk3ODAyMiAxMy45NTYwNDQsMC4xMDk4OTAxMSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIzLjA3NjkyMzEsMTYuMzE4NjgxMyBDMjQuNDUwNTQ5NSwxNC43MjUyNzQ3IDI4Ljk1NjA0NCw5LjQ1MDU0OTQ1IDMxLjc1ODI0MTgsNi4zNzM2MjYzNyBDMzIuODU3MTQyOSw1LjE2NDgzNTE2IDM0LjI4NTcxNDMsNC40NTA1NDk0NSAzNS45ODkwMTEsNC4zOTU2MDQ0IEMzNy4zMDc2OTIzLDQuMzQwNjU5MzQgMzguNjgxMzE4Nyw0LjcyNTI3NDczIDM5LjcyNTI3NDcsNS40Mzk1NjA0NCBDMzYuNTkzNDA2Niw1LjY1OTM0MDY2IDM1LjA1NDk0NTEsNy41Mjc0NzI1MyAzNSw3LjU4MjQxNzU4IEwyNy42MzczNjI2LDE2LjMxODY4MTMgTDIzLjA3NjkyMzEsMTYuMzE4NjgxMyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMuMDc2OTIzMDgsMTkuNDUwNTQ5NSBDMC45ODkwMTA5ODksMTcuMDMyOTY3IDAuMTY0ODM1MTY1LDEzLjc5MTIwODggMC43MTQyODU3MTQsMTAuMTY0ODM1MiBDMS4xNTM4NDYxNSw3LjAzMjk2NzAzIDMuNzM2MjYzNzQsNC4wNjU5MzQwNyA2LjY0ODM1MTY1LDIuNzQ3MjUyNzUgQzUuNjU5MzQwNjYsMy43OTEyMDg3OSA0LjgzNTE2NDg0LDUuMDU0OTQ1MDUgNC4yODU3MTQyOSw2LjU5MzQwNjU5IEMyLjQ3MjUyNzQ3LDExLjU5MzQwNjYgNC43MjUyNzQ3MywxNS44MjQxNzU4IDUuNzY5MjMwNzcsMTYuOTc4MDIyIEMxMC4yNzQ3MjUzLDIyLjE5NzgwMjIgMjIuMTQyODU3MSwzNS44MjQxNzU4IDIyLjI1Mjc0NzMsMzUuOTM0MDY1OSBMMjIuNTI3NDcyNSwzNi4yNjM3MzYzIEwyMi43NDcyNTI3LDM2LjA0Mzk1NiBDMjIuOTEyMDg3OSwzNS44NzkxMjA5IDM3LjQ3MjUyNzUsMTkuMDY1OTM0MSA0MC43MTQyODU3LDE1LjQzOTU2MDQgQzQzLjQ2MTUzODUsMTIuMzA3NjkyMyA0My4wNzY5MjMxLDcuNjM3MzYyNjQgNDAuODI0MTc1OCw1LjU0OTQ1MDU1IEMzOS42MTUzODQ2LDQuMzk1NjA0NCAzNy44MDIxOTc4LDMuNzM2MjYzNzQgMzYuMDQzOTU2LDMuOTAxMDk4OSBDMzQuMjMwNzY5MiwzLjk1NjA0Mzk2IDMyLjYzNzM2MjYsNC43ODAyMTk3OCAzMS40Mjg1NzE0LDYuMDQzOTU2MDQgQzI4LjUxNjQ4MzUsOS4yMzA3NjkyMyAyMy42MjYzNzM2LDE0Ljg5MDEwOTkgMjIuNTI3NDcyNSwxNi4xNTM4NDYyIEMyMS41Mzg0NjE1LDE0Ljk0NTA1NDkgMTcuMTk3ODAyMiw5LjY3MDMyOTY3IDE0Ljk0NTA1NDksNy4xOTc4MDIyIEMxNC4yMzA3NjkyLDYuNDI4NTcxNDMgMTMuMDIxOTc4LDUuNjA0Mzk1NiAxMC43NjkyMzA4LDUuMzg0NjE1MzggQzExLjU5MzQwNjYsNC43ODAyMTk3OCAxMi42OTIzMDc3LDQuNDUwNTQ5NDUgMTMuNzkxMjA4OCw0LjM0MDY1OTM0IEMxNS4wNTQ5NDUxLDQuMjg1NzE0MjkgMTYuOTIzMDc2OSw0LjUwNTQ5NDUxIDE4LjUxNjQ4MzUsNi4yNjM3MzYyNiBDMjAuMzg0NjE1NCw4LjI0MTc1ODI0IDIyLjI1Mjc0NzMsMTAuNDM5NTYwNCAyMi4yNTI3NDczLDEwLjQzOTU2MDQgTDIyLjQ3MjUyNzUsMTAuNjU5MzQwNyBMMjIuNjkyMzA3NywxMC40Mzk1NjA0IEMyMi42OTIzMDc3LDEwLjQzOTU2MDQgMjUsNy44MDIxOTc4IDI4LjE4NjgxMzIsNC4xNzU4MjQxOCBDMzAuOTM0MDY1OSwxLjA5ODkwMTEgMzQuMjMwNzY5MiwwIDM2LjQ4MzUxNjUsMCBDMzguNzM2MjYzNywwIDQzLjQ2MTUzODUsMS4zNzM2MjYzNyA0NS40OTQ1MDU1LDYuNjQ4MzUxNjUgQzQ2LjcwMzI5NjcsOS44MzUxNjQ4NCA0Ni4xNTM4NDYyLDE0LjA2NTkzNDEgNDQuMTc1ODI0MiwxNi4zMTg2ODEzIEMzOC41NzE0Mjg2LDIyLjg1NzE0MjkgMjQuMTc1ODI0MiwzOS4yODU3MTQzIDIyLjMwNzY5MjMsNDEuNDgzNTE2NSBDMjAuMzg0NjE1NCwzOS4yODU3MTQzIDUuMjc0NzI1MjcsMjEuOTIzMDc2OSAzLjA3NjkyMzA4LDE5LjQ1MDU0OTUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik00Ny45NjcwMzMsMTguNDYxNTM4NSBDNDMuNTcxNDI4NiwyMy40MDY1OTM0IDI5LjE3NTgyNDIsNDAuMzI5NjcwMyAyNy45MTIwODc5LDQxLjc1ODI0MTggTDIzLjAyMTk3OCw0MS43NTgyNDE4IEMyNS41NDk0NTA1LDM4Ljc5MTIwODggMzkuMjg1NzE0MywyMy4xMzE4NjgxIDQ0LjcyNTI3NDcsMTYuODEzMTg2OCBDNDYuODY4MTMxOSwxNC4zOTU2MDQ0IDQ3LjQxNzU4MjQsMTAgNDYuMDk4OTAxMSw2LjU5MzQwNjU5IEM0NS40Mzk1NjA0LDUgNDQuNjE1Mzg0NiwzLjY4MTMxODY4IDQzLjYyNjM3MzYsMi43NDcyNTI3NSBDNDYuMDQzOTU2LDMuNzkxMjA4NzkgNDcuOTEyMDg3OSw1LjQ5NDUwNTQ5IDQ5LjAxMDk4OSw3LjkxMjA4NzkxIEw0OS4wNjU5MzQxLDguMDIxOTc4MDIgQzQ5LjAxMDk4OSw3Ljk2NzAzMjk3IDUxLjgxMzE4NjgsMTQuMDEwOTg5IDQ3Ljk2NzAzMywxOC40NjE1Mzg1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"

/***/ }),

/***/ "./src/index.tsx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: /apps/node_modules/preact/dist/preact.esm.js
var preact_esm = __webpack_require__("../../node_modules/preact/dist/preact.esm.js");

// EXTERNAL MODULE: /apps/node_modules/normalize.css/normalize.css
var normalize = __webpack_require__("../../node_modules/normalize.css/normalize.css");
var normalize_default = /*#__PURE__*/__webpack_require__.n(normalize);

// EXTERNAL MODULE: /apps/node_modules/preact-compat/dist/preact-compat.es.js
var preact_compat_es = __webpack_require__("../../node_modules/preact-compat/dist/preact-compat.es.js");

// EXTERNAL MODULE: /apps/node_modules/prop-types/index.js
var prop_types = __webpack_require__("../../node_modules/prop-types/index.js");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: /apps/node_modules/history/createBrowserHistory.js
var createBrowserHistory = __webpack_require__("../../node_modules/history/createBrowserHistory.js");
var createBrowserHistory_default = /*#__PURE__*/__webpack_require__.n(createBrowserHistory);

// EXTERNAL MODULE: /apps/node_modules/history/createMemoryHistory.js
var createMemoryHistory = __webpack_require__("../../node_modules/history/createMemoryHistory.js");
var createMemoryHistory_default = /*#__PURE__*/__webpack_require__.n(createMemoryHistory);

// EXTERNAL MODULE: /apps/node_modules/warning/browser.js
var browser = __webpack_require__("../../node_modules/warning/browser.js");
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);

// EXTERNAL MODULE: /apps/node_modules/invariant/browser.js
var invariant_browser = __webpack_require__("../../node_modules/invariant/browser.js");
var invariant_browser_default = /*#__PURE__*/__webpack_require__.n(invariant_browser);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/Router.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for putting history on context.
 */

var Router_Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;


    invariant_browser_default()(children == null || preact_compat_es["a" /* default */].Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    browser_default()(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? preact_compat_es["a" /* default */].Children.only(children) : null;
  };

  return Router;
}(preact_compat_es["a" /* default */].Component);

Router_Router.propTypes = {
  history: prop_types_default.a.object.isRequired,
  children: prop_types_default.a.node
};
Router_Router.contextTypes = {
  router: prop_types_default.a.object
};
Router_Router.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_Router = (Router_Router);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/MemoryRouter.js
function MemoryRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MemoryRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MemoryRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter_MemoryRouter = function (_React$Component) {
  MemoryRouter__inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    MemoryRouter__classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = MemoryRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createMemoryHistory_default()(_this.props), _temp), MemoryRouter__possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(es_Router, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(preact_compat_es["a" /* default */].Component);

MemoryRouter_MemoryRouter.propTypes = {
  initialEntries: prop_types_default.a.array,
  initialIndex: prop_types_default.a.number,
  getUserConfirmation: prop_types_default.a.func,
  keyLength: prop_types_default.a.number,
  children: prop_types_default.a.node
};


/* harmony default export */ var es_MemoryRouter = (MemoryRouter_MemoryRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Prompt.js
function Prompt__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Prompt__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Prompt__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  Prompt__inherits(Prompt, _React$Component);

  function Prompt() {
    Prompt__classCallCheck(this, Prompt);

    return Prompt__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(preact_compat_es["a" /* default */].Component);

Prompt.propTypes = {
  when: prop_types_default.a.bool,
  message: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      block: prop_types_default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ var es_Prompt = (Prompt);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Redirect.js
function Redirect__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Redirect__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Redirect__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * The public API for updating the location programatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  Redirect__inherits(Redirect, _React$Component);

  function Redirect() {
    Redirect__classCallCheck(this, Redirect);

    return Redirect__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;


    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(preact_compat_es["a" /* default */].Component);

Redirect.propTypes = {
  push: prop_types_default.a.bool,
  from: prop_types_default.a.string,
  to: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object])
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      push: prop_types_default.a.func.isRequired,
      replace: prop_types_default.a.func.isRequired
    }).isRequired,
    staticContext: prop_types_default.a.object
  }).isRequired
};


/* harmony default export */ var es_Redirect = (Redirect);
// EXTERNAL MODULE: /apps/node_modules/react-router/node_modules/path-to-regexp/index.js
var path_to_regexp = __webpack_require__("../../node_modules/react-router/node_modules/path-to-regexp/index.js");
var path_to_regexp_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/matchPath.js


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var matchPath_compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = path_to_regexp_default()(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict;

  var _compilePath = matchPath_compilePath(path, { end: exact, strict: strict }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

/* harmony default export */ var es_matchPath = (matchPath);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Route.js
var Route__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Route__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Route__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Route__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for matching a single path and rendering.
 */

var Route_Route = function (_React$Component) {
  Route__inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    Route__classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Route__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), Route__possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: Route__extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, _ref2) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact;
    var route = _ref2.route;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    var pathname = (location || route.location).pathname;

    return path ? es_matchPath(pathname, { path: path, strict: strict, exact: exact }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    var _props = this.props,
        component = _props.component,
        render = _props.render,
        children = _props.children;


    browser_default()(!(component && render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    browser_default()(!(component && children), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    browser_default()(!(render && children), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    browser_default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    browser_default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props2 = this.props,
        children = _props2.children,
        component = _props2.component,
        render = _props2.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? preact_compat_es["a" /* default */].createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !Array.isArray(children) || children.length ? // Preact defaults to empty children array
    preact_compat_es["a" /* default */].Children.only(children) : null : null;
  };

  return Route;
}(preact_compat_es["a" /* default */].Component);

Route_Route.propTypes = {
  computedMatch: prop_types_default.a.object, // private, from <Switch>
  path: prop_types_default.a.string,
  exact: prop_types_default.a.bool,
  strict: prop_types_default.a.bool,
  component: prop_types_default.a.func,
  render: prop_types_default.a.func,
  children: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.node]),
  location: prop_types_default.a.object
};
Route_Route.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.object.isRequired,
    route: prop_types_default.a.object.isRequired,
    staticContext: prop_types_default.a.object
  })
};
Route_Route.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_Route = (Route_Route);
// EXTERNAL MODULE: /apps/node_modules/history/PathUtils.js
var PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");
var PathUtils_default = /*#__PURE__*/__webpack_require__.n(PathUtils);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/StaticRouter.js
var StaticRouter__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function StaticRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function StaticRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function StaticRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;


  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var StaticRouter_addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return StaticRouter__extends({}, location, {
    pathname: Object(PathUtils["addLeadingSlash"])(basename) + location.pathname
  });
};

var StaticRouter_stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = Object(PathUtils["addLeadingSlash"])(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return StaticRouter__extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var StaticRouter_createLocation = function createLocation(location) {
  return typeof location === 'string' ? Object(PathUtils["parsePath"])(location) : normalizeLocation(location);
};

var StaticRouter_createURL = function createURL(location) {
  return typeof location === 'string' ? location : Object(PathUtils["createPath"])(location);
};

var StaticRouter_staticHandler = function staticHandler(methodName) {
  return function () {
    invariant_browser_default()(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter_StaticRouter = function (_React$Component) {
  StaticRouter__inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    StaticRouter__classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = StaticRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return Object(PathUtils["addLeadingSlash"])(_this.props.basename + StaticRouter_createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
      context.url = StaticRouter_createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
      context.url = StaticRouter_createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), StaticRouter__possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: StaticRouter_stripBasename(basename, StaticRouter_createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: StaticRouter_staticHandler('go'),
      goBack: StaticRouter_staticHandler('goBack'),
      goForward: StaticRouter_staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return preact_compat_es["a" /* default */].createElement(es_Router, StaticRouter__extends({}, props, { history: history }));
  };

  return StaticRouter;
}(preact_compat_es["a" /* default */].Component);

StaticRouter_StaticRouter.propTypes = {
  basename: prop_types_default.a.string,
  context: prop_types_default.a.object.isRequired,
  location: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object])
};
StaticRouter_StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter_StaticRouter.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_StaticRouter = (StaticRouter_StaticRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Switch.js
function Switch__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Switch__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Switch__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch_Switch = function (_React$Component) {
  Switch__inherits(Switch, _React$Component);

  function Switch() {
    Switch__classCallCheck(this, Switch);

    return Switch__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    browser_default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    browser_default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    preact_compat_es["a" /* default */].Children.forEach(children, function (element) {
      if (!preact_compat_es["a" /* default */].isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? es_matchPath(location.pathname, { path: path, exact: exact, strict: strict }) : route.match;
      }
    });

    return match ? preact_compat_es["a" /* default */].cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(preact_compat_es["a" /* default */].Component);

Switch_Switch.contextTypes = {
  router: prop_types_default.a.shape({
    route: prop_types_default.a.object.isRequired
  }).isRequired
};
Switch_Switch.propTypes = {
  children: prop_types_default.a.node,
  location: prop_types_default.a.object
};


/* harmony default export */ var es_Switch = (Switch_Switch);
// EXTERNAL MODULE: /apps/node_modules/hoist-non-react-statics/index.js
var hoist_non_react_statics = __webpack_require__("../../node_modules/hoist-non-react-statics/index.js");
var hoist_non_react_statics_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/withRouter.js
var withRouter__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function withRouter__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A public higher-order component to access the imperative API
 */
var withRouter_withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = withRouter__objectWithoutProperties(props, ['wrappedComponentRef']);

    return preact_compat_es["a" /* default */].createElement(es_Route, { render: function render(routeComponentProps) {
        return preact_compat_es["a" /* default */].createElement(Component, withRouter__extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: prop_types_default.a.func
  };

  return hoist_non_react_statics_default()(C, Component);
};

/* harmony default export */ var es_withRouter = (withRouter_withRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/index.js


















// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/BrowserRouter.js
function BrowserRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BrowserRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function BrowserRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter_BrowserRouter = function (_React$Component) {
  BrowserRouter__inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    BrowserRouter__classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = BrowserRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createBrowserHistory_default()(_this.props), _temp), BrowserRouter__possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(es_Router, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(preact_compat_es["a" /* default */].Component);

BrowserRouter_BrowserRouter.propTypes = {
  basename: prop_types_default.a.string,
  forceRefresh: prop_types_default.a.bool,
  getUserConfirmation: prop_types_default.a.func,
  keyLength: prop_types_default.a.number,
  children: prop_types_default.a.node
};


/* harmony default export */ var es_BrowserRouter = (BrowserRouter_BrowserRouter);
// EXTERNAL MODULE: /apps/node_modules/history/createHashHistory.js
var createHashHistory = __webpack_require__("../../node_modules/history/createHashHistory.js");
var createHashHistory_default = /*#__PURE__*/__webpack_require__.n(createHashHistory);

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/HashRouter.js
function HashRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function HashRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function HashRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter_HashRouter = function (_React$Component) {
  HashRouter__inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    HashRouter__classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = HashRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createHashHistory_default()(_this.props), _temp), HashRouter__possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(es_Router, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(preact_compat_es["a" /* default */].Component);

HashRouter_HashRouter.propTypes = {
  basename: prop_types_default.a.string,
  getUserConfirmation: prop_types_default.a.func,
  hashType: prop_types_default.a.oneOf(['hashbang', 'noslash', 'slash']),
  children: prop_types_default.a.node
};


/* harmony default export */ var es_HashRouter = (HashRouter_HashRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Link.js
var Link__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Link__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Link__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Link__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Link__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link_Link = function (_React$Component) {
  Link__inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    Link__classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Link__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), Link__possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        props = Link__objectWithoutProperties(_props, ['replace', 'to']); // eslint-disable-line no-unused-vars

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return preact_compat_es["a" /* default */].createElement('a', Link__extends({}, props, { onClick: this.handleClick, href: href }));
  };

  return Link;
}(preact_compat_es["a" /* default */].Component);

Link_Link.propTypes = {
  onClick: prop_types_default.a.func,
  target: prop_types_default.a.string,
  replace: prop_types_default.a.bool,
  to: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]).isRequired
};
Link_Link.defaultProps = {
  replace: false
};
Link_Link.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      push: prop_types_default.a.func.isRequired,
      replace: prop_types_default.a.func.isRequired,
      createHref: prop_types_default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ var es_Link = (Link_Link);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/MemoryRouter.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/NavLink.js
var NavLink__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function NavLink__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink_NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      rest = NavLink__objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive']);

  return preact_compat_es["a" /* default */].createElement(es_Route, {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return preact_compat_es["a" /* default */].createElement(es_Link, NavLink__extends({
        to: to,
        className: isActive ? [activeClassName, className].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? NavLink__extends({}, style, activeStyle) : style
      }, rest));
    }
  });
};

NavLink_NavLink.propTypes = {
  to: es_Link.propTypes.to,
  exact: prop_types_default.a.bool,
  strict: prop_types_default.a.bool,
  location: prop_types_default.a.object,
  activeClassName: prop_types_default.a.string,
  className: prop_types_default.a.string,
  activeStyle: prop_types_default.a.object,
  style: prop_types_default.a.object,
  isActive: prop_types_default.a.func
};

NavLink_NavLink.defaultProps = {
  activeClassName: 'active'
};

/* harmony default export */ var es_NavLink = (NavLink_NavLink);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Prompt.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Redirect.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Route.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Router.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/StaticRouter.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Switch.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/matchPath.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/withRouter.js

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/index.js


























// EXTERNAL MODULE: /apps/node_modules/classnames/bind.js
var bind = __webpack_require__("../../node_modules/classnames/bind.js");
var bind_default = /*#__PURE__*/__webpack_require__.n(bind);

// EXTERNAL MODULE: /apps/packages/components/src/button.scss
var src_button = __webpack_require__("../../packages/components/src/button.scss");
var button_default = /*#__PURE__*/__webpack_require__.n(src_button);

// CONCATENATED MODULE: /apps/packages/components/src/Button.tsx
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const cx = bind["bind"](src_button);
const Button = (_a) => {
    var { class: className, secondary = false } = _a, restProps = __rest(_a, ["class", "secondary"]);
    return (Object(preact_esm["c" /* h */])("button", Object.assign({ class: cx(src_button["self"], className, { primary: !secondary, secondary }) }, restProps)));
};
/* harmony default export */ var src_Button = (Button);

// CONCATENATED MODULE: ./src/pages/Home.tsx



const Home = () => (Object(preact_esm["c" /* h */])("div", null,
    Object(preact_esm["c" /* h */])(es_Link, { to: "/whitelist" },
        Object(preact_esm["c" /* h */])(src_Button, null, "Whitelist")),
    Object(preact_esm["c" /* h */])(es_Link, { to: "/status" },
        Object(preact_esm["c" /* h */])(src_Button, null, "Status")),
    Object(preact_esm["c" /* h */])(es_Link, { to: "/linklist" },
        Object(preact_esm["c" /* h */])(src_Button, null, "LinkList"))));
/* harmony default export */ var pages_Home = (Home);

// EXTERNAL MODULE: /apps/node_modules/web3/index.js
var node_modules_web3 = __webpack_require__("../../node_modules/web3/index.js");
var web3_default = /*#__PURE__*/__webpack_require__.n(node_modules_web3);

// CONCATENATED MODULE: /apps/packages/utils/src/web3.ts

let web3_web3;
if (typeof window.web3 !== 'undefined') {
    web3_web3 = new node_modules_web3(window.web3.currentProvider);
}
else {
    web3_web3 = new node_modules_web3();
}
/* harmony default export */ var src_web3 = (web3_web3);

// CONCATENATED MODULE: /apps/packages/utils/src/index.ts


// EXTERNAL MODULE: /apps/packages/components/src/link.scss
var src_link = __webpack_require__("../../packages/components/src/link.scss");
var link_default = /*#__PURE__*/__webpack_require__.n(src_link);

// CONCATENATED MODULE: /apps/packages/components/src/Link.tsx



const Link_cx = bind["bind"](src_link);
const stopPropagation = (e) => e.stopPropagation();
const src_Link_Link = ({ class: className, link, lines = 2, style: externalStyle }) => {
    if (!(lines === 2 || lines === 8)) {
        throw new Error('Only 2 and 8 lines links are available');
    }
    return (Object(preact_esm["c" /* h */])("div", { class: bind(src_link["self"], className), style: externalStyle },
        Object(preact_esm["c" /* h */])("div", { class: src_link["title"] }, link.title),
        Object(preact_esm["c" /* h */])("div", { class: Link_cx('summary', { lines2: lines === 2, lines8: lines === 8 }) }, link.summary),
        Object(preact_esm["c" /* h */])("a", { class: src_link["link"], target: "_blank", href: link.target, onClick: stopPropagation }, link.target)));
};
/* harmony default export */ var src_Link = (src_Link_Link);

// EXTERNAL MODULE: /apps/node_modules/classnames/index.js
var classnames = __webpack_require__("../../node_modules/classnames/index.js");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: /apps/packages/components/src/paper.scss
var paper = __webpack_require__("../../packages/components/src/paper.scss");
var paper_default = /*#__PURE__*/__webpack_require__.n(paper);

// CONCATENATED MODULE: /apps/packages/components/src/Paper.tsx
var Paper___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const Paper = (_a) => {
    var { class: className } = _a, restProps = Paper___rest(_a, ["class"]);
    return (Object(preact_esm["c" /* h */])("div", Object.assign({}, restProps, { class: classnames(className, paper["self"]) })));
};
/* harmony default export */ var src_Paper = (Paper);

// EXTERNAL MODULE: /apps/packages/components/src/loader.scss
var loader = __webpack_require__("../../packages/components/src/loader.scss");
var loader_default = /*#__PURE__*/__webpack_require__.n(loader);

// CONCATENATED MODULE: /apps/packages/components/src/Loader.tsx



const Loader = ({ class: className }) => {
    return Object(preact_esm["c" /* h */])("div", { class: classnames(loader["self"], className) });
};
/* harmony default export */ var src_Loader = (Loader);

// EXTERNAL MODULE: /apps/packages/components/src/textWithLabel.scss
var textWithLabel = __webpack_require__("../../packages/components/src/textWithLabel.scss");
var textWithLabel_default = /*#__PURE__*/__webpack_require__.n(textWithLabel);

// EXTERNAL MODULE: /apps/packages/components/src/label.scss
var src_label = __webpack_require__("../../packages/components/src/label.scss");
var label_default = /*#__PURE__*/__webpack_require__.n(src_label);

// CONCATENATED MODULE: /apps/packages/components/src/Label.tsx


const Label = (props) => {
    if (props && props.children) {
        return Object(preact_esm["c" /* h */])("p", { class: src_label["self"] }, props.children);
    }
    return Object(preact_esm["c" /* h */])("p", { class: src_label["self"] });
};
/* harmony default export */ var src_Label = (Label);

// CONCATENATED MODULE: /apps/packages/components/src/TextWithLabel.tsx




const TextWithLabel = ({ label, text, class: className, children }) => {
    return (Object(preact_esm["c" /* h */])("div", { class: classnames(textWithLabel["self"], className) },
        Object(preact_esm["c" /* h */])(src_Label, null, label),
        Object(preact_esm["c" /* h */])("p", { class: textWithLabel["text"] }, text || children)));
};
/* harmony default export */ var src_TextWithLabel = (TextWithLabel);

// CONCATENATED MODULE: /apps/packages/components/src/Svg.tsx

const getSvgContentRegxp = /<svg[^>]*>(.*)<\/svg>/;
const Svg = ({ svg, size, viewBox, class: className }) => {
    let svgContent;
    const regexpResult = getSvgContentRegxp.exec(svg);
    if (regexpResult) {
        svgContent = regexpResult[1];
    }
    return (Object(preact_esm["c" /* h */])("svg", { class: className, style: { width: size }, alt: name, dangerouslySetInnerHTML: { __html: svgContent }, viewBox: viewBox, xmlns: "http://www.w3.org/2000/svg" }));
};
/* harmony default export */ var src_Svg = (Svg);

// EXTERNAL MODULE: /apps/node_modules/open-iconic/font/css/open-iconic.min.css
var open_iconic_min = __webpack_require__("../../node_modules/open-iconic/font/css/open-iconic.min.css");
var open_iconic_min_default = /*#__PURE__*/__webpack_require__.n(open_iconic_min);

// EXTERNAL MODULE: /apps/packages/components/src/icon.scss
var src_icon = __webpack_require__("../../packages/components/src/icon.scss");
var icon_default = /*#__PURE__*/__webpack_require__.n(src_icon);

// CONCATENATED MODULE: /apps/packages/components/src/Icon.tsx




const Icon = ({ name, class: className }) => (Object(preact_esm["c" /* h */])("span", { class: classnames(src_icon["self"], className, 'oi'), "data-glyph": name, "aria-hidden": "true" }));
/* harmony default export */ var src_Icon = (Icon);

// EXTERNAL MODULE: /apps/packages/components/src/tooltip.scss
var tooltip = __webpack_require__("../../packages/components/src/tooltip.scss");
var tooltip_default = /*#__PURE__*/__webpack_require__.n(tooltip);

// CONCATENATED MODULE: /apps/packages/components/src/Tooltip.tsx



const Tooltip = ({ class: className, style: externalStyle, text, children }) => (Object(preact_esm["c" /* h */])("div", { style: externalStyle, class: classnames(tooltip["self"], className) },
    children,
    text && Object(preact_esm["c" /* h */])("div", { class: tooltip["text"] }, text)));
/* harmony default export */ var src_Tooltip = (Tooltip);

// EXTERNAL MODULE: ./src/pages/Status/components/steps.scss
var steps = __webpack_require__("./src/pages/Status/components/steps.scss");
var steps_default = /*#__PURE__*/__webpack_require__.n(steps);

// CONCATENATED MODULE: ./src/pages/Status/components/Steps.tsx






const Steps_cx = bind["bind"](steps);
const cubeSvg = __webpack_require__("../../node_modules/svg-inline-loader/index.js?removeTags=true&removeSVGTagAttrs=true!./images/cube.svg");
const Step = ({ icon, state, children }) => (Object(preact_esm["c" /* h */])("div", { class: Steps_cx(steps["step"], { [state]: true }) },
    Object(preact_esm["c" /* h */])("div", { class: steps["icon"] }, icon),
    Object(preact_esm["c" /* h */])("div", { class: steps["content"] }, children)));
const Steps = ({ context, linkId, link, blockchainState }) => {
    let step0State;
    let step0Reason;
    if (blockchainState.web3Available) {
        if (blockchainState.blockNumber) {
            step0State = 'done';
        }
        else {
            step0State = 'waiting';
            step0Reason = 'Waiting for blockchain';
        }
    }
    else {
        step0State = 'disabled';
        step0Reason = 'Web is unavailable';
    }
    const step1State = link ? 'done' : 'waiting';
    const step2State = link && link.whitelisted ? 'done' : 'waiting';
    const [network] = context.split(':');
    const networkPrefix = network !== 'eth' ? `${network}.` : '';
    const [, tx] = linkId.split(':');
    const etherscanUrl = link ? `https://${networkPrefix}etherscan.io/tx/${tx}` : '';
    return (Object(preact_esm["c" /* h */])("div", { class: steps["self"] },
        Object(preact_esm["c" /* h */])("div", { class: steps["progressCotainer"] },
            Object(preact_esm["c" /* h */])("div", { class: steps["progress"] })),
        Object(preact_esm["c" /* h */])("div", { class: steps["stepsContainer"] },
            Object(preact_esm["c" /* h */])(Step, { state: step0State, icon: Object(preact_esm["c" /* h */])(src_Tooltip, { text: step0Reason },
                    Object(preact_esm["c" /* h */])(src_Icon, { class: steps["icon"], name: "eye" })) },
                Object(preact_esm["c" /* h */])("p", null, "Visible on blockchain"),
                Object(preact_esm["c" /* h */])("a", { href: etherscanUrl, target: "_blank" },
                    "Etherscan ",
                    Object(preact_esm["c" /* h */])(src_Icon, { name: "external-link" }))),
            Object(preact_esm["c" /* h */])(Step, { state: step1State, icon: Object(preact_esm["c" /* h */])(src_Svg, { svg: cubeSvg, size: "1.2em", viewBox: "0 0 23 27" }) },
                Object(preact_esm["c" /* h */])("p", null, "Userfeeds Address"),
                Object(preact_esm["c" /* h */])("span", null, "Visible to publisher")),
            Object(preact_esm["c" /* h */])(Step, { state: step2State, icon: Object(preact_esm["c" /* h */])(src_Icon, { class: steps["icon"], name: "check" }) },
                Object(preact_esm["c" /* h */])("p", null, "Put on whitelist"),
                Object(preact_esm["c" /* h */])("span", null, "All set!")))));
};
/* harmony default export */ var components_Steps = (Steps);

// EXTERNAL MODULE: ./src/pages/Status/Status.scss
var Status_Status = __webpack_require__("./src/pages/Status/Status.scss");
var Status_default = /*#__PURE__*/__webpack_require__.n(Status_Status);

// CONCATENATED MODULE: ./src/pages/Status/index.tsx
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









const heartSvg = __webpack_require__("./images/heart.svg");
const getTransactionReceipt = (tx) => {
    return new Promise((resolve, reject) => {
        src_web3.eth.getTransactionReceipt(tx, (error, result) => {
            if (error) {
                return reject(error);
            }
            resolve(result);
        });
    });
};
const getBlockNumber = () => {
    return new Promise((resolve, reject) => {
        src_web3.eth.getBlockNumber((error, currentBlockNumber) => {
            if (error) {
                return reject(error);
            }
            resolve(currentBlockNumber);
        });
    });
};
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
class pages_Status_Status extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._fetchLinks = (context, algorithm, whitelist) => __awaiter(this, void 0, void 0, function* () {
            const baseURL = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/`)
                    .then((res) => res.json());
                const whitelistedLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/?whitelist=${whitelist}`)
                    .then((res) => res.json());
                const [allLinks, whitelistedLinks] = yield Promise.all([allLinksRequest,
                    whitelistedLinksRequest]);
                const links = allLinks.items.map((link) => {
                    const whitelisted = whitelistedLinks.items.find((a) => link.id === a.id);
                    return Object.assign({}, link, { whitelisted: !!whitelisted });
                });
                return links;
            }
            catch (_) {
                return [];
            }
        });
        this._observeBlockchainState = (linkId) => __awaiter(this, void 0, void 0, function* () {
            if (!src_web3.isConnected()) {
                return this.setState({ blockchain: Object.assign({}, this.state.blockchain, { web3Available: false }) });
            }
            this.setState({ blockchain: Object.assign({}, this.state.blockchain, { web3Available: true }) });
            const [, tx] = linkId.split(':');
            let receipt;
            do {
                receipt = yield getTransactionReceipt(tx);
                yield wait(1000);
            } while (!receipt);
            const currentBlockNumber = yield getBlockNumber();
            this.setState({
                blockchain: Object.assign({}, this.state.blockchain, { blockNumber: receipt.blockNumber, currentBlockNumber }),
            });
            while (true) {
                yield wait(10000);
                const currentBlockNumber = yield getBlockNumber();
                this.setState({ blockchain: Object.assign({}, this.state.blockchain, { currentBlockNumber }) });
            }
        });
        this._findLinkById = (linkId) => (links) => {
            const link = links.find((l) => l.id === linkId);
            this.setState({ link });
            return link;
        };
        const params = new URLSearchParams(props.location.search);
        const context = params.get('context') || '';
        const algorithm = params.get('algorithm') || '';
        const whitelist = params.get('whitelist') || '';
        const linkId = params.get('linkId') || '';
        const publisherNote = params.get('publisherNote') || '';
        const widgetLocation = params.get('widgetLocation') || '';
        this.state = {
            linkId,
            context,
            algorithm,
            whitelist,
            publisherNote,
            widgetLocation,
            blockchain: {
                web3Available: false,
                blockNumber: null,
                currentBlockNumber: null,
            },
        };
        this._observeBlockchainState(linkId);
        this._fetchLinks(context, algorithm, whitelist)
            .then(this._findLinkById(linkId))
            .then((link) => {
            if (!link) {
                const setTimeoutForFetch = () => {
                    setTimeout(() => {
                        this._fetchLinks(context, algorithm, whitelist)
                            .then(this._findLinkById(linkId))
                            .then((link) => !link && setTimeoutForFetch());
                    }, 5000);
                };
                setTimeoutForFetch();
            }
        });
    }
    render() {
        if (!this.state.context) {
            return null;
        }
        const { linkId, context, link, blockchain, widgetLocation } = this.state;
        return (Object(preact_esm["c" /* h */])("div", { class: Status_Status["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Status_Status["preview"] },
                link && Object(preact_esm["c" /* h */])(src_Link, { link: link }),
                !link && Object(preact_esm["c" /* h */])("div", { class: Status_Status["loader"] },
                    Object(preact_esm["c" /* h */])(src_Loader, null))),
            Object(preact_esm["c" /* h */])(src_Paper, { class: Status_Status["content"] },
                Object(preact_esm["c" /* h */])("img", { src: heartSvg }),
                Object(preact_esm["c" /* h */])("h2", null, "Your link has been succesfully submited!"),
                Object(preact_esm["c" /* h */])("p", null, "In order to track its progress please save the link"),
                Object(preact_esm["c" /* h */])(src_TextWithLabel, { class: Status_Status["label"], label: "Link status:" },
                    Object(preact_esm["c" /* h */])("div", { class: Status_Status["linkLabel"] },
                        Object(preact_esm["c" /* h */])("a", { class: Status_Status["link"], href: window.location.href }, window.location.href),
                        Object(preact_esm["c" /* h */])(src_Button, { secondary: true, class: Status_Status["addBookmark"] }, "Add to bookmarks"))),
                Object(preact_esm["c" /* h */])(src_TextWithLabel, { class: Status_Status["label"], label: "Widget location:" },
                    Object(preact_esm["c" /* h */])("a", { href: widgetLocation }, widgetLocation)),
                Object(preact_esm["c" /* h */])(components_Steps, { linkId: linkId, context: context, link: link, blockchainState: blockchain }))));
    }
}

// EXTERNAL MODULE: /apps/node_modules/@userfeeds/core/index.js
var core = __webpack_require__("../../node_modules/@userfeeds/core/index.js");
var core_default = /*#__PURE__*/__webpack_require__.n(core);

// EXTERNAL MODULE: /apps/node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__("../../node_modules/lodash.debounce/index.js");
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);

// EXTERNAL MODULE: /apps/packages/components/src/input.scss
var input = __webpack_require__("../../packages/components/src/input.scss");
var input_default = /*#__PURE__*/__webpack_require__.n(input);

// CONCATENATED MODULE: /apps/packages/components/src/Input.tsx
var Input___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const Input_cx = bind["bind"](input);
class Input_Input extends preact_esm["a" /* Component */] {
    constructor() {
        super(...arguments);
        this._onChange = (e) => {
            this.props.onChange(e.target.value, this.props.name);
        };
        this._onInputRef = (ref) => this.input = ref;
        this._onPlaceholderClick = () => {
            if (this.input) {
                this.input.focus();
            }
        };
    }
    render(_a) {
        var { class: className, placeholder, errorMessage, value, onChange, multiline, disabled = false } = _a, restProps = Input___rest(_a, ["class", "placeholder", "errorMessage", "value", "onChange", "multiline", "disabled"]);
        return (Object(preact_esm["c" /* h */])("div", { class: Input_cx(input["self"], { invalid: !!errorMessage }) },
            !multiline ? (Object(preact_esm["c" /* h */])("input", Object.assign({ ref: this._onInputRef, class: input["input"], value: value, disabled: disabled, required: true, onInput: this._onChange }, restProps))) : (Object(preact_esm["c" /* h */])("textarea", Object.assign({ ref: this._onInputRef, class: input["input"], value: value, required: true, onInput: this._onChange, rows: 3 }, restProps))),
            Object(preact_esm["c" /* h */])("span", { class: input["placeholder"], onClick: this._onPlaceholderClick }, placeholder),
            errorMessage && Object(preact_esm["c" /* h */])("span", { class: input["error"] }, errorMessage)));
    }
}

// EXTERNAL MODULE: /apps/packages/components/src/adsList.scss
var adsList = __webpack_require__("../../packages/components/src/adsList.scss");
var adsList_default = /*#__PURE__*/__webpack_require__.n(adsList);

// CONCATENATED MODULE: /apps/packages/components/src/AdsList.tsx



const AdsList_noop = () => null;
const Ad = ({ ad, onClick }) => (Object(preact_esm["c" /* h */])("div", { class: adsList["row"] },
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])("div", null,
            "URL: ",
            Object(preact_esm["c" /* h */])("a", { href: ad.target }, ad.target)),
        Object(preact_esm["c" /* h */])("div", null,
            "score: ",
            web3.fromWei(ad.score, 'ether')),
        Object(preact_esm["c" /* h */])("div", null, ad.title),
        Object(preact_esm["c" /* h */])("div", null, ad.summary)),
    Object(preact_esm["c" /* h */])("div", { class: adsList["button"] },
        Object(preact_esm["c" /* h */])(src_Button, { onClick: onClick.bind(null, ad), disabled: ad.whitelisted }, "Add to whitelist"))));
const AdsList = ({ ads = [], onItemClick = AdsList_noop }) => (Object(preact_esm["c" /* h */])("div", { class: adsList["self"] }, ads.map((ad) => (Object(preact_esm["c" /* h */])(Ad, { ad: ad, onClick: onItemClick })))));
/* harmony default export */ var src_AdsList = (AdsList);

// EXTERNAL MODULE: ./src/pages/Whitelist.scss
var Whitelist = __webpack_require__("./src/pages/Whitelist.scss");
var Whitelist_default = /*#__PURE__*/__webpack_require__.n(Whitelist);

// CONCATENATED MODULE: ./src/pages/Whitelist.tsx
var Whitelist___awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



// import CircularProgress from 'material-ui/CircularProgress';




class Whitelist_Creator extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._onContextChange = (context) => {
            this.setState({ context });
            this._fetchLinks();
        };
        this._onWhitelistChange = (whitelist) => {
            this.setState({ whitelist });
            this._fetchLinks();
        };
        this._fetchLinks = lodash_debounce_default()(() => Whitelist___awaiter(this, void 0, void 0, function* () {
            const { context, algorithm, whitelist } = this.state;
            this.setState({ fetching: true });
            const baseURL = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/`)
                    .then((res) => res.json());
                const whitelistedLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/?whitelist=${whitelist}`)
                    .then((res) => res.json());
                const [allLinks, whitelistedLinks] = yield Promise.all([
                    allLinksRequest,
                    whitelistedLinksRequest,
                ]);
                const links = allLinks.items.map((link) => {
                    const whitelisted = !!whitelistedLinks.items.find((a) => link.id === a.id);
                    return Object.assign({}, link, { whitelisted });
                });
                this.setState({ links, fetching: false });
            }
            catch (_) {
                this.setState({ fetching: false });
            }
        }), 500);
        this._onLinkClick = (link) => {
            const [_, address] = this.state.whitelist.split(':');
            const claim = {
                claim: { target: link.id },
                credits: [{
                        type: 'interface',
                        value: window.location.href,
                    }],
            };
            core_default.a.ethereum.claims.sendClaim(address, claim);
        };
        const params = new URLSearchParams(props.location.search);
        this.state = {
            links: [],
            fetching: false,
            context: params.get('context') || '',
            algorithm: params.get('algorithm') || 'links',
            whitelist: params.get('whitelist') || '',
            contextFromParams: params.has('context'),
            whitelistFromParams: params.has('whitelist'),
        };
    }
    componentWillMount() {
        if (this.state.contextFromParams) {
            this._fetchLinks();
        }
    }
    render() {
        return (Object(preact_esm["c" /* h */])("div", { class: Whitelist["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Whitelist["paper"] },
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Userfeed ID", value: this.state.context, onChange: this._onContextChange, disabled: this.state.contextFromParams }),
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Whitelist ID", value: this.state.whitelist, onChange: this._onWhitelistChange, disabled: this.state.whitelistFromParams }),
                Object(preact_esm["c" /* h */])(src_AdsList, { ads: this.state.links, onItemClick: this._onLinkClick }))));
    }
}

// EXTERNAL MODULE: /apps/packages/components/src/linkList.scss
var linkList = __webpack_require__("../../packages/components/src/linkList.scss");
var linkList_default = /*#__PURE__*/__webpack_require__.n(linkList);

// CONCATENATED MODULE: /apps/packages/components/src/LinkList.tsx


const LinkList_noop = () => null;
const LinkList_Link = ({ link }) => (Object(preact_esm["c" /* h */])("div", { class: linkList["row"] },
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])("div", null,
            "URL: ",
            Object(preact_esm["c" /* h */])("a", { href: link.target }, link.target)),
        Object(preact_esm["c" /* h */])("div", null, link.summary))));
const LinkList_LinkList = ({ links = [] }) => (Object(preact_esm["c" /* h */])("div", { class: linkList["self"] }, links.map((link) => (Object(preact_esm["c" /* h */])(LinkList_Link, { link: link })))));
/* harmony default export */ var src_LinkList = (LinkList_LinkList);

// CONCATENATED MODULE: ./src/pages/LinkList.tsx
var LinkList___awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


// import CircularProgress from 'material-ui/CircularProgress';




class pages_LinkList_LinkList extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._onContextChange = (context) => {
            this.setState({ context });
            this._fetchLinks();
        };
        this._fetchLinks = lodash_debounce_default()(() => LinkList___awaiter(this, void 0, void 0, function* () {
            const { context } = this.state;
            this.setState({ fetching: true });
            const fetchUrl = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${fetchUrl}/${context}/authored/?type=link`)
                    .then((res) => res.json());
                const [allLinks] = yield Promise.all([allLinksRequest]);
                this.setState({ links: allLinks.items, fetching: false });
                return allLinks;
            }
            catch (_) {
                this.setState({ fetching: false });
                return null;
            }
        }), 500);
        const params = new URLSearchParams(props.location.search);
        this.state = {
            links: [],
            fetching: false,
            context: params.get('context') || '',
            algorithm: params.get('algorithm') || 'links',
            contextFromParams: params.has('context'),
        };
    }
    componentWillMount() {
        if (this.state.contextFromParams) {
            this._fetchLinks();
        }
    }
    render() {
        return (Object(preact_esm["c" /* h */])("div", { class: Whitelist["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Whitelist["paper"] },
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Advertiser ID", value: this.state.context, onChange: this._onContextChange, disabled: this.state.contextFromParams }),
                Object(preact_esm["c" /* h */])(src_LinkList, { links: this.state.links }))));
    }
}

// CONCATENATED MODULE: ./src/App.tsx






const App = () => (Object(preact_esm["c" /* h */])(es_HashRouter, null,
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])(es_Route, { exact: true, path: "/", component: pages_Home }),
        Object(preact_esm["c" /* h */])(es_Route, { path: "/status", component: pages_Status_Status }),
        Object(preact_esm["c" /* h */])(es_Route, { path: "/whitelist", component: Whitelist_Creator }),
        Object(preact_esm["c" /* h */])(es_Route, { path: "/linklist", component: pages_LinkList_LinkList }))));
/* harmony default export */ var src_App = (App);

// EXTERNAL MODULE: ./styles/all.scss
var styles_all = __webpack_require__("./styles/all.scss");
var all_default = /*#__PURE__*/__webpack_require__.n(styles_all);

// CONCATENATED MODULE: ./src/index.tsx




const root = document.querySelector('.root');
if (root) {
    Object(preact_esm["e" /* render */])(Object(preact_esm["c" /* h */])(src_App, null), root);
}


/***/ }),

/***/ "./src/pages/Status/Status.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/Status.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Status.scss", function() {
			var newContent = require("!!../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Status.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/pages/Status/components/steps.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/components/steps.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./steps.scss", function() {
			var newContent = require("!!../../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./steps.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/pages/Whitelist.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Whitelist.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Whitelist.scss", function() {
			var newContent = require("!!../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Whitelist.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./styles/all.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./styles/all.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./all.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./all.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTY4MzAwOGJlZWFhMjcyODQ4ZTIiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL2V0aGVyZXVtQ2xhaW1zLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy91dGlscy9jb250cmFjdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9iaW5kLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy11dGYxNi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jZmIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWVjYi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtYW5zaXg5MjMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzEwMTI2LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtbm9wYWRkaW5nLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC16ZXJvcGFkZGluZy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LWxlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JpcGVtZDE2MC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3RyaXBsZWRlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3M/YWM1YSIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3M/Y2U2ZSIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuZW90Iiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5vdGYiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLnN2ZyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMudHRmIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy53b2ZmIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJlYWN0LWNvbXBhdC9kaXN0L3ByZWFjdC1jb21wYXQuZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QuZXNtLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL2ltYWdlcy9jdWJlLnN2ZyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzPzE4YWQiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2J1dHRvbi5zY3NzPzZkZGMiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2ljb24uc2Nzcz8yODNhIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzP2Y0MmQiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3M/M2MyZSIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzPzc1ZTIiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3M/MTc3NyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3M/OWI5MiIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2Nzcz82YTEwIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90ZXh0V2l0aExhYmVsLnNjc3M/ZmI3ZCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdG9vbHRpcC5zY3NzP2UxNTciLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2Nzcz81NDlmIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9zdGVwcy5zY3NzP2MxY2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzP2M3ODQiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL2FsbC5zY3NzPzQyN2YiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy91dGY4L3V0ZjguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb24iLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2FkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9ib29sLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9jb2Rlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2R5bmFtaWNieXRlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Zvcm1hdHRlcnMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9pbnQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9wYXJhbS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3JlYWwuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS90eXBlLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdWludC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3VyZWFsLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvYnJvd3Nlci14aHIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9zaGEzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi92ZXJzaW9uLmpzb24iLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9hbGxldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2JhdGNoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9jb250cmFjdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXJyb3JzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9ldmVudC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXh0ZW5kLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Zvcm1hdHRlcnMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9odHRwcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2liYW4uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2lwY3Byb3ZpZGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9qc29ucnBjLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZGIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZXRoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL25ldC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9wZXJzb25hbC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zaGguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvc3dhcm0uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvd2F0Y2hlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbmFtZXJlZy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3JlcXVlc3RtYW5hZ2VyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvdHJhbnNmZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMveGhyMi9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rLnNjc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xvYWRlci5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9wYXBlci5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90ZXh0V2l0aExhYmVsLnNjc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2NzcyIsIndlYnBhY2s6Ly8vLi9pbWFnZXMvaGVhcnQuc3ZnIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0Jyb3dzZXJSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0hhc2hSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL05hdkxpbmsuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9CdXR0b24udHN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9Ib21lLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvdXRpbHMvc3JjL3dlYjMudHMiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL3V0aWxzL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGluay50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1BhcGVyLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTG9hZGVyLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGFiZWwudHN4Iiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9UZXh0V2l0aExhYmVsLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvU3ZnLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvSWNvbi50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1Rvb2x0aXAudHN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9TdGVwcy50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1N0YXR1cy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0lucHV0LnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvQWRzTGlzdC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1doaXRlbGlzdC50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0xpbmtMaXN0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvTGlua0xpc3QudHN4Iiwid2VicGFjazovLy8uL3NyYy9BcHAudHN4Iiwid2VicGFjazovLy8uL3NyYy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL2FsbC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7OztBQ05BLE9BQU8sd0JBQXdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9DQUFvQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0NBQW9DO0FBQ3pDLEtBQUssK0JBQStCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUssa0RBQWtEO0FBQ3ZELEtBQUssb0RBQW9EO0FBQ3pELEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsS0FBSyxrREFBa0Q7QUFDdkQsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDbEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNqSEE7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFV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RixDQUFDLEc7Ozs7Ozs7QUM5SUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDakJELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDM0VELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUMzUUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQzdFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDbkhELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUN6REQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDdkNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQ3JERCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUNoREQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDM0NELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDdkNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDN0JELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQzFJRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa2RBQWtkLCtCQUErQjtBQUNqZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUVBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUNsVUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQ2xGRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDbFVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBOzs7Ozs7Ozs7QUMzRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsMkI7Ozs7Ozs7O0FDdERBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7OztBQ3REQTs7QUFF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Q0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCLEVBQUU7QUFDckU7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbERBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUY7QUFDckY7Ozs7Ozs7O0FDbDhCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQy9WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0SkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdEZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUNuUEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNsVEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLDBFQUEwRSx1QkFBdUIsRUFBRTtBQUNuRztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsdUJBQXVCLEVBQUU7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7Ozs7Ozs7O0FDMVJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsQ0FBQztBQUNELDBHQUE0RDtBQUM1RDs7QUFFQSx5RUFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDNUpBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCLEVBQUUsYUFBYSxHQUFHLFVBQVUsTUFBTTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUNqT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSyxFOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEtBQUssS0FBSztBQUN2QyxvQkFBb0IsYUFBYSxLQUFLLE9BQU8sT0FBTztBQUNwRCxvQkFBb0IsV0FBVyxLQUFLLE1BQU0sT0FBTztBQUNqRCxvQkFBb0IsV0FBVyxLQUFLLE1BQU0sT0FBTztBQUNqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCOztBQUVuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0M7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7OztBQUdqRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQzdNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7Ozs7Ozs7OztBQ25GQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ25LQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDakVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGNBQWMsRUFBRTtBQUMvRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaldBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ25EQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBOzs7Ozs7OztBQ2xIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDOUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTs7Ozs7Ozs7QUNoSkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7QUFHMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULDRCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBOzs7Ozs7Ozs7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDUEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7Ozs7Ozs7O0FDMUZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBOzs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9hcHBzL2xpbmtzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHN4XCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGE2ODMwMDhiZWVhYTI3Mjg0OGUyIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXRoZXJldW06IHtcbiAgICBjbGFpbXM6IHJlcXVpcmUoJy4vc3JjL2V0aGVyZXVtQ2xhaW1zJyksXG4gIH0sXG4gIHV0aWxzOiByZXF1aXJlKCcuL3NyYy91dGlscycpLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgeyBnZXRDdXJyZW50TmV0d29ya05hbWUgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHtcbiAgcGF5YWJsZUFiaSxcbiAgbm90cGF5YWJsZUFiaSxcbiAgZ2V0Q29udHJhY3RBZGRyZXNzLFxufSA9IHJlcXVpcmUoJy4vdXRpbHMvY29udHJhY3QnKTtcblxuZnVuY3Rpb24gc2VuZFBheWFibGVDbGFpbShhZGRyZXNzLCBjbGFpbSwgdmFsdWUpIHtcbiAgY29uc3QgY29udHJhY3QgPSB3ZWIzLmV0aC5jb250cmFjdChwYXlhYmxlQWJpKVxuICAgIC5hdChnZXRDb250cmFjdEFkZHJlc3MoZ2V0Q3VycmVudE5ldHdvcmtOYW1lKCksIHRydWUpKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnRyYWN0LnBvc3QoXG4gICAgICBhZGRyZXNzLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoY2xhaW0pLFxuICAgICAgeyB2YWx1ZTogd2ViMy50b1dlaSh2YWx1ZSwgJ2V0aGVyJykgfSxcbiAgICAgIChlcnJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9LFxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZW5kTm90cGF5YWJsZUNsYWltKGFkZHJlc3MsIGNsYWltKSB7XG4gIGNvbnN0IGNvbnRyYWN0ID0gd2ViMy5ldGguY29udHJhY3Qobm90cGF5YWJsZUFiaSlcbiAgICAuYXQoZ2V0Q29udHJhY3RBZGRyZXNzKGdldEN1cnJlbnROZXR3b3JrTmFtZSgpLCBmYWxzZSkpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29udHJhY3QucG9zdChcbiAgICAgIEpTT04uc3RyaW5naWZ5KGNsYWltKSxcbiAgICAgIChlcnJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9LFxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZW5kQ2xhaW0oYWRkcmVzcywgY2xhaW0sIHZhbHVlKSB7XG4gIGNvbnN0IHBheWFibGUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXG4gIHJldHVybiBwYXlhYmxlXG4gICAgPyBzZW5kUGF5YWJsZUNsYWltKGFkZHJlc3MsIGNsYWltLCB2YWx1ZSlcbiAgICA6IHNlbmROb3RwYXlhYmxlQ2xhaW0oYWRkcmVzcywgY2xhaW0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2VuZENsYWltLFxuICBzZW5kUGF5YWJsZUNsYWltLFxuICBzZW5kTm90cGF5YWJsZUNsYWltLFxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvZXRoZXJldW1DbGFpbXMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL2V0aGVyZXVtQ2xhaW1zLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuY29uc3QgcGF5YWJsZUNvbnRyYWN0QWRkcmVzc01hcHBpbmcgPSB7XG4gIHJvcHN0ZW46ICcweGE4NDVjNjg2YTY5NmMzZDMzOTg4OTE3YzM4N2Q4YWI5MzljNjYyMjYnLFxuICByaW5rZWJ5OiAnMHgwYTQ4YWM4MjYzZDlkNzk3NjhkMTBjZjlkN2U4MmExOWM0OWYwMDAyJyxcbn07XG5cbmNvbnN0IG5vdHBheWFibGVDb250cmFjdEFkZHJlc3NNYXBwaW5nID0ge1xuICByb3BzdGVuOiAnMHg1YzNmZTZiOTRiNTdjMWUyOTQwMDA0MDMzNDBmMTJmMDgzZTcxYjgzJyxcbiAgcmlua2VieTogJzB4MDlkY2RmMzRlMGMyOGIxMDZmZGZlNTEwMDljYjcxYWU5MmJmOGJiYycsXG59O1xuXG5mdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3MobmV0d29ya05hbWUsIHBheWFibGUgPSB0cnVlKSB7XG4gIGxldCBjb250cmFjdDtcbiAgaWYgKHBheWFibGUpIHtcbiAgICBjb250cmFjdCA9IHBheWFibGVDb250cmFjdEFkZHJlc3NNYXBwaW5nW25ldHdvcmtOYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjb250cmFjdCA9IG5vdHBheWFibGVDb250cmFjdEFkZHJlc3NNYXBwaW5nW25ldHdvcmtOYW1lXTtcbiAgfVxuXG4gIGlmICghY29udHJhY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgfVxuXG4gIHJldHVybiBjb250cmFjdDtcbn1cblxuY29uc3QgcGF5YWJsZUFiaSA9IFt7XG4gIGNvbnN0YW50OiBmYWxzZSxcbiAgaW5wdXRzOiBbXG4gICAgeyBuYW1lOiAndXNlcmZlZWQnLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICB7IG5hbWU6ICdkYXRhJywgdHlwZTogJ3N0cmluZycgfSxcbiAgXSxcbiAgbmFtZTogJ3Bvc3QnLFxuICBvdXRwdXRzOiBbXSxcbiAgcGF5YWJsZTogdHJ1ZSxcbiAgdHlwZTogJ2Z1bmN0aW9uJyxcbn0sIHtcbiAgYW5vbnltb3VzOiBmYWxzZSxcbiAgaW5wdXRzOiBbXG4gICAgeyBuYW1lOiAnc2VuZGVyJywgdHlwZTogJ2FkZHJlc3MnLCBpbmRleGVkOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogJ3VzZXJmZWVkJywgdHlwZTogJ2FkZHJlc3MnLCBpbmRleGVkOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogJ2RhdGEnLCB0eXBlOiAnc3RyaW5nJywgaW5kZXhlZDogZmFsc2UgfSxcbiAgXSxcbiAgbmFtZTogJ0NsYWltJyxcbiAgdHlwZTogJ2V2ZW50Jyxcbn1dO1xuXG5jb25zdCBub3RwYXlhYmxlQWJpID0gW3tcbiAgY29uc3RhbnQ6IGZhbHNlLFxuICBpbnB1dHM6IFtcbiAgICB7IG5hbWU6ICdkYXRhJywgdHlwZTogJ3N0cmluZycgfSxcbiAgXSxcbiAgbmFtZTogJ3Bvc3QnLFxuICBvdXRwdXRzOiBbXSxcbiAgcGF5YWJsZTogZmFsc2UsXG4gIHR5cGU6ICdmdW5jdGlvbicsXG59LCB7XG4gIGFub255bW91czogZmFsc2UsXG4gIGlucHV0czogW1xuICAgIHsgbmFtZTogJ3NlbmRlcicsIHR5cGU6ICdhZGRyZXNzJywgaW5kZXhlZDogZmFsc2UgfSxcbiAgICB7IG5hbWU6ICdkYXRhJywgdHlwZTogJ3N0cmluZycsIGluZGV4ZWQ6IGZhbHNlIH0sXG4gIF0sXG4gIG5hbWU6ICdDbGFpbScsXG4gIHR5cGU6ICdldmVudCdcbn1dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGF5YWJsZUFiaSxcbiAgbm90cGF5YWJsZUFiaSxcbiAgZ2V0Q29udHJhY3RBZGRyZXNzLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL3V0aWxzL2NvbnRyYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy91dGlscy9jb250cmFjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmNvbnN0IG5ldHdvcmtNYXBwaW5nID0ge1xuICAnMSc6ICdldGhlcmV1bScsXG4gICczJzogJ3JvcHN0ZW4nLFxuICAnNCc6ICdyaW5rZWJ5JyxcbiAgJzQyJzogJ2tvdmFuJyxcbn07XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnROZXR3b3JrTmFtZSgpIHtcbiAgaWYgKCF3ZWIzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3ZWIzIG5vdCBhdmFpbGFibGUnKTtcbiAgfVxuXG4gIHJldHVybiBuZXR3b3JrTWFwcGluZ1t3ZWIzLnZlcnNpb24ubmV0d29ya107XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDdXJyZW50TmV0d29ya05hbWUsXG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy91dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvdXRpbHMvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIGJpZ251bWJlci5qcyB2Mi4wLjcgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzL0xJQ0VOQ0UgKi9cblxuOyhmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLypcbiAgICAgIGJpZ251bWJlci5qcyB2Mi4wLjdcbiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXG4gICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcbiAgICAgIENvcHlyaWdodCAoYykgMjAxNSBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxuICAgICAgTUlUIEV4cGF0IExpY2VuY2VcbiAgICAqL1xuXG5cbiAgICB2YXIgQmlnTnVtYmVyLCBjcnlwdG8sIHBhcnNlTnVtZXJpYyxcbiAgICAgICAgaXNOdW1lcmljID0gL14tPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2ksXG4gICAgICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBub3RCb29sID0gJyBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdCcsXG4gICAgICAgIHJvdW5kaW5nTW9kZSA9ICdyb3VuZGluZyBtb2RlJyxcbiAgICAgICAgdG9vTWFueURpZ2l0cyA9ICdudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0cycsXG4gICAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nLFxuICAgICAgICBCQVNFID0gMWUxNCxcbiAgICAgICAgTE9HX0JBU0UgPSAxNCxcbiAgICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcbiAgICAgICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcbiAgICAgICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcbiAgICAgICAgU1FSVF9CQVNFID0gMWU3LFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxuICAgICAgICAgKiB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24sIGJleW9uZCB3aGljaCBhblxuICAgICAgICAgKiBleGNlcHRpb24gaXMgdGhyb3duIChpZiBFUlJPUlMgaXMgdHJ1ZSkuXG4gICAgICAgICAqL1xuICAgICAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxuXG5cbiAgICAvKlxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFub3RoZXIoY29uZmlnT2JqKSB7XG4gICAgICAgIHZhciBkaXYsXG5cbiAgICAgICAgICAgIC8vIGlkIHRyYWNrcyB0aGUgY2FsbGVyIGZ1bmN0aW9uLCBzbyBpdHMgbmFtZSBjYW4gYmUgaW5jbHVkZWQgaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgICAgICBpZCA9IDAsXG4gICAgICAgICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSxcbiAgICAgICAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXG5cblxuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRElUQUJMRSBERUZBVUxUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxuICAgICAgICAgICAgICogVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5jb25maWcuXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXG4gICAgICAgICAgICAgKiB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXG4gICAgICAgICAgICAgKiBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXG4gICAgICAgICAgICAgKiBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxuICAgICAgICAgICAgICogQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxuICAgICAgICAgICAgICogRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxuICAgICAgICAgICAgICogSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cbiAgICAgICAgICAgICAqIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cbiAgICAgICAgICAgICAqIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cbiAgICAgICAgICAgICAqIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXG4gICAgICAgICAgICAgKiBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxuXG4gICAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cblxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogLTdcbiAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXG5cbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxuICAgICAgICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxuXG4gICAgICAgICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxuXG4gICAgICAgICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcbiAgICAgICAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxuXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcbiAgICAgICAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cbiAgICAgICAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcblxuICAgICAgICAgICAgLy8gV2hldGhlciBCaWdOdW1iZXIgRXJyb3JzIGFyZSBldmVyIHRocm93bi5cbiAgICAgICAgICAgIEVSUk9SUyA9IHRydWUsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxuXG4gICAgICAgICAgICAvLyBDaGFuZ2UgdG8gaW50VmFsaWRhdG9yTm9FcnJvcnMgaWYgRVJST1JTIGlzIGZhbHNlLlxuICAgICAgICAgICAgaXNWYWxpZEludCA9IGludFZhbGlkYXRvcldpdGhFcnJvcnMsICAgICAvLyBpbnRWYWxpZGF0b3JXaXRoRXJyb3JzL2ludFZhbGlkYXRvck5vRXJyb3JzXG5cbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cbiAgICAgICAgICAgICAqIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxuICAgICAgICAgICAgICogVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cbiAgICAgICAgICAgICAqIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxuICAgICAgICAgICAgICogICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxuICAgICAgICAgICAgICogRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxuICAgICAgICAgICAgICogSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxuICAgICAgICAgICAgICogbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAqIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcblxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSB0b1Bvd2VyIG9wZXJhdGlvbi5cbiAgICAgICAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDEwMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxuXG4gICAgICAgICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXG4gICAgICAgICAgICBGT1JNQVQgPSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxuICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplOiAzLFxuICAgICAgICAgICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxuICAgICAgICAgICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwXG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgICAgIC8vIENPTlNUUlVDVE9SXG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cbiAgICAgICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxuICAgICAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygbi4gSW50ZWdlciwgMiB0byA2NCBpbmNsdXNpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBCaWdOdW1iZXIoIG4sIGIgKSB7XG4gICAgICAgICAgICB2YXIgYywgZSwgaSwgbnVtLCBsZW4sIHN0cixcbiAgICAgICAgICAgICAgICB4ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIHVzYWdlIHdpdGhvdXQgbmV3LlxuICAgICAgICAgICAgaWYgKCAhKCB4IGluc3RhbmNlb2YgQmlnTnVtYmVyICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAnQmlnTnVtYmVyKCkgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IG5ldzoge259J1xuICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCAyNiwgJ2NvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBuZXcnLCBuICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIG4sIGIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBiYXNlIG5vdCBhbiBpbnRlZ2VyOiB7Yn0nXG4gICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIGJhc2Ugb3V0IG9mIHJhbmdlOiB7Yn0nXG4gICAgICAgICAgICBpZiAoIGIgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggYiwgMiwgNjQsIGlkLCAnYmFzZScgKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIER1cGxpY2F0ZS5cbiAgICAgICAgICAgICAgICBpZiAoIG4gaW5zdGFuY2VvZiBCaWdOdW1iZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHgucyA9IG4ucztcbiAgICAgICAgICAgICAgICAgICAgeC5lID0gbi5lO1xuICAgICAgICAgICAgICAgICAgICB4LmMgPSAoIG4gPSBuLmMgKSA/IG4uc2xpY2UoKSA6IG47XG4gICAgICAgICAgICAgICAgICAgIGlkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggKCBudW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJyApICYmIG4gKiAwID09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHgucyA9IDEgLyBuIDwgMCA/ICggbiA9IC1uLCAtMSApIDogMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPT09IH5+biApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGUgPSAwLCBpID0gbjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LmUgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgeC5jID0gW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gbiArICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzTnVtZXJpYy50ZXN0KCBzdHIgPSBuICsgJycgKSApIHJldHVybiBwYXJzZU51bWVyaWMoIHgsIHN0ciwgbnVtICk7XG4gICAgICAgICAgICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/ICggc3RyID0gc3RyLnNsaWNlKDEpLCAtMSApIDogMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSBiIHwgMDtcbiAgICAgICAgICAgICAgICBzdHIgPSBuICsgJyc7XG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgcmV0dXJuIHZhbHVlIGlzIHJvdW5kZWQgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICBpZiAoIGIgPT0gMTAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKCBuIGluc3RhbmNlb2YgQmlnTnVtYmVyID8gbiA6IHN0ciApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoIHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAvLyBBbnkgbnVtYmVyIGluIGV4cG9uZW50aWFsIGZvcm0gd2lsbCBmYWlsIGR1ZSB0byB0aGUgW0VlXVsrLV0uXG4gICAgICAgICAgICAgICAgaWYgKCAoIG51bSA9IHR5cGVvZiBuID09ICdudW1iZXInICkgJiYgbiAqIDAgIT0gMCB8fFxuICAgICAgICAgICAgICAgICAgISggbmV3IFJlZ0V4cCggJ14tPycgKyAoIGMgPSAnWycgKyBBTFBIQUJFVC5zbGljZSggMCwgYiApICsgJ10rJyApICtcbiAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIGMgKyAnKT8kJyxiIDwgMzcgPyAnaScgOiAnJyApICkudGVzdChzdHIpICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKCB4LCBzdHIsIG51bSwgYiApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gMSAvIG4gPCAwID8gKCBzdHIgPSBzdHIuc2xpY2UoMSksIC0xICkgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggRVJST1JTICYmIHN0ci5yZXBsYWNlKCAvXjBcXC4wKnxcXC4vLCAnJyApLmxlbmd0aCA+IDE1ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG51bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSggaWQsIHRvb01hbnlEaWdpdHMsIG4gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBudW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RyID0gY29udmVydEJhc2UoIHN0ciwgMTAsIGIsIHgucyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xuICAgICAgICAgICAgaWYgKCAoIGUgPSBzdHIuaW5kZXhPZignLicpICkgPiAtMSApIHN0ciA9IHN0ci5yZXBsYWNlKCAnLicsICcnICk7XG5cbiAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XG4gICAgICAgICAgICBpZiAoICggaSA9IHN0ci5zZWFyY2goIC9lL2kgKSApID4gMCApIHtcblxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICBpZiAoIGUgPCAwICkgZSA9IGk7XG4gICAgICAgICAgICAgICAgZSArPSArc3RyLnNsaWNlKCBpICsgMSApO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoIDAsIGkgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgLy8gSW50ZWdlci5cbiAgICAgICAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKysgKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxuICAgICAgICAgICAgZm9yICggbGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODsgKTtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggaSwgbGVuICsgMSApO1xuXG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIERpc2FsbG93IG51bWJlcnMgd2l0aCBvdmVyIDE1IHNpZ25pZmljYW50IGRpZ2l0cyBpZiBudW1iZXIgdHlwZS5cbiAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG51bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXG4gICAgICAgICAgICAgICAgaWYgKCBudW0gJiYgRVJST1JTICYmIGxlbiA+IDE1ICkgcmFpc2UoIGlkLCB0b29NYW55RGlnaXRzLCB4LnMgKiBuICk7XG5cbiAgICAgICAgICAgICAgICBlID0gZSAtIGkgLSAxO1xuXG4gICAgICAgICAgICAgICAgIC8vIE92ZXJmbG93P1xuICAgICAgICAgICAgICAgIGlmICggZSA+IE1BWF9FWFAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5maW5pdHkuXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBVbmRlcmZsb3c/XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IE1JTl9FWFAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gWmVyby5cbiAgICAgICAgICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeC5lID0gZTtcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcblxuICAgICAgICAgICAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICBpID0gKCBlICsgMSApICUgTE9HX0JBU0U7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZSA8IDAgKSBpICs9IExPR19CQVNFO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IGxlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCggK3N0ci5zbGljZSggMCwgaSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jLnB1c2goICtzdHIuc2xpY2UoIGksIGkgKz0gTE9HX0JBU0UgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gTE9HX0JBU0UgLSBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSBsZW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGktLTsgc3RyICs9ICcwJyApO1xuICAgICAgICAgICAgICAgICAgICB4LmMucHVzaCggK3N0ciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBaZXJvLlxuICAgICAgICAgICAgICAgIHguYyA9IFsgeC5lID0gMCBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZCA9IDA7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcblxuXG4gICAgICAgIEJpZ051bWJlci5hbm90aGVyID0gYW5vdGhlcjtcblxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XG4gICAgICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XG4gICAgICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XG4gICAgICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgb3IgYW4gYXJndW1lbnQgbGlzdCwgd2l0aCBvbmUgb3IgbWFueSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgb3JcbiAgICAgICAgICogcGFyYW1ldGVycyByZXNwZWN0aXZlbHk6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgREVDSU1BTF9QTEFDRVMgIHtudW1iZXJ9ICBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmVcbiAgICAgICAgICogICBST1VORElOR19NT0RFICAge251bWJlcn0gIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmVcbiAgICAgICAgICogICBFWFBPTkVOVElBTF9BVCAge251bWJlcnxudW1iZXJbXX0gIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ludGVnZXIgLU1BWCB0byAwIGluY2wuLCAwIHRvIE1BWCBpbmNsLl1cbiAgICAgICAgICogICBSQU5HRSAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsLiwgaW50ZWdlciAxIHRvIE1BWCBpbmNsLl1cbiAgICAgICAgICogICBFUlJPUlMgICAgICAgICAge2Jvb2xlYW58bnVtYmVyfSAgIHRydWUsIGZhbHNlLCAxIG9yIDBcbiAgICAgICAgICogICBDUllQVE8gICAgICAgICAge2Jvb2xlYW58bnVtYmVyfSAgIHRydWUsIGZhbHNlLCAxIG9yIDBcbiAgICAgICAgICogICBNT0RVTE9fTU9ERSAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOSBpbmNsdXNpdmVcbiAgICAgICAgICogICBQT1dfUFJFQ0lTSU9OICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYIGluY2x1c2l2ZVxuICAgICAgICAgKiAgIEZPUk1BVCAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgU2VlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXRcbiAgICAgICAgICogICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqICAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiAgICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cbiAgICAgICAgICogICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XG4gICAgICAgICAqICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxuICAgICAgICAgKiAgICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cbiAgICAgICAgICpcbiAgICAgICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcbiAgICAgICAgICpcbiAgICAgICAgICogRS5nLlxuICAgICAgICAgKiBCaWdOdW1iZXIuY29uZmlnKDIwLCA0KSBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQmlnTnVtYmVyLmNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2LCBwLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIHIgPSB7fSxcbiAgICAgICAgICAgICAgICBhID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIG8gPSBhWzBdLFxuICAgICAgICAgICAgICAgIGhhcyA9IG8gJiYgdHlwZW9mIG8gPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyBpZiAoIG8uaGFzT3duUHJvcGVydHkocCkgKSByZXR1cm4gKCB2ID0gb1twXSApICE9IG51bGw7IH1cbiAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyBpZiAoIGEubGVuZ3RoID4gaSApIHJldHVybiAoIHYgPSBhW2krK10gKSAhPSBudWxsOyB9O1xuXG4gICAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgREVDSU1BTF9QTEFDRVMgbm90IGFuIGludGVnZXI6IHt2fSdcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBERUNJTUFMX1BMQUNFUyBvdXQgb2YgcmFuZ2U6IHt2fSdcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0RFQ0lNQUxfUExBQ0VTJyApICYmIGlzVmFsaWRJbnQoIHYsIDAsIE1BWCwgMiwgcCApICkge1xuICAgICAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gREVDSU1BTF9QTEFDRVM7XG5cbiAgICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cbiAgICAgICAgICAgIC8vICdjb25maWcoKSBST1VORElOR19NT0RFIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUk9VTkRJTkdfTU9ERSBvdXQgb2YgcmFuZ2U6IHt2fSdcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ1JPVU5ESU5HX01PREUnICkgJiYgaXNWYWxpZEludCggdiwgMCwgOCwgMiwgcCApICkge1xuICAgICAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2IHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbcF0gPSBST1VORElOR19NT0RFO1xuXG4gICAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxuICAgICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVhQT05FTlRJQUxfQVQgbm90IGFuIGludGVnZXI6IHt2fSdcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBFWFBPTkVOVElBTF9BVCBvdXQgb2YgcmFuZ2U6IHt2fSdcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0VYUE9ORU5USUFMX0FUJyApICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpc0FycmF5KHYpICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzVmFsaWRJbnQoIHZbMF0sIC1NQVgsIDAsIDIsIHAgKSAmJiBpc1ZhbGlkSW50KCB2WzFdLCAwLCBNQVgsIDIsIHAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzVmFsaWRJbnQoIHYsIC1NQVgsIE1BWCwgMiwgcCApICkge1xuICAgICAgICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLSggVE9fRVhQX1BPUyA9ICggdiA8IDAgPyAtdiA6IHYgKSB8IDAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gWyBUT19FWFBfTkVHLCBUT19FWFBfUE9TIF07XG5cbiAgICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxuICAgICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cbiAgICAgICAgICAgIC8vICdjb25maWcoKSBSQU5HRSBub3QgYW4gaW50ZWdlcjoge3Z9J1xuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJBTkdFIGNhbm5vdCBiZSB6ZXJvOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0Ugb3V0IG9mIHJhbmdlOiB7dn0nXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdSQU5HRScgKSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSh2KSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1ZhbGlkSW50KCB2WzBdLCAtTUFYLCAtMSwgMiwgcCApICYmIGlzVmFsaWRJbnQoIHZbMV0sIDEsIE1BWCwgMiwgcCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF0gfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV0gfCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggaXNWYWxpZEludCggdiwgLU1BWCwgTUFYLCAyLCBwICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdiB8IDAgKSBNSU5fRVhQID0gLSggTUFYX0VYUCA9ICggdiA8IDAgPyAtdiA6IHYgKSB8IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoRVJST1JTKSByYWlzZSggMiwgcCArICcgY2Fubm90IGJlIHplcm8nLCB2ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcltwXSA9IFsgTUlOX0VYUCwgTUFYX0VYUCBdO1xuXG4gICAgICAgICAgICAvLyBFUlJPUlMge2Jvb2xlYW58bnVtYmVyfSB0cnVlLCBmYWxzZSwgMSBvciAwLlxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIEVSUk9SUyBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3Z9J1xuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnRVJST1JTJyApICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2ID09PSAhIXYgfHwgdiA9PT0gMSB8fCB2ID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWRJbnQgPSAoIEVSUk9SUyA9ICEhdiApID8gaW50VmFsaWRhdG9yV2l0aEVycm9ycyA6IGludFZhbGlkYXRvck5vRXJyb3JzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhaXNlKCAyLCBwICsgbm90Qm9vbCwgdiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbcF0gPSBFUlJPUlM7XG5cbiAgICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbnxudW1iZXJ9IHRydWUsIGZhbHNlLCAxIG9yIDAuXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgQ1JZUFRPIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgY3J5cHRvIHVuYXZhaWxhYmxlOiB7Y3J5cHRvfSdcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0NSWVBUTycgKSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggdiA9PT0gISF2IHx8IHYgPT09IDEgfHwgdiA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gISEoIHYgJiYgY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8gPT0gJ29iamVjdCcgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2ICYmICFDUllQVE8gJiYgRVJST1JTICkgcmFpc2UoIDIsICdjcnlwdG8gdW5hdmFpbGFibGUnLCBjcnlwdG8gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVSUk9SUykge1xuICAgICAgICAgICAgICAgICAgICByYWlzZSggMiwgcCArIG5vdEJvb2wsIHYgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gQ1JZUFRPO1xuXG4gICAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIE1PRFVMT19NT0RFIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgTU9EVUxPX01PREUgb3V0IG9mIHJhbmdlOiB7dn0nXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdNT0RVTE9fTU9ERScgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCA5LCAyLCBwICkgKSB7XG4gICAgICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2IHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbcF0gPSBNT0RVTE9fTU9ERTtcblxuICAgICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUE9XX1BSRUNJU0lPTiBub3QgYW4gaW50ZWdlcjoge3Z9J1xuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFBPV19QUkVDSVNJT04gb3V0IG9mIHJhbmdlOiB7dn0nXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdQT1dfUFJFQ0lTSU9OJyApICYmIGlzVmFsaWRJbnQoIHYsIDAsIE1BWCwgMiwgcCApICkge1xuICAgICAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2IHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbcF0gPSBQT1dfUFJFQ0lTSU9OO1xuXG4gICAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cbiAgICAgICAgICAgIC8vICdjb25maWcoKSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnRk9STUFUJyApICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdiA9PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgRk9STUFUID0gdjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVSUk9SUykge1xuICAgICAgICAgICAgICAgICAgICByYWlzZSggMiwgcCArICcgbm90IGFuIG9iamVjdCcsIHYgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gRk9STUFUO1xuXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhPck1pbiggYXJndW1lbnRzLCBQLmx0ICk7IH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4T3JNaW4oIGFyZ3VtZW50cywgUC5ndCApOyB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcbiAgICAgICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXG4gICAgICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogJ3JhbmRvbSgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xuICAgICAgICAgKiAncmFuZG9tKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xuICAgICAgICAgKiAncmFuZG9tKCkgY3J5cHRvIHVuYXZhaWxhYmxlOiB7Y3J5cHRvfSdcbiAgICAgICAgICovXG4gICAgICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxuICAgICAgICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXG4gICAgICAgICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxuICAgICAgICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKCBNYXRoLnJhbmRvbSgpICogcG93Ml81MyApOyB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcbiAgICAgICAgICAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgYyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xuXG4gICAgICAgICAgICAgICAgZHAgPSBkcCA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAxNCApID8gREVDSU1BTF9QTEFDRVMgOiBkcCB8IDA7XG4gICAgICAgICAgICAgICAgayA9IG1hdGhjZWlsKCBkcCAvIExPR19CQVNFICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ1JZUFRPKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyggbmV3IFVpbnQzMkFycmF5KCBrICo9IDIgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBrOyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUzIGJpdHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2ID49IDllMTUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCBuZXcgVWludDMyQXJyYXkoMikgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnB1c2goIHYgJSAxZTE0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gayAvIDI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY3J5cHRvICYmIGNyeXB0by5yYW5kb21CeXRlcyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKCBrICo9IDcgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgazsgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gKCAoIGFbaV0gJiAzMSApICogMHgxMDAwMDAwMDAwMDAwICkgKyAoIGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFbaSArIDJdICogMHgxMDAwMDAwMDAgKSArICggYVtpICsgM10gKiAweDEwMDAwMDAgKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhW2kgKyA0XSA8PCAxNiApICsgKCBhW2kgKyA1XSA8PCA4ICkgKyBhW2kgKyA2XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA+PSA5ZTE1ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weSggYSwgaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMucHVzaCggdiAlIDFlMTQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBrIC8gNztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlKCAxNCwgJ2NyeXB0byB1bmF2YWlsYWJsZScsIGNyeXB0byApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tOiBDUllQVE8gaXMgZmFsc2Ugb3IgY3J5cHRvIGlzIHVuYXZhaWxhYmxlIGFuZCBFUlJPUlMgaXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgazsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA8IDllMTUgKSBjW2krK10gPSB2ICUgMWUxNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGsgPSBjWy0taV07XG4gICAgICAgICAgICAgICAgZHAgJT0gTE9HX0JBU0U7XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXG4gICAgICAgICAgICAgICAgaWYgKCBrICYmIGRwICkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XG4gICAgICAgICAgICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoIGsgLyB2ICkgKiB2O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSApO1xuXG4gICAgICAgICAgICAgICAgLy8gWmVybz9cbiAgICAgICAgICAgICAgICBpZiAoIGkgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICBjID0gWyBlID0gMCBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zaGlmdCgpLCBlIC09IExPR19CQVNFKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpIDwgTE9HX0JBU0UgKSBlIC09IExPR19CQVNFIC0gaTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByYW5kLmUgPSBlO1xuICAgICAgICAgICAgICAgIHJhbmQuYyA9IGM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuXG5cbiAgICAgICAgLy8gUFJJVkFURSBGVU5DVElPTlNcblxuXG4gICAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxuICAgICAgICBmdW5jdGlvbiBjb252ZXJ0QmFzZSggc3RyLCBiYXNlT3V0LCBiYXNlSW4sIHNpZ24gKSB7XG4gICAgICAgICAgICB2YXIgZCwgZSwgaywgciwgeCwgeGMsIHksXG4gICAgICAgICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCAnLicgKSxcbiAgICAgICAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxuICAgICAgICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcblxuICAgICAgICAgICAgaWYgKCBiYXNlSW4gPCAzNyApIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBOb24taW50ZWdlci5cbiAgICAgICAgICAgIGlmICggaSA+PSAwICkge1xuICAgICAgICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cbiAgICAgICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSggJy4nLCAnJyApO1xuICAgICAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XG4gICAgICAgICAgICAgICAgeCA9IHkucG93KCBzdHIubGVuZ3RoIC0gaSApO1xuICAgICAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cbiAgICAgICAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQoIHRvRml4ZWRQb2ludCggY29lZmZUb1N0cmluZyggeC5jICksIHguZSApLCAxMCwgYmFzZU91dCApO1xuICAgICAgICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxuICAgICAgICAgICAgeGMgPSB0b0Jhc2VPdXQoIHN0ciwgYmFzZUluLCBiYXNlT3V0ICk7XG4gICAgICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxuICAgICAgICAgICAgZm9yICggOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpICk7XG4gICAgICAgICAgICBpZiAoICF4Y1swXSApIHJldHVybiAnMCc7XG5cbiAgICAgICAgICAgIGlmICggaSA8IDAgKSB7XG4gICAgICAgICAgICAgICAgLS1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4LmMgPSB4YztcbiAgICAgICAgICAgICAgICB4LmUgPSBlO1xuXG4gICAgICAgICAgICAgICAgLy8gc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXG4gICAgICAgICAgICAgICAgeC5zID0gc2lnbjtcbiAgICAgICAgICAgICAgICB4ID0gZGl2KCB4LCB5LCBkcCwgcm0sIGJhc2VPdXQgKTtcbiAgICAgICAgICAgICAgICB4YyA9IHguYztcbiAgICAgICAgICAgICAgICByID0geC5yO1xuICAgICAgICAgICAgICAgIGUgPSB4LmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGQgPSBlICsgZHAgKyAxO1xuXG4gICAgICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cbiAgICAgICAgICAgIGkgPSB4Y1tkXTtcbiAgICAgICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcbiAgICAgICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xuXG4gICAgICAgICAgICByID0gcm0gPCA0ID8gKCBpICE9IG51bGwgfHwgciApICYmICggcm0gPT0gMCB8fCBybSA9PSAoIHgucyA8IDAgPyAzIDogMiApIClcbiAgICAgICAgICAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYoIHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBybSA9PSAoIHgucyA8IDAgPyA4IDogNyApICk7XG5cbiAgICAgICAgICAgIGlmICggZCA8IDEgfHwgIXhjWzBdICkge1xuXG4gICAgICAgICAgICAgICAgLy8gMV4tZHAgb3IgMC5cbiAgICAgICAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KCAnMScsIC1kcCApIDogJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCAtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGNbZF0gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Yy51bnNoaWZ0KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxuICAgICAgICAgICAgICAgIGZvciAoIGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyApO1xuXG4gICAgICAgICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IEFMUEhBQkVULmNoYXJBdCggeGNbaSsrXSApICk7XG4gICAgICAgICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cbiAgICAgICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXG4gICAgICAgICAgICBmdW5jdGlvbiBtdWx0aXBseSggeCwgaywgYmFzZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHgubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxuICAgICAgICAgICAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcblxuICAgICAgICAgICAgICAgIGZvciAoIHggPSB4LnNsaWNlKCk7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XG4gICAgICAgICAgICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xuICAgICAgICAgICAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKCAoIG0gJSBTUVJUX0JBU0UgKSAqIFNRUlRfQkFTRSApICsgY2Fycnk7XG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gKCB0ZW1wIC8gYmFzZSB8IDAgKSArICggbSAvIFNRUlRfQkFTRSB8IDAgKSArIGtoaSAqIHhoaTtcbiAgICAgICAgICAgICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYXJyeSkgeC51bnNoaWZ0KGNhcnJ5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wYXJlKCBhLCBiLCBhTCwgYkwgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGNtcDtcblxuICAgICAgICAgICAgICAgIGlmICggYUwgIT0gYkwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gY21wID0gMDsgaSA8IGFMOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYVtpXSAhPSBiW2ldICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KCBhLCBiLCBhTCwgYmFzZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGFMLS07ICkge1xuICAgICAgICAgICAgICAgICAgICBhW2FMXSAtPSBpO1xuICAgICAgICAgICAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cbiAgICAgICAgICAgICAgICBmb3IgKCA7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zaGlmdCgpICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggeCwgeSwgZHAsIHJtLCBiYXNlICkge1xuICAgICAgICAgICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcbiAgICAgICAgICAgICAgICAgICAgeUwsIHl6LFxuICAgICAgICAgICAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgeGMgPSB4LmMsXG4gICAgICAgICAgICAgICAgICAgIHljID0geS5jO1xuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cbiAgICAgICAgICAgICAgICBpZiAoICF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxuICAgICAgICAgICAgICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoIHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMgKSA/IE5hTiA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xuICAgICAgICAgICAgICAgIHFjID0gcS5jID0gW107XG4gICAgICAgICAgICAgICAgZSA9IHguZSAtIHkuZTtcbiAgICAgICAgICAgICAgICBzID0gZHAgKyBlICsgMTtcblxuICAgICAgICAgICAgICAgIGlmICggIWJhc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBCQVNFO1xuICAgICAgICAgICAgICAgICAgICBlID0gYml0Rmxvb3IoIHguZSAvIExPR19CQVNFICkgLSBiaXRGbG9vciggeS5lIC8gTE9HX0JBU0UgKTtcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyB5Y1tpXSA9PSAoIHhjW2ldIHx8IDAgKTsgaSsrICk7XG4gICAgICAgICAgICAgICAgaWYgKCB5Y1tpXSA+ICggeGNbaV0gfHwgMCApICkgZS0tO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgcWMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbW9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcyArPSAyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cblxuICAgICAgICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKCBiYXNlIC8gKCB5Y1swXSArIDEgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09ICggYmFzZSAvIDIgKSAtIDEuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICggbiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuID4gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHljID0gbXVsdGlwbHkoIHljLCBuLCBiYXNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4YyA9IG11bHRpcGx5KCB4YywgbiwgYmFzZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHhpID0geUw7XG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKCAwLCB5TCApO1xuICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwICk7XG4gICAgICAgICAgICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgeXoudW5zaGlmdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgeWMwID0geWNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICggeWNbMV0gPj0gYmFzZSAvIDIgKSB5YzArKztcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmICggYmFzZSA9PSAzICYmIHljMCA9PSAxICkgeWMwID0gMSArIDFlLTE1O1xuXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoIHljLCByZW0sIHlMLCByZW1MICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNtcCA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeUwgIT0gcmVtTCApIHJlbTAgPSByZW0wICogYmFzZSArICggcmVtWzFdIHx8IDAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKCByZW0wIC8geWMwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAxLiBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0IChuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAyLiBpZiBwcm9kdWN0ID4gcmVtYWluZGVyOiBwcm9kdWN0IC09IGRpdmlzb3IsIG4tLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAzLiByZW1haW5kZXIgLT0gcHJvZHVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA0LiBpZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlciBhdCAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDUuIGNvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDYuIElmIHJlbWFpbmRlciA+IGRpdmlzb3I6IHJlbWFpbmRlciAtPSBkaXZpc29yLCBuKytcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA+IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoIHljLCBuLCBiYXNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY29tcGFyZSggcHJvZCwgcmVtLCBwcm9kTCwgcmVtTCApID09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLS07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QoIHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvZEwgPCByZW1MICkgcHJvZC51bnNoaWZ0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcmVtLCBwcm9kLCByZW1MLCBiYXNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjbXAgPT0gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBjb21wYXJlKCB5YywgcmVtLCB5TCwgcmVtTCApIDwgMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KCByZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY21wID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBxY1tpKytdID0gbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlbVswXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBbIHhjW3hpXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICggKCB4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwgKSAmJiBzLS0gKTtcblxuICAgICAgICAgICAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFxY1swXSApIHFjLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBiYXNlID09IEJBU0UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKysgKTtcbiAgICAgICAgICAgICAgICAgICAgcm91bmQoIHEsIGRwICsgKCBxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSApICsgMSwgcm0sIG1vcmUgKTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxLmUgPSBlO1xuICAgICAgICAgICAgICAgICAgICBxLnIgPSArbW9yZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxuICAgICAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBuIGlzIGEgQmlnTnVtYmVyLlxuICAgICAgICAgKiBpIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXG4gICAgICAgICAqIHJtIGlzIHRoZSByb3VuZGluZyBtb2RlLlxuICAgICAgICAgKiBjYWxsZXIgaXMgY2FsbGVyIGlkOiB0b0V4cG9uZW50aWFsIDE5LCB0b0ZpeGVkIDIwLCB0b0Zvcm1hdCAyMSwgdG9QcmVjaXNpb24gMjQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBmb3JtYXQoIG4sIGksIHJtLCBjYWxsZXIgKSB7XG4gICAgICAgICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcblxuICAgICAgICAgICAgcm0gPSBybSAhPSBudWxsICYmIGlzVmFsaWRJbnQoIHJtLCAwLCA4LCBjYWxsZXIsIHJvdW5kaW5nTW9kZSApXG4gICAgICAgICAgICAgID8gcm0gfCAwIDogUk9VTkRJTkdfTU9ERTtcblxuICAgICAgICAgICAgaWYgKCAhbi5jICkgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGMwID0gbi5jWzBdO1xuICAgICAgICAgICAgbmUgPSBuLmU7XG5cbiAgICAgICAgICAgIGlmICggaSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xuICAgICAgICAgICAgICAgIHN0ciA9IGNhbGxlciA9PSAxOSB8fCBjYWxsZXIgPT0gMjQgJiYgbmUgPD0gVE9fRVhQX05FR1xuICAgICAgICAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKCBzdHIsIG5lIClcbiAgICAgICAgICAgICAgICAgIDogdG9GaXhlZFBvaW50KCBzdHIsIG5lICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSByb3VuZCggbmV3IEJpZ051bWJlcihuKSwgaSwgcm0gKTtcblxuICAgICAgICAgICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cbiAgICAgICAgICAgICAgICBlID0gbi5lO1xuXG4gICAgICAgICAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyggbi5jICk7XG4gICAgICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcbiAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cblxuICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAgICAgICAgICAgICAgIGlmICggY2FsbGVyID09IDE5IHx8IGNhbGxlciA9PSAyNCAmJiAoIGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKysgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbCggc3RyLCBlICk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpIC09IG5lO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlICsgMSA+IGxlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggLS1pID4gMCApIGZvciAoIHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGUgKyAxID09IGxlbiApIHN0ciArPSAnLic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpLS07IHN0ciArPSAnMCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxuICAgICAgICBmdW5jdGlvbiBtYXhPck1pbiggYXJncywgbWV0aG9kICkge1xuICAgICAgICAgICAgdmFyIG0sIG4sXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGlmICggaXNBcnJheSggYXJnc1swXSApICkgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICBtID0gbmV3IEJpZ051bWJlciggYXJnc1swXSApO1xuXG4gICAgICAgICAgICBmb3IgKCA7ICsraSA8IGFyZ3MubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICBuID0gbmV3IEJpZ051bWJlciggYXJnc1tpXSApO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXG4gICAgICAgICAgICAgICAgaWYgKCAhbi5zICkge1xuICAgICAgICAgICAgICAgICAgICBtID0gbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbWV0aG9kLmNhbGwoIG0sIG4gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgbiBpcyBhbiBpbnRlZ2VyIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXG4gICAgICAgICAqIFVzZSBmb3IgYXJndW1lbnQgdmFsaWRhdGlvbiB3aGVuIEVSUk9SUyBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaW50VmFsaWRhdG9yV2l0aEVycm9ycyggbiwgbWluLCBtYXgsIGNhbGxlciwgbmFtZSApIHtcbiAgICAgICAgICAgIGlmICggbiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT0gdHJ1bmNhdGUobikgKSB7XG4gICAgICAgICAgICAgICAgcmFpc2UoIGNhbGxlciwgKCBuYW1lIHx8ICdkZWNpbWFsIHBsYWNlcycgKSArXG4gICAgICAgICAgICAgICAgICAoIG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlJyA6ICcgbm90IGFuIGludGVnZXInICksIG4gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxuICAgICAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXNlKCBuLCBjLCBlICkge1xuICAgICAgICAgICAgdmFyIGkgPSAxLFxuICAgICAgICAgICAgICAgIGogPSBjLmxlbmd0aDtcblxuICAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgICAgIGZvciAoIDsgIWNbLS1qXTsgYy5wb3AoKSApO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxuICAgICAgICAgICAgZm9yICggaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyApO1xuXG4gICAgICAgICAgICAvLyBPdmVyZmxvdz9cbiAgICAgICAgICAgIGlmICggKCBlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEgKSA+IE1BWF9FWFAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmZpbml0eS5cbiAgICAgICAgICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBVbmRlcmZsb3c/XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBlIDwgTUlOX0VYUCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFplcm8uXG4gICAgICAgICAgICAgICAgbi5jID0gWyBuLmUgPSAwIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZSA9IGU7XG4gICAgICAgICAgICAgICAgbi5jID0gYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cbiAgICAgICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkvaSxcbiAgICAgICAgICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxuICAgICAgICAgICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxuICAgICAgICAgICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCt8Xlxccyt8XFxzKyQvZztcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggeCwgc3RyLCBudW0sIGIgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2UsXG4gICAgICAgICAgICAgICAgICAgIHMgPSBudW0gPyBzdHIgOiBzdHIucmVwbGFjZSggd2hpdGVzcGFjZU9yUGx1cywgJycgKTtcblxuICAgICAgICAgICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cbiAgICAgICAgICAgICAgICBpZiAoIGlzSW5maW5pdHlPck5hTi50ZXN0KHMpICkge1xuICAgICAgICAgICAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFudW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBiYXNlUHJlZml4LCBmdW5jdGlvbiAoIG0sIHAxLCBwMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gKCBwMiA9IHAyLnRvTG93ZXJDYXNlKCkgKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gYjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBkb3RBZnRlciwgJyQxJyApLnJlcGxhY2UoIGRvdEJlZm9yZSwgJzAuJDEnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RyICE9IHMgKSByZXR1cm4gbmV3IEJpZ051bWJlciggcywgYmFzZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBub3QgYSBudW1iZXI6IHtufSdcbiAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBub3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVSUk9SUykgcmFpc2UoIGlkLCAnbm90IGEnICsgKCBiID8gJyBiYXNlICcgKyBiIDogJycgKSArICcgbnVtYmVyJywgc3RyICk7XG4gICAgICAgICAgICAgICAgICAgIHgucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cblxuICAgICAgICAvLyBUaHJvdyBhIEJpZ051bWJlciBFcnJvci5cbiAgICAgICAgZnVuY3Rpb24gcmFpc2UoIGNhbGxlciwgbXNnLCB2YWwgKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoIFtcbiAgICAgICAgICAgICAgICAnbmV3IEJpZ051bWJlcicsICAgICAvLyAwXG4gICAgICAgICAgICAgICAgJ2NtcCcsICAgICAgICAgICAgICAgLy8gMVxuICAgICAgICAgICAgICAgICdjb25maWcnLCAgICAgICAgICAgIC8vIDJcbiAgICAgICAgICAgICAgICAnZGl2JywgICAgICAgICAgICAgICAvLyAzXG4gICAgICAgICAgICAgICAgJ2RpdlRvSW50JywgICAgICAgICAgLy8gNFxuICAgICAgICAgICAgICAgICdlcScsICAgICAgICAgICAgICAgIC8vIDVcbiAgICAgICAgICAgICAgICAnZ3QnLCAgICAgICAgICAgICAgICAvLyA2XG4gICAgICAgICAgICAgICAgJ2d0ZScsICAgICAgICAgICAgICAgLy8gN1xuICAgICAgICAgICAgICAgICdsdCcsICAgICAgICAgICAgICAgIC8vIDhcbiAgICAgICAgICAgICAgICAnbHRlJywgICAgICAgICAgICAgICAvLyA5XG4gICAgICAgICAgICAgICAgJ21pbnVzJywgICAgICAgICAgICAgLy8gMTBcbiAgICAgICAgICAgICAgICAnbW9kJywgICAgICAgICAgICAgICAvLyAxMVxuICAgICAgICAgICAgICAgICdwbHVzJywgICAgICAgICAgICAgIC8vIDEyXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbicsICAgICAgICAgLy8gMTNcbiAgICAgICAgICAgICAgICAncmFuZG9tJywgICAgICAgICAgICAvLyAxNFxuICAgICAgICAgICAgICAgICdyb3VuZCcsICAgICAgICAgICAgIC8vIDE1XG4gICAgICAgICAgICAgICAgJ3NoaWZ0JywgICAgICAgICAgICAgLy8gMTZcbiAgICAgICAgICAgICAgICAndGltZXMnLCAgICAgICAgICAgICAvLyAxN1xuICAgICAgICAgICAgICAgICd0b0RpZ2l0cycsICAgICAgICAgIC8vIDE4XG4gICAgICAgICAgICAgICAgJ3RvRXhwb25lbnRpYWwnLCAgICAgLy8gMTlcbiAgICAgICAgICAgICAgICAndG9GaXhlZCcsICAgICAgICAgICAvLyAyMFxuICAgICAgICAgICAgICAgICd0b0Zvcm1hdCcsICAgICAgICAgIC8vIDIxXG4gICAgICAgICAgICAgICAgJ3RvRnJhY3Rpb24nLCAgICAgICAgLy8gMjJcbiAgICAgICAgICAgICAgICAncG93JywgICAgICAgICAgICAgICAvLyAyM1xuICAgICAgICAgICAgICAgICd0b1ByZWNpc2lvbicsICAgICAgIC8vIDI0XG4gICAgICAgICAgICAgICAgJ3RvU3RyaW5nJywgICAgICAgICAgLy8gMjVcbiAgICAgICAgICAgICAgICAnQmlnTnVtYmVyJyAgICAgICAgICAvLyAyNlxuICAgICAgICAgICAgXVtjYWxsZXJdICsgJygpICcgKyBtc2cgKyAnOiAnICsgdmFsICk7XG5cbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSAnQmlnTnVtYmVyIEVycm9yJztcbiAgICAgICAgICAgIGlkID0gMDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxuICAgICAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcm91bmQoIHgsIHNkLCBybSwgciApIHtcbiAgICAgICAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXG4gICAgICAgICAgICAgICAgcG93czEwID0gUE9XU19URU47XG5cbiAgICAgICAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxuICAgICAgICAgICAgaWYgKHhjKSB7XG5cbiAgICAgICAgICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxuICAgICAgICAgICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXG4gICAgICAgICAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cbiAgICAgICAgICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXG4gICAgICAgICAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXG4gICAgICAgICAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cbiAgICAgICAgICAgICAgICBvdXQ6IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyApO1xuICAgICAgICAgICAgICAgICAgICBpID0gc2QgLSBkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBzZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB4Y1sgbmkgPSAwIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwWyBkIC0gaiAtIDEgXSAlIDEwIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoICggaSArIDEgKSAvIExPR19CQVNFICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmkgPj0geGMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwWyBkIC0gaiAtIDEgXSAlIDEwIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbIGQgLSBqIC0gMSBdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxuICAgICAgICAgICAgICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoIGogPCAwID8gbiA6IG4gJSBwb3dzMTBbIGQgLSBqIC0gMSBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgciA9IHJtIDwgNFxuICAgICAgICAgICAgICAgICAgICAgID8gKCByZCB8fCByICkgJiYgKCBybSA9PSAwIHx8IHJtID09ICggeC5zIDwgMCA/IDMgOiAyICkgKVxuICAgICAgICAgICAgICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKCBybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAoIGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwWyBkIC0gaiBdIDogMCA6IHhjW25pIC0gMV0gKSAlIDEwICkgJiAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJtID09ICggeC5zIDwgMCA/IDggOiA3ICkgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNkIDwgMSB8fCAheGNbMF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsgc2QgJSBMT0dfQkFTRSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBuaS0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IHBvd3MxMFsgTE9HX0JBU0UgLSBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxuICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IoIG4gLyBwb3dzMTBbIGQgLSBqIF0gJSBwb3dzMTBbal0gKSAqIGsgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXA/XG4gICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgOyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuaSA9PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKysgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKysgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT0gayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1swXSA9PSBCQVNFICkgeGNbMF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGNbbmldICE9IEJBU0UgKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxuICAgICAgICAgICAgICAgIGlmICggeC5lID4gTUFYX0VYUCApIHtcbiAgICAgICAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB4LmUgPCBNSU5fRVhQICkge1xuICAgICAgICAgICAgICAgICAgICB4LmMgPSBbIHguZSA9IDAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcbiAgICAgICAgICAgIGlmICggeC5zIDwgMCApIHgucyA9IDE7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSB3aG9sZVxuICAgICAgICAgKiBudW1iZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiBJbmZpbml0eS5cbiAgICAgICAgICovXG4gICAgICAgIFAuY2VpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggbmV3IEJpZ051bWJlcih0aGlzKSwgdGhpcy5lICsgMSwgMiApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuXG4gICAgICAgICAqIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxuICAgICAgICAgKiAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXG4gICAgICAgICAqIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxuICAgICAgICAgKiBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICBpZCA9IDE7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlXG4gICAgICAgICAqIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuLCB2LFxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLmM7XG5cbiAgICAgICAgICAgIGlmICggIWMgKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG4gPSAoICggdiA9IGMubGVuZ3RoIC0gMSApIC0gYml0Rmxvb3IoIHRoaXMuZSAvIExPR19CQVNFICkgKSAqIExPR19CQVNFO1xuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cbiAgICAgICAgICAgIGlmICggdiA9IGNbdl0gKSBmb3IgKCA7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0gKTtcbiAgICAgICAgICAgIGlmICggbiA8IDAgKSBuID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiAgbiAvIDAgPSBJXG4gICAgICAgICAqICBuIC8gTiA9IE5cbiAgICAgICAgICogIG4gLyBJID0gMFxuICAgICAgICAgKiAgMCAvIG4gPSAwXG4gICAgICAgICAqICAwIC8gMCA9IE5cbiAgICAgICAgICogIDAgLyBOID0gTlxuICAgICAgICAgKiAgMCAvIEkgPSAwXG4gICAgICAgICAqICBOIC8gbiA9IE5cbiAgICAgICAgICogIE4gLyAwID0gTlxuICAgICAgICAgKiAgTiAvIE4gPSBOXG4gICAgICAgICAqICBOIC8gSSA9IE5cbiAgICAgICAgICogIEkgLyBuID0gSVxuICAgICAgICAgKiAgSSAvIDAgPSBJXG4gICAgICAgICAqICBJIC8gTiA9IE5cbiAgICAgICAgICogIEkgLyBJID0gTlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIGlkID0gMztcbiAgICAgICAgICAgIHJldHVybiBkaXYoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xuICAgICAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cbiAgICAgICAgICovXG4gICAgICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIGlkID0gNDtcbiAgICAgICAgICAgIHJldHVybiBkaXYoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSwgMCwgMSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXG4gICAgICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5lcXVhbHMgPSBQLmVxID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgICAgICAgICAgaWQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApID09PSAwO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhIHdob2xlXG4gICAgICAgICAqIG51bWJlciBpbiB0aGUgZGlyZWN0aW9uIG9mIC1JbmZpbml0eS5cbiAgICAgICAgICovXG4gICAgICAgIFAuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIG5ldyBCaWdOdW1iZXIodGhpcyksIHRoaXMuZSArIDEsIDMgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcbiAgICAgICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBQLmdyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIGlkID0gNjtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA+IDA7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgICAgICAgICAgaWQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuICggYiA9IGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApICkgPT09IDEgfHwgYiA9PT0gMDtcblxuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBQLmlzSW50ZWdlciA9IFAuaXNJbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IoIHRoaXMuZSAvIExPR19CQVNFICkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5zO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIFAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zIDwgMDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxuICAgICAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIFAubGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgICAgICAgICAgaWQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApIDwgMDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBQLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICBpZCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gKCBiID0gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgKSA9PT0gLTEgfHwgYiA9PT0gMDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqICBuIC0gMCA9IG5cbiAgICAgICAgICogIG4gLSBOID0gTlxuICAgICAgICAgKiAgbiAtIEkgPSAtSVxuICAgICAgICAgKiAgMCAtIG4gPSAtblxuICAgICAgICAgKiAgMCAtIDAgPSAwXG4gICAgICAgICAqICAwIC0gTiA9IE5cbiAgICAgICAgICogIDAgLSBJID0gLUlcbiAgICAgICAgICogIE4gLSBuID0gTlxuICAgICAgICAgKiAgTiAtIDAgPSBOXG4gICAgICAgICAqICBOIC0gTiA9IE5cbiAgICAgICAgICogIE4gLSBJID0gTlxuICAgICAgICAgKiAgSSAtIG4gPSBJXG4gICAgICAgICAqICBJIC0gMCA9IElcbiAgICAgICAgICogIEkgLSBOID0gTlxuICAgICAgICAgKiAgSSAtIEkgPSBOXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXG4gICAgICAgICAqL1xuICAgICAgICBQLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgdCwgeExUeSxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhID0geC5zO1xuXG4gICAgICAgICAgICBpZCA9IDEwO1xuICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKTtcbiAgICAgICAgICAgIGIgPSB5LnM7XG5cbiAgICAgICAgICAgIC8vIEVpdGhlciBOYU4/XG4gICAgICAgICAgICBpZiAoICFhIHx8ICFiICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcblxuICAgICAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xuICAgICAgICAgICAgaWYgKCBhICE9IGIgKSB7XG4gICAgICAgICAgICAgICAgeS5zID0gLWI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXG4gICAgICAgICAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcbiAgICAgICAgICAgICAgICB4YyA9IHguYyxcbiAgICAgICAgICAgICAgICB5YyA9IHkuYztcblxuICAgICAgICAgICAgaWYgKCAheGUgfHwgIXllICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xuICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiB4YyA/ICggeS5zID0gLWIsIHkgKSA6IG5ldyBCaWdOdW1iZXIoIHljID8geCA6IE5hTiApO1xuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHplcm8/XG4gICAgICAgICAgICAgICAgaWYgKCAheGNbMF0gfHwgIXljWzBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWNbMF0gPyAoIHkucyA9IC1iLCB5ICkgOiBuZXcgQmlnTnVtYmVyKCB4Y1swXSA/IHggOlxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxuICAgICAgICAgICAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XG4gICAgICAgICAgICB5ZSA9IGJpdEZsb29yKHllKTtcbiAgICAgICAgICAgIHhjID0geGMuc2xpY2UoKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxuICAgICAgICAgICAgaWYgKCBhID0geGUgLSB5ZSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggeExUeSA9IGEgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB4YztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ZSA9IHhlO1xuICAgICAgICAgICAgICAgICAgICB0ID0geWM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKCBiID0gYTsgYi0tOyB0LnB1c2goMCkgKTtcbiAgICAgICAgICAgICAgICB0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxuICAgICAgICAgICAgICAgIGogPSAoIHhMVHkgPSAoIGEgPSB4Yy5sZW5ndGggKSA8ICggYiA9IHljLmxlbmd0aCApICkgPyBhIDogYjtcblxuICAgICAgICAgICAgICAgIGZvciAoIGEgPSBiID0gMDsgYiA8IGo7IGIrKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHhjW2JdICE9IHljW2JdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cbiAgICAgICAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcblxuICAgICAgICAgICAgYiA9ICggaiA9IHljLmxlbmd0aCApIC0gKCBpID0geGMubGVuZ3RoICk7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cbiAgICAgICAgICAgIGlmICggYiA+IDAgKSBmb3IgKCA7IGItLTsgeGNbaSsrXSA9IDAgKTtcbiAgICAgICAgICAgIGIgPSBCQVNFIC0gMTtcblxuICAgICAgICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cbiAgICAgICAgICAgIGZvciAoIDsgaiA+IGE7ICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB4Y1stLWpdIDwgeWNbal0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIgKTtcbiAgICAgICAgICAgICAgICAgICAgLS14Y1tpXTtcbiAgICAgICAgICAgICAgICAgICAgeGNbal0gKz0gQkFTRTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIGZvciAoIDsgeGNbMF0gPT0gMDsgeGMuc2hpZnQoKSwgLS15ZSApO1xuXG4gICAgICAgICAgICAvLyBaZXJvP1xuICAgICAgICAgICAgaWYgKCAheGNbMF0gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcbiAgICAgICAgICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXG4gICAgICAgICAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHkuYyA9IFsgeS5lID0gMCBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcbiAgICAgICAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpc2UoIHksIHhjLCB5ZSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogICBuICUgMCA9ICBOXG4gICAgICAgICAqICAgbiAlIE4gPSAgTlxuICAgICAgICAgKiAgIG4gJSBJID0gIG5cbiAgICAgICAgICogICAwICUgbiA9ICAwXG4gICAgICAgICAqICAtMCAlIG4gPSAtMFxuICAgICAgICAgKiAgIDAgJSAwID0gIE5cbiAgICAgICAgICogICAwICUgTiA9ICBOXG4gICAgICAgICAqICAgMCAlIEkgPSAgMFxuICAgICAgICAgKiAgIE4gJSBuID0gIE5cbiAgICAgICAgICogICBOICUgMCA9ICBOXG4gICAgICAgICAqICAgTiAlIE4gPSAgTlxuICAgICAgICAgKiAgIE4gJSBJID0gIE5cbiAgICAgICAgICogICBJICUgbiA9ICBOXG4gICAgICAgICAqICAgSSAlIDAgPSAgTlxuICAgICAgICAgKiAgIEkgJSBOID0gIE5cbiAgICAgICAgICogICBJICUgSSA9ICBOXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIHZhciBxLCBzLFxuICAgICAgICAgICAgICAgIHggPSB0aGlzO1xuXG4gICAgICAgICAgICBpZCA9IDExO1xuICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cbiAgICAgICAgICAgIGlmICggIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxuICAgICAgICAgICAgfSBlbHNlIGlmICggIXkuYyB8fCB4LmMgJiYgIXguY1swXSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBNT0RVTE9fTU9ERSA9PSA5ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXG4gICAgICAgICAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXG4gICAgICAgICAgICAgICAgcyA9IHkucztcbiAgICAgICAgICAgICAgICB5LnMgPSAxO1xuICAgICAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIDMgKTtcbiAgICAgICAgICAgICAgICB5LnMgPSBzO1xuICAgICAgICAgICAgICAgIHEucyAqPSBzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxID0gZGl2KCB4LCB5LCAwLCBNT0RVTE9fTU9ERSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geC5taW51cyggcS50aW1lcyh5KSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcbiAgICAgICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XG4gICAgICAgICAgICB4LnMgPSAteC5zIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqICBuICsgMCA9IG5cbiAgICAgICAgICogIG4gKyBOID0gTlxuICAgICAgICAgKiAgbiArIEkgPSBJXG4gICAgICAgICAqICAwICsgbiA9IG5cbiAgICAgICAgICogIDAgKyAwID0gMFxuICAgICAgICAgKiAgMCArIE4gPSBOXG4gICAgICAgICAqICAwICsgSSA9IElcbiAgICAgICAgICogIE4gKyBuID0gTlxuICAgICAgICAgKiAgTiArIDAgPSBOXG4gICAgICAgICAqICBOICsgTiA9IE5cbiAgICAgICAgICogIE4gKyBJID0gTlxuICAgICAgICAgKiAgSSArIG4gPSBJXG4gICAgICAgICAqICBJICsgMCA9IElcbiAgICAgICAgICogIEkgKyBOID0gTlxuICAgICAgICAgKiAgSSArIEkgPSBJXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKS5cbiAgICAgICAgICovXG4gICAgICAgIFAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgICAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYSA9IHgucztcblxuICAgICAgICAgICAgaWQgPSAxMjtcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XG4gICAgICAgICAgICBiID0geS5zO1xuXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xuICAgICAgICAgICAgaWYgKCAhYSB8fCAhYiApIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG5cbiAgICAgICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cbiAgICAgICAgICAgICBpZiAoIGEgIT0gYiApIHtcbiAgICAgICAgICAgICAgICB5LnMgPSAtYjtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5taW51cyh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXG4gICAgICAgICAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcbiAgICAgICAgICAgICAgICB4YyA9IHguYyxcbiAgICAgICAgICAgICAgICB5YyA9IHkuYztcblxuICAgICAgICAgICAgaWYgKCAheGUgfHwgIXllICkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIGEgLyAwICk7XG5cbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgemVybz9cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cbiAgICAgICAgICAgICAgICBpZiAoICF4Y1swXSB8fCAheWNbMF0gKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlciggeGNbMF0gPyB4IDogYSAqIDAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XG4gICAgICAgICAgICB5ZSA9IGJpdEZsb29yKHllKTtcbiAgICAgICAgICAgIHhjID0geGMuc2xpY2UoKTtcblxuICAgICAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxuICAgICAgICAgICAgaWYgKCBhID0geGUgLSB5ZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGEgPiAwICkge1xuICAgICAgICAgICAgICAgICAgICB5ZSA9IHhlO1xuICAgICAgICAgICAgICAgICAgICB0ID0geWM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgICAgICB0ID0geGM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgZm9yICggOyBhLS07IHQucHVzaCgwKSApO1xuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhID0geGMubGVuZ3RoO1xuICAgICAgICAgICAgYiA9IHljLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxuICAgICAgICAgICAgaWYgKCBhIC0gYiA8IDAgKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgZm9yICggYSA9IDA7IGI7ICkge1xuICAgICAgICAgICAgICAgIGEgPSAoIHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSApIC8gQkFTRSB8IDA7XG4gICAgICAgICAgICAgICAgeGNbYl0gJT0gQkFTRTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICB4Yy51bnNoaWZ0KGEpO1xuICAgICAgICAgICAgICAgICsreWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcbiAgICAgICAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpc2UoIHksIHhjLCB5ZSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogW3pdIHtib29sZWFufG51bWJlcn0gV2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUsIGZhbHNlLCAxIG9yIDAuXG4gICAgICAgICAqL1xuICAgICAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoeikge1xuICAgICAgICAgICAgdmFyIG4sIHYsXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYyA9IHguYztcblxuICAgICAgICAgICAgLy8gJ3ByZWNpc2lvbigpIGFyZ3VtZW50IG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7en0nXG4gICAgICAgICAgICBpZiAoIHogIT0gbnVsbCAmJiB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwICkge1xuICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCAxMywgJ2FyZ3VtZW50JyArIG5vdEJvb2wsIHogKTtcbiAgICAgICAgICAgICAgICBpZiAoIHogIT0gISF6ICkgeiA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggIWMgKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcblxuICAgICAgICAgICAgaWYgKCB2ID0gY1t2XSApIHtcblxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0gKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBmb3IgKCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggeiAmJiB4LmUgKyAxID4gbiApIG4gPSB4LmUgKyAxO1xuXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mXG4gICAgICAgICAqIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIHRvIDAgYW5kIFJPVU5ESU5HX01PREUgcmVzcGVjdGl2ZWx5IGlmXG4gICAgICAgICAqIG9taXR0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAncm91bmQoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXG4gICAgICAgICAqICdyb3VuZCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xuICAgICAgICAgKiAncm91bmQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xuICAgICAgICAgKiAncm91bmQoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcbiAgICAgICAgICovXG4gICAgICAgIFAucm91bmQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcbiAgICAgICAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCBkcCA9PSBudWxsIHx8IGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDE1ICkgKSB7XG4gICAgICAgICAgICAgICAgcm91bmQoIG4sIH5+ZHAgKyB0aGlzLmUgKyAxLCBybSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAhaXNWYWxpZEludCggcm0sIDAsIDgsIDE1LCByb3VuZGluZ01vZGUgKSA/IFJPVU5ESU5HX01PREUgOiBybSB8IDAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXG4gICAgICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cbiAgICAgICAgICpcbiAgICAgICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgayBpcyBvdXQgb2YgcmFuZ2UgYW5kIEVSUk9SUyBpcyBmYWxzZSwgdGhlIHJlc3VsdCB3aWxsIGJlIMKxMCBpZiBrIDwgMCwgb3IgwrFJbmZpbml0eVxuICAgICAgICAgKiBvdGhlcndpc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICdzaGlmdCgpIGFyZ3VtZW50IG5vdCBhbiBpbnRlZ2VyOiB7a30nXG4gICAgICAgICAqICdzaGlmdCgpIGFyZ3VtZW50IG91dCBvZiByYW5nZToge2t9J1xuICAgICAgICAgKi9cbiAgICAgICAgUC5zaGlmdCA9IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZEludCggaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIsIDE2LCAnYXJndW1lbnQnIClcblxuICAgICAgICAgICAgICAvLyBrIDwgMWUrMjEsIG9yIHRydW5jYXRlKGspIHdpbGwgcHJvZHVjZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAgICAgICAgICAgPyBuLnRpbWVzKCAnMWUnICsgdHJ1bmNhdGUoaykgKVxuICAgICAgICAgICAgICA6IG5ldyBCaWdOdW1iZXIoIG4uYyAmJiBuLmNbMF0gJiYgKCBrIDwgLU1BWF9TQUZFX0lOVEVHRVIgfHwgayA+IE1BWF9TQUZFX0lOVEVHRVIgKVxuICAgICAgICAgICAgICAgID8gbi5zICogKCBrIDwgMCA/IDAgOiAxIC8gMCApXG4gICAgICAgICAgICAgICAgOiBuICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiAgc3FydCgtbikgPSAgTlxuICAgICAgICAgKiAgc3FydCggTikgPSAgTlxuICAgICAgICAgKiAgc3FydCgtSSkgPSAgTlxuICAgICAgICAgKiAgc3FydCggSSkgPSAgSVxuICAgICAgICAgKiAgc3FydCggMCkgPSAgMFxuICAgICAgICAgKiAgc3FydCgtMCkgPSAtMFxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXG4gICAgICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjID0geC5jLFxuICAgICAgICAgICAgICAgIHMgPSB4LnMsXG4gICAgICAgICAgICAgICAgZSA9IHguZSxcbiAgICAgICAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcbiAgICAgICAgICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XG5cbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xuICAgICAgICAgICAgaWYgKCBzICE9PSAxIHx8ICFjIHx8ICFjWzBdICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCAhcyB8fCBzIDwgMCAmJiAoICFjIHx8IGNbMF0gKSA/IE5hTiA6IGMgPyB4IDogMSAvIDAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cbiAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQoICt4ICk7XG5cbiAgICAgICAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XG4gICAgICAgICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgaWYgKCBzID09IDAgfHwgcyA9PSAxIC8gMCApIHtcbiAgICAgICAgICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcbiAgICAgICAgICAgICAgICBpZiAoICggbi5sZW5ndGggKyBlICkgJSAyID09IDAgKSBuICs9ICcwJztcbiAgICAgICAgICAgICAgICBzID0gTWF0aC5zcXJ0KG4pO1xuICAgICAgICAgICAgICAgIGUgPSBiaXRGbG9vciggKCBlICsgMSApIC8gMiApIC0gKCBlIDwgMCB8fCBlICUgMiApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzID09IDEgLyAwICkge1xuICAgICAgICAgICAgICAgICAgICBuID0gJzFlJyArIGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5zbGljZSggMCwgbi5pbmRleE9mKCdlJykgKyAxICkgKyBlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByID0gbmV3IEJpZ051bWJlciggcyArICcnICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxuICAgICAgICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcbiAgICAgICAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXG4gICAgICAgICAgICBpZiAoIHIuY1swXSApIHtcbiAgICAgICAgICAgICAgICBlID0gci5lO1xuICAgICAgICAgICAgICAgIHMgPSBlICsgZHA7XG4gICAgICAgICAgICAgICAgaWYgKCBzIDwgMyApIHMgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGZvciAoIDsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKCB0LnBsdXMoIGRpdiggeCwgdCwgZHAsIDEgKSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2VmZlRvU3RyaW5nKCB0LmMgICApLnNsaWNlKCAwLCBzICkgPT09ICggbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZUb1N0cmluZyggci5jICkgKS5zbGljZSggMCwgcyApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByLmUgPCBlICkgLS1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG4uc2xpY2UoIHMgLSAzLCBzICsgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFyZXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCB0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHQudGltZXModCkuZXEoeCkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHAgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1JyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCByLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogIG4gKiAwID0gMFxuICAgICAgICAgKiAgbiAqIE4gPSBOXG4gICAgICAgICAqICBuICogSSA9IElcbiAgICAgICAgICogIDAgKiBuID0gMFxuICAgICAgICAgKiAgMCAqIDAgPSAwXG4gICAgICAgICAqICAwICogTiA9IE5cbiAgICAgICAgICogIDAgKiBJID0gTlxuICAgICAgICAgKiAgTiAqIG4gPSBOXG4gICAgICAgICAqICBOICogMCA9IE5cbiAgICAgICAgICogIE4gKiBOID0gTlxuICAgICAgICAgKiAgTiAqIEkgPSBOXG4gICAgICAgICAqICBJICogbiA9IElcbiAgICAgICAgICogIEkgKiAwID0gTlxuICAgICAgICAgKiAgSSAqIE4gPSBOXG4gICAgICAgICAqICBJICogSSA9IElcbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgdGltZXMgdGhlIHZhbHVlIG9mXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKS5cbiAgICAgICAgICovXG4gICAgICAgIFAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcbiAgICAgICAgICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgICAgICAgICB4YyA9IHguYyxcbiAgICAgICAgICAgICAgICB5YyA9ICggaWQgPSAxNywgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKSApLmM7XG5cbiAgICAgICAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xuICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXG4gICAgICAgICAgICAgICAgaWYgKCAheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjICkge1xuICAgICAgICAgICAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkucyAqPSB4LnM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeS5jID0gWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeS5lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlID0gYml0Rmxvb3IoIHguZSAvIExPR19CQVNFICkgKyBiaXRGbG9vciggeS5lIC8gTE9HX0JBU0UgKTtcbiAgICAgICAgICAgIHkucyAqPSB4LnM7XG4gICAgICAgICAgICB4Y0wgPSB4Yy5sZW5ndGg7XG4gICAgICAgICAgICB5Y0wgPSB5Yy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cbiAgICAgICAgICAgIGlmICggeGNMIDwgeWNMICkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xuXG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cbiAgICAgICAgICAgIGZvciAoIGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSApO1xuXG4gICAgICAgICAgICBiYXNlID0gQkFTRTtcbiAgICAgICAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xuXG4gICAgICAgICAgICBmb3IgKCBpID0geWNMOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcbiAgICAgICAgICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcblxuICAgICAgICAgICAgICAgIGZvciAoIGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7ICkge1xuICAgICAgICAgICAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xuICAgICAgICAgICAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xuICAgICAgICAgICAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoICggbSAlIHNxcnRCYXNlICkgKiBzcXJ0QmFzZSApICsgemNbal0gKyBjO1xuICAgICAgICAgICAgICAgICAgICBjID0gKCB4bG8gLyBiYXNlIHwgMCApICsgKCBtIC8gc3FydEJhc2UgfCAwICkgKyB5aGkgKiB4aGk7XG4gICAgICAgICAgICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHpjW2pdID0gYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICArK2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHpjLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpc2UoIHksIHpjLCBlICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZlxuICAgICAgICAgKiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHByZWNpc2lvbiBvdXQgb2YgcmFuZ2U6IHtzZH0nXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHByZWNpc2lvbiBub3QgYW4gaW50ZWdlcjoge3NkfSdcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXG4gICAgICAgICAqL1xuICAgICAgICBQLnRvRGlnaXRzID0gZnVuY3Rpb24gKCBzZCwgcm0gKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XG4gICAgICAgICAgICBzZCA9IHNkID09IG51bGwgfHwgIWlzVmFsaWRJbnQoIHNkLCAxLCBNQVgsIDE4LCAncHJlY2lzaW9uJyApID8gbnVsbCA6IHNkIHwgMDtcbiAgICAgICAgICAgIHJtID0gcm0gPT0gbnVsbCB8fCAhaXNWYWxpZEludCggcm0sIDAsIDgsIDE4LCByb3VuZGluZ01vZGUgKSA/IFJPVU5ESU5HX01PREUgOiBybSB8IDA7XG4gICAgICAgICAgICByZXR1cm4gc2QgPyByb3VuZCggbiwgc2QsIHJtICkgOiBuO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXG4gICAgICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXG4gICAgICAgICAqL1xuICAgICAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsXG4gICAgICAgICAgICAgIGRwICE9IG51bGwgJiYgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMTkgKSA/IH5+ZHAgKyAxIDogbnVsbCwgcm0sIDE5ICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xuICAgICAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxuICAgICAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cbiAgICAgICAgICpcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqICd0b0ZpeGVkKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXG4gICAgICAgICAqICd0b0ZpeGVkKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xuICAgICAgICAgKiAndG9GaXhlZCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXG4gICAgICAgICAqICd0b0ZpeGVkKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXG4gICAgICAgICAqL1xuICAgICAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsIGRwICE9IG51bGwgJiYgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMjAgKVxuICAgICAgICAgICAgICA/IH5+ZHAgKyB0aGlzLmUgKyAxIDogbnVsbCwgcm0sIDIwICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXG4gICAgICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgICAqIG9mIHRoZSBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLmNvbmZpZykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZPUk1BVCA9IHtcbiAgICAgICAgICogICAgICBkZWNpbWFsU2VwYXJhdG9yIDogJy4nLFxuICAgICAgICAgKiAgICAgIGdyb3VwU2VwYXJhdG9yIDogJywnLFxuICAgICAgICAgKiAgICAgIGdyb3VwU2l6ZSA6IDMsXG4gICAgICAgICAqICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplIDogMCxcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIDogJ1xceEEwJywgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXG4gICAgICAgICAqICAgICAgZnJhY3Rpb25Hcm91cFNpemUgOiAwXG4gICAgICAgICAqIH07XG4gICAgICAgICAqXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAndG9Gb3JtYXQoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xuICAgICAgICAgKiAndG9Gb3JtYXQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xuICAgICAgICAgKiAndG9Gb3JtYXQoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcbiAgICAgICAgICovXG4gICAgICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBmb3JtYXQoIHRoaXMsIGRwICE9IG51bGwgJiYgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMjEgKVxuICAgICAgICAgICAgICA/IH5+ZHAgKyB0aGlzLmUgKyAxIDogbnVsbCwgcm0sIDIxICk7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5jICkge1xuICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICAgICAgZzEgPSArRk9STUFULmdyb3VwU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgZzIgPSArRk9STUFULnNlY29uZGFyeUdyb3VwU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBGT1JNQVQuZ3JvdXBTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXG4gICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcbiAgICAgICAgICAgICAgICAgICAgaXNOZWcgPSB0aGlzLnMgPCAwLFxuICAgICAgICAgICAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGcxID4gMCAmJiBsZW4gPiAwICkge1xuICAgICAgICAgICAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XG4gICAgICAgICAgICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKCAwLCBpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpICs9IGcxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoIGksIGcxICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGcyID4gMCApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XG4gICAgICAgICAgICAgICAgICA/IGludFBhcnQgKyBGT1JNQVQuZGVjaW1hbFNlcGFyYXRvciArICggKCBnMiA9ICtGT1JNQVQuZnJhY3Rpb25Hcm91cFNpemUgKVxuICAgICAgICAgICAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKCBuZXcgUmVnRXhwKCAnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyApLFxuICAgICAgICAgICAgICAgICAgICAgICckJicgKyBGT1JNQVQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciApXG4gICAgICAgICAgICAgICAgICAgIDogZnJhY3Rpb25QYXJ0IClcbiAgICAgICAgICAgICAgICAgIDogaW50UGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyBhcnJheSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlIGZyYWN0aW9uIHdpdGhcbiAgICAgICAgICogYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmVcbiAgICAgICAgICogbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtXG4gICAgICAgICAqIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvXG4gICAgICAgICAqIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEgYW5kIDwgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAndG9GcmFjdGlvbigpIG1heCBkZW5vbWluYXRvciBub3QgYW4gaW50ZWdlcjoge21kfSdcbiAgICAgICAgICogJ3RvRnJhY3Rpb24oKSBtYXggZGVub21pbmF0b3Igb3V0IG9mIHJhbmdlOiB7bWR9J1xuICAgICAgICAgKi9cbiAgICAgICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XG4gICAgICAgICAgICB2YXIgYXJyLCBkMCwgZDIsIGUsIGV4cCwgbiwgbjAsIHEsIHMsXG4gICAgICAgICAgICAgICAgayA9IEVSUk9SUyxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcbiAgICAgICAgICAgICAgICB4YyA9IHguYyxcbiAgICAgICAgICAgICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpLFxuICAgICAgICAgICAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSksXG4gICAgICAgICAgICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcblxuICAgICAgICAgICAgaWYgKCBtZCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIEVSUk9SUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcbiAgICAgICAgICAgICAgICBFUlJPUlMgPSBrO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBrID0gbi5pc0ludCgpICkgfHwgbi5sdChPTkUpICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlKCAyMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ21heCBkZW5vbWluYXRvciAnICsgKCBrID8gJ291dCBvZiByYW5nZScgOiAnbm90IGFuIGludGVnZXInICksIG1kICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFUlJPUlMgaXMgZmFsc2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG1kIGlzIGEgZmluaXRlIG5vbi1pbnRlZ2VyID49IDEsIHJvdW5kIGl0IHRvIGFuIGludGVnZXIgYW5kIHVzZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgbWQgPSAhayAmJiBuLmMgJiYgcm91bmQoIG4sIG4uZSArIDEsIDEgKS5ndGUoT05FKSA/IG4gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAheGMgKSByZXR1cm4geC50b1N0cmluZygpO1xuICAgICAgICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cbiAgICAgICAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxuICAgICAgICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcbiAgICAgICAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyAoIGV4cCA9IGUgJSBMT0dfQkFTRSApIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwIF07XG4gICAgICAgICAgICBtZCA9ICFtZCB8fCBuLmNtcChkKSA+IDAgPyAoIGUgPiAwID8gZCA6IG4xICkgOiBuO1xuXG4gICAgICAgICAgICBleHAgPSBNQVhfRVhQO1xuICAgICAgICAgICAgTUFYX0VYUCA9IDEgLyAwO1xuICAgICAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XG5cbiAgICAgICAgICAgIC8vIG4wID0gZDEgPSAwXG4gICAgICAgICAgICBuMC5jWzBdID0gMDtcblxuICAgICAgICAgICAgZm9yICggOyA7ICkgIHtcbiAgICAgICAgICAgICAgICBxID0gZGl2KCBuLCBkLCAwLCAxICk7XG4gICAgICAgICAgICAgICAgZDIgPSBkMC5wbHVzKCBxLnRpbWVzKGQxKSApO1xuICAgICAgICAgICAgICAgIGlmICggZDIuY21wKG1kKSA9PSAxICkgYnJlYWs7XG4gICAgICAgICAgICAgICAgZDAgPSBkMTtcbiAgICAgICAgICAgICAgICBkMSA9IGQyO1xuICAgICAgICAgICAgICAgIG4xID0gbjAucGx1cyggcS50aW1lcyggZDIgPSBuMSApICk7XG4gICAgICAgICAgICAgICAgbjAgPSBkMjtcbiAgICAgICAgICAgICAgICBkID0gbi5taW51cyggcS50aW1lcyggZDIgPSBkICkgKTtcbiAgICAgICAgICAgICAgICBuID0gZDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGQyID0gZGl2KCBtZC5taW51cyhkMCksIGQxLCAwLCAxICk7XG4gICAgICAgICAgICBuMCA9IG4wLnBsdXMoIGQyLnRpbWVzKG4xKSApO1xuICAgICAgICAgICAgZDAgPSBkMC5wbHVzKCBkMi50aW1lcyhkMSkgKTtcbiAgICAgICAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xuICAgICAgICAgICAgZSAqPSAyO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXG4gICAgICAgICAgICBhcnIgPSBkaXYoIG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSApLm1pbnVzKHgpLmFicygpLmNtcChcbiAgICAgICAgICAgICAgICAgIGRpdiggbjAsIGQwLCBlLCBST1VORElOR19NT0RFICkubWludXMoeCkuYWJzKCkgKSA8IDFcbiAgICAgICAgICAgICAgICAgICAgPyBbIG4xLnRvU3RyaW5nKCksIGQxLnRvU3RyaW5nKCkgXVxuICAgICAgICAgICAgICAgICAgICA6IFsgbjAudG9TdHJpbmcoKSwgZDAudG9TdHJpbmcoKSBdO1xuXG4gICAgICAgICAgICBNQVhfRVhQID0gZXhwO1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB6ZXJvIGhhcyBjb3JyZWN0IHNpZ24uXG4gICAgICAgICAgICByZXR1cm4gK3ggfHwgKCB4LnMgPyB4LnMgKiAwIDogTmFOICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJhaXNlZCB0byB0aGUgcG93ZXIgbi5cbiAgICAgICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXG4gICAgICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm90IDAsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cbiAgICAgICAgICpcbiAgICAgICAgICogbiB7bnVtYmVyfSBJbnRlZ2VyLCAtOTAwNzE5OTI1NDc0MDk5MiB0byA5MDA3MTk5MjU0NzQwOTkyIGluY2x1c2l2ZS5cbiAgICAgICAgICogKFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkyLilcbiAgICAgICAgICpcbiAgICAgICAgICogJ3BvdygpIGV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXG4gICAgICAgICAqICdwb3coKSBleHBvbmVudCBvdXQgb2YgcmFuZ2U6IHtufSdcbiAgICAgICAgICovXG4gICAgICAgIFAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBrLCB5LFxuICAgICAgICAgICAgICAgIGkgPSBtYXRoZmxvb3IoIG4gPCAwID8gLW4gOiArbiApLFxuICAgICAgICAgICAgICAgIHggPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBQYXNzIMKxSW5maW5pdHkgdG8gTWF0aC5wb3cgaWYgZXhwb25lbnQgaXMgb3V0IG9mIHJhbmdlLlxuICAgICAgICAgICAgaWYgKCAhaXNWYWxpZEludCggbiwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIsIDIzLCAnZXhwb25lbnQnICkgJiZcbiAgICAgICAgICAgICAgKCAhaXNGaW5pdGUobikgfHwgaSA+IE1BWF9TQUZFX0lOVEVHRVIgJiYgKCBuIC89IDAgKSB8fFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQobikgIT0gbiAmJiAhKCBuID0gTmFOICkgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggTWF0aC5wb3coICt4LCBuICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvbiBlcXVhdGVzXG4gICAgICAgICAgICAvLyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sIGkuZS4gdGhlcmUgd2lsbCBiZSBhXG4gICAgICAgICAgICAvLyBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC4gKFVzaW5nICsgMS41IHdvdWxkIGdpdmUgWzksIDIxXSBndWFyZCBkaWdpdHMuKVxuICAgICAgICAgICAgayA9IFBPV19QUkVDSVNJT04gPyBtYXRoY2VpbCggUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMiApIDogMDtcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XG5cbiAgICAgICAgICAgIGZvciAoIDsgOyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggaSAlIDIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICF5LmMgKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrICYmIHkuYy5sZW5ndGggPiBrICkgeS5jLmxlbmd0aCA9IGs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IG1hdGhmbG9vciggaSAvIDIgKTtcbiAgICAgICAgICAgICAgICBpZiAoICFpICkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB4ID0geC50aW1lcyh4KTtcbiAgICAgICAgICAgICAgICBpZiAoIGsgJiYgeC5jICYmIHguYy5sZW5ndGggPiBrICkgeC5jLmxlbmd0aCA9IGs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbiA8IDAgKSB5ID0gT05FLmRpdih5KTtcbiAgICAgICAgICAgIHJldHVybiBrID8gcm91bmQoIHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUgKSA6IHk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xuICAgICAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xuICAgICAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxuICAgICAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSBwcmVjaXNpb24gbm90IGFuIGludGVnZXI6IHtzZH0nXG4gICAgICAgICAqICd0b1ByZWNpc2lvbigpIHByZWNpc2lvbiBvdXQgb2YgcmFuZ2U6IHtzZH0nXG4gICAgICAgICAqICd0b1ByZWNpc2lvbigpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXG4gICAgICAgICAqICd0b1ByZWNpc2lvbigpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xuICAgICAgICAgKi9cbiAgICAgICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uICggc2QsIHJtICkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCggdGhpcywgc2QgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBzZCwgMSwgTUFYLCAyNCwgJ3ByZWNpc2lvbicgKVxuICAgICAgICAgICAgICA/IHNkIHwgMCA6IG51bGwsIHJtLCAyNCApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcbiAgICAgICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcbiAgICAgICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxuICAgICAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxuICAgICAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIDY0IGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogJ3RvU3RyaW5nKCkgYmFzZSBub3QgYW4gaW50ZWdlcjoge2J9J1xuICAgICAgICAgKiAndG9TdHJpbmcoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xuICAgICAgICAgKi9cbiAgICAgICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB2YXIgc3RyLFxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLFxuICAgICAgICAgICAgICAgIHMgPSBuLnMsXG4gICAgICAgICAgICAgICAgZSA9IG4uZTtcblxuICAgICAgICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xuICAgICAgICAgICAgaWYgKCBlID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzIDwgMCApIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBiID09IG51bGwgfHwgIWlzVmFsaWRJbnQoIGIsIDIsIDY0LCAyNSwgJ2Jhc2UnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcbiAgICAgICAgICAgICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoIHN0ciwgZSApXG4gICAgICAgICAgICAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKCB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApLCBiIHwgMCwgMTAsIHMgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHMgPCAwICYmIG4uY1swXSApIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHRydW5jYXRlZCB0byBhIHdob2xlXG4gICAgICAgICAqIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIFAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggbmV3IEJpZ051bWJlcih0aGlzKSwgdGhpcy5lICsgMSwgMSApO1xuICAgICAgICB9O1xuXG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudC5cbiAgICAgICAgICovXG4gICAgICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8vIEFsaWFzZXMgZm9yIEJpZ0RlY2ltYWwgbWV0aG9kcy5cbiAgICAgICAgLy9QLmFkZCA9IFAucGx1czsgICAgICAgICAvLyBQLmFkZCBpbmNsdWRlZCBhYm92ZVxuICAgICAgICAvL1Auc3VidHJhY3QgPSBQLm1pbnVzOyAgIC8vIFAuc3ViIGluY2x1ZGVkIGFib3ZlXG4gICAgICAgIC8vUC5tdWx0aXBseSA9IFAudGltZXM7ICAgLy8gUC5tdWwgaW5jbHVkZWQgYWJvdmVcbiAgICAgICAgLy9QLmRpdmlkZSA9IFAuZGl2O1xuICAgICAgICAvL1AucmVtYWluZGVyID0gUC5tb2Q7XG4gICAgICAgIC8vUC5jb21wYXJlVG8gPSBQLmNtcDtcbiAgICAgICAgLy9QLm5lZ2F0ZSA9IFAubmVnO1xuXG5cbiAgICAgICAgaWYgKCBjb25maWdPYmogIT0gbnVsbCApIEJpZ051bWJlci5jb25maWcoY29uZmlnT2JqKTtcblxuICAgICAgICByZXR1cm4gQmlnTnVtYmVyO1xuICAgIH1cblxuXG4gICAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXG5cblxuICAgIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcbiAgICAgICAgdmFyIGkgPSBuIHwgMDtcbiAgICAgICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XG4gICAgfVxuXG5cbiAgICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cbiAgICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcbiAgICAgICAgdmFyIHMsIHosXG4gICAgICAgICAgICBpID0gMSxcbiAgICAgICAgICAgIGogPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBhWzBdICsgJyc7XG5cbiAgICAgICAgZm9yICggOyBpIDwgajsgKSB7XG4gICAgICAgICAgICBzID0gYVtpKytdICsgJyc7XG4gICAgICAgICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIDsgei0tOyBzID0gJzAnICsgcyApO1xuICAgICAgICAgICAgciArPSBzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxuICAgICAgICBmb3IgKCBqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODsgKTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoIDAsIGogKyAxIHx8IDEgKTtcbiAgICB9XG5cblxuICAgIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cbiAgICBmdW5jdGlvbiBjb21wYXJlKCB4LCB5ICkge1xuICAgICAgICB2YXIgYSwgYixcbiAgICAgICAgICAgIHhjID0geC5jLFxuICAgICAgICAgICAgeWMgPSB5LmMsXG4gICAgICAgICAgICBpID0geC5zLFxuICAgICAgICAgICAgaiA9IHkucyxcbiAgICAgICAgICAgIGsgPSB4LmUsXG4gICAgICAgICAgICBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciBOYU4/XG4gICAgICAgIGlmICggIWkgfHwgIWogKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBhID0geGMgJiYgIXhjWzBdO1xuICAgICAgICBiID0geWMgJiYgIXljWzBdO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIGEgfHwgYiApIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XG5cbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xuICAgICAgICBpZiAoIGkgIT0gaiApIHJldHVybiBpO1xuXG4gICAgICAgIGEgPSBpIDwgMDtcbiAgICAgICAgYiA9IGsgPT0gbDtcblxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XG4gICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXG4gICAgICAgIGlmICggIWIgKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xuXG4gICAgICAgIGogPSAoIGsgPSB4Yy5sZW5ndGggKSA8ICggbCA9IHljLmxlbmd0aCApID8gayA6IGw7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBqOyBpKysgKSBpZiAoIHhjW2ldICE9IHljW2ldICkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cbiAgICAgICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIFJldHVybiB0cnVlIGlmIG4gaXMgYSB2YWxpZCBudW1iZXIgaW4gcmFuZ2UsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBVc2UgZm9yIGFyZ3VtZW50IHZhbGlkYXRpb24gd2hlbiBFUlJPUlMgaXMgZmFsc2UuXG4gICAgICogTm90ZTogcGFyc2VJbnQoJzFlKzEnKSA9PSAxIGJ1dCBwYXJzZUZsb2F0KCcxZSsxJykgPT0gMTAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50VmFsaWRhdG9yTm9FcnJvcnMoIG4sIG1pbiwgbWF4ICkge1xuICAgICAgICByZXR1cm4gKCBuID0gdHJ1bmNhdGUobikgKSA+PSBtaW4gJiYgbiA8PSBtYXg7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cbiAgICAgKiBFZy4gY29udmVydEJhc2UoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cbiAgICAgKiBFZy4gY29udmVydEJhc2UoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoIHN0ciwgYmFzZUluLCBiYXNlT3V0ICkge1xuICAgICAgICB2YXIgaixcbiAgICAgICAgICAgIGFyciA9IFswXSxcbiAgICAgICAgICAgIGFyckwsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBpIDwgbGVuOyApIHtcbiAgICAgICAgICAgIGZvciAoIGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4gKTtcbiAgICAgICAgICAgIGFyclsgaiA9IDAgXSArPSBBTFBIQUJFVC5pbmRleE9mKCBzdHIuY2hhckF0KCBpKysgKSApO1xuXG4gICAgICAgICAgICBmb3IgKCA7IGogPCBhcnIubGVuZ3RoOyBqKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGFycltqXSA+IGJhc2VPdXQgLSAxICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGFycltqICsgMV0gPT0gbnVsbCApIGFycltqICsgMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xuICAgICAgICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoIHN0ciwgZSApIHtcbiAgICAgICAgcmV0dXJuICggc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyICkgK1xuICAgICAgICAgICggZSA8IDAgPyAnZScgOiAnZSsnICkgKyBlO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KCBzdHIsIGUgKSB7XG4gICAgICAgIHZhciBsZW4sIHo7XG5cbiAgICAgICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XG4gICAgICAgIGlmICggZSA8IDAgKSB7XG5cbiAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MuXG4gICAgICAgICAgICBmb3IgKCB6ID0gJzAuJzsgKytlOyB6ICs9ICcwJyApO1xuICAgICAgICAgICAgc3RyID0geiArIHN0cjtcblxuICAgICAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zLlxuICAgICAgICAgICAgaWYgKCArK2UgPiBsZW4gKSB7XG4gICAgICAgICAgICAgICAgZm9yICggeiA9ICcwJywgZSAtPSBsZW47IC0tZTsgeiArPSAnMCcgKTtcbiAgICAgICAgICAgICAgICBzdHIgKz0gejtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBsZW4gKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKCAwLCBlICkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xuICAgICAgICBuID0gcGFyc2VGbG9hdChuKTtcbiAgICAgICAgcmV0dXJuIG4gPCAwID8gbWF0aGNlaWwobikgOiBtYXRoZmxvb3Iobik7XG4gICAgfVxuXG5cbiAgICAvLyBFWFBPUlRcblxuXG4gICAgQmlnTnVtYmVyID0gYW5vdGhlcigpO1xuXG4gICAgLy8gQU1ELlxuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAgIGRlZmluZSggZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9ICk7XG5cbiAgICAvLyBOb2RlIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xuICAgICAgICBpZiAoICFjcnlwdG8gKSB0cnkgeyBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTsgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIEJyb3dzZXIuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLkJpZ051bWJlciA9IEJpZ051bWJlcjtcbiAgICB9XG59KSh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaCh0aGlzICYmIHRoaXNbYXJnXSB8fCBhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkodGhpcywgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2godGhpcyAmJiB0aGlzW2tleV0gfHwga2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvYmluZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBMb29rdXAgdGFibGVzXG5cdCAgICB2YXIgU0JPWCA9IFtdO1xuXHQgICAgdmFyIElOVl9TQk9YID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8zID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcblx0ICAgICAgICB2YXIgZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdhbGsgR0YoMl44KVxuXHQgICAgICAgIHZhciB4ID0gMDtcblx0ICAgICAgICB2YXIgeGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XG5cdCAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuXHQgICAgICAgICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG5cdCAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcblx0ICAgICAgICAgICAgSU5WX1NCT1hbc3hdID0geDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG5cdCAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XG5cdCAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuXHQgICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcblx0ICAgICAgICAgICAgaWYgKCF4KSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcblx0ICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcblx0ICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgQUVTID0gQ19hbGdvLkFFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXG5cdCAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdCB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XG5cblx0ICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcblx0ICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuXHQgICAgICAgICAgICB2YXIgczIgPSBNW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XG5cdCAgICAgICAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuXHQgICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcblx0ICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgICAgIHZhciB0MCA9IFNVQl9NSVhfMFtzMCA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MyA9IFNVQl9NSVhfMFtzMyA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG5cdCAgICAgICAgICAgICAgICBzMCA9IHQwO1xuXHQgICAgICAgICAgICAgICAgczEgPSB0MTtcblx0ICAgICAgICAgICAgICAgIHMyID0gdDI7XG5cdCAgICAgICAgICAgICAgICBzMyA9IHQzO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0Mjtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuQUVTO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYWVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHRDcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyID0gQ19saWIuQ2lwaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcblx0ICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xuXHQgICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBjaXBoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIF9FTkNfWEZPUk1fTU9ERTogMSxcblxuXHQgICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaXBoZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSgpKVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kZSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgQ0JDID0gQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1Jcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBpdjtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBYT1IgYmxvY2tzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIENCQztcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGFkZGluZyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX3BhZCA9IEMucGFkID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQa2NzNyA9IENfcGFkLlBrY3M3ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnBhZCh3b3JkQXJyYXksIDQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5jb25jYXQocGFkZGluZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIG1vZGU6IENCQyxcblx0ICAgICAgICAgICAgcGFkZGluZzogUGtjczdcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxuXHQgICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSBjZmcuaXY7XG5cdCAgICAgICAgICAgIHZhciBtb2RlID0gY2ZnLm1vZGU7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZUVuY3J5cHRvcjtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsaXplXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVbnBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gY2lwaGVydGV4dCBUaGUgcmF3IGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IHNhbHQgVGhlIHNhbHQgdXNlZCB3aXRoIGEga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc2NoZW1lIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXG5cdCAgICAgKiBAcHJvcGVydHkge0Zvcm1hdH0gZm9ybWF0dGVyIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGl2OiBpdldvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxuXHQgICAgICAgICAqICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG5cdCAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXG5cdCAgICAgICAgICogICAgICAgICBibG9ja1NpemU6IDQsXG5cdCAgICAgICAgICogICAgICAgICBmb3JtYXR0ZXI6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG5cdCAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRm9ybWF0IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGZvcm1hdHRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMRm9ybWF0dGVyID0gQ19mb3JtYXQuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIEZvcm1hdFxuXHQgICAgICAgICAgICBpZiAoc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gd29yZEFycmF5LnRvU3RyaW5nKEJhc2U2NCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcblx0ICAgICAgICAgICAgLy8gUGFyc2UgYmFzZTY0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcblx0ICAgICAgICAgICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PSAweDUzNjE2Yzc0ICYmIGNpcGhlcnRleHRXb3Jkc1sxXSA9PSAweDY1NjQ1ZjVmKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNhbHRcblx0ICAgICAgICAgICAgICAgIHZhciBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG5cdCAgICAgICAgICAgICAgICBrZXk6IGtleSxcblx0ICAgICAgICAgICAgICAgIGl2OiBjaXBoZXJDZmcuaXYsXG5cdCAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcblx0ICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxuXHQgICAgICAgICAgICAgICAgcGFkZGluZzogY2lwaGVyQ2ZnLnBhZGRpbmcsXG5cdCAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG5cdCAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcblx0ICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcblx0ICAgICAgICAgICAgaWYgKCFzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBpdiA9IFdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcblx0ICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG5cdCAgICAgKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZGY6IE9wZW5TU0xLZGZcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0cm9vdC5DcnlwdG9KUyA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbCBvZiBPYmplY3QuY3JlYXRlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9O1xuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgdmFyIHIgPSAoZnVuY3Rpb24gKG1fdykge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1fdyA9IG1fdztcblx0ICAgICAgICAgICAgICAgIHZhciBtX3ogPSAweDNhZGU2OGIxO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSAweGZmZmZmZmZmO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG1feiA9ICgweDkwNjkgKiAobV96ICYgMHhGRkZGKSArIChtX3ogPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICBtX3cgPSAoMHg0NjUwICogKG1fdyAmIDB4RkZGRikgKyAobV93ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICgobV96IDw8IDB4MTApICsgbV93KSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0IC89IDB4MTAwMDAwMDAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAwLjU7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChNYXRoLnJhbmRvbSgpID4gLjUgPyAxIDogLTEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcmNhY2hlOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfciA9IHIoKHJjYWNoZSB8fCBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKTtcblxuXHQgICAgICAgICAgICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG5cdCAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKChfcigpICogMHgxMDAwMDAwMDApIHwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuXHQgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuXHQgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSAgICAgICA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAgICAgICAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHQgICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcblxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApIHtcblx0ICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgIHZhciBuQnl0ZXMgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoaSAlIDQpIHtcblx0ICAgICAgICAgICAgICB2YXIgYml0czEgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkgLSAxKV0gPDwgKChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSAoYml0czEgfCBiaXRzMikgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgbkJ5dGVzKys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NDtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBCRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjE2QkUgPSBDX2VuYy5VdGYxNiA9IENfZW5jLlV0ZjE2QkUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmMTYuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IEJFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnBhcnNlKHV0ZjE2U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IExFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICBDX2VuYy5VdGYxNkxFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHN3YXBFbmRpYW4oKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmKTtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IExFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUucGFyc2UodXRmMTZTdHIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gc3dhcEVuZGlhbih1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gc3dhcEVuZGlhbih3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuICgod29yZCA8PCA4KSAmIDB4ZmYwMGZmMDApIHwgKCh3b3JkID4+PiA4KSAmIDB4MDBmZjAwZmYpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5VdGYxNjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLXV0ZjE2LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy11dGYxNi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhMVwiKSwgcmVxdWlyZShcIi4vaG1hY1wiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9zaGExXCIsIFwiLi9obWFjXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxuXHQgICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcblx0ICAgICAqL1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREYgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcblx0ICAgICAgICAgICAgaGFzaGVyOiBNRDUsXG5cdCAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblxuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcblx0ICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgKi9cblx0ICAgIEMuRXZwS0RGID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcblx0ICAgICAgICByZXR1cm4gRXZwS0RGLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5FdnBLREY7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4O1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQ7XG5cblx0ICAgIHZhciBIZXhGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhlIGNpcGhlcnRleHQgb2YgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgY2lwaGVydGV4dCBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBIZXgucGFyc2UoaW5wdXQpO1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5mb3JtYXQuSGV4O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9mb3JtYXQtaGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Zvcm1hdC1oZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8qKlxuXHQgICAgICogSE1BQyBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBITUFDID0gQ19hbGdvLkhNQUMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjSGFzaGVyID0gQ3J5cHRvSlMuYWxnby5ITUFDLmNyZWF0ZShDcnlwdG9KUy5hbGdvLlNIQTI1Niwga2V5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgaGFzaGVyID0gdGhpcy5faGFzaGVyID0gbmV3IGhhc2hlci5pbml0KCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gVXRmOC5wYXJzZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemUgPSBoYXNoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEFsbG93IGFyYml0cmFyeSBsZW5ndGgga2V5c1xuXHQgICAgICAgICAgICBpZiAoa2V5LnNpZ0J5dGVzID4gaGFzaGVyQmxvY2tTaXplQnl0ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAga2V5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUga2V5IGZvciBpbm5lciBhbmQgb3V0ZXIgcGFkc1xuXHQgICAgICAgICAgICB2YXIgb0tleSA9IHRoaXMuX29LZXkgPSBrZXkuY2xvbmUoKTtcblx0ICAgICAgICAgICAgdmFyIGlLZXkgPSB0aGlzLl9pS2V5ID0ga2V5LmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5V29yZHMgPSBvS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBYT1Iga2V5cyB3aXRoIHBhZCBjb25zdGFudHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG5cdCAgICAgICAgICAgICAgICBpS2V5V29yZHNbaV0gXj0gMHgzNjM2MzYzNjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIEhNQUMgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICBoYXNoZXIudXBkYXRlKHRoaXMuX2lLZXkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtITUFDfSBUaGlzIEhNQUMgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIEhNQUNcblx0ICAgICAgICAgICAgdmFyIGlubmVySGFzaCA9IGhhc2hlci5maW5hbGl6ZShtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIHZhciBobWFjID0gaGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhtYWM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSwgcmVxdWlyZShcIi4vbGliLXR5cGVkYXJyYXlzXCIpLCByZXF1aXJlKFwiLi9lbmMtdXRmMTZcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vc2hhMVwiKSwgcmVxdWlyZShcIi4vc2hhMjU2XCIpLCByZXF1aXJlKFwiLi9zaGEyMjRcIiksIHJlcXVpcmUoXCIuL3NoYTUxMlwiKSwgcmVxdWlyZShcIi4vc2hhMzg0XCIpLCByZXF1aXJlKFwiLi9zaGEzXCIpLCByZXF1aXJlKFwiLi9yaXBlbWQxNjBcIiksIHJlcXVpcmUoXCIuL2htYWNcIiksIHJlcXVpcmUoXCIuL3Bia2RmMlwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSwgcmVxdWlyZShcIi4vbW9kZS1jZmJcIiksIHJlcXVpcmUoXCIuL21vZGUtY3RyXCIpLCByZXF1aXJlKFwiLi9tb2RlLWN0ci1nbGFkbWFuXCIpLCByZXF1aXJlKFwiLi9tb2RlLW9mYlwiKSwgcmVxdWlyZShcIi4vbW9kZS1lY2JcIiksIHJlcXVpcmUoXCIuL3BhZC1hbnNpeDkyM1wiKSwgcmVxdWlyZShcIi4vcGFkLWlzbzEwMTI2XCIpLCByZXF1aXJlKFwiLi9wYWQtaXNvOTc5NzFcIiksIHJlcXVpcmUoXCIuL3BhZC16ZXJvcGFkZGluZ1wiKSwgcmVxdWlyZShcIi4vcGFkLW5vcGFkZGluZ1wiKSwgcmVxdWlyZShcIi4vZm9ybWF0LWhleFwiKSwgcmVxdWlyZShcIi4vYWVzXCIpLCByZXF1aXJlKFwiLi90cmlwbGVkZXNcIiksIHJlcXVpcmUoXCIuL3JjNFwiKSwgcmVxdWlyZShcIi4vcmFiYml0XCIpLCByZXF1aXJlKFwiLi9yYWJiaXQtbGVnYWN5XCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCIsIFwiLi9saWItdHlwZWRhcnJheXNcIiwgXCIuL2VuYy11dGYxNlwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9zaGExXCIsIFwiLi9zaGEyNTZcIiwgXCIuL3NoYTIyNFwiLCBcIi4vc2hhNTEyXCIsIFwiLi9zaGEzODRcIiwgXCIuL3NoYTNcIiwgXCIuL3JpcGVtZDE2MFwiLCBcIi4vaG1hY1wiLCBcIi4vcGJrZGYyXCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCIsIFwiLi9tb2RlLWNmYlwiLCBcIi4vbW9kZS1jdHJcIiwgXCIuL21vZGUtY3RyLWdsYWRtYW5cIiwgXCIuL21vZGUtb2ZiXCIsIFwiLi9tb2RlLWVjYlwiLCBcIi4vcGFkLWFuc2l4OTIzXCIsIFwiLi9wYWQtaXNvMTAxMjZcIiwgXCIuL3BhZC1pc285Nzk3MVwiLCBcIi4vcGFkLXplcm9wYWRkaW5nXCIsIFwiLi9wYWQtbm9wYWRkaW5nXCIsIFwiLi9mb3JtYXQtaGV4XCIsIFwiLi9hZXNcIiwgXCIuL3RyaXBsZWRlc1wiLCBcIi4vcmM0XCIsIFwiLi9yYWJiaXRcIiwgXCIuL3JhYmJpdC1sZWdhY3lcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGlmIHR5cGVkIGFycmF5cyBhcmUgc3VwcG9ydGVkXG5cdCAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuXHQgICAgLy8gUmVmZXJlbmNlIG9yaWdpbmFsIGluaXRcblx0ICAgIHZhciBzdXBlckluaXQgPSBXb3JkQXJyYXkuaW5pdDtcblxuXHQgICAgLy8gQXVnbWVudCBXb3JkQXJyYXkuaW5pdCB0byBoYW5kbGUgdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgc3ViSW5pdCA9IFdvcmRBcnJheS5pbml0ID0gZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0ICAgICAgICAvLyBDb252ZXJ0IGJ1ZmZlcnMgdG8gdWludDhcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5IHx8XG5cdCAgICAgICAgICAgICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuXHQgICAgICAgICkge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBIYW5kbGUgVWludDhBcnJheVxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdHlwZWRBcnJheUJ5dGVMZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gRXh0cmFjdCBieXRlc1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZEFycmF5Qnl0ZUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSB0eXBlZEFycmF5W2ldIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhpcyB3b3JkIGFycmF5XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5jYWxsKHRoaXMsIHdvcmRzLCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRWxzZSBjYWxsIG5vcm1hbCBpbml0XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXk7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9saWItdHlwZWRhcnJheXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBUID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsICAxMiwgVFsxXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTcsIFRbMl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA3LCAgVFs0XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAgMTIsIFRbNV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzcsICAyMiwgVFs3XSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNywgIFRbOF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG5cblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA0LCAgVFszMl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE0LCAyMywgVFszNV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNiwgVFszOF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsICAxMSwgVFs0MV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA0LCAgVFs0NF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsICAyMywgVFs0N10pO1xuXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzcsICAxMCwgVFs0OV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCAgVFs1Ml0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgIDEwLCBUWzUzXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsICAyMSwgVFs1NV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDYsICBUWzU2XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNSwgVFs1OF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE1LCBUWzYyXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5NRDU7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIEZlZWRiYWNrIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkNGQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgQ0ZCID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgQ0ZCLkVuY3J5cHRvciA9IENGQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKTtcblxuXHQgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBDRkIuRGVjcnlwdG9yID0gQ0ZCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0LmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpO1xuXG5cdCAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQod29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSB0aGlzLl9wcmV2QmxvY2s7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBDRkI7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DRkI7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY2ZiLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY2ZiLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqIEBwcmVzZXJ2ZVxuXHQgKiBDb3VudGVyIGJsb2NrIG1vZGUgY29tcGF0aWJsZSB3aXRoICBEciBCcmlhbiBHbGFkbWFuIGZpbGVlbmMuY1xuXHQgKiBkZXJpdmVkIGZyb20gQ3J5cHRvSlMubW9kZS5DVFJcblx0ICogSmFuIEhydWJ5IGpocnVieS53ZWJAZ21haWwuY29tXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkNUUkdsYWRtYW4gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIENUUkdsYWRtYW4gPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdFx0ZnVuY3Rpb24gaW5jV29yZCh3b3JkKVxuXHRcdHtcblx0XHRcdGlmICgoKHdvcmQgPj4gMjQpICYgMHhmZikgPT09IDB4ZmYpIHsgLy9vdmVyZmxvd1xuXHRcdFx0dmFyIGIxID0gKHdvcmQgPj4gMTYpJjB4ZmY7XG5cdFx0XHR2YXIgYjIgPSAod29yZCA+PiA4KSYweGZmO1xuXHRcdFx0dmFyIGIzID0gd29yZCAmIDB4ZmY7XG5cblx0XHRcdGlmIChiMSA9PT0gMHhmZikgLy8gb3ZlcmZsb3cgYjFcblx0XHRcdHtcblx0XHRcdGIxID0gMDtcblx0XHRcdGlmIChiMiA9PT0gMHhmZilcblx0XHRcdHtcblx0XHRcdFx0YjIgPSAwO1xuXHRcdFx0XHRpZiAoYjMgPT09IDB4ZmYpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRiMyA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0KytiMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQrK2IyO1xuXHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0KytiMTtcblx0XHRcdH1cblxuXHRcdFx0d29yZCA9IDA7XG5cdFx0XHR3b3JkICs9IChiMSA8PCAxNik7XG5cdFx0XHR3b3JkICs9IChiMiA8PCA4KTtcblx0XHRcdHdvcmQgKz0gYjM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHR3b3JkICs9ICgweDAxIDw8IDI0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3b3JkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluY0NvdW50ZXIoY291bnRlcilcblx0XHR7XG5cdFx0XHRpZiAoKGNvdW50ZXJbMF0gPSBpbmNXb3JkKGNvdW50ZXJbMF0pKSA9PT0gMClcblx0XHRcdHtcblx0XHRcdFx0Ly8gZW5jcl9kYXRhIGluIGZpbGVlbmMuYyBmcm9tICBEciBCcmlhbiBHbGFkbWFuJ3MgY291bnRzIG9ubHkgd2l0aCBEV09SRCBqIDwgOFxuXHRcdFx0XHRjb3VudGVyWzFdID0gaW5jV29yZChjb3VudGVyWzFdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3VudGVyO1xuXHRcdH1cblxuXHQgICAgdmFyIEVuY3J5cHRvciA9IENUUkdsYWRtYW4uRW5jcnlwdG9yID0gQ1RSR2xhZG1hbi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXHQgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXIgPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblxuXHRcdFx0XHRpbmNDb3VudGVyKGNvdW50ZXIpO1xuXG5cdFx0XHRcdHZhciBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xuXHQgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgQ1RSR2xhZG1hbi5EZWNyeXB0b3IgPSBFbmNyeXB0b3I7XG5cblx0ICAgIHJldHVybiBDVFJHbGFkbWFuO1xuXHR9KCkpO1xuXG5cblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkNUUkdsYWRtYW47XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY3RyLWdsYWRtYW4uanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDb3VudGVyIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkNUUiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgQ1RSID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgdmFyIEVuY3J5cHRvciA9IENUUi5FbmNyeXB0b3IgPSBDVFIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyXG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblx0ICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xuXHQgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXJcblx0ICAgICAgICAgICAgY291bnRlcltibG9ja1NpemUgLSAxXSA9IChjb3VudGVyW2Jsb2NrU2l6ZSAtIDFdICsgMSkgfCAwXG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgQ1RSLkRlY3J5cHRvciA9IEVuY3J5cHRvcjtcblxuXHQgICAgcmV0dXJuIENUUjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkNUUjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogRWxlY3Ryb25pYyBDb2RlYm9vayBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5FQ0IgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIEVDQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIEVDQi5FbmNyeXB0b3IgPSBFQ0IuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIEVDQi5EZWNyeXB0b3IgPSBFQ0IuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBFQ0I7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5FQ0I7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIE91dHB1dCBGZWVkYmFjayBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5PRkIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIE9GQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIHZhciBFbmNyeXB0b3IgPSBPRkIuRW5jcnlwdG9yID0gT0ZCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlclxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSB0aGlzLl9rZXlzdHJlYW07XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAga2V5c3RyZWFtID0gdGhpcy5fa2V5c3RyZWFtID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBPRkIuRGVjcnlwdG9yID0gRW5jcnlwdG9yO1xuXG5cdCAgICByZXR1cm4gT0ZCO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuT0ZCO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBBTlNJIFguOTIzIHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuQW5zaVg5MjMgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhU2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgIC8vIENvbXB1dGUgbGFzdCBieXRlIHBvc2l0aW9uXG5cdCAgICAgICAgdmFyIGxhc3RCeXRlUG9zID0gZGF0YVNpZ0J5dGVzICsgblBhZGRpbmdCeXRlcyAtIDE7XG5cblx0ICAgICAgICAvLyBQYWRcblx0ICAgICAgICBkYXRhLmNsYW1wKCk7XG5cdCAgICAgICAgZGF0YS53b3Jkc1tsYXN0Qnl0ZVBvcyA+Pj4gMl0gfD0gblBhZGRpbmdCeXRlcyA8PCAoMjQgLSAobGFzdEJ5dGVQb3MgJSA0KSAqIDgpO1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgKz0gblBhZGRpbmdCeXRlcztcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuQW5zaXg5MjM7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1hbnNpeDkyMy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtYW5zaXg5MjMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogSVNPIDEwMTI2IHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuSXNvMTAxMjYgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgIC8vIFBhZFxuXHQgICAgICAgIGRhdGEuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKG5QYWRkaW5nQnl0ZXMgLSAxKSkuXG5cdCAgICAgICAgICAgICBjb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoW25QYWRkaW5nQnl0ZXMgPDwgMjRdLCAxKSk7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzEwMTI2O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvMTAxMjYuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzEwMTI2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIElTTy9JRUMgOTc5Ny0xIFBhZGRpbmcgTWV0aG9kIDIuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuSXNvOTc5NzEgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBBZGQgMHg4MCBieXRlXG5cdCAgICAgICAgZGF0YS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4ODAwMDAwMDBdLCAxKSk7XG5cblx0ICAgICAgICAvLyBaZXJvIHBhZCB0aGUgcmVzdFxuXHQgICAgICAgIENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZy5wYWQoZGF0YSwgYmxvY2tTaXplKTtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIFJlbW92ZSB6ZXJvIHBhZGRpbmdcblx0ICAgICAgICBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcudW5wYWQoZGF0YSk7XG5cblx0ICAgICAgICAvLyBSZW1vdmUgb25lIG1vcmUgYnl0ZSAtLSB0aGUgMHg4MCBieXRlXG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcy0tO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5Jc285Nzk3MTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzk3OTcxLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBBIG5vb3AgcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5Ob1BhZGRpbmcgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLk5vUGFkZGluZztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLW5vcGFkZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtbm9wYWRkaW5nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIFplcm8gcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZyA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgIC8vIFBhZFxuXHQgICAgICAgIGRhdGEuY2xhbXAoKTtcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzICs9IGJsb2NrU2l6ZUJ5dGVzIC0gKChkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXMpIHx8IGJsb2NrU2l6ZUJ5dGVzKTtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAvLyBVbnBhZFxuXHQgICAgICAgIHZhciBpID0gZGF0YS5zaWdCeXRlcyAtIDE7XG5cdCAgICAgICAgd2hpbGUgKCEoKGRhdGFXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmYpKSB7XG5cdCAgICAgICAgICAgIGktLTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGkgKyAxO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLXplcm9wYWRkaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC16ZXJvcGFkZGluZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhMVwiKSwgcmVxdWlyZShcIi4vaG1hY1wiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9zaGExXCIsIFwiLi9obWFjXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTE7XG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUEJLREYyID0gQ19hbGdvLlBCS0RGMiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UuIERlZmF1bHQ6IFNIQTFcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogU0hBMSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb21wdXRlcyB0aGUgUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IEhNQUMuY3JlYXRlKGNmZy5oYXNoZXIsIHBhc3N3b3JkKTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrSW5kZXggPSBXb3JkQXJyYXkuY3JlYXRlKFsweDAwMDAwMDAxXSk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tJbmRleFdvcmRzID0gYmxvY2tJbmRleC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBobWFjLnVwZGF0ZShzYWx0KS5maW5hbGl6ZShibG9ja0luZGV4KTtcblx0ICAgICAgICAgICAgICAgIGhtYWMucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tXb3JkcyA9IGJsb2NrLndvcmRzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrV29yZHNMZW5ndGggPSBibG9ja1dvcmRzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgdmFyIGludGVybWVkaWF0ZSA9IGJsb2NrO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSBobWFjLmZpbmFsaXplKGludGVybWVkaWF0ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaG1hYy5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJtZWRpYXRlV29yZHMgPSBpbnRlcm1lZGlhdGUud29yZHM7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBYT1IgaW50ZXJtZWRpYXRlIHdpdGggYmxvY2tcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrV29yZHNMZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1dvcmRzW2pdIF49IGludGVybWVkaWF0ZVdvcmRzW2pdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgYmxvY2tJbmRleFdvcmRzWzBdKys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENvbXB1dGVzIHRoZSBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5QQktERjIgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBQQktERjIuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlBCS0RGMjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGJrZGYyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3Bia2RmMi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHNcblx0ICAgIHZhciBTICA9IFtdO1xuXHQgICAgdmFyIENfID0gW107XG5cdCAgICB2YXIgRyAgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSYWJiaXQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKlxuXHQgICAgICogVGhpcyBpcyBhIGxlZ2FjeSB2ZXJzaW9uIHRoYXQgbmVnbGVjdGVkIHRvIGNvbnZlcnQgdGhlIGtleSB0byBsaXR0bGUtZW5kaWFuLlxuXHQgICAgICogVGhpcyBlcnJvciBkb2Vzbid0IGFmZmVjdCB0aGUgY2lwaGVyJ3Mgc2VjdXJpdHksXG5cdCAgICAgKiBidXQgaXQgZG9lcyBhZmZlY3QgaXRzIGNvbXBhdGliaWxpdHkgd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMuXG5cdCAgICAgKi9cblx0ICAgIHZhciBSYWJiaXRMZWdhY3kgPSBDX2FsZ28uUmFiYml0TGVnYWN5ID0gU3RyZWFtQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBLID0gdGhpcy5fa2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLmNmZy5pdjtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIHN0YXRlIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1ggPSBbXG5cdCAgICAgICAgICAgICAgICBLWzBdLCAoS1szXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1sxXSwgKEtbMF0gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMl0sIChLWzFdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzNdLCAoS1syXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgQyA9IHRoaXMuX0MgPSBbXG5cdCAgICAgICAgICAgICAgICAoS1syXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLCAoS1swXSAmIDB4ZmZmZjAwMDApIHwgKEtbMV0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzNdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksIChLWzFdICYgMHhmZmZmMDAwMCkgfCAoS1syXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMF0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSwgKEtbMl0gJiAweGZmZmYwMDAwKSB8IChLWzNdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1sxXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpLCAoS1szXSAmIDB4ZmZmZjAwMDApIHwgKEtbMF0gJiAweDAwMDBmZmZmKVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIENhcnJ5IGJpdFxuXHQgICAgICAgICAgICB0aGlzLl9iID0gMDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGNvdW50ZXJzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBDW2ldIF49IFhbKGkgKyA0KSAmIDddO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSVYgc2V0dXBcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBJViA9IGl2LndvcmRzO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzAgPSBJVlswXTtcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8xID0gSVZbMV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xuXHQgICAgICAgICAgICAgICAgdmFyIGkwID0gKCgoSVZfMCA8PCA4KSB8IChJVl8wID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8wIDw8IDI0KSB8IChJVl8wID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMiA9ICgoKElWXzEgPDwgOCkgfCAoSVZfMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMSA8PCAyNCkgfCAoSVZfMSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTEgPSAoaTAgPj4+IDE2KSB8IChpMiAmIDB4ZmZmZjAwMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkzID0gKGkyIDw8IDE2KSAgfCAoaTAgJiAweDAwMDBmZmZmKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgICAgICBDWzBdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1sxXSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbMl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzNdIF49IGkzO1xuXHQgICAgICAgICAgICAgICAgQ1s0XSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbNV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzZdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1s3XSBePSBpMztcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW1cblx0ICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcblx0ICAgICAgICAgICAgU1swXSA9IFhbMF0gXiAoWFs1XSA+Pj4gMTYpIF4gKFhbM10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzFdID0gWFsyXSBeIChYWzddID4+PiAxNikgXiAoWFs1XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMl0gPSBYWzRdIF4gKFhbMV0gPj4+IDE2KSBeIChYWzddIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1szXSA9IFhbNl0gXiAoWFszXSA+Pj4gMTYpIF4gKFhbMV0gPDwgMTYpO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgU1tpXSA9ICgoKFNbaV0gPDwgOCkgIHwgKFNbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoU1tpXSA8PCAyNCkgfCAoU1tpXSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgICAgICBNW29mZnNldCArIGldIF49IFNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gbmV4dFN0YXRlKCkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblx0ICAgICAgICB2YXIgQyA9IHRoaXMuX0M7XG5cblx0ICAgICAgICAvLyBTYXZlIG9sZCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIENfW2ldID0gQ1tpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgQ1swXSA9IChDWzBdICsgMHg0ZDM0ZDM0ZCArIHRoaXMuX2IpIHwgMDtcblx0ICAgICAgICBDWzFdID0gKENbMV0gKyAweGQzNGQzNGQzICsgKChDWzBdID4+PiAwKSA8IChDX1swXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzJdID0gKENbMl0gKyAweDM0ZDM0ZDM0ICsgKChDWzFdID4+PiAwKSA8IChDX1sxXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzNdID0gKENbM10gKyAweDRkMzRkMzRkICsgKChDWzJdID4+PiAwKSA8IChDX1syXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzRdID0gKENbNF0gKyAweGQzNGQzNGQzICsgKChDWzNdID4+PiAwKSA8IChDX1szXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzVdID0gKENbNV0gKyAweDM0ZDM0ZDM0ICsgKChDWzRdID4+PiAwKSA8IChDX1s0XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzZdID0gKENbNl0gKyAweDRkMzRkMzRkICsgKChDWzVdID4+PiAwKSA8IChDX1s1XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzddID0gKENbN10gKyAweGQzNGQzNGQzICsgKChDWzZdID4+PiAwKSA8IChDX1s2XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICB0aGlzLl9iID0gKENbN10gPj4+IDApIDwgKENfWzddID4+PiAwKSA/IDEgOiAwO1xuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBneCA9IFhbaV0gKyBDW2ldO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnN0cnVjdCBoaWdoIGFuZCBsb3cgYXJndW1lbnQgZm9yIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnYSA9IGd4ICYgMHhmZmZmO1xuXHQgICAgICAgICAgICB2YXIgZ2IgPSBneCA+Pj4gMTY7XG5cblx0ICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdoID0gKCgoKGdhICogZ2EpID4+PiAxNykgKyBnYSAqIGdiKSA+Pj4gMTUpICsgZ2IgKiBnYjtcblx0ICAgICAgICAgICAgdmFyIGdsID0gKCgoZ3ggJiAweGZmZmYwMDAwKSAqIGd4KSB8IDApICsgKCgoZ3ggJiAweDAwMDBmZmZmKSAqIGd4KSB8IDApO1xuXG5cdCAgICAgICAgICAgIC8vIEhpZ2ggWE9SIGxvd1xuXHQgICAgICAgICAgICBHW2ldID0gZ2ggXiBnbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHN0YXRlIHZhbHVlc1xuXHQgICAgICAgIFhbMF0gPSAoR1swXSArICgoR1s3XSA8PCAxNikgfCAoR1s3XSA+Pj4gMTYpKSArICgoR1s2XSA8PCAxNikgfCAoR1s2XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbMV0gPSAoR1sxXSArICgoR1swXSA8PCA4KSAgfCAoR1swXSA+Pj4gMjQpKSArIEdbN10pIHwgMDtcblx0ICAgICAgICBYWzJdID0gKEdbMl0gKyAoKEdbMV0gPDwgMTYpIHwgKEdbMV0gPj4+IDE2KSkgKyAoKEdbMF0gPDwgMTYpIHwgKEdbMF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzNdID0gKEdbM10gKyAoKEdbMl0gPDwgOCkgIHwgKEdbMl0gPj4+IDI0KSkgKyBHWzFdKSB8IDA7XG5cdCAgICAgICAgWFs0XSA9IChHWzRdICsgKChHWzNdIDw8IDE2KSB8IChHWzNdID4+PiAxNikpICsgKChHWzJdIDw8IDE2KSB8IChHWzJdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs1XSA9IChHWzVdICsgKChHWzRdIDw8IDgpICB8IChHWzRdID4+PiAyNCkpICsgR1szXSkgfCAwO1xuXHQgICAgICAgIFhbNl0gPSAoR1s2XSArICgoR1s1XSA8PCAxNikgfCAoR1s1XSA+Pj4gMTYpKSArICgoR1s0XSA8PCAxNikgfCAoR1s0XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbN10gPSAoR1s3XSArICgoR1s2XSA8PCA4KSAgfCAoR1s2XSA+Pj4gMjQpKSArIEdbNV0pIHwgMDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUmFiYml0TGVnYWN5ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0TGVnYWN5KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SYWJiaXRMZWdhY3k7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC1sZWdhY3kuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LWxlZ2FjeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHNcblx0ICAgIHZhciBTICA9IFtdO1xuXHQgICAgdmFyIENfID0gW107XG5cdCAgICB2YXIgRyAgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSYWJiaXQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG1cblx0ICAgICAqL1xuXHQgICAgdmFyIFJhYmJpdCA9IENfYWxnby5SYWJiaXQgPSBTdHJlYW1DaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEsgPSB0aGlzLl9rZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuY2ZnLml2O1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBLW2ldID0gKCgoS1tpXSA8PCA4KSAgfCAoS1tpXSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChLW2ldIDw8IDI0KSB8IChLW2ldID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIHN0YXRlIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1ggPSBbXG5cdCAgICAgICAgICAgICAgICBLWzBdLCAoS1szXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1sxXSwgKEtbMF0gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMl0sIChLWzFdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzNdLCAoS1syXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgQyA9IHRoaXMuX0MgPSBbXG5cdCAgICAgICAgICAgICAgICAoS1syXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLCAoS1swXSAmIDB4ZmZmZjAwMDApIHwgKEtbMV0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzNdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksIChLWzFdICYgMHhmZmZmMDAwMCkgfCAoS1syXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMF0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSwgKEtbMl0gJiAweGZmZmYwMDAwKSB8IChLWzNdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1sxXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpLCAoS1szXSAmIDB4ZmZmZjAwMDApIHwgKEtbMF0gJiAweDAwMDBmZmZmKVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIENhcnJ5IGJpdFxuXHQgICAgICAgICAgICB0aGlzLl9iID0gMDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGNvdW50ZXJzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBDW2ldIF49IFhbKGkgKyA0KSAmIDddO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSVYgc2V0dXBcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBJViA9IGl2LndvcmRzO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzAgPSBJVlswXTtcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8xID0gSVZbMV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xuXHQgICAgICAgICAgICAgICAgdmFyIGkwID0gKCgoSVZfMCA8PCA4KSB8IChJVl8wID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8wIDw8IDI0KSB8IChJVl8wID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMiA9ICgoKElWXzEgPDwgOCkgfCAoSVZfMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMSA8PCAyNCkgfCAoSVZfMSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTEgPSAoaTAgPj4+IDE2KSB8IChpMiAmIDB4ZmZmZjAwMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkzID0gKGkyIDw8IDE2KSAgfCAoaTAgJiAweDAwMDBmZmZmKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgICAgICBDWzBdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1sxXSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbMl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzNdIF49IGkzO1xuXHQgICAgICAgICAgICAgICAgQ1s0XSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbNV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzZdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1s3XSBePSBpMztcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW1cblx0ICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcblx0ICAgICAgICAgICAgU1swXSA9IFhbMF0gXiAoWFs1XSA+Pj4gMTYpIF4gKFhbM10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzFdID0gWFsyXSBeIChYWzddID4+PiAxNikgXiAoWFs1XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMl0gPSBYWzRdIF4gKFhbMV0gPj4+IDE2KSBeIChYWzddIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1szXSA9IFhbNl0gXiAoWFszXSA+Pj4gMTYpIF4gKFhbMV0gPDwgMTYpO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgU1tpXSA9ICgoKFNbaV0gPDwgOCkgIHwgKFNbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoU1tpXSA8PCAyNCkgfCAoU1tpXSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgICAgICBNW29mZnNldCArIGldIF49IFNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gbmV4dFN0YXRlKCkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblx0ICAgICAgICB2YXIgQyA9IHRoaXMuX0M7XG5cblx0ICAgICAgICAvLyBTYXZlIG9sZCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIENfW2ldID0gQ1tpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgQ1swXSA9IChDWzBdICsgMHg0ZDM0ZDM0ZCArIHRoaXMuX2IpIHwgMDtcblx0ICAgICAgICBDWzFdID0gKENbMV0gKyAweGQzNGQzNGQzICsgKChDWzBdID4+PiAwKSA8IChDX1swXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzJdID0gKENbMl0gKyAweDM0ZDM0ZDM0ICsgKChDWzFdID4+PiAwKSA8IChDX1sxXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzNdID0gKENbM10gKyAweDRkMzRkMzRkICsgKChDWzJdID4+PiAwKSA8IChDX1syXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzRdID0gKENbNF0gKyAweGQzNGQzNGQzICsgKChDWzNdID4+PiAwKSA8IChDX1szXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzVdID0gKENbNV0gKyAweDM0ZDM0ZDM0ICsgKChDWzRdID4+PiAwKSA8IChDX1s0XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzZdID0gKENbNl0gKyAweDRkMzRkMzRkICsgKChDWzVdID4+PiAwKSA8IChDX1s1XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzddID0gKENbN10gKyAweGQzNGQzNGQzICsgKChDWzZdID4+PiAwKSA8IChDX1s2XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICB0aGlzLl9iID0gKENbN10gPj4+IDApIDwgKENfWzddID4+PiAwKSA/IDEgOiAwO1xuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBneCA9IFhbaV0gKyBDW2ldO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnN0cnVjdCBoaWdoIGFuZCBsb3cgYXJndW1lbnQgZm9yIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnYSA9IGd4ICYgMHhmZmZmO1xuXHQgICAgICAgICAgICB2YXIgZ2IgPSBneCA+Pj4gMTY7XG5cblx0ICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdoID0gKCgoKGdhICogZ2EpID4+PiAxNykgKyBnYSAqIGdiKSA+Pj4gMTUpICsgZ2IgKiBnYjtcblx0ICAgICAgICAgICAgdmFyIGdsID0gKCgoZ3ggJiAweGZmZmYwMDAwKSAqIGd4KSB8IDApICsgKCgoZ3ggJiAweDAwMDBmZmZmKSAqIGd4KSB8IDApO1xuXG5cdCAgICAgICAgICAgIC8vIEhpZ2ggWE9SIGxvd1xuXHQgICAgICAgICAgICBHW2ldID0gZ2ggXiBnbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHN0YXRlIHZhbHVlc1xuXHQgICAgICAgIFhbMF0gPSAoR1swXSArICgoR1s3XSA8PCAxNikgfCAoR1s3XSA+Pj4gMTYpKSArICgoR1s2XSA8PCAxNikgfCAoR1s2XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbMV0gPSAoR1sxXSArICgoR1swXSA8PCA4KSAgfCAoR1swXSA+Pj4gMjQpKSArIEdbN10pIHwgMDtcblx0ICAgICAgICBYWzJdID0gKEdbMl0gKyAoKEdbMV0gPDwgMTYpIHwgKEdbMV0gPj4+IDE2KSkgKyAoKEdbMF0gPDwgMTYpIHwgKEdbMF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzNdID0gKEdbM10gKyAoKEdbMl0gPDwgOCkgIHwgKEdbMl0gPj4+IDI0KSkgKyBHWzFdKSB8IDA7XG5cdCAgICAgICAgWFs0XSA9IChHWzRdICsgKChHWzNdIDw8IDE2KSB8IChHWzNdID4+PiAxNikpICsgKChHWzJdIDw8IDE2KSB8IChHWzJdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs1XSA9IChHWzVdICsgKChHWzRdIDw8IDgpICB8IChHWzRdID4+PiAyNCkpICsgR1szXSkgfCAwO1xuXHQgICAgICAgIFhbNl0gPSAoR1s2XSArICgoR1s1XSA8PCAxNikgfCAoR1s1XSA+Pj4gMTYpKSArICgoR1s0XSA8PCAxNikgfCAoR1s0XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbN10gPSAoR1s3XSArICgoR1s2XSA8PCA4KSAgfCAoR1s2XSA+Pj4gMjQpKSArIEdbNV0pIHwgMDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUmFiYml0ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SYWJiaXQ7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJDNCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJDNCA9IENfYWxnby5SQzQgPSBTdHJlYW1DaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2lnQnl0ZXMgPSBrZXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBzYm94XG5cdCAgICAgICAgICAgIHZhciBTID0gdGhpcy5fUyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBTW2ldID0gaTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEtleSBzZXR1cFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleUJ5dGVJbmRleCA9IGkgJSBrZXlTaWdCeXRlcztcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlCeXRlID0gKGtleVdvcmRzW2tleUJ5dGVJbmRleCA+Pj4gMl0gPj4+ICgyNCAtIChrZXlCeXRlSW5kZXggJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIGogPSAoaiArIFNbaV0gKyBrZXlCeXRlKSAlIDI1NjtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICAgICAgdmFyIHQgPSBTW2ldO1xuXHQgICAgICAgICAgICAgICAgU1tpXSA9IFNbal07XG5cdCAgICAgICAgICAgICAgICBTW2pdID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50ZXJzXG5cdCAgICAgICAgICAgIHRoaXMuX2kgPSB0aGlzLl9qID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSBePSBnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkKCkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBTID0gdGhpcy5fUztcblx0ICAgICAgICB2YXIgaSA9IHRoaXMuX2k7XG5cdCAgICAgICAgdmFyIGogPSB0aGlzLl9qO1xuXG5cdCAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtIHdvcmRcblx0ICAgICAgICB2YXIga2V5c3RyZWFtV29yZCA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCA0OyBuKyspIHtcblx0ICAgICAgICAgICAgaSA9IChpICsgMSkgJSAyNTY7XG5cdCAgICAgICAgICAgIGogPSAoaiArIFNbaV0pICUgMjU2O1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgdmFyIHQgPSBTW2ldO1xuXHQgICAgICAgICAgICBTW2ldID0gU1tqXTtcblx0ICAgICAgICAgICAgU1tqXSA9IHQ7XG5cblx0ICAgICAgICAgICAga2V5c3RyZWFtV29yZCB8PSBTWyhTW2ldICsgU1tqXSkgJSAyNTZdIDw8ICgyNCAtIG4gKiA4KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBVcGRhdGUgY291bnRlcnNcblx0ICAgICAgICB0aGlzLl9pID0gaTtcblx0ICAgICAgICB0aGlzLl9qID0gajtcblxuXHQgICAgICAgIHJldHVybiBrZXlzdHJlYW1Xb3JkO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJDNC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJDNC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SQzQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzQpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1vZGlmaWVkIFJDNCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJDNERyb3AgPSBDX2FsZ28uUkM0RHJvcCA9IFJDNC5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcm9wIFRoZSBudW1iZXIgb2Yga2V5c3RyZWFtIHdvcmRzIHRvIGRyb3AuIERlZmF1bHQgMTkyXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBSQzQuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGRyb3A6IDE5MlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgUkM0Ll9kb1Jlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gRHJvcFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jZmcuZHJvcDsgaSA+IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SQzREcm9wLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0RHJvcC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SQzREcm9wID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0RHJvcCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUkM0O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYzQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqIEBwcmVzZXJ2ZVxuXHQoYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuXHRSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cblx0ICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXHQgICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblx0VEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXHQqL1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIF96bCA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgIDAsICAxLCAgMiwgIDMsICA0LCAgNSwgIDYsICA3LCAgOCwgIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG5cdCAgICAgICAgNywgIDQsIDEzLCAgMSwgMTAsICA2LCAxNSwgIDMsIDEyLCAgMCwgIDksICA1LCAgMiwgMTQsIDExLCAgOCxcblx0ICAgICAgICAzLCAxMCwgMTQsICA0LCAgOSwgMTUsICA4LCAgMSwgIDIsICA3LCAgMCwgIDYsIDEzLCAxMSwgIDUsIDEyLFxuXHQgICAgICAgIDEsICA5LCAxMSwgMTAsICAwLCAgOCwgMTIsICA0LCAxMywgIDMsICA3LCAxNSwgMTQsICA1LCAgNiwgIDIsXG5cdCAgICAgICAgNCwgIDAsICA1LCAgOSwgIDcsIDEyLCAgMiwgMTAsIDE0LCAgMSwgIDMsICA4LCAxMSwgIDYsIDE1LCAxM10pO1xuXHQgICAgdmFyIF96ciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgIDUsIDE0LCAgNywgIDAsICA5LCAgMiwgMTEsICA0LCAxMywgIDYsIDE1LCAgOCwgIDEsIDEwLCAgMywgMTIsXG5cdCAgICAgICAgNiwgMTEsICAzLCAgNywgIDAsIDEzLCAgNSwgMTAsIDE0LCAxNSwgIDgsIDEyLCAgNCwgIDksICAxLCAgMixcblx0ICAgICAgICAxNSwgIDUsICAxLCAgMywgIDcsIDE0LCAgNiwgIDksIDExLCAgOCwgMTIsICAyLCAxMCwgIDAsICA0LCAxMyxcblx0ICAgICAgICA4LCAgNiwgIDQsICAxLCAgMywgMTEsIDE1LCAgMCwgIDUsIDEyLCAgMiwgMTMsICA5LCAgNywgMTAsIDE0LFxuXHQgICAgICAgIDEyLCAxNSwgMTAsICA0LCAgMSwgIDUsICA4LCAgNywgIDYsICAyLCAxMywgMTQsICAwLCAgMywgIDksIDExXSk7XG5cdCAgICB2YXIgX3NsID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgIDExLCAxNCwgMTUsIDEyLCAgNSwgIDgsICA3LCAgOSwgMTEsIDEzLCAxNCwgMTUsICA2LCAgNywgIDksICA4LFxuXHQgICAgICAgIDcsIDYsICAgOCwgMTMsIDExLCAgOSwgIDcsIDE1LCAgNywgMTIsIDE1LCAgOSwgMTEsICA3LCAxMywgMTIsXG5cdCAgICAgICAgMTEsIDEzLCAgNiwgIDcsIDE0LCAgOSwgMTMsIDE1LCAxNCwgIDgsIDEzLCAgNiwgIDUsIDEyLCAgNywgIDUsXG5cdCAgICAgICAgICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCAgOSwgIDgsICA5LCAxNCwgIDUsICA2LCAgOCwgIDYsICA1LCAxMixcblx0ICAgICAgICA5LCAxNSwgIDUsIDExLCAgNiwgIDgsIDEzLCAxMiwgIDUsIDEyLCAxMywgMTQsIDExLCAgOCwgIDUsICA2IF0pO1xuXHQgICAgdmFyIF9zciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgIDgsICA5LCAgOSwgMTEsIDEzLCAxNSwgMTUsICA1LCAgNywgIDcsICA4LCAxMSwgMTQsIDE0LCAxMiwgIDYsXG5cdCAgICAgICAgOSwgMTMsIDE1LCAgNywgMTIsICA4LCAgOSwgMTEsICA3LCAgNywgMTIsICA3LCAgNiwgMTUsIDEzLCAxMSxcblx0ICAgICAgICA5LCAgNywgMTUsIDExLCAgOCwgIDYsICA2LCAxNCwgMTIsIDEzLCAgNSwgMTQsIDEzLCAxMywgIDcsICA1LFxuXHQgICAgICAgIDE1LCAgNSwgIDgsIDExLCAxNCwgMTQsICA2LCAxNCwgIDYsICA5LCAxMiwgIDksIDEyLCAgNSwgMTUsICA4LFxuXHQgICAgICAgIDgsICA1LCAxMiwgIDksIDEyLCAgNSwgMTQsICA2LCAgOCwgMTMsICA2LCAgNSwgMTUsIDEzLCAxMSwgMTEgXSk7XG5cblx0ICAgIHZhciBfaGwgPSAgV29yZEFycmF5LmNyZWF0ZShbIDB4MDAwMDAwMDAsIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsIDB4OEYxQkJDREMsIDB4QTk1M0ZENEVdKTtcblx0ICAgIHZhciBfaHIgPSAgV29yZEFycmF5LmNyZWF0ZShbIDB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSSVBFTUQxNjAgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBSSVBFTUQxNjAgPSBDX2FsZ28uUklQRU1EMTYwID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCAgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggID0gdGhpcy5faGFzaC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGhsID0gX2hsLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaHIgPSBfaHIud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB6bCA9IF96bC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHpyID0gX3pyLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2wgPSBfc2wud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzciA9IF9zci53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsO1xuXHQgICAgICAgICAgICB2YXIgYXIsIGJyLCBjciwgZHIsIGVyO1xuXG5cdCAgICAgICAgICAgIGFyID0gYWwgPSBIWzBdO1xuXHQgICAgICAgICAgICBiciA9IGJsID0gSFsxXTtcblx0ICAgICAgICAgICAgY3IgPSBjbCA9IEhbMl07XG5cdCAgICAgICAgICAgIGRyID0gZGwgPSBIWzNdO1xuXHQgICAgICAgICAgICBlciA9IGVsID0gSFs0XTtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgdmFyIHQ7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgdCA9IChhbCArICBNW29mZnNldCt6bFtpXV0pfDA7XG5cdCAgICAgICAgICAgICAgICBpZiAoaTwxNil7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjEoYmwsY2wsZGwpICsgaGxbMF07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8MzIpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMihibCxjbCxkbCkgKyBobFsxXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw0OCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYzKGJsLGNsLGRsKSArIGhsWzJdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDY0KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjQoYmwsY2wsZGwpICsgaGxbM107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjUoYmwsY2wsZGwpICsgaGxbNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0ID0gdHwwO1xuXHQgICAgICAgICAgICAgICAgdCA9ICByb3RsKHQsc2xbaV0pO1xuXHQgICAgICAgICAgICAgICAgdCA9ICh0K2VsKXwwO1xuXHQgICAgICAgICAgICAgICAgYWwgPSBlbDtcblx0ICAgICAgICAgICAgICAgIGVsID0gZGw7XG5cdCAgICAgICAgICAgICAgICBkbCA9IHJvdGwoY2wsIDEwKTtcblx0ICAgICAgICAgICAgICAgIGNsID0gYmw7XG5cdCAgICAgICAgICAgICAgICBibCA9IHQ7XG5cblx0ICAgICAgICAgICAgICAgIHQgPSAoYXIgKyBNW29mZnNldCt6cltpXV0pfDA7XG5cdCAgICAgICAgICAgICAgICBpZiAoaTwxNil7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjUoYnIsY3IsZHIpICsgaHJbMF07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8MzIpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNChicixjcixkcikgKyBoclsxXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw0OCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYzKGJyLGNyLGRyKSArIGhyWzJdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDY0KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjIoYnIsY3IsZHIpICsgaHJbM107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjEoYnIsY3IsZHIpICsgaHJbNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0ID0gdHwwO1xuXHQgICAgICAgICAgICAgICAgdCA9ICByb3RsKHQsc3JbaV0pIDtcblx0ICAgICAgICAgICAgICAgIHQgPSAodCtlcil8MDtcblx0ICAgICAgICAgICAgICAgIGFyID0gZXI7XG5cdCAgICAgICAgICAgICAgICBlciA9IGRyO1xuXHQgICAgICAgICAgICAgICAgZHIgPSByb3RsKGNyLCAxMCk7XG5cdCAgICAgICAgICAgICAgICBjciA9IGJyO1xuXHQgICAgICAgICAgICAgICAgYnIgPSB0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIHQgICAgPSAoSFsxXSArIGNsICsgZHIpfDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsyXSArIGRsICsgZXIpfDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFszXSArIGVsICsgYXIpfDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFs0XSArIGFsICsgYnIpfDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFswXSArIGJsICsgY3IpfDA7XG5cdCAgICAgICAgICAgIEhbMF0gPSAgdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWwgPDwgOCkgIHwgKG5CaXRzVG90YWwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXG5cdCAgICBmdW5jdGlvbiBmMSh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoeCkgXiAoeSkgXiAoeikpO1xuXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGYyKHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCgoeCkmKHkpKSB8ICgofngpJih6KSkpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmMyh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoKHgpIHwgKH4oeSkpKSBeICh6KSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGY0KHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCgoeCkgJiAoeikpIHwgKCh5KSYofih6KSkpKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjUoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKHgpIF4gKCh5KSB8KH4oeikpKSk7XG5cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcm90bCh4LG4pIHtcblx0ICAgICAgICByZXR1cm4gKHg8PG4pIHwgKHg+Pj4oMzItbikpO1xuXHQgICAgfVxuXG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5SSVBFTUQxNjAoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlJJUEVNRDE2MCh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlJJUEVNRDE2MCA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFJJUEVNRDE2MCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjUklQRU1EMTYwKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1JJUEVNRDE2MCA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihSSVBFTUQxNjApO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SSVBFTUQxNjA7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JpcGVtZDE2MC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yaXBlbWQxNjAuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsXG5cdCAgICAgICAgICAgICAgICAweGMzZDJlMWYwXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZSA9IGQ7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTE7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhMjU2XCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTI1NlwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMjI0IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMjI0ID0gQ19hbGdvLlNIQTIyNCA9IFNIQTI1Ni5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSxcblx0ICAgICAgICAgICAgICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTRcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gU0hBMjU2Ll9kb0ZpbmFsaXplLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgaGFzaC5zaWdCeXRlcyAtPSA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjI0KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyMjQod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyMjQgPSBTSEEyNTYuX2NyZWF0ZUhlbHBlcihTSEEyMjQpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTIyNChtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyMjQgPSBTSEEyNTYuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjI0KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyMjQ7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyMjQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuXHQgICAgdmFyIEggPSBbXTtcblx0ICAgIHZhciBLID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzUHJpbWUobikge1xuXHQgICAgICAgICAgICB2YXIgc3FydE4gPSBNYXRoLnNxcnQobik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGZhY3RvciA9IDI7IGZhY3RvciA8PSBzcXJ0TjsgZmFjdG9yKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICghKG4gJSBmYWN0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbEJpdHMobikge1xuXHQgICAgICAgICAgICByZXR1cm4gKChuIC0gKG4gfCAwKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBuID0gMjtcblx0ICAgICAgICB2YXIgblByaW1lID0gMDtcblx0ICAgICAgICB3aGlsZSAoblByaW1lIDwgNjQpIHtcblx0ICAgICAgICAgICAgaWYgKGlzUHJpbWUobikpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChuUHJpbWUgPCA4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgSFtuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XG5cblx0ICAgICAgICAgICAgICAgIG5QcmltZSsrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbisrO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMjU2IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NiA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoSC5zbGljZSgwKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cdCAgICAgICAgICAgIHZhciBmID0gSFs1XTtcblx0ICAgICAgICAgICAgdmFyIGcgPSBIWzZdO1xuXHQgICAgICAgICAgICB2YXIgaCA9IEhbN107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweCA9IFdbaSAtIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwICA9ICgoZ2FtbWEweCA8PCAyNSkgfCAoZ2FtbWEweCA+Pj4gNykpICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMHggPDwgMTQpIHwgKGdhbW1hMHggPj4+IDE4KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTB4ID4+PiAzKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMSAgPSAoKGdhbW1hMXggPDwgMTUpIHwgKGdhbW1hMXggPj4+IDE3KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTF4IDw8IDEzKSB8IChnYW1tYTF4ID4+PiAxOSkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWExeCA+Pj4gMTApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1haiA9IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMCA9ICgoYSA8PCAzMCkgfCAoYSA+Pj4gMikpIF4gKChhIDw8IDE5KSB8IChhID4+PiAxMykpIF4gKChhIDw8IDEwKSB8IChhID4+PiAyMikpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMSA9ICgoZSA8PCAyNikgfCAoZSA+Pj4gNikpIF4gKChlIDw8IDIxKSB8IChlID4+PiAxMSkpIF4gKChlIDw8IDcpICB8IChlID4+PiAyNSkpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IHNpZ21hMCArIG1hajtcblxuXHQgICAgICAgICAgICAgICAgaCA9IGc7XG5cdCAgICAgICAgICAgICAgICBnID0gZjtcblx0ICAgICAgICAgICAgICAgIGYgPSBlO1xuXHQgICAgICAgICAgICAgICAgZSA9IChkICsgdDEpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IGI7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSAodDEgKyB0MikgfCAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNV0gPSAoSFs1XSArIGYpIHwgMDtcblx0ICAgICAgICAgICAgSFs2XSA9IChIWzZdICsgZykgfCAwO1xuXHQgICAgICAgICAgICBIWzddID0gKEhbN10gKyBoKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1NignbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyNTYobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1Nik7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTI1NjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjU2LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTI1Ni5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX3g2NCA9IEMueDY0O1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlc1xuXHQgICAgdmFyIFJIT19PRkZTRVRTID0gW107XG5cdCAgICB2YXIgUElfSU5ERVhFUyAgPSBbXTtcblx0ICAgIHZhciBST1VORF9DT05TVEFOVFMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBDb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSByaG8gb2Zmc2V0IGNvbnN0YW50c1xuXHQgICAgICAgIHZhciB4ID0gMSwgeSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG5cdCAgICAgICAgICAgIFJIT19PRkZTRVRTW3ggKyA1ICogeV0gPSAoKHQgKyAxKSAqICh0ICsgMikgLyAyKSAlIDY0O1xuXG5cdCAgICAgICAgICAgIHZhciBuZXdYID0geSAlIDU7XG5cdCAgICAgICAgICAgIHZhciBuZXdZID0gKDIgKiB4ICsgMyAqIHkpICUgNTtcblx0ICAgICAgICAgICAgeCA9IG5ld1g7XG5cdCAgICAgICAgICAgIHkgPSBuZXdZO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbXB1dGUgcGkgaW5kZXggY29uc3RhbnRzXG5cdCAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgIFBJX0lOREVYRVNbeCArIDUgKiB5XSA9IHkgKyAoKDIgKiB4ICsgMyAqIHkpICUgNSkgKiA1O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29tcHV0ZSByb3VuZCBjb25zdGFudHNcblx0ICAgICAgICB2YXIgTEZTUiA9IDB4MDE7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciByb3VuZENvbnN0YW50TXN3ID0gMDtcblx0ICAgICAgICAgICAgdmFyIHJvdW5kQ29uc3RhbnRMc3cgPSAwO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoTEZTUiAmIDB4MDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYml0UG9zaXRpb24gPSAoMSA8PCBqKSAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGJpdFBvc2l0aW9uIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRDb25zdGFudExzdyBePSAxIDw8IGJpdFBvc2l0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoYml0UG9zaXRpb24gPj0gMzIpICovIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRDb25zdGFudE1zdyBePSAxIDw8IChiaXRQb3NpdGlvbiAtIDMyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBMRlNSXG5cdCAgICAgICAgICAgICAgICBpZiAoTEZTUiAmIDB4ODApIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgcG9seW5vbWlhbCBvdmVyIEdGKDIpOiB4XjggKyB4XjYgKyB4XjUgKyB4XjQgKyAxXG5cdCAgICAgICAgICAgICAgICAgICAgTEZTUiA9IChMRlNSIDw8IDEpIF4gMHg3MTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgTEZTUiA8PD0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIFJPVU5EX0NPTlNUQU5UU1tpXSA9IFg2NFdvcmQuY3JlYXRlKHJvdW5kQ29uc3RhbnRNc3csIHJvdW5kQ29uc3RhbnRMc3cpO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHMgZm9yIHRlbXBvcmFyeSB2YWx1ZXNcblx0ICAgIHZhciBUID0gW107XG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gWDY0V29yZC5jcmVhdGUoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0zIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMyA9IENfYWxnby5TSEEzID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG91dHB1dExlbmd0aFxuXHQgICAgICAgICAqICAgVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIG91dHB1dCBoYXNoLlxuXHQgICAgICAgICAqICAgT25seSB2YWx1ZXMgcGVybWl0dGVkIGFyZTogMjI0LCAyNTYsIDM4NCwgNTEyLlxuXHQgICAgICAgICAqICAgRGVmYXVsdDogNTEyXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBIYXNoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIG91dHB1dExlbmd0aDogNTEyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZSA9IFtdXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgc3RhdGVbaV0gPSBuZXcgWDY0V29yZC5pbml0KCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9ICgxNjAwIC0gMiAqIHRoaXMuY2ZnLm91dHB1dExlbmd0aCkgLyAzMjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja1NpemVMYW5lcyA9IHRoaXMuYmxvY2tTaXplIC8gMjtcblxuXHQgICAgICAgICAgICAvLyBBYnNvcmJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQmxvY2tTaXplTGFuZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgTTJpICA9IE1bb2Zmc2V0ICsgMiAqIGldO1xuXHQgICAgICAgICAgICAgICAgdmFyIE0yaTEgPSBNW29mZnNldCArIDIgKiBpICsgMV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBNMmkgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpIDw8IDgpICB8IChNMmkgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpIDw8IDI0KSB8IChNMmkgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgIE0yaTEgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpMSA8PCA4KSAgfCAoTTJpMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkxIDw8IDI0KSB8IChNMmkxID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEFic29yYiBtZXNzYWdlIGludG8gc3RhdGVcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbaV07XG5cdCAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggXj0gTTJpMTtcblx0ICAgICAgICAgICAgICAgIGxhbmUubG93ICBePSBNMmk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBUaGV0YVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBNaXggY29sdW1uIGxhbmVzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSAwLCB0THN3ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW3ggKyA1ICogeV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRNc3cgXj0gbGFuZS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0THN3IF49IGxhbmUubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyeSB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHggPSBUW3hdO1xuXHQgICAgICAgICAgICAgICAgICAgIFR4LmhpZ2ggPSB0TXN3O1xuXHQgICAgICAgICAgICAgICAgICAgIFR4LmxvdyAgPSB0THN3O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHg0ID0gVFsoeCArIDQpICUgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4MSA9IFRbKHggKyAxKSAlIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDFNc3cgPSBUeDEuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHgxTHN3ID0gVHgxLmxvdztcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE1peCBzdXJyb3VuZGluZyBjb2x1bW5zXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSBUeDQuaGlnaCBeICgoVHgxTXN3IDw8IDEpIHwgKFR4MUxzdyA+Pj4gMzEpKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdExzdyA9IFR4NC5sb3cgIF4gKChUeDFMc3cgPDwgMSkgfCAoVHgxTXN3ID4+PiAzMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5oaWdoIF49IHRNc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUubG93ICBePSB0THN3O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmhvIFBpXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBsYW5lSW5kZXggPSAxOyBsYW5lSW5kZXggPCAyNTsgbGFuZUluZGV4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVNc3cgPSBsYW5lLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVMc3cgPSBsYW5lLmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmhvT2Zmc2V0ID0gUkhPX09GRlNFVFNbbGFuZUluZGV4XTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSBsYW5lc1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyaG9PZmZzZXQgPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IChsYW5lTXN3IDw8IHJob09mZnNldCkgfCAobGFuZUxzdyA+Pj4gKDMyIC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0THN3ID0gKGxhbmVMc3cgPDwgcmhvT2Zmc2V0KSB8IChsYW5lTXN3ID4+PiAoMzIgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHJob09mZnNldCA+PSAzMikgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IChsYW5lTHN3IDw8IChyaG9PZmZzZXQgLSAzMikpIHwgKGxhbmVNc3cgPj4+ICg2NCAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdExzdyA9IChsYW5lTXN3IDw8IChyaG9PZmZzZXQgLSAzMikpIHwgKGxhbmVMc3cgPj4+ICg2NCAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zcG9zZSBsYW5lc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUUGlMYW5lID0gVFtQSV9JTkRFWEVTW2xhbmVJbmRleF1dO1xuXHQgICAgICAgICAgICAgICAgICAgIFRQaUxhbmUuaGlnaCA9IHRNc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgVFBpTGFuZS5sb3cgID0gdExzdztcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmhvIHBpIGF0IHggPSB5ID0gMFxuXHQgICAgICAgICAgICAgICAgdmFyIFQwID0gVFswXTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGF0ZTAgPSBzdGF0ZVswXTtcblx0ICAgICAgICAgICAgICAgIFQwLmhpZ2ggPSBzdGF0ZTAuaGlnaDtcblx0ICAgICAgICAgICAgICAgIFQwLmxvdyAgPSBzdGF0ZTAubG93O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBDaGlcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lSW5kZXggPSB4ICsgNSAqIHk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbbGFuZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFRMYW5lID0gVFtsYW5lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVHgxTGFuZSA9IFRbKCh4ICsgMSkgJSA1KSArIDUgKiB5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFR4MkxhbmUgPSBUWygoeCArIDIpICUgNSkgKyA1ICogeV07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IHJvd3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5oaWdoID0gVExhbmUuaGlnaCBeICh+VHgxTGFuZS5oaWdoICYgVHgyTGFuZS5oaWdoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5sb3cgID0gVExhbmUubG93ICBeICh+VHgxTGFuZS5sb3cgICYgVHgyTGFuZS5sb3cpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW90YVxuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVswXTtcblx0ICAgICAgICAgICAgICAgIHZhciByb3VuZENvbnN0YW50ID0gUk9VTkRfQ09OU1RBTlRTW3JvdW5kXTtcblx0ICAgICAgICAgICAgICAgIGxhbmUuaGlnaCBePSByb3VuZENvbnN0YW50LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICBsYW5lLmxvdyAgXj0gcm91bmRDb25zdGFudC5sb3c7O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCaXRzID0gdGhpcy5ibG9ja1NpemUgKiAzMjtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDEgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKChNYXRoLmNlaWwoKG5CaXRzTGVmdCArIDEpIC8gYmxvY2tTaXplQml0cykgKiBibG9ja1NpemVCaXRzKSA+Pj4gNSkgLSAxXSB8PSAweDgwO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgdmFyIG91dHB1dExlbmd0aEJ5dGVzID0gdGhpcy5jZmcub3V0cHV0TGVuZ3RoIC8gODtcblx0ICAgICAgICAgICAgdmFyIG91dHB1dExlbmd0aExhbmVzID0gb3V0cHV0TGVuZ3RoQnl0ZXMgLyA4O1xuXG5cdCAgICAgICAgICAgIC8vIFNxdWVlemVcblx0ICAgICAgICAgICAgdmFyIGhhc2hXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dExlbmd0aExhbmVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtpXTtcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lTXN3ID0gbGFuZS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmVMc3cgPSBsYW5lLmxvdztcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIGxhbmVNc3cgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZU1zdyA8PCA4KSAgfCAobGFuZU1zdyA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTXN3IDw8IDI0KSB8IChsYW5lTXN3ID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICBsYW5lTHN3ID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVMc3cgPDwgOCkgIHwgKGxhbmVMc3cgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZUxzdyA8PCAyNCkgfCAobGFuZUxzdyA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTcXVlZXplIHN0YXRlIHRvIHJldHJpZXZlIGhhc2hcblx0ICAgICAgICAgICAgICAgIGhhc2hXb3Jkcy5wdXNoKGxhbmVMc3cpO1xuXHQgICAgICAgICAgICAgICAgaGFzaFdvcmRzLnB1c2gobGFuZU1zdyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KGhhc2hXb3Jkcywgb3V0cHV0TGVuZ3RoQnl0ZXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSBjbG9uZS5fc3RhdGUgPSB0aGlzLl9zdGF0ZS5zbGljZSgwKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZVtpXSA9IHN0YXRlW2ldLmNsb25lKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMyA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTMpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTMobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMyA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEzKTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhNTEyXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCIsIFwiLi9zaGE1MTJcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ194NjQgPSBDLng2NDtcblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcblx0ICAgIHZhciBYNjRXb3JkQXJyYXkgPSBDX3g2NC5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIFNIQTUxMiA9IENfYWxnby5TSEE1MTI7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTM4NCBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTM4NCA9IENfYWxnby5TSEEzODQgPSBTSEE1MTIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFg2NFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCksIG5ldyBYNjRXb3JkLmluaXQoMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcpLCBuZXcgWDY0V29yZC5pbml0KDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzkpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDY3MzMyNjY3LCAweGZmYzAwYjMxKSwgbmV3IFg2NFdvcmQuaW5pdCgweDhlYjQ0YTg3LCAweDY4NTgxNTExKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyksIG5ldyBYNjRXb3JkLmluaXQoMHg0N2I1NDgxZCwgMHhiZWZhNGZhNClcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gU0hBNTEyLl9kb0ZpbmFsaXplLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgaGFzaC5zaWdCeXRlcyAtPSAxNjtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTM4NCgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMzg0KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMzg0ID0gU0hBNTEyLl9jcmVhdGVIZWxwZXIoU0hBMzg0KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzODQobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMzg0ID0gU0hBNTEyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTM4NCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMzg0O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMzg0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX3g2NCA9IEMueDY0O1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkO1xuXHQgICAgdmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIGZ1bmN0aW9uIFg2NFdvcmRfY3JlYXRlKCkge1xuXHQgICAgICAgIHJldHVybiBYNjRXb3JkLmNyZWF0ZS5hcHBseShYNjRXb3JkLCBhcmd1bWVudHMpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb25zdGFudHNcblx0ICAgIHZhciBLID0gW1xuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIpLCBYNjRXb3JkX2NyZWF0ZSgweDcxMzc0NDkxLCAweDIzZWY2NWNkKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGI1YzBmYmNmLCAweGVjNGQzYjJmKSwgWDY0V29yZF9jcmVhdGUoMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCksIFg2NFdvcmRfY3JlYXRlKDB4NTlmMTExZjEsIDB4YjYwNWQwMTkpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIpLCBYNjRXb3JkX2NyZWF0ZSgweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGQ4MDdhYTk4LCAweGEzMDMwMjQyKSwgWDY0V29yZF9jcmVhdGUoMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksIFg2NFdvcmRfY3JlYXRlKDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYpLCBYNjRXb3JkX2NyZWF0ZSgweDgwZGViMWZlLCAweDNiMTY5NmIxKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDliZGMwNmE3LCAweDI1YzcxMjM1KSwgWDY0V29yZF9jcmVhdGUoMHhjMTliZjE3NCwgMHhjZjY5MjY5NCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhlNDliNjljMSwgMHg5ZWYxNGFkMiksIFg2NFdvcmRfY3JlYXRlKDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUpLCBYNjRXb3JkX2NyZWF0ZSgweDI0MGNhMWNjLCAweDc3YWM5YzY1KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDJkZTkyYzZmLCAweDU5MmIwMjc1KSwgWDY0V29yZF9jcmVhdGUoMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksIFg2NFdvcmRfY3JlYXRlKDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIpLCBYNjRXb3JkX2NyZWF0ZSgweGE4MzFjNjZkLCAweDJkYjQzMjEwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGIwMDMyN2M4LCAweDk4ZmIyMTNmKSwgWDY0V29yZF9jcmVhdGUoMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhjNmUwMGJmMywgMHgzZGE4OGZjMiksIFg2NFdvcmRfY3JlYXRlKDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYpLCBYNjRXb3JkX2NyZWF0ZSgweDE0MjkyOTY3LCAweDBhMGU2ZTcwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI3YjcwYTg1LCAweDQ2ZDIyZmZjKSwgWDY0V29yZF9jcmVhdGUoMHgyZTFiMjEzOCwgMHg1YzI2YzkyNiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksIFg2NFdvcmRfY3JlYXRlKDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NjUwYTczNTQsIDB4OGJhZjYzZGUpLCBYNjRXb3JkX2NyZWF0ZSgweDc2NmEwYWJiLCAweDNjNzdiMmE4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDgxYzJjOTJlLCAweDQ3ZWRhZWU2KSwgWDY0V29yZF9jcmVhdGUoMHg5MjcyMmM4NSwgMHgxNDgyMzUzYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCksIFg2NFdvcmRfY3JlYXRlKDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEpLCBYNjRXb3JkX2NyZWF0ZSgweGM3NmM1MWEzLCAweDA2NTRiZTMwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGQxOTJlODE5LCAweGQ2ZWY1MjE4KSwgWDY0V29yZF9jcmVhdGUoMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksIFg2NFdvcmRfY3JlYXRlKDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgpLCBYNjRXb3JkX2NyZWF0ZSgweDFlMzc2YzA4LCAweDUxNDFhYjUzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI3NDg3NzRjLCAweGRmOGVlYjk5KSwgWDY0V29yZF9jcmVhdGUoMHgzNGIwYmNiNSwgMHhlMTliNDhhOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgzOTFjMGNiMywgMHhjNWM5NWE2MyksIFg2NFdvcmRfY3JlYXRlKDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMpLCBYNjRXb3JkX2NyZWF0ZSgweDY4MmU2ZmYzLCAweGQ2YjJiOGEzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDc0OGY4MmVlLCAweDVkZWZiMmZjKSwgWDY0V29yZF9jcmVhdGUoMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksIFg2NFdvcmRfY3JlYXRlKDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgpLCBYNjRXb3JkX2NyZWF0ZSgweGE0NTA2Y2ViLCAweGRlODJiZGU5KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGJlZjlhM2Y3LCAweGIyYzY3OTE1KSwgWDY0V29yZF9jcmVhdGUoMHhjNjcxNzhmMiwgMHhlMzcyNTMyYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhjYTI3M2VjZSwgMHhlYTI2NjE5YyksIFg2NFdvcmRfY3JlYXRlKDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUpLCBYNjRXb3JkX2NyZWF0ZSgweGY1N2Q0ZjdmLCAweGVlNmVkMTc4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDA2ZjA2N2FhLCAweDcyMTc2ZmJhKSwgWDY0V29yZF9jcmVhdGUoMHgwYTYzN2RjNSwgMHhhMmM4OThhNiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksIFg2NFdvcmRfY3JlYXRlKDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQpLCBYNjRXb3JkX2NyZWF0ZSgweDMyY2FhYjdiLCAweDQwYzcyNDkzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDNjOWViZTBhLCAweDE1YzliZWJjKSwgWDY0V29yZF9jcmVhdGUoMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiksIFg2NFdvcmRfY3JlYXRlKDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMpLCBYNjRXb3JkX2NyZWF0ZSgweDZjNDQxOThjLCAweDRhNDc1ODE3KVxuXHQgICAgXTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0c1xuXHQgICAgdmFyIFcgPSBbXTtcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFdbaV0gPSBYNjRXb3JkX2NyZWF0ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTUxMiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTUxMiA9IENfYWxnby5TSEE1MTIgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFg2NFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCksIG5ldyBYNjRXb3JkLmluaXQoMHhiYjY3YWU4NSwgMHg4NGNhYTczYiksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIpLCBuZXcgWDY0V29yZC5pbml0KDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDUxMGU1MjdmLCAweGFkZTY4MmQxKSwgbmV3IFg2NFdvcmQuaW5pdCgweDliMDU2ODhjLCAweDJiM2U2YzFmKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiksIG5ldyBYNjRXb3JkLmluaXQoMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSlcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBIMCA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBIMSA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBIMiA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBIMyA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBINCA9IEhbNF07XG5cdCAgICAgICAgICAgIHZhciBINSA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBINiA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBINyA9IEhbN107XG5cblx0ICAgICAgICAgICAgdmFyIEgwaCA9IEgwLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIMGwgPSBIMC5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIMWggPSBIMS5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDFsID0gSDEubG93O1xuXHQgICAgICAgICAgICB2YXIgSDJoID0gSDIuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgybCA9IEgyLmxvdztcblx0ICAgICAgICAgICAgdmFyIEgzaCA9IEgzLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIM2wgPSBIMy5sb3c7XG5cdCAgICAgICAgICAgIHZhciBINGggPSBINC5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDRsID0gSDQubG93O1xuXHQgICAgICAgICAgICB2YXIgSDVoID0gSDUuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg1bCA9IEg1Lmxvdztcblx0ICAgICAgICAgICAgdmFyIEg2aCA9IEg2LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBINmwgPSBINi5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIN2ggPSBINy5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDdsID0gSDcubG93O1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhaCA9IEgwaDtcblx0ICAgICAgICAgICAgdmFyIGFsID0gSDBsO1xuXHQgICAgICAgICAgICB2YXIgYmggPSBIMWg7XG5cdCAgICAgICAgICAgIHZhciBibCA9IEgxbDtcblx0ICAgICAgICAgICAgdmFyIGNoID0gSDJoO1xuXHQgICAgICAgICAgICB2YXIgY2wgPSBIMmw7XG5cdCAgICAgICAgICAgIHZhciBkaCA9IEgzaDtcblx0ICAgICAgICAgICAgdmFyIGRsID0gSDNsO1xuXHQgICAgICAgICAgICB2YXIgZWggPSBINGg7XG5cdCAgICAgICAgICAgIHZhciBlbCA9IEg0bDtcblx0ICAgICAgICAgICAgdmFyIGZoID0gSDVoO1xuXHQgICAgICAgICAgICB2YXIgZmwgPSBINWw7XG5cdCAgICAgICAgICAgIHZhciBnaCA9IEg2aDtcblx0ICAgICAgICAgICAgdmFyIGdsID0gSDZsO1xuXHQgICAgICAgICAgICB2YXIgaGggPSBIN2g7XG5cdCAgICAgICAgICAgIHZhciBobCA9IEg3bDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIFdpID0gV1tpXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIG1lc3NhZ2Vcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gV2kuaGlnaCA9IE1bb2Zmc2V0ICsgaSAqIDJdICAgICB8IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IFdpLmxvdyAgPSBNW29mZnNldCArIGkgKiAyICsgMV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBHYW1tYTBcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweCAgPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHhoID0gZ2FtbWEweC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4bCA9IGdhbW1hMHgubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTBoICA9ICgoZ2FtbWEweGggPj4+IDEpIHwgKGdhbW1hMHhsIDw8IDMxKSkgXiAoKGdhbW1hMHhoID4+PiA4KSB8IChnYW1tYTB4bCA8PCAyNCkpIF4gKGdhbW1hMHhoID4+PiA3KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwbCAgPSAoKGdhbW1hMHhsID4+PiAxKSB8IChnYW1tYTB4aCA8PCAzMSkpIF4gKChnYW1tYTB4bCA+Pj4gOCkgfCAoZ2FtbWEweGggPDwgMjQpKSBeICgoZ2FtbWEweGwgPj4+IDcpIHwgKGdhbW1hMHhoIDw8IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBHYW1tYTFcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCAgPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeGggPSBnYW1tYTF4LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXhsID0gZ2FtbWExeC5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMWggID0gKChnYW1tYTF4aCA+Pj4gMTkpIHwgKGdhbW1hMXhsIDw8IDEzKSkgXiAoKGdhbW1hMXhoIDw8IDMpIHwgKGdhbW1hMXhsID4+PiAyOSkpIF4gKGdhbW1hMXhoID4+PiA2KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExbCAgPSAoKGdhbW1hMXhsID4+PiAxOSkgfCAoZ2FtbWExeGggPDwgMTMpKSBeICgoZ2FtbWExeGwgPDwgMykgfCAoZ2FtbWExeGggPj4+IDI5KSkgXiAoKGdhbW1hMXhsID4+PiA2KSB8IChnYW1tYTF4aCA8PCAyNikpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpNyAgPSBXW2kgLSA3XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2k3aCA9IFdpNy5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTdsID0gV2k3LmxvdztcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTE2ICA9IFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2kxNmggPSBXaTE2LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpMTZsID0gV2kxNi5sb3c7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gZ2FtbWEwbCArIFdpN2w7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IGdhbW1hMGggKyBXaTdoICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMGwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBXaWwgKyBnYW1tYTFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBXaWggKyBnYW1tYTFoICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMWwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBXaWwgKyBXaTE2bDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gV2loICsgV2kxNmggKyAoKFdpbCA+Pj4gMCkgPCAoV2kxNmwgPj4+IDApID8gMSA6IDApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgV2kuaGlnaCA9IFdpaDtcblx0ICAgICAgICAgICAgICAgICAgICBXaS5sb3cgID0gV2lsO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgY2hoICA9IChlaCAmIGZoKSBeICh+ZWggJiBnaCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hsICA9IChlbCAmIGZsKSBeICh+ZWwgJiBnbCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqaCA9IChhaCAmIGJoKSBeIChhaCAmIGNoKSBeIChiaCAmIGNoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWpsID0gKGFsICYgYmwpIF4gKGFsICYgY2wpIF4gKGJsICYgY2wpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwaCA9ICgoYWggPj4+IDI4KSB8IChhbCA8PCA0KSkgIF4gKChhaCA8PCAzMCkgIHwgKGFsID4+PiAyKSkgXiAoKGFoIDw8IDI1KSB8IChhbCA+Pj4gNykpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMGwgPSAoKGFsID4+PiAyOCkgfCAoYWggPDwgNCkpICBeICgoYWwgPDwgMzApICB8IChhaCA+Pj4gMikpIF4gKChhbCA8PCAyNSkgfCAoYWggPj4+IDcpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTFoID0gKChlaCA+Pj4gMTQpIHwgKGVsIDw8IDE4KSkgXiAoKGVoID4+PiAxOCkgfCAoZWwgPDwgMTQpKSBeICgoZWggPDwgMjMpIHwgKGVsID4+PiA5KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExbCA9ICgoZWwgPj4+IDE0KSB8IChlaCA8PCAxOCkpIF4gKChlbCA+Pj4gMTgpIHwgKGVoIDw8IDE0KSkgXiAoKGVsIDw8IDIzKSB8IChlaCA+Pj4gOSkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldXG5cdCAgICAgICAgICAgICAgICB2YXIgS2kgID0gS1tpXTtcblx0ICAgICAgICAgICAgICAgIHZhciBLaWggPSBLaS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgdmFyIEtpbCA9IEtpLmxvdztcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IGhsICsgc2lnbWExbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSBoaCArIHNpZ21hMWggKyAoKHQxbCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IHQxbCArIGNobDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSB0MWggKyBjaGggKyAoKHQxbCA+Pj4gMCkgPCAoY2hsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSB0MWwgKyBLaWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gdDFoICsgS2loICsgKCh0MWwgPj4+IDApIDwgKEtpbCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gdDFsICsgV2lsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IHQxaCArIFdpaCArICgodDFsID4+PiAwKSA8IChXaWwgPj4+IDApID8gMSA6IDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuXHQgICAgICAgICAgICAgICAgdmFyIHQybCA9IHNpZ21hMGwgKyBtYWpsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyaCA9IHNpZ21hMGggKyBtYWpoICsgKCh0MmwgPj4+IDApIDwgKHNpZ21hMGwgPj4+IDApID8gMSA6IDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgICAgIGhoID0gZ2g7XG5cdCAgICAgICAgICAgICAgICBobCA9IGdsO1xuXHQgICAgICAgICAgICAgICAgZ2ggPSBmaDtcblx0ICAgICAgICAgICAgICAgIGdsID0gZmw7XG5cdCAgICAgICAgICAgICAgICBmaCA9IGVoO1xuXHQgICAgICAgICAgICAgICAgZmwgPSBlbDtcblx0ICAgICAgICAgICAgICAgIGVsID0gKGRsICsgdDFsKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBlaCA9IChkaCArIHQxaCArICgoZWwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZGggPSBjaDtcblx0ICAgICAgICAgICAgICAgIGRsID0gY2w7XG5cdCAgICAgICAgICAgICAgICBjaCA9IGJoO1xuXHQgICAgICAgICAgICAgICAgY2wgPSBibDtcblx0ICAgICAgICAgICAgICAgIGJoID0gYWg7XG5cdCAgICAgICAgICAgICAgICBibCA9IGFsO1xuXHQgICAgICAgICAgICAgICAgYWwgPSAodDFsICsgdDJsKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBhaCA9ICh0MWggKyB0MmggKyAoKGFsID4+PiAwKSA8ICh0MWwgPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIMGwgPSBIMC5sb3cgID0gKEgwbCArIGFsKTtcblx0ICAgICAgICAgICAgSDAuaGlnaCA9IChIMGggKyBhaCArICgoSDBsID4+PiAwKSA8IChhbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIMWwgPSBIMS5sb3cgID0gKEgxbCArIGJsKTtcblx0ICAgICAgICAgICAgSDEuaGlnaCA9IChIMWggKyBiaCArICgoSDFsID4+PiAwKSA8IChibCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIMmwgPSBIMi5sb3cgID0gKEgybCArIGNsKTtcblx0ICAgICAgICAgICAgSDIuaGlnaCA9IChIMmggKyBjaCArICgoSDJsID4+PiAwKSA8IChjbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIM2wgPSBIMy5sb3cgID0gKEgzbCArIGRsKTtcblx0ICAgICAgICAgICAgSDMuaGlnaCA9IChIM2ggKyBkaCArICgoSDNsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBINGwgPSBINC5sb3cgID0gKEg0bCArIGVsKTtcblx0ICAgICAgICAgICAgSDQuaGlnaCA9IChINGggKyBlaCArICgoSDRsID4+PiAwKSA8IChlbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBINWwgPSBINS5sb3cgID0gKEg1bCArIGZsKTtcblx0ICAgICAgICAgICAgSDUuaGlnaCA9IChINWggKyBmaCArICgoSDVsID4+PiAwKSA8IChmbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBINmwgPSBINi5sb3cgID0gKEg2bCArIGdsKTtcblx0ICAgICAgICAgICAgSDYuaGlnaCA9IChINmggKyBnaCArICgoSDZsID4+PiAwKSA8IChnbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIN2wgPSBINy5sb3cgID0gKEg3bCArIGhsKTtcblx0ICAgICAgICAgICAgSDcuaGlnaCA9IChIN2ggKyBoaCArICgoSDdsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyAxMjgpID4+PiAxMCkgPDwgNSkgKyAzMF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyAxMjgpID4+PiAxMCkgPDwgNSkgKyAzMV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgaGFzaCB0byAzMi1iaXQgd29yZCBhcnJheSBiZWZvcmUgcmV0dXJuaW5nXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaC50b1gzMigpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEwMjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEE1MTIpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTUxMihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBNTEyKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEE1MTI7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGE1MTIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFBlcm11dGVkIENob2ljZSAxIGNvbnN0YW50c1xuXHQgICAgdmFyIFBDMSA9IFtcblx0ICAgICAgICA1NywgNDksIDQxLCAzMywgMjUsIDE3LCA5LCAgMSxcblx0ICAgICAgICA1OCwgNTAsIDQyLCAzNCwgMjYsIDE4LCAxMCwgMixcblx0ICAgICAgICA1OSwgNTEsIDQzLCAzNSwgMjcsIDE5LCAxMSwgMyxcblx0ICAgICAgICA2MCwgNTIsIDQ0LCAzNiwgNjMsIDU1LCA0NywgMzksXG5cdCAgICAgICAgMzEsIDIzLCAxNSwgNywgIDYyLCA1NCwgNDYsIDM4LFxuXHQgICAgICAgIDMwLCAyMiwgMTQsIDYsICA2MSwgNTMsIDQ1LCAzNyxcblx0ICAgICAgICAyOSwgMjEsIDEzLCA1LCAgMjgsIDIwLCAxMiwgNFxuXHQgICAgXTtcblxuXHQgICAgLy8gUGVybXV0ZWQgQ2hvaWNlIDIgY29uc3RhbnRzXG5cdCAgICB2YXIgUEMyID0gW1xuXHQgICAgICAgIDE0LCAxNywgMTEsIDI0LCAxLCAgNSxcblx0ICAgICAgICAzLCAgMjgsIDE1LCA2LCAgMjEsIDEwLFxuXHQgICAgICAgIDIzLCAxOSwgMTIsIDQsICAyNiwgOCxcblx0ICAgICAgICAxNiwgNywgIDI3LCAyMCwgMTMsIDIsXG5cdCAgICAgICAgNDEsIDUyLCAzMSwgMzcsIDQ3LCA1NSxcblx0ICAgICAgICAzMCwgNDAsIDUxLCA0NSwgMzMsIDQ4LFxuXHQgICAgICAgIDQ0LCA0OSwgMzksIDU2LCAzNCwgNTMsXG5cdCAgICAgICAgNDYsIDQyLCA1MCwgMzYsIDI5LCAzMlxuXHQgICAgXTtcblxuXHQgICAgLy8gQ3VtdWxhdGl2ZSBiaXQgc2hpZnQgY29uc3RhbnRzXG5cdCAgICB2YXIgQklUX1NISUZUUyA9IFsxLCAgMiwgIDQsICA2LCAgOCwgIDEwLCAxMiwgMTQsIDE1LCAxNywgMTksIDIxLCAyMywgMjUsIDI3LCAyOF07XG5cblx0ICAgIC8vIFNCT1hlcyBhbmQgcm91bmQgcGVybXV0YXRpb24gY29uc3RhbnRzXG5cdCAgICB2YXIgU0JPWF9QID0gW1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwMDogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDIwMDAwMDAwOiAweDgwODAwMixcblx0ICAgICAgICAgICAgMHgzMDAwMDAwMDogMHgyLFxuXHQgICAgICAgICAgICAweDQwMDAwMDAwOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg1MDAwMDAwMDogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwMDA6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweDcwMDAwMDAwOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMDogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwMDA6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDAwOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwMDA6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweGMwMDAwMDAwOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwMDA6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweGUwMDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwMDA6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHg4MDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDA6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDI4MDAwMDAwOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwMDA6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDAwMDogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwMDA6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDY4MDAwMDAwOiAweDgwODAwMixcblx0ICAgICAgICAgICAgMHg3ODAwMDAwMDogMHgyLFxuXHQgICAgICAgICAgICAweDg4MDAwMDAwOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHg5ODAwMDAwMDogMHg4MjAwLFxuXHQgICAgICAgICAgICAweGE4MDAwMDAwOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDAwMDogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwMDA6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDAwOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwMDA6IDB4MjAyLFxuXHQgICAgICAgICAgICAweGY4MDAwMDAwOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHgxOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDE6IDB4Mixcblx0ICAgICAgICAgICAgMHgyMDAwMDAwMTogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwMDE6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDQwMDAwMDAxOiAweDgwODAwMixcblx0ICAgICAgICAgICAgMHg1MDAwMDAwMTogMHg4MjAwLFxuXHQgICAgICAgICAgICAweDYwMDAwMDAxOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg3MDAwMDAwMTogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDE6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDkwMDAwMDAxOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDAwMTogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwMDE6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHhjMDAwMDAwMTogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwMDE6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweGUwMDAwMDAxOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwMDE6IDB4MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHgxODAwMDAwMTogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwMDE6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDM4MDAwMDAxOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDAwMTogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDU4MDAwMDAxOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHg2ODAwMDAwMTogMHgyLFxuXHQgICAgICAgICAgICAweDc4MDAwMDAxOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwMDE6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHg5ODAwMDAwMTogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwMDE6IDB4MjAyLFxuXHQgICAgICAgICAgICAweGI4MDAwMDAxOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHhjODAwMDAwMTogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwMDE6IDB4MCxcblx0ICAgICAgICAgICAgMHhlODAwMDAwMTogMHg4MjAwLFxuXHQgICAgICAgICAgICAweGY4MDAwMDAxOiAweDgwODAwMlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweDIwMDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHg0MDAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweDUwMDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHg3MDAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA6IDB4ODQwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweGIwMDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHhkMDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweGYwMDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHgzODAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg2ODAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDc4MDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHg5ODAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHhkODAwMDAwOiAweDg0MDAwLFxuXHQgICAgICAgICAgICAweGU4MDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4MTIwMDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4MTMwMDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4MTQwMDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4MTYwMDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTcwMDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweDE5MDAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweDFiMDAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweDFjMDAwMDAwOiAweDg0MDAwLFxuXHQgICAgICAgICAgICAweDFkMDAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDFlMDAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFmMDAwMDAwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDEwODAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweDExODAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDEyODAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweDEzODAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDAwMDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTY4MDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4MTc4MDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4MWE4MDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4MWI4MDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4MWM4MDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZDgwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweDFlODAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDFmODAwMDAwOiAweDg0MDAwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweDQwMDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHg1MDAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHg2MDAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHg3MDAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDA6IDB4MTAxMDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweGUwMDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweGYwMDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHgyODAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgzODAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHg1ODAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDc4MDAwMDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHhhODAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwOiAweDEwMTAwLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweGU4MDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweGY4MDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHgxMTAwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDEyMDAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4MTMwMDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDE0MDAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweDE1MDAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHgxNjAwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4MTcwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHgxOTAwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweDFiMDAwMDA6IDB4MTAxMDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweDFkMDAwMDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDFlMDAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4MWYwMDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweDEwODAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMTgwMDAwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHgxMjgwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE0ODAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTU4MDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDE2ODAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweDE3ODAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHgxODgwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweDE5ODAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHgxYTgwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweDFiODAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHgxYzgwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4MWQ4MDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweDFlODAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHgxZjgwMDAwOiAweDEwMTAwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgyMDAwMDogMHg0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHg1MDAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4NjAwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4NzAwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweDgwMDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDkwMDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHhiMDAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHhjMDAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHhkMDAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweGUwMDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgxODAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHgyODAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgzODAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHg3ODAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHg4ODAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweDk4MDAwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweGE4MDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweGM4MDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweGQ4MDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHhlODAwMDogMHg0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxMTAwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDEyMDAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHgxMzAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxNDAwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHgxNTAwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTYwMDAwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweDE3MDAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgxODAwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTkwMDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYjAwMDA6IDB4NDAxMDQwLFxuXHQgICAgICAgICAgICAweDFjMDAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweDFlMDAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHgxZjAwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHgxMDgwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTE4MDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDEyODAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDEzODAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxNTgwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTY4MDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDE3ODAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHgxODgwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWE4MDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweDFiODAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxYzgwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHgxZDgwMDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZjgwMDA6IDB4NDAxMDQwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MCxcblx0ICAgICAgICAgICAgMHgxMDAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHgzMDAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDQwMDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4NTAwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDYwMDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4NzAwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHg4MDAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHhhMDAwOiAweDIwMDAwMDgwLFxuXHQgICAgICAgICAgICAweGIwMDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4YzAwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHhkMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweGYwMDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTgwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgyODAwOiAweDgwLFxuXHQgICAgICAgICAgICAweDM4MDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHg0ODAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDU4MDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4NjgwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHg3ODAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDg4MDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTgwMDogMHgwLFxuXHQgICAgICAgICAgICAweGE4MDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4YjgwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweGM4MDA6IDB4MjAwMDAwODAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHhlODAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHgxMDAwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHgxMTAwMDogMHg4MCxcblx0ICAgICAgICAgICAgMHgxMjAwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMzAwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxNDAwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDE1MDAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDE2MDAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE3MDAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTkwMDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxYjAwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxYzAwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHgxZDAwMDogMHgyMDAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxZTAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFmMDAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTA4MDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MTE4MDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMjgwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDEzODAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE0ODAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE1ODAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTY4MDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MTc4MDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4MTk4MDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MWE4MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxYjgwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYzgwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDFkODAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDFlODAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweDFmODAwOiAweDIwMDAwMDgwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHgxMDA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHgyMDA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzAwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDQwMDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHg1MDA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDYwMDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4NzAwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDogMHgwLFxuXHQgICAgICAgICAgICAweDkwMDogMHgxMDAwMjAwOCxcblx0ICAgICAgICAgICAgMHhhMDA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweGIwMDogMHg4LFxuXHQgICAgICAgICAgICAweGMwMDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHhkMDA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweGUwMDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweGYwMDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHg4MDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MjgwOiAweDgsXG5cdCAgICAgICAgICAgIDB4MzgwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHg0ODA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweDU4MDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHg2ODA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4NzgwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4ODgwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHg5ODA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHhhODA6IDB4MTAwMDIwMDgsXG5cdCAgICAgICAgICAgIDB4YjgwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweGM4MDogMHgwLFxuXHQgICAgICAgICAgICAweGQ4MDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHhlODA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweGY4MDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDExMDA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTIwMDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxMzAwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTQwMDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNjAwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDE3MDA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweDE4MDA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweDE5MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxYTAwOiAweDgsXG5cdCAgICAgICAgICAgIDB4MWIwMDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYzAwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDogMHgxMDAwMjAwOCxcblx0ICAgICAgICAgICAgMHgxZTAwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweDFmMDA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDEwODA6IDB4OCxcblx0ICAgICAgICAgICAgMHgxMTgwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxMjgwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMzgwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDE0ODA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweDE2ODA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTc4MDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODgwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweDE5ODA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MWE4MDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweDFiODA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweDFjODA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDFkODA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZTgwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFmODA6IDB4MTAwMDIwMDhcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDIwOiAweDQwMCxcblx0ICAgICAgICAgICAgMHgzMDogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4NDA6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHg1MDogMHgwLFxuXHQgICAgICAgICAgICAweDYwOiAweDEsXG5cdCAgICAgICAgICAgIDB4NzA6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHg4MDogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweDkwOiAweDEwMDAwMSxcblx0ICAgICAgICAgICAgMHhhMDogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweGIwOiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4YzA6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHhkMDogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4ZTA6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweGYwOiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDE4OiAweDAsXG5cdCAgICAgICAgICAgIDB4Mjg6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgzODogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweDQ4OiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHg1ODogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweDY4OiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4Nzg6IDB4NDAxLFxuXHQgICAgICAgICAgICAweDg4OiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHg5ODogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweGE4OiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4Yjg6IDB4MTAwMDAxLFxuXHQgICAgICAgICAgICAweGM4OiAweDQwMCxcblx0ICAgICAgICAgICAgMHhkODogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweGU4OiAweDEsXG5cdCAgICAgICAgICAgIDB4Zjg6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweDEwMDogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDExMDogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTIwOiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MTMwOiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTQwOiAweDEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxNTA6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHgxNjA6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxNzA6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDE4MDogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4MTkwOiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MWEwOiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxYjA6IDB4MSxcblx0ICAgICAgICAgICAgMHgxYzA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZDA6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZTA6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHgxZjA6IDB4NDAwLFxuXHQgICAgICAgICAgICAweDEwODogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTE4OiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MTI4OiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTM4OiAweDEsXG5cdCAgICAgICAgICAgIDB4MTQ4OiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4OiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNjg6IDB4NDAxLFxuXHQgICAgICAgICAgICAweDE3ODogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweDE4ODogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweDE5ODogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweDFhODogMHgwLFxuXHQgICAgICAgICAgICAweDFiODogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweDFjODogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MWQ4OiAweDQwMCxcblx0ICAgICAgICAgICAgMHgxZTg6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHgxZjg6IDB4MTAwMDAxXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDE6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4MjogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDM6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4NDogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHg1OiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4NjogMHg4MDIwODAwLFxuXHQgICAgICAgICAgICAweDc6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDg6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHg5OiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4YTogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHhiOiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4YzogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4ZDogMHgwLFxuXHQgICAgICAgICAgICAweGU6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHhmOiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAwOiAweDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMTogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAyOiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDM6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNDogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA1OiAweDIwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA2OiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA3OiAweDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA4OiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDk6IDB4ODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBhOiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBiOiAweDgwMjA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGM6IDB4MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwZDogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBlOiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGY6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4MTA6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4MTE6IDB4ODAyMDgwMCxcblx0ICAgICAgICAgICAgMHgxMjogMHgyMCxcblx0ICAgICAgICAgICAgMHgxMzogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4MTQ6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHgxNTogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweDE2OiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4MTc6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg6IDB4MCxcblx0ICAgICAgICAgICAgMHgxOTogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHgxYTogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDFiOiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4MWM6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHgxZDogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHgxZTogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4MWY6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMDogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMTogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTI6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMzogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNDogMHgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNTogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE2OiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTc6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxODogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE5OiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWE6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxYjogMHgwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFjOiAweDIwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFkOiAweDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxZTogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxZjogMHg4MDIwODAwXG5cdCAgICAgICAgfVxuXHQgICAgXTtcblxuXHQgICAgLy8gTWFza3MgdGhhdCBzZWxlY3QgdGhlIFNCT1ggaW5wdXRcblx0ICAgIHZhciBTQk9YX01BU0sgPSBbXG5cdCAgICAgICAgMHhmODAwMDAwMSwgMHgxZjgwMDAwMCwgMHgwMWY4MDAwMCwgMHgwMDFmODAwMCxcblx0ICAgICAgICAweDAwMDFmODAwLCAweDAwMDAxZjgwLCAweDAwMDAwMWY4LCAweDgwMDAwMDFmXG5cdCAgICBdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgREVTID0gQ19hbGdvLkRFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTZWxlY3QgNTYgYml0cyBhY2NvcmRpbmcgdG8gUEMxXG5cdCAgICAgICAgICAgIHZhciBrZXlCaXRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleUJpdFBvcyA9IFBDMVtpXSAtIDE7XG5cdCAgICAgICAgICAgICAgICBrZXlCaXRzW2ldID0gKGtleVdvcmRzW2tleUJpdFBvcyA+Pj4gNV0gPj4+ICgzMSAtIGtleUJpdFBvcyAlIDMyKSkgJiAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXNzZW1ibGUgMTYgc3Via2V5c1xuXHQgICAgICAgICAgICB2YXIgc3ViS2V5cyA9IHRoaXMuX3N1YktleXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgblN1YktleSA9IDA7IG5TdWJLZXkgPCAxNjsgblN1YktleSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc3Via2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViS2V5ID0gc3ViS2V5c1tuU3ViS2V5XSA9IFtdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIGJpdFNoaWZ0ID0gQklUX1NISUZUU1tuU3ViS2V5XTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU2VsZWN0IDQ4IGJpdHMgYWNjb3JkaW5nIHRvIFBDMlxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZyb20gdGhlIGxlZnQgMjgga2V5IGJpdHNcblx0ICAgICAgICAgICAgICAgICAgICBzdWJLZXlbKGkgLyA2KSB8IDBdIHw9IGtleUJpdHNbKChQQzJbaV0gLSAxKSArIGJpdFNoaWZ0KSAlIDI4XSA8PCAoMzEgLSBpICUgNik7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgcmlnaHQgMjgga2V5IGJpdHNcblx0ICAgICAgICAgICAgICAgICAgICBzdWJLZXlbNCArICgoaSAvIDYpIHwgMCldIHw9IGtleUJpdHNbMjggKyAoKChQQzJbaSArIDI0XSAtIDEpICsgYml0U2hpZnQpICUgMjgpXSA8PCAoMzEgLSBpICUgNik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNpbmNlIGVhY2ggc3Via2V5IGlzIGFwcGxpZWQgdG8gYW4gZXhwYW5kZWQgMzItYml0IGlucHV0LFxuXHQgICAgICAgICAgICAgICAgLy8gdGhlIHN1YmtleSBjYW4gYmUgYnJva2VuIGludG8gOCB2YWx1ZXMgc2NhbGVkIHRvIDMyLWJpdHMsXG5cdCAgICAgICAgICAgICAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGtleSB0byBiZSB1c2VkIHdpdGhvdXQgZXhwYW5zaW9uXG5cdCAgICAgICAgICAgICAgICBzdWJLZXlbMF0gPSAoc3ViS2V5WzBdIDw8IDEpIHwgKHN1YktleVswXSA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA3OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJLZXlbaV0gPSBzdWJLZXlbaV0gPj4+ICgoaSAtIDEpICogNCArIDMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc3ViS2V5WzddID0gKHN1YktleVs3XSA8PCA1KSB8IChzdWJLZXlbN10gPj4+IDI3KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52ZXJzZSBzdWJrZXlzXG5cdCAgICAgICAgICAgIHZhciBpbnZTdWJLZXlzID0gdGhpcy5faW52U3ViS2V5cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGludlN1YktleXNbaV0gPSBzdWJLZXlzWzE1IC0gaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX3N1YktleXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52U3ViS2V5cyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIHN1YktleXMpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0XG5cdCAgICAgICAgICAgIHRoaXMuX2xCbG9jayA9IE1bb2Zmc2V0XTtcblx0ICAgICAgICAgICAgdGhpcy5fckJsb2NrID0gTVtvZmZzZXQgKyAxXTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHBlcm11dGF0aW9uXG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCA0LCAgMHgwZjBmMGYwZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxNiwgMHgwMDAwZmZmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCAyLCAgMHgzMzMzMzMzMyk7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCA4LCAgMHgwMGZmMDBmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAgMHg1NTU1NTU1NSk7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCAxNjsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViS2V5ID0gc3ViS2V5c1tyb3VuZF07XG5cdCAgICAgICAgICAgICAgICB2YXIgbEJsb2NrID0gdGhpcy5fbEJsb2NrO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJCbG9jayA9IHRoaXMuX3JCbG9jaztcblxuXHQgICAgICAgICAgICAgICAgLy8gRmVpc3RlbCBmdW5jdGlvblxuXHQgICAgICAgICAgICAgICAgdmFyIGYgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBmIHw9IFNCT1hfUFtpXVsoKHJCbG9jayBeIHN1YktleVtpXSkgJiBTQk9YX01BU0tbaV0pID4+PiAwXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xCbG9jayA9IHJCbG9jaztcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JCbG9jayA9IGxCbG9jayBeIGY7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVbmRvIHN3YXAgZnJvbSBsYXN0IHJvdW5kXG5cdCAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbEJsb2NrO1xuXHQgICAgICAgICAgICB0aGlzLl9sQmxvY2sgPSB0aGlzLl9yQmxvY2s7XG5cdCAgICAgICAgICAgIHRoaXMuX3JCbG9jayA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gRmluYWwgcGVybXV0YXRpb25cblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDEsICAweDU1NTU1NTU1KTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsICAweDAwZmYwMGZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDIsICAweDMzMzMzMzMzKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDQsICAweDBmMGYwZjBmKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSA9IHRoaXMuX2xCbG9jaztcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHRoaXMuX3JCbG9jaztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogNjQvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyLFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8vIFN3YXAgYml0cyBhY3Jvc3MgdGhlIGxlZnQgYW5kIHJpZ2h0IHdvcmRzXG5cdCAgICBmdW5jdGlvbiBleGNoYW5nZUxSKG9mZnNldCwgbWFzaykge1xuXHQgICAgICAgIHZhciB0ID0gKCh0aGlzLl9sQmxvY2sgPj4+IG9mZnNldCkgXiB0aGlzLl9yQmxvY2spICYgbWFzaztcblx0ICAgICAgICB0aGlzLl9yQmxvY2sgXj0gdDtcblx0ICAgICAgICB0aGlzLl9sQmxvY2sgXj0gdCA8PCBvZmZzZXQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGV4Y2hhbmdlUkwob2Zmc2V0LCBtYXNrKSB7XG5cdCAgICAgICAgdmFyIHQgPSAoKHRoaXMuX3JCbG9jayA+Pj4gb2Zmc2V0KSBeIHRoaXMuX2xCbG9jaykgJiBtYXNrO1xuXHQgICAgICAgIHRoaXMuX2xCbG9jayBePSB0O1xuXHQgICAgICAgIHRoaXMuX3JCbG9jayBePSB0IDw8IG9mZnNldDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5ERVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5ERVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihERVMpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRyaXBsZS1ERVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFRyaXBsZURFUyA9IENfYWxnby5UcmlwbGVERVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIERFUyBpbnN0YW5jZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMSA9IERFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgwLCAyKSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMyID0gREVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDIsIDQpKSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczMgPSBERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoNCwgNikpKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczEuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczIuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczMuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMyLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMxLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxOTIvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyLFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuVHJpcGxlREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuVHJpcGxlREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlRyaXBsZURFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoVHJpcGxlREVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5UcmlwbGVERVM7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3RyaXBsZWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy90cmlwbGVkZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgWDMyV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXG5cdCAgICAvKipcblx0ICAgICAqIHg2NCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX3g2NCA9IEMueDY0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSA2NC1iaXQgd29yZC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCA2NC1iaXQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIDMyIGJpdHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IDMyIGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB4NjRXb3JkID0gQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoaWdoLCBsb3cpIHtcblx0ICAgICAgICAgICAgdGhpcy5oaWdoID0gaGlnaDtcblx0ICAgICAgICAgICAgdGhpcy5sb3cgPSBsb3c7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBOT1RzIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBuZWdhdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG5lZ2F0ZWQgPSB4NjRXb3JkLm5vdCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIG5vdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IH50aGlzLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB+dGhpcy5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgQU5EcyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIEFORCB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBBTkRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBhbmRlZCA9IHg2NFdvcmQuYW5kKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBhbmQ6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoICYgd29yZC5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgJiB3b3JkLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBPUnMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBPUiB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBPUmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9yZWQgPSB4NjRXb3JkLm9yKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBvcjogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggfCB3b3JkLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyB8IHdvcmQubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIFhPUnMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBYT1Igd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgWE9SaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgeG9yZWQgPSB4NjRXb3JkLnhvcihhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8geG9yOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCBeIHdvcmQuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IF4gd29yZC5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNoaWZ0cyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSBsZWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHNoaWZ0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc2hpZnRlZCA9IHg2NFdvcmQuc2hpZnRMKDI1KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBzaGlmdEw6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIGlmIChuIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gKHRoaXMuaGlnaCA8PCBuKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbikpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IDw8IG47XG5cdCAgICAgICAgICAgIC8vIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMubG93IDw8IChuIC0gMzIpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9IDA7XG5cdCAgICAgICAgICAgIC8vIH1cblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogU2hpZnRzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIHJpZ2h0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHNoaWZ0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc2hpZnRlZCA9IHg2NFdvcmQuc2hpZnRSKDcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHNoaWZ0UjogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gaWYgKG4gPCAzMikge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9ICh0aGlzLmxvdyA+Pj4gbikgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG4pKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoID4+PiBuO1xuXHQgICAgICAgICAgICAvLyB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMuaGlnaCA+Pj4gKG4gLSAzMik7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IDA7XG5cdCAgICAgICAgICAgIC8vIH1cblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUm90YXRlcyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSBsZWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciByb3RhdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHJvdGF0ZWQgPSB4NjRXb3JkLnJvdEwoMjUpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHJvdEw6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLnNoaWZ0TChuKS5vcih0aGlzLnNoaWZ0Uig2NCAtIG4pKTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUm90YXRlcyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSByaWdodC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byByb3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgcm90YXRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciByb3RhdGVkID0geDY0V29yZC5yb3RSKDcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHJvdFI6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLnNoaWZ0UihuKS5vcih0aGlzLnNoaWZ0TCg2NCAtIG4pKTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIGFkZCB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBhZGRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBhZGRlZCA9IHg2NFdvcmQuYWRkKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBhZGQ6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSAodGhpcy5sb3cgKyB3b3JkLmxvdykgfCAwO1xuXHQgICAgICAgICAgICAvLyB2YXIgY2FycnkgPSAobG93ID4+PiAwKSA8ICh0aGlzLmxvdyA+Pj4gMCkgPyAxIDogMDtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSAodGhpcy5oaWdoICsgd29yZC5oaWdoICsgY2FycnkpIHwgMDtcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiA2NC1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBYNjRXb3JkQXJyYXkgPSBDX3g2NC5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyksXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgxODE5MWExYiwgMHgxYzFkMWUxZilcblx0ICAgICAgICAgKiAgICAgXSk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxuXHQgICAgICAgICAqICAgICBdLCAxMCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogODtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIDY0LWJpdCB3b3JkIGFycmF5IHRvIGEgMzItYml0IHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDcnlwdG9KUy5saWIuV29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkncyBkYXRhIGFzIGEgMzItYml0IHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB4MzJXb3JkQXJyYXkgPSB4NjRXb3JkQXJyYXkudG9YMzIoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1gzMjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHg2NFdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHg2NFdvcmRzTGVuZ3RoID0geDY0V29yZHMubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHgzMldvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeDY0V29yZHNMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHg2NFdvcmQgPSB4NjRXb3Jkc1tpXTtcblx0ICAgICAgICAgICAgICAgIHgzMldvcmRzLnB1c2goeDY0V29yZC5oaWdoKTtcblx0ICAgICAgICAgICAgICAgIHgzMldvcmRzLnB1c2goeDY0V29yZC5sb3cpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFgzMldvcmRBcnJheS5jcmVhdGUoeDMyV29yZHMsIHRoaXMuc2lnQnl0ZXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0geDY0V29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIFwid29yZHNcIiBhcnJheVxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUgZWFjaCBYNjRXb3JkIG9iamVjdFxuXHQgICAgICAgICAgICB2YXIgd29yZHNMZW5ndGggPSB3b3Jkcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHNMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaV0gPSB3b3Jkc1tpXS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBub3JtYWxpemUuY3NzIHY3LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9odG1se2xpbmUtaGVpZ2h0OjEuMTU7LW1zLXRleHQtc2l6ZS1hZGp1c3Q6MTAwJTstd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6MTAwJX1ib2R5e21hcmdpbjowfWFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9ZmlnY2FwdGlvbixmaWd1cmUsbWFpbntkaXNwbGF5OmJsb2NrfWZpZ3VyZXttYXJnaW46MWVtIDQwcHh9aHJ7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MDtvdmVyZmxvdzp2aXNpYmxlfXByZXtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXA6b2JqZWN0c31hYmJyW3RpdGxlXXtib3JkZXItYm90dG9tOm5vbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lIGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDppbmhlcml0O2ZvbnQtd2VpZ2h0OmJvbGRlcn1jb2RlLGtiZCxzYW1we2ZvbnQtZmFtaWx5Om1vbm9zcGFjZSxtb25vc3BhY2U7Zm9udC1zaXplOjFlbX1kZm57Zm9udC1zdHlsZTppdGFsaWN9bWFya3tiYWNrZ3JvdW5kLWNvbG9yOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1Yntib3R0b206LS4yNWVtfXN1cHt0b3A6LS41ZW19YXVkaW8sdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2t9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1pbWd7Ym9yZGVyLXN0eWxlOm5vbmV9c3ZnOm5vdCg6cm9vdCl7b3ZlcmZsb3c6aGlkZGVufWJ1dHRvbixpbnB1dCxvcHRncm91cCxzZWxlY3QsdGV4dGFyZWF7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXNpemU6MTAwJTtsaW5lLWhlaWdodDoxLjE1O21hcmdpbjowfWJ1dHRvbixpbnB1dHtvdmVyZmxvdzp2aXNpYmxlfWJ1dHRvbixzZWxlY3R7dGV4dC10cmFuc2Zvcm06bm9uZX1bdHlwZT1yZXNldF0sW3R5cGU9c3VibWl0XSxidXR0b24saHRtbCBbdHlwZT1idXR0b25dey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b259W3R5cGU9YnV0dG9uXTo6LW1vei1mb2N1cy1pbm5lcixbdHlwZT1yZXNldF06Oi1tb3otZm9jdXMtaW5uZXIsW3R5cGU9c3VibWl0XTo6LW1vei1mb2N1cy1pbm5lcixidXR0b246Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyLXN0eWxlOm5vbmU7cGFkZGluZzowfVt0eXBlPWJ1dHRvbl06LW1vei1mb2N1c3JpbmcsW3R5cGU9cmVzZXRdOi1tb3otZm9jdXNyaW5nLFt0eXBlPXN1Ym1pdF06LW1vei1mb2N1c3JpbmcsYnV0dG9uOi1tb3otZm9jdXNyaW5ne291dGxpbmU6MXB4IGRvdHRlZCBCdXR0b25UZXh0fWZpZWxkc2V0e3BhZGRpbmc6LjM1ZW0gLjc1ZW0gLjYyNWVtfWxlZ2VuZHtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6aW5oZXJpdDtkaXNwbGF5OnRhYmxlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6MDt3aGl0ZS1zcGFjZTpub3JtYWx9cHJvZ3Jlc3N7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9dGV4dGFyZWF7b3ZlcmZsb3c6YXV0b31bdHlwZT1jaGVja2JveF0sW3R5cGU9cmFkaW9de2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjB9W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfVt0eXBlPXNlYXJjaF17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDtvdXRsaW5lLW9mZnNldDotMnB4fVt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sW3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbnstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX06Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247Zm9udDppbmhlcml0fWRldGFpbHMsbWVudXtkaXNwbGF5OmJsb2NrfXN1bW1hcnl7ZGlzcGxheTpsaXN0LWl0ZW19Y2FudmFze2Rpc3BsYXk6aW5saW5lLWJsb2NrfVtoaWRkZW5dLHRlbXBsYXRle2Rpc3BsYXk6bm9uZX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEvYXBwcy9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGZvbnQtZmFjZXtmb250LWZhbWlseTpJY29ucztzcmM6dXJsKFwiICsgcmVxdWlyZShcIi4uL2ZvbnRzL29wZW4taWNvbmljLmVvdFwiKSArIFwiKTtzcmM6dXJsKFwiICsgcmVxdWlyZShcIi4uL2ZvbnRzL29wZW4taWNvbmljLmVvdFwiKSArIFwiPyNpY29uaWMtc20pIGZvcm1hdChcXFwiZW1iZWRkZWQtb3BlbnR5cGVcXFwiKSx1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvb3Blbi1pY29uaWMud29mZlwiKSArIFwiKSBmb3JtYXQoXFxcIndvZmZcXFwiKSx1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvb3Blbi1pY29uaWMudHRmXCIpICsgXCIpIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKSx1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvb3Blbi1pY29uaWMub3RmXCIpICsgXCIpIGZvcm1hdChcXFwib3BlbnR5cGVcXFwiKSx1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvb3Blbi1pY29uaWMuc3ZnXCIpICsgXCIjaWNvbmljLXNtKSBmb3JtYXQoXFxcInN2Z1xcXCIpO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0ub2lbZGF0YS1nbHlwaF0ub2ktdGV4dC1yZXBsYWNle2ZvbnQtc2l6ZTowO2xpbmUtaGVpZ2h0OjB9Lm9pW2RhdGEtZ2x5cGhdLm9pLXRleHQtcmVwbGFjZTpiZWZvcmV7d2lkdGg6MWVtO3RleHQtYWxpZ246Y2VudGVyfS5vaVtkYXRhLWdseXBoXTpiZWZvcmV7Zm9udC1mYW1pbHk6SWNvbnM7ZGlzcGxheTppbmxpbmUtYmxvY2s7c3BlYWs6bm9uZTtsaW5lLWhlaWdodDoxO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZX0ub2lbZGF0YS1nbHlwaF06ZW1wdHk6YmVmb3Jle3dpZHRoOjFlbTt0ZXh0LWFsaWduOmNlbnRlcjtib3gtc2l6aW5nOmNvbnRlbnQtYm94fS5vaVtkYXRhLWdseXBoXS5vaS1hbGlnbi1sZWZ0OmJlZm9yZXt0ZXh0LWFsaWduOmxlZnR9Lm9pW2RhdGEtZ2x5cGhdLm9pLWFsaWduLXJpZ2h0OmJlZm9yZXt0ZXh0LWFsaWduOnJpZ2h0fS5vaVtkYXRhLWdseXBoXS5vaS1hbGlnbi1jZW50ZXI6YmVmb3Jle3RleHQtYWxpZ246Y2VudGVyfS5vaVtkYXRhLWdseXBoXS5vaS1mbGlwLWhvcml6b250YWw6YmVmb3Jley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWCgtMSk7LW1zLXRyYW5zZm9ybTpzY2FsZVgoLTEpO3RyYW5zZm9ybTpzY2FsZVgoLTEpfS5vaVtkYXRhLWdseXBoXS5vaS1mbGlwLXZlcnRpY2FsOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoLTEpOy1tcy10cmFuc2Zvcm06c2NhbGVYKC0xKTt0cmFuc2Zvcm06c2NhbGVZKC0xKX0ub2lbZGF0YS1nbHlwaF0ub2ktZmxpcC1ob3Jpem9udGFsLXZlcnRpY2FsOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgtMSk7LW1zLXRyYW5zZm9ybTpzY2FsZVgoLTEpO3RyYW5zZm9ybTpzY2FsZSgtMSl9Lm9pW2RhdGEtZ2x5cGg9YWNjb3VudC1sb2dpbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDAwXFxcIn0ub2lbZGF0YS1nbHlwaD1hY2NvdW50LWxvZ291dF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDAxXFxcIn0ub2lbZGF0YS1nbHlwaD1hY3Rpb24tcmVkb106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDAyXFxcIn0ub2lbZGF0YS1nbHlwaD1hY3Rpb24tdW5kb106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDAzXFxcIn0ub2lbZGF0YS1nbHlwaD1hbGlnbi1jZW50ZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwNFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YWxpZ24tbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDA1XFxcIn0ub2lbZGF0YS1nbHlwaD1hbGlnbi1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDA2XFxcIn0ub2lbZGF0YS1nbHlwaD1hcGVydHVyZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDA3XFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy1ib3R0b21dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctY2lyY2xlLWJvdHRvbV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDA5XFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy1jaXJjbGUtbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDBBXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy1jaXJjbGUtcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctY2lyY2xlLXRvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDBDXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMERcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMEVcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LXRoaWNrLWJvdHRvbV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDBGXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy10aGljay1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTBcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LXRoaWNrLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTFcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LXRoaWNrLXRvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDEyXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy10b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXVkaW8tc3BlY3RydW1dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxNFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXVkaW9dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxNVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmFkZ2VdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxNlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmFuXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTdcXFwifS5vaVtkYXRhLWdseXBoPWJhci1jaGFydF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDE4XFxcIn0ub2lbZGF0YS1nbHlwaD1iYXNrZXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmF0dGVyeS1lbXB0eV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDFBXFxcIn0ub2lbZGF0YS1nbHlwaD1iYXR0ZXJ5LWZ1bGxdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmVha2VyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMUNcXFwifS5vaVtkYXRhLWdseXBoPWJlbGxdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxRFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Ymx1ZXRvb3RoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMUVcXFwifS5vaVtkYXRhLWdseXBoPWJvbGRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxRlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Ym9sdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDIwXFxcIn0ub2lbZGF0YS1nbHlwaD1ib29rXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjFcXFwifS5vaVtkYXRhLWdseXBoPWJvb2ttYXJrXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjJcXFwifS5vaVtkYXRhLWdseXBoPWJveF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDIzXFxcIn0ub2lbZGF0YS1nbHlwaD1icmllZmNhc2VdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyNFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YnJpdGlzaC1wb3VuZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDI1XFxcIn0ub2lbZGF0YS1nbHlwaD1icm93c2VyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjZcXFwifS5vaVtkYXRhLWdseXBoPWJydXNoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjdcXFwifS5vaVtkYXRhLWdseXBoPWJ1Z106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDI4XFxcIn0ub2lbZGF0YS1nbHlwaD1idWxsaG9ybl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDI5XFxcIn0ub2lbZGF0YS1nbHlwaD1jYWxjdWxhdG9yXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMkFcXFwifS5vaVtkYXRhLWdseXBoPWNhbGVuZGFyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMkJcXFwifS5vaVtkYXRhLWdseXBoPWNhbWVyYS1zbHJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FyZXQtYm90dG9tXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMkRcXFwifS5vaVtkYXRhLWdseXBoPWNhcmV0LWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyRVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FyZXQtcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyRlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FyZXQtdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzBcXFwifS5vaVtkYXRhLWdseXBoPWNhcnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2hhdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDMyXFxcIn0ub2lbZGF0YS1nbHlwaD1jaGVja106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDMzXFxcIn0ub2lbZGF0YS1nbHlwaD1jaGV2cm9uLWJvdHRvbV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDM0XFxcIn0ub2lbZGF0YS1nbHlwaD1jaGV2cm9uLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzNVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2hldnJvbi1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDM2XFxcIn0ub2lbZGF0YS1nbHlwaD1jaGV2cm9uLXRvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDM3XFxcIn0ub2lbZGF0YS1nbHlwaD1jaXJjbGUtY2hlY2tdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2lyY2xlLXhdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2xpcGJvYXJkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwM0FcXFwifS5vaVtkYXRhLWdseXBoPWNsb2NrXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwM0JcXFwifS5vaVtkYXRhLWdseXBoPWNsb3VkLWRvd25sb2FkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwM0NcXFwifS5vaVtkYXRhLWdseXBoPWNsb3VkLXVwbG9hZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDNEXFxcIn0ub2lbZGF0YS1nbHlwaD1jbG91ZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDNFXFxcIn0ub2lbZGF0YS1nbHlwaD1jbG91ZHldOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzRlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29kZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQwXFxcIn0ub2lbZGF0YS1nbHlwaD1jb2ddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0MVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29sbGFwc2UtZG93bl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQyXFxcIn0ub2lbZGF0YS1nbHlwaD1jb2xsYXBzZS1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDNcXFwifS5vaVtkYXRhLWdseXBoPWNvbGxhcHNlLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDRcXFwifS5vaVtkYXRhLWdseXBoPWNvbGxhcHNlLXVwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDVcXFwifS5vaVtkYXRhLWdseXBoPWNvbW1hbmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0NlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29tbWVudC1zcXVhcmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0N1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29tcGFzc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQ4XFxcIn0ub2lbZGF0YS1nbHlwaD1jb250cmFzdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQ5XFxcIn0ub2lbZGF0YS1nbHlwaD1jb3B5d3JpdGluZ106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDRBXFxcIn0ub2lbZGF0YS1nbHlwaD1jcmVkaXQtY2FyZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDRCXFxcIn0ub2lbZGF0YS1nbHlwaD1jcm9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNENcXFwifS5vaVtkYXRhLWdseXBoPWRhc2hib2FyZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDREXFxcIn0ub2lbZGF0YS1nbHlwaD1kYXRhLXRyYW5zZmVyLWRvd25sb2FkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNEVcXFwifS5vaVtkYXRhLWdseXBoPWRhdGEtdHJhbnNmZXItdXBsb2FkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNEZcXFwifS5vaVtkYXRhLWdseXBoPWRlbGV0ZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDUwXFxcIn0ub2lbZGF0YS1nbHlwaD1kaWFsXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTFcXFwifS5vaVtkYXRhLWdseXBoPWRvY3VtZW50XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTJcXFwifS5vaVtkYXRhLWdseXBoPWRvbGxhcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDUzXFxcIn0ub2lbZGF0YS1nbHlwaD1kb3VibGUtcXVvdGUtc2Fucy1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTRcXFwifS5vaVtkYXRhLWdseXBoPWRvdWJsZS1xdW90ZS1zYW5zLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTVcXFwifS5vaVtkYXRhLWdseXBoPWRvdWJsZS1xdW90ZS1zZXJpZi1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTZcXFwifS5vaVtkYXRhLWdseXBoPWRvdWJsZS1xdW90ZS1zZXJpZi1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDU3XFxcIn0ub2lbZGF0YS1nbHlwaD1kcm9wbGV0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNThcXFwifS5vaVtkYXRhLWdseXBoPWVqZWN0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNTlcXFwifS5vaVtkYXRhLWdseXBoPWVsZXZhdG9yXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNUFcXFwifS5vaVtkYXRhLWdseXBoPWVsbGlwc2VzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNUJcXFwifS5vaVtkYXRhLWdseXBoPWVudmVsb3BlLWNsb3NlZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDVDXFxcIn0ub2lbZGF0YS1nbHlwaD1lbnZlbG9wZS1vcGVuXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNURcXFwifS5vaVtkYXRhLWdseXBoPWV1cm9dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1RVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXhjZXJwdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDVGXFxcIn0ub2lbZGF0YS1nbHlwaD1leHBhbmQtZG93bl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDYwXFxcIn0ub2lbZGF0YS1nbHlwaD1leHBhbmQtbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDYxXFxcIn0ub2lbZGF0YS1nbHlwaD1leHBhbmQtcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2MlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXhwYW5kLXVwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjNcXFwifS5vaVtkYXRhLWdseXBoPWV4dGVybmFsLWxpbmtdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2NFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXllXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjVcXFwifS5vaVtkYXRhLWdseXBoPWV5ZWRyb3BwZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2NlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZmlsZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDY3XFxcIn0ub2lbZGF0YS1nbHlwaD1maXJlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjhcXFwifS5vaVtkYXRhLWdseXBoPWZsYWddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2OVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Zmxhc2hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2QVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Zm9sZGVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNkJcXFwifS5vaVtkYXRhLWdseXBoPWZvcmtdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2Q1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZnVsbHNjcmVlbi1lbnRlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDZEXFxcIn0ub2lbZGF0YS1nbHlwaD1mdWxsc2NyZWVuLWV4aXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2RVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Z2xvYmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2RlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Z3JhcGhdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3MFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Z3JpZC1mb3VyLXVwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzFcXFwifS5vaVtkYXRhLWdseXBoPWdyaWQtdGhyZWUtdXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3MlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Z3JpZC10d28tdXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3M1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9aGFyZC1kcml2ZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDc0XFxcIn0ub2lbZGF0YS1nbHlwaD1oZWFkZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3NVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9aGVhZHBob25lc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDc2XFxcIn0ub2lbZGF0YS1nbHlwaD1oZWFydF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDc3XFxcIn0ub2lbZGF0YS1nbHlwaD1ob21lXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzhcXFwifS5vaVtkYXRhLWdseXBoPWltYWdlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzlcXFwifS5vaVtkYXRhLWdseXBoPWluYm94XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwN0FcXFwifS5vaVtkYXRhLWdseXBoPWluZmluaXR5XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwN0JcXFwifS5vaVtkYXRhLWdseXBoPWluZm9dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3Q1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9aXRhbGljXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwN0RcXFwifS5vaVtkYXRhLWdseXBoPWp1c3RpZnktY2VudGVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwN0VcXFwifS5vaVtkYXRhLWdseXBoPWp1c3RpZnktbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDdGXFxcIn0ub2lbZGF0YS1nbHlwaD1qdXN0aWZ5LXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODBcXFwifS5vaVtkYXRhLWdseXBoPWtleV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDgxXFxcIn0ub2lbZGF0YS1nbHlwaD1sYXB0b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4MlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bGF5ZXJzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODNcXFwifS5vaVtkYXRhLWdseXBoPWxpZ2h0YnVsYl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDg0XFxcIn0ub2lbZGF0YS1nbHlwaD1saW5rLWJyb2tlbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDg1XFxcIn0ub2lbZGF0YS1nbHlwaD1saW5rLWludGFjdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDg2XFxcIn0ub2lbZGF0YS1nbHlwaD1saXN0LXJpY2hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4N1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9bGlzdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDg4XFxcIn0ub2lbZGF0YS1nbHlwaD1sb2NhdGlvbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDg5XFxcIn0ub2lbZGF0YS1nbHlwaD1sb2NrLWxvY2tlZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDhBXFxcIn0ub2lbZGF0YS1nbHlwaD1sb2NrLXVubG9ja2VkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOEJcXFwifS5vaVtkYXRhLWdseXBoPWxvb3AtY2lyY3VsYXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4Q1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9bG9vcC1zcXVhcmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4RFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bG9vcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDhFXFxcIn0ub2lbZGF0YS1nbHlwaD1tYWduaWZ5aW5nLWdsYXNzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOEZcXFwifS5vaVtkYXRhLWdseXBoPW1hcC1tYXJrZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5MFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWFwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTFcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXBhdXNlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTJcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXBsYXldOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5M1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtcmVjb3JkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTRcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXNraXAtYmFja3dhcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5NVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtc2tpcC1mb3J3YXJkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTZcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXN0ZXAtYmFja3dhcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5N1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWEtc3RlcC1mb3J3YXJkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOThcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXN0b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5OVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVkaWNhbC1jcm9zc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDlBXFxcIn0ub2lbZGF0YS1nbHlwaD1tZW51XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOUJcXFwifS5vaVtkYXRhLWdseXBoPW1pY3JvcGhvbmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5Q1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWludXNdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5RFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bW9uaXRvcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDlFXFxcIn0ub2lbZGF0YS1nbHlwaD1tb29uXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOUZcXFwifS5vaVtkYXRhLWdseXBoPW1vdmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bXVzaWNhbC1ub3RlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTFcXFwifS5vaVtkYXRhLWdseXBoPXBhcGVyY2xpcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEEyXFxcIn0ub2lbZGF0YS1nbHlwaD1wZW5jaWxdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGVvcGxlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTRcXFwifS5vaVtkYXRhLWdseXBoPXBlcnNvbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEE1XFxcIn0ub2lbZGF0YS1nbHlwaD1waG9uZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEE2XFxcIn0ub2lbZGF0YS1nbHlwaD1waWUtY2hhcnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGluXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQThcXFwifS5vaVtkYXRhLWdseXBoPXBsYXktY2lyY2xlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTlcXFwifS5vaVtkYXRhLWdseXBoPXBsdXNdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cG93ZXItc3RhbmRieV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEFCXFxcIn0ub2lbZGF0YS1nbHlwaD1wcmludF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEFDXFxcIn0ub2lbZGF0YS1nbHlwaD1wcm9qZWN0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQURcXFwifS5vaVtkYXRhLWdseXBoPXB1bHNlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQUVcXFwifS5vaVtkYXRhLWdseXBoPXB1enpsZS1waWVjZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEFGXFxcIn0ub2lbZGF0YS1nbHlwaD1xdWVzdGlvbi1tYXJrXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjBcXFwifS5vaVtkYXRhLWdseXBoPXJhaW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cmFuZG9tXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjJcXFwifS5vaVtkYXRhLWdseXBoPXJlbG9hZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEIzXFxcIn0ub2lbZGF0YS1nbHlwaD1yZXNpemUtYm90aF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEI0XFxcIn0ub2lbZGF0YS1nbHlwaD1yZXNpemUtaGVpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjVcXFwifS5vaVtkYXRhLWdseXBoPXJlc2l6ZS13aWR0aF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEI2XFxcIn0ub2lbZGF0YS1nbHlwaD1yc3MtYWx0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjdcXFwifS5vaVtkYXRhLWdseXBoPXJzc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEI4XFxcIn0ub2lbZGF0YS1nbHlwaD1zY3JpcHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c2hhcmUtYm94ZWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c2hhcmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c2hpZWxkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQkNcXFwifS5vaVtkYXRhLWdseXBoPXNpZ25hbF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEJEXFxcIn0ub2lbZGF0YS1nbHlwaD1zaWducG9zdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEJFXFxcIn0ub2lbZGF0YS1nbHlwaD1zb3J0LWFzY2VuZGluZ106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEJGXFxcIn0ub2lbZGF0YS1nbHlwaD1zb3J0LWRlc2NlbmRpbmddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c3ByZWFkc2hlZXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c3Rhcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEMyXFxcIn0ub2lbZGF0YS1nbHlwaD1zdW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGFibGV0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzRcXFwifS5vaVtkYXRhLWdseXBoPXRhZ106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEM1XFxcIn0ub2lbZGF0YS1nbHlwaD10YWdzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzZcXFwifS5vaVtkYXRhLWdseXBoPXRhcmdldF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEM3XFxcIn0ub2lbZGF0YS1nbHlwaD10YXNrXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzhcXFwifS5vaVtkYXRhLWdseXBoPXRlcm1pbmFsXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzlcXFwifS5vaVtkYXRhLWdseXBoPXRleHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGh1bWItZG93bl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMENCXFxcIn0ub2lbZGF0YS1nbHlwaD10aHVtYi11cF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMENDXFxcIn0ub2lbZGF0YS1nbHlwaD10aW1lcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMENEXFxcIn0ub2lbZGF0YS1nbHlwaD10cmFuc2Zlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMENFXFxcIn0ub2lbZGF0YS1nbHlwaD10cmFzaF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMENGXFxcIn0ub2lbZGF0YS1nbHlwaD11bmRlcmxpbmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dmVydGljYWwtYWxpZ24tYm90dG9tXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDFcXFwifS5vaVtkYXRhLWdseXBoPXZlcnRpY2FsLWFsaWduLWNlbnRlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQyXFxcIn0ub2lbZGF0YS1nbHlwaD12ZXJ0aWNhbC1hbGlnbi10b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9dmlkZW9dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBENFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dm9sdW1lLWhpZ2hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBENVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dm9sdW1lLWxvd106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQ2XFxcIn0ub2lbZGF0YS1nbHlwaD12b2x1bWUtb2ZmXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDdcXFwifS5vaVtkYXRhLWdseXBoPXdhcm5pbmddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9d2lmaV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQ5XFxcIn0ub2lbZGF0YS1nbHlwaD13cmVuY2hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9eF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMERCXFxcIn0ub2lbZGF0YS1nbHlwaD15ZW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9em9vbS1pbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEREXFxcIn0ub2lbZGF0YS1nbHlwaD16b29tLW91dF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMERFXFxcIn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEvYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9jc3Mvb3Blbi1pY29uaWMubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciBnZXRDb25maXJtYXRpb24gPSBleHBvcnRzLmdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xudmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBleHBvcnRzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG52YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBleHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG52YXIgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGV4cG9ydHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvRE9NVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZSA9IHJlcXVpcmUoJ3Jlc29sdmUtcGF0aG5hbWUnKTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVzb2x2ZVBhdGhuYW1lKTtcblxudmFyIF92YWx1ZUVxdWFsID0gcmVxdWlyZSgndmFsdWUtZXF1YWwnKTtcblxudmFyIF92YWx1ZUVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbHVlRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAoMCwgX3Jlc29sdmVQYXRobmFtZTIuZGVmYXVsdCkobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgKDAsIF92YWx1ZUVxdWFsMi5kZWZhdWx0KShhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYWRkTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5hZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxudmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG52YXIgaGFzQmFzZW5hbWUgPSBleHBvcnRzLmhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZXhwb3J0cy5zdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG52YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxudmFyIHBhcnNlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L1BhdGhVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfRE9NVXRpbHMuY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gISgwLCBfRE9NVXRpbHMuc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSkoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBfRE9NVXRpbHMuZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIWJhc2VuYW1lIHx8ICgwLCBfUGF0aFV0aWxzLmhhc0Jhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmICgoMCwgX0RPTVV0aWxzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQpKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyAoMCwgX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCkocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCkoKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IF9QYXRoVXRpbHMuY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgY3VzdG9tU3RhdGljcykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleXNbaV1dICYmICFLTk9XTl9TVEFUSUNTW2tleXNbaV1dICYmICghY3VzdG9tU3RhdGljcyB8fCAhY3VzdG9tU3RhdGljc1trZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21wb25lbnRba2V5c1tpXV0gPSBzb3VyY2VDb21wb25lbnRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL25vcm1hbGl6ZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbm9ybWFsaXplLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbm9ybWFsaXplLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vb3Blbi1pY29uaWMubWluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9vcGVuLWljb25pYy5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9vcGVuLWljb25pYy5taW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9jc3Mvb3Blbi1pY29uaWMubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3Q7YmFzZTY0LEpHNEFBSHh0QUFBQkFBSUFBQUFBQUFJQUJRTUFBQUFBQUFBQkFKQUJBQUFBQUV4UUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFFQUFBQUFBQUFBR1l3TEt3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBb0FTUUJqQUc4QWJnQnpBQUFBREFCcEFHTUFid0J1QUdrQVl3QUFBQndBVmdCbEFISUFjd0JwQUc4QWJnQWdBREVBTGdBeEFDNEFNUUFnQUFBQUVnQlZBRzRBZEFCcEFIUUFiQUJsQUdRQU1RQUFBQUFBQUFFQUFBQVBBSUFBQXdCd1JrWlVUV3Z3QWFRQUFBRDhBQUFBSEU5VEx6STBCbEZpQUFBQkdBQUFBR0JqYldGd0FBL2tpUUFBQVhnQUFBRkNZM1owSUFBQUFBQUFBR0dJQUFBQUNtWndaMjIrYitZNUFBQmhsQUFBQzJ4bllYTndBQUFBRUFBQVlZQUFBQUFJWjJ4NVpramw3cTRBQUFLOEFBQlNHR2hsWVdRQjg3dEZBQUJVMUFBQUFEWm9hR1ZoQm93RUFRQUFWUXdBQUFBa2FHMTBlSnFlQUJvQUFGVXdBQUFEaG14dlkyR2p1bzlFQUFCWXVBQUFBY1p0WVhod0Fad0wxZ0FBV29BQUFBQWdibUZ0Wlk3MkVNVUFBRnFnQUFBQ2ZIQnZjM1R0RURQK0FBQmRIQUFBQkdOd2NtVnczV3NEaFFBQWJRQUFBQUI3QUFBQUFRQUFBQURNUGFMUEFBQUFBTS9aTDJvQUFBQUF6OWt2YWdBRUF2NEJrQUFGQUFBQ0NBSXdBQUFBY0FJSUFqQUFBQUdBQUNjQXp3QUFBZ0FGQXdBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQlFaa1ZrQU1EZ0FPRGVBeUFBQUFCSUF5QUFaUUFBQUFFQUFBQUFBQUFBQUFBQUFDQUFBUUFBQUFNQUFBQURBQUFBSEFBQkFBQUFBQUE4QUFNQUFRQUFBQndBQkFBZ0FBQUFCQUFFQUFFQUFPRGUvLzhBQU9BQS8vOGdBd0FCQUFBQUFBQUFBUVlBQUFFQUFBQUFBQUFBQVFJQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUJvQUFBRHNBaFVBQXdBSEFBaTFCZ1FCQUFJdEt6TVJNeEVuTXhFakd0SzRucDRDRmYzckdnSGhBQUlBQUFBQUF5QUN2QUFIQUE0QUNMVUtDQUlBQWkwckFTRVJJVFVoRVNFZkFRYzFJVFVoQVN3QjlQNE1BWkQrY0dUSXlQNXdBWkFDdlAxRVpBSDBaSmFXWkdRQUFnQUFBQUFESUFLOEFBY0FEZ0FJdFEwSUFnQUNMU3NCSVJFaE5TRVJJUWNWSVJVaEZTY0JMQUgwL2d3QmtQNXdaQUdRL25ESUFyejlSR1FCOUdSa1pHU1dBQUFCQUFBQVpBTWdBcndBRHdBR3N3WUFBUzByRWlBV0hRRXpCeWN6TlRRbUlnWVZOTTBCSXMxa3lNaGtrdENTQXJ6TmtUTEl5REpva3BKb2tRQUJBQUFBWkFNZ0Fyd0FEd0FHc3dzQUFTMHJBQ0FXRlRRbUlnWWRBVE1ISnpNMU5BRXhBU0xOa3RDU1pNaklaQUs4elpGb2twSm9Nc2pJTXBFQUFBQUFCQUFBQUFBRElBSzhBQU1BQndBTEFBOEFEVUFLRGd3S0NBWUVBZ0FFTFNzUklSVWhGeUVWSVFjaEZTRVhJUlVoQXlEODRHUUNXUDJvWkFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUFBQUVBQUFBQUFNZ0Fyd0FBd0FIQUFzQUR3QU5RQW9PREFvSUJnUUNBQVF0S3hFaEZTRVZJUlVoRlNFVklSVWhGU0VESVB6Z0FsajlxQU1nL09BQ1dQMm9BcnhrWkdSa1pHUmtBQUFBQkFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRFVBS0Rnd0tDQVlFQWdBRUxTc1JJUlVoRnlFVklRY2hGU0VYSVJVaEF5RDg0TWdDV1Ayb3lBTWcvT0RJQWxqOXFBSzhaR1JrWkdSa1pBQUFBQUFGQUFEL253TWdBcndBQlFBTEFCRUFGZ0FiQUE5QURCc1hFeElRREFnR0F3QUZMU3NCTWhjSEpUWUhGd1VtTlRRbEZoVVVCeU1sRXk0Qkp3VWhEZ0VIQVpCc1lrdit2bHl3di83S0JnS3djQkRhL3FKd1hwY3FBVXNCZERHallnSzhPK0hxTW5DSzNpUWtxR3QxbmlSQU5mNmxFWGRXSEZOcENRQUFBUUFBQUFBQjlBTWdBQVlBQnJNRUFBRXRLeE16RVRNTEFUUElaTWozL2NnRElQNE0vdFFCTEFBQUFBQUNBQUFBQUFNZ0F5QUFCd0FPQUFpMUN3Z0VBQUl0S3hJZ0ZoQUdJQ1lRSlJFakNRRWpFZW9CVE9ycS9yVHFBU3pJQVN3QkxNZ0RJT3IrdE9ycUFVeUcvdFQrMUFFc0FTd0FBQUFBQWdBQUFBQURJQU1nQUFjQURnQUl0UW9JQkFBQ0xTc1NJQllRQmlBbUVDVUpBVFVoTlNIcUFVenE2djYwNmdHUS90UUJMQUVzL3RRRElPcit0T3JxQVV5Ry90VCsxTWpJQUFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTkNBUUFBaTByRWlBV0VBWWdKaEFsRlNFVklSVUI2Z0ZNNnVyK3RPb0JrUDdVQVN3QkxBTWc2djYwNnVvQlRJYkl5TWdCTEFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTENBUUFBaTByRWlBV0VBWWdKaEFsQVRNUk14RXo2Z0ZNNnVyK3RPb0JrUDdVeU1qSUF5RHEvclRxNmdGTWh2N1UvdFFCTEFBQUFBRUFBQUJrQXlBQ1dBQUdBQWF6QlFBQkxTc0JGU0VWSVJVbEFTd0I5UDRNL3RRQ1dNaGt5UGNBQUFBQUFRQUFBR1FESUFKWUFBWUFCck1DQUFFdEt3RU5BVFVoTlNFQjlBRXMvdFQrREFIMEFsajMvY2hrQUFBQkFBQUFBQUpZQXlBQUJnQUdzd1FBQVMwckV6TVJNd2tCTThqSXlQN1gvdEhJQXlEK0RQN1VBU3dBQUFFQUFBQmtBeUFDdkFBR0FBYXpCUUFCTFNzQkZTRVZJUlVCQVN3QjlQNE0vdFFDdk1qSXlBRXBBQUFBQVFBQUFHUURJQUs4QUFZQUJyTUNBQUV0S3drQ05TRTFJUUgwQVN6KzFQNE1BZlFDdlA3WC90SEl5QUFCQUFBQUFBSllBeUFBQmdBR3N3TUFBUzByQ1FFakVTTVJJd0VwQVMvSXlNZ0RJUDdVL2d3QjlBQUFBQUVBQUFBQUFmUURJQUFHQUFhekF3QUJMU3NiQVNNUkl4RWo5LzNJWk1nRElQN1UvZ3dCOUFBRUFBQUFBQUs4QXlBQUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLd0V6RVNNRE14RWpBVE1SSXdFekZTTUJrR1JreUdSa0FaQmtaUDJvWkdRRElQemdBcno5cUFIMC9uQUJMTWdBQUFRQUFBQWlBeUFDV0FBS0FCVUFId0FwQUExQUNpUWdIQllRQ3dZQUJDMHJFeGNHRlJRWEJ5NEJOVFFsRmhVVUJnY25OalUwSndVWEJoVVVGd2NtTlRRbEZoVVVCeWMyTlRRbmRFaFlXRWczUFFLc2REMDNTRmhZL3A5RkhCeEZPd0ZWT3p0RkhCd0NXRWhZZVgxWVNEZVVVcVYwZEtWU2xEZElXSDE1V0VSSUhDa3NIRWc3VlZJNk8xRlZPMGdjTENrY0FBQUNBQUFBQUFHUUF5QUFCd0FQQUFpMURRZ0VBQUl0S3hJeUZoUUdJaVkwRXhZek1qY1JKd2QycEhaMnBIWmtOaTR0TjJSa0F5QjJwSFoycFA2VkV4UCt3V1JrQUFNQUFBQUFBeUFESUFBSEFBOEFGd0FLdHhJUURRZ0VBQU10S3hJZ0ZoQUdJQ1lRSlNJR0ZSUVhBU1lYQVJZek1qWTFOT3NCU3V2ci9yYnJBWkI4c0RnQm8wNlQvbDFPWVh5d0F5RHIvcmJyNndGS2g3QjhZVTRCb3poOS9sMDRzSHhoQUFBREFBQUFBQU1nQXJ3QUJRQUpBQTBBQ3JjTUNnZ0dCQUFETFNzUk14RWhGU0VCTXhFakFUTVJJMlFDdlB6Z0FmVEl5UDdVeU1nQ3ZQMm9aQUs4L2d3QkxQN1VBQVFBQUFBQUF5QURJQUFYQUJvQUpnQXlBQTFBQ2kwbklSc1pHQXdCQkMwckFUWVhIZ0lYTXhVakVSUUdJeUVpSmpVUkl6VXpFellYQnlFRUlnWWRBUlFXTWpZOUFUUWtJZ1lkQVJRV01qWTlBVFFCalJFUkFXeDRESUJrRkE3OTdBNFVaSURxRGhpUUFTRCs3eW9kSFNvZEFROHFIUjBxSFFNZ0FRNEJnWTRQWlA2U0RoUVVEZ0Z1WkFFWkVYNnN5QjBWWkJVZEhSVmtGUjBkRldRVkhSMFZaQlVBQWdBQUFHUURJQUs4QUE4QUV3QUl0UkVRQ1FBQ0xTc1RJVElkQVRNVkl4VVVJeUVpTlJFMEZ4RWhFUWtDcWdsa1pBbjlWZ2xrQWZRQ3ZBcSt5TDhKQ1FKR0NXVCtjQUdRQUFBQUFBRUFBQUJrQXlBQ3ZBQVBBQWF6Q1FBQkxTc1RJVElkQVRNVkl4VVVJeUVpTlJFMENRS3FDV1JrQ2YxV0NRSzhDcjdJdndrSkFrWUpBQUFBQUFJQUFQK2NBeUFDdkFBbUFDOEFDTFVzSnhZQ0FpMHJFelEyT3dNaE1oWVVCaXNCRlJJWEZoVVVCeU1HSXlFaUpqVTBOellUTlNNaUJpTWlKZ1VqRlFjR0J5RXZBVndhRXdNRkJRSDBGUjBkRlRLT0dDSXBBeXM1L2dBK1VpSVlqaklCQmdFVkhRR1l5QVkvT0FIQ2R3WUNpaElnSFNvZGpmN3pLRGN6UGlrcFVqNHpOeWdCRFkwQkhoMmlDbnRwNUFvQUFBQUNBQUFBQUFNZ0F5QUFEUUFUQUFpMUVRNEhBQUl0S3dBeUZoVVVGeFlWSVRRM05qVTBFek1VQmlJbUFUNmtkb1pDL09CQ2htVElPMUk3QXlCMlVwdHZOMDlQTjIrYlV2MjZLVHM3QUFBQUFBTUFBQUFBQWlZRElBQU5BQkFBRXdBS3R4SVJEdzRGQUFNdEt4TXpCUWNYQlNNMUJ5YzNKemNYTnhVM0J4VTNsaklCWHVIaC9xSXlTMHVXbGt0TFpKYVdsZ01nK3BPWit2cExTNWFXUzB0a3lHVEl5R1FBQUFBREFBQUFBQU1nQXlBQUZRQWRBQ1VBQ3JjZkhoY1dDd0FETFNzUklUSVdGUlFISGdFVkZBWWpJVFV5TmpVUk5DWWpJUlV6TWpZMEppTURFVE15TmpRbUl3SDBVbllzUVUrU2FQM2FLVHM3S1FFc1pDazdPeWxrbGo1WVdENERJSFpTUmpjZmVFcG9rbVE3S1FHUUtUdklPMUk3L3RUKzFGaDhXQUFBQVFBQUFBQUI5QU1nQUFVQUJyTURBQUV0S3dFUk13RVJJd0VzeVA3VXlBTWcvdFQrREFFc0FBRUFBQUFBQXJ3RElBQWJBQWF6RWdBQkxTc1RJUkUzRnhFek1oWVZFU0VpQmhRV015RVZJU0ltTlJFM1BnRTNaQUVzWkdReUZSMzkyaFVkSFJVQ0p2M2FQbGdEQmlzZEF5RCsxR1JrQVN3ZEZmM2FIU29kWkZnK0FpWVRIU3NHQUFFQUFBQUFBWkFESUFBRUFBYXpBZ0FCTFNzUklSRW5Cd0dReU1nRElQemd5TWdBQUFJQUFBQUFBeUFESUFBREFBOEFDTFVMQkFJQUFpMHJFU0VWSVJVaEZUTTFJUkVVSXlFaU5RTWcvT0FCTE1zQktRbjg4Z2tESUdSa1oyZjlzUWtKQUFBREFBQUFBQU1nQXlBQUZ3QWJBQ2NBQ3JjakhCa1lDd0FETFNzQk16SVdIUUV6TWgwQkZBWWpJU0ltUFFFME93RTFORFlYRlRNMUFSWXpJVEkzRlJRaklTSTFBU3pJS1R1L0NSMFYvVVFWSFFtL095bkkvZ3dZR2dLOEdoZ0ovUElKQXlBN0tXUUo4UlVkSFJYeENXUXBPMlJrWlA0VkNRbklDUWtBQVFBQUFBQUNXQU1nQUNRQUJyTVZBQUV0S3dFeUZoVWpOQ1lqSWdjR0ZSUVdGek1WSXdZSElSVWhOVGMyTnlNMU15NENOVFEzTmdFc1htcGtNakl2R1J3WkE2eXlGMW9CNi8yb0VGY1RlbjBDRHdneU53TWdhbDR5TWg4ak94eDNIR1JoWjJSNkRGZFBaQTFIUEI5ZVBrVUFBQUFFQUFEL25BTWdBcndBRkFBY0FDZ0FMQUFOUUFvcUtTRWRHUlVMQUFRdEt4TTdBeUV5RmhVUkZBWWpJU0ltTlJFMU5EWVdJZ1lVRmpJMk5EY2lCaFFXTXlFeU5qUW1Jd1VSSVJFaUJBTUVCUUs4RlIwZEZmMUVGUjBVbHlvZEhTb2RsaFVkSFJVQkxCVWRIUlg5MmdKWUFyd2RGZjFFRlIwZEZRSzhBZzhkWUIwcUhSMHFIUjBxSFIwcUhjaitjQUdRQUFBQUFnQUFBQUFER2dNZEFBMEFHd0FJdFJNT0J3QUNMU3NCSHdFV0J3RVBBUzRCSno4QkNRRXlGaFVVQmlNaUp6NEJOVFEyQXVnR0xBVUYvdllQR1JGUE5nd05BWGYrS0RoT25HNUtQRDFKVFFNZEF5d0ZCLzZKRFF3MlR4RVpEd0VLL25aT09HNmNJaU44U1RoT0FBQUFBQUVBQVArN0FzNEN2QUJuQUFhek1nc0JMU3NUTkRZek1oOEJOeTRCUGdFeUhnRUdCeGMzTmpNeUZoVVVCZzhCRmhjek1oWVVCaXNCRkFjWEhnRVZGQVlqSWk4QkJnY21QUWMwSmlNaUJnY1dGQWNkQXhRSEppY0hCaU1pSmpVME5qOEJKalVyQVNJbU5UUTJPd0kyTnljdUFRa2JFdzRNZ3gwY0JpUkpWa2trQlJ3Y2d3c0tGUjBRQzNNVUJVUVZIUjBWTWdaT0R4WWRGUkFQUVNWQ1BCMFZFaHdFQVFFN1F5UkNEeEFWSFJZUFRnWXlCUlVkSFJVRlJRVVVkQXdRQWNNU0lBZENGaDFZVFRnM1RWZ2VGa0lISFJVTkdnWTRJdzhkS2gwaUlDZ0VIUkFWSFFzalNDWWhKNGNFQlFZRkJWY1ZIUmNSQXhBRFVnUUZrQ2dnS1VVakN4MFZFQjBFS0NBaUhSVVVIZzhqT0FVYUFBSUFBQUFDQXJ3Q3ZBQUhBQndBQ0xVU0NRVUFBaTByQVRNeUZSRVVLd0VCSlJFbkZTSUhGeFlPQVNZbkF5TWlQUUUwT3dFQ1dGc0pDVnYrZWdFaStoY0ZTd2dPSmlvSVoxc0pDYllDdkFuOXVna0JrNVArREgwREZySVRLaEFPRXdFUUNiWUpBQUFBQndBQUFBQUN2QU1nQUFzQUR3QVRBQmNBR3dBZkFDTUFFMEFRSVNBZEhCa1lGUlFSRUEwTUJRQUhMU3NUSVRJVkVSUWpJU0kxRVRRWEZTRTFBUlV6TlRNVk16VXpFVE1SQlJVek5UTVZNelVKQXFvSkNmMVdDV1FCOVA0TVpHUmtaR1QrREdSa1pBTWdDZnp5Q1FrRERnbGt5TWorMUdSa1pHVCsxQUVzeUdSa1pHUUFCd0FBQUFBQ3ZBTWdBQU1BQ3dBUEFCTUFGd0FiQUI4QUUwQVFIUndaR0JVVUVSQU5EQWNFQWdBSExTc1JJUlVoRlNFUkZDTWhJalVURlRNMU14VXpOVE1WTXpVRkZUTTFNeFV6TlFLOC9VUUN2QW45Vmdsa1pHUmtaR1QrREdSa1pBTWd5R1QrRlFrSkFZZGtaR1JrWkdUSVpHUmtaQUFBQkFBQUFBQURJQU1nQUJnQUlBQW9BREFBRFVBS0xTa2xJUjBaQ3dBRUxTc0JNeklmQVJZN0FUSVZFUlFqSVNJMUVUUTJPd0V5UHdFMkFpSUdGQll5TmpRa0lnWVVGakkyTkNZeUZoUUdJaVkwQVptMkNBUmVCQWhTQ1FuODhnbFlQbzBJQkY0RTVpb2RIU29kQVg2a2RuYWtkdkZTT3p0U093TWdDYllKQ2YyNkNRa0J1VDVZQ2JZSi90UWRLaDBkS2gxMnBIWjJwQkk3VWpzN1VnQUFBQUVBQUFESUF5QUNXQUFDQUFhekFnQUJMU3NSSVFFRElQNXdBbGorY0FBQUFRQUFBQUFCa0FNZ0FBSUFCck1CQUFFdEt3RVJBUUdRL25BRElQemdBWkFBQUFBQUFRQUFBQUFCa0FNZ0FBSUFCck1DQUFFdEt4RUpBUUdRL25BRElQNXcvbkFBQUFBQUFRQUFBTWdESUFKWUFBSUFCck1CQUFFdEt3a0JJUUdRQVpEODRBSlkvbkFBQUFBQUF3QUFBQUFESHdKWUFDRUFLUUF4QUFxM0xpb21JaElDQXkwckVUUTJPd1F5Rmg4QklUSVdEd0VPQVNNaElpWW5MZ0V2QVNNaUJpTWlKZ0F5RmhRR0lpWTBKRElXRkFZaUpqUWJFd01GQk1nTkdnVW1BYndLQ0FOUkF4VUwvcUlLRlFNT05nMEtsZ0VGQVJVZUFWRXFIUjBxSFFGSktoMGRLaDBDSmhJZ0VRdElEd3I2Q2c4UENpbW9LUmtCSHY1VEhTb2RIU29kSFNvZEhTb0FBZ0FBQUFBRElBSzhBQVlBQ3dBSXRRa0hCZ0FDTFNzUklSVWhFU01IQVNFUkp5RUI5UDdVWkdRQkxBSDBaUDV3QXJ4ay90UmtBU3orREdRQUFRQUFBRUlERUFLOEFBMEFCck1DQUFFdEt3RVhBUzRDTHdFM0ZoYytBZ0tCai80VElFbGFHRWlOUzA0bmpuUUN2STMrRXlKS1dSbEhqVXhLSjQ1MEFBRUFBQUF5QXlBQ1dBQUZBQWF6QkFBQkxTc1RGemNYQ1FHVyt2cVcvbkQrY0FKWSt2cVcvbkFCa0FBQUFRQUFBQUFDSmdNZ0FBVUFCck1FQUFFdEt3RVhCeGNIQVFHUWx2cjZsdjV3QXlDVyt2cVdBWkFBQUFBQkFBQUFBQUltQXlBQUJRQUdzd0lBQVMwckV3a0JKemNubGdHUS9uQ1crdm9ESVA1dy9uQ1crdm9BQUFFQUFBQXlBeUFDV0FBRkFBYXpBZ0FCTFNzSkFRY25CeWNCa0FHUWx2cjZsZ0pZL25DVyt2cVdBQUFBQWdBQUFBQURJQU1nQUFjQURRQUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVDVUhKd2NYQWVvQlRPcnEvclRxQWxqNlpFaXNBVUlESU9yK3RPcnFBVXc0K21SSXJBRkNBQUFBQWdBQUFBQURJQU1nQUFjQUV3QUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVEY0hGd2NYTnhjM0p6Y25CK29CVE9ycS9yVHEra2lXbGtpV2xraVdsa2lXQXlEcS9yVHE2Z0ZNT0VpV2xraVdsa2lXbGtpV0FBQUFBQUlBQUFBQUFyd0RJQUFSQUNVQUNMVWRFZ2tBQWkwckFESVdIUUV6TWhZZEFTRTFORFk3QVRVMEJUTVZJVFV6TWhZVkVSUUdJeUVpSmpVUk5EWUJTU29kU3dzTy90UU9DMHYrN1VzQjlFc0xEZzRML1hZTERnNERJQjBWTWc0TFMwc0xEaklWUjhqSURndjlkZ3NPRGdzQ2lnc09BQUFBQUFNQUFBQUFBeUFESUFBSEFBOEFHQUFLdHhVUURBZ0VBQU10S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFsTXhVV0Z3Y21Md0hyQVVycjYvNjI2d0lNK0xDdytMRCtvbVFpSmtna01CQURJT3YrdHV2ckFVcUhzUGl3c1BoTXRTUWhTQ2d3REFBQ0FBQUFBQU1nQXlBQUdRQXNBQWkxSmg0SkFBSXRLd0V5RmgwQkhnRVZGQWNqTlRRbUlnWWRBU0VtTlRRMk16NEJFenNCTWpZek1oWWRBak1ISnpNOUFUUTJBY0pva2lzNUNiOVlmRmorOEJ4MlVoR1BTZ01FQVFZQ0ZSMld5TWlXRkFNZ2ttZ3lFRlV4R2hneVBsaFlQakl4TTFKMlZuTCtjQUVkRlFHV3lNaVdBZzhkQUFBQUFnQUFBQUFESUFNZ0FCUUFId0FJdFJvVkNRQUNMU3NCTWhZZEFSNEJGUlFISXljSEl5WTFORFl6UGdFVEZ5TVZGQVlpSmowQkl3SENhSklyT1FtTnlNamVISFpTRVk5YStzZ2RLaDNJQXlDU2FESVFWVEVhR01qSU1UTlNkbFp5L2o3Nk1oVWRIUlV5QUFBQUFRQUFBR1FESUFLOEFCSUFCck1KQUFFdEt3RXlGaDBCSGdFVkZBWWpJU0ltTkRZelBnRUJ3bWlTS3psWVB2NCtVbloyVWhHUEFyeVNhRElRVlRFK1dIYWtkbFp5QUFBQUFnQUFBQUFESUFNZ0FBc0FIZ0FJdFJVTUJ3QUNMU3NUTWhjaUJnY0dCeVkxTkRZRk1oWWRBUjRCRlJRR0l5RWlKalEyTXo0QitudE5hckVxT2lvWmtnRXdhSklyT1ZnKy9qNVNkblpTRVk4RElHUnpYaEFmTkRab2tzaVNhRElRVlRFK1dIYWtkbFp5QUFBQUF3QUFBR1FESUFLOEFBTUFDUUFQQUFxM0RRb0hCQUlBQXkwckFUTUJJd016Qnhjakp5VXpGd2NqTndIMFpQN1VaR1JrWkdSa1pBSllaR1JrWkdRQ3ZQMm9BZlRJeU1qSXlNaklBQUlBQUFBQUF5QURJQUFmQUNjQUNMVWtJQkFBQWkwckFUTWZBVGNYQng4QkZROEJGd2NuRHdFakx3RUhKemN2QVRVL0FTYzNGemNXSWdZVUZqSTJOQUZlWkRJY2QwZ3lESGQzRERKSWR4d3laREljZDBneURIZDNEREpJZHh5aWZGaFlmRmdESUhjTU1raDNIREprTWh4M1NESU1kM2NNTWtoM0hESmtNaHgzU0RJTWcxaDhXRmg4QUFBQUF3QUFBQUFESUFNZ0FBTUFCZ0FLQUFxM0NRY0dCQUlBQXkwckVTRVZJUmNoQndVaEZTRURJUHpneUFHUXlQNXdBeUQ4NEFNZ3lHVEl5R1FBQXdBQUFBQURJQU1nQUFNQUJ3QUtBQXEzQ1FnR0JBSUFBeTByRVRNUkl3RXpFU01ERVNka1pBSll5TWhreUFNZy9PQURJUHpnQWxqK2NNZ0FBd0FBQUFBRElBTWdBQU1BQndBS0FBcTNDZ2dHQkFJQUF5MHJFVE1SSXdFekVTTUJGd2ZJeUFLOFpHVCtjTWpJQXlEODRBTWcvT0FDV01qSUFBQUFBQU1BQUFBQUF5QURJQUFEQUFZQUNnQUt0d2tIQlFRQ0FBTXRLeEVoRlNFRkZ5RUhJUlVoQXlEODRBR1F5UDV3eUFNZy9PQURJR1RJeUdUSUFBWUFBQUFBQXJ3Q3ZBQW5BREFBT1FBOUFFWUFUd0FSUUE1S1IwSStPem8xTVN3b0ZBQUdMU3NTTWhZZEFUTTFORFl5RmhRR0t3RVZNeklXRkFZaUpqMEJJeFVVQmlJbU5EWTdBVFVqSWlZMEZpSUdGQlk3QVRVMEpDSUdIUUV6TWpZMEJSVXpOUWNpQmhRV01qWTlBU0VWRkJZeU5qUW1JMWg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHhZV0Q0eU1qNVlxeW9kSFJVeUFYTXFIVElWSGY3VVpQb1ZIUjBxSFFFc0hTb2RIUlVDdkZnK01qSStXRmg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHdNSFNvZE1oVWRIUlV5SFNxclpHVElIU29kSFJVeU1oVWRIU29kQUFBQkFBQUFBQU1nQXlBQUNnQUdzd1lCQVMwckVUUXpJVElWRVNjaElqVUpBdzRKeVAyeENRTVhDUXI4NnNnSkFBQUVBQUFBQUFNZ0F5QUFCd0FQQUJNQUd3QU5RQW9ZRkJJUURBZ0VBQVF0S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFuQXdVVEZpSUdGQll5TmpUckFVcnI2LzYyNndJTStMQ3crTEJrWlA3VVpIa3FIUjBxSFFNZzYvNjI2K3NCU29ldytMQ3crRXorMUdRQkxESWRLaDBkS2dBQUFBSUFBQUFBQXlBRElBQUhBQTBBQ0xVSkNBUUFBaTByRWlBV0VBWWdKaEFsRVRJMk5DYnJBVXJyNi82MjZ3R1FmTEN3QXlEci9yYnI2d0ZLaC8yb3NQaXdBQUFBQlFBQUFBQURJQU1nQUFNQUJ3QUxBQThBRndBUFFBd1VFQTRNQ2dnR0JBSUFCUzByRVNFVklSVWhGU0VWSVJVaEZTRVZJU1F5RmhRR0lpWTBBeUQ4NEFIMC9nd0RJUHpnQWxqOXFBTFpLaDBkS2gwRElHUmtaTWhrWkdSa0hTb2RIU29BQUFRQUFBQmtBeUFDdkFBSkFCTUFGd0FiQUExQUNoa1lGUlFPQ2dVQUJDMHJFeUV5RmgwQklUVTBOZ2NoRVJRR0l5RWlKalUzRlRNMU14VXpOUmtDN2dzTy9PQU9EZ01nRGd2OUVnc09aR1JrWkFLOERndExTd3NPeVA2SkN3NE9DNjlrWkdSa0FBQUFBd0FBQUFBRElBTWdBQklBRlFBWUFBcTNGeFlVRXdzQUF5MHJFek1WSVRjWEJ4RXpGU01WSXpVaEVTTTFNeGNSQVJjQklXUmtBY0prTW1Sa1pHVCtER1JrWkFGZU12NmlBVjRESUdSa01tVCtQbVJrWkFIMFpHVCtvZ0ZlTXY2aUFBQUFBQVVBQUFBQUF5QURJQUFIQUE4QUZ3QXNBRFFBRDBBTU1TMG1HeFFRREFnRUFBVXRLeElnRmhBR0lDWVFKQ0lHRkJZeU5qUWtNaFlVQmlJbU5BYzBOamM3QWpJZkFUY3lGaFFHSWlZMU55Y21KRElXRkFZaUpqVHJBVXJyNi82MjZ3SU0rTEN3K0xEK3Z5b2RIU29kbGhRT0F3TUlGZzViR1NrN08xSTdCbG9RQVVrcUhSMHFIUU1nNi82MjYrc0JTb2V3K0xDdytFd2RLaDBkS25jUEhRUVFXZ1k3VWpzN0tSbGJEa1lkS2gwZEtnQUFBQUlBQUFBQUF5QURJQUFHQUFvQUNMVUpCd1FBQWkwckFUTVJNd2tCTXdFaEZTRUJMTWpJL3RUKzFNaisxQU1nL09BRElQN1UvdFFCTFA1d1pBQUFBQUFDQUFBQUFBTWdBeUFBQXdBS0FBaTFCd1FDQUFJdEt4RWhGU0VGQVNNUkl4RWpBeUQ4NEFHUUFTekl5TWdESUdSay90VCsxQUVzQUFJQUFBQmtBeUFDdkFBRUFCQUFDTFVKQlFJQUFpMHJFeUVSSVFNbEJ4Y0hGemNYTnljM0p3ZklBbGo5cU1nQlhraVdsa2lXbGtpV2xraVdBcno5cUFFczNraVdsa2lXbGtpV2xraVdBQUFBQWdBQUFHUURJQUs4QUFzQUdBQUl0Uk1NQXdBQ0xTc1NJQllWSXpRbUlnWVZJelFsRnpjZUFSVVVCaUltTlRRMjZ3Rks2MlN3K0xCa0FWVTdPejVQZHFSMlR3Szg2NlY4c0xCOHBScFlXQk5wUTFKMmRsSkRhUUFBQUFBRkFBQUFBQUs4QXlBQUJRQUlBQXdBRUFBVUFBOUFEQklSRGcwS0NRY0dCQUFGTFNzUklSRWhFU0VKQVNFbEZUTTFCeFV6TlFjVklUVUJMQUdRL1VRQmtBRXMvdFQrMUdSa1pHUUJrQU1nL25EK2NBTWcvdFJrWkdUSVpHVElaR1FBQUFBQUFRQUEvNXdCOUFLOEFEc0FCck1lQUFFdEt4TXpGVE15RnhZZEFTTTFKaXNCSWdZZEFSUVdGd1VlQVIwQkZBWXJBUlVqTlNNaUp5WTlBVE1WRmpzQk1qWTlBVFFtSnlVdUFUMEJORFk3QWNoa1N6RWdMR1FJRWZvTERoY0xBUUV4UEVvelMyUkxNU0FzWkFnUitnc09Gd3YrL3pFOFNqTkxBcnhrRmg4dlpGNEdEZ3N5Q3g0RFFReE9Nekl6U21Sa0ZoOHZaRjRHRGdzeUN4NERRUXhPTXpJelNnQUNBQUFBWkFNZ0Fyd0FBd0FIQUFpMUJ3UURBQUl0S3hFaEVRa0JJUkVCQVN6KzFBSDBBU3orMUFLOC90VCsxQUpZL3RUKzFBQUFBQUlBQUFCa0F5QUN2QUFEQUFjQUNMVUZCQUVBQWkwckFSRWhFUUVSSVJFQkxQN1VBeUQrMUFLOC9hZ0JMQUVzL2FnQkxBQUNBQUFBWkFNZ0Fyd0FDZ0FWQUFpMUVRc0dBQUl0S3dFVklnWVZNeEVoRVRRMklSVWlCaFV6RVNFUk5EWUJMRk4xeVA3VXNBSndVM1hJL3RTd0FyeGtkVlArMUFFc2ZMQmtkVlArMUFFc2ZMQUFBQUFDQUFBQVpBTWdBcndBQ2dBVkFBaTFEd3NFQUFJdEt4RWhFUlFHSXpVeU5qVWpBU0VSRkFZak5USTJOU01CTExCOFUzWElBZlFCTExCOFUzWElBcnorMUh5d1pIVlRBU3orMUh5d1pIVlRBQUlBQVAvcUFsZ0RJQUFTQUNJQUNMVVlFd2tBQWkwckFSY2VCQlVVQmlJbU5UUStBemNDSWdZVkZCWXpNalkwSmlNaUpqVTBBU3dpRFNoWlJUZXcrTEEzUlZrb0RWOHFIWFpTRlIwZEZTazdBeUFpRFN0eWI1STlmTEN3ZkQyU2IzSXJEZjVLSFJWU2RoMHFIVHNwRlFBQ0FBQUFBQU1nQXlBQUFnQUdBQWkxQlFNQkFBSXRLd2tCSVJVaEZTRUJrQUdRL09BRElQemdBeUQrREdUSUFBQUNBQUFBQUFKWUF5QUFBZ0FGQUFpMUJRTUJBQUl0S3drQklSVWhBUUVzQVN6OXFBSlkvdFFESVA3VXlQN1VBQUFEQUFBQkxBTWdBZlFBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSUFmVEl5TWpJeUFBQUFBQUNBQUFBWkFNZ0Fyd0FCQUFKQUFpMUNBVURBQUl0S3hFaEZRVWxGUVVsRVNFRElQNXcvbkFCa0FHUS9PQUN2R1RJeUdUSXlQNXdBQU1BQUFBQUF5QURJQUFFQUFvQUR3QUt0dzRMQ0FVQ0FBTXRLd0VGRVNFUkpRVVZCU1UxQlNFVkJ5Y0JrQUdRL09BQmtQN1VBU3dCTFA0TUFaREl5QU1neVAyb0FsaFlscnlXbHJ3bVpHUmtBQUFBQUFFQUFQK2NBeUFDdkFBakFBYXpGUUFCTFNzQk1oY0hKaUlHQnlFSElSUVhJUWNqRmpNeU54VUdJeUltSnlFM015WTFJemN6UGdFQ1dHTmNFRTdDbVI4QlN4RCtzaE1CS1JEZVdvUnlWbDVxYkxZMi93QVR4UkRJR2I4aTFBSzhNbW80YjFsa0xUZGtaRTU2T0cxYlpFQWtaSU9wQUFBQUFBWUFBQUFBQXlBQ3ZBQURBQWNBQ3dBUEFCTUFGd0FSUUE0V0ZCSVFEZ3dLQ0FZRUFnQUdMU3NSSVJVaEZTRVZJUlVoRlNFVk14VWpOek1WSXpjekZTTUN2UDFFQWZUK0RBTWcvT0JrWk1oa1pNaGtaQUs4WkdSa1pHUmtaR1JrWkdRQUFBQURBQUFBQUFNZ0F5QUFBd0FHQUFvQUNyY0pCd1lFQWdBRExTc1JJUlVoRnlFSEJTRVZJUU1nL09ESUFaREkvbkFESVB6Z0F5QmtaTWpJeUFBREFBQUFBQU1nQXlBQUF3QUhBQW9BQ3JjS0NBWUVBZ0FETFNzUk14RWpBVE1SSXdFWEIyUmtBbGpJeVA1d3lNZ0RJUHpnQXlEODRBSll5TWdBQUFBQUF3QUFBQUFESUFNZ0FBTUFCd0FLQUFxM0NRZ0dCQUlBQXkwckVUTVJJd0V6RVNNREVTZkl5QUs4WkdSa3lBTWcvT0FESVB6Z0FsaitjTWdBQXdBQUFBQURJQU1nQUFNQUJnQUtBQXEzQ1FjRkJBSUFBeTByRVNFVklRVVhJUWNoRlNFRElQemdBWkRJL25ESUF5RDg0QU1neU1qSVpHUUFBZ0FBQUFBRElBTWdBQWtBRUFBSXRRNEtDQUFDTFNzUk14VWpFU0UxTXhVaEFTRVJKd2NuTjhoa0FsaGsvT0FCa0FHUWx2cGsrZ01nWlAyb1pNZ0RJUDV3bHZwaytnQUFBd0FBQUdRRElBSzhBQnNBSXdBMUFBcTNNU1FnSEEwQUF5MHJBVEllQkI4QkRnUWpJaTRDTHdFK0JoWWlCaFFXTWpZMEp6SVhCaFVVRmpNeU54WVZGQVlpSmpRMkFaTXlZMHhGTVNRSkNRWVhUMWFHUlVlSFhFY1JFUU1NS1M1SVRXU0RwSFoycEhiSUNoSWNIUlVlRGdZN1VqczdBcndoTlVCQU5SRVFEQ2xuVDBFK1dGZ2ZId1lXUGpsRk1pSmtkcVIyZHFRU0JnNGVGUjBjRWdvcE96dFNPd0FDQUFEL25BTWlBcjBBSVFBbEFBaTFKQ0laQXdJdEt3RTdBVFl6TWg4Qk56WXlGeFlVRHdFWEZoVVVCaU1pTHdFQklSRUJKeVkxTkRZWEFSY0JBVXNEQXdNSEZnOWVRaXQrS3l3c1FWMFNIUlVaRHo3K2cvN3pBWGMvRUJXQy9zZUFBVHdDdkFFUlhVRXJLeXg4TEVKZURoZ1ZIUlJCL29NQkVBRjlQdzRXRHgzWC9zV0VBVHdBQWdBQUFBQUN2QU1nQUFVQUNBQUl0UWNHQkFBQ0xTc1JJUkVoRVNFSkFTRUJMQUdRL1VRQmtBRXMvdFFESVA1dy9uQURJUDdVQUFBQ0FBQUFBQUs4QXlBQUdnQXNBQWkxSXhzTkFBSXRLeE1lQkJVVURnUVhMZ1ExTkQ0RU5BRWVCQlVVQmlNaE5ENEVOTWdJRzBVMUt5czlRUzBMR1FnYlJUVXJJVEU1TVNBQkdBZ2JSVFVyUHlYKzFDRXhPVEVnQXlBRUVEaEFhRGd1WFVkU1Jsd3VCQkE0UUdnNEtGQkFRa0ZDVHY3OUJCQTRRR2c0Wm1Jb1VFQkNRVUpPQUFBQUFnQUFBQUFESUFNZ0FBTUFEQUFJdFFrRUFnQUNMU3NSTXhFakV5RVZJUWNYSVRValpHVElBU3dCTE1qSS9uRElBeUQ4NEFNZ1pNdkZaQUFBQVFBQUFBQUJrQU1nQUFvQUJyTUdBQUV0S3hNekJ6TURNd0VETXpjamxwWmt5SmFXL3RSa2hrTElBeURJL3RUKzFBRXN5QUFBQUFBQ0FBQUFBQU1nQXlBQUJRQVBBQWkxQ2dZRUFBSXRLeEVoRlNFVklSVWhFUlFHSXlFaUpqVUJMQUgwL09BRElCMFYvVVFWSFFNZ1pHUmsvajRWSFIwVkFBQUFBQUVBQUFBQUFyd0RJQUF3QUFhekpRQUJMU3NTTWhZVkZBWUhGVFk3QVRJMlBRRXVBVFUwTmpJV0ZSUUdCeFVVQmlzQklnY2VBUlVVQmlJbU5UUTJOelV1QVRVMFdIeFlOeTBiRjhnVkhTMDNXSHhZTnkxWVBzZ1NFQ1l1V0h4WU55MHROd01nV0Q0eFRROTJDUjBWT3c5Tk1UNVlXRDR4VFE4N1BsZ1FFa2dzUGxoWVBqRk5EOW9QVFRFK0FBQUFBQUlBQUFBQUF5QURJQUFHQUEwQUNMVUtCd1FBQWkwckVTRUhGd2NuQnlFWE54RWhOeWNCa0phV1pKYVdBZlNXbHY1d2xwWURJSmFXWkphV2xwYitjSmFXQUFBQUFnQUFBQUFESUFNZ0FBWUFEUUFJdFFzSEF3QUNMU3NURnpjUklUY25BU0VIRndjbkIyU1dsdjV3bHBZQmtBR1FscFprbHBZRElKYVcvbkNXbHY3VWxwWmtscFlBQUFBQUF3QUFBQUFESUFNZ0FBY0FSZ0JWQUFxM1VVY25DQVFBQXkwckVpQVdFQVlnSmhBbElnY1hGZ1lIQmlJR0Z4WUdMZ0VIQmg0QkJ5Y2lCeFlYSGdFWEhnRUhGak15TmpjMkppTWlMZ0kzUGdNbkpqNEJOVFFtSnlZK0F6Y21GdzRCRnhZMkZ4NERQd0UxSnVvQlRPcnEvclRxQVpCUVNSWVdEUllLS3hFRkJnb09Gd1lUR1NBSE93b0dBUklKVGcwbE5oQTZNRXVES1FJWEhSNHdNUnNCQVI4ZUVRME5CUlJFQVFFREN3WVRBem5DSXprRkF6WUlBd2tIRUFrV0VBTWc2djYwNnVvQlRJWXNFdzhqQ1FRT0Z4UUlDUWdFRWtOR0FTSUtIallEQ1EwV2FTQVdRem9VR0FjVEtSNFBMQ0VvQ3hJTkdRb1ZGd1lGQ3cwSEVnSVRiUW9mREFnQkJnTVVEUVlMRmdNbUFBQUNBQUFBQUFNZ0F5QUFCd0FMQUFpMUNnZ0VBQUl0S3dFWEFTY0hKd0VYQVNFVklRSy9ZZjV3Wk1oa0FTeGsvbkFESVB6Z0F5QmsvbkJreTJRQkwyVCtjR1FBQUJBQUFBQUFBcndDdkFBREFBY0FDd0FQQUJNQUZ3QWJBQjhBSXdBbkFDc0FMd0F6QURjQU93QS9BQ1ZBSWo0OE9qZzJOREl3TGl3cUtDWWtJaUFlSEJvWUZoUVNFQTRNQ2dnR0JBSUFFQzByRVRNVkl6Y3pGU00zTXhVak56TVZJd1V6RlNNM014VWpOek1WSXpjekZTTUZNeFVqTnpNVkl6Y3pGU00zTXhVakJUTVZJemN6RlNNM014VWpOek1WSTJSa3lHUmt5R1JreUdSay9haGtaTWhrWk1oa1pNaGtaUDJvWkdUSVpHVElaR1RJWkdUOXFHUmt5R1JreUdSa3lHUmtBcnhrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa0FBa0FBQUFBQXlBRElBQURBQWNBQ3dBUEFCTUFGd0FiQUI4QUl3QVhRQlFpSUI0Y0doZ1dGQklRRGd3S0NBWUVBZ0FKTFNzUk14VWpKVE1WSXlVekZTTUZNeFVqSlRNVkl5VXpGU01GTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSS9hakl5QUVzeU1nQkxNakkvYWpJeUFFc3lNZ0JMTWpJQXlESXlNakl5R1RJeU1qSXlHVEl5TWpJeUFBQUFBUUFBQUFBQXlBRElBQURBQWNBQ3dBUEFBMUFDZzRNQ2dnR0JBSUFCQzByRVNFUklRRWhFU0VGSVJFaEFTRVJJUUVzL3RRQjlBRXMvdFQrREFFcy90UUI5QUVzL3RRRElQN1VBU3orMU1qKzFBRXMvdFFBQUFBREFBQUFBQUs4QXlBQURRQVpBQ0VBQ3JjZUdoVU9CZ0FETFNzVElUSVZFUlFHSXlFaUpqVVJOQkVXTXlFeU54RVVJeUVpTlNRaUJoUVdNalkwRXdLV0V4MFYvYWdWSFJnYUFsZ2FHQlA5YWhNQ095b2RIU29kQXlBVC9yVVZIUjBWQVVzVC9oVUpDZjdlRXhPMUhTb2RIU29BQUFFQUFBQUFBcndDdkFBekFBYXpHZ0FCTFNzUklSVWpJZ1lkQVNFMU5DWXJBVFVoRlNNaUJoVVJGQlk3QVJVaE5UTXlOajBCSVJVVUZqc0JGU0UxTXpJMk5SRTBKaXNCQVN3eUZSMEJMQjBWTWdFc01oVWRIUlV5L3RReUZSMysxQjBWTXY3VU1oVWRIUlV5QXJ4a0hSV1dsaFVkWkdRZEZmNXdGUjFrWkIwVmxwWVZIV1JrSFJVQmtCVWRBQUFBQUFFQUFBQUFBeUFDdkFBbEFBYXpDd0FCTFNzQU1oWWRBVE15RmgwQkZBWXJBU0ltTlJFMEppSUdGUkVVQmlzQklpWTlBVFEyT3dFMU5BRVUrTEF5RlIwZEZXUVZIWFdtZFIwVlpCVWRIUlV5QXJ5d2ZHUWRGY2dWSFIwVkFWNVRkWFZUL3FJVkhSMFZ5QlVkWkh3QUFBQUJBQUFBRXdNZ0Fyd0FEUUFHc3d3Q0FTMHJFRFEyTWhZVk5EWXlGaFFIQ1FGMnBIWjJwSFk3L3F2K3F3R2lwSFoyVWxKMmRxUTcvcXdCVkFBQkFBQUFBQU1nQXJ3QUNnQUdzd01BQVMwckNRRW5FU00xSXhVakVTTUJrQUdRWk1qSXlHUUN2UDdVQS81dHlNZ0JrQUFBQWdBQUFBQURJQU1nQUFNQURRQUl0UWNFQWdBQ0xTc1JJUkVoRXhFM0FUTTFKemNYRVFNZy9PQmtaQUdRWk1oa1pBTWcvT0FDdlA3VVpQNXdaTWhrWkFFc0FBQUNBQUFBQUFNZ0F5QUFDd0FUQUFpMUR3d0ZBQUl0S3hNaE1oVVJGQ01oSWpVUk5CY1JNeGN6TnpNUkV3TDZFeFA5QmhOa1pHVElaR1FESUJQOUJoTVRBdm9UeVA3VVpHUUJMQUFBQXdBQUFNZ0RJQUpZQUJVQUlBQXJBQXEzSmlFYUZnb0FBeTByRXpJV0Z6NEJNeklXRkFZaklpWW5EZ0VqSWlZME5oY2lCaFFXTXpJMk55NEJJU0lHQng0Qk16STJOQ2JJTjE0ek0xNDNYV3RyWFRkZU16TmZObDFyYTEwek1URXpIVDhxS2o4QmN4MC9LaW8vSFRNeE1RSllRRG82UUhpZ2VFQTZPa0I0b0hoa1BGQThOREF3TkRRd01EUThVRHdBQWdBQUFBQUJrQU1nQUFjQUpRQUl0UllJQkFBQ0xTc0FNaFlVQmlJbU5BWXlGaFVVQmhVVUZqSTJOVE1VQmlNaUpqVTBQZ0UxTkNZaUJoVWpOQUVEVWpzN1VqdHdmRmhrSFNvZFpGZytQMWN5TWgwcUhXUURJRHRTT3p0U3YxazlKY2NPRlIwZEZUNVlWa0FsY1ZvS0ZSMGRGVDRBQUFBQUFRQUFBQUFDdkFNZ0FCQUFCck1IQUFFdEt4TWhGU01EQnpNVklUVXpQZ0kvQVNQSUFmUjY2Z2FpL2d4NklrNWdHZ2VqQXlCay9iUU1aR1JZeE85QkRBQUFBQUFFQUFBQUFBTWdBcndBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt4RWhGU0VWSVJVaEZTRVZJUmNoRlNFRElQemdBeUQ4NEFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUJBQUFBQUFESUFLOEFBTUFCd0FMQUE4QURVQUtEZ3dLQ0FZRUFnQUVMU3NSSVJVaEZTRVZJUlVoRlNFVklSVWhBeUQ4NEFNZy9PQURJUHpnQWxqOXFBSzhaR1JrWkdSa1pBQUFBQVFBQUFBQUF5QUN2QUFEQUFjQUN3QVBBQTFBQ2c0TUNnZ0dCQUlBQkMwckVTRVZJUlVoRlNFVklSVWhGeUVWSVFNZy9PQURJUHpnQXlEODRNZ0NXUDJvQXJ4a1pHUmtaR1JrQUFBQ0FBQUFBQU1nQXlBQUVRQVpBQWkxRmhJTEFBSXRLd0F5RmhRR0l5SW5CeFVqRlNFMUFTWTFOQ1FpQmhRV01qWTBBYjdRa3BKb0lBOER5UDdVQVM4REFWVlNPenRTT3dNZ2t0Q1NBd05reU1nQkx3OGdhQzQ3VWpzN1VnQUFBQUFDQUFBQUFBTWdBbGdBR0FBZ0FBaTFIQmtOQUFJdEt4TTdBeUV5RmhVUk14VVVCaU1oSWlZOUFUTVJOVFEyRnhFekZUTTFNeEdHQXdRRUJRSDBGUjFrSFJYOVJCVWRaQlJRWk1oa0FsZ2RGZjZpbGhVZEhSV1dBVjRDRHgxZy90UmtaQUVzQUFBQUFBTUFBQUFBQXlBRElBQURBQWtBRHdBS3R3d0tCZ1FDQUFNdEt4RWhFU0VsTXhFaE5TRTNNeEVoTlNFQmtQNXdBZlJrL25BQkxNaGsvbkFCTEFNZy9uREkvbkJrWlA1d1pBQUFBQUFFQUFEL213SDhBcjBBRVFBakFEMEFVQUFOUUFwTlFESWxIQk1LQVFRdEt3RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0R3RWVBUlVVQmlNaUppc0JMZ0UxTkRZM0Z6UTJPd1F5RmhRR0t3RWlCaU1pSmdGUkNnc1ZIUkFML3RRUEVCVWRGZzhCa0FzS0ZSMFFDLzV3RHhBVkhSWVBBWkFMQ2hVZEVBdHFFaGtlRlFFR0FjZ1RIUThMRGhzVEF3UUZaQlVkSFJWa0FRWUJGUjBDdGdjZEZRMGFCcFlMSFJVUUhRUUhIUlVOR2diSUN4MFZFQjBFQngwVkRSb0dPQU1kRWhVZUFRRWRGQXdhQnZRU0lCMHFIUUVlQUFRQUFBQUFBeDRESUFBRkFDY0FTZ0JRQUExQUNrOUxSUzBRQ0FJQUJDMHJFek1WSXpVekpUTTJGeFlYRmhRUEFRWWpJaVkxTkQ4Qk5pWW5KZ1lQQVFZaklpWTFORDhCTmdFMk93RXlOak15RmhRUEFRWVdGeFkyUHdFMk16SVdGUlFQQVFZSEJpWW5KalEzQlRNVkl4VWp4MlRJWkFHREFTSVdOeW82T3BZUEhCVWRHSlllQVIwZ1ZSc3NEeHNWSFJnck12N1VEUWtEQVFZQkZSME9saDRCSFNCVkd5d1BHeFVkR0NzZkxEUnlLVG82QWJuSVpHUURJTWhrWVFJRkRDbzZwRHVXR0IwVkhBK1dIbFVkSGdNYkxCZ2RGUndQTERUKzBSQUJIU29PbGg1VkhSNERHeXdZSFJVY0R5d2ZFQk1aS1R1a09veGtaQUFBQUFJQUFBQUZBeDRESFFBckFGUUFDTFZVVFFrQkFpMHJBVFlYRmhjV0ZBOEJCaWN1QlNNbU5UUTJNeklYRmhjV1B3RTJKaWNtQmdjR0l5SW1OVFEzTmdjZUFoY2VBUlVVQmlNaUp5WW5KZzhCQmhZWEZqWTNOak15RmhVVUJ3WUhCaVluSmpRL0FUWUNTaU1XTnlvNk9wWlVZZ3dXRFJFRkRnRWFIUlVPREE4YU56T1dIZ0VkSUZVYkR4d1ZIUmd5ZWhZZ0dBY1BGaDBWRUE4VEhEa3VsaDRCSFNCVkd3OGJGUjBYSHl3MGNpazZPcFpRQXgwQ0JRd3FPcVE3bGxRR0FRTURCd01JRGg0VkhnY0xBZ1F6bGg1VkhSNERHeGdkRlJ3UE5PTUJDQXNDQkIwUUZSMExDUUVDTHBZZVZSMGVBeHNZSFJVZERoOFFFeGtwTzZRNmxsQUFBQUFBQmdBQUFBQURJQUs4QUFNQUJ3QUxBQThBRXdBWEFCRkFEaFlVRWhBT0RBb0lCZ1FDQUFZdEt4RWhFU0VCSVJVaEZTRVZJUVVoRVNFQklSVWhGU0VWSVFFcy90UUJrQUdRL25BQkxQN1UvbkFCTFA3VUFaQUJrUDV3QVN6KzFBSzgvdFFCTEdSa1pHVCsxQUVzWkdSa0FBZ0FBQUFBQXlBQ3ZBQUhBQXNBRXdBWEFCOEFJd0FyQUM4QUZVQVNMaXdvSkNJZ0hCZ1dGQkFNQ2dnRUFBZ3RLeEl5RmhRR0lpWTBOeUVWSVFZeUZoUUdJaVkwTnlFVklRWXlGaFFHSWlZME55RVZJUVl5RmhRR0lpWTBOeUVWSVIwcUhSMHFIY2dDV1Ayb3F5b2RIU29keUFKWS9haXJLaDBkS2gzSUFsajlxS3NxSFIwcUhjZ0NXUDJvQXJ3ZEtoMGRLaDFrWkIwcUhSMHFIV1JrSFNvZEhTb2RaR1FkS2gwZEtoMWtBQUFBQVFBQUFBQURJQU1nQUFNQUJyTUJBQUV0S3drQkF5VURJUDV3WlA3VUF5RDg0QUVzWkFBQUFBSUFBQUFBQWxnQ3ZBQUxBQk1BQ0xVUURBWUFBaTByRWpJV0hRRXpFU0VSTXpVME5pSUdIUUV6TlRUYXBIWmsvYWhrOGxRNnlBSzhkbEprL25BQmtHUlNFam9xWkdRcUFBRUFBQUFBQWxnRElBQVJBQWF6QmdBQkxTc1NNaFlkQVRNUklSRWhOVFFtSWdZVkl6VGFwSFprL2FnQmtEcFVPbVFESUhaU3lQNXdBWkRJS2pvNktsSUFBQUFBQWdBQUFHUURJQUs4QUFvQUZRQUl0UThMQmdBQ0xTc0JGU0lHRlRNSEp6TTBOZ1VYSXhRR0l6VXlOalVqQVpCVGRXU1dsbVN3QVhhV1pMQjhVM1ZrQXJ4a2RWUEl5SHl3Wk1oOHNHUjFVd0FDQUFBQUFBTWdBeUFBQ2dBVkFBaTFFZ3NFQUFJdEt4TWhFVE1ISnpNMUlSVWpId0VqRlNFMU14VWhFU05rQWxoa2xwWmsvbkJrTXBaa0FaQmsvYWhrQXlEKzFQcjZ5R1F5K3Noa3lBRXNBQUlBQUFBQUF5QUN2QUFMQUJjQUNMVVdEQUlBQWkwckFSY0hOU0VWSXpVME5qTWhBUlVoTlRNVkZBWWpJUlVuQWxqSXlQNE1aRHNwQWZUK2NBSDBaRHNwL2d6SUFyeVdsbVJrWkNrNy90UmtaR1FwTzJTV0FBQUNBQUQvL2dNaUF5QUFHUUFqQUFpMUh4b05BQUl0S3hJZ0ZoVVVCeFlmQVI0QkZSUUdJeUltTHdFbUp3WWpJaVlRQVRJMk5UUW1JZ1lVRnMwQklzMHNDZ1prREJJOEtoRXJER1FGQjAxWmtjMEJYbXFRa3RDU2tnTWd6WkZXVUFZR1pBd3JFU284RWd4a0JBa3B6UUVpL25XUWFtaVNrdENTQUFBQUFnQUFBQUFDV0FNZ0FCQUFHQUFJdFJVUkNRQUNMU3NTTWhZVkZBNENEd0V1QkRVMEpDSUdGQll5TmpTdytMQStXRmdmSHd3cFowOUJBWDZrZG5ha2RnTWdzSHc0a0g1dUlDQU1LMzExa3poOFRIYWtkbmFrQUFRQUFBQUFBeUVESUFBSUFCY0FKZ0F1QUExQUNpc25IeGdSRHdjQUJDMHJFU0VSRmhVVUJ4VWhKVFEyT3dJUklSRWhOU3NCSWlZQ01oWVZGQVlQQVM0RU5UUVdJZ1lVRmpJMk5BTWdBUUg4NEFIdkhSVUZsdjJvQWxpV0JSVWR6M3hZU3lVbUJoUTBLQ0NyS2gwZEtoMERJUDNqQXdnSEErNzZGQjRCa1Ayb1pCMEJjMWcrTEgwcEtBWVdQanBLSEQ0TUhTb2RIU29BQWdBQUFHUUNXQUs4QUFNQUJ3QUl0UVlFQWdBQ0xTc1JNeEVqQVRNUkk4aklBWkRJeUFLOC9hZ0NXUDJvQUFBQUFRQUFBR1FDV0FLOEFBSUFCck1DQUFFdEt4RUpBUUpZL2FnQ3ZQN1UvdFFBQUFBQUFRQUFBR1FDV0FLOEFBY0FCck1FQUFFdEt4SXlGaFFHSWlZMHNQaXdzUGl3QXJ5dytMQ3crQUFBQUFBQ0FBQUFaQU1nQXJ3QUFnQUZBQWkxQlFRQkFBSXRLd0VSQVNFQkVRR1EvbkFCa0FHUUFyejlxQUVzQVN6OXFBQUNBQUFBWkFNZ0Fyd0FBZ0FGQUFpMUJBTUNBQUl0S3hFSkFTRVJBUUdRL25BQmtBR1FBcnorMVA3VUFsaisxQUFDQUFBQVpBSzhBcndBQXdBR0FBaTFCZ1VDQUFJdEt4RXpFU01UQVJISXlNZ0I5QUs4L2FnQkxBRXMvYWdBQUFBQ0FBQUFaQUs4QXJ3QUFnQUdBQWkxQkFNQ0FBSXRLeEVKQVNFUk14RUI5UDRNQWZUSUFyeisxUDdVQWxqOXFBQUJBQUFBWkFKWUFyd0FBd0FHc3dJQUFTMHJFU0VSSVFKWS9hZ0N2UDJvQUFFQUFBQUFBeUFESUFBTEFBYXpCZ0FCTFNzVElSVXpFU01WSVRVakVUUElBWkRJeVA1d3lNZ0RJTWorY01qSUFaQUFBQUFEQUFBQUF3TWdBcndBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSSVJVaEZTRVZJUlVoRlNFRElQemdBeUQ4NEFNZy9PQUN2R1RGWk1oa0FBQUNBQUQvbkFKWUFzQUFFQUE4QUFpMUx4VUpBUUl0S3dFMk16SVdIUUlVQmlJbVBRSTBOZ2M3QVRJMk16SVdIUUlVRmpJMlBRRTBOaklXSFFFVUJnY1ZNeklXRlNFME5qc0JOUzRCUFFJME5nRVdEZ2dwT3p0U095N1VCQU1CQmdJVkhYV21kUjBxSFk5ck1pazcvbkE3S1RKcmp4UUN2QVE3S1FUSUtUczdLY2dDSVRyQkFSMFZBVEpUZFhWVE1oVWRIUlV5YnFZU2Fqc3BLVHRxRXFadU1nSVBIUUFBQUFBQkFBQUJMQU1nQWZRQUF3QUdzd0lBQVMwckVTRVZJUU1nL09BQjlNZ0FBQUlBQVArY0F5QUN2QUFnQUNRQUNMVWlJUklBQWkwckV6c0RJVElXRlJFVUJpc0JGVE15RmhVaE5EWTdBVFVqSWlZMUVUVTBOaGNSSVJFaUJBTUVCUUs4RlIwZEZmcGtLVHY5cURzcFpQb1ZIUlJRQWxnQ3ZCMFYvZ3dWSFdRN0tTazdaQjBWQWZRQ0R4MWcvbkFCa0FBQkFBRC9zZ01LQXJ3QUR3QUdzd2tBQVMwckFRWVZGQll6TWpjT0FTTWlKalUwTmdFUUZ1cW1RVDhvMElLbTZwZ0N2RDlCcHVvV2VKanFwb0xRQUFBQUFRQUFBQUFDdkFLOEFCY0FCck1NQUFFdEt3RVhJeFV6TlJjSE5TTVZNd2NuTXpVakZTYzNGVE0xSXdGZWxtU1dscGFXWkphV1pKYVdscFprQXJ5V2xtU1dsbVNXbHBhV1pKYVdaSllBQUFBQkFBQUFBQU1nQXlBQUhRQUdzeEFBQVMwckFSRVVCaUltTkRZek1oYzFCQWNSRkFZaUpqUTJNeklYRVQ0RUF5QllmRmhZUGhjYi92V0ZXSHhZV0Q0WEd3UVVXSGprQXlEOTJqNVlXSHhZQ2M0SUt2NXpQbGhZZkZnSkFaa0VEaUlhRmdBQUFRQUEvNTBDdWdLOEFDd0FCck1uQUFFdEt3QXlGeFlVRHdFR0lpWTBQd0VYRHdFR0ZCWXlQd0UrQVNjdUFRY0JEZ0VYRmpJL0FoY0hCaUltTkRjQkFhR2tPem82K2lSblNDUmdSVm9IQnc0WUIvb2NBUjBkVlI3KzZqSUJNelNTTkFsMFJYMVE1S0JRQVJZQ3ZEczdwRHIwSkVobkpHRkZYZ01JRmhBSTl4NVJIaDBCSHY3dE5KQXpORFFNY1VWOVVLRGtVQUVRQUFBQ0FBQUFBQU1nQXlBQUF3QUlBQWkxQmdRQ0FBSXRLd0VYQnljSEZ3RWpOUUpZeUdUSVpNaitjTWdESU1oa3lHVEkvbkRJQUFBQUFBUUFBQUFBQXlBRElBQU1BQlFBSGdBcUFBMUFDaVlmR1JVUkRRUUFCQzByQVRJV0ZBWWpJaWMyTlRRbk5nUXlGaFFHSWlZMEJSNEJIUUVqTlRRbk5nVVdNamNlQVIwQklUVTBOZ0ltUGxoWVBob2hDVWd1L3VKOFdGaDhXQUp4SWluSUxHWDl1a2ZRUnlJcC9nd3BBeUIxcG5VVEp5cCtWbGhrZGFaMWRhYkhFVDhtcGtKSVBnTVRWRlFSUHlhbXBpWS9BQUFDQUFBQUFBTWdBeUFBQndBVEFBaTFEd2dFQUFJdEt3QXlGaFFHSWlZMEF4WXlOeDRCSFFFaE5UUTJBVDJtZFhXbWRRbFo4RmxRYi96Z2J3TWdrODZUazg3K24yUmtCSE5SWkdSUmN3QUFBQU1BQUFBQUFmUURJQUFMQUE4QUZ3QUt0eFFRRFF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjUklSRUNJZ1lVRmpJMk5CTUJ6aE1UL2pJVFpBRXNnU29kSFNvZEF5QVQvUVlURXdMNkUyVCtEQUgwL2RvZEtoMGRLZ0FBQXdBQUFBQURJQU1nQUFVQUR3QVdBQXEzRWhBTEJnTUFBeTByQVRJWEVRRTJCUjRCRlJRR0l5SW5BU1VYQnk0Qk5UUUJYaG9ZL3RkbEFTaUFyTTJSZTJNQkVQNW43ZFEyUGdNZ0EvNXpBU2xuYWhQQ2c1SE5VUUVRMGVyVUtucEdmQUFBQUFFQUFQK2NBcndDdkFBakFBYXpGUUlCTFNzVE5EWTdBeUV5RmhRR0t3RVZNeklXRlNFUkJ5Y1JJVFEyT3dFMUl5SUdJeUltWEJzVEF3UUZBWkFWSFIwVk1tUXBPLzdVT0N6KzFEc3BaRElCQmdFVkhRS0tFaUFkS2gzSU95bisxR1JrQVN3cE84Z0JIZ0FBQUFJQUFBQUFBeUFESUFBSEFBb0FDTFVKQ0FRQUFpMHJFaUFXRUFZZ0poQWxFU1hxQVV6cTZ2NjA2Z0VzQVN3RElPcit0T3JxQVV3aS9uRElBQUVBQUFBQUF5QURJQUFMQUFhekJnQUJMU3NCTXhFaEZTRVJJeEVoTlNFQkxNZ0JMUDdVeVA3VUFTd0RJUDdVeVA3VUFTeklBQUFBQWdBQUFBQUN2QU1nQUFNQUhnQUl0UmdFQWdBQ0xTc0JNeEVqQXhjSEJoVVVGakkyTlRRbUx3RTNGeDRCRlJRR0lDWTFORFkzQVN4a1pJQStLRjZTMEpJMExTVStKajVJemY3ZXpVZytBeUQrY0FFQVRoOUxlbWlTa21nN1p5TWZUaDh4a0ZLUnpjMlJVcEF4QUFBQUFBTUFBQUFBQXlBRElBQURBQk1BRndBS3R4WVVDUVFDQUFNdEt4TWhGU0VISVRJVkVSUXJBVFVoRlNNaU5SRTBGeUVSSWNnQmtQNXd2d01PQ1FsYi9haGJDY2dCa1A1d0F5RElaQW4rNWduSXlBa0JHZ25JL3RRQUFBQUFCUUFBQUFBRElBSzhBQU1BQndBTEFBOEFFd0FQUUF3U0VBNE1DZ2dHQkFJQUJTMHJFVE1SSXdFekVTTUJNeFVqRnpNVkl4Y3pGU05rWkFLOFpHVCtETWpJWk1qSVpNaklBcno5UkFLOC9VUUNXR1JrWkdSa0FBRUFBUC9oQXlBQ3ZBQWJBQWF6RWdBQkxTc0JGaE0rQVRjV0Z6TVZJeWNHQnlZREJnSUhKaWNqTlRNZkFUWVNBVVVhYVE4NkR4UkRxZWNOU2lZV1lSVlRGUnc0ZEx3SkF3OVdBcnhYL3JRbGxDVW1obVFjdUZ0SkFUaEQvdlpEV0s1a0lnWXhBUnNBQVFBQS81d0RJQUs4QURrQUJyTWZBZ0V0S3hNME5qSVdGUlFPQVFjR0ZUTVZNamMrQWpNeUZoUUdJeUl1QVNjbUl4VWpORGMrQWpVMEppSUdGUlFlQVJjV0ZTTVJNelFuTGdMSU9WWTVDUkFEQStjV0JnY2RGdzByT1RrckRSY2RCd1lXNXdNREVBazVWamtKRUFNRDUrY0RBeEFKQWxnck9Ua3JEUmNkQndZVzV3TURFQWs1VmprSkVBTUQ1eFlHQngwWERTczVPU3NORngwSEJoWUNXQllHQngwWEFBQUFBZ0FBLzV3QjhRSzhBQ3NBTHdBSXRTNHNEd0FDTFNzVE1oY1dGUlFPQVFjT0JCMEJJelUwUGdFM1BnZzFOQ2NtSXlJSEJnY25OamMyRXpNVkkvZCtRVHNyS2lJWEN4NElDV1FvS2lFQ0d3UVZCQThEQndJY0psUlBKUmdIWkFveFFraGtaQUs4T3paWE5sOHVIaFFMSVJZb0dCa1pObDR3SFFJWEJSUUlFdzRXRnc0cEdTSWxHQzBNVHpGQy9VUmtBQUFBQUFRQUFBQUFBeUFESUFBZkFETUFSd0JiQUExQUNsUk1RRGdzSkFvQUJDMHJBVElXSFFFZUFSVVVCZ2N1QVNNaUJ5NEJJZ1lISmlNaUJ5WTFORFl6UGdFRE93RXlOak15RmgwQ0ZBWWlKajBDTkRZSE93RXlOak15RmgwQ0ZBWWlKajBDTkRZbE93RXlOak15RmgwQ0ZBWWlKajBDTkRZQndtaVNLemsvTVJGTExoc2REVkJtVUEwZEd6a29OWFpTRVk4YUJBTUJCZ0lWSFIwcUhSUzZCQU1CQmdJVkhSMHFIUlFCbmdNRUFRWUNGUjBkS2gwVUF5Q1NhRElRVlRFelVBMHFOQXd4UHo4eERDSTZURkoyVm5MK0RBRWRGUUhJRlIwZEZjZ0NEeDFnQVIwVkFXUVZIUjBWWkFJUEhRUUJIUlVCWkJVZEhSVmtBZzhkQUFFQUFBQUFBeUFESUFBakFBYXpDd0FCTFNzQkZ3YzFJd2NmQVRNMUZ3YzFJeUl2QVFjR0t3RTFNemN2QVNNMU16SWZBVGMyT3dFQ1dNaklNcG12QmhiSXlCa3VJS2FaSHk5a1pLYWpBMlJrTGlDWmpSOHZNZ01nbHBaa3Y4NERaSmFXWkNhK3ZpWmt6cjhEWkNheXNpWUFBQUFBQVFBQUFBQURJQU1nQUJVQUJyTVFBQUV0S3dFeUZ6Y1JJVGNtSXlJR0ZCWXlOeGNHSXlJbUVEWUJrS0ozZC83VWJWbDRmTEN3K0ZoSWRLaWw2K3NESUhkMy90UnRXN0Q0c0ZoSWRPc0JTdXNBQUFBQUFRQUFBQUFESUFNZ0FBa0FCck1GQUFFdEt3RWhFU2NCRnlFUkZ3RUJrQUdRcHY1d3B2NXdwZ0dRQXlEK2NLYitjS1lCa0tZQmtBQUJBQUFBQUFIMEF5QUFDUUFHc3dVQUFTMHJHd0VqRlRNTEFUTTFJL3I2eU1qNitzaklBeUQrMU1qKzFBRXN5QUFCQUFBQVpBTWdBbGdBQ1FBR3N3VUFBUzByQVJVek5RMEJOU01WSlFFc3lBRXMvdFRJL3RRQ1dNakkrdnJJeVBvQUFBQUFBd0FBQUFBRElBTWdBQW9BRWdBWEFBcTNGaE1PQ3dVQUF5MHJFVElFRmhJVkl6UUNKQ01WTWdBVkl6UW1JeFV5RmhVam9nRXAxbi9Jb1A3c3BNNEJKc2l2ZlZKMnlBTWdmOWIrMTZLa0FSU2daUDdhem4ydlpIWlNBQUFFQUFBQUFBTWdBeUFBQ2dBVEFCc0FJd0FOUUFvZ0hCY1VEd3NFQUFRdEt4TXlCQklWSXpRdUFpTVZNaDRCRlNNMEppTVZNaFlWSXpRbUl3WXlGaFFHSWlZMFpMNEJRcnhrWDZEZmVvam1obVRxcG55d1pIVlRLVkk3TzFJN0F5QzgvcjYrZXQrZ1gyU0c1b2ltNm1Td2ZGTjFaRHRTT3p0U0FBQUFBUUFBQUFBRElBTWdBQ0VBQnJNUkFBRXRLd0VoTWhZZEFTRTFOQ1lpQmgwQklSRVVCaU1oSWlZOUFUTVZGQll5TmpVUk5EWUJMQUdRS1R2K2NCMHFIUUdRT3luK0RDazdaQjBxSFRzRElEc3B5SllWSFIwVit2N1VLVHM3S2NpV0ZSMGRGUUltS1RzQUFBQUFBZ0FBQUFBRElBSzhBQklBSFFBSXRSb1RDZ0FDTFNzVE14VWpFU0UxTXhVVUJpTWhJaVkxRVRRMklSY0hOU01pQmdjK0FUTkw0Y2dCa0dRc0gvNCtIeXdzQWl6SXlNaEdiQkFSNEprQ3ZHVCtER1I5SHl3c0h3SW1IeXpJeUdSV1E1YkxBQUVBQUFBQUF5QUN2QUFNQUFhekJ3QUJMU3NKQWpVaklnWUhORDRDTXdIMEFTeisxR1NZMGlZdGJjaVNBcnorNVA3RXlKcVNkcXlMUndBQUFBSUFBQUFBQXlBRElBQVVBQndBQ0xVV0ZRc0JBaTByQVRjWEZnUVhGUlFIQmdjR0lpY21KeVk5QVRZa0V4RUZGaGNXRnhZQmZSTVRKUUVPU3BNOVFFaHdTRUE5azBvQkRqaisyZ3h1T0RJckF4Y0pDUTl6SGgvZ3cxRXZOVFV2VWNYZUh4NXovVndDVDNxMWswb2tId0FFQUFBQUFBSzhBeUFBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt3RXpFU01ETXhFakF6TVJJd016RVNNQ1dHUmt5R1JreUdSa3lHUmtBeUQ4NEFLOC9VUUI5UDRNQVN6KzFBQUFBQUVBQUFBQUFyd0RJQUFOQUFhekJ3QUJMU3NCTXhVekZ3Y2pFU01SSXljM013RXNaTWhrWk1oa3lHUmt5QU1neUdSay9uQUI5R1JrQUFBQUFBUUFBQUFBQXlBRElBQUdBQW9BRGdBU0FBMUFDaEVQRFFzSkJ3UUFCQzByRXpNUk13Y25NeE16RlNNVklSVWhGU0VWSWNoa3lQcjZ5TWpJeUFFcy90UUJrUDV3QXlEOXFNaklBbGhrWkdSa1pBQUFBQVFBQUFBQUF5QURJQUFHQUFvQURnQVNBQTFBQ2hFUERRc0pCd1FBQkMwckV6TVJNd2NuTXhNaEZTRVZJUlVoRlRNVkk4aGt5UHI2eU1nQmtQNXdBU3orMU1qSUF5RDlxTWpJQWxoa1pHUmtaQUFBQUFjQUFBQUFBeUFDdkFBUEFCTUFGd0FiQUI4QUl3QW5BQk5BRUNVa0lTQWRIQmtZRlJRUkVBY0FCeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNWTXpVekZTRTFCUlV6TlRNVklUVUZGVE0xTXhVaE5Vc0NpaDhzTEIvOWRoOHNMRGhrWkFHUS9haGtaQUdRL2Foa1pBR1FBcndzSC8zYUh5d3NId0ltSHl4a1pHUmtaTWhrWkdSa3lHUmtaR1FBQUFFQUFBQUFBeUFESUFBSkFBYXpCQUFCTFNzQkV5RUhFeWNIRXljaEFaQmtBU3o2WlByNlpQb0JMQU1nL3RUSS90VEl5QUVzeUFBQUNRQUFBQUFESUFNZ0FBY0FEd0FYQUI4QUp3QXZBRGNBUHdCSEFCZEFGRVJBUERnME1Dd29KQ0FjR0JRUURBZ0VBQWt0S3dBeUZoUUdJaVkwQmpJV0ZBWWlKalFrTWhZVUJpSW1OQVF5RmhRR0lpWTBCaklXRkFZaUpqUWtNaFlVQmlJbU5BUXlGaFFHSWlZMEpESVdGQVlpSmpRR01oWVVCaUltTkFGN0toMGRLaDNkS2gwZEtoMENFU29kSFNvZC91YWtkbmFrZHFzcUhSMHFIUUxaS2gwZEtoMzl4U29kSFNvZEFoRXFIUjBxSGQwcUhSMHFIUU1nSFNvZEhTcEhIU29kSFNvZEhTb2RIU3BIZHFSMmRxUWdIU29kSFNvZEhTb2RIU3JkSFNvZEhTb2RIU29kSFNwSEhTb2RIU29BQXdBQUFBQUN2QU1nQUE4QUV3QVpBQXEzRnhRUkVBY0FBeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNSSVJFQ0lnWVdNallpQW5nT0ZCUU8vWWdPRkJSUUFmVGRPaDBjUEJ3RElCUU8vU1FPRkJRT0F0d09GR1QrREFIMC9kb3lNaklBQUFJQUFBQUFBeUFESUFBRUFBd0FDTFVKQlFNQUFpMHJFU0VKQWpZaUJoUVdNalkwQVN3QjlQN1UvZ3p4VWpzN1Vqc0RJUDRNL3RRQjlNZzdVanM3VWdBREFBQUFaQU1nQWxnQUJBQUtBQklBQ3JjUEN3Z0ZBd0FETFNzUk13RUhBU1V6QVFjbk55UWlCaFFXTWpZMHlBRXN5UDdVQVZTZ0FTeklUbmYrS2lvZEhTb2RBbGorMU1nQkxNaisxTWhPZXNnZEtoMGRLZ0FBQkFBQUFBQURJQU1nQUFjQUR3QVhBQjhBRFVBS0hCZ1VFQXdJQkFBRUxTc1NJQllRQmlBbUVDUWlCaFFXTWpZMEpESVdGQVlpSmpRMklnWVVGakkyTk9zQlN1dnIvcmJyQWd6NHNMRDRzUDZDcEhaMnBIYnlWRG82VkRvRElPdit0dXZyQVVxSHNQaXdzUGhNZHFSMmRxUVNPbFE2T2xRQUFnQUFBQUFESUFLOEFBa0FEd0FJdFF3S0NBQUNMU3NSSVFjaEVTRTFOeEVoQVJjQkp6Y1hBaTlrL3BrQjlHVDlSQUs4WlA1d3lHUmtBcnhrL2d5ZlpQNlpBcnhrL25ESVpHUUFBQU1BQUFBQUF5QURJQUFMQUJFQUZRQUt0eE1TRUF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjSEZ3Y1hOeGNWSVRVSkF3NEpDZnp5Q1paSVpHUklyRTRCTEFNZ0NmenlDUWtERGdsT1NHUmtTS3d5WkdRQUFBQUJBQUFBQUFNZ0F5QUFHUUFHc3cwQUFTMHJFU0VWSXpRbUt3RVJGQlk3QVJVaE5UTXlOalVSSXlJR0ZTTURJREk3S1pZZEZUTCtjRElWSFpZcE96SURJTWdwTy8zYUZSMWtaQjBWQWlZN0tRQUFBQUFDQUFBQUF3SzhBcndBQXdBZEFBaTFGUVFDQUFJdEt4RXpFU01USVRJWEVoVVVCaXNCSWdZVkZCY1dEZ0VtSnk0Q0p5WWpaR1RJQVY0aERtY2RGWllVSGk4R0VpWWtDd0krT0FnY0xBSzgvbkFCa0IvKzNSd1ZIUjhUSDVrVUpRd1JGQU43YUFnY0FBSUFBQUFBQXJ3Q3ZBQWNBQ0FBQ0xVZkhSUUNBaTByQVRZM0Z4NEJCd1lWRkJZN0FUSVdGUlFHRHdFR0l5RVJNamMrQWdFekVTTUJrQkFmRXhNU0JpOGVGSllWSFRRYUdRNGgvcUlzSEFnNFB2NXlaR1FDbWg4REF3WWxGSmtmRXg4ZEZReWdTa2tmQVpBY0NHaDcvdm4rY0FBQUFnQUEvNXdDdkFLOEFCOEFLZ0FJdFNNZ0Z3QUNMU3NUSVJVakZSWVhCeVlqSWdZVUZqSTJOVFFuTnhZVkZBWWdKalUwTmpjMUl3VUFCd1lpSmpRM1BnRTN5QUVzWkRJV0lpa3ZhSktTMEpJUVd4bk4vdDdOcklCa0FmVCsyQlFQSmg0UENjQmJBcnhrQmdnSVhoQ1MwSktTYUM4cEpVUTVrYzNOa1lQR0VnTVEvcVFVRHg0bUR3bVdSd0FDQUFBQUFBTWdBcndBQmdBTkFBaTFEQWNDQUFJdEt3RVhCelVoTlNFQkZTRVZJUlVuQWxqSXlQMm9BbGorY0FKWS9haklBcnlXbG1Say90UmtaR1NXQUFBQUFBSUFBQUFBQXJ3RElBQVBBQ2NBQ0xVakVBZ0FBaTByQVRNeUZoVXpNaFlWSVRRMk93RTBOZ016RVJRV01qWTFFVE1SRkJZeU5qVVJNeEVVSXlFaU5RRXNaQ2s3WkNrNy9VUTdLV1E3bjJRZEtoMWtIU29kWkJQK01oTURJRHNwT3lrcE95azcvdFQrb2hVZEhSVUJYdjZpRlIwZEZRRmUvaDhURXdBQ0FBQUFBQUs4QXlBQUVRQVZBQWkxRkJJTUFBSXRLeE16RVJRV01qWTFFVE1SRkFZckFTSW1OUU1oRlNGa3lEdFNPMlIyVWpKbmsyUUN2UDFFQXlEK2NDazdPeWtCa1A1d1VuWjFVLzdVWkFBQUFBQUVBQUFBQUFNZ0Fyd0FDd0FYQUNNQUp3QU5RQW9tSkIwWUVRd0ZBQVF0S3hNek1oVVJGQ3NCSWpVUk5DRXpNaFVSRkNzQklqVVJOQVV6TWhVUkZDc0JJalVSTkFFaEZTRUp0Z2tKdGdrQ1liWUpDYllKL3QyMkNRbTJDZjdVQXlEODRBSzhDZjRlQ1FrQjRna0ovaDRKQ1FIaUNjZ0ovdVlKQ1FFYUNmNXdaQUFBQUFBSEFBQUFBQU1nQXJ3QUJ3QVBBQmNBR3dBakFDc0FNd0FUUUJBdkxDY2tIeHdhR0JRUURBZ0VBQWN0S3hNek1oMEJJelUwSVRNeUhRRWpOVFFGTXpJZEFTTTFOQVVoRlNFVk14VVVLd0VpTlNVekZSUXJBU0kxSlRNVkZDc0JJalVLdFFuSUFtSzFDY2orM3JVSnlQN1VBeUQ4NE1nSnRna0JMTWdKdFFvQkxNZ0p0UW9DdkFtL3Z3a0p2NzhKWkFsYld3bklaR1MvQ1FtL1d3a0pXNzhKQ1FBQUFBUUFBQUFBQXlBQ3ZBQURBQThBR3dBbkFBMUFDaUVjRlJBSkJBSUFCQzByRVNFVklSY3pNaFVSRkNzQklqVVJOQ0V6TWhVUkZDc0JJalVSTkNFek1oVVJGQ3NCSWpVUk5BTWcvT0FKdGdrSnRna0JOYllKQ2JZSkFUVzJDUW0yQ1FLOFpHUUovaDRKQ1FIaUNRbis1Z2tKQVJvSkNmNGVDUWtCNGdrQUFBQUFBUUFBQUdRRElBSllBQlVBQnJNTkFBRXRLeE1oTWhZZEFUY3pFU01uRlJRR0l5RWlKalVSTkRZeUFmUVZIV1JrWkdRZEZmNE1GUjBkQWxnZEZaWmsvdFJrbGhVZEhSVUJrQlVkQUFNQUFBQUFBeUFESUFBSEFCd0FKQUFLdHlRZEVna0NBQU10S3dFekVTTW5JeEV6SVRVeUZ4NEJGQVlISXdZak5USTNQZ0UwSmljbUJ4Y2VBUlFHRHdFQlRrSkNoc2pJQVN3bEptSi9mMklESWlZYUdFRlZWVUVZR2hraEtpc2dHUU1nL09ESUFaQmtDaG1oMEtJWkNXUUdFV3VNYXhFR1pBTUlOMFEzQ0FNQUFnQUFBQUFDV0FNZ0FBY0FEd0FJdFE4SUFnQUNMU3NCTXhFakp5TVJNd1VYSGdFVUJnOEJBVTVDUW9iSXlBRXNHU0VxS3lBWkF5RDg0TWdCa0dRRENEZEVOd2dEQUFBQUFRQUFBQUFCa0FNZ0FBY0FCck1DQUFFdEt3RXpFU01uSXhFekFVNUNRb2JJeUFNZy9PRElBWkFBQUFBREFBQUFBQUs4QXlBQUR3QVRBQmNBQ3JjVkZCRVFCd0FETFNzQk16SVhBUmNWRkNNaElqMEJOd0UyQXhVek5RTVZNelVCTlZJSUJBRW1Bd245VmdrREFTWUVBV1JrWkFNZ0NmMVdFMUVKQ1ZFVEFxb0ovdFRJeVA3VVpHUUFBQUFEQUFBQUFBTHhBeUFBQ1FBU0FCb0FDcmNYRXcwS0F3QURMU3NCTWhjSEppTWlCeWMyRWpJWEJ5WWpJZ2NuRmpJV0ZBWWlKalFCZDlDcU5ZMjRzNDgxcWxqcVl6VklXMVZLTnF4U096dFNPd01nYlZKYlcxSnQvdFErVlM4dlZlNDdVanM3VWdBQUFBSUFBQUFBQXlFRElBQVpBQ0VBQ0xVZUdnOEFBaTByQVRJWEJ4VXpOeFlWRkFZaklpY0JCaUluSmpRM0FTWTFORFlBSWdZVUZqSTJOQUluSUE5aHlHRURrMmNxTVA3Z0hGZ2NIUjBCSXhPVC9yb3FIUjBxSFFNZ0EySElZUThnYUpJVC90MGNIQjFXSFFFZk1DdG9rdjEySFNvZEhTb0FBQUVBQVArc0F4QUN2QUFYQUFhekRRQUJMU3NURmhjK0FqY1hCeDRDRndjdUFpY0hKelkzSmllTkFmd2JabElrai8wY1psVW1qeVJUWlJ2OWpUUEgrUUVDdkFINUhHVlRKbzM5RzJWVEpJOG1WV1ljL1k4d3gvd0JBQUFBQVFBQUFBQUN2QU1nQUJjQUJyTU9BQUV0S3hFekV6TVRNd016RlNFVklSVWhGU00xSVRVaE5TRTFNMlRuSnVkazRlSCsxQUVzL3RSay90UUJMUDdVNFFNZy90UUJMUDdVWkdSa3lNaGtaR1FBQUFBQUF3QUEvLzRESWdNZ0FCa0FKd0F6QUFxM0xpZ2VHZzBBQXkwckVpQVdGUlFIRmg4QkhnRVZGQVlqSWlZdkFTWW5CaU1pSmhBa0lnWVVGak15TnpZL0FUWTFOQ1V6RlRNVkl4VWpOU00xTTgwQklzMHNDQVZuREJJOEtoRXJER1FGQkU5YWtjMEJ4dENTa21oY1J3NFJBelgrMUdSa1pHUmtaQU1nelpGWVVRUUZaQXdyRVNvOEVneG5CUWdzelFFaWFaTFFrandYQ0FORFdXZ3VaR1JrWkdRQUFBQURBQUQvL2dNaUF5QUFHUUFuQUNzQUNyY3FLQjRhRFFBRExTc1NJQllWRkFjV0h3RWVBUlVVQmlNaUppOEJKaWNHSXlJbUVDUWlCaFFXTXpJM05qOEJOalUwQlNFVkljMEJJczBzQ0FWbkRCSThLaEVyREdRRkJFOWFrYzBCeHRDU2ttaGNSdzRSQXpYK2NBRXMvdFFESU0yUldGRUVCV1FNS3hFcVBCSU1ad1VJTE0wQkltbVMwSkk4RndnRFExbG9ObVFBQVFBQUFBRVptU3NMakJsZkR6ejFBQXNESUFBQUFBRFAyUzlxQUFBQUFNL1pMMm9BQVArYkF5SURJQUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUCtiQUVnRGhBQUFBQUFESWdBQkFBQUFBQUFBQUFBQUFBQUFBQUFBNFFFZ0FCb0FBQUFBQVFvQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBSllBQUFDV0FBQUF5QUFBQU1nQUFBQmtBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBbGdBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUFaQUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU9FQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQTRRQUFBSllBQUFEaEFBQUFsZ0FBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSzhBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBZlFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQVpBQUFBTWdBQUFESUFBQUE0UUFBQU1nQUFBRElBQUFBNFFBQUFBQUFBQUFBQUFXQUJZQUZnQTRBRm9BZUFDWUFNQUE1Z0VPQVV3QllnR0lBYTRCMGdIMkFnd0NJZ0k0QWs0Q1pBSjZBbzRDdGdNQUF5SURWQU4yQThnRDdnUU1CRllFZmdTcUJPZ0UvQVVzQlQ0RlhnV2NCZFlHSUFaWUJ1SUhGZ2RZQjVRSDVBZjBDQVlJR0FncUNIZ0lsZ2kyQ013STRnajRDUTRKTWdsZUNab0p6QW9RQ2tZS2FncWdDc1lMREFzcUMwZ0xhQXVHQy9vTUVneE1ERzRNb0F6VURRWU5ZQTJBRFp3TnhBM3lEaVFPZGc2U0Rxd08xZzcrRHpZUFRnOW1ENFFQb0EvS0VBWVFPQkJXRUhZUWxCQ3lFTllSS0JGc0VZZ1J6QkhxRWdZU0tCSndFcElTdGhNK0UyQVQwaFFhRkVZVWdCVElGUUFWSGhVNEZWb1ZnQlhJRmdRV0poWk1GbklXbUJiSUZ2d1hJaGVZR0JZWW1CalFHU2daUEJsZ0dZSVpxaG5TR2Y0YVBCcG9HclFhekJyZUd2UWJEQnNrR3p3YlZCdGtHMzRibkJ2d0hBQWNPQnhZSElBY3NoeitIUm9kWkIyTUhib2Q3QjRpSGtBZVhCNlVIc0llN2g4aUgzWWZ3Q0ErSUhnZ29pQytJTllnOENFZUlWd2hraUhFSWVJaUdpSkNJbUFpaWlLMEl2d2pHQ09RSThJajRpUU9KRW9rY0NTY0pNWWsraVUwSlhvbG5DWGFKZ1FtUmlhWUp0Z20vaWMrSjJJbmVDZW9KOXdvR0NoR0tIQW93aWtNQUFBQUFRQUFBT0lBYUFBUUFBQUFBQUFDQUFBQUFBQnpBQUFBTmd0c0FBQUFBQUFBQUE0QXJnQUJBQUFBQUFBQUFFSUFoZ0FCQUFBQUFBQUJBQVVBMVFBQkFBQUFBQUFDQUFZQTZRQUJBQUFBQUFBREFDUUJPZ0FCQUFBQUFBQUVBQWtCY3dBQkFBQUFBQUFGQUE0Qm13QUJBQUFBQUFBR0FBc0J3Z0FEQUFFRUNRQUFBSVFBQUFBREFBRUVDUUFCQUFvQXlRQURBQUVFQ1FBQ0FBd0Eyd0FEQUFFRUNRQURBRWdBOEFBREFBRUVDUUFFQUJJQlh3QURBQUVFQ1FBRkFCd0JmUUFEQUFFRUNRQUdBQllCcWdCREFISUFaUUJoQUhRQVpRQmtBQ0FBWWdCNUFDQUFVQUF1QUVvQUxnQWdBRThBYmdCdkFISUFhUUFnQUhjQWFRQjBBR2dBSUFCR0FHOEFiZ0IwQUVZQWJ3QnlBR2NBWlFBZ0FESUFMZ0F3QUNBQUtBQm9BSFFBZEFCd0FEb0FMd0F2QUdZQWJ3QnVBSFFBWmdCdkFISUFad0JsQUM0QWN3Qm1BQzRBYmdCbEFIUUFLUUFBUTNKbFlYUmxaQ0JpZVNCUUxrb3VJRTl1YjNKcElIZHBkR2dnUm05dWRFWnZjbWRsSURJdU1DQW9hSFIwY0RvdkwyWnZiblJtYjNKblpTNXpaaTV1WlhRcEFBQkpBR01BYndCdUFITUFBRWxqYjI1ekFBQnBBR01BYndCdUFHa0FZd0FBYVdOdmJtbGpBQUJHQUc4QWJnQjBBRVlBYndCeUFHY0FaUUFnQURJQUxnQXdBQ0FBT2dBZ0FGVUFiZ0IwQUdrQWRBQnNBR1VBWkFBeEFDQUFPZ0FnQURFQUxRQTNBQzBBTWdBd0FERUFOQUFBUm05dWRFWnZjbWRsSURJdU1DQTZJRlZ1ZEdsMGJHVmtNU0E2SURFdE55MHlNREUwQUFCVkFHNEFkQUJwQUhRQWJBQmxBR1FBTVFBQVZXNTBhWFJzWldReEFBQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREVBTGdBeEFDQUFBRlpsY25OcGIyNGdNUzR4TGpFZ0FBQnZBSEFBWlFCdUFDMEFhUUJqQUc4QWJnQnBBR01BQUc5d1pXNHRhV052Ym1sakFBQUNBQUFBQUFBQS80TUFNZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9JQUFBQUJBQUlCQWdFREFRUUJCUUVHQVFjQkNBRUpBUW9CQ3dCRUFFVUFSZ0JIQUVnQVNRRU1BUTBCRGdFUEFSQUJFUUVTQVJNQkZBRVZBUllCRndFWUFSa0JHZ0ViQVJ3QkhRRWVBUjhCSUFFaEFTSUJJd0VrQVNVQkpnRW5BU2dCS1FFcUFTc0JMQUV0QVM0Qkx3RXdBVEVCTWdFekFUUUJOUUUyQVRjQk9BRTVBVG9CT3dFOEFUMEJQZ0UvQVVBQlFRRkNBVU1CUkFGRkFVWUJSd0ZJQVVrQlNnRkxBVXdCVFFGT0FVOEJVQUZSQVZJQlV3RlVBVlVCVmdGWEFWZ0JXUUZhQVZzQlhBRmRBVjRCWHdGZ0FXRUJZZ0ZqQVdRQlpRRm1BV2NCYUFGcEFXb0Jhd0ZzQVcwQmJnRnZBWEFCY1FGeUFYTUJkQUYxQVhZQmR3RjRBWGtCZWdGN0FYd0JmUUYrQVg4QmdBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0FvQUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0FjTUJ4QUhGQWNZQnh3SElBY2tCeWdITEFjd0J6UUhPQWM4QjBBSFJBZElCMHdIVUFkVUIxZ0hYQWRnQjJRQUJNUUV5QVRNQk5BRTFBVFlCTndFNEFUa0NNVEFDTVRFQ01USUNNVE1DTVRRQ01UVUNNVFlDTVRjQ01UZ0NNVGtDTVdFQ01XSUNNV01DTVdRQ01XVUNNV1lDTWpBQ01qRUNNaklDTWpNQ01qUUNNalVDTWpZQ01qY0NNamdDTWprQ01tRUNNbUlDTW1NQ01tUUNNbVVDTW1ZQ016QUNNekVDTXpJQ016TUNNelFDTXpVQ016WUNNemNDTXpnQ016a0NNMkVDTTJJQ00yTUNNMlFDTTJVQ00yWUNOREFDTkRFQ05ESUNORE1DTkRRQ05EVUNORFlDTkRjQ05EZ0NORGtDTkdFQ05HSUNOR01DTkdRQ05HVUNOR1lDTlRBQ05URUNOVElDTlRNQ05UUUNOVFVDTlRZQ05UY0NOVGdDTlRrQ05XRUNOV0lDTldNQ05XUUNOV1VDTldZQ05qQUNOakVDTmpJQ05qTUNOalFDTmpVQ05qWUNOamNDTmpnQ05qa0NObUVDTm1JQ05tTUNObVFDTm1VQ05tWUNOekFDTnpFQ056SUNOek1DTnpRQ056VUNOellDTnpjQ056Z0NOemtDTjJFQ04ySUNOMk1DTjJRQ04yVUNOMllDT0RBQ09ERUNPRElDT0RNQ09EUUNPRFVDT0RZQ09EY0NPRGdDT0RrQ09HRUNPR0lDT0dNQ09HUUNPR1VDT0dZQ09UQUNPVEVDT1RJQ09UTUNPVFFDT1RVQ09UWUNPVGNDT1RnQ09Ua0NPV0VDT1dJQ09XTUNPV1FDT1dVQ09XWUNZVEFDWVRFQ1lUSUNZVE1DWVRRQ1lUVUNZVFlDWVRjQ1lUZ0NZVGtDWVdFQ1lXSUNZV01DWVdRQ1lXWUNZakFDWWpFQ1lqSUNZak1DWWpRQ1lqVUNZallDWWpjQ1lqZ0NZamtDWW1FQ1ltSUNZbU1DWW1RQ1ltVUNZbVlDWXpBQ1l6RUNZeklDWXpNQ1l6UUNZelVDWXpZQ1l6Y0NZemdDWXprQ1kyRUNZMklDWTJNQ1kyUUNZMlVDWTJZQ1pEQUNaREVDWkRJQ1pETUNaRFFDWkRVQ1pEWUNaRGNDWkRnQ1pEa0NaR0VDWkdJQ1pHTUNaR1FDWkdVQUFBRUFBZi8vQUE4QUFBQUFBQUFBQUFBQUFBQ3dBQ3dnc0FCVldFVlpJQ0JMdUFBT1VVdXdCbE5hV0xBMEc3QW9XV0JtSUlwVldMQUNKV0c1Q0FBSUFHTmpJMkliSVNHd0FGbXdBRU1qUkxJQUFRQkRZRUl0c0FFc3NDQmdaaTJ3QWl3Z1pDQ3d3RkN3QkNaYXNpZ0JDa05GWTBWU1cxZ2hJeUViaWxnZ3NGQlFXQ0d3UUZrYklMQTRVRmdoc0RoWldTQ3hBUXBEUldORllXU3dLRkJZSWJFQkNrTkZZMFVnc0RCUVdDR3dNRmtiSUxEQVVGZ2daaUNLaW1FZ3NBcFFXR0FiSUxBZ1VGZ2hzQXBnR3lDd05sQllJYkEyWUJ0Z1dWbFpHN0FCSzFsWkk3QUFVRmhsV1ZrdHNBTXNJRVVnc0FRbFlXUWdzQVZEVUZpd0JTTkNzQVlqUWhzaElWbXdBV0F0c0FRc0l5RWpJU0Jrc1FWaVFpQ3dCaU5Dc1FFS1EwVmpzQXBEc0FCZ1JiQURLaUVnc0FaRElJb2dpckFCSzdFd0JTV0tVVmhnVUJ0aFVsbFlJMWtoSUxCQVUxaXdBU3NiSWJCQVdTT3dBRkJZWlZrdHNBVXNzQWRESzdJQUFnQkRZRUl0c0FZc3NBY2pRaU1nc0FBalFtR3dBbUptc0FGanNBRmdzQVVxTGJBSExDQWdSU0N3QzBOanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ1JMQUJZQzJ3Q0N5eUJ3c0FRMFZDS2lHeUFBRUFRMkJDTGJBSkxMQUFReU5Fc2dBQkFFTmdRaTJ3Q2l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtJTEFnVUZnaHNBQWJzREJRV0xBZ0c3QkFXVmtqc0FCUVdHVlpzQU1sSTJGRVJMQUJZQzJ3Q3l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtzQ1JRV0xBQUc3QkFXU093QUZCWVpWbXdBeVVqWVVSRXNBRmdMYkFNTENDd0FDTkNzZ3NLQTBWWUlSc2pJVmtxSVMyd0RTeXhBZ0pGc0dSaFJDMndEaXl3QVdBZ0lMQU1RMHF3QUZCWUlMQU1JMEpac0ExRFNyQUFVbGdnc0EwalFsa3RzQThzSUxBUVltYXdBV01ndUFRQVk0b2pZYkFPUTJBZ2ltQWdzQTRqUWlNdHNCQXNTMVJZc1FSa1JGa2tzQTFsSTNndHNCRXNTMUZZUzFOWXNRUmtSRmtiSVZra3NCTmxJM2d0c0JJc3NRQVBRMVZZc1E4UFE3QUJZVUt3RHl0WnNBQkRzQUlsUXJFTUFpVkNzUTBDSlVLd0FSWWpJTEFESlZCWXNRRUFRMkN3QkNWQ2lvb2dpaU5oc0E0cUlTT3dBV0VnaWlOaHNBNHFJUnV4QVFCRFlMQUNKVUt3QWlWaHNBNHFJVm13REVOSHNBMURSMkN3QW1JZ3NBQlFXTEJBWUZsbXNBRmpJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDeEFBQVRJMFN3QVVPd0FENnlBUUVCUTJCQ0xiQVRMQUN4QUFKRlZGaXdEeU5DSUVXd0N5TkNzQW9qc0FCZ1FpQmdzQUZodFJBUUFRQU9BRUpDaW1DeEVnWXJzSElyR3lKWkxiQVVMTEVBRXlzdHNCVXNzUUVUS3kyd0ZpeXhBaE1yTGJBWExMRURFeXN0c0Jnc3NRUVRLeTJ3R1N5eEJSTXJMYkFhTExFR0V5c3RzQnNzc1FjVEt5MndIQ3l4Q0JNckxiQWRMTEVKRXlzdHNCNHNBTEFOSzdFQUFrVlVXTEFQSTBJZ1JiQUxJMEt3Q2lPd0FHQkNJR0N3QVdHMUVCQUJBQTRBUWtLS1lMRVNCaXV3Y2lzYklsa3RzQjhzc1FBZUt5MndJQ3l4QVI0ckxiQWhMTEVDSGlzdHNDSXNzUU1lS3kyd0l5eXhCQjRyTGJBa0xMRUZIaXN0c0NVc3NRWWVLeTJ3Sml5eEJ4NHJMYkFuTExFSUhpc3RzQ2dzc1FrZUt5MndLU3dnUExBQllDMndLaXdnWUxBUVlDQkRJN0FCWUVPd0FpVmhzQUZnc0NrcUlTMndLeXl3S2l1d0tpb3RzQ3dzSUNCSElDQ3dDME5qdUFRQVlpQ3dBRkJZc0VCZ1dXYXdBV05nSTJFNEl5Q0tWVmdnUnlBZ3NBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZQ05oT0JzaFdTMndMU3dBc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0xpd0FzQTByc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0x5d2dOYkFCWUMyd01Dd0FzQUZGWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqc0FFcnNBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpzQUVyc0FBV3RBQUFBQUFBUkQ0ak9MRXZBUlVxTGJBeExDQThJRWNnc0F0RFk3Z0VBR0lnc0FCUVdMQkFZRmxtc0FGallMQUFRMkU0TGJBeUxDNFhQQzJ3TXl3Z1BDQkhJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDd0FFTmhzQUZEWXpndHNEUXNzUUlBRmlVZ0xpQkhzQUFqUXJBQ0pVbUtpa2NqUnlOaElGaGlHeUZac0FFalFySXpBUUVWRkNvdHNEVXNzQUFXc0FRbHNBUWxSeU5ISTJHd0NVTXJaWW91SXlBZ1BJbzRMYkEyTExBQUZyQUVKYkFFSlNBdVJ5TkhJMkVnc0FRalFyQUpReXNnc0dCUVdDQ3dRRkZZc3dJZ0F5QWJzd0ltQXhwWlFrSWpJTEFJUXlDS0kwY2pSeU5oSTBaZ3NBUkRzQUppSUxBQVVGaXdRR0JaWnJBQlkyQWdzQUVySUlxS1lTQ3dBa05nWkNPd0EwTmhaRkJZc0FKRFlSdXdBME5nV2JBREpiQUNZaUN3QUZCWXNFQmdXV2F3QVdOaEl5QWdzQVFtSTBaaE9Cc2pzQWhEUnJBQ0piQUlRMGNqUnlOaFlDQ3dCRU93QW1JZ3NBQlFXTEJBWUZsbXNBRmpZQ01nc0FFckk3QUVRMkN3QVN1d0JTVmhzQVVsc0FKaUlMQUFVRml3UUdCWlpyQUJZN0FFSm1FZ3NBUWxZR1Fqc0FNbFlHUlFXQ0ViSXlGWkl5QWdzQVFtSTBaaE9Ga3RzRGNzc0FBV0lDQWdzQVVtSUM1SEkwY2pZU004T0Myd09DeXdBQllnc0FnalFpQWdJRVlqUjdBQkt5TmhPQzJ3T1N5d0FCYXdBeVd3QWlWSEkwY2pZYkFBVkZndUlEd2pJUnV3QWlXd0FpVkhJMGNqWVNDd0JTV3dCQ1ZISTBjalliQUdKYkFGSlVtd0FpVmh1UWdBQ0FCall5TWdXR0liSVZsanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ0l5NGpJQ0E4aWpnaklWa3RzRG9zc0FBV0lMQUlReUF1UnlOSEkyRWdZTEFnWUdhd0FtSWdzQUJRV0xCQVlGbG1zQUZqSXlBZ1BJbzRMYkE3TENNZ0xrYXdBaVZHVWxnZ1BGa3VzU3NCRkNzdHNEd3NJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UFN3aklDNUdzQUlsUmxKWUlEeFpJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UGl5d05Tc2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJMYkEvTExBMks0b2dJRHl3QkNOQ2lqZ2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJzQVJETHJBckt5MndRQ3l3QUJhd0JDV3dCQ1lnTGtjalJ5TmhzQWxES3lNZ1BDQXVJeml4S3dFVUt5MndRU3l4Q0FRbFFyQUFGckFFSmJBRUpTQXVSeU5ISTJFZ3NBUWpRckFKUXlzZ3NHQlFXQ0N3UUZGWXN3SWdBeUFic3dJbUF4cFpRa0lqSUVld0JFT3dBbUlnc0FCUVdMQkFZRmxtc0FGallDQ3dBU3NnaW9waElMQUNRMkJrSTdBRFEyRmtVRml3QWtOaEc3QURRMkJac0FNbHNBSmlJTEFBVUZpd1FHQlpackFCWTJHd0FpVkdZVGdqSUR3ak9Cc2hJQ0JHSTBld0FTc2pZVGdoV2JFckFSUXJMYkJDTExBMUt5NnhLd0VVS3kyd1F5eXdOaXNoSXlBZ1BMQUVJMElqT0xFckFSUXJzQVJETHJBckt5MndSQ3l3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckF4S2kyd1JTeXdBQlVnUjdBQUkwS3lBQUVCRlJRVExyQXhLaTJ3Uml5eEFBRVVFN0F5S2kyd1J5eXdOQ290c0Vnc3NBQVdSU01nTGlCR2lpTmhPTEVyQVJRckxiQkpMTEFJSTBLd1NDc3RzRW9zc2dBQVFTc3RzRXNzc2dBQlFTc3RzRXdzc2dFQVFTc3RzRTBzc2dFQlFTc3RzRTRzc2dBQVFpc3RzRThzc2dBQlFpc3RzRkFzc2dFQVFpc3RzRkVzc2dFQlFpc3RzRklzc2dBQVBpc3RzRk1zc2dBQlBpc3RzRlFzc2dFQVBpc3RzRlVzc2dFQlBpc3RzRllzc2dBQVFDc3RzRmNzc2dBQlFDc3RzRmdzc2dFQVFDc3RzRmtzc2dFQlFDc3RzRm9zc2dBQVF5c3RzRnNzc2dBQlF5c3RzRndzc2dFQVF5c3RzRjBzc2dFQlF5c3RzRjRzc2dBQVB5c3RzRjhzc2dBQlB5c3RzR0Fzc2dFQVB5c3RzR0Vzc2dFQlB5c3RzR0lzc0RjckxyRXJBUlFyTGJCakxMQTNLN0E3S3kyd1pDeXdOeXV3UENzdHNHVXNzQUFXc0RjcnNEMHJMYkJtTExBNEt5NnhLd0VVS3kyd1p5eXdPQ3V3T3lzdHNHZ3NzRGdyc0R3ckxiQnBMTEE0SzdBOUt5MndhaXl3T1NzdXNTc0JGQ3N0c0dzc3NEa3JzRHNyTGJCc0xMQTVLN0E4S3kyd2JTeXdPU3V3UFNzdHNHNHNzRG9yTHJFckFSUXJMYkJ2TExBNks3QTdLeTJ3Y0N5d09pdXdQQ3N0c0hFc3NEb3JzRDByTGJCeUxMTUpCQUlEUlZnaEd5TWhXVUlyc0FobHNBTWtVSGl3QVJVd0xRQkx1QURJVWxpeEFRR09XYkFCdVFnQUNBQmpjTEVBQlVLeEFBQXFzUUFGUXJFQUNDcXhBQVZDc1FBSUtyRUFCVUs1QUFBQUNTcXhBQVZDdVFBQUFBa3FzUU1BUkxFa0FZaFJXTEJBaUZpeEEyUkVzU1lCaUZGWXVnaUFBQUVFUUloalZGaXhBd0JFV1ZsWldiRUFEQ3E0QWYrRnNBU05zUUlBUkFBPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuZW90XG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5lb3Rcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsVDFSVVR3QUtBSUFBQXdBZ1EwWkdJRjNOUW9vQUFBVlFBQUJKRmtaR1ZFMXI4QUdrQUFCUjZBQUFBQnhQVXk4eU5BWlJnZ0FBQVJBQUFBQmdZMjFoY0FBTjQ0UUFBQVBzQUFBQlFtaGxZV1FCODd0RkFBQUFyQUFBQURab2FHVmhCb3dEL3dBQUFPUUFBQUFrYUcxMGVKb0VBQUFBQUU1b0FBQURmbTFoZUhBQTRGQUFBQUFCQ0FBQUFBWnVZVzFsanZZUXhRQUFBWEFBQUFKOGNHOXpkUCtHQURJQUFBVXdBQUFBSUFBQkFBQUFBUm1aUVRCak5sOFBQUFVBQ3dNZ0FBQUFBTS9aTDJvQUFBQUF6OWt2YWdBQS81c0RJZ01nQUFBQUNBQUNBQUFBQUFBQUFBRUFBQU1nLzVzQVNBT0VBQUFBQUFNaUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFEZkFBQlFBQURnQUFBQUJBTCtBWkFBQlFBQUFnZ0NNQUFBQUhBQ0NBSXdBQUFCZ0FBbkFNOEFBQUlBQlFNQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFVR1pGWkFEQTRBRGczZ01nQUFBQVNBTWdBR1VBQUFBQkFBQUFBQUFBQUFBQUlBQWdBQUVBQUFBT0FLNEFBUUFBQUFBQUFBQkNBSVlBQVFBQUFBQUFBUUFGQU5VQUFRQUFBQUFBQWdBR0FPa0FBUUFBQUFBQUF3QWtBVG9BQVFBQUFBQUFCQUFKQVhNQUFRQUFBQUFBQlFBT0Fac0FBUUFBQUFBQUJnQUxBY0lBQXdBQkJBa0FBQUNFQUFBQUF3QUJCQWtBQVFBS0FNa0FBd0FCQkFrQUFnQU1BTnNBQXdBQkJBa0FBd0JJQVBBQUF3QUJCQWtBQkFBU0FWOEFBd0FCQkFrQUJRQWNBWDBBQXdBQkJBa0FCZ0FXQWFvQVF3QnlBR1VBWVFCMEFHVUFaQUFnQUdJQWVRQWdBRkFBTGdCS0FDNEFJQUJQQUc0QWJ3QnlBR2tBSUFCM0FHa0FkQUJvQUNBQVJnQnZBRzRBZEFCR0FHOEFjZ0JuQUdVQUlBQXlBQzRBTUFBZ0FDZ0FhQUIwQUhRQWNBQTZBQzhBTHdCbUFHOEFiZ0IwQUdZQWJ3QnlBR2NBWlFBdUFITUFaZ0F1QUc0QVpRQjBBQ2tBQUVOeVpXRjBaV1FnWW5rZ1VDNUtMaUJQYm05eWFTQjNhWFJvSUVadmJuUkdiM0puWlNBeUxqQWdLR2gwZEhBNkx5OW1iMjUwWm05eVoyVXVjMll1Ym1WMEtRQUFTUUJqQUc4QWJnQnpBQUJKWTI5dWN3QUFhUUJqQUc4QWJnQnBBR01BQUdsamIyNXBZd0FBUmdCdkFHNEFkQUJHQUc4QWNnQm5BR1VBSUFBeUFDNEFNQUFnQURvQUlBQlZBRzRBZEFCcEFIUUFiQUJsQUdRQU1RQWdBRG9BSUFBeEFDMEFOd0F0QURJQU1BQXhBRFFBQUVadmJuUkdiM0puWlNBeUxqQWdPaUJWYm5ScGRHeGxaREVnT2lBeExUY3RNakF4TkFBQVZRQnVBSFFBYVFCMEFHd0FaUUJrQURFQUFGVnVkR2wwYkdWa01RQUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F4QUM0QU1RQWdBQUJXWlhKemFXOXVJREV1TVM0eElBQUFid0J3QUdVQWJnQXRBR2tBWXdCdkFHNEFhUUJqQUFCdmNHVnVMV2xqYjI1cFl3QUFBQUFEQUFBQUF3QUFBQndBQVFBQUFBQUFQQUFEQUFFQUFBQWNBQVFBSUFBQUFBUUFCQUFCQUFEZzN2Ly9BQURnQVAvL0lBRUFBUUFBQUFBQUFBRUdBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd0FBQUFBQUFQK0RBRElBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUJBUUFBUUVCREc5d1pXNHRhV052Ym1sakFBRUNBQUVBT3ZqekFQajBBZmoxQXZqMkEvZ1ZCQjRLQUJKZmk0c2VDZ0FTWDR1TERBZUtKdm0yK2JVRkhBUU5EeHdBQUJBY0Jjd1JIQUF1SEVWV0VnRGNBZ0FCQUFFQUFnQURBQVFBQlFBR0FBY0FDQUFKQUFvQURBQU9BQkFBRWdBVUFCWUFHQUFhQUJ3QUhnQWdBQ0lBSkFBbUFDZ0FLZ0FzQUM0QU1BQXlBRFFBTmdBNEFEb0FQQUErQUVBQVFnQkVBRVlBU0FCS0FFd0FUZ0JRQUZJQVZBQldBRmdBV2dCY0FGNEFZQUJpQUdRQVpnQm9BR29BYkFCdUFIQUFjZ0IwQUhZQWVBQjZBSHdBZmdDQUFJSUFoQUNHQUlnQWlnQ01BSTRBa0FDU0FKUUFsZ0NZQUpvQW5BQ2VBS0FBb2dDa0FLWUFxQUNxQUt3QXJnQ3dBTElBdEFDMkFMZ0F1Z0M4QUw0QXdBRENBTVFBeGdESUFNb0F6QURPQU5BQTBnRFVBTllBMkFEYUFOd0EzZ0RnQU9JQTVBRG1BT2dBNmdEc0FPNEE4QUR5QVBRQTlnRDRBUG9BL0FEK0FRQUJBZ0VFQVFZQkNBRUtBUXdCRGdFUUFSSUJGQUVXQVJnQkdnRWNBUjRCSUFFaUFTUUJKZ0VvQVNvQkxBRXVBVEFCTWdFMEFUWUJPQUU2QVR3QlBnRkFBVUlCUkFGR0FVZ0JTZ0ZNQVU0QlVBRlNBVlFCVmdGWUFWb0JYQUZlQVdBQllnRmtBV1lCYUFGcUFXd0JiZ0Z3QVhJQmRBRjJBWGdCZWdGOEFYNEJnQUdDQVlRQmhnR0lBWW9CakFHT0FaQUJrZ0dVQVpZQm1BR2FBWndCbmdHZ0FhSUJwQUdtQWFzQjdRSDJBZnN4TWpNME5UWTNPRGt4TURFeE1USXhNekUwTVRVeE5qRTNNVGd4T1RGaE1XSXhZekZrTVdVeFpqSXdNakV5TWpJek1qUXlOVEkyTWpjeU9ESTVNbUV5WWpKak1tUXlaVEptTXpBek1UTXlNek16TkRNMU16WXpOek00TXprellUTmlNMk16WkRObE0yWTBNRFF4TkRJME16UTBORFUwTmpRM05EZzBPVFJoTkdJMFl6UmtOR1UwWmpVd05URTFNalV6TlRRMU5UVTJOVGMxT0RVNU5XRTFZalZqTldRMVpUVm1OakEyTVRZeU5qTTJORFkxTmpZMk56WTROamsyWVRaaU5tTTJaRFpsTm1ZM01EY3hOekkzTXpjME56VTNOamMzTnpnM09UZGhOMkkzWXpka04yVTNaamd3T0RFNE1qZ3pPRFE0TlRnMk9EYzRPRGc1T0dFNFlqaGpPR1E0WlRobU9UQTVNVGt5T1RNNU5EazFPVFk1TnprNE9UazVZVGxpT1dNNVpEbGxPV1poTUdFeFlUSmhNMkUwWVRWaE5tRTNZVGhoT1dGaFlXSmhZMkZrWVdaaU1HSXhZakppTTJJMFlqVmlObUkzWWpoaU9XSmhZbUppWTJKa1ltVmlabU13WXpGak1tTXpZelJqTldNMll6ZGpPR001WTJGalltTmpZMlJqWldObVpEQmtNV1F5WkROa05HUTFaRFprTjJRNFpEbGtZV1JpWkdOa1pHUmxNUzR4TGpGRGNtVmhkR1ZrSUdKNUlGQXVTaTRnVDI1dmNta2dkMmwwYUNCR2IyNTBSbTl5WjJVZ01pNHdJQ2hvZEhSd09pOHZabTl1ZEdadmNtZGxMbk5tTG01bGRDbFZiblJwZEd4bFpERkpZMjl1Y3dBQUFBR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBRUlBUXdCRUFFVUFSZ0JIQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBYmdCdVFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQWNjQnlBSEpBY29CeXdITUFjMEJ6Z0hQQWRBQjBRSFNBZE1CMUFIVkFkWUIxd0hZQWRrQjJnSGJBZHdCM1FIZUFkOEI0QUhoQWVJQjR3SGtBZVVCNWdIbkFlZ0I2UUhxQWVzQjdBSHRBZTRCN3dId0FmRUI4Z0h6QWZRQjlRSDJBZmNCK0FINUFmb0Ird0g4QWYwQi9nSC9BZ0FDQVFJQ0FnTUNCQUlGQWdZQ0J3SUlBZ2tDQ2dJTEFnd0NEUUlPQWc4Q0VBSVJBaElDRXdJVUFoVUNGZ0lYQWhnQ0dRSWFBaHNDSEFJZEFoNENId0lnQWlFQ0lnSWpBaVFDSlFJbUFpY0NLQUlwQWlvQ0t3SXNBaTBDTGdDUUFpOENNQUl4QWpJQ013STBBalVDTmdJM0FqZ0NPUUk2QWpzQ1BBSTlBajRDUHdKQUFrRUNRZ0pEQWtRQ1JRSkdBa2NDU0FKSkFrb0NTd0pNQWswQ1RnSlBBbEFDVVFKU0FsTUNWQUpWQWxZQ1Z3SllBbGtDV2dKYkFsd0NYUUplQU9BQ0FBRUFJd0JNQUhzQXZBRDhBU0FCUkFGb0FkOENBUUl0QWxNQ2ZRS21Bc1FDM1FNQUF5QURPd05lQTM4RHJRUklCSGdFeHdUM0JWMEZwd1hUQm5FR3RRY0FCM0FIakFmVUIrOElGd2lQQ1JjSmhRbmNDdkVMVEF1ekRCRU10QXpCRE5RTTVBenlEV3NObmczS0RlVU9CQTRqRGo0T1hnNTFEdFFQRGcrV0Qvc1FCeEE5RUhNUTd4RVJFVFFSVmhGMkVpa1NXQktFRXF3UzNSTXBFMjRVQWhRckZGVVVjQlRORlJBVnFCVzdGZElXRkJaSkZxSVd1aGJhRnZrWEd4ZGRGK2dZS1JoTEdHMFlrQml3R09nWlNobTlHZHNhTGhwU0duNGF0UnRIRzFZYlp4d1dIRDBjdWh6OEhTTWRnUjN0SG1JZWxoN0ZIdmdmUFIreElEUWdheUNQSUxNZzF5RXhJWVloclNLWkk0a2tmU1M1SlBVbENTVkhKWUlsenlZWkptQW01U2NiSjVJbnBpZXpKK01uL1NnVktDb29SU2haS0lJb255bFJLVndwdVNuOEtsRXFvQ3NzSzFBcjl5eE1MSmdzOVMxTkxXb3RreTM3TGs4dWpDN3RMNGt2K0RENE1XNHh6ekg2TWljeVVUS2pNd2N6YlRPK00razBVelNITk1rMCtqVXJOWWcxc1RZY05tODJrVGJJTnY4M096ZUdOOGs0SHppQ09SYzVTam01T2ZvNkpqck5Pdlk3S3p1Sk82RTdzVHY0UEdFODBqMGNQV3c5blQzR0xvdXorRm16QWJPejk0U3pBN01XOTlUNHFmdlVCclA4Z1JYNFdmZUUvRmtIRG92djkxenY5MXp2QWZsUTd3TVU0UGZBK1ZBVklBcjhKUHRjRlNmOEpDZjRKQ2NIOTF6M0tnVU9pKy8zWE8vM1hPOEIrVkR2QXhUZzk4RDVVQlVnQ3Z6cysxd1YrMXo3S3ZkYyt5cUw3L2draTR2di9DU0xCUTc0N084QitJajNYQVAzOHZsUUZmdFYrekg3TWZ0Vjl4NzNCUGNFOXg3M0h2Y0Urd1Q3SGg5Wkp3ZjNYUHRjOTF6M1hDZUxpNzBGOTFYN01mY3grMVVlRHZqczd3SHY5MXdEK0ZiNVVCWDdWZnN4K3pIN1ZSOVpKd2YzWFB0YzkxejNYQ2VMaTcwRjl4NzNCUGNFOXg3M0h2Y0Urd1Q3SHZkVit6SDNNZnRWSGc2TDcrL3Y3Ky92N3dINVVBUWhDdjFRKzF3VklncjlVUHRjRlNFSy9WRDdYQlVpQ2c2TDcrL3Y3Ky92N3dINVVBUWhDdjIwKzF3Vklncjg3UHRjRlNFSy9iVDdYQlVpQ2c2TDcrL3Y3Ky92N3dINVVBUWhDdnpzKzF3Vklncjl0UHRjRlNFSy9PejdYQlVpQ2c2TCtiUUQrQ1Q1VUJWR2kwcDRVbXdJOTliN2Z0YjNkUVZQcjBTaVFJc0krNmY3QkJVL1Fsb21pL3NHaTNLTmRJOXpDUGZLOTNJRitBajNFUlg3RHZ3TDkyNkxCWk9yazZ5THJvdjJZT3RHMHdqOGJQdldGZnREK3hFRnd2c0Y4elgzRkhRSXQvZFdGY243V1FYM0daZjNCZGZMOXdFSUR2YWdkZ0gzWE84RDkxejV0Qlg4aVB0Y0IvZVIrOEQzaS9mQSsxeUxpL2lJQlE2Z2R2bFE3d0dMOThEM1hQZkFBL2drK2JRVkl3b25KeFgzWFB2QTkxd0crOEQ3d1B2QTk4RDNYSXNGRG92M3dQZGM5OEFCK1ZEdkEvZ2srYlFWSXdvbkJQdGM5OEQ3WFB2QSsxd0grOEQzd0FVT2kvZkE5MXozd0FHTDd3UDRKUG0wRlNNS0p3VDN3UHZBKzhEN3dJdjNYUHZBaTR2M1hQZkFpd1VPaSs4QmkvZkE5MXozd0FQNEpQbTBGU01LSndUM3dQdkErMXlMaS92QSsxeUxpL2ZBKzF5TEJRNzN3TzhCOThENDdCWDd3UHVSOThEN2k0djNYUGlJaTR2di9JaUxCUTczd084QitJajQ3Qlg3WFB5SUovaUkrMXdIOThEM2tRVU85cUIyQWZkYzkxd0Q5MXo1dEJYOGlQdGNCL2ZEKzhEM3ZmZkErMXlMaS9pSUJRNzN3UGRjQWZmQStWQVYrOEQ3dy9mQSs3Mkw5MXo0aUl1TDkxejhpSXNGRHZmQTkxd0IrSWo1VUJYN1hQeUkrMXo0aVB0Y0IvZkE5OE1GRHZhZ2RnSDNYUGRjQS9lOStiUVYrNzM3d1BkY2k0djhpUGRjaTR2NGlQZGNpd1VPOXFCMkFmZGM3d1AzaS9tMEZmdUwrOEQzWEl1TC9JanZpNHY0aVBkY2l3VU9vSFlCaSsvdjcrL3Y3KzhEK0NUNXRCVWtDdnZBSnhYODdPLzQ3QWYzd0NjVkpRcjlVQ2NWKzF6djkxd0hEb3Z2NysvM1hPL3Y3d1AzQ1Bqc0ZVTkRYeWlMK3dLTCt3SzNKTk5EQ05QVEJWWEJhZGVMM292ZXJkUEJ3UWo0aE5NVlEwTUZ3Vld0UTRzNGl6aHBQMVZWQ05OREJkUFR0L0tMOXdLTDl3SmY3a1BUQ1B3OSt5QVZaMmQwV1l0VWkxU2lWcTluQ05EVEJYbWRnYVdMcDR1bmxhS2RuUWozYWRJVlJrUUZuWG1WZEl0dmkyK0JjWGw1Q05CREJhK3Zvc0NMd292Q2RMeG5yd2dPTHFCMitDVDRKQUdMK0NRRDkxejV0QlVtQ2lmOGRSV0wrOVB2Nys4bmkvZlRCV3VBYW9Ob2kyaUxhWk5zbGdnT2krLzQ3TzhCaSsvNDdPOEQrQ1Q1dEJVbkNpY0V6WXZIZHJ4b0NQdzMvRGNGYUx4Mng0dk5pL2M2OXhyM0d2YzZpd2ozaVBzUkZhNWFvRStMU1l2N092c2EreHI3T290SmkwK2dXcTRJRG92dkFZdnY3L2RjNy9kY0EvbFFCUDFRK2JUdi9WRDQ3QWY0SkJiOGlQZGMrSWdIL0lqN1hCWDd3UGRjOThBSERvdnY5OER2QWUvdjcvZGM3KzhERkRqNElmbTBGWDZLZm9TQ2dBajdmdnV0K3hTTGl5ZnZpNHY4QWdWNW0zdWRIdmlvQnAyYm01MGYrQUx2Ny9zVUIzQ3MrMmoza0ltTmdKU0JrSDZLQ0k3N0ZCWDNKUHRBKzdTTEJZWDdYQlVvQ3ZmQUZpZ0tEdS92K0NUdkVvdnYrSWozWFB0Yzd4UG9sUGxRRllXSWlJVWYvTm9IaFk2SWtSNzVQZ2FSam82UkgvZFRCeFB3Ny9kY0JoUG9KL2RTQnBHSWo0VWUvT01uRmZpSS9DVDhpQVlPNy9qc0FaVDVVQldGaUlpRkgvemFCNFdPaUpFZStUNEdrWTZPa1IvM1UrLzNYQ2YzVWdlUmlJK0ZIZzRuOThENEpPOEI5MXp2OTF6dkErZjVIaFZ2b1hTbkhvMkxqNHlOaXdpOSt5RUdnbnI3QS90cVhUMTdjWGxwaTEyTFpKcGxwWEdsY2JGOHNvc0krSlFHc1l1dm02V2tDSTRHcGFXYXNZdXlpN2g1cm51bFhkbjdBL2RxZ3B3STl5RzlCNmVob2FlbmRhRnZIL3lJaTRhTGhvdUlpd1Z4ZUhCMEgvZ3NXUldMK3phUmdRV0xpOHI3RDhNaUNQeFdCc1AweXZjUGk0c0lrWldMOXpZRkRvdnY3L2pzQWZnaytiUVYrd0l4TWZzQ0g0c2pWeTA1UjJKcGNsdUxWd2o1dEFhTHYzSzdZcTA1ejFmcGkvTUk5d0l4NWZzQ0hpZjlVQlZVdUY3Q3dyaTR3aDRPOXFCMkFmY3E3d1AzS3ZtMEZZdjdqa0RXUUVEM0t2c3EreXI3S3RaQTF0YUwrNDY5aS9meTk0NzdkZmN0OTNYM0ovdnk5NDRGdmZzcUZmY3FKL3NxSndVbkJQY3FKL3NxSndVT2krLzN3Ty8zWE84UzcvZGM5MXozWENmM1hCUDArYlFFSndmQ3VGNVVIL3drQjFSZVhsUWVKL2k2Qi9jZTl3VDNCUGNlSDR2dlVPQTJzd2dUK0thdG5MZUx1Z2ozQWpIbCt3SWUrMXduRmU4R3dyaGVWRlJlWGxRZkp3WW5CUGNxQmhQMDNzNUlPRGhJU0RnZit5b0dEdmFnZGdIM3dQbTBGZnZBL0lqM1hJdUwrOEQzd1BpSSsxeUxCUTZMN3dHTDcvaUk3d1B2K2JRVmVJZ0ZaSU5zYklOa0NJaDRpL3k2QlRqT1NONGUrTHJ2L0xvR2IzV2hwNmVob2FjZitMcjR1Z2FuZGFGdkhsbjd3QVluN3ljbmkvZkFCUTR1b0hZQmkvZ2tBL20wQkl2OXRQZGM5MXozWFB0Y2kvbTBCUTc1VU84QitiUUVJUXI5dFB0Y0ZmempCNFdPaUpFZSthSUdrWTZPa1IvNDQvdTlKUHRmOGdjT2kvZGM3L2ZBNys4QjkxenY5MXp2QS9mQStiUVZWRjVlVkI4bisxTUhoWWlJaFIvN2hRZHZvWFduSHZsUUJxZWhvYWNmOTRVSGtZaU9oUjc3VSs4R3dsNjRWQjc3WENjVjkxd24rMXdHKzhEOEd4WDdYQWVGam9pUkh2bWlCcEdPanBFZjkxd0hlNFY3aUhtTENQMVFCbm1MZTQ1N2tRZ085b3Z2OTF6djk4RHZFdS92UGUvM1J1OFQ5UGZBK2JRVlRZdFZjV2xnYVdGN1U0dFJpMGFjVTVOWkNQc1JKd1lUN1BjT0JvQmVjVmRHUmdoN2Y0djdEdmpzaTR2di9IK0xCY3ZVcnM2Wnh3ajNSdS83UUFZVDlJUFBkOE9Mdm91eWxxMmNvSnlnbjVXdWk3S0xvWUNaZlpsOWxuV0xaQWp2Qm92RmU3OW1zQWhtc0ZlYlVZc0lEaWZ2K0NUdjcrOEJpKy92Ny9nazd3T3QrVkFWZUlWOGRZdDNDSXVKaS8xUUJXK2hkYWNlK1ZBR3A2R2hweC81VUFlbmRhRnZIdjFRaTRhTGg0dUlpd1gzQkNjVktRcjNYQmIzd0Fhbm9YVnZiM1YxYngvN3dBWnZkYUducDZHaHB4LzdqdnRjRmZqcy9DVDg3QVlPb0hZQjl4cjNuZ1A1ZlBteEZZV0kvQXY3bm41OGYzSUYwM1RDVktKRENLU1htcGozbnZnTEJZNlBqSStIandoZnR3WDhlUHdlRlVGUlQwRWZpeWhWTkR0ZHNuVzZmN3VMQ1Bjbjl3djNDL2NuMVUvSFFSOE9odTcxN3dINExmZkFBNVQ0VnhXTGVaZDNtNFFJOXdoVEJZSjdnWHFGZWdoR2k0YUxCVzkxYzNGdm9YV25INUNMdllzRmkzU05kWTkyQ0QxakJYYUdlM1NMZG90dm9YV25pNVdMbUpDVGtRak5yZ1dqWGJGa3RIS3VucU9raTZjSWkvY2tpNUNMajR2ZEJZeU9pNUNMam91T2k1Q0tqcENpb0p5aml3aW5vWFZ2SDRzMGk0YUxob3VGaTRhTGg0djdHd1dMY0tSeHJuaTBvN0d6bzdrSXpHZ0ZrNFdZaHBXTHA0dWhvWXVuaTZCN29uYVFDRDJ6QlkrZ2phR0xvZ2k5QnFlaG9hZW5kYUZ2SDBjR2haeUJuSUtiQ1BjSHd3V2FrNWVmaTV5THAzV2hiNHVDaTRXSWhZY0kreGRKYjZFRjJkNDk5enY3QzR2N0M0czkrejNhT2dodWRmc1h6UVdFajRDT2c0dHdpM2h3aTNRSUR2anM3d1A0N1BsUUZmenM1Z2VSam82UkgvamFCNUdJam9VZS9IWDdXUlY0aVB0S2l3V0ZpSWlGSC90S0I0V09pSkVlNW92eSs2UUZsbktzZ0tTV3BKYVdySUNrQ0VEM1JnV09tWldUbW9zSWk0NzNqdnNSaS9pSUJRNkw3Ky92NysvM1hPOEJpKy92NysvdjcrOERsUG0wRllXSWlJVWYvYUlIaFk2SWtSNzVQZ2FSam82UkgvbWlCNUdJam9VZS9PTW5GZmlJKzF6OGlBWW5CTzhuSndiM1hPOFY3eWNuQnZkYzd4WHYrOEFuQnZ3azd4WHZKeWNHOTF6dkZlOG5Kd1lPaSsvdjcrL3Y3L2RjQVl2djcrL3Y3Ky92QS9tMEJQdGMrVkQzWEFmOVVQdkFGZngvQjRXT2lKRWUrVDRHa1k2T2tSLzRmd2Y4N0NjVjd5Y25CdmRjN3hYdkp5Y0c5MXp2RmU4bkp3YjhKQ2NWN3ljbkJ2ZGM3eFh2SnljR0RvdnY3L2RjNy9mQSs4RHZFb3Z2NysvdjkxenY3eFB2K0MzNXRCV0ZpNGVIaVlZSUxmdEtCUlBmaVlhSGg0V0xDUHNoQmpoSVNEZ2YvRTBIaFk2SWtSNzVvZ2FSam82UkgvamFCNUdJam9VZU9RYUZpNGVQaVpBSUxmZEtCUlB2aVpDSGo0V0xDQlBmL0UzN3dCV25vWFZ2YjNWMWIyOTFvYWNmcDZHaHB4NFQ3L2Z5RnZjQzVUSDdBdnNDTVRIN0F2c0NNZVgzQWgvM0F1WGw5d0llSndRcUNnNzQ3QVQ0SlB3aytDVDRKQVVPTHFCMkFmZ2srYlFWL0NUOEpQZ2svQ1FGRGk2Z2RnSDV0QVNML2JUNEpQZ2tCUTc0SlBqc0Zmd2svQ1Q1dElzRkRvdnY3L2ZBaSs4Uzk4anY5MXp2RTdqNHVnUnZvblNuSG8yTGpveU5pd2ozS291VmNnV21PS1kzcGpnSUU5aVBmcHQvbVlzSTkvSUdtWXVjbDQrWUNOejNqZ1VUdUkrWWhwZDlpd2dUMlB4UWkyWFRCUk80aEpwM21IcUxDUHRjaTRlTGhvdUlpd1Z4ZDNCMEgvZjYvRllWS3dyM3dCWXJDZzZnZHUvNEpPL3ZBWXYzWE8vNGlBUDVVQVNML0lqdjcrK0xpL2ZBOThDTGkrOEYrMXo3WEJYOEpQZ2tCKzhuaS9pSUJRNzVGZmxRRmZzRit3djdDdnNHK3dqN0NWZThXTDFadmdqN0lmc2gwMFFGMUVIV1E5SS9DUGlCK0lFRkR2Y3ErT3dWK3lyN0t2Z2svQ1Q0SlBnayt5cjNLdnVPKzQ0RkR2YWdkZ0g0SlBtMEZmd2svQ1Q0SlB3azl5cjNLdnVPOTQ3M2p2ZU9CUTcyb0hZQjl5cjV0Qlg3S3ZzcTk0NzdqdnVPKzQ3M0t2c3ErQ1Q0SkFVTytDVDQ3Qlg4SlB3azl5cjdLdmVPOTQ3M2p2dU85eXIzS2dVT2kvbTBBZmdrK2JRVkl3cjNYUHRHRmRORCs5YjcxdnRBOTBEVDArOG5CUTZMK2JRQmkvbTBBL2drK2JRVkl3cjdLdnRHRlN3S0RvdjRpTy92QVl2djkxenY5MXp2QXhRNDkvTDV0QlZ2ZFhWdkgxbEFCMzJBZ0gwZlFQZkExZ2VaZ0paOUhrQzlCcWQxb1c4ZSs5a25GWDJBZ0gwZi9SNEhmWmFBbVI3NUhnYVpscGFaSC9rZUI1bUFsbjBlUVB0Yy9JajNYQVlPaSsvNDdPOEJpKy8zanUvM2p1OERGRGo0SlBtMEZTY0tKd1F0Q2xrbkZZdjdjcHQvQmFodXAyNm1iUWpUMHdWeW9YT2lkS01JOTBrSERxQjIrSWozd0FHTDk4RHY3Ky8zWEFQNFZ2bTBGZnNOaXlFMWRQc0crd0tMTVRHTCt3S0xacFpxbkcwSTk2UzlCdDdPenQ3ZXprZzRIbG4zVXdlUm00NmJpNTJMekdITFVhQUl2UWYzSHZzRTl3VDdIaDU3L0NRVmVJVjhkWXQzQ0l1Smkvc3EreXFMOTF6N1hQZGM5MXo3S291TDl5cUxqQVduZGFGdkhvaUxpSXFJaXdpSEJnNmdkZ0g0Sk84RCtGYjV0Qlg3RFlzaE5YVDdCdnNDaXpFeGkvc0NpMmFXYXB4dENQZHlpL2RjOTF6M1hQdGM5eUdMQlpHYmpwdUxuWXZNWWN0Um9BaTlCL2NlK3dUM0JQc2VIdnhXQlB1Tys0NzNYSXVMV1FWdm9YV25wNkdocHg2OTkxd0hEdS80N0FINFZ2bFFGUzRLRG92NDdBSDNqdm0wRmZzZSt3VDdCUHNlSDR0a2xHbWJhcW1oclpxdmxjTDNFUGNUNFBjamkxM0hRN001aXdqM1hQdGNGUzRLRHZpSStWQVYrOEQ4N08rTDk4RDQ3QVg4aUNjVkovdGM3L3RjNzRzbjkxenY5MXdGK0NRVzcvdGNKL3RjNzR2djkxd245MXdGRG92M2p2ZkE5NDRCaS9lTzk4RDNqZ1AzOHZtMEZWbjdDMjkvK3d1OVEwTzkrd3QvYi9zTFdZc245d3RabDI5Wit3dlRRL2NMdmFkL3Zmc0xCZStMdmZjTHA1ZjNDMW5UMDFuM0M1ZW45d3U5aSsvN0M3MS9wNzMzQzBQVCt3dFpiNWNGV2ZjTEJWbjdqaFhlemtnNE9FaElPRGhJenQ3ZXpzN2VIdzZMNy9pSTkxd0IrYlFFTHdyODdQdkFGZmRjKzF6M1hQZGNCZnpzL0NRVklRb09vSFlCaSsvNGlQZGNBL20wQkNRSytJZ1dNQXI3d1B0Y0ZmdGMrMXozWFB0Y0JRNmdkZ0dMOTF6NGlPOEQrYlFFTUFyNGlCWWtDdnlJKzF3Vmkvd2s5MXozWEFVT2kvZGMrSWp2QWZtMEJDRUsvQ1Q3d0JYN1hQdGMrQ1NMQmZ6c0p4VXZDZzZMNysvdjcrL3Y3d0dMNysvdjcrL3Y3d1AzS3ZsUUZUaElTRGc0emtqZUg3MG5XUVk0U0VnNE9NNUkzdDdPenQ0ZnZlOVpCempPU043ZXpzN2Uza2pPT0I1Wjc3MEczczdPM3Q1SXpqZzRTRWc0SDFrbnZRZmVTTTQ0SGljRXA2RjFieDlaV1FkdmRhR25wNkdocHgvNEpCYW5vWFZ2YjNWMWJ4OVp2UWFub2FHbkh2dU8rMXdWN3ljbkJ2c3FKeFc5V1FadmRYVnZiM1docDZlaG9hY2U5L0lXdlFhbm9YVnZiM1YxYjI5MW9hY2ZEcUIyOTF6NDdBR0wrYlFEK2FzRS9Ob0hoWTZJa1I3NDQ0djNYUHRjaS9tcUJaR0lqNFVlL2FJR2hvZUhoaDhPaSsvNDdPOEJpKy80N084RCtDVDV0QlVuQ2ljRUxRcjNYQ2NWKzhBbkovdkE5OER2QlNmM0toVXBDZzZMNy9qczd3R0wrQ1Qzd084RCtDVDV0QlVuQ2ljRTl6cjNHdnNhK3pyN092c2EreHI3T2g4T2krL3Y3L2RjNysvdkFmbFE3d1A1dEFRaEN2MjArMXdWSi9pSTd3ZjhpUHZBRlNFSy9iVDdYQlVpQ3ZjcUZpc0tEdS92Ny9kYzcrOEJpKy92N3dNVTRLVDVVQlY5Z0lCOUgwRDV0TllIbVlDV2ZSNzltL3RjRmZ3TEIzMldnSmtlK1lJR21aYVdtUi80Q3dmOVVQdGNGZThuSndiM1hPOFY3eWNuQmc2Z2R1L3YrQ1R2QWUvditDVHZBKy81dEJVbkp5ZnYvSWo0aUNmdjcrL3ZKL2hXQisvdldiMG5KL3hXaTR2dkJmdGNCUGZ5aS92eSsvSUYrQ1Qzd0JYNzh2dnlCdzZMNysvM1hJdnZpKy92N3hLTDcvZGM5MXo3S3UrOTcrL3ZFNnhBK0NUNXRCWDdjUHRJKzBqN2NQdHc5MGo3U1BkdzkzRDNTUGRJOTNBZjkzRDdTUGRJKzNBZUp3UXRDaE9kUUNjRU1RcjdYUHNvRll0L2tudVVnd2psTUFVVDNrQ0ZjZ1ZVdUY3Q3dyaTR3c0pldUZRZWNvVXc1UVdEbEh1U2Y0c0lnNHVJaTRpTEJYaUZmSFdMZHdnVHJNRDM4cnNWTVFvT2krOEI5OEQzWEFQM3dQbTBGZnZBKzF3SDk4RDd3UGZBOThEN1hJdUw5OEFGL0lqOVVCVWhDZzZnZHZsUTd3SDN3UGRjQS9tMEJDRUsvQ1Q3WEJYN3dQdkE5MXlMaS92QTkxeUxpL2ZBOTF5TEJRNzNYUGxRRmZ0Yys4RDNYUHZBK095TGkvanNCZnhXUFJVc0NnNzQ3TzhCaSsvditDVHY3d01VY1BnaytWQVYrM0Q3U1B0SSszQWY3d2IzT3ZjYTl4cjNPdmM2OXhyN0d2czZIdThHOTNEN1NQZEkrM0FlVVB0bEZUcHlUeitMTVFqN0F1VXg5d0wzQXVYbDl3SWVpK1ZQMXpxa0NGQXpCUTZMNysvM1hQdGM3Ky92RW92djcrOFRuUG0wQlAyMCtWRDRKQWNUelB3aytDUUc3eFlUblB2QTk4QUgvT3p2RmU4bkp3WW5CTzhHRTd3bkp3Y25CQlBNTWdvTzlvdnYrQ1R2QVl2djcrL3Y3d01VT1BkYytWQVZKMEFIUjFKU1J4OVpCNHRIdGxMTmV3ajNsVW9GbVllZmNvdDhDRmtIZllDQWZSNzdqZ1ovaTRLT2g0NEk2U2NuQjR0cG9HK2llNko3cDRXcGl3aldKKy92MWdiUHhNVFBINzBIaTg5Z3hFbWJDUHVWekFWOWozZWtpNW9JdlFlWmxwYVpIdmVPQnBlTGxJaVBpQWd0Nys4SGk2MTJwM1NiZEp0dmtXMkxDRUR2Qmc2TDk4RDNYUGZBQS9sUUJETUs5MXdXTXdvT2kvZkE5MXozd0FQM3dQbFFGVFFLK0lqNDdCVTBDZzd2OThEM1hPOFNpL2ZBKzhEditDVDN3UHZBN3hQZzk4RDVVQlUxQ2hQUSsxd0dFK0QzQStUazl3TWVFOGo0aU84Vk5Rb1R4UHRjQmhQSTl3UGs1UGNESGc3djcvZGM5OEFTaS9mQUorLzNYUGZBSis4VDRQbFFCUHZBQnhQUTkxd0dFK0EyQ2hQSTkxd1crOEFIRThUM1hBWVR5RFlLRHZaMTd3R0w3L2VPOTQ0RDk4RDV0QlZwYVFXQWdQdVQrNWVMKzI0SSt6bjNHL3NiOXpuM09mY2I5eHYzT1I2TDkyNzdrL2VYZ0pZSSswejhTaFdub1hWdlZMaGV3cWVoZFc5dmRYVnYrd0l4NWZjQ3A2R2hweDhPaS9kY0FmZ2srYlFWL0NUOGlQbTBpd1g5dENjVkx3b085cUIyQWZmQStiUVYrOEQ3d1Bqc2l3WDg3UHRjRmZmQSs4RDN3UGZBQlE3M3dQZGNBWXYzWE8vM1hPLzNYQU1VY1BpSUJEY0s3eFkzQ3U4V053b08rVkFFaXlmNEpQdGMrQ1QzWEl2dkJmMjArMXdWL0NUNXRQZ2tCL3drKzF3RkRxQjJBWXZ2K096dkEvZ2srYlFWL0NUN1hJdjg3UG0waTR2NDdBWDhKT01WOThEN0tvdjdVUHZBK3lyN3dQY3FpL2RRQmU5bEZZc245MXduOTF6dmkrOEZEaWZ2NysvdjcvZGM3d0gzWE84RCtPejVVQlg3VG92N0xmc1VYdnRBQ1B0VGkzSW45MXlMQll0cGsybVRhd2o3V1l0NEovZVVpd1hSK3dyM0V6bjNKNHZVaTgrZ3hxNEk5dzRIVmx0R2JUMkxNb3M5c2xUSUNQZHlpNXZ2KzcyTEJZQ3JnNnVMcndqMzRvdWI3L3ZmaXdXMDl3ajNBZC8zRjR2Tmk4ZDJ2R2dJbS9VRlVxcEtua2FMQ0E2TDcrL3Y3Ky92N3dHTDcrL3Y3KzhERkE3NVVBUW4rVkR2Qi8xUSsxd1ZKL2lJN3dmOGlQdGNGU0VLL2JUN1hCVW43KzhIN3hZbjcrOEg3eFluNys4SERvdjNYUGlJN3dINXRBUWhDdnpzKzF3VjkxejdYUGRjOTF3Ri9PejhKQlV2Q2c2Z2RnR0w3L2lJOTF3RCtiUUVKQXI0aUJZd0N2enMrMXdWaS93azkxejNYQVVPb0hZQmkvZGMrSWp2QS9tMEJEQUsrSWdXSkFyN1hQdGNGZnRjKzF6M1hQdGNCUTZMNy9pSTkxd0IrYlFFTHdyOEpQd2tGZnRjKzF6NEpJc0YvT3duRlNFS0RvdnYrT3p2QVl2ditPenZBL20wQlAyMCtiVDNYQ2NuL096NDdPL3ZCL2RjRnZjcSt5cjdqdnVPN3lmM2p2ZU85eXI3S292NEpBVU83Ky92Ny9kYzd3SDN3TzhEK0NmNVVCWDdrZnNxKzhDTGkvY3ErOEQza2ZlTDl5cjN3SXVMK3lyM3dQdUxINGduRlRnS0p3UlVYbDVVVkxoZXdzSzR1TUlmaTVXSWxJaVVnM3Q3ZjNlTGI0dDFvWXVuaTUrWG01dVRnbzZDam9HTENBNzRLL2ZmK1ZBVmVJVjdkWXQzaTMrU2U1U0RDTXBNL0F2OEVZdjdwUGVoaS9nUitCSEpTZ1dUZ0o2Q21JdW5pNkdoaTZlTG1JT2NnWk1JTHVuTXpRWEZ4WXZyVWNWU3hDbUxVbElJU1VvdDZBV0RsSHFUZjR1SWk0ZUxpSW9JaUFiM0JmdHZGZmNYK3hmNzBQdlEreFQzR0FVT2kvZ2tBWXYzd0FQNXRBVDl0UGxRK0NUOEpQZ2tCKzhXKzhEM3dBY09vSFlTaS9na0ovZ2tFOEQzWFBtMEZlLzdYUHZBSjR2N1hJdjdYUGRjSjR1TEtmZGE5Nzd4aS9kY0NQZGMrMXp2aXg3M3dQdkFGUk9nNy90Yys4QW5pL3RjQ1BmQUJyUEh2ZmNxOTF6N1hPK0xIdzZnZGdHTDd3UDV0QVFrQ3U4Vy9DVDNYQ2Y0SkFmN1hQZFo5MXozWC92QWk0dnZCUTR1b0hZQjl5cjV0Qlg3S3Z2QTkxeUxTZnRjK3hxTDcvdkE5OEQzd1BzcWkvY3E5OEQ3WEl2djkxd0ZEb3Y0aU8vM1hQdGM3eElUd1BtMEJQdGNCeE9nK2JUdi9JZ0dFOER2Qi92QSs4QVYvRllIYjZGMXB4NzVVQWFub2FHbkgvaFdCdzZnZHZmQTd4S0w5OEQ3WE8vM1hQZkErMXp2RStEM0t2bTBGVGhJU0RnZkU5Q0xTYlJVeG5jSSsyNEhFK1JRZDJKVWkwa0lPTTVJM3Q3T3p0NGVpOGRwdlZtamxKU1drcG1MQ1BkY0J0M1B6OTBmeGdjVHlNYWZ0TUtMelFqZVNNNDRPRWhJT0I0VDFJdEp0RlRHZHdoUUIyOTFkVzhlKzF3R2VvdDVoM3lHQ1BjS0J4UGd4cCswd292TkNONUl6amdlRHFCMkFmbTBCRGtLNy93a0ZUb0tEcUIyQWUvNXRCVTZDdmNxKzQ0Vk9Rb09pKy80N084QmkrOEQrQ1Q1dEJVakNpY0VyWXVwZ3FtQmRuZHplWTk1ajNuTWtJdG1pM0JoZ3FsdHJtZ29UWWxkaURmaWZ0Q0xDTFdMbG5lSWMxVStMMXNtaTJXTGFaUnBtS0czV2VKY3AzU2lXb0p2bG9LbWdxYUtxUWlPa0pDUWs0c0l4bWtGblk4dzl4SzFwWitYczFkK3duKyt1blNwbUtXV242bHFuUWgxbmdXNHByK2N3NHNJOTN2N0FSV2RkWnB6bG5FSWk0aDFkUVZ2YjRhOGdKVitsMTE5aFpxRW5jT2pzWllJRG92dkFmbFQrYlFWKzhQN3dDZnYrOEQ3dys4bjkxejNYKzhuK0NUNEpBWDl0UHpzRlNFS0RvdnY3Ky92NysvdkFZdnY3Ky92NysvdkEvbFFCQ2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3dmOVVQdGNGU2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3dmOVVQdGNGU2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3dmOVVQdGNGU2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3djT2kvZGM3L2RjNy9kY0FZdjNYTy8zWE8vM1hBTVUvUG0wQkRjSzd4WTNDdThXTndyOXRQdkFGVGNLN3hZM0N1OFdOd3I5dFB2QUZUY0s3eFkzQ3U4V053b09pL2ZBOTF6M3dBR0w5OEQzWFBmQUEvbTBCRHNLOTF3V093cjl0UHlJRlRzSzkxd1dPd29PaSsvdjcrLzRKQUg0N084RG52bTBGWUNEZzRBZis5OEhiNkYxcHg3NDdBYW5vYUduSC9mZkI1YURrNEFlL1QzOGZ4WDd0Z2VBazRPV0h2a3FCcGFUazVZZjk3WUhlNFY3aUhtTENQenNCbm1MZTQ1N2tRajR1dnNCRlNrS0RvdnY5MXp2OTF6dkFlL3Y5OER2QXhUZytWQUVKNzBIcDZGMWJ4LzhKQWR2ZFhWdkhsa245OER2V1FadmRhR25IL2NxOThEN0tnZHZkWFZ2SGxrbjk4RHZXUVp2ZGFHbkgvZ2tCNmVob2FjZXZlLzd3Q2U5QnFlaGRXOGYreXI3d1BjcUI2ZWhvYWNldmU4R0RxQjIrT3p2RW92M1hDZnYrQ1QzWFB0Yzd4UFErQ1Q1VUJYN09mc2IreHY3T1I4bldRY1Q0RzkxZFc4Zisxd0hiNkYxcHg3dkJxZWhvYWNmRTlUMzhnZjNBK1RrOXdQM0ErUXkrd01lRThqNzhnZHZvWFduSHU4R3A2R2hweC8zWEFlbmRhRnZIaFBVV2U4Rzl6bjdHL2NiK3prZUR2aUlCSXRVb2xtdlp3ajM2ZnZvOStuMzZBV3ZyNks5aThJSTl3RXc1dnNCK3dFd01Qc0I5d0V3NXZzQit3RXdNUHNCSGc2Z2RnSHY5MXozWFBkY0EvZ2srVkFWL0NUN3dPK0xpL3drOTF5TGkvZGM5MXlMaS90YzkxeUxpL2duNzRnRkRvdnYrT3p2QVl2ditPenZBL20wQlAyMCtiVDV0QWY5VUNjVitPejd3QVluN3ljbjkxejdYSXNuSjR2OEpQZ2tKeWNGRG92M1hQZ2s5MXdCaSsvNDdPOERudm0wRllDRGc0QWYvWTRIZ0pPRGxoNzVqZ2FXazVPV0gvbU9CNWFEazRBZS9UMzdYQlg0N1B2QUp3WW5KL3RjaXlmdko0c0ZEdmRjNy9kYzd3R0w3L2pzN3dQM1hQanNGZnNYUmlZb0tOQW05eGNmMm92S3c4WE54VW5JVTl5TENQY1gwUER1N2tidyt4Y2ZPb3RPVTFGSlVjMU53enVMQ0NjRXRZdTVYTGxXWFZaZFhHR0xDRUZ4d2JtNXBjSFZIL2drRnRXbFZWMWRjVlZCSDJDTFhycGR3TG5BdUxxMml3Z09Mb3Z2OS9MdnZmZGNFdS92aS9kYysxenZFK1Qzd1BtMEZSUG9WRjVlVkI4VDVGUzRYc0llRStqQ3VMakNIOEpldUZRZSt5cjdqaFU0U0VnNEh4UHc3d2Fub2FHbkhoUGtwNkYxYng4VDhJdHZKL3NjaXpVSU5jNUwzaDRUNk43T3p0NGZFK1FuQm05MWRXOGVFL0J2ZGFHbkh4UGtpNi92OXlpTHpRamNTTkE0SGc2TDcvanM3d0gzWFBtMEZTZjNOd2VFZndVOSsxZzgrMWMrKzFrSSt3NG4rSWp2K3pZR2taY0YyZmRZMnZkWDJQZFpDUGNPN3dZT2krL3Y3Ky92Nys4QitWQUVJUXI5dFB0Y0ZTRUsvYlQ3WEJVaEN2MVErMXdWSWdvT2krL3Y3Ky92Nys4QitWQUVJUXI5dFB0Y0ZTRUsvYlQ3WEJVaEN2MjArMXdWSWdvT2krL3Y3Ky92Nys4QitWQUVJUXI5dFB0Y0ZTRUsvYlQ3WEJVaEN2enMrMXdWSWdvT29IYjN3UGRjOTF6dkFmZkE5MXozWE84RCtMcjV0Qlg3SHZzRSt3VDdIaCtMZTR0N2pud0krOFA3dzR2N1hQZkFpNHYzWFBkY2k0dnZqbzRGbW9pYmk1dUxDUGNlOXdUM0JQY2U5eDc3QlBjRSt4NGZ2U2NWUEFvT2kvZGM5OER2QWUvditDVHZBL2NhK093VmVJVjhkWXQzQ0l1SmkvdnlKNHVMK3lvRmI2RjFweDc1VUFhbm9hR25IL2NxSi9meUI2ZDFvVzhlL0lpTGhvdUhpNGVMQmNvbkZmZ2srOEFuSi90Yzd5Y0dEb3Z2NysvditDUUJpL2drNysvdjd3UDV0QVQ4SlBnaytDUUg3L3RjRlQwSzcvdGNGVDBLRHZZbjd4TDNBL2ZIKzUvM1pCT0E5K1g1U2hYN3dQc3FCWGFHZTNTTGRvdHZvWFduaTVXTG1KQ1RrUWozd1BjcUJacVRsNStMbkl1bmRhRnZpd2lDaTRXSWhZY0k3L3NxRmZ3aysxd0Zkb1o3ZEl0MmkyK2hkYWVMbFl1WWtKT1JDUGdrOTF3Rm1wT1huNHVjaTZkMW9XK0xnb3VGaUlXSENQdGNCUHZBK3lvRkU4QjlnMzkzaTN1TGNhRjBwWW9JRTZEM1hBYU5pNCtLallzSUU4Q25vcUtuSDR1amVLRnpqd2oxd3dXYWs1ZWZpNXlMcDNXaGI0dUNpNFdJaFljSUU2RDdzdndlRlcraGRLY2VqWXVQakkyTENPOEdwNkdocDZkMW9XOGZKNHVHaTRlTGlJc0ZjWGR3ZEI4T29IYnY3L2drN3dIM1crLzNYTzhEOTF2NXRCVW5KeWYzWFBkY0IvZXppQlZUaUdOM2Eyb0lZRjhGZm9PQWQ0dDhpMitoZGFlTG1vdWVscE9ZQ0xlM0JhMnQwSkswWXJKa2pFcGpZd2o3S3ZzcUJYNkRnSGVMZkl0dm9YV25pNXFMbjVhVG1BajNLdmNxQmRuWmkvY1JQZGx2cDJxZFo1TjVqM2VMZVlvSS9BLzd4eFg3S3ZzcUJUMDlpL3NSMlQzRFU5eDcwYVNtbGFXYW9hRUl0cmNGbUpPV240dWFpNmQxb1crTGZJdDRnSU4rQ0Y5ZkJXbHBSb1JpdEdTeWlzeXpzd2ozS3ZjcUJaT1RrWnVMbG91bmRhRnZpNG1MaDRxSml3aUlCb09MZ1lDSGhnajN0L3UyRmZ0YzcrL3Y3d2NPOTVUcTZlNDk3eElUZ1BqZStiRVZVNGhqZDJ0cWZvT0FkNHQ4aTIraGRhZUxtb3VmbHBPWXJhM1FrclJpc21TTVNtTmpDUHNxK3lvRlgxOW5obkdOY1kxOGxvdUxoSStBam9PTGI0dDFkSXR2aTNxV2VKcURtb09lZmIySUNMMkkwWjdKeVFqM0t2Y3FCZG5aaS9jUlBkbHZwMnFkWjVNSWVZOTJpM21LQ0JPZysxejdleFZaalVkNVQwOEkreXI3S2dVOVBZdjdFZGs5dzFQY2U5R2twcFdsbXFHaG1KT1ZuNHVhaTZkMW9XK0xmSXQ0Z0lOK0NHbHBSb1JpdEdTeWlzeXpzd2ozS3ZjcUJiT3pycENuaXFlS25vS0xpd2dUd0pPRm1JYVZpNmVMb2FHTHA0dWdlNkoya0FoMmtIMmFXWTBJRG92djcrL3Y3Ky92QVl2M3dBUDVVQVE3Q3U4V0ovZ2s3d2Y4SlB0Y0ZTZjN3TzhIL1ZEN1hCVTdDdThXSi9nazd3ZjhKUHRjRlNmM3dPOEhEb3Z2NysvdjcrL3ZBWXZ2QTczNVVCVXJDdmNxRmlJSy9ZTDdYQlVyQ3ZjcUZpSUsvWUw3WEJVckN2Y3FGaUlLL1lMN1hCVXJDdmNxRmlJS0RxQjJBZm0wK2JRVi9iVDhKUGZBSisvN3dBVU85b3Y0SlBkYzd3SHY3L2RjN3dQM3dQbFFGZnNDTVRIN0FoOG5KL3drK096NEpDZnZCL2NDTWVYN0FoNG5CTU8zWDFNZkovdGM3d2ZEdDdmREhnNzJpL2drOThEdkFlL3Y5MXp2QS9mQStiUVYrd0l4TWZzQ0grOEd3N2UzdzhPM1gxTWUrMXo4SlB3aytPejRKQ2YzWEFmM0FqSGwrd0llRHUvditDVHZBZS92K0NUdkEvZ2srVkFWK3puN0cvc2IremtmSjR2M0t2dGM5eXIzWENlTEJmY0Q1T1QzQXg3M2poYjdLdnRjNzRzRit3TXlNdnNESGljSDl6bjNHL2NiOXprZjd3WU9pKy80N084QjcrLzRKTzhENy9tMEZmdGM3Ky80SlB0Y0p3ZjNLdnVPOXlyM2ppZUxpL2ZBQmZ5Nis0NFYreXI3anUrTGkvdkErT3lMaS9kY0o0dUxKL3draTR2M1hPK0xCUTZnZHUvdjk4RHZBWXZ2K096dkEvanMrVkFWSi95SUIxUmVYbFFmSisvditJZ25CL2RjOXlvRi9PejdqaFg3WFBzcTkxejdLb3Z2K0lpTEJjSzR1TUlmN3ljbi9JZ0hEdmdyNysvNGlPOEJpKy80aU84RDkvTDV0Qlg3VmZzeCt6SDdWZnRWOXpIN01mZFZIOGFMeFpxOHBZNkhrSVdQaUFqdkp3V2JlNng5b292RGk3bTVpOE9Mb24yc2U1c0lKKzhGaDQrRWtJYU9wcnljeEl2SENQZFYrekgzTWZ0Vkh2enNCUHNmK3dQM0EvY2Y5eC8zQS9jRDl4LzNIL2NEK3dQN0gvc2krd0Q3QVBzaUh3NzJvSGI1VU84QmkrLzRKTzhEOThENXRCWDdPdnNhK3hyN092dGM5OEQ3d0l1TDk4RDN3UGRjOXpyN0d2Y2Erem9mSndRNENnNzRLNHZ2NysvM1hPL3Y3d0dMNysvdjcrLzNYTzhEK2JRRS9iVDV0UGVDQjR5T2k0K0xqb3VPaTVDS2pnajRzUWY3eGZ5NkZXK2hkYWNla0l2M0tvdUxKL3pzaTR2NDdQanNpNHY4SlBzcWk0YUxCVzkxYzNFZit5WDM4aFU0U0VnNEovY3EreXFMaS9jcTl5cnYza2pPT0I4bkJDa0tEdmFMOTF6M1hQZGNBL2xRQkQ0Szkxd1dQZ29POXZsUUJJdjg3UGpzOThBRkR2YnYrT3dCaS9qc0EvZkErVkFWK3pyN0d2c2ErenI3T3ZjYSt4cjNPdmM2OXhyM0d2YzY5enI3R3ZjYSt6b2ZEdmdrK1ZBVi9DVDd3UGdrKzhBRjk4QUUrQ1Q3d0l2NDdBVU8rVkFFaS96cytDVDN3QVg3d0FUNEpQZkEvQ1Qzd0FVT2kvZGNBL2xRQkQ0Sys4QUUrSWo3d0l2NDdBVU8rSWozWEFQNVVBU0wvT3o0aVBmQUJmdkFCUGRjK096N1hBWU85dS80N0FHTCtPd0QrVkFFL096NDdQanNCdzZnZHZkYytDUUI5MXo0SkFQM1hQbTBGZnRjKzF6OEpQZGMrMXo0SlBkYzkxejRKUHRjOTF3SERvN3Y5MXp2OTFudkFmbFFCQ0VLL2JUN3ZSVWhDdjIwKzhBVklRb085aWZ2OWVuditDZ1NpKy92OTF6N0t1LzNLdThUK3ZlcStWQVZZSUZvWDR0ZkNJdUppL3RjQlZTNFhzTEN1TGpDSG92M1hJdVBCY0pldUZRZWdvdUZpWVNKQ1B1SSsxd1ZlSVY4ZFl0M0NJdUppMWtGRS9hTCt5ajNBZnNPOXlGekNDRUhFL3BaQmxSZVhsUWYrQ1FHd2w2NFZCNFQ5bG4xQnZjaG8vY0I5dzZMOXlnSXZRZW5kYUZ2YjNWMWJ4NVpCL3NETWpMN0Evc0RNdVQzQXg2THZZdU1CYWQxb1c4ZWlJdUlpb2lMQ0lnR0R2ZkE5MXdCK0lnRUx3b09KKy92Ny9nazd3R0w3L2pzN3dPdCtWQVZlSVY4ZFl0M0NJdUppL3lJQlcraGRhY2U5NDRuSndaVVhsNVVIL2pzQnNKZXVGUWVKKy8zamdhbm9hR25IL2lJQjZkMW9XOGUvVkNMaG91SGk0aUxCY2tuRmZqcy9DVDg3QVlPUGZlT0FZdjNqZ1AzcFBsUUZmc3lWdnNHK3ltTCswU0wrM0gzUi90SDkzR0w5MFNMOXluM0JzRDNNbU45WUlOZWkvdHhpL3RIOTBlTDkzR0x1Sk8ybWJNSURxQjI5OER2QWZmQTd3UDM4dmxRRmZzcSt5cnZpNHY3S3ZzcWk0dnYreXI3S3ZjcSt5cUw3L2NxaTR2N0tpZUw5eXI3S3ZjcTl5b25pNHYzS2dYM0tpY0c5eXIzS3ZzcTl5cUxKL3NxaTR2M0t1K0xCUTZMOThEN1hQZkE5MW4zWHhLTDk4QW43L2RjOThBbjd4T3ErYlQ1dEJYOGlDY25peC84TFFkOGtIbVBlb3NJRTdBL0NoTnErQ0VIMUtMM0VxRDNYWkVJKzJJSGZKQjVqM3FMQ0JOa1B3b085MlA0aC9sUUZWaUxXSGRrWkFqN3F2dWtCU0FnaS90QzlpRDJJUGRDaS9iMkNQY1I5eEZHMFBzSSt3V0Nmd1ZHUnZzRWkwYlFSOCtOOXdMTjBBajNxdmVuQmJPenpJcXlaTEpraVUxbVl3ajdqdnVMQllHQmVZdUJsWUdWaTUyVmxRaVNqdVhwUnRBcktnVmJXNHM4dTF1N1c5cUx1N3NJOTQ3M2lBWFoyWXYzRVQzWlpMSlluMWlMQ0E2Z2RnSDQ3UG0wRlNjbjkxejdYTy92QmZ3a0Z2d2svQ1NMKzF6M1hJdjRKUGdrQlE2TDkxenYrQ1Q3d1Bna0V1LzN3Ty8zWENmM1hCTzQrTHI1dEJWWWkxOW5jRmU0VmFaQml6ZUxib2h4aFhHZWdKMkRvWXNJM3M3bDl3SWY5d0pJNVRnZUU5RDd3Q2NWT0VneCt3TDdBczR4M3Q3TzVmY0NIL2NDU09VNEh2aHYrOUFWWUZoUGJFbUpDQlBVcG1XY1hZdFpDRW4zWFBjNkI0dS9iTGRmb1FqOUhpY1ZYM1ZzWDR0WENQczZCeE9ZK0lqM09nYUx2MnkzWDZGZVZrNXNSb3RHaTA2cVhzQUlEb3YzWE8vNGlBSDNYUGdrQS9naytiUVYrd0l4K3dUN0h2c2U1ZnNFOXdMM0F1WDNCUGNlOXg0eDl3VDdBaC83WmZ5SUZTR0dOalNMK3dBSUovbTA3d2VMOXdBMjRpR1FWVTVCWkRxTE9vdEJzbFhJQ0E3Mmk3M3Z2ZmlJN3hLTDkxejdYTy8zWFBkY0orOFQ2cDc1dEJXQWc0T0FILzJPQjRDVGc1WWUrR0lHbHBPVGxoLzVqZ2VXZzVPQUh2d1JKeFgzd1B5SSs4QUc5eXBaRlJQMEtRb09vSFlCOS9MNXRCVXFpelJrVEVzSTk3Mzd2WXY0SVFWN2pYcU1lb3NJOXlvaEZZdjc2ZnVrKzZRRnlGblhiT0NMOTFXTDl6SDNNWXYzVll2M1JQc1g5eVA3UGFRSS9DMzdHQlZUVldoQml6ZUxLN2s0MFZRSTkyajNhQVVPOThEdjkxenZBZmZBN3dQbitSNFZiNkYwcHg2Tmk0K01qWXNJdmZ0Y0p3WlVYbDVVSC9mQSs4QUd0eWZENzR2M3dQZkFpd1hDWHJoVUhpZjNYTDBHcDZHaHA2ZDFvVzhmL0NTTGhvdUhpNGlMQlhGM2NIUWZEb3Y1dEFHTDk4QUQrQ1Q1dEJVakNpZjdYQlgzd1B0Yys4RDdYQVVPb0hiM3dQZGNBZmZBOTF3RDk4RDV0Qlg3d1B2QSsxejN3UHZBOTF6M3dQZkE5MXo3d1BmQUJ3Nkw3d0dMNy9kYzcvZGM3d01VY1BmQStiUVZKUXI3ZVBza0ZXVnNCVHBMVmllTCt3TUkrMVgzTWZzeDkxWDNWZmN4OXpIM1ZSNkw5d05YN3puTENHV3FUVDJ3YkFYRlhiSkVpenNJK3gvN0Evc0QreC83SC9zRDl3UDNIeDZMMjYvU3hia0lzNm9GRG92M3dPL3Y3L2RjQVl2djcvZ2s3KzhERkJ6M1hQbTBGZnRjK0NUM1hBZjg0L3ZBRllXSWlJVWYrNjRIaFk2SWtSN205MXo0N1B0YzVnYVJqbzZSSC9ldUI1R0lqb1VlL09QN1hCWDd3UGdrOThBSERxQjI3Ky92NysvdkFZdnYrT3p2QS9sUUJQMVE3L2xRQi9qc0Z2MVE3L2xRQi96c0p4VW45MXp2QnlmN1hCVW45MXp2QnlmN1hCVW45MXp2Qnc3M2UrOEI5OW41VUJWaCt4eGkreHhoK3gwSWlKR0NyZnRRaTRzbjl3aUxCYWMwcHpTbk03WDNHYlQzR3JYM0diUDdGTFQ3RkxIN0ZiSG1zT2V3NXdpWWIvZDdpNHZ2K3oyTEJXN0ZiOFJ0eEc1QmJVRnVRVi8zSDE3M0gySDNJUWdPNy9qcy9PejNYQktMOTF5TDkxeUw5MXdUa1BkYytPd1ZpMitkZDVWempvV0xnWXQvQ0JPbyszdjg3UGQ3Qm91WGk1V0lrWUdqZVorTHB3akV0cmJFeExaZ1VoNkxiM2wzZ1hPSWhZdUJpMzhJOTN2M2V3YVhpNVdMa1lnSUUwaWpnWjk1cDRzSXhMYTJ4TVJndGxJZmI0dDNlWE9CaFlpQmkzK0xDUGQ3KzNzSGk1ZUxsWTZSQ0JPUWxhT2RuNHVuQ01SZ3RsSWVVbUJnVWg4T2tpZnYrT3p2QWZkWjcrL3ZBL2VMK1ZBVk5vdE1jV05qWTJOOVdZWmxDTzkvQlkrbGs2T2VucDZlcXAzTmk4MkxyM3VmZVo5NWszU0xjb3M0YUhSWlgxbGZTa3VMK3drSWN1K2tCNHZlcXFLOXQ3MjMwTXVMOXdtTHUzdkJZTEpnc2t1Zk40c0lXZjFRRlNmdjd3Y09pL2RjNy9mQSsxejRKQkx2NysvdjcrOFVIQk84K0ZiNXRCVVQzUHNOaXlFMWRQc0dDQk84K3dJeE1mc0NINHRYbjEyc1p3Z1QzS1doclpld2k1K0xub2FjaEFnVHZKekx4YnZRaTlDTHhWdWNTd2dUM0p5U25wQ2ZpOHFMd0dTaFZNdWN1OFdMMEl2TVljdFJvQWk5Qi9jZSt3VDNCUHNlSHZzSS9JZ1ZlSVY4ZFl0M0NJdUppL3RjQlcraGRhZW5vYUduSG92M1hJdU1CYWQxb1c4ZWlJdUlpb2lMQ0lnRysyQW5GWGlGZkhXTGR3aUxpWXNuQlcraGRhZW5vYUduSG92dmk0d0ZwM1doYng2SWk0aUtpSXNJaUFiNElCWjRoWHgxaTNjSWk0bUxKd1Z2b1hXbnA2R2hweDZMNzR1TUJhZDFvVzhlaUl1SWlvaUxDSWNHRHFCMjcrLzRKTzhCK096NXRCVW5XUWRvaTNhQWRYQUkreUg3UnZzdDkwWUZkYVYxbDJtTENDY243d2FPaVBjMysxUDdPdnRpSjR1TEorK0xCYTZMb0phaHBnajNMZmRTOXpyN1VnV2hjYUIvcm9zSXBDY0c5MXozS3Z0Yzl5cUxKM1dMaFk3N1EvZGk5eTMzVTcyTGl5ZjNYUGNxQlE2TDcvanM3d0dMN3dQNEpQbTBGZnR3KzBqN1NQdHcrM0QzU1B0STkzQWY5d0tMOGJmVDB3aEQwd1ZWVlVCcE9Jc0krenI3R3ZjYTl6cjNPdmNhOXhyM09oL2VpOU5ud1ZRSSt3SDdBZmZBaTR2M3dQc0wrd3NGUTlNb3V2c0Npd2dPb0hZQitDVDV0QlgzT3ZzNi9DVDhKUHM2OXpxTC9DVDRKSXY3T3ZjNitDVDRKUGM2K3pxTCtDUUZEdmFnZGdIM1hPOEQ5NDc1dEJYN2p2dkE5MXlMaS90YysxeUw5NDc3d1BlTzk4RDdYSXVMOTF6M1hJc0ZEdmZBN3dIM3dQanNGZnZBKzQ3M3dQdU9pL2RjOTF5TGkvdGM5OEQzanZ2QTk0NkwrMXo3WElzRkRxQjIrT3ozWEFINDdQZGNBL20wQlB0Y0IvZmg5NS83bi92aEgvZGNCdmhOKy92MysveE5IdnZBQlB0Y0IvYzc5eG43R2ZzN0gvZGNCdmVuKzNYM2RmdW5IdnZBQlB0Yzkxd0g5d0l4NWZzQ0hnNkw5MXp2NysvdjcrOEJpL2RjNysvdjcrL3ZBKy81dEJVbkIvZmc5NkQ3b1B2Z0grOEcrQmI3enZmTy9CWWUrMXdFSndmM2N2ZEcrMGI3Y2gvdkJ2ZW8rM1QzZFB1b0h2dGNCQ2NIOXdQa012c0RIKzhHOXpuN0cvY2IremtlKzF3RUtnb09pL2drL0NUditDVDN3Q2Z2RW92djcrOFRYUGZBK2JRVlZGNWVWQi84dWdkdmRYVnZiM1docHg3M0tpZjdYQWRVdUY3Q0hoT00rSWdHRTB6Q3VMakNIeE9jOThEOEpQZU9CNmVob2Flbm9YVnZIaE1zK3lyNEpBY1RIUGRjQnhNc3dsNjRWQjRPaSsvNGlPOEJpKy80Sk84RDF2bFFGV0pwYVdJZi9Mb0hZcTFwdEI3NFZnYTByYTIwSC9jUkp5ZjhKUGlJOTF6dkIvZkFGaWNIKzJHTCt6cjdMblQ3VzZEajJzenBpd2ozWENjRzkxejNYQVVPb0hiM3dQZGNBZmlJK1ZBVisxd0gvQ1FuKzJIN3V4Ky85MXIzS1BIM1hJc0k3L3RjQnZmQTk5QUZEb3Z2QWZnUithc1YreE5XK3hKVSt4UlhDR3dIaS9zNnp2c20yeUN6VnJaZnRXeTFiTE4xdVl1NWk3T2h0YXExcXJhM3M4RGI5YzczSjR2M09naXFCL3NVdi9zU3d2c1R3QWg0bEFYOVVBU0hpMjZTYXFOcW8yV3phTGxMNEZuM0NZUDNFZ2ozdXZjT0JRNmdkZ0dMNysvdjcrL3Y3d1A0N1BtMEZTUUsrOEFuRmYxUTcvbFFCL3ZBKzF3Vi9JanYrSWdIKzhEN1hCWDd3Ty8zd0FjT29IYjRKUGRjSi9kY0V2ZkE3eE93OThENXRCVW4rMXdIRTlBbkp3VVRzTzhuOTF5TGkveUk3NHNGRTlENEpQZGNCeE93Nys4RkU5QW43L3RjaTR2M1hBVU9vSGIzd08vdjcrL3ZBZmRjN3dQM1hQbTBGVUFLN3hZbjkxenZCL3RjKzF3VkovZkE3d2Y3d1B0Y0ZTZjRKTzhIRHFCMjk4RHY3Ky92N3dIM1hPOEQ5MXo1dEJWQUN1OFdKL2drN3dmOEpQdGNGU2Yzd084SCs4RDdYQlVuOTF6dkJ3Nkw3Ky92Nysvdjd3R0w3Ky92K0NUdkE5YjVVQlZpYVdsaUgveTZCMkt0YWJRZStSNEd0SzJ0dEIvNHVnZTBhYTFpSHYwRkp4WHZKeWNHOTF6dkZUSUsrMXduRmU4bkp3YjNYTzhWTWdyN1hDY1Y3eWNuQnZkYzd4VXlDZzZnZGdINEpQbTBGU2Y3d1B2QWkvZU8rMXduKzhEM2p2ZGM5NDc3WENmM3dQZU85MXo3d0lzRkRvdnZpKy8zS3UvM0t1K0w3eEtMNzR2djl5cnY5eXJ2aSs4VEtRRDRKUG0wRlRFS0V6TUErNDRuRlRFSytJZ1dFekdBS3dyN2ppY1ZFM09BSmdyNzh2c3FGUk1sQUNzSytWQVdFeUZBS3dvVFl3RDg3UHVPRlRFSytJZ1dFMkdBS3dvVG9RRDdqaWNWTVFvT29IYjNLcjM0aU84QmkrLzRpTzhEcmZtMEZYbDdlM2tmL1hBSGVadDduUjc1REFhZG01dWRIL2x3QjUxN20za2UvTW9uRmZpSS9JajhpQWIzamxrVnNZdWtZWGhxZUdwWmkzaXNlS3lrdGJHTENBNmdkdmxRN3dHTDd3UDV0QVNMKzhENGlQeUk5OEQzd1B5SStJZ0ZKeWNWUEFvTytJanZBWXZ2QS9qc0JJdjdYUGZBKzhEM1hQZGMrOEQzd0FYM0lCYjN3ZnZBK3d2N0R0azk5MXozWFB2QTk4QUYrL0luRlNrS0RvdnY3Ky8zWE8vdjd3R0w3Ky92OTF6djcrOEQrQ1Q1dEJVbkNpY0VMUW9uQkNZS0p3VER0MTlUVTE5ZlUxTmZ0OFBEdDdmREh3Nkw3L2lJN3dHTDcvaUk3d1A1VUFUOVVQbFE5L3NISnllTCt6UDhpSXVMK0lqMys0dnY3d1gzSVJiN3dQdkFKKzhuSi9kYysxejRKUGdrQlE2TCtDVHY5OEFCK1ZEdkE1VDV0QldGaUlpRkgvMmlCNFdPaUpFZSthSUdrWTZPa1IvNW9nZVJpSTZGSHYwVlBSWDNRUHRBKzBEN1FFUFQ3KzhuN3dYMzF2c3FGZmZBSi92QUJnNkw3L2pzN3dHTHZmZU85MXozanIwREZEajV0QVQ3WEwwSHdyaTR3aDczS3Z5NkJtOTFkVzhlV1NmNEpPOVpCbTkxb2FjZitMcjNLZ2ZDdUY1VUg3MzNYQVlPaSsvditJajd3T3dUZ1BsUUJDVUtFOER2RnZ3a0I2ZUxwSUtlZUFnVG9KNTQ2dnRWbVhHWmNhVitwWk9sazVpb2c2V0RwV1QzR1l1a0NLU2hwS2NlOXlvR0U4Q25vYUducHlUM3Q0c2ZnNTE1bUhhTENBNmdkaEtMNysvNGlQdkE3QlBRK0NUNUxoVjljU3o3VlhoNENCUGdlSGh5Z20rTENQd2s5L0lIb0l1ZG1KT2RDSXZ5OTdlbnAzV2hieC83S2dadmRhU2tIeFBRaTZTeTl4bVRwWk9sZnFoeGt3aDRqZ1Y0aVhsK2dYZ0kvQ1Q3bmhVbENnNG43L2lJN0k3dkFZdnYrSWp2QS9kYytWQVZKKytJQi9zK2Mvc1creWVMKzBRSSsxWDNNZnN4OTFYM1ZmY3g5ekgzVlI2THQ0QzJmYkVJTUdZRmxtK1Fib3RzQ1BzZit3UDdBL3NmK3gvN0EvY0Q5eC8zSC9jRDl3UDNIeDZwaTZtR3A0QUlyZWtGZFpOeWozS1BDSkh2N3dmM1hQc0lGWXVML0FEN3JIZDNkM2VMYjU5M24zZW5pNStmbjUvM3ZQZndpNHNJRHFCMjcrLzN3TzhCK096NVVCVW4vT3duK093bkIvZGM5eW9GL096N2poWDdYUHNxOTF6N0tvdnYrT3lMaSsvODdJc0ZEb3Z2K0lqM1hQdGM3eEx2NysvdjcrOFVIQlBjOThENXRCVVR2RlJlWGxRZkp3WlVYbDVVSC9sUUJzSmV1RlFlSndZVDNNSmV1RlFlKzhEN3dCWDhkUWVBazRPV0h2aGlCcGFUazVZZitIVW4rL0lIYjNWMWIyOTFvYWNlOS9JbisvSUhiM1YxYjI5MW9hY2U5L0lIRG92djcrOEI3L2RjOTF6dkErLzV0Qlg4SkFmN0F2Y0VNZmNlSHIwRzl3TGw1ZmNDSC9na0ovd2tCMVJlWGxSVVhyakNIdmdrQi92QS9WQVZKL2xRN3djT2krL3YrSWdCaS9kYzcvZGM3L2RjQXhRNGxQbFFGVUVLK0RZV1FRcjhkdnRjRlVJSy9ILzhKQlVoQ2c2TDkxd243Ky92Ny9kYysxenZFb3YzWE8vM1hPLzNYQlFIRXplVitWQVZoWWVJaFIvN1UvZGM5MU1Ia1lpT2hSNzROeGFHaG9pRkgvdFQ5MXozVXdlUmlJNkZIaE12L0hVbkZZV0hpSVVmTVBkYzVnZVJpSTZGSHZ4Lysxd1ZJUW9UcC8yMCsxd1YrMU1IaFk2SWtSNzNTZ2FSam82UkgvZFRCeE5uN3hZd0I0V1BpSkVlOTBrR2tZNk9rUi9tQnhPbjd4YjdVd2VGajRpUkh2ZEpCcEdPanBFZjkxTUhEb3Y0aU8vdkFZdjNYTy8zWE8vM1hBTVVPUGxRQkNFSy9hdjdYQlZCQ3ZjS0ZrSUs5d29XUVFvTzcvaUlBYjM0N0JWdmRYVnZIL3drQjIraGRhY2UrSWdHcDZHaHB4K0w5eXJ2SisrTGkvZkFKNHNuSjR2M0tnV25kYUZ2SGc2Z2R1L3YrQ1R2QVl2NEpPL3Y3KzhEOStMNXRCVkRDdS83WEJXY2k1eUptNGZoZGNzOWl5MkxMVXM5TlhWN2gzcUplb3NJSndla2k2T09vcEVJamdiM0ZxenE5d3FMOXlDTDl5QXM5d243RnF4MGtYR1BjWXNJKzF3RVJBb085cUIyQVl2NEpPL3ZBL2ZpK2JRVlF3cnYrOEFWUkFvT0xxQjJBWXY0SkFQMzR2bTBGVU1LRG92djcrOEI5OG41dEJXRmk0ZUhpWVlJKzdyOVBvaDRpem9GaFk2SWtSNzVQZ2FSam82Ukg0dmNpSjc3dXZrK0JZbVFoNCtGaXdndys4QVY3L3RjSndZbkJPOG5Kd1lPaS9kYzkxenY5MXp2QWZlbjkxd0QrQXY1dEJYN0hvdjdGR1Q3QVVVSXdEa0Y2TWIzQXF2M0M0djNESXYzQkd6b1R3akEzUVg3QWRIN0Y3TDdIb3NJKzhBRVBJdERkVTFqQ01FMkJicXB2NXpIaThhTHhYcTViUWpBNEFWTnNqK2lQWXNJKzhBRUtnb08rQ3VMdmZlTzkxd0I5OEgzWEFQNHUvbTBGZnNlK3dUN0JQc2VINHRyazJ5V2J3ajd0L3V6QldSa2kwbXlaSjkzcFlPbGk2V0xwWk9mbndqM3RQZTNCYWVBcVlPcmkvY2VpL2NFOXdTTDl4NkxtNHViaUpvSUtpcjdYSXVMOTF6czdBVjhqbnVMZTRzSS9GYjlIaFVwQ2c3M0lmbFFGZnNoK3lFRjN6ZmVOdDQzT0RnNU56WTdDUGNoK3lQM2tmZVJCZDAzM3pqY05RajNJL2NqQlRYY09OODMzUWoza2ZlUit5UDNJUVU3TmpZNU9UZzMzamJlTjk4SURxQjI5MXp2Nys4Qjk4RHZBL20wQlBkMSs4RDdkWXVMSi9mQWk0c24rOENMaXlmM3dJdUwrMXp2aTR2M1hQZkFpNHZ2KzhDTGkrOEY5OER2KzNVRzkzWDN3Q2VMKzN2N3dHV0wrM3Yzd0FVTytDdnY3L2RjNy9kYzd3R0w3L2RjNy9kYzd3TVUvUGZ5K2JRVlJRb25CRVlLV1NjVkp5Y243eWZ2NysvdkorOEhEdmdyNysvM1hPLzNYTzhCaSsvNGlPOERGT0QzOHZtMEZVVUtKd1JHQ3ZzcSsxd1ZKL2ZBN3djTytiUVUrSUVWbmd3Szd3cTl0NUh2dmIzdmordnY5MXdNRE84THZiM3ZrN1diclpMbzcrLzNYQXdOSEFBdUV3QW5BZ0FCQUE4QUZRQWJBRDBBUkFCTEFHVUFod0NmQUxFQXd3RFZBUDBCSHdGUUFWZ0JZQUZ6QVhvQmhnR1NBYU1CdVFIQkFkc0I4Z0lJQWhBQ0lnSXRBalVDUXdKWUFuWUNsQUtzQXNBRERnTkFKL2drL0lqOEpDZjRpUGxRQndzbitiVHZCd3NuK096dkJ3djdjZnRIKzBmN2NmdHg5MGY3Ui9keDkzSDNSL2RIOTNIM2NmdEg5MGY3Y1I4TC9iVHYrYlFIQy93azcvZ2tCd3Y3QWpFeCt3TDdBdVV4OXdMM0F1WGw5d0wzQWpIbCt3SWZDL3R3KzBqN1NQdHcrM0QzU1B0STkzRDNjUGRJOTBqM2NQZHcrMGozU1B0d0h3dW5vWFZ2SHljSGIzVjFiMjkxb2FjZTd3ZW5vYUduSGd1bm9YVnZiM1YxYjI5MW9hZW5vYUduSHd0VVhsNVVWTGhld3NLNHVNTENYcmhVSHd0dmRYVnZiNkYxcDZlaG9hZW5kYUZ2SHd2M0t2c3E5eXIzS3RORCt5cjdLdmNxK3lwRFEvc3E5eXI3S3ZzcVE5UDNLdmNxK3lyM0tnVUw5enIzR3ZzYSt6cjdPdnNhK3hyN092czYreHIzR3ZjNjl6cjNHdmNhOXpvZkMvc05peUUxZFBzR0NQc0NNVEg3QXZzQzVUSDNBaC80VmdiZXpzN2VINHZNWWN0Um9BaTlCL2NlK3dUM0JQc2VIZ3Y3WFBtMDkxd0hDLzIwOTF6NXRBY0xiM1YxYjIraGRhZW5vYUduSDZkMW9XOGVDL2drSi93a0JndUwvT3ozd1BmQWkvZkFCUXY3d1B2QWkvdkE5OENMQlF2N09mc2IreHY3T1IvN3dQZkE5OEFIQy9zRE1qTDdBeDRuQi9jNTl4djNHL2M1SC9mQUJ3djdYUGRjOTF3SEMvY0M1VEg3QXZzQ01USDdBdnNDTWVYM0F2Y0M1ZVgzQWg4TGkvd2s5eXIzS3ZjcSt5cnY3L3NxOXlyM0t2Y3FCUXNuSi9jcSt5cjdLdnNxK0NTTGkvZ2sreXI3S2dVTCs4RDN3UGZBQnd2Q3VGNVVWRjVlVkZSZXVNTEN1TGpDSHd2N3dQdkFKL2drK0NRSEMvenM5MXo0N0FjTE9FaElPRGpPU043ZXpzN2VId3Y4N1B0Y0IvZU8rMXozanZkYysxeUxpL2pzQlF1RmlJaUZIL3gyQjRXT2lKRWU5MG9Ha1k2T2tSLzRkZ2VSaUk2RkhndUZpSWlGSC91dUI0V09pSkVlOTBvR2tZNk9rUi8zcmdlUmlJNkZIZ3Y3R3Z0YysxeUxpL3drOTF5TDl4cjdYTTJMaS9tMEJRdUwrMXlramdXMmxxdXppN21MdVd5elg1WUlDL3RWK3pIN01mdFYrMVgzTWZzeDkxVWZ5SXZGbTcybmpZZVBoWTZJQ084a0JadDdySDJpaThPTHVibUx3NHVpZmF4N213Z2s3d1dJam9XUGg0Mm12WnpGaThnSTkxWDdNZmN4KzFVZUMvY2Y5d1A3QS9zZkg0dFFlRlZwWUFpSWlBVi9oWDk5aElCZlpsSjBUWXNJK3gvN0EvY0Q5eC8zSC9jRDl3UDNIeDhMQUFBQmtBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBbGdBQUFKWUFBQURJQUFBQXlBQUFBR1FBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFDV0FBQUF5QUFBQUdRQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFHUUFBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBbGdBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQTRRQUFBTWdBQUFESUFBQUF5QUFBQUdRQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUdRQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRGhBQUFBbGdBQUFPRUFBQUNXQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBcndBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCOUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBQmtBQUFBeUFBQUFNZ0FBQURoQUFBQXlBQUFBTWdBQUFEaEFBQUFBQUFBQUFBQUFFQUFBQUF6RDJpendBQUFBRFAyUzlxQUFBQUFNL1pMMm89XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5vdGZcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLm90ZlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QZ284SVVSUFExUlpVRVVnYzNabklGQlZRa3hKUXlBaUxTOHZWek5ETHk5RVZFUWdVMVpISURFdU1TOHZSVTRpSUNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk5SGNtRndhR2xqY3k5VFZrY3ZNUzR4TDBSVVJDOXpkbWN4TVM1a2RHUWlJRDRLUENFdExRb3lNREUwTFRjdE1Ub2dRM0psWVhSbFpDNEtMUzArQ2p4emRtY2dlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQRzFsZEdGa1lYUmhQZ3BEY21WaGRHVmtJR0o1SUVadmJuUkdiM0puWlNBeU1ERXlNRGN6TVNCaGRDQlVkV1VnU25Wc0lDQXhJREl3T2pNNU9qSXlJREl3TVRRS0lFSjVJRkF1U2k0Z1QyNXZjbWtLUTNKbFlYUmxaQ0JpZVNCUUxrb3VJRTl1YjNKcElIZHBkR2dnUm05dWRFWnZjbWRsSURJdU1DQW9hSFIwY0RvdkwyWnZiblJtYjNKblpTNXpaaTV1WlhRcENqd3ZiV1YwWVdSaGRHRStDanhrWldaelBnbzhabTl1ZENCcFpEMGliM0JsYmkxcFkyOXVhV01pSUdodmNtbDZMV0ZrZGkxNFBTSTRNREFpSUQ0S0lDQThabTl1ZEMxbVlXTmxJQW9nSUNBZ1ptOXVkQzFtWVcxcGJIazlJa2xqYjI1eklnb2dJQ0FnWm05dWRDMTNaV2xuYUhROUlqUXdNQ0lLSUNBZ0lHWnZiblF0YzNSeVpYUmphRDBpYm05eWJXRnNJZ29nSUNBZ2RXNXBkSE10Y0dWeUxXVnRQU0k0TURBaUNpQWdJQ0J3WVc1dmMyVXRNVDBpTWlBd0lEVWdNeUF3SURBZ01DQXdJREFnTUNJS0lDQWdJR0Z6WTJWdWREMGlPREF3SWdvZ0lDQWdaR1Z6WTJWdWREMGlNQ0lLSUNBZ0lHSmliM2c5SWkwd0xqVWdMVEV3TVNBNE1ESWdPREF3TGpFeU5pSUtJQ0FnSUhWdVpHVnliR2x1WlMxMGFHbGphMjVsYzNNOUlqVXdJZ29nSUNBZ2RXNWtaWEpzYVc1bExYQnZjMmwwYVc5dVBTSXRNVEF3SWdvZ0lDQWdkVzVwWTI5a1pTMXlZVzVuWlQwaVZTdEZNREF3TFVVd1JFVWlDaUFnTHo0S0lDQWdJRHh0YVhOemFXNW5MV2RzZVhCb0lDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaUlpQjFibWxqYjJSbFBTSW1JM2hsTURBd095SWdDbVE5SWswek1EQWdOekF3YURVd01IWXROekF3YUMwMU1EQjJNVEF3YURRd01IWTFNREJvTFRRd01IWXhNREI2VFRRd01DQTFNREJzTWpBd0lDMHhOVEJzTFRJd01DQXRNVFV3ZGpFd01HZ3ROREF3ZGpFd01HZzBNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhJaUIxYm1samIyUmxQU0ltSTNobE1EQXhPeUlnQ21ROUlrMHpNREFnTnpBd2FEVXdNSFl0TnpBd2FDMDFNREIyTVRBd2FEUXdNSFkxTURCb0xUUXdNSFl4TURCNlRUSXdNQ0ExTURCMkxURXdNR2cwTURCMkxURXdNR2d0TkRBd2RpMHhNREJzTFRJd01DQXhOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpJaUlIVnVhV052WkdVOUlpWWplR1V3TURJN0lpQUtaRDBpVFRNMU1DQTNNREJqTVRreklEQWdNelV3SUMweE5UY2dNelV3SUMwek5UQjJMVFV3YURFd01Hd3RNakF3SUMweU1EQnNMVEl3TUNBeU1EQm9NVEF3ZGpVd1l6QWdNVE00SUMweE1USWdNalV3SUMweU5UQWdNalV3Y3kweU5UQWdMVEV4TWlBdE1qVXdJQzB5TlRCak1DQXhPVE1nTVRVM0lETTFNQ0F6TlRBZ016VXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6SWlCMWJtbGpiMlJsUFNJbUkzaGxNREF6T3lJZ0NtUTlJazAwTlRBZ056QXdZekU1TXlBd0lETTFNQ0F0TVRVM0lETTFNQ0F0TXpVd1l6QWdNVE00SUMweE1USWdNalV3SUMweU5UQWdNalV3Y3kweU5UQWdMVEV4TWlBdE1qVXdJQzB5TlRCMkxUVXdhREV3TUd3dE1qQXdJQzB5TURCc0xUSXdNQ0F5TURCb01UQXdkalV3WXpBZ01Ua3pJREUxTnlBek5UQWdNelV3SURNMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXdORHNpSUFwa1BTSk5NQ0EzTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRURXdNQ0ExTURCb05qQXdkaTB4TURCb0xUWXdNSFl4TURCNlRUQWdNekF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWsweE1EQWdNVEF3YURZd01IWXRNVEF3YUMwMk1EQjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMUlpQjFibWxqYjJSbFBTSW1JM2hsTURBMU95SWdDbVE5SWswd0lEY3dNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTUNBMU1EQm9OakF3ZGkweE1EQm9MVFl3TUhZeE1EQjZUVEFnTXpBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJREV3TUdnMk1EQjJMVEV3TUdndE5qQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5pSWdkVzVwWTI5a1pUMGlKaU40WlRBd05qc2lJQXBrUFNKTk1DQTNNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRJd01DQTFNREJvTmpBd2RpMHhNREJvTFRZd01IWXhNREI2VFRBZ016QXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB5TURBZ01UQXdhRFl3TUhZdE1UQXdhQzAyTURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzSWlCMWJtbGpiMlJsUFNJbUkzaGxNREEzT3lJZ0NtUTlJazAwTURBZ056QXdZemMxSURBZ01UUTJJQzB5TXlBeU1EWWdMVFU1YkMwM05TQXRNakkxYkMwek1qSWdNak0wWXpVM0lETXhJREV5TWlBMU1DQXhPVEVnTlRCNlRURXlOU0ExT0Roc01Ua3hJQzB4TXpoc0xUTXhNQ0F0TWpJeVl5MDBJREkwSUMwMklEUTNJQzAySURjeVl6QWdNVEUwSURRNUlESXhOU0F4TWpVZ01qZzRlazAyT0RnZ05UYzFZelk1SUMwM01pQXhNVElnTFRFMk9DQXhNVElnTFRJM05XTXdJQzB6TlNBdE9DQXROamdnTFRFMklDMHhNREJvTFRJeE9IcE5NakUySURJMU0yd3hNVElnTFRNME4yTXRNVEk0SURJeklDMHlNeklnTVRBNUlDMHlPRGNnTWpJeWVrMHpOeklnTVRBd0NtZ3pOekpqTFRZMElDMHhNRGtnTFRFM055QXRNVGcxSUMwek1UQWdMVEU1TjNvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9DSWdkVzVwWTI5a1pUMGlKaU40WlRBd09Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk1qQXdJRGd3TUdneE1EQjJMVFV3TUdneU1EQnNMVEkwTnlBdE16QXdiQzB5TlRNZ016QXdhREl3TUhZMU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamtpSUhWdWFXTnZaR1U5SWlZamVHVXdNRGs3SWlBS1pEMGlUVFF3TUNBNE1EQmpNakl4SURBZ05EQXdJQzB4TnprZ05EQXdJQzAwTURCekxURTNPU0F0TkRBd0lDMDBNREFnTFRRd01ITXROREF3SURFM09TQXROREF3SURRd01ITXhOemtnTkRBd0lEUXdNQ0EwTURCNlRUTXdNQ0EzTURCMkxUTXdNR2d0TWpBd2JETXdNQ0F0TXpBd2JETXdNQ0F6TURCb0xUSXdNSFl6TURCb0xUSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWVNJZ2RXNXBZMjlrWlQwaUppTjRaVEF3WVRzaUlBcGtQU0pOTkRBd0lEZ3dNR015TWpFZ01DQTBNREFnTFRFM09TQTBNREFnTFRRd01ITXRNVGM1SUMwME1EQWdMVFF3TUNBdE5EQXdjeTAwTURBZ01UYzVJQzAwTURBZ05EQXdjekUzT1NBME1EQWdOREF3SURRd01IcE5OREF3SURjd01Hd3RNekF3SUMwek1EQnNNekF3SUMwek1EQjJNakF3YURNd01IWXlNREJvTFRNd01IWXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1JaUlIVnVhV052WkdVOUlpWWplR1V3TUdJN0lpQUtaRDBpVFRRd01DQTRNREJqTWpJeElEQWdOREF3SUMweE56a2dOREF3SUMwME1EQnpMVEUzT1NBdE5EQXdJQzAwTURBZ0xUUXdNSE10TkRBd0lERTNPU0F0TkRBd0lEUXdNSE14TnprZ05EQXdJRFF3TUNBME1EQjZUVFF3TUNBM01EQjJMVEl3TUdndE16QXdkaTB5TURCb016QXdkaTB5TURCc016QXdJRE13TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVl5SWdkVzVwWTI5a1pUMGlKaU40WlRBd1l6c2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qRWdNQ0EwTURBZ0xURTNPU0EwTURBZ0xUUXdNSE10TVRjNUlDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGM1SUMwME1EQWdOREF3Y3pFM09TQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNR3d0TXpBd0lDMHpNREJvTWpBd2RpMHpNREJvTWpBd2RqTXdNR2d5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01HUTdJaUFLWkQwaVRUTXdNQ0EyTURCMkxUSXdNR2cxTURCMkxURXdNR2d0TlRBd2RpMHlNREJzTFRNd01DQXlORGQ2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1VaUlIVnVhV052WkdVOUlpWWplR1V3TUdVN0lpQUtaRDBpVFRVd01DQTJNREJzTXpBd0lDMHlORGRzTFRNd01DQXRNalV6ZGpJd01HZ3ROVEF3ZGpFd01HZzFNREIyTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSm1JaUIxYm1samIyUmxQU0ltSTNobE1EQm1PeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHlNREFnT0RBd2FESXdNSFl0TlRBd2FESXdNR3d0TWprM0lDMHpNREJzTFRNd015QXpNREJvTWpBd2RqVXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTVRBaUlIVnVhV052WkdVOUlpWWplR1V3TVRBN0lpQUtaRDBpVFRNd01DQTNNREIyTFRJd01HZzFNREIyTFRJd01HZ3ROVEF3ZGkweU1EQnNMVE13TUNBeU9UZDZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakV4SWlCMWJtbGpiMlJsUFNJbUkzaGxNREV4T3lJZ0NtUTlJazAxTURBZ056QXdiRE13TUNBdE1qazNiQzB6TURBZ0xUTXdNM1l5TURCb0xUVXdNSFl5TURCb05UQXdkakl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1USWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01USTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU5qQXdJaUFLWkQwaVRUSTVOeUE0TURCc016QXpJQzB6TURCb0xUSXdNSFl0TlRBd2FDMHlNREIyTlRBd2FDMHlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpFeklpQjFibWxqYjJSbFBTSW1JM2hsTURFek95SWdhRzl5YVhvdFlXUjJMWGc5SWpZd01DSWdDbVE5SWsweU5EY2dPREF3YkRJMU15QXRNekF3YUMweU1EQjJMVFV3TUdndE1UQXdkalV3TUdndE1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l4TkNJZ2RXNXBZMjlrWlQwaUppTjRaVEF4TkRzaUlBcGtQU0pOTkRBd0lEZ3dNR2d4TURCMkxUZ3dNR2d0TVRBd2RqZ3dNSHBOTWpBd0lEY3dNR2d4TURCMkxUWXdNR2d0TVRBd2RqWXdNSHBOTmpBd0lEWXdNR2d4TURCMkxUUXdNR2d0TVRBd2RqUXdNSHBOTUNBMU1EQm9NVEF3ZGkweU1EQm9MVEV3TUhZeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakUxSWlCMWJtbGpiMlJsUFNJbUkzaGxNREUxT3lJZ0NtUTlJazB4TVRZZ05qQXdiRGN5SUMwM01tTXROVFFnTFRVMElDMDRPQ0F0TVRJMklDMDRPQ0F0TWpBNWN6TTBJQzB4TlRrZ09EZ2dMVEl4TTJ3dE56SWdMVGN5WXkwM01pQTNNaUF0TVRFMklERTNOU0F0TVRFMklESTROWE0wTkNBeU1Ea2dNVEUySURJNE1YcE5OamcwSURZd01HTTNNaUF0TnpJZ01URTJJQzB4TnpFZ01URTJJQzB5T0RGekxUUTBJQzB5TVRNZ0xURXhOaUF0TWpnMWJDMDNNaUEzTW1NMU5DQTFOQ0E0T0NBeE16QWdPRGdnTWpFemN5MHpOQ0F4TlRVZ0xUZzRJREl3T1hwTk1qVTVJRFEyTUd3Mk9TQXROekpqTFRFNElDMHhPQ0F0TWpnZ0xUUXhJQzB5T0NBdE5qa0tjekV3SUMwMU5DQXlPQ0F0TnpKc0xUWTVJQzAzTW1NdE16WWdNellnTFRVNUlEZzVJQzAxT1NBeE5EUnpNak1nTVRBMUlEVTVJREUwTVhwTk5UUXhJRFExT1dNek5pQXRNellnTlRrZ0xUZzFJRFU1SUMweE5EQnpMVEl6SUMweE1EZ2dMVFU1SUMweE5EUnNMVFk1SURjeVl6RTRJREU0SURJNElEUTBJREk0SURjeWN5MHhNQ0ExTVNBdE1qZ2dOamw2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpFMklpQjFibWxqYjJSbFBTSW1JM2hsTURFMk95SWdhRzl5YVhvdFlXUjJMWGc5SWpRd01DSWdDbVE5SWsweU1EQWdPREF3WXpFeE1DQXdJREl3TUNBdE9UQWdNakF3SUMweU1EQnpMVGt3SUMweU1EQWdMVEl3TUNBdE1qQXdjeTB5TURBZ09UQWdMVEl3TUNBeU1EQnpPVEFnTWpBd0lESXdNQ0F5TURCNlRURXdNQ0F6TVRsak16RWdMVEV4SURZMUlDMHhPU0F4TURBZ0xURTVjelk0SURnZ01UQXdJREU1ZGkwek1UbHNMVEV3TUNBeE1EQnNMVEV3TUNBdE1UQXdkak14T1hvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1UY2lJSFZ1YVdOdlpHVTlJaVlqZUdVd01UYzdJaUFLWkQwaVRUUXdNQ0E0TURCak1qSXdJREFnTkRBd0lDMHhPREFnTkRBd0lDMDBNREJ6TFRFNE1DQXROREF3SUMwME1EQWdMVFF3TUhNdE5EQXdJREU0TUNBdE5EQXdJRFF3TUhNeE9EQWdOREF3SURRd01DQTBNREI2VFRRd01DQTNNREJqTFRFMk5pQXdJQzB6TURBZ0xURXpOQ0F0TXpBd0lDMHpNREJqTUNBdE5qWWdNakVnTFRFeU5pQTFOaUF0TVRjMWJEUXhPU0EwTVRsakxUUTVJRE0xSUMweE1Ea2dOVFlnTFRFM05TQTFObnBOTmpRMElEVTNOV3d0TkRFNUlDMDBNVGxqTkRrZ0xUTTFJREV3T1NBdE5UWWdNVGMxSUMwMU5tTXhOallnTUNBek1EQWdNVE0wSURNd01DQXpNREFLWXpBZ05qWWdMVEl4SURFeU5pQXROVFlnTVRjMWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhPQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXhPRHNpSUFwa1BTSk5NQ0EzTURCb01UQXdkaTAyTURCb056QXdkaTB4TURCb0xUZ3dNSFkzTURCNlRUVXdNQ0EzTURCb01qQXdkaTAxTURCb0xUSXdNSFkxTURCNlRUSXdNQ0ExTURCb01qQXdkaTB6TURCb0xUSXdNSFl6TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqRTVJaUIxYm1samIyUmxQU0ltSTNobE1ERTVPeUlnQ21ROUlrMHpPVGNnT0RBd1l6RXpJREVnTWpNZ0xUUWdNelFnTFRFell6SWdMVElnTWpFMElDMHlOVFFnTWpReElDMHlPRGRvTVRJNGRpMHhNREJvTFRFd01IWXRNelkyWXpBZ0xURTRJQzB4TmlBdE16UWdMVE0wSUMwek5HZ3ROVE15WXkweE9DQXdJQzB6TkNBeE5pQXRNelFnTXpSMk16WTJhQzB4TURCMk1UQXdhREV5T0d3eU16UWdNamd4WXprZ01URWdNaklnTVRnZ016VWdNVGw2VFRRd01DQTJOekpzTFRFME5DQXRNVGN5YURJNE9IcE5NalV3SURNd01HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEIyTFRFd01HTXdJQzB5T0NBeU1pQXROVEFnTlRBZ0xUVXdjelV3SURJeUlEVXdJRFV3Q25ZeE1EQmpNQ0F5T0NBdE1qSWdOVEFnTFRVd0lEVXdlazAxTlRBZ016QXdZeTB5T0NBd0lDMDFNQ0F0TWpJZ0xUVXdJQzAxTUhZdE1UQXdZekFnTFRJNElESXlJQzAxTUNBMU1DQXROVEJ6TlRBZ01qSWdOVEFnTlRCMk1UQXdZekFnTWpnZ0xUSXlJRFV3SUMwMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTVdFaUlIVnVhV052WkdVOUlpWWplR1V3TVdFN0lpQUtaRDBpVFRrZ056QXdhRFk0TW1NMklEQWdPU0F0TkNBNUlDMHhNSFl0TVRrd2FERXdNSFl0TWpBd2FDMHhNREIyTFRFNU1XTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDJPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJOVGd5WXpBZ05pQXpJRGtnT1NBNWVrMHhNREFnTmpBd2RpMDBNREJvTlRBd2RqUXdNR2d0TlRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhZaUlnZFc1cFkyOWtaVDBpSmlONFpUQXhZanNpSUFwa1BTSk5PU0EzTURCb05qZ3lZellnTUNBNUlDMDBJRGtnTFRFd2RpMHhPVEJvTVRBd2RpMHlNREJvTFRFd01IWXRNVGt4WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRZNE1tTXROaUF3SUMwNUlETWdMVGtnT1hZMU9ESmpNQ0EySURNZ09TQTVJRGw2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpGaklpQjFibWxqYjJSbFBTSW1JM2hsTURGak95SWdDbVE5SWswNU1pQTJOVEJqTUNBeU15QXhPU0ExTUNBME5TQTFNR2d6YURWb05XZzFNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNR2d0TlRCMkxURTBNV001SUMweE55QXhNakFnTFRJek1TQXhOallnTFRNd09XTXhOaUF0TWpZZ016UWdMVFl4SURNMElDMHhNRFpqTUNBdE16a2dMVEUxSUMwM055QXROREVnTFRFd00yZ3RNMk10TWpZZ0xUSTFJQzAyTWlBdE5ERWdMVEV3TUNBdE5ERm9MVFV4TW1NdE16a2dNQ0F0TnpjZ01UVWdMVEV3TXlBME1YTXROREVnTmpRZ0xUUXhJREV3TTJNd0lEUTJJREU0SURnd0lETTBJREV3Tmdwak5EWWdOemdnTVRVM0lESTVNaUF4TmpZZ016QTVkakUwTVdndE5UQmpMVElnTUNBdE5pQXRNU0F0T0NBdE1XTXRNamdnTUNBdE5UQWdNak1nTFRVd0lEVXhlazAxTURBZ05qQXdhQzB5TURCMkxURTJNbXd0TmlBdE1UQnpMVFl6SUMweE1qTWdMVEV4T1NBdE1qSTRhRFExTUdNdE5UWWdNVEExSUMweE1Ua2dNakk0SUMweE1Ua2dNakk0YkMwMklERXdkakUyTW5vaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1XUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01XUTdJaUFLWkQwaVRUUXdNQ0E0TURCak1URXdJREFnTWpBd0lDMDVNQ0F5TURBZ0xUSXdNR013SUMweE1EUWdOVElnTFRFNU9DQXhNelFnTFRJMk5tTTBNU0F0TXpRZ05qWWdMVGd5SURZMklDMHhNelJvTFRnd01HTXdJRFV5SURJMUlERXdNQ0EyTmlBeE16UmpPRElnTmpnZ01UTTBJREUyTWlBeE16UWdNalkyWXpBZ01URXdJRGt3SURJd01DQXlNREFnTWpBd2VrMHpNREFnTVRBd2FESXdNR013SUMwMU5TQXRORFVnTFRFd01DQXRNVEF3SUMweE1EQnpMVEV3TUNBME5TQXRNVEF3SURFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNV1VpSUhWdWFXTnZaR1U5SWlZamVHVXdNV1U3SWlCb2IzSnBlaTFoWkhZdGVEMGlOakF3SWlBS1pEMGlUVEUxTUNBNE1EQm9OVEJzTXpVd0lDMHlOVEJzTFRJeU5TQXRNVFEzYkRJeU5TQXRNVFV6YkMwek5UQWdMVEkxTUdndE5UQjJNalV3YkMwM05TQXROelZzTFRjMUlEYzFiREUxTUNBeE5UQnNMVEUxTUNBeE5UQnNOelVnTnpWc056VWdMVGMxZGpJMU1IcE5NalV3SURZMU1IWXRNakF3YkRFMU1DQXhNREI2VFRJMU1DQXpOVEIyTFRJd01Hd3hOVEFnTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhaaUlnZFc1cFkyOWtaVDBpSmlONFpUQXhaanNpSUFwa1BTSk5NQ0E0TURCb05UQXdZekV4TUNBd0lESXdNQ0F0T1RBZ01qQXdJQzB5TURCak1DQXRORGNnTFRFM0lDMDVNU0F0TkRRZ0xURXlOV000TlNBdE5EQWdNVFEwSUMweE1qVWdNVFEwSUMweU1qVmpNQ0F0TVRNNElDMHhNVElnTFRJMU1DQXRNalV3SUMweU5UQm9MVFUxTUhZeE1EQmpOVFVnTUNBeE1EQWdORFVnTVRBd0lERXdNSFkwTURCak1DQTFOU0F0TkRVZ01UQXdJQzB4TURBZ01UQXdkakV3TUhwTk16QXdJRGN3TUhZdE1qQXdhREV3TUdNMU5TQXdJREV3TUNBME5TQXhNREFnTVRBd2N5MDBOU0F4TURBZ0xURXdNQ0F4TURCb0xURXdNSHBOTXpBd0lEUXdNSFl0TXpBd2FERTFNQXBqT0RNZ01DQXhOVEFnTmpjZ01UVXdJREUxTUhNdE5qY2dNVFV3SUMweE5UQWdNVFV3YUMweE5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakl3SWlCMWJtbGpiMlJsUFNJbUkzaGxNREl3T3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB6TURBZ09EQXdkaTB6TURCb01qQXdiQzB6TURBZ0xUVXdNSFl6TURCb0xUSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTWpFaUlIVnVhV052WkdVOUlpWWplR1V3TWpFN0lpQUtaRDBpVFRFd01DQTRNREJvTXpBd2RpMHpNREJzTVRBd0lERXdNR3d4TURBZ0xURXdNSFl6TURCb05UQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTAxTlRCb0xUVTFNR010TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCek1qSWdMVFV3SURVd0lDMDFNR2cxTlRCMkxURXdNR2d0TlRVd1l5MDRNeUF3SUMweE5UQWdOamNnTFRFMU1DQXhOVEIyTlRVd2JETWdNVGxqT0NBek9TQXpPU0EzTUNBM09DQTNPSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTWpJaUlIVnVhV052WkdVOUlpWWplR1V3TWpJN0lpQm9iM0pwZWkxaFpIWXRlRDBpTkRBd0lpQUtaRDBpVFRBZ09EQXdhRFF3TUhZdE9EQXdiQzB5TURBZ01qQXdiQzB5TURBZ0xUSXdNSFk0TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqSXpJaUIxYm1samIyUmxQU0ltSTNobE1ESXpPeUlnQ21ROUlrMHdJRGd3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1DQTJNREJvTXpBd2RpMHhNRE5vTWpBemRqRXdNMmd5T1RkMkxUVTVNV013SUMwMklDMHpJQzA1SUMwNUlDMDVhQzAzT0RKakxUWWdNQ0F0T1NBeklDMDVJRGwyTlRreGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXlOQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXlORHNpSUFwa1BTSk5NekF3SURnd01HZ3lNREJqTlRVZ01DQXhNREFnTFRRMUlERXdNQ0F0TVRBd2RpMHhNREJvTVRreFl6WWdNQ0E1SUMweklEa2dMVGwyTFRJME1XTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRjd01HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdkakkwTVdNd0lEWWdNeUE1SURrZ09XZ3hPVEYyTVRBd1l6QWdOVFVnTkRVZ01UQXdJREV3TUNBeE1EQjZUVE13TUNBM01EQjJMVEV3TUdneU1EQjJNVEF3YUMweU1EQjZUVEFnTWpBNVl6RTJJQzAySURNeUlDMDVJRFV3SUMwNWFEY3dNR014T0NBd0lETTBJRE1nTlRBZ09YWXRNakF3WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRjNE1ncGpMVFlnTUNBdE9TQXpJQzA1SURsMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l5TlNJZ2RXNXBZMjlrWlQwaUppTjRaVEF5TlRzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTXpBd0lEZ3dNR00xT0NBd0lERXhNQ0F0TVRZZ01UUTNJQzAxTTNNMU15QXRPRGtnTlRNZ0xURTBOMmd0TVRBd1l6QWdNemtnTFRFeElEWXhJQzB5TlNBM05YTXRNellnTWpVZ0xUYzFJREkxWXkwek5TQXdJQzAxTlNBdE1UQWdMVGN5SUMwek1YTXRNamdnTFRVMUlDMHlPQ0F0T1RSak1DQXROVEVnTWpBZ0xURXdOeUF5T0NBdE1UYzFhREUzTW5ZdE1UQXdhQzB4TnpoakxURTBJQzAyTUNBdE5Ea2dMVEV5TnlBdE1URXpJQzB5TURCb05Ea3hkaTB4TURCb0xUWXdNSFl4TWpKc01UWWdNVEpqTmprZ05qa2dPVFVnTVRJeElERXdOaUF4Tmpab0xURXlNbll4TURCb01USTFDbU10T0NBMU1DQXRNalVnTVRBMklDMHlOU0F4TnpWak1DQTFPQ0F4TmlBeE1UUWdOVEFnTVRVMll6TTBJRFF6SURnNElEWTVJREUxTUNBMk9Yb2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNallpSUhWdWFXTnZaR1U5SWlZamVHVXdNalk3SWlBS1pEMGlUVE0wSURjd01HZzBhRE5vTkdnMWFEY3dNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEIyTFRjd01HTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRjd01HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdkamN3TUhZeVl6QWdNakFnTVRVZ05ESWdNelFnTkRoNlRURTFNQ0EyTURCakxUSTRJREFnTFRVd0lDMHlNaUF0TlRBZ0xUVXdjekl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQnpMVEl5SURVd0lDMDFNQ0ExTUhwTk16VXdJRFl3TUdNdE1qZ2dNQ0F0TlRBZ0xUSXlJQzAxTUNBdE5UQnpNaklnTFRVd0lEVXdJQzAxTUdnek1EQmpNamdnTUNBMU1DQXlNaUExTUNBMU1BcHpMVEl5SURVd0lDMDFNQ0ExTUdndE16QXdlazB4TURBZ05EQXdkaTAwTURCb05qQXdkalF3TUdndE5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l5TnlJZ2RXNXBZMjlrWlQwaUppTjRaVEF5TnpzaUlBcGtQU0pOTnpRMElEYzVOMncySUMwemJEUTBJQzAwTkdNMElDMDBJRE1nTFRnZ01DQXRNVEpzTFRJMk5pQXRNemMxYkMweE5TQXRNVE5zTFRJMUlDMHhNbU10TWpNZ056SWdMVGM0SURFeU55QXRNVFV3SURFMU1Hd3hNaUF5Tld3eE15QXhOV3d6TnpVZ01qWTJlazB5TmpZZ05EQXdZemMwSURBZ01UTTBJQzAyTUNBeE16UWdMVEV6TkdNd0lDMHhORGNnTFRFeE9TQXRNalkySUMweU5qWWdMVEkyTm1NdE5EZ2dNQ0F0T1RVZ01USWdMVEV6TkNBek5HTTRNQ0EwTmlBeE16UWdNVE16SURFek5DQXlNekpqTUNBM05DQTFPQ0F4TXpRZ01UTXlJREV6TkhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1qZ2lJSFZ1YVdOdlpHVTlJaVlqZUdVd01qZzdJaUFLWkQwaVRUa2dORFV4WXpBZ01qTWdNVGtnTlRBZ05EWWdOVEJqT0NBd0lERTVJQzB6SURJMklDMDNiREV6TVNBdE5qWnNNamtnTWpKakxUYzVJRGd4SUMweElESTFNQ0F4TVRnZ01qVXdjekU1TnlBdE1UWTNJREV4T1NBdE1qVXdiREk0SUMweU1td3hNekVnTmpaak5pQTBJREV5SURjZ01qRWdOMk15T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJqTUNBdE1UY2dMVEV5SUMwek55QXRNamNnTFRRMWJDMHhNVFVnTFRVMll6a2dMVEUySURFNUlDMHpNeUF5TlNBdE5UQm9OamhqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNR2d0TlRBS1l6QWdMVEl6SUMweUlDMDBOU0F0TmlBdE5qWnNOemdnTFRRd1l6SXhJQzAxSURNM0lDMHlPQ0F6TnlBdE5EbGpNQ0F0TWpnZ0xUSXlJQzAxTUNBdE5UQWdMVFV3WXkweE1DQXdJQzB5TXlBMUlDMHpNU0F4TVd3dE5qVWdNelZqTFRJMElDMDBOaUF0TmpJZ0xUZzJJQzB4TURNZ0xURXhNR010TXpVZ01Ua2dMVFl3SURRMUlDMDJNQ0EzTW5ZeE16VjJOSFkxZGpaMk5YWTFkamczWXpBZ01qZ2dMVEl5SURVd0lDMDFNQ0ExTUdNdE1qUWdNQ0F0TkRVZ0xURTNJQzAxTUNBdE5EQmpNU0F0TXlBeElDMDRJREVnTFRFeGN6QWdMVGdnTFRFZ0xURXhkaTA0TW5ZdE5IWXROWFl0TVRRMENtTXdJQzB5T0NBdE1qUWdMVFV6SUMwMU9TQXROekpqTFRReElESTFJQzAzT1NBMk5DQXRNVEF6SURFeE1Hd3ROallnTFRNMVl5MDRJQzAySUMweU1TQXRNVEVnTFRNeElDMHhNV010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3WXpBZ01qRWdNVFlnTkRRZ016Y2dORGxzTnpnZ05EQmpMVFFnTWpFZ0xUWWdORE1nTFRZZ05qWm9MVFV3YUMwMVl5MHlPQ0F3SUMwMU1DQXlNaUF0TlRBZ05UQmpNQ0F5TmlBeU1pQTFNQ0ExTUNBMU1HZzFhRFk1WXpZZ01UY2dNVFlnTXpRZ01qVWdOVEJzTFRFeE5pQTFObU10TVRZZ055QXRNamdnTWpjZ0xUSTRJRFExZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeU9TSWdkVzVwWTI5a1pUMGlKaU40WlRBeU9Uc2lJQXBrUFNKTk5qQXdJRGN3TUdnNU1XTTJJREFnT1NBdE15QTVJQzA1ZGkwMU9ESmpNQ0F0TmlBdE15QXRPU0F0T1NBdE9XZ3RPVEYyTmpBd2VrMHlNVEFnTlRBemJESTVNQ0F4TkRkMkxUVXdNR3d0TWpVd0lERXlOWFl0TTJNdE1UVWdNQ0F0TWpVZ0xUZ2dMVEk0SUMweU1tdzNOU0F0TVRjNFl6RXhJQzB5TlNBd0lDMDFPQ0F0TWpVZ0xUWTVjeTAxT0NBd0lDMDJPU0F5Tld3dE1UQXpJREkzTW1ndE9URmpMVFlnTUNBdE9TQXpJQzA1SURsMk1UZ3lZekFnTmlBeklEa2dPU0E1YURFNE1ub2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNbUVpSUhWdWFXTnZaR1U5SWlZamVHVXdNbUU3SWlBS1pEMGlUVGtnT0RBd2FEWTRNbU0ySURBZ09TQXRNeUE1SUMwNWRpMDNPREpqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0TmpneVl5MDJJREFnTFRrZ015QXRPU0E1ZGpjNE1tTXdJRFlnTXlBNUlEa2dPWHBOTVRBd0lEY3dNSFl0TWpBd2FEVXdNSFl5TURCb0xUVXdNSHBOTVRBd0lEUXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSHBOTXpBd0lEUXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSHBOTlRBd0lEUXdNSFl0TXpBd2FERXdNSFl6TURCb0xURXdNSHBOTVRBd0lESXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSHBOTXpBd0lESXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTW1JaUlIVnVhV052WkdVOUlpWWplR1V3TW1JN0lpQUtaRDBpVFRBZ09EQXdhRGN3TUhZdE1qQXdhQzAzTURCMk1qQXdlazB3SURVd01HZzNNREIyTFRRNU1XTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDJPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJORGt4ZWsweE1EQWdOREF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWswek1EQWdOREF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWswMU1EQWdOREF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWsweE1EQWdNakF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWswek1EQWdNakF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeVl5SWdkVzVwWTI5a1pUMGlKaU40WlRBeVl6c2lJQXBrUFNKTk5EQTVJRGd3TUdneE9ESmpOaUF3SURFd0lDMDBJREV5SUMwNWJEazBJQzB4T0RKak1pQXROU0EySUMwNUlERXlJQzA1YURneVl6WWdNQ0E1SUMweklEa2dMVGwyTFRVNE1tTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDNPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJORFF4WXpBZ09ETWdOamNnTVRVd0lERTFNQ0F4TlRCb01UUXhZellnTUNBeE1DQTBJREV5SURsc09UUWdNVGd5WXpJZ05TQTJJRGtnTVRJZ09YcE5NVFV3SURVd01HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJ6TWpJZ0xUVXdJRFV3SUMwMU1ITTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2VncE5OVEF3SURVd01HTXRNVEV3SURBZ0xUSXdNQ0F0T1RBZ0xUSXdNQ0F0TWpBd2N6a3dJQzB5TURBZ01qQXdJQzB5TURCek1qQXdJRGt3SURJd01DQXlNREJ6TFRrd0lESXdNQ0F0TWpBd0lESXdNSHBOTlRBd0lEUXdNR00xTlNBd0lERXdNQ0F0TkRVZ01UQXdJQzB4TURCekxUUTFJQzB4TURBZ0xURXdNQ0F0TVRBd2N5MHhNREFnTkRVZ0xURXdNQ0F4TURCek5EVWdNVEF3SURFd01DQXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpKa0lpQjFibWxqYjJSbFBTSW1JM2hsTURKa095SWdDbVE5SWswd0lEWXdNR2c0TURCc0xUUXdNQ0F0TkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXlaU0lnZFc1cFkyOWtaVDBpSmlONFpUQXlaVHNpSUdodmNtbDZMV0ZrZGkxNFBTSTBNREFpSUFwa1BTSk5OREF3SURnd01IWXRPREF3YkMwME1EQWdOREF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeVppSWdkVzVwWTI5a1pUMGlKaU40WlRBeVpqc2lJR2h2Y21sNkxXRmtkaTE0UFNJME1EQWlJQXBrUFNKTk1DQTRNREJzTkRBd0lDMDBNREJzTFRRd01DQXROREF3ZGpnd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNekFpSUhWdWFXTnZaR1U5SWlZamVHVXdNekE3SWlBS1pEMGlUVFF3TUNBMk1EQnNOREF3SUMwME1EQm9MVGd3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU16RWlJSFZ1YVdOdlpHVTlJaVlqZUdVd016RTdJaUFLWkQwaVRUQWdOVFV3WXpBZ01qTWdNakFnTlRBZ05EWWdOVEJvTTJnMWFEUm9NakF3WXpFM0lEQWdNemNnTFRFeklEUTBJQzB5T0d3ek9DQXROekpvTkRRMFl6RTBJREFnTVRrZ0xURXlJREUxSUMweU5Xd3RPREVnTFRJMU1HTXROQ0F0TVRNZ0xUSXhJQzB5TlNBdE16VWdMVEkxYUMwek5UQmpMVEUwSURBZ0xUTXdJREV5SUMwek5DQXlOV010TWpjZ09ETWdMVFUwSURFMk55QXRPREVnTWpVd2JDMHhNQ0F5TldndE1UVXdZeTB5SURBZ0xUVWdMVEVnTFRjZ0xURmpMVEk0SURBZ0xUVXhJREl6SUMwMU1TQTFNWHBOTXpVNElERXdNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEFLY3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazAyTlRnZ01UQXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNeklpSUhWdWFXTnZaR1U5SWlZamVHVXdNekk3SWlBS1pEMGlUVEFnTnpBd2FEVXdNSFl0TVRBd2FDMHpNREIyTFRNd01HZ3RNVEF3YkMweE1EQWdMVEV3TUhZMU1EQjZUVE13TUNBMU1EQm9OVEF3ZGkwMU1EQnNMVEV3TUNBeE1EQm9MVFF3TUhZME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak16SWlCMWJtbGpiMlJsUFNJbUkzaGxNRE16T3lJZ0NtUTlJazAyTkRFZ056QXdiREUwTXlBdE1UUXhiQzAwT1RNZ0xUUTVNMk10TnpFZ056WWdMVEUwTmlBeE5EZ2dMVEl4T1NBeU1qSnNMVGN5SURjeGJERTBNU0F4TkRGak5UQWdMVFV4SURFd01TQXRNVEF4SURFMU15QXRNVFV3WXpFeE5pQXhNVGNnTWpNMElESXpNU0F6TkRjZ016VXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6TkNJZ2RXNXBZMjlrWlQwaUppTjRaVEF6TkRzaUlBcGtQU0pOTVRVd0lEWXdNR3d5TlRBZ0xUSTFNR3d5TlRBZ01qVXdiREUxTUNBdE1UVXdiQzAwTURBZ0xUUXdNR3d0TkRBd0lEUXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTXpVaUlIVnVhV052WkdVOUlpWWplR1V3TXpVN0lpQm9iM0pwZWkxaFpIWXRlRDBpTmpBd0lpQUtaRDBpVFRRd01DQTRNREJzTVRVd0lDMHhOVEJzTFRJMU1DQXRNalV3YkRJMU1DQXRNalV3YkMweE5UQWdMVEUxTUd3dE5EQXdJRFF3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU16WWlJSFZ1YVdOdlpHVTlJaVlqZUdVd016WTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU5qQXdJaUFLWkQwaVRURTFNQ0E0TURCc05EQXdJQzAwTURCc0xUUXdNQ0F0TkRBd2JDMHhOVEFnTVRVd2JESTFNQ0F5TlRCc0xUSTFNQ0F5TlRCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqTTNJaUIxYm1samIyUmxQU0ltSTNobE1ETTNPeUlnQ21ROUlrMDBNREFnTmpBd2JEUXdNQ0F0TkRBd2JDMHhOVEFnTFRFMU1Hd3RNalV3SURJMU1Hd3RNalV3SUMweU5UQnNMVEUxTUNBeE5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak00SWlCMWJtbGpiMlJsUFNJbUkzaGxNRE00T3lJZ0NtUTlJazAwTURBZ09EQXdZekl5TVNBd0lEUXdNQ0F0TVRjNUlEUXdNQ0F0TkRBd2N5MHhOemtnTFRRd01DQXROREF3SUMwME1EQnpMVFF3TUNBeE56a2dMVFF3TUNBME1EQnpNVGM1SURRd01DQTBNREFnTkRBd2VrMDJNREFnTmpJeWJDMHlOVEFnTFRJMU1Hd3RNVEF3SURFd01Hd3ROeklnTFRjeWJERTNNaUF0TVRjeWJETXlNaUF6TWpKNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqTTVJaUIxYm1samIyUmxQU0ltSTNobE1ETTVPeUlnQ21ROUlrMDBNREFnT0RBd1l6SXlNU0F3SURRd01DQXRNVGM1SURRd01DQXROREF3Y3kweE56a2dMVFF3TUNBdE5EQXdJQzAwTURCekxUUXdNQ0F4TnprZ0xUUXdNQ0EwTURCek1UYzVJRFF3TUNBME1EQWdOREF3ZWsweU5UQWdOakl5YkMwM01pQXROekpzTVRVd0lDMHhOVEJzTFRFMU1DQXRNVFV3YkRjeUlDMDNNbXd4TlRBZ01UVXdiREUxTUNBdE1UVXdiRGN5SURjeWJDMHhOVEFnTVRVd2JERTFNQ0F4TlRCc0xUY3lJRGN5YkMweE5UQWdMVEUxTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU0yRWlJSFZ1YVdOdlpHVTlJaVlqZUdVd00yRTdJaUFLWkQwaVRUTTFNQ0E0TURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2RpMDFNR2czTldNeE5DQXdJREkxSUMweE1TQXlOU0F0TWpWMkxUYzFhQzB6TURCMk56VmpNQ0F4TkNBeE1TQXlOU0F5TlNBeU5XZzNOWFkxTUdNd0lESTRJREl5SURVd0lEVXdJRFV3ZWsweU5TQTNNREJvTnpWMkxUSXdNR2cxTURCMk1qQXdhRGMxWXpFMElEQWdNalVnTFRFeElESTFJQzB5TlhZdE5qVXdZekFnTFRFMElDMHhNU0F0TWpVZ0xUSTFJQzB5TldndE5qVXdZeTB4TkNBd0lDMHlOU0F4TVNBdE1qVWdNalYyTmpVd1l6QWdNVFFnTVRFZ01qVWdNalVnTWpWNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqTmlJaUIxYm1samIyUmxQU0ltSTNobE1ETmlPeUlnQ21ROUlrMDBNREFnT0RBd1l6SXlNQ0F3SURRd01DQXRNVGd3SURRd01DQXROREF3Y3kweE9EQWdMVFF3TUNBdE5EQXdJQzAwTURCekxUUXdNQ0F4T0RBZ0xUUXdNQ0EwTURCek1UZ3dJRFF3TUNBME1EQWdOREF3ZWswME1EQWdOekF3WXkweE5qWWdNQ0F0TXpBd0lDMHhNelFnTFRNd01DQXRNekF3Y3pFek5DQXRNekF3SURNd01DQXRNekF3Y3pNd01DQXhNelFnTXpBd0lETXdNSE10TVRNMElETXdNQ0F0TXpBd0lETXdNSHBOTXpVd0lEWXdNR2d4TURCMkxURTRNV015TXlBdE1qUWdORGNnTFRRM0lEY3lJQzAyT1d3dE56SWdMVGN5WXkweU55QXpNQ0F0TlRVZ05Ua2dMVGcwSURnNGJDMHhOaUF4TWdwMk1qSXllaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6WXlJZ2RXNXBZMjlrWlQwaUppTjRaVEF6WXpzaUlBcGtQU0pOTkRVd0lEZ3dNR014TXpnZ01DQXlOVEFnTFRFeE1pQXlOVEFnTFRJMU1IWXROVEJqTlRnZ0xUSXhJREV3TUNBdE9EVWdNVEF3SUMweE5UQmpNQ0F0TVRnZ0xUTWdMVE0wSUMwNUlDMDFNR2d0TVRreGRqVXdZekFnT0RNZ0xUWTNJREUxTUNBdE1UVXdJREUxTUhNdE1UVXdJQzAyTnlBdE1UVXdJQzB4TlRCMkxUVXdhQzB5TnpKakxURTNJRE13SUMweU9DQTJNeUF0TWpnZ01UQXdZekFnTVRFd0lEa3dJREl3TUNBeU1EQWdNakF3WXpJeklERXhOQ0F4TWprZ01qQXdJREkxTUNBeU1EQjZUVFF6TkNBME1EQm9NMmcwWXpNZ01DQTJJREVnT1NBeFl6STRJREFnTlRBZ0xUSXlJRFV3SUMwMU1IWXRNUXAyTFRFMU1HZ3hOVEJzTFRJd01DQXRNakF3YkMweU1EQWdNakF3YURFMU1IWXhOVEIyTW1Nd0lESXdJREUxSURReUlETTBJRFE0ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJelpDSWdkVzVwWTI5a1pUMGlKaU40WlRBelpEc2lJQXBrUFNKTk5EVXdJRGd3TUdNeE16Z2dNQ0F5TlRBZ0xURXhNaUF5TlRBZ0xUSTFNSFl0TlRCak5UZ2dMVEl4SURFd01DQXRPRFVnTVRBd0lDMHhOVEJqTUNBdE1UZ2dMVE1nTFRNMElDMDVJQzAxTUdndE1UUXhiQzB5TURBZ01qQXdiQzB5TURBZ0xUSXdNR2d0TWpJeVl5MHhOeUF6TUNBdE1qZ2dOak1nTFRJNElERXdNR013SURFeE1DQTVNQ0F5TURBZ01qQXdJREl3TUdNeU15QXhNVFFnTVRJNUlESXdNQ0F5TlRBZ01qQXdlazAwTlRBZ016VXdiREkxTUNBdE1qVXdhQzB5TURCMkxUVXdZekFnTFRJNElDMHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdkalV3YUMweU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak5sSWlCMWJtbGpiMlJsUFNJbUkzaGxNRE5sT3lJZ0NtUTlJazAwTlRBZ056QXdZekV6T0NBd0lESTFNQ0F0TVRFeUlESTFNQ0F0TWpVd2RpMDFNR00xT0NBdE1qRWdNVEF3SUMwNE5TQXhNREFnTFRFMU1HTXdJQzA0TXlBdE5qY2dMVEUxTUNBdE1UVXdJQzB4TlRCb0xUUTFNR010TVRFd0lEQWdMVEl3TUNBNU1DQXRNakF3SURJd01ITTVNQ0F5TURBZ01qQXdJREl3TUdNeU15QXhNVFFnTVRJNUlESXdNQ0F5TlRBZ01qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6WmlJZ2RXNXBZMjlrWlQwaUppTjRaVEF6WmpzaUlBcGtQU0pOTWpVd0lEZ3dNR000TWlBd0lERTFOQ0F0TkRBZ01qQXdJQzB4TURCakxURTBNeUF3SUMweU56QWdMVGcxSUMwek1qVWdMVEl3T1dNdE16WWdMVEV3SUMwM01DQXRNalVnTFRFd01DQXRORGRqTFRFMklETXpJQzB5TlNBMk55QXRNalVnTVRBMll6QWdNVE00SURFeE1pQXlOVEFnTWpVd0lESTFNSHBOTkRVd0lEWXdNR014TXpnZ01DQXlOVEFnTFRFeE1pQXlOVEFnTFRJMU1IWXROVEJqTlRnZ0xUSXhJREV3TUNBdE9EVWdNVEF3SUMweE5UQmpNQ0F0T0RNZ0xUWTNJQzB4TlRBZ0xURTFNQ0F0TVRVd2FDMDBOVEJqTFRFeE1DQXdJQzB5TURBZ09UQWdMVEl3TUNBeU1EQUtjemt3SURJd01DQXlNREFnTWpBd1l6SXpJREV4TkNBeE1qa2dNakF3SURJMU1DQXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpRd0lpQjFibWxqYjJSbFBTSW1JM2hsTURRd095SWdDbVE5SWswMU1EQWdOekF3YURFd01Hd3RNekF3SUMwMk1EQm9MVEV3TUhwTk1UQXdJRFl3TUdneE1EQnNMVEV3TUNBdE1qQXdiREV3TUNBdE1qQXdhQzB4TURCc0xURXdNQ0F5TURCNlRUWXdNQ0EyTURCb01UQXdiREV3TUNBdE1qQXdiQzB4TURBZ0xUSXdNR2d0TVRBd2JERXdNQ0F5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqUXhJaUIxYm1samIyUmxQU0ltSTNobE1EUXhPeUlnQ21ROUlrMHpOVEFnT0RBd2FERXdNR3cxTUNBdE1URTViREk0SUMweE1td3hNVGtnTlRCc056SWdMVGN5YkMwMU1DQXRNVEU1YkRFeUlDMHlPR3d4TVRrZ0xUVXdkaTB4TURCc0xURXhPU0F0TlRCc0xURXlJQzB5T0d3MU1DQXRNVEU1YkMwM01pQXROekpzTFRFeE9TQTFNR3d0TWpnZ0xURXliQzAxTUNBdE1URTVhQzB4TURCc0xUVXdJREV4T1d3dE1qZ2dNVEpzTFRFeE9TQXROVEJzTFRjeUlEY3liRFV3SURFeE9Xd3RNVElnTWpoc0xURXhPU0ExTUhZeE1EQnNNVEU1SURVd2JERXlJREk0YkMwMU1DQXhNVGxzTnpJZ056SnNNVEU1SUMwMU1Hd3lPQ0F4TW5wTk5EQXdJRFUxTUFwakxUZ3pJREFnTFRFMU1DQXROamNnTFRFMU1DQXRNVFV3Y3pZM0lDMHhOVEFnTVRVd0lDMHhOVEJ6TVRVd0lEWTNJREUxTUNBeE5UQnpMVFkzSURFMU1DQXRNVFV3SURFMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlORElpSUhWdWFXTnZaR1U5SWlZamVHVXdOREk3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TWpBd2FDMDRNREIyTWpBd2VrMHlNREFnTlRBd2FEUXdNR3d0TWpBd0lDMHlNREI2VFRBZ01UQXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kwTXlJZ2RXNXBZMjlrWlQwaUppTjRaVEEwTXpzaUlBcGtQU0pOTUNBNE1EQm9NVEF3ZGkwNE1EQm9MVEV3TUhZNE1EQjZUVFl3TUNBNE1EQm9NakF3ZGkwNE1EQm9MVEl3TUhZNE1EQjZUVFV3TUNBMk1EQjJMVFF3TUd3dE1qQXdJREl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5EUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05EUTdJaUFLWkQwaVRUQWdPREF3YURJd01IWXRPREF3YUMweU1EQjJPREF3ZWswM01EQWdPREF3YURFd01IWXRPREF3YUMweE1EQjJPREF3ZWswek1EQWdOakF3YkRJd01DQXRNakF3YkMweU1EQWdMVEl3TUhZME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalExSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFExT3lJZ0NtUTlJazB3SURnd01HZzRNREIyTFRFd01HZ3RPREF3ZGpFd01IcE5OREF3SURVd01Hd3lNREFnTFRJd01HZ3ROREF3ZWswd0lESXdNR2c0TURCMkxUSXdNR2d0T0RBd2RqSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTkRZaUlIVnVhV052WkdVOUlpWWplR1V3TkRZN0lpQUtaRDBpVFRFMU1DQTNNREJqT0RNZ01DQXhOVEFnTFRZM0lERTFNQ0F0TVRVd2RpMDFNR2d4TURCMk5UQmpNQ0E0TXlBMk55QXhOVEFnTVRVd0lERTFNSE14TlRBZ0xUWTNJREUxTUNBdE1UVXdjeTAyTnlBdE1UVXdJQzB4TlRBZ0xURTFNR2d0TlRCMkxURXdNR2cxTUdNNE15QXdJREUxTUNBdE5qY2dNVFV3SUMweE5UQnpMVFkzSUMweE5UQWdMVEUxTUNBdE1UVXdjeTB4TlRBZ05qY2dMVEUxTUNBeE5UQjJOVEJvTFRFd01IWXROVEJqTUNBdE9ETWdMVFkzSUMweE5UQWdMVEUxTUNBdE1UVXdjeTB4TlRBZ05qY2dMVEUxTUNBeE5UQnpOamNnTVRVd0lERTFNQ0F4TlRCb05UQjJNVEF3YUMwMU1BcGpMVGd6SURBZ0xURTFNQ0EyTnlBdE1UVXdJREUxTUhNMk55QXhOVEFnTVRVd0lERTFNSHBOTVRVd0lEWXdNR010TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCek1qSWdMVFV3SURVd0lDMDFNR2cxTUhZMU1HTXdJREk0SUMweU1pQTFNQ0F0TlRBZ05UQjZUVFUxTUNBMk1EQmpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3ZGkwMU1HZzFNR015T0NBd0lEVXdJREl5SURVd0lEVXdjeTB5TWlBMU1DQXROVEFnTlRCNlRUTXdNQ0EwTURCMkxURXdNR2d4TURCMk1UQXdhQzB4TURCNlRURTFNQ0F5TURCakxUSTRJREFnTFRVd0lDMHlNaUF0TlRBZ0xUVXdjekl5SUMwMU1DQTFNQ0F0TlRBS2N6VXdJREl5SURVd0lEVXdkalV3YUMwMU1IcE5OVEF3SURJd01IWXROVEJqTUNBdE1qZ2dNaklnTFRVd0lEVXdJQzAxTUhNMU1DQXlNaUExTUNBMU1ITXRNaklnTlRBZ0xUVXdJRFV3YUMwMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlORGNpSUhWdWFXTnZaR1U5SWlZamVHVXdORGM3SWlBS1pEMGlUVEFnTnpreFl6QWdOU0EwSURrZ09TQTVhRGM0TW1NMklEQWdPU0F0TkNBNUlDMHhNSFl0Tnprd2JDMHlNREFnTWpBd2FDMDFPVEZqTFRZZ01DQXRPU0F6SUMwNUlEbDJOVGd5ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJME9DSWdkVzVwWTI5a1pUMGlKaU40WlRBME9Ec2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qQWdNQ0EwTURBZ0xURTRNQ0EwTURBZ0xUUXdNSE10TVRnd0lDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGd3SUMwME1EQWdOREF3Y3pFNE1DQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNR010TVRZMklEQWdMVE13TUNBdE1UTTBJQzB6TURBZ0xUTXdNSE14TXpRZ0xUTXdNQ0F6TURBZ0xUTXdNSE16TURBZ01UTTBJRE13TUNBek1EQnpMVEV6TkNBek1EQWdMVE13TUNBek1EQjZUVFl3TUNBMk1EQnNMVEV3TUNBdE16QXdiQzB6TURBZ0xURXdNR3d4TURBZ016QXdlazAwTURBZ05EVXdZeTB5T0NBd0lDMDFNQ0F0TWpJZ0xUVXdJQzAxTUFwek1qSWdMVFV3SURVd0lDMDFNSE0xTUNBeU1pQTFNQ0ExTUhNdE1qSWdOVEFnTFRVd0lEVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kwT1NJZ2RXNXBZMjlrWlQwaUppTjRaVEEwT1RzaUlBcGtQU0pOTkRBd0lEZ3dNR015TWpBZ01DQTBNREFnTFRFNE1DQTBNREFnTFRRd01ITXRNVGd3SUMwME1EQWdMVFF3TUNBdE5EQXdjeTAwTURBZ01UZ3dJQzAwTURBZ05EQXdjekU0TUNBME1EQWdOREF3SURRd01IcE5OREF3SURjd01IWXROakF3WXpFMk5pQXdJRE13TUNBeE16UWdNekF3SURNd01ITXRNVE0wSURNd01DQXRNekF3SURNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOR0VpSUhWdWFXTnZaR1U5SWlZamVHVXdOR0U3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJRFl3TUdnMU1EQjJMVEV3TUdndE5UQXdkakV3TUhwTk1DQXpNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRBZ01UQXdhRFl3TUhZdE1UQXdhQzAyTURCMk1UQXdlazAzTlRBZ01UQXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOR0lpSUhWdWFXTnZaR1U5SWlZamVHVXdOR0k3SWlBS1pEMGlUVEkxSURjd01HZzNOVEJqTVRRZ01DQXlOU0F0TVRFZ01qVWdMVEkxZGkwM05XZ3RPREF3ZGpjMVl6QWdNVFFnTVRFZ01qVWdNalVnTWpWNlRUQWdOVEF3YURnd01IWXRNemMxWXpBZ0xURTBJQzB4TVNBdE1qVWdMVEkxSUMweU5XZ3ROelV3WXkweE5DQXdJQzB5TlNBeE1TQXRNalVnTWpWMk16YzFlazB4TURBZ016QXdkaTB4TURCb01UQXdkakV3TUdndE1UQXdlazB6TURBZ016QXdkaTB4TURCb01UQXdkakV3TUdndE1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kwWXlJZ2RXNXBZMjlrWlQwaUppTjRaVEEwWXpzaUlBcGtQU0pOTVRBd0lEZ3dNR2d4TURCMkxURXdNR2cwTlRCc01UQXdJREV3TUd3MU1DQXROVEJzTFRFd01DQXRNVEF3ZGkwME5UQm9NVEF3ZGkweE1EQm9MVEV3TUhZdE1UQXdhQzB4TURCMk1UQXdhQzAxTURCMk5UQXdhQzB4TURCMk1UQXdhREV3TUhZeE1EQjZUVEl3TUNBMk1EQjJMVE0xTUd3ek5UQWdNelV3YUMwek5UQjZUVFl3TUNBMU5UQnNMVE0xTUNBdE16VXdhRE0xTUhZek5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalJrSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFJrT3lJZ0NtUTlJazAwTURBZ09EQXdZekl5TUNBd0lEUXdNQ0F0TVRnd0lEUXdNQ0F0TkRBd2N5MHhPREFnTFRRd01DQXROREF3SUMwME1EQnpMVFF3TUNBeE9EQWdMVFF3TUNBME1EQnpNVGd3SURRd01DQTBNREFnTkRBd2VrMDBNREFnTnpBd1l5MHhOallnTUNBdE16QXdJQzB4TXpRZ0xUTXdNQ0F0TXpBd2N6RXpOQ0F0TXpBd0lETXdNQ0F0TXpBd2N6TXdNQ0F4TXpRZ016QXdJRE13TUhNdE1UTTBJRE13TUNBdE16QXdJRE13TUhwTk5EQXdJRFl3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCekxUSXlJQzAxTUNBdE5UQWdMVFV3Y3kwMU1DQXlNaUF0TlRBZ05UQnpNaklnTlRBZ05UQWdOVEI2Q2sweU1EQWdORFV5WXpBZ01qQWdNVFVnTkRJZ016UWdORGhvTTJnemFEaGpNVElnTUNBeU9DQXROeUF6TmlBdE1UWnNPVEVnTFRrd2JESTFJRFpqTlRVZ01DQXhNREFnTFRRMUlERXdNQ0F0TVRBd2N5MDBOU0F0TVRBd0lDMHhNREFnTFRFd01ITXRNVEF3SURRMUlDMHhNREFnTVRBd2JEWWdNalZzTFRrd0lEa3hZeTA1SURnZ0xURTJJREkwSUMweE5pQXpObnBOTlRVd0lEVXdNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJ6TFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCek1qSWdOVEFnTlRBZ05UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalJsSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFJsT3lJZ0NtUTlJazB6TURBZ09EQXdhREl3TUhZdE16QXdhREl3TUd3dE16QXdJQzB6TURCc0xUTXdNQ0F6TURCb01qQXdkak13TUhwTk1DQXhNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpSbUlpQjFibWxqYjJSbFBTSW1JM2hsTURSbU95SWdDbVE5SWswd0lEZ3dNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTkRBd0lEWXdNR3d6TURBZ0xUTXdNR2d0TWpBd2RpMHpNREJvTFRJd01IWXpNREJvTFRJd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOVEFpSUhWdWFXTnZaR1U5SWlZamVHVXdOVEE3SWlBS1pEMGlUVEl3TUNBM01EQm9OakF3ZGkwMk1EQm9MVFl3TUd3dE1qQXdJRE13TUhwTk16VXdJRFl5TW13dE56SWdMVGN5YkRFMU1DQXRNVFV3YkMweE5UQWdMVEUxTUd3M01pQXROekpzTVRVd0lERTFNR3d4TlRBZ0xURTFNR3czTWlBM01td3RNVFV3SURFMU1Hd3hOVEFnTVRVd2JDMDNNaUEzTW13dE1UVXdJQzB4TlRCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqVXhJaUIxYm1samIyUmxQU0ltSTNobE1EVXhPeUlnQ21ROUlrMDBNREFnTnpBd1l6SXlNQ0F3SURRd01DQXRNVGd3SURRd01DQXROREF3YUMweE1EQmpNQ0F4TmpZZ0xURXpOQ0F6TURBZ0xUTXdNQ0F6TURCekxUTXdNQ0F0TVRNMElDMHpNREFnTFRNd01HZ3RNVEF3WXpBZ01qSXdJREU0TUNBME1EQWdOREF3SURRd01IcE5NelF4SURRNU1XdzFPU0F0T0Roc05Ua2dPRGhqT0RFZ0xUSTFJREUwTVNBdE1UQXhJREUwTVNBdE1Ua3hZekFnTFRFeE1DQXRPVEFnTFRJd01DQXRNakF3SUMweU1EQnpMVEl3TUNBNU1DQXRNakF3SURJd01HTXdJRGt3SURZd0lERTJOaUF4TkRFZ01Ua3hlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxTWlJZ2RXNXBZMjlrWlQwaUppTjRaVEExTWpzaUlBcGtQU0pOTUNBNE1EQm9NekF3ZGkwME1EQm9OREF3ZGkwME1EQm9MVGN3TUhZNE1EQjZUVFF3TUNBNE1EQnNNekF3SUMwek1EQm9MVE13TUhZek1EQjZUVEV3TUNBMk1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVEV3TUNBME1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVEV3TUNBeU1EQjJMVEV3TUdnME1EQjJNVEF3YUMwME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalV6SWlCMWJtbGpiMlJsUFNJbUkzaGxNRFV6T3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB5TURBZ056QXdhREV3TUhZdE1UQXdhRGMxWXpNd0lEQWdOVGdnTFRZZ09ERWdMVEl5Y3pRMElDMDBOQ0EwTkNBdE56aDJMVEV3TUdndE1UQXdkamswWXkwMElETWdMVEV6SURZZ0xUSTFJRFpvTFRJMU1HTXRNVFFnTUNBdE1qVWdMVEV4SUMweU5TQXRNalYyTFRVd1l6QWdMVEUxSURJd0lDMDBNQ0F6TkNBdE5EUnNNalUzSUMwMk5XTTJOaUF0TVRZZ01UQTVJQzAzTXlBeE1Ea2dMVEUwTVhZdE5UQmpNQ0F0TmpnZ0xUVTNJQzB4TWpVZ0xURXlOU0F0TVRJMWFDMDNOWFl0TVRBd2FDMHhNREIyTVRBd2FDMDNOV010TXpBZ01DQXROVGdnTmlBdE9ERWdNakp6TFRRMElEUTBJQzAwTkNBM09BcDJNVEF3YURFd01IWXRPVFJqTkNBdE15QXhNeUF0TmlBeU5TQXRObWd5TlRCak1UUWdNQ0F5TlNBeE1TQXlOU0F5TlhZMU1HTXdJREUxSUMweU1DQTBNQ0F0TXpRZ05EUnNMVEkxTnlBMk5XTXROallnTVRZZ0xURXdPU0EzTXlBdE1UQTVJREUwTVhZMU1HTXdJRFk0SURVM0lERXlOU0F4TWpVZ01USTFhRGMxZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOVFFpSUhWdWFXTnZaR1U5SWlZamVHVXdOVFE3SWlBS1pEMGlUVEFnTnpBd2FETXdNSFl0TXpBd2JDMHpNREFnTFRNd01IWTJNREI2VFRVd01DQTNNREJvTXpBd2RpMHpNREJzTFRNd01DQXRNekF3ZGpZd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOVFVpSUhWdWFXTnZaR1U5SWlZamVHVXdOVFU3SWlBS1pEMGlUVE13TUNBM01EQjJMVFl3TUdndE16QXdkak13TUhwTk9EQXdJRGN3TUhZdE5qQXdhQzB6TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxTmlJZ2RXNXBZMjlrWlQwaUppTjRaVEExTmpzaUlBcGtQU0pOTXpBd0lEY3dNSFl0TVRBd1l5MHhNVEVnTUNBdE1qQXdJQzA0T1NBdE1qQXdJQzB5TURCb01qQXdkaTB6TURCb0xUTXdNSFl6TURCak1DQXhOalVnTVRNMUlETXdNQ0F6TURBZ016QXdlazA0TURBZ056QXdkaTB4TURCakxURXhNU0F3SUMweU1EQWdMVGc1SUMweU1EQWdMVEl3TUdneU1EQjJMVE13TUdndE16QXdkak13TUdNd0lERTJOU0F4TXpVZ016QXdJRE13TUNBek1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalUzSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFUzT3lJZ0NtUTlJazB3SURjd01HZ3pNREIyTFRNd01HTXdJQzB4TmpVZ0xURXpOU0F0TXpBd0lDMHpNREFnTFRNd01IWXhNREJqTVRFeElEQWdNakF3SURnNUlESXdNQ0F5TURCb0xUSXdNSFl6TURCNlRUVXdNQ0EzTURCb016QXdkaTB6TURCak1DQXRNVFkxSUMweE16VWdMVE13TUNBdE16QXdJQzB6TURCMk1UQXdZekV4TVNBd0lESXdNQ0E0T1NBeU1EQWdNakF3YUMweU1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMU9DSWdkVzVwWTI5a1pUMGlKaU40WlRBMU9Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16QXdJRGd3TUd3ek5DQXRNelJqTVRFZ0xURXhJREkyTmlBdE1qY3dJREkyTmlBdE5EZzRZekFnTFRFMk5TQXRNVE0xSUMwek1EQWdMVE13TUNBdE16QXdjeTB6TURBZ01UTTFJQzB6TURBZ016QXdZekFnTWpFNElESTFOU0EwTnpjZ01qWTJJRFE0T0hwTk1UVXdJRE15T0dNdE1qZ2dNQ0F0TlRBZ0xUSXlJQzAxTUNBdE5UQmpNQ0F0TVRFd0lEa3dJQzB5TURBZ01qQXdJQzB5TURCak1qZ2dNQ0ExTUNBeU1pQTFNQ0ExTUhNdE1qSWdOVEFnTFRVd0lEVXdZeTAxTlNBd0lDMHhNREFnTkRVZ0xURXdNQ0F4TURCak1DQXlPQ0F0TWpJZ05UQWdMVFV3SURVd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTFPU0lnZFc1cFkyOWtaVDBpSmlONFpUQTFPVHNpSUFwa1BTSk5OREF3SURnd01HdzBNREFnTFRVd01HZ3RPREF3ZWswd0lESXdNR2c0TURCMkxUSXdNR2d0T0RBd2RqSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTldFaUlIVnVhV052WkdVOUlpWWplR1V3TldFN0lpQm9iM0pwZWkxaFpIWXRlRDBpTmpBd0lpQUtaRDBpVFRNd01DQTRNREJzTXpBd0lDMHpNREJvTFRZd01IcE5NQ0F6TURCb05qQXdiQzB6TURBZ0xUTXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTldJaUlIVnVhV052WkdVOUlpWWplR1V3TldJN0lpQUtaRDBpVFRBZ05UQXdhREl3TUhZdE1qQXdhQzB5TURCMk1qQXdlazB6TURBZ05UQXdhREl3TUhZdE1qQXdhQzB5TURCMk1qQXdlazAyTURBZ05UQXdhREl3TUhZdE1qQXdhQzB5TURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxWXlJZ2RXNXBZMjlrWlQwaUppTjRaVEExWXpzaUlBcGtQU0pOTUNBM01EQm9PREF3ZGkweE1EQnNMVFF3TUNBdE1qQXdiQzAwTURBZ01qQXdkakV3TUhwTk1DQTFNREJzTkRBd0lDMHlNREJzTkRBd0lESXdNSFl0TkRBd2FDMDRNREIyTkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTFaQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTFaRHNpSUFwa1BTSk5OREF3SURnd01HdzBNREFnTFRJd01IWXROakF3YUMwNE1EQjJOakF3ZWswME1EQWdOamc0YkMwek1EQWdMVEUxTUhZdE1UZzRiRE13TUNBdE1UVXdiRE13TUNBeE5UQjJNVGc0ZWsweU1EQWdOVEF3YURRd01IWXRNVEF3YkMweU1EQWdMVEV3TUd3dE1qQXdJREV3TUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalZsSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFZsT3lJZ0NtUTlJazAyTURBZ056QXdZelk1SURBZ01UTTBJQzB4T1NBeE9URWdMVFV3YkMweE5pQXRNVEEyWXkwME9TQXpOU0F0TVRBNUlEVTJJQzB4TnpVZ05UWmpMVEV6TVNBd0lDMHlOREFnTFRnMElDMHlPREVnTFRJd01HZ3pNekZzTFRFMklDMHhNREJvTFRNek5HTXdJQzB6TmlBNElDMDJPQ0F4T1NBdE1UQXdhREk1TjJ3dE1UWWdMVEV3TUdndE1qSXlZelUxSUMwMk1TQXhNek1nTFRFd01DQXlNaklnTFRFd01HTTNPQ0F3SURFME55QXpNQ0F5TURBZ056aDJMVEV5TW1NdE5Ua2dMVE0xSUMweE1qY2dMVFUySUMweU1EQWdMVFUyWXkweE5EY2dNQ0F0TWpjMElEZ3lJQzB6TkRRZ01qQXdhQzB5TlRZS2JERTVJREV3TUdneE9UZGpMVGdnTXpJZ0xURTJJRFkySUMweE5pQXhNREJvTFRJd01Hd3lOU0F4TURCb01Ua3hZelExSURFM01pQXhPVGdnTXpBd0lETTROQ0F6TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqVm1JaUIxYm1samIyUmxQU0ltSTNobE1EVm1PeUlnQ21ROUlrMHdJRGN3TUdnM01EQjJMVEV3TUdndE56QXdkakV3TUhwTk1DQTFNREJvTlRBd2RpMHhNREJvTFRVd01IWXhNREI2VFRBZ016QXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB3SURFd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5NakF3SURFd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5OREF3SURFd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOakFpSUhWdWFXTnZaR1U5SWlZamVHVXdOakE3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHlNREFnTmpBd2FEUXdNR3d0TWpBd0lDMHlNREI2VFRBZ01qQXdhRGd3TUhZdE1qQXdhQzA0TURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kyTVNJZ2RXNXBZMjlrWlQwaUppTjRaVEEyTVRzaUlBcGtQU0pOTUNBNE1EQm9NVEF3ZGkwNE1EQm9MVEV3TUhZNE1EQjZUVFl3TUNBNE1EQm9NakF3ZGkwNE1EQm9MVEl3TUhZNE1EQjZUVEl3TUNBMk1EQnNNakF3SUMweU1EQnNMVEl3TUNBdE1qQXdkalF3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5qSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05qSTdJaUFLWkQwaVRUQWdPREF3YURJd01IWXRPREF3YUMweU1EQjJPREF3ZWswM01EQWdPREF3YURFd01IWXRPREF3YUMweE1EQjJPREF3ZWswMk1EQWdOakF3ZGkwME1EQnNMVEl3TUNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJall6SWlCMWJtbGpiMlJsUFNJbUkzaGxNRFl6T3lJZ0NtUTlJazB3SURnd01HZzRNREIyTFRJd01HZ3RPREF3ZGpJd01IcE5OREF3SURRd01Hd3lNREFnTFRJd01HZ3ROREF3ZWswd0lERXdNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTmpRaUlIVnVhV052WkdVOUlpWWplR1V3TmpRN0lpQUtaRDBpVFRBZ09EQXdhREl3TUhZdE1UQXdhQzB4TURCMkxUWXdNR2cyTURCMk1UQXdhREV3TUhZdE1qQXdhQzA0TURCMk9EQXdlazAwTURBZ09EQXdhRFF3TUhZdE5EQXdiQzB4TlRBZ01UVXdiQzB5TlRBZ0xUSTFNR3d0TVRBd0lERXdNR3d5TlRBZ01qVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kyTlNJZ2RXNXBZMjlrWlQwaUppTjRaVEEyTlRzaUlBcGtQU0pOTkRBeklEY3dNR015TkRjZ01DQXpPVGNnTFRNd01DQXpPVGNnTFRNd01ITXRNVFV3SUMwek1EQWdMVE01TnlBdE16QXdZeTB5TlRNZ01DQXROREF6SURNd01DQXROREF6SURNd01ITXhOVEFnTXpBd0lEUXdNeUF6TURCNlRUUXdNQ0EyTURCakxURXhNQ0F3SUMweU1EQWdMVGt3SUMweU1EQWdMVEl3TUhNNU1DQXRNakF3SURJd01DQXRNakF3Y3pJd01DQTVNQ0F5TURBZ01qQXdjeTA1TUNBeU1EQWdMVEl3TUNBeU1EQjZUVFF3TUNBMU1EQmpNVEFnTUNBeE9TQXRNeUF5T0NBdE5tTXRNVFlnTFRnZ0xUSTRJQzB5TkNBdE1qZ2dMVFEwWXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRBS1l6SXdJREFnTXpZZ01USWdORFFnTWpoak15QXRPU0EySUMweE9DQTJJQzB5T0dNd0lDMDFOU0F0TkRVZ0xURXdNQ0F0TVRBd0lDMHhNREJ6TFRFd01DQTBOU0F0TVRBd0lERXdNSE0wTlNBeE1EQWdNVEF3SURFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOallpSUhWdWFXTnZaR1U5SWlZamVHVXdOalk3SWlCb2IzSnBlaTFoWkhZdGVEMGlPVEF3SWlBS1pEMGlUVE16TVNBM01EQm9NMmd6WXpNZ01TQTNJREVnTVRBZ01XTXhNaUF3SURJNUlDMDRJRE0zSUMweE4ydzVOQ0F0T1ROc05qWWdOalZqTlRjZ05UY2dNVFUxSURVM0lESXhNaUF3WXpVNElDMDFPQ0ExT0NBdE1UVTBJREFnTFRJeE1td3ROalVnTFRZMmJEa3pJQzA1TkdNeE1DQXRPQ0F4T0NBdE1qVWdNVGdnTFRNNFl6QWdMVEk0SUMweU1pQXROVEFnTFRVd0lDMDFNR010TVRNZ01DQXRNeklnT1NBdE5EQWdNakJzTFRZeUlEWTFiQzB6T0RFZ0xUTTRNV2d0TWpZNWRqSTNNbXd6TnpVZ016Z3hiQzAyTXlBMk0yTXRPU0E0SUMweE5pQXlOQ0F0TVRZZ016WmpNQ0F5TUNBeE5pQTBNaUF6TlNBME9Ib0tUVFEwTnlBME9ERnNMVE14TXlBdE16RTFiREV5T0NBdE1UTXliRE14TmlBek1UWjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalkzSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFkzT3lJZ0NtUTlJazB3SURnd01HZ3pNREIyTFRRd01HZzBNREIyTFRRd01HZ3ROekF3ZGpnd01IcE5OREF3SURnd01Hd3pNREFnTFRNd01HZ3RNekF3ZGpNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOamdpSUhWdWFXTnZaR1U5SWlZamVHVXdOamc3SWlBS1pEMGlUVEl3TUNBNE1EQmpNQ0F3SURJd01DQXRNVEF3SURJd01DQXRNekF3Y3kweU9UZ2dMVE13TWlBdE1qQXdJQzAxTURCak1DQXdJQzB5TURBZ01UQXdJQzB5TURBZ016QXdjek13TUNBek1EQWdNakF3SURVd01IcE5OVEF3SURVd01HTXdJREFnTWpBd0lDMHhNREFnTWpBd0lDMHpNREJqTUNBdE1UVXdJQzAyTUNBdE1qQXdJQzB4TURBZ0xUSXdNR2d0TXpBd1l6QWdNakF3SURNd01DQXpNREFnTWpBd0lEVXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTmpraUlIVnVhV052WkdVOUlpWWplR1V3TmprN0lpQUtaRDBpVFRBZ09EQXdhREV3TUhZdE9EQXdhQzB4TURCMk9EQXdlazB5TURBZ09EQXdhRE13TUhZdE1UQXdhRE13TUd3dE1qQXdJQzB5TUROc01qQXdJQzB4T1Rkb0xUUXdNSFl4TURCb0xUSXdNSFkwTURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqWmhJaUIxYm1samIyUmxQU0ltSTNobE1EWmhPeUlnYUc5eWFYb3RZV1IyTFhnOUlqUXdNQ0lnQ21ROUlrMHhOVEFnT0RBd2FERTFNR3d0TVRBd0lDMHlNREJvTWpBd2JDMHhOVEFnTFRNd01HZ3hOVEJzTFRNd01DQXRNekF3YkMweE1EQWdNekF3YURFek5HdzJOaUF5TURCb0xUSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTm1JaUlIVnVhV052WkdVOUlpWWplR1V3Tm1JN0lpQUtaRDBpVFRBZ09EQXdhRE13TUhZdE1UQXdhRFV3TUhZdE1UQXdhQzA0TURCMk1qQXdlazB3SURVd01HZzRNREIyTFRRMU1HTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRjd01HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdkalExTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5tTWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05tTTdJaUFLWkQwaVRURTFNQ0E0TURCak9ETWdNQ0F4TlRBZ0xUWTNJREUxTUNBdE1UVXdZekFnTFRZMklDMDBNU0F0TVRJeElDMHhNREFnTFRFME1YWXRNVEU0WXpFMUlEVWdNek1nT1NBMU1DQTVhREl3TUdNeU9DQXdJRFV3SURJeUlEVXdJRFV3ZGpVNVl5MDFPU0F5TUNBdE1UQXdJRGMxSUMweE1EQWdNVFF4WXpBZ09ETWdOamNnTVRVd0lERTFNQ0F4TlRCek1UVXdJQzAyTnlBeE5UQWdMVEUxTUdNd0lDMDJOaUF0TkRFZ0xURXlNU0F0TVRBd0lDMHhOREYyTFRVNVl6QWdMVGd5SUMwMk9DQXRNVFV3SUMweE5UQWdMVEUxTUdndE1qQXdZeTB4TkNBd0lDMHlOU0F0TnlBdE16UWdMVEUyQ21NMU1DQXRNalFnT0RRZ0xUYzBJRGcwSUMweE16UmpNQ0F0T0RNZ0xUWTNJQzB4TlRBZ0xURTFNQ0F0TVRVd2N5MHhOVEFnTmpjZ0xURTFNQ0F4TlRCak1DQTJOaUEwTVNBeE1qRWdNVEF3SURFME1YWXlNVGhqTFRVNUlESXdJQzB4TURBZ056VWdMVEV3TUNBeE5ERmpNQ0E0TXlBMk55QXhOVEFnTVRVd0lERTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTm1RaUlIVnVhV052WkdVOUlpWWplR1V3Tm1RN0lpQUtaRDBpVFRBZ09EQXdhRFF3TUd3dE1UVXdJQzB4TlRCc01UVXdJQzB4TlRCc0xURXdNQ0F0TVRBd2JDMHhOVEFnTVRVd2JDMHhOVEFnTFRFMU1IWTBNREI2VFRVd01DQTBNREJzTVRVd0lDMHhOVEJzTVRVd0lERTFNSFl0TkRBd2FDMDBNREJzTVRVd0lERTFNR3d0TVRVd0lERTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTm1VaUlIVnVhV052WkdVOUlpWWplR1V3Tm1VN0lpQUtaRDBpVFRFd01DQTRNREJzTVRVd0lDMHhOVEJzTVRVd0lERTFNSFl0TkRBd2FDMDBNREJzTVRVd0lERTFNR3d0TVRVd0lERTFNSHBOTkRBd0lEUXdNR2cwTURCc0xURTFNQ0F0TVRVd2JERTFNQ0F0TVRVd2JDMHhNREFnTFRFd01Hd3RNVFV3SURFMU1Hd3RNVFV3SUMweE5UQjJOREF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMlppSWdkVzVwWTI5a1pUMGlKaU40WlRBMlpqc2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qRWdNQ0EwTURBZ0xURTNPU0EwTURBZ0xUUXdNSE10TVRjNUlDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGM1SUMwME1EQWdOREF3Y3pFM09TQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNR010TlRZZ01DQXRNVEE0SUMweE55QXRNVFV6SUMwME5Hd3lNaUF0TVRsak16TWdMVEU0SURFeklDMDBPQ0F0TVRNZ0xUVTVZeTB6TUNBdE1UTWdMVGMzSURFd0lDMDJOU0F0TkRGak1UTWdMVFUxSUMweU55QXRNeUF0TkRjZ0xURTFZeTAwTWlBdE1qWWdORGtnTFRFMU1pQXpNU0F0TVRVMmJDMDFPU0F6TkdNdE9DQXdJQzB4TXlBdE5TQXRNVFlnTFRFd0NtTXhJQzB6TUNBeE1DQXROVGNnTVRrZ0xUZzBZekk0SUMweE1TQTNOeUF0TWlBeE1EQWdMVEkxWXpRM0lDMHlPQ0E1TnlBdE1URTFJRGMxSUMweE5UbGpNelFnTFRFeklEWTRJQzB5TWlBeE1EWWdMVEl5WXpFd01TQXdJREU1TXlBME9DQXlORGNnTVRJMVl6TWdNalFnTFRnZ05EUWdMVFV3SURRMFl5MDJPU0F3SUMweE5UWWdNVE1nTFRFMU15QTVOMk15SURRMklERXdNU0F4TURnZ05qWWdNVFF6WXkwek1DQXpNQ0F4TWlBek9TQXhNaUEyTm1Nd0lETTNJQzAyTlNBek1pQXROamtnTlRCek1qQWdNellnTkRFZ05UWmpMVE13SURFd0lDMDJNQ0F4T1NBdE9UUWdNVGw2VFRZek1TQTFPVEVLWXkwek9DQXRNVEVnTFRrMElDMHpOU0F0T0RjZ0xUVXpZellnTFRFMUlEVXlJQzB4SURZMUlDMHhNMk14TVNBdE1UQWdNVFlnTFRVNUlEUTBJQzB6TVd3eU1pQXlNbll6WXkweE1TQXlOaUF0TWpZZ05UQWdMVFEwSURjeWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNNQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTNNRHNpSUFwa1BTSk5OekF6SURnd01HdzVOeUF0TVRBd2JDMDBNREFnTFRRd01Hd3RNVEF3SURFd01Hd3RNakF3SUMweU1ETnNMVEV3TUNBeE1EQnNNekF3SURNd00yd3hNREFnTFRFd01IcE5NQ0F4TURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqY3hJaUIxYm1samIyUmxQU0ltSTNobE1EY3hPeUlnQ21ROUlrMHdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk1qQXdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk5EQXdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk5qQXdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk1DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRJd01DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRRd01DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRZd01DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRBZ016QXdhREV3TUhZdE1UQXdhQzB4TURCMk1UQXdlazB5TURBZ016QXdhREV3TUFwMkxURXdNR2d0TVRBd2RqRXdNSHBOTkRBd0lETXdNR2d4TURCMkxURXdNR2d0TVRBd2RqRXdNSHBOTmpBd0lETXdNR2d4TURCMkxURXdNR2d0TVRBd2RqRXdNSHBOTUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZUVEl3TUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZUVFF3TUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZUVFl3TUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamN5SWlCMWJtbGpiMlJsUFNJbUkzaGxNRGN5T3lJZ0NtUTlJazB3SURnd01HZ3lNREIyTFRJd01HZ3RNakF3ZGpJd01IcE5NekF3SURnd01HZ3lNREIyTFRJd01HZ3RNakF3ZGpJd01IcE5OakF3SURnd01HZ3lNREIyTFRJd01HZ3RNakF3ZGpJd01IcE5NQ0ExTURCb01qQXdkaTB5TURCb0xUSXdNSFl5TURCNlRUTXdNQ0ExTURCb01qQXdkaTB5TURCb0xUSXdNSFl5TURCNlRUWXdNQ0ExTURCb01qQXdkaTB5TURCb0xUSXdNSFl5TURCNlRUQWdNakF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWswek1EQWdNakF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWswMk1EQWdNakF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJM015SWdkVzVwWTI5a1pUMGlKaU40WlRBM016c2lJQXBrUFNKTk1DQTRNREJvTXpBd2RpMHpNREJvTFRNd01IWXpNREI2VFRVd01DQTRNREJvTXpBd2RpMHpNREJvTFRNd01IWXpNREI2VFRBZ016QXdhRE13TUhZdE16QXdhQzB6TURCMk16QXdlazAxTURBZ016QXdhRE13TUhZdE16QXdhQzB6TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzTkNJZ2RXNXBZMjlrWlQwaUppTjRaVEEzTkRzaUlBcGtQU0pOTVRrZ09EQXdhRFkyTW1NeE1TQXdJREU1SUMwNElERTVJQzB4T1hZdE16TXhZekFnTFRJNElDMHlNaUF0TlRBZ0xUVXdJQzAxTUdndE5qQXdZeTB5T0NBd0lDMDFNQ0F5TWlBdE5UQWdOVEIyTXpNeFl6QWdNVEVnT0NBeE9TQXhPU0F4T1hwTk1DQXpNRGxqTVRZZ0xUWWdNeklnTFRrZ05UQWdMVGxvTmpBd1l6RTRJREFnTXpRZ015QTFNQ0E1ZGkweU9UQmpNQ0F0TVRFZ0xUZ2dMVEU1SUMweE9TQXRNVGxvTFRZMk1tTXRNVEVnTUNBdE1Ua2dPQ0F0TVRrZ01UbDJNamt3ZWswMU5UQWdNakF3WXkweU9DQXdJQzAxTUNBdE1qSWdMVFV3SUMwMU1ITXlNaUF0TlRBZ05UQWdMVFV3Q25NMU1DQXlNaUExTUNBMU1ITXRNaklnTlRBZ0xUVXdJRFV3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJM05TSWdkVzVwWTI5a1pUMGlKaU40WlRBM05Uc2lJQXBrUFNKTk1DQTNNREJvTXpBd2RpMHhNREJvTFRVd1l5MHlPQ0F3SUMwMU1DQXRNaklnTFRVd0lDMDFNSFl0TVRVd2FETXdNSFl4TlRCak1DQXlPQ0F0TWpJZ05UQWdMVFV3SURVd2FDMDFNSFl4TURCb016QXdkaTB4TURCb0xUVXdZeTB5T0NBd0lDMDFNQ0F0TWpJZ0xUVXdJQzAxTUhZdE5EQXdZekFnTFRJNElESXlJQzAxTUNBMU1DQXROVEJvTlRCMkxURXdNR2d0TXpBd2RqRXdNR2cxTUdNeU9DQXdJRFV3SURJeUlEVXdJRFV3ZGpFMU1HZ3RNekF3ZGkweE5UQmpNQ0F0TWpnZ01qSWdMVFV3SURVd0lDMDFNR2cxTUhZdE1UQXdhQzB6TURCMk1UQXdhRFV3WXpJNElEQWdOVEFnTWpJZ05UQWdOVEFLZGpRd01HTXdJREk0SUMweU1pQTFNQ0F0TlRBZ05UQm9MVFV3ZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOellpSUhWdWFXTnZaR1U5SWlZamVHVXdOelk3SWlBS1pEMGlUVFF3TUNBM01EQmpNVFkxSURBZ016QXdJQzB4TXpVZ016QXdJQzB6TURCMkxURXdNR2cxTUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCMkxUSXdNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xURXdNR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZGpNMU1HTXdJREV4TVNBdE9Ea2dNakF3SUMweU1EQWdNakF3Y3kweU1EQWdMVGc1SUMweU1EQWdMVEl3TUhZdE16VXdZekFnTFRJNElDMHlNaUF0TlRBZ0xUVXdJQzAxTUdndE1UQXdZeTB5T0NBd0lDMDFNQ0F5TWlBdE5UQWdOVEIyTWpBd1l6QWdNamdnTWpJZ05UQWdOVEFnTlRCb05UQjJNVEF3Q21Nd0lERTJOU0F4TXpVZ016QXdJRE13TUNBek1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamMzSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGMzT3lJZ0NtUTlJazB3SURVd01HTXdJREV3T1NBNU1TQXlNREFnTWpBd0lESXdNSE15TURBZ0xUa3hJREl3TUNBdE1qQXdZekFnTVRBNUlEa3hJREl3TUNBeU1EQWdNakF3Y3pJd01DQXRPVEVnTWpBd0lDMHlNREJqTUNBdE5UVWdMVEl6SUMweE1EVWdMVFU1SUMweE5ERnNMVE0wTVNBdE16UXdiQzB6TkRFZ016UXdZeTB6TmlBek5pQXROVGtnT0RZZ0xUVTVJREUwTVhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU56Z2lJSFZ1YVdOdlpHVTlJaVlqZUdVd056ZzdJaUFLWkQwaVRUUXdNQ0EzTURCc05EQXdJQzB6TURCc0xURXdNQ0F6ZGkwME1ETm9MVEl3TUhZeU1EQm9MVEl3TUhZdE1qQXdhQzB5TURCMk5EQXdhQzB4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqYzVJaUIxYm1samIyUmxQU0ltSTNobE1EYzVPeUlnQ21ROUlrMHdJRGd3TUdnNE1EQjJMVGd3TUdndE9EQXdkamd3TUhwTk1UQXdJRGN3TUhZdE16QXdiREV3TUNBeE1EQnNOREF3SUMwME1EQm9NVEF3ZGpFd01Hd3RNakF3SURJd01Hd3hNREFnTVRBd2JERXdNQ0F0TVRBd2RqTXdNR2d0TmpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNZU0lnZFc1cFkyOWtaVDBpSmlONFpUQTNZVHNpSUFwa1BTSk5NVGtnT0RBd2FEYzJNbU14TVNBd0lERTVJQzA0SURFNUlDMHhPWFl0TnpZeVl6QWdMVEV4SUMwNElDMHhPU0F0TVRrZ0xURTVhQzAzTmpKakxURXhJREFnTFRFNUlEZ2dMVEU1SURFNWRqYzJNbU13SURFeElEZ2dNVGtnTVRrZ01UbDZUVEV3TUNBMk1EQjJMVE13TUdneE1EQnNNVEF3SUMweE1EQm9NakF3YkRFd01DQXhNREJvTVRBd2RqTXdNR2d0TmpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNZaUlnZFc1cFkyOWtaVDBpSmlONFpUQTNZanNpSUFwa1BTSk5NakF3SURZd01HTTRNQ0F3SURFME1pQXROVFlnTWpBd0lDMHhNakpqTlRnZ05qWWdNVEU1SURFeU1pQXlNREFnTVRJeVl6RXpNU0F3SURJd01DQXRNVEF4SURJd01DQXRNakF3Y3kwMk9TQXRNakF3SUMweU1EQWdMVEl3TUdNdE9ERWdNQ0F0TVRReUlEVTJJQzB5TURBZ01USXlZeTAxT0NBdE5qWWdMVEV5TVNBdE1USXlJQzB5TURBZ0xURXlNbU10TVRNeElEQWdMVEl3TUNBeE1ERWdMVEl3TUNBeU1EQnpOamtnTWpBd0lESXdNQ0F5TURCNlRUSXdNQ0ExTURCakxUYzBJREFnTFRFd01DQXROVFFnTFRFd01DQXRNVEF3Y3pJMklDMHhNREFnTVRBd0lDMHhNREFLWXpReUlEQWdPRGdnTkRjZ01UTTBJREV3TUdNdE5EWWdOVE1nTFRreUlERXdNQ0F0TVRNMElERXdNSHBOTmpBd0lEVXdNR010TkRNZ01DQXRPRGdnTFRRM0lDMHhNelFnTFRFd01HTTBOaUF0TlRNZ09URWdMVEV3TUNBeE16UWdMVEV3TUdNM05DQXdJREV3TUNBMU5DQXhNREFnTVRBd2N5MHlOaUF4TURBZ0xURXdNQ0F4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqZGpJaUIxYm1samIyUmxQU0ltSTNobE1EZGpPeUlnYUc5eWFYb3RZV1IyTFhnOUlqUXdNQ0lnQ21ROUlrMHpNREFnT0RBd1l6VTFJREFnTVRBd0lDMDBOU0F4TURBZ0xURXdNSE10TkRVZ0xURXdNQ0F0TVRBd0lDMHhNREJ6TFRFd01DQTBOU0F0TVRBd0lERXdNSE0wTlNBeE1EQWdNVEF3SURFd01IcE5NVFV3SURVMU1HTTRNeUF3SURFMU1DQXROamtnTVRVd0lDMHhOVEJqTUNBdE5qWWdMVEV3TUNBdE1qRTBJQzB4TURBZ0xUSTFNR013SUMweU9DQXlNaUF0TlRBZ05UQWdMVFV3Y3pVd0lESXlJRFV3SURVd2FERXdNR013SUMwNE15QXROamNnTFRFMU1DQXRNVFV3SUMweE5UQnpMVEUxTUNBMk5DQXRNVFV3SURFMU1ITXhNREFnTWpJeUlERXdNQ0F5TlRCekxUSXlJRFV3SUMwMU1DQTFNQXB6TFRVd0lDMHlNaUF0TlRBZ0xUVXdhQzB4TURCak1DQTRNeUEyTnlBeE5UQWdNVFV3SURFMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOMlFpSUhWdWFXTnZaR1U5SWlZamVHVXdOMlE3SWlBS1pEMGlUVEl3TUNBNE1EQm9OVEF3ZGkweE1EQm9MVEV5TW1NdE56Y2dMVEU1TnlBdE1UVTJJQzB6T1RJZ0xUSXpOQ0F0TlRnNGJDMDJJQzB4TW1neE5qSjJMVEV3TUdndE5UQXdkakV3TUdneE1qSmpOemNnTVRrM0lERTFOaUF6T1RJZ01qTTBJRFU0T0d3M0lERXlhQzB4TmpOMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzWlNJZ2RXNXBZMjlrWlQwaUppTjRaVEEzWlRzaUlBcGtQU0pOTUNBM01EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZUVEFnTlRBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJRE13TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1UQXdJREV3TUdnMk1EQjJMVEV3TUdndE5qQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU4yWWlJSFZ1YVdOdlpHVTlJaVlqZUdVd04yWTdJaUFLWkQwaVRUQWdOekF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWswd0lEVXdNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTUNBek1EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZUVEFnTVRBd2FEWXdNSFl0TVRBd2FDMDJNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTRNQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTRNRHNpSUFwa1BTSk5NQ0EzTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUQWdOVEF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWswd0lETXdNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTWpBd0lERXdNR2cyTURCMkxURXdNR2d0TmpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT0RFaUlIVnVhV052WkdVOUlpWWplR1V3T0RFN0lpQUtaRDBpVFRVMU1DQTRNREJqTVRNNElEQWdNalV3SUMweE1USWdNalV3SUMweU5UQnpMVEV4TWlBdE1qVXdJQzB5TlRBZ0xUSTFNR010TVRZZ01DQXRNeklnTUNBdE5EY2dNMnd0TXlBdE0zWXRNVEF3YUMweU1EQjJMVEl3TUdndE16QXdkakl3TUd3ek1ETWdNekF6WXkweklERTFJQzB6SURNeElDMHpJRFEzWXpBZ01UTTRJREV4TWlBeU5UQWdNalV3SURJMU1IcE5OakF3SURjd01HTXROVFVnTUNBdE1UQXdJQzAwTlNBdE1UQXdJQzB4TURCek5EVWdMVEV3TUNBeE1EQWdMVEV3TUhNeE1EQWdORFVnTVRBd0lERXdNSE10TkRVZ01UQXdJQzB4TURBZ01UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0TWlJZ2RXNXBZMjlrWlQwaUppTjRaVEE0TWpzaUlBcGtQU0pOTVRNMElEWXdNR2d6YURSb05HZzFhRFV3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCMkxUTTFNR2d4TURCMkxURTFNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xUY3dNR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZGpFMU1HZ3hNREIyTXpVd2RqSmpNQ0F5TUNBeE5TQTBNaUF6TkNBME9IcE5NakF3SURVd01IWXRNekF3YURFd01IWXRNVEF3YURJd01IWXhNREJvTVRBd2RqTXdNR2d0TkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTRNeUlnZFc1cFkyOWtaVDBpSmlONFpUQTRNenNpSUFwa1BTSk5NQ0E0TURCb05EQXdkaTAwTURCb0xUUXdNSFkwTURCNlRUVXdNQ0EyTURCb01UQXdkaTAwTURCb0xUUXdNSFl4TURCb016QXdkak13TUhwTk56QXdJRFF3TUdneE1EQjJMVFF3TUdndE5EQXdkakV3TUdnek1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNE5DSWdkVzVwWTI5a1pUMGlKaU40WlRBNE5Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16TTNJRFk1TkdNMklEUWdNVElnTnlBeU1TQTNZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNR013SUMweE55QXRNVElnTFRNM0lDMHlOeUF0TkRWc0xUTXdNQ0F0TVRVd1l5MDRJQzAySUMweU1TQXRNVEVnTFRNeElDMHhNV010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3WXpBZ01qRWdNVFlnTkRRZ016Y2dORGw2VFRRek55QTFORFJqTmlBMElERXlJRGNnTWpFZ04yTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQmpNQ0F0TVRjZ0xURXlJQzB6TnlBdE1qY2dMVFExYkMwME1EQWdMVEl3TUdNdE9DQXROaUF0TWpFZ0xURXhJQzB6TVNBdE1URmpMVEk0SURBZ0xUVXdJREl5SUMwMU1DQTFNQXBqTUNBeU1TQXhOaUEwTkNBek55QTBPWHBOTkRNM0lETTBOR00ySURRZ01USWdOeUF5TVNBM1l6STRJREFnTlRBZ0xUSXlJRFV3SUMwMU1HTXdJQzB4TnlBdE1USWdMVE0zSUMweU55QXRORFZzTFRFd05pQXROVFpqTWpRZ0xUUWdORE1nTFRJMklEUXpJQzAxTUdNd0lDMHlPQ0F0TWpNZ0xUVXhJQzAxTVNBdE5URmpMVElnTUNBdE5pQXhJQzA0SURGb0xUSXdNR010TWpZZ01TQXRORGdnTWpRZ0xUUTRJRFV3WXpBZ01UWWdNVElnTXpZZ01qWWdORFI2VFRFMU1TQXROVEJqTUNBeU15QXlNQ0ExTUNBME5pQTFNR2d6YURSb05XZ3hNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Q25NdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRFd01HTXRNaUF3SUMwMklDMHhJQzA0SUMweFl5MHlPQ0F3SUMwMU1DQXlNeUF0TlRBZ05URjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamcxSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGcxT3lJZ0NtUTlJazB4T1RrZ09EQXdhREV3TUhZdE1qQXdhQzB5TURCMk1UQXdhREV3TUhZeE1EQjZUVFU0TmlBM09UZG9NV014T0NBeElETTRJREVnTlRZZ0xUTmpNellnTFRnZ05qa2dMVEkySURrM0lDMDFOR00zT0NBdE56Z2dOemdnTFRJd015QXdJQzB5T0RGc0xURTFNQ0F0TVRVd1l5MDRJQzB4TXlBdE1qZ2dMVEkwSUMwME15QXRNalJqTFRJNElEQWdMVFV3SURJeUlDMDFNQ0ExTUdNd0lERTFJREV4SURNMUlESTBJRFF6YkRFMU1DQXhOVEJqTkRBZ05EQWdNemtnTVRBMUlEQWdNVFEwWXkwME1TQTBNU0F0TVRFd0lETTBJQzB4TkRRZ01Hd3RORFFnTFRRMENtTXRPQ0F0TVRNZ0xUSTNJQzB5TkNBdE5ESWdMVEkwWXkweU9DQXdJQzAxTUNBeU1pQXROVEFnTlRCak1DQXhOU0F4TVNBek5TQXlOQ0EwTTJ3ME15QTBOR016TWlBek15QTNNaUExTXlBeE1qZ2dOVFo2VFRJd09DQTBPVEJqTkNBMUlERTBJREUySURJeUlERTJhRE5qTWlBd0lEWWdNU0E0SURGak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd1l6QWdMVEV4SUMwMklDMHlOeUF0TVRRZ0xUTTFiQzB4TlRBZ0xURTFNR010TkRBZ0xUUXdJQzB6T1NBdE1UQTFJREFnTFRFME5HTTBNU0F0TkRFZ01URXdJQzB6TkNBeE5EUWdNR3cwTkNBME5HTTRJREV6SURJM0lESTBJRFF5SURJMENtTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQmpNQ0F0TVRVZ0xURXhJQzB6TlNBdE1qUWdMVFF6YkMwME15QXRORFJqTFRJeUlDMHlNaUF0TkRnZ0xUTTNJQzAzTlNBdE5EZGpMVGN3SUMweU5TQXRNVFV4SUMwNUlDMHlNRGNnTkRkakxUYzRJRGM0SUMwM09DQXlNRE1nTUNBeU9ERjZUVFE1T1NBeU1EQm9NakF3ZGkweE1EQm9MVEV3TUhZdE1UQXdhQzB4TURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0TmlJZ2RXNXBZMjlrWlQwaUppTjRaVEE0TmpzaUlBcGtQU0pOTlRnMklEYzVOMk14T0NBeElETTVJREVnTlRjZ0xUTmpNellnTFRnZ05qa2dMVEkySURrM0lDMDFOR00zT0NBdE56Z2dOemdnTFRJd015QXdJQzB5T0RGc0xURTFNQ0F0TVRVd1l5MDJNaUF0TmpJZ0xURXpNaUF0T0RFZ0xURTRNaUF0TnpoekxUWTVJREUzSUMwNE5DQXlOWE10TWpZZ01qY2dMVEkySURRMFl6QWdNamdnTWpJZ05URWdOVEFnTlRGak9DQXdJREU1SUMweklESTJJQzAzWXpBZ01DQXhOU0F0TVRFZ05ERWdMVEV6Y3pZeUlETWdNVEEySURRM2JERTFNQ0F4TlRCak5EQWdOREFnTXprZ01UQTFJREFnTVRRMFl5MDBNU0EwTVNBdE1URXdJRE0wSUMweE5EUWdNQXBqTFRnZ0xURXpJQzB5T0NBdE1qUWdMVFF6SUMweU5HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdZekFnTVRVZ01URWdNelVnTWpRZ05ETmpNeklnTXpNZ056SWdOVE1nTVRJNElEVTJlazB6T0RZZ05UWTJZelV3SUMweUlEWTBJQzB4TnlBNE5TQXRNakp6TXpjZ0xUSTRJRE0zSUMwME9XTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJqTFRFd0lEQWdMVEl6SURVZ0xUTXhJREV4WXpBZ01DQXRNVGtnT1NBdE5EY2dNVEJ6TFRZeklDMDBJQzB4TURNZ0xUUTBiQzB4TlRBZ0xURTFNR010TkRBZ0xUUXdJQzB6T1NBdE1UQTFJREFnTFRFME5HTTBNU0F0TkRFZ01URXdJQzB6TkNBeE5EUWdNQXBqT0NBeE15QXlOeUF5TkNBME1pQXlOR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJqTUNBdE1UVWdMVEV3SUMwek5TQXRNak1nTFRRell5MHlNaUF0TWpJZ0xUUTRJQzB6TnlBdE56VWdMVFEzWXkwM01DQXRNalVnTFRFMU1TQXRPU0F0TWpBM0lEUTNZeTAzT0NBM09DQXROemdnTWpBeklEQWdNamd4YkRFMU1DQXhOVEJqTmpBZ05qQWdNVEk0SURjNElERTNPQ0EzTm5vaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9EY2lJSFZ1YVdOdlpHVTlJaVlqZUdVd09EYzdJaUFLWkQwaVRUQWdOekF3YURNd01IWXRNekF3YUMwek1EQjJNekF3ZWswME1EQWdOekF3YURRd01IWXRNVEF3YUMwME1EQjJNVEF3ZWswME1EQWdOVEF3YURNd01IWXRNVEF3YUMwek1EQjJNVEF3ZWswd0lETXdNR2d6TURCMkxUTXdNR2d0TXpBd2RqTXdNSHBOTkRBd0lETXdNR2cwTURCMkxURXdNR2d0TkRBd2RqRXdNSHBOTkRBd0lERXdNR2d6TURCMkxURXdNR2d0TXpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT0RnaUlIVnVhV052WkdVOUlpWWplR1V3T0RnN0lpQUtaRDBpVFRVd0lEY3dNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJ6TFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCek1qSWdOVEFnTlRBZ05UQjZUVEl3TUNBM01EQm9OakF3ZGkweE1EQm9MVFl3TUhZeE1EQjZUVFV3SURVd01HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEJ6TWpJZ05UQWdOVEFnTlRCNlRUSXdNQ0ExTURCb05qQXdkaTB4TURCb0xUWXdNSFl4TURCNlRUVXdJRE13TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCekxUSXlJQzAxTUNBdE5UQWdMVFV3Y3kwMU1DQXlNaUF0TlRBZ05UQUtjekl5SURVd0lEVXdJRFV3ZWsweU1EQWdNekF3YURZd01IWXRNVEF3YUMwMk1EQjJNVEF3ZWswMU1DQXhNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazB5TURBZ01UQXdhRFl3TUhZdE1UQXdhQzAyTURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0T1NJZ2RXNXBZMjlrWlQwaUppTjRaVEE0T1RzaUlBcGtQU0pOT0RBd0lEZ3dNR3d0TkRBd0lDMDRNREJzTFRFd01DQXpNREJzTFRNd01DQXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpoaElpQjFibWxqYjJSbFBTSW1JM2hsTURoaE95SWdhRzl5YVhvdFlXUjJMWGc5SWpZd01DSWdDbVE5SWswek1EQWdOekF3WXpFeE1DQXdJREl3TUNBdE9UQWdNakF3SUMweU1EQjJMVEV3TUdneE1EQjJMVFF3TUdndE5qQXdkalF3TUdneE1EQjJNVEF3WXpBZ01URXdJRGt3SURJd01DQXlNREFnTWpBd2VrMHpNREFnTmpBd1l5MDFOaUF3SUMweE1EQWdMVFEwSUMweE1EQWdMVEV3TUhZdE1UQXdhREl3TUhZeE1EQmpNQ0ExTmlBdE5EUWdNVEF3SUMweE1EQWdNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNFlpSWdkVzVwWTI5a1pUMGlKaU40WlRBNFlqc2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16QXdJRGd3TUdNeE1UQWdNQ0F5TURBZ0xUa3dJREl3TUNBdE1qQXdkaTB5TURCb01UQXdkaTAwTURCb0xUWXdNSFkwTURCb05EQXdkakl3TUdNd0lEVTJJQzAwTkNBeE1EQWdMVEV3TUNBeE1EQnpMVEV3TUNBdE5EUWdMVEV3TUNBdE1UQXdhQzB4TURCak1DQXhNVEFnT1RBZ01qQXdJREl3TUNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamhqSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGhqT3lJZ0NtUTlJazAwTURBZ056QXdkaTB4TURCakxURXhNU0F3SUMweU1EQWdMVGc1SUMweU1EQWdMVEl3TUdneE1EQnNMVEUxTUNBdE1qQXdiQzB4TlRBZ01qQXdhREV3TUdNd0lERTJOU0F4TXpVZ016QXdJRE13TUNBek1EQjZUVFkxTUNBMk1EQnNNVFV3SUMweU1EQm9MVEV3TUdNd0lDMHhOalVnTFRFek5TQXRNekF3SUMwek1EQWdMVE13TUhZeE1EQmpNVEV4SURBZ01qQXdJRGc1SURJd01DQXlNREJvTFRFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPR1FpSUhWdWFXTnZaR1U5SWlZamVHVXdPR1E3SWlBS1pEMGlUVEV3TUNBNE1EQm9OakF3ZGkwek1EQm9NVEF3YkMweE5UQWdMVEkxTUd3dE1UVXdJREkxTUdneE1EQjJNakF3YUMwME1EQjJMVEV3TUdndE1UQXdkakl3TUhwTk1UVXdJRFUxTUd3eE5UQWdMVEkxTUdndE1UQXdkaTB5TURCb05EQXdkakV3TUdneE1EQjJMVEl3TUdndE5qQXdkak13TUdndE1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0WlNJZ2RXNXBZMjlrWlQwaUppTjRaVEE0WlRzaUlBcGtQU0pOTmpBd0lEY3dNR3d5TURBZ0xURTFNR3d0TWpBd0lDMHhOVEIyTVRBd2FDMDFNREIyTFRFd01HZ3RNVEF3ZGpFd01HTXdJRFUxSURRMUlERXdNQ0F4TURBZ01UQXdhRFV3TUhZeE1EQjZUVEl3TUNBek1EQjJMVEV3TUdnMU1EQjJNVEF3YURFd01IWXRNVEF3WXpBZ0xUVTFJQzAwTlNBdE1UQXdJQzB4TURBZ0xURXdNR2d0TlRBd2RpMHhNREJzTFRJd01DQXhOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpobUlpQjFibWxqYjJSbFBTSW1JM2hsTURobU95SWdhRzl5YVhvdFlXUjJMWGc5SWprd01DSWdDbVE5SWswek5UQWdPREF3WXpFNU15QXdJRE0xTUNBdE1UVTNJRE0xTUNBdE16VXdZekFnTFRZd0lDMHhOeUF0TVRFM0lDMDBOQ0F0TVRZMll6VWdMVE1nTVRJZ0xUZ2dNVFlnTFRFeWJERXdNQ0F0TVRBd1l6RTJJQzB4TmlBek1DQXRORGtnTXpBZ0xUY3lZekFnTFRVMklDMDBOaUF0TVRBeUlDMHhNRElnTFRFd01tTXRNak1nTUNBdE5UWWdNVFFnTFRjeUlETXdiQzB4TURBZ01UQXdZeTAwSURNZ0xUa2dPU0F0TVRJZ01UTmpMVFE1SUMweU5pQXRNVEEzSUMwME1TQXRNVFkySUMwME1XTXRNVGt6SURBZ0xUTTFNQ0F4TlRjZ0xUTTFNQ0F6TlRCek1UVTNJRE0xTUNBek5UQWdNelV3ZWswek5UQWdNakF3Q21NeE5ESWdNQ0F5TlRBZ01UQTRJREkxTUNBeU5UQmpNQ0F4TXprZ0xURXhNU0F5TlRBZ0xUSTFNQ0F5TlRCekxUSTFNQ0F0TVRFeElDMHlOVEFnTFRJMU1ITXhNVEVnTFRJMU1DQXlOVEFnTFRJMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPVEFpSUhWdWFXTnZaR1U5SWlZamVHVXdPVEE3SWlCb2IzSnBlaTFoWkhZdGVEMGlOakF3SWlBS1pEMGlUVE13TUNBNE1EQmpNVFkySURBZ016QXdJQzB4TXpRZ016QXdJQzB6TURCak1DQXRNakF3SUMwek1EQWdMVFV3TUNBdE16QXdJQzAxTURCekxUTXdNQ0F6TURBZ0xUTXdNQ0ExTURCak1DQXhOallnTVRNMElETXdNQ0F6TURBZ016QXdlazB6TURBZ056QXdZeTB4TVRBZ01DQXRNakF3SUMwNU1DQXRNakF3SUMweU1EQnpPVEFnTFRJd01DQXlNREFnTFRJd01ITXlNREFnT1RBZ01qQXdJREl3TUhNdE9UQWdNakF3SUMweU1EQWdNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNU1TSWdkVzVwWTI5a1pUMGlKaU40WlRBNU1Uc2lJR2h2Y21sNkxXRmtkaTE0UFNJNU1EQWlJQXBrUFNKTk1DQTRNREJvT0RBd2RpMDFOREZqTVNBdE15QXhJQzA0SURFZ0xURXhjekFnTFRjZ0xURWdMVEV3ZGkweU16aG9MVGd3TUhZNE1EQjZUVFE1TlNBeU5UQmpNQ0F5TmlBeU1pQTFNQ0ExTUNBMU1HZzFhREUxTUhZME1EQm9MVFl3TUhZdE5qQXdhRFl3TUhZeE1EQm9MVEUxTUdndE5XTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdlazB6TlRBZ05qQXdZemd6SURBZ01UVXdJQzAyTnlBeE5UQWdMVEUxTUdNd0lDMHhNREFnTFRFMU1DQXRNalV3SUMweE5UQWdMVEkxTUhNdE1UVXdJREUxTUNBdE1UVXdJREkxTUdNd0lEZ3pJRFkzSURFMU1DQXhOVEFnTVRVd2VrMHpOVEFnTlRBd0NtTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJ6TWpJZ0xUVXdJRFV3SUMwMU1ITTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTVNaUlnZFc1cFkyOWtaVDBpSmlONFpUQTVNanNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5NQ0EzTURCb01qQXdkaTAyTURCb0xUSXdNSFkyTURCNlRUUXdNQ0EzTURCb01qQXdkaTAyTURCb0xUSXdNSFkyTURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqa3pJaUIxYm1samIyUmxQU0ltSTNobE1Ea3pPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHdJRGN3TUd3Mk1EQWdMVE13TUd3dE5qQXdJQzB6TURCMk5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1TkNJZ2RXNXBZMjlrWlQwaUppTjRaVEE1TkRzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTXpBd0lEY3dNR014TmpZZ01DQXpNREFnTFRFek5DQXpNREFnTFRNd01ITXRNVE0wSUMwek1EQWdMVE13TUNBdE16QXdjeTB6TURBZ01UTTBJQzB6TURBZ016QXdjekV6TkNBek1EQWdNekF3SURNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPVFVpSUhWdWFXTnZaR1U5SWlZamVHVXdPVFU3SWlBS1pEMGlUVFF3TUNBM01EQjJMVFl3TUd3dE5EQXdJRE13TUhwTk5EQXdJRFF3TUd3ME1EQWdNekF3ZGkwMk1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamsySWlCMWJtbGpiMlJsUFNJbUkzaGxNRGsyT3lJZ0NtUTlJazB3SURjd01HdzBNREFnTFRNd01Hd3ROREF3SUMwek1EQjJOakF3ZWswME1EQWdNVEF3ZGpZd01HdzBNREFnTFRNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPVGNpSUhWdWFXTnZaR1U5SWlZamVHVXdPVGM3SWlBS1pEMGlUVEFnTnpBd2FESXdNSFl0TmpBd2FDMHlNREIyTmpBd2VrMHlNREFnTkRBd2JEVXdNQ0F6TURCMkxUWXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT1RnaUlIVnVhV052WkdVOUlpWWplR1V3T1RnN0lpQUtaRDBpVFRBZ056QXdiRFV3TUNBdE16QXdiQzAxTURBZ0xUTXdNSFkyTURCNlRUVXdNQ0F4TURCMk5qQXdhREl3TUhZdE5qQXdhQzB5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqazVJaUIxYm1samIyUmxQU0ltSTNobE1EazVPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHdJRGN3TUdnMk1EQjJMVFl3TUdndE5qQXdkall3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9XRWlJSFZ1YVdOdlpHVTlJaVlqZUdVd09XRTdJaUFLWkQwaVRUSXdNQ0E0TURCb05EQXdkaTB5TURCb01qQXdkaTAwTURCb0xUSXdNSFl0TWpBd2FDMDBNREIyTWpBd2FDMHlNREIyTkRBd2FESXdNSFl5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqbGlJaUIxYm1samIyUmxQU0ltSTNobE1EbGlPeUlnQ21ROUlrMHdJRGN3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1DQTBNRE5vT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRBZ01UQXphRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1WXlJZ2RXNXBZMjlrWlQwaUppTjRaVEE1WXpzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTWpjNElEY3dNR00zSURJZ01UTWdOQ0F5TWlBMFl6VTFJREFnTVRBd0lDMDBOU0F4TURBZ0xURXdNSFl0TkhZdE1qQXdZekFnTFRVMUlDMDBOU0F0TVRBd0lDMHhNREFnTFRFd01ITXRNVEF3SURRMUlDMHhNREFnTVRBd2RqSXdNSFl5WXpBZ05EUWdNelVnT0RnZ056Z2dPVGg2VFRNMElEVXdNR2cwYUROak15QXdJRFlnTVNBNUlERmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTB4ZGkwMU1HTXdJQzB4TVRFZ09Ea2dMVEl3TUNBeU1EQWdMVEl3TUhNeU1EQWdPRGtnTWpBd0lESXdNSFkxTUdNd0lESTRJREl5SURVd0lEVXdJRFV3Y3pVd0lDMHlNaUExTUNBdE5UQjJMVFV3Q21Nd0lDMHhORGdnTFRFd09TQXRNamN3SUMweU5UQWdMVEk1TkhZdE1UQTJhRFV3WXpVMUlEQWdNVEF3SUMwME5TQXhNREFnTFRFd01HZ3ROREF3WXpBZ05UVWdORFVnTVRBd0lERXdNQ0F4TURCb05UQjJNVEEyWXkweE5ERWdNalFnTFRJMU1DQXhORFlnTFRJMU1DQXlPVFIyTlRCMk1tTXdJREl3SURFMUlEUXlJRE0wSURRNGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTVaQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTVaRHNpSUFwa1BTSk5NQ0ExTURCb09EQXdkaTB5TURCb0xUZ3dNSFl5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqbGxJaUIxYm1samIyUmxQU0ltSTNobE1EbGxPeUlnQ21ROUlrMHpOQ0EzTURCb05HZ3phRFJvTldnM01EQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTAxTURCak1DQXRNamdnTFRJeUlDMDFNQ0F0TlRBZ0xUVXdhQzB5TlRCMkxURXdNR2d4TURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdhQzAyTURCak1DQTFOU0EwTlNBeE1EQWdNVEF3SURFd01HZ3hNREIyTVRBd2FDMHlOVEJqTFRJNElEQWdMVFV3SURJeUlDMDFNQ0ExTUhZMU1EQjJNbU13SURJd0lERTFJRFF5SURNMElEUTRlazB4TURBZ05qQXdkaTAwTURCb05qQXdkalF3TUdndE5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1WmlJZ2RXNXBZMjlrWlQwaUppTjRaVEE1WmpzaUlBcGtQU0pOTWpjeUlEY3dNR010TVRRZ0xUUXdJQzB5TWlBdE9ETWdMVEl5SUMweE1qaGpNQ0F0TWpJeElERTNPU0F0TkRBd0lEUXdNQ0F0TkRBd1l6UTFJREFnT0RnZ09DQXhNamdnTWpKakxUVXpJQzB4TlRnZ0xUSXdNaUF0TWpjeUlDMHpOemdnTFRJM01tTXRNakl4SURBZ0xUUXdNQ0F4TnprZ0xUUXdNQ0EwTURCak1DQXhOellnTVRFMElETXlOU0F5TnpJZ016YzRlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poTUNJZ2RXNXBZMjlrWlQwaUppTjRaVEJoTURzaUlBcGtQU0pOTXpVd0lEY3dNR3d4TlRBZ0xURTFNR2d0TVRBd2RpMHhOVEJvTVRVd2RqRXdNR3d4TlRBZ0xURTFNR3d0TVRVd0lDMHhOVEIyTVRBd2FDMHhOVEIyTFRFMU1HZ3hNREJzTFRFMU1DQXRNVFV3YkMweE5UQWdNVFV3YURFd01IWXhOVEJvTFRFMU1IWXRNVEF3YkMweE5UQWdNVFV3YkRFMU1DQXhOVEIyTFRFd01HZ3hOVEIyTVRVd2FDMHhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1FeElpQjFibWxqYjJSbFBTSW1JM2hsTUdFeE95SWdDbVE5SWswNE1EQWdPREF3ZGkwMU5UQmpNQ0F0T0RNZ0xUWTNJQzB4TlRBZ0xURTFNQ0F0TVRVd2N5MHhOVEFnTmpjZ0xURTFNQ0F4TlRCek5qY2dNVFV3SURFMU1DQXhOVEJqTVRjZ01DQXpOU0F0TkNBMU1DQXRPWFl5TURaakxUSXdNU0F0TmlBdE16STNJQzB5TnlBdE5EQXdJQzAxTUhZdE16azNZekFnTFRneklDMDJOeUF0TVRVd0lDMHhOVEFnTFRFMU1ITXRNVFV3SURZM0lDMHhOVEFnTVRVd2N6WTNJREUxTUNBeE5UQWdNVFV3WXpFM0lEQWdNelVnTFRRZ05UQWdMVGwyTkRBNWN6RXdNQ0F4TURBZ05qQXdJREV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVlUSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1lUSTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU56QXdJaUFLWkQwaVRUUTVPU0EzTURCak5URWdNQ0F4TURJZ0xUSXdJREUwTVNBdE5UbGpOemdnTFRjNElEYzRJQzB5TURNZ01DQXRNamd4YkMweU5UQWdMVEkwTkdNdE5EZ2dMVFE0SUMweE1qY2dMVFE0SUMweE56VWdNSE10TkRnZ01USTNJREFnTVRjMWJEazJJRGszYkRZNUlDMDJPV3d0T1RBZ0xUazBiQzAzSUMwell5MHhNQ0F0TVRBZ0xURXdJQzB5T0NBd0lDMHpPSE15T0NBdE1UQWdNemdnTUd3eU5UQWdNalEzWXpNM0lEUXdJRE01SURFd01pQXdJREUwTVhNdE1UQTBJRFF3SUMweE5EUWdNR3d0TWpjNElDMHlOelZqTFRZMklDMDJPU0F0TmpnZ0xURTNPU0F3SUMweU5EY0tZelk1SUMwMk9TQXhPREVnTFRZNUlESTFNQ0F3YkRrZ01USnNNVEUySURFeE0ydzJPU0F0Tmpsc0xURXlOU0F0TVRJMVl5MHhNRGNnTFRFd055QXRNamd4SUMweE1EY2dMVE00T0NBd2N5MHhNRGNnTWpneElEQWdNemc0YkRJM09DQXlOekpqTXprZ016a2dPVEFnTlRrZ01UUXhJRFU1ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaE15SWdkVzVwWTI5a1pUMGlKaU40WlRCaE16c2lJQXBrUFNKTk5qQXdJRGd3TUd3eU1EQWdMVEl3TUd3dE1UQXdJQzB4TURCc0xUSXdNQ0F5TURCNlRUUXdNQ0EyTURCc01qQXdJQzB5TURCc0xUUXdNQ0F0TkRBd2FDMHlNREIyTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhOQ0lnZFc1cFkyOWtaVDBpSmlONFpUQmhORHNpSUFwa1BTSk5OVFV3SURnd01HTTRNeUF3SURFMU1DQXRPVEFnTVRVd0lDMHlNREJ6TFRZM0lDMHlNREFnTFRFMU1DQXRNakF3WXkweU1pQXdJQzAwTUNBNElDMDFPU0F4T1dNMklESTJJRGtnTlRJZ09TQTRNV013SURnMElDMHlOeUF4TlRnZ0xUY3lJREl4TW1NeU55QTFNaUEzTVNBNE9DQXhNaklnT0RoNlRUSTFNQ0EzTURCak9ETWdNQ0F4TlRBZ0xUa3dJREUxTUNBdE1qQXdjeTAyTnlBdE1qQXdJQzB4TlRBZ0xUSXdNSE10TVRVd0lEa3dJQzB4TlRBZ01qQXdjelkzSURJd01DQXhOVEFnTWpBd2VrMDNNalVnTXpnMFl6UTBJQzB5TWlBM05TQXROallnTnpVZ0xURXhPSFl0TVRZMmFDMHlNREIyTmpZS1l6QWdOVEFnTFRFM0lEazJJQzAwTkNBeE16UmpOallnTWlBeE1qWWdNek1nTVRZNUlEZzBlazAzTlNBeU9EUmpORFVnTFRVeklERXdOaUF0T0RRZ01UYzFJQzA0TkhNeE16QWdNekVnTVRjMUlEZzBZelEwSUMweU1pQTNOU0F0TmpZZ056VWdMVEV4T0hZdE1UWTJhQzAxTURCMk1UWTJZekFnTlRJZ016RWdPVFlnTnpVZ01URTRlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poTlNJZ2RXNXBZMjlrWlQwaUppTjRaVEJoTlRzaUlBcGtQU0pOTkRBd0lEZ3dNR014TVRBZ01DQXlNREFnTFRFeE1pQXlNREFnTFRJMU1ITXRPVEFnTFRJMU1DQXRNakF3SUMweU5UQnpMVEl3TUNBeE1USWdMVEl3TUNBeU5UQnpPVEFnTWpVd0lESXdNQ0F5TlRCNlRURTVNU0F6TURCak5UUWdMVFl4SURFeU9DQXRNVEF3SURJd09TQXRNVEF3Y3pFMU5TQXpPU0F5TURrZ01UQXdZekV3TmlBdE5TQXhPVEVnTFRreUlERTVNU0F0TWpBd2RpMHhNREJvTFRnd01IWXhNREJqTUNBeE1EZ2dPRFVnTVRrMUlERTVNU0F5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltRTJJaUIxYm1samIyUmxQU0ltSTNobE1HRTJPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHhPU0E0TURCb05EWXlZekV4SURBZ01Ua2dMVGdnTVRrZ0xURTVkaTAzTmpKak1DQXRNVEVnTFRnZ0xURTVJQzB4T1NBdE1UbG9MVFEyTW1NdE1URWdNQ0F0TVRrZ09DQXRNVGtnTVRsMk56WXlZekFnTVRFZ09DQXhPU0F4T1NBeE9YcE5NVEF3SURjd01IWXROVEF3YURNd01IWTFNREJvTFRNd01IcE5NalV3SURFMU1HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJ6TWpJZ0xUVXdJRFV3SUMwMU1ITTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhOeUlnZFc1cFkyOWtaVDBpSmlONFpUQmhOenNpSUFwa1BTSk5NelV3SURnd01HTXhOeUF3SURNMElDMHhJRFV3SUMwemRpMHpPVGRzTFRJNU55QXlPVGRqTmpNZ05qUWdNVFV3SURFd015QXlORGNnTVRBemVrMDFNREFnTmprMFl6RTJPU0F0TWpVZ016QXdJQzB4TmpnZ016QXdJQzB6TkRSak1DQXRNVGt6SUMweE5UY2dMVE0xTUNBdE16VXdJQzB6TlRCakxUZzFJREFnTFRFMk1TQXpNU0F0TWpJeUlEZ3hiREkzTWlBeU56SjJNelF4ZWswNU1TQTFOakpzTWpNM0lDMHlNelJzTFRJeE1pQXRNakV5WXkwM01DQTFOU0F0TVRFMklERXpPQ0F0TVRFMklESXpOR013SURnMElETTFJREUxT0NBNU1TQXlNVEo2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1FNElpQjFibWxqYjJSbFBTSW1JM2hsTUdFNE95SWdDbVE5SWswNU1pQTJOVEJqTUNBeU15QXlNQ0ExTUNBME5pQTFNR2d6YURSb05XZzBNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNR2d0TlRCMkxUSXdNR2d4TURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdhQzB6TURCMkxUTXdNR3d0TlRZZ0xURXdNR3d0TkRRZ01UQXdkak13TUdndE16QXdZekFnTlRVZ05EVWdNVEF3SURFd01DQXhNREJvTVRBd2RqSXdNR2d0TlRCakxUSWdNQ0F0TmlBdE1TQXRPQ0F0TVdNdE1qZ2dNQ0F0TlRBZ01qTWdMVFV3SURVeGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhPU0lnZFc1cFkyOWtaVDBpSmlONFpUQmhPVHNpSUFwa1BTSk5OREF3SURnd01HTXlNakVnTUNBME1EQWdMVEUzT1NBME1EQWdMVFF3TUhNdE1UYzVJQzAwTURBZ0xUUXdNQ0F0TkRBd2N5MDBNREFnTVRjNUlDMDBNREFnTkRBd2N6RTNPU0EwTURBZ05EQXdJRFF3TUhwTk16QXdJRFl3TUhZdE5EQXdiRE13TUNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUZoSWlCMWJtbGpiMlJsUFNJbUkzaGxNR0ZoT3lJZ0NtUTlJazB6TURBZ09EQXdhREl3TUhZdE16QXdhRE13TUhZdE1qQXdhQzB6TURCMkxUTXdNR2d0TWpBd2RqTXdNR2d0TXpBd2RqSXdNR2d6TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poWWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJoWWpzaUlBcGtQU0pOTXpBd0lEZ3dNR2d4TURCMkxUUXdNR2d0TVRBd2RqUXdNSHBOTVRjeUlEWTFObXcyTWlBdE56aHNMVFF3SUMwek1XTXROVGdnTFRRMklDMDVOQ0F0TVRFM0lDMDVOQ0F0TVRrM1l6QWdMVEV6T1NBeE1URWdMVEkxTUNBeU5UQWdMVEkxTUhNeU5UQWdNVEV4SURJMU1DQXlOVEJqTUNBNE1DQXRNemtnTVRVeElDMDVOeUF4T1Rkc0xUTTNJRE14YkRZeUlEYzRiRE00SUMwek1XTTRNaUF0TmpRZ01UTTBJQzB4TmpRZ01UTTBJQzB5TnpWak1DQXRNVGt6SUMweE5UY2dMVE0xTUNBdE16VXdJQzB6TlRCekxUTTFNQ0F4TlRjZ0xUTTFNQ0F6TlRCak1DQXhNVEVnTlRNZ01qRXhJREV6TkNBeU56VjZDaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poWXlJZ2RXNXBZMjlrWlQwaUppTjRaVEJoWXpzaUlBcGtQU0pOTWpBd0lEZ3dNR2cwTURCMkxUSXdNR2d0TkRBd2RqSXdNSHBOT1NBMU1EQm9Oemd5WXpZZ01DQTVJQzB6SURrZ0xUbDJMVEk0TW1Nd0lDMDJJQzB6SUMwNUlDMDVJQzA1YUMwNU1YWXlNREJvTFRZd01IWXRNakF3YUMwNU1XTXROaUF3SUMwNUlETWdMVGtnT1hZeU9ESmpNQ0EySURNZ09TQTVJRGw2VFRJd01DQXpNREJvTkRBd2RpMHpNREJvTFRRd01IWXpNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1Ga0lpQjFibWxqYjJSbFBTSW1JM2hsTUdGa095SWdDbVE5SWswd0lEY3dNR2d4TURCMkxUY3dNR2d0TVRBd2RqY3dNSHBOTnpBd0lEY3dNR2d4TURCMkxUY3dNR2d0TVRBd2RqY3dNSHBOTWpBd0lEWXdNR2d5TURCMkxURXdNR2d0TWpBd2RqRXdNSHBOTXpBd0lEUXdNR2d5TURCMkxURXdNR2d0TWpBd2RqRXdNSHBOTkRBd0lESXdNR2d5TURCMkxURXdNR2d0TWpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWVdVaUlIVnVhV052WkdVOUlpWWplR1V3WVdVN0lpQUtaRDBpVFRNeU5TQTNNREJqTkRJZ0xURTBNU0E0TnlBdE1qZ3dJREV6TVNBdE5ERTVZekk1SURjMElEVTVJREUwT0NBNE9DQXlNakpqTXpBZ0xUVTNJRFU0SUMweE1UUWdPRGNnTFRFM01tZ3hOamwyTFRFd01HZ3RNak14YkMweE15QXlPR010TXpjZ0xUa3lJQzAzTkNBdE1UZzBJQzB4TVRJZ0xUSTNOV010TXpnZ01USTVJQzAzT1NBeU5UY2dMVEV4T1NBek9EVmpMVFF5SUMweE16TWdMVGd6SUMweU5qY2dMVEV5TlNBdE5EQXdZeTB5T0NBNE9DQXROVFlnTVRjMUlDMDROQ0F5TmpKb0xURXhObll4TURCb01UZzRiRGtnTFRNMGJETWdMVFpqTkRJZ01UTTNJRGd6SURJM015QXhNalVnTkRBNWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhaaUlnZFc1cFkyOWtaVDBpSmlONFpUQmhaanNpSUFwa1BTSk5NakF3SURZd01HTXdJRFUzSURReklERXdNQ0F4TURBZ01UQXdjekV3TUNBdE5ETWdNVEF3SUMweE1EQmpNQ0F0TWpnZ0xURTRJQzAwT0NBdE1qZ2dMVGN5WXkweklDMDJJQzB6SUMweE5pQXRNeUF0TWpob01qTXhkaTB5TXpGak1USWdNQ0F5TWlBd0lESTRJRE5qTWpRZ01UQWdORFFnTWpnZ056SWdNamhqTlRjZ01DQXhNREFnTFRReklERXdNQ0F0TVRBd2N5MDBNeUF0TVRBd0lDMHhNREFnTFRFd01HTXRNamdnTUNBdE5EZ2dNVGdnTFRjeUlESTRZeTAySURNZ0xURTJJRE1nTFRJNElETjJMVEl6TVdndE1qTXhZekFnTVRJZ01DQXlNaUF6SURJNFl6RXdJREkwSURJNElEUTBJREk0SURjeUNtTXdJRFUzSUMwME15QXhNREFnTFRFd01DQXhNREJ6TFRFd01DQXRORE1nTFRFd01DQXRNVEF3WXpBZ0xUSTRJREU0SUMwME9DQXlPQ0F0TnpKak15QXROaUF6SUMweE5pQXpJQzB5T0dndE1qTXhkall3TUdneU16RmpNQ0F4TWlBd0lESXlJQzB6SURJNFl5MHhNQ0F5TkNBdE1qZ2dORFFnTFRJNElEY3llaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppTUNJZ2RXNXBZMjlrWlQwaUppTjRaVEJpTURzaUlHaHZjbWw2TFdGa2RpMTRQU0kxTURBaUlBcGtQU0pOTWpRM0lEY3dNR000TkNBd0lERTBPQ0F0TWpBZ01Ua3hJQzAxT1hNMU9TQXRPVE1nTlRrZ0xURTBNV013SUMweE1UY2dMVFk1SUMweE9ERWdMVEV4T1NBdE1qSTFjeTA0TVNBdE5qY2dMVGd4SUMweE5UQjJMVEkxYUMweE1EQjJNalZqTUNBeE1UY2dOalVnTVRneElERXhOU0F5TWpWek9EVWdOamNnT0RVZ01UVXdZekFnTWpVZ0xUZ2dORGdnTFRJNElEWTJjeTAxTmlBek5DQXRNVEl5SURNMGN5MDVOeUF0TVRnZ0xURXhOaUF0TXpkekxUSTNJQzAwTXlBdE16RWdMVFk1YkMweE1EQWdNVEpqTlNBek9DQXhPU0E0T0NBMU9TQXhNamh6TVRBeklEWTJJREU0T0NBMk5ucE5NVGszSURCb01UQXdDbll0TVRBd2FDMHhNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmlNU0lnZFc1cFkyOWtaVDBpSmlONFpUQmlNVHNpSUFwa1BTSk5ORFV3SURnd01HTXhNemdnTUNBeU5UQWdMVEV4TWlBeU5UQWdMVEkxTUhZdE5UQmpOVGdnTFRJeElERXdNQ0F0T0RVZ01UQXdJQzB4TlRCak1DQXROamtnTFRRNElDMHhNamNnTFRFeE1pQXRNVFEwWXkweU1pQTFOU0F0TnpVZ09UUWdMVEV6T0NBNU5HTXRNakFnTUNBdE16a2dMVFVnTFRVMklDMHhNbU10TVRjZ05qUWdMVGMxSURFeE1pQXRNVFEwSURFeE1uTXRNVEkzSUMwME9DQXRNVFEwSUMweE1USmpMVEUzSURjZ0xUTTJJREV5SUMwMU5pQXhNbU10TXpjZ01DQXROekVnTFRFeUlDMDVOeUF0TXpSakxUTXpJRE0ySUMwMU15QTRNaUF0TlRNZ01UTTBDbU13SURFeE1DQTVNQ0F5TURBZ01qQXdJREl3TUdNeU15QXhNVFFnTVRJNUlESXdNQ0F5TlRBZ01qQXdlazB6TXpRZ016QXdhRFJvTTJNeklEQWdOaUF4SURrZ01XTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQjJMVEYyTFRJd01HTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1IWXlNREIyTW1Nd0lESXdJREUxSURReUlETTBJRFE0ZWsweE16UWdNakF3YURSb00yTXpJREFnTmlBeElEa2dNV015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEIyTFRGMkxURXdNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCekxUVXdJREl5SUMwMU1DQTFNSFl4TURCMk1ncGpNQ0F5TUNBeE5TQTBNaUF6TkNBME9IcE5OVE0wSURJd01HZ3phRFJqTXlBd0lEWWdNU0E1SURGak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2RpMHhkaTB4TURCak1DQXRNamdnTFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCMk1UQXdkakpqTUNBeU1DQXhOU0EwTWlBek5DQTBPSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWWpJaUlIVnVhV052WkdVOUlpWWplR1V3WWpJN0lpQUtaRDBpVFRZd01DQTRNREJzTWpBd0lDMHhOVEJzTFRJd01DQXRNVFV3ZGpFd01HZ3ROVEJzTFRFMU15QXRNVGt4YkRFM05TQXRNakEyYkRZZ0xUTm9NakoyTVRBd2JESXdNQ0F0TVRVd2JDMHlNREFnTFRFMU1IWXhNREJvTFRJMVl5MHpOU0F3SUMwMU5pQXhNaUF0TnpnZ016aHNMVEUyTmlBeE9UQnNMVEUxTXlBdE1Ua3dZeTB5TWlBdE1qY2dMVFF6SUMwek9DQXROemdnTFRNNGFDMHhNREIyTVRBd2FERXdNR3d4TmpZZ01qQTJiQzB4TmpNZ01Ua3hiQzB6SUROb0xURXdNSFl4TURCb01UQXdZek0wSURBZ05UWWdMVEV5SURjNElDMHpPR3d4TlRNZ0xURTNPR3d4TkRFZ01UYzRDbU15TWlBeU55QTBNeUF6T0NBM09DQXpPR2cxTUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUl6SWlCMWJtbGpiMlJsUFNJbUkzaGxNR0l6T3lJZ0NtUTlJazAwTURBZ09EQXdZekV4TUNBd0lESXdPU0F0TkRjZ01qZ3hJQzB4TVRsc01URTVJREV4T1hZdE16QXdhQzB6TURCc01UQTVJREV3T1dNdE5UUWdOVFVnTFRFeU5pQTVNU0F0TWpBNUlEa3hZeTB4TmpZZ01DQXRNekF3SUMweE16UWdMVE13TUNBdE16QXdjekV6TkNBdE16QXdJRE13TUNBdE16QXdZemd6SURBZ01UVTRJRE0wSURJeE1pQTRPR3czTWlBdE56SmpMVGN5SUMwM01pQXRNVGMwSUMweE1UWWdMVEk0TkNBdE1URTJZeTB5TWpBZ01DQXROREF3SURFNE1DQXROREF3SURRd01ITXhPREFnTkRBd0lEUXdNQ0EwTURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltSTBJaUIxYm1samIyUmxQU0ltSTNobE1HSTBPeUlnQ21ROUlrMDBNREFnT0RBd2FEUXdNSFl0TkRBd2JDMHhOallnTVRZMmJDMDBNREFnTFRRd01Hd3hOallnTFRFMk5tZ3ROREF3ZGpRd01Hd3hOallnTFRFMk5tdzBNREFnTkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmlOU0lnZFc1cFkyOWtaVDBpSmlONFpUQmlOVHNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5NalV3SURnd01Hd3lOVEFnTFRNd01HZ3RNakF3ZGkweU1EQm9NakF3YkMweU5UQWdMVE13TUd3dE1qVXdJRE13TUdneU1EQjJNakF3YUMweU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUkySWlCMWJtbGpiMlJsUFNJbUkzaGxNR0kyT3lJZ0NtUTlJazB6TURBZ05qQXdkaTB5TURCb01qQXdkakl3TUd3ek1EQWdMVEkxTUd3dE16QXdJQzB5TlRCMk1qQXdhQzB5TURCMkxUSXdNR3d0TXpBd0lESTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWWpjaUlIVnVhV052WkdVOUlpWWplR1V3WWpjN0lpQUtaRDBpVFRBZ09EQXdZelEwTVNBd0lEZ3dNQ0F0TXpVNUlEZ3dNQ0F0T0RBd2FDMHlNREJqTUNBek16TWdMVEkyTnlBMk1EQWdMVFl3TUNBMk1EQjJNakF3ZWswd0lEVXdNR015TnpVZ01DQTFNREFnTFRJeU5TQTFNREFnTFRVd01HZ3RNakF3WXpBZ01UWTNJQzB4TXpNZ016QXdJQzB6TURBZ016QXdkakl3TUhwTk1DQXlNREJqTVRFd0lEQWdNakF3SUMwNU1DQXlNREFnTFRJd01HZ3RNakF3ZGpJd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZamdpSUhWdWFXTnZaR1U5SWlZamVHVXdZamc3SWlBS1pEMGlUVEV3TUNBNE1EQmpNemcySURBZ056QXdJQzB6TVRRZ056QXdJQzAzTURCb0xURXdNR013SURNek1pQXRNalk0SURZd01DQXROakF3SURZd01IWXhNREI2VFRFd01DQTJNREJqTWpjMklEQWdOVEF3SUMweU1qUWdOVEF3SUMwMU1EQm9MVEV3TUdNd0lESXlNaUF0TVRjNElEUXdNQ0F0TkRBd0lEUXdNSFl4TURCNlRURXdNQ0EwTURCak1UWTFJREFnTXpBd0lDMHhNelVnTXpBd0lDMHpNREJvTFRFd01HTXdJREV4TVNBdE9Ea2dNakF3SUMweU1EQWdNakF3ZGpFd01IcE5NVEF3SURJd01HTTFOU0F3SURFd01DQXRORFVnTVRBd0lDMHhNREJ6TFRRMUlDMHhNREFnTFRFd01DQXRNVEF3Q25NdE1UQXdJRFExSUMweE1EQWdNVEF3Y3pRMUlERXdNQ0F4TURBZ01UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppT1NJZ2RXNXBZMjlrWlQwaUppTjRaVEJpT1RzaUlBcGtQU0pOTXpBd0lEZ3dNR2cwTURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdkaTB5TURCb0xUUXdNSFl4TlRCak1DQXlPQ0F0TWpJZ05UQWdMVFV3SURVd2N5MDFNQ0F0TWpJZ0xUVXdJQzAxTUhZdE1qVXdhRFF3TUhZdE16QXdZekFnTFRVMUlDMDBOU0F0TVRBd0lDMHhNREFnTFRFd01HZ3ROVEF3WXkwMU5TQXdJQzB4TURBZ05EVWdMVEV3TUNBeE1EQjJNakF3YURFd01IWXRNVFV3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQjJOVFV3WXpBZ05UVWdORFVnTVRBd0lERXdNQ0F4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltSmhJaUIxYm1samIyUmxQU0ltSTNobE1HSmhPeUlnQ21ROUlrMDNOU0EzTURCb01qSTFkaTB4TURCb0xUSXdNSFl0TlRBd2FEUXdNSFl4TURCb01UQXdkaTB4TWpWak1DQXROREVnTFRNMElDMDNOU0F0TnpVZ0xUYzFhQzAwTlRCakxUUXhJREFnTFRjMUlETTBJQzAzTlNBM05YWTFOVEJqTUNBME1TQXpOQ0EzTlNBM05TQTNOWHBOTmpBd0lEY3dNR3d5TURBZ0xUSXdNR3d0TWpBd0lDMHlNREIyTVRBd2FDMHlNREJqTFRrMElEQWdMVEUzTXlBdE5qVWdMVEU1TkNBdE1UVXpZekl6SURFNU9TQXhPRGtnTXpVeklETTVOQ0F6TlROMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppWWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJpWWpzaUlBcGtQU0pOTlRBd0lEY3dNR3d6TURBZ0xUSTROR3d0TXpBd0lDMHpNVFoyTWpBd2FDMHhNREJqTFRJd01DQXdJQzB6TkRnZ0xURXdNaUF0TkRBd0lDMHpNREJqTUNBeU9UVWdNVEF3SURVd01DQTFNREFnTlRBd2RqSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWW1NaUlIVnVhV052WkdVOUlpWWplR1V3WW1NN0lpQUtaRDBpVFRNNE1TQTNPVEZzTVRrZ09Xd3hPU0F0T1dNeE1qY2dMVFV6SURJMU15QXRNVEE0SURNNE1TQXRNVFl3ZGkwek1XTXdJQzB4TmpZZ0xUWTNJQzB6TVRNZ0xURTBOeUF0TkRFNVl5MDBNQ0F0TlRNZ0xUZ3pJQzA1TnlBdE1USTFJQzB4TWpoekxUZ3lJQzAxTXlBdE1USTRJQzAxTTNNdE9EWWdNaklnTFRFeU9DQTFNM010T0RVZ056VWdMVEV5TlNBeE1qaGpMVGd3SURFd055QXRNVFEzSURJMU15QXRNVFEzSURReE9YWXpNV014TWpnZ05USWdNalUwSURFd055QXpPREVnTVRZd2VrMDBNREFnTVRBd2RqVTVNV3d0TWprMElDMHhNakpqT0NBdE1USTJJRFU0SUMweU5ETWdNVEl5SUMwek1qZ0tZek0xSUMwME5pQTNNeUF0T0RZZ01UQTJJQzB4TVRCek5qSWdMVE14SURZMklDMHpNWG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWW1RaUlIVnVhV052WkdVOUlpWWplR1V3WW1RN0lpQUtaRDBpVFRZd01DQTRNREJvTVRBd2RpMDRNREJvTFRFd01IWTRNREI2VFRRd01DQTNNREJvTVRBd2RpMDNNREJvTFRFd01IWTNNREI2VFRJd01DQTFNREJvTVRBd2RpMDFNREJvTFRFd01IWTFNREI2VFRBZ016QXdhREV3TUhZdE16QXdhQzB4TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppWlNJZ2RXNXBZMjlrWlQwaUppTjRaVEJpWlRzaUlBcGtQU0pOTXpBd0lEZ3dNR2d4TURCMkxUSXdNR2d5TURCc01UQXdJQzB4TURCc0xURXdNQ0F0TVRBd2FDMHlNREIyTFRRd01HZ3RNVEF3ZGpVd01HZ3RNakF3YkMweE1EQWdNVEF3YkRFd01DQXhNREJvTWpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWW1ZaUlIVnVhV052WkdVOUlpWWplR1V3WW1ZN0lpQUtaRDBpVFRJd01DQTRNREJvTVRBd2RpMDJNREJvTWpBd2JDMHlOVEFnTFRJd01Hd3RNalV3SURJd01HZ3lNREIyTmpBd2VrMDBNREFnT0RBd2FESXdNSFl0TVRBd2FDMHlNREIyTVRBd2VrMDBNREFnTmpBd2FETXdNSFl0TVRBd2FDMHpNREIyTVRBd2VrMDBNREFnTkRBd2FEUXdNSFl0TVRBd2FDMDBNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmpNQ0lnZFc1cFkyOWtaVDBpSmlONFpUQmpNRHNpSUFwa1BTSk5NakF3SURnd01HZ3hNREIyTFRZd01HZ3lNREJzTFRJMU1DQXRNakF3YkMweU5UQWdNakF3YURJd01IWTJNREI2VFRRd01DQTRNREJvTkRBd2RpMHhNREJvTFRRd01IWXhNREI2VFRRd01DQTJNREJvTXpBd2RpMHhNREJvTFRNd01IWXhNREI2VFRRd01DQTBNREJvTWpBd2RpMHhNREJvTFRJd01IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1NeElpQjFibWxqYjJSbFBTSW1JM2hsTUdNeE95SWdDbVE5SWswM05TQTNNREJvTmpVd1l6UXhJREFnTnpVZ0xUTTBJRGMxSUMwM05YWXROVFV3WXpBZ0xUUXhJQzB6TkNBdE56VWdMVGMxSUMwM05XZ3ROalV3WXkwME1TQXdJQzAzTlNBek5DQXROelVnTnpWMk5UVXdZekFnTkRFZ016UWdOelVnTnpVZ056VjZUVEV3TUNBMk1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVE13TUNBMk1EQjJMVEV3TUdnME1EQjJNVEF3YUMwME1EQjZUVEV3TUNBME1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVE13TUNBME1EQjJMVEV3TUdnME1EQjJNVEF3YUMwME1EQjZUVEV3TUNBeU1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVE13TUNBeU1EQUtkaTB4TURCb05EQXdkakV3TUdndE5EQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0pqTWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJqTWpzaUlBcGtQU0pOTkRBd0lEZ3dNR3d4TURBZ0xUTXdNR2d6TURCc0xUSTFNQ0F0TWpBd2JERXdNQ0F0TXpBd2JDMHlOVEFnTWpBd2JDMHlOVEFnTFRJd01Hd3hNREFnTXpBd2JDMHlOVEFnTWpBd2FETXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWXpNaUlIVnVhV052WkdVOUlpWWplR1V3WXpNN0lpQUtaRDBpVFRRd01DQTRNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazB4TlRBZ056QXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1IcE5OalV3SURjd01HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEJ6TWpJZ05UQWdOVEFnTlRCNlRUUXdNQ0EyTURCak1URXdJREFnTWpBd0lDMDVNQ0F5TURBZ0xUSXdNQXB6TFRrd0lDMHlNREFnTFRJd01DQXRNakF3Y3kweU1EQWdPVEFnTFRJd01DQXlNREJ6T1RBZ01qQXdJREl3TUNBeU1EQjZUVFV3SURRMU1HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEJ6TWpJZ05UQWdOVEFnTlRCNlRUYzFNQ0EwTlRCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdjekl5SURVd0lEVXdJRFV3ZWsweE5UQWdNakF3WXpJNElEQWdOVEFnTFRJeUlEVXdJQzAxTUhNdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1BcHpNaklnTlRBZ05UQWdOVEI2VFRZMU1DQXlNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazAwTURBZ01UQXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZelFpSUhWdWFXTnZaR1U5SWlZamVHVXdZelE3SWlBS1pEMGlUVE0wSURnd01HZzJNekpqTVRnZ01DQXpOQ0F0TVRZZ016UWdMVE0wZGkwM016SmpNQ0F0TVRnZ0xURTJJQzB6TkNBdE16UWdMVE0wYUMwMk16SmpMVEU0SURBZ0xUTTBJREUySUMwek5DQXpOSFkzTXpKak1DQXhPQ0F4TmlBek5DQXpOQ0F6TkhwTk1UQXdJRGN3TUhZdE5UQXdhRFV3TUhZMU1EQm9MVFV3TUhwTk16VXdJREUxTUdNdE16Z2dNQ0F0TmpNZ0xUUXlJQzAwTkNBdE56VnpOamtnTFRNeklEZzRJREJ6TFRZZ056VWdMVFEwSURjMWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmpOU0lnZFc1cFkyOWtaVDBpSmlONFpUQmpOVHNpSUFwa1BTSk5NQ0E0TURCb016QXdiRFV3TUNBdE5UQXdiQzB6TURBZ0xUTXdNR3d0TlRBd0lEVXdNSFl6TURCNlRUSXdNQ0EzTURCakxUVTFJREFnTFRFd01DQXRORFVnTFRFd01DQXRNVEF3Y3pRMUlDMHhNREFnTVRBd0lDMHhNREJ6TVRBd0lEUTFJREV3TUNBeE1EQnpMVFExSURFd01DQXRNVEF3SURFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZellpSUhWdWFXTnZaR1U5SWlZamVHVXdZelk3SWlBS1pEMGlUVEFnTmpBd2FESXdNR3d6TURBZ0xUTXdNR3d0TWpBd0lDMHlNREJzTFRNd01DQXpNREIyTWpBd2VrMHpOREFnTmpBd2FERTJNR3d6TURBZ0xUTXdNR3d0TWpBd0lDMHlNREJzTFRjNElEYzRiREV4T1NBeE1qSjZUVEUxTUNBMU1EQmpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3Y3pJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEJ6TFRJeUlEVXdJQzAxTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZemNpSUhWdWFXTnZaR1U5SWlZamVHVXdZemM3SWlBS1pEMGlUVFF3TUNBNE1EQmpNakl3SURBZ05EQXdJQzB4T0RBZ05EQXdJQzAwTURCekxURTRNQ0F0TkRBd0lDMDBNREFnTFRRd01ITXROREF3SURFNE1DQXROREF3SURRd01ITXhPREFnTkRBd0lEUXdNQ0EwTURCNlRUUXdNQ0EzTURCakxURTJOaUF3SUMwek1EQWdMVEV6TkNBdE16QXdJQzB6TURCek1UTTBJQzB6TURBZ016QXdJQzB6TURCek16QXdJREV6TkNBek1EQWdNekF3Y3kweE16UWdNekF3SUMwek1EQWdNekF3ZWswME1EQWdOakF3WXpFeE1DQXdJREl3TUNBdE9UQWdNakF3SUMweU1EQnpMVGt3SUMweU1EQWdMVEl3TUNBdE1qQXdjeTB5TURBZ09UQWdMVEl3TUNBeU1EQUtjemt3SURJd01DQXlNREFnTWpBd2VrMDBNREFnTlRBd1l5MDFOaUF3SUMweE1EQWdMVFEwSUMweE1EQWdMVEV3TUhNME5DQXRNVEF3SURFd01DQXRNVEF3Y3pFd01DQTBOQ0F4TURBZ01UQXdjeTAwTkNBeE1EQWdMVEV3TUNBeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbU00SWlCMWJtbGpiMlJsUFNJbUkzaGxNR000T3lJZ0NtUTlJazB3SURjd01HZzFOVGxzTFRFd01DQXRNVEF3YUMwek5UbDJMVFV3TUdnMU1EQjJNVFU1YkRFd01DQXhNREIyTFRNMU9XZ3ROekF3ZGpjd01IcE5OekF3SURjd01Hd3hNREFnTFRFd01Hd3ROREF3SUMwME1EQnNMVEl3TUNBeU1EQnNNVEF3SURFd01Hd3hNREFnTFRFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZemtpSUhWdWFXTnZaR1U5SWlZamVHVXdZems3SWlBS1pEMGlUVGtnT0RBd2FEYzRNbU0ySURBZ09TQXRNeUE1SUMwNWRpMDNPREpqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0TnpneVl5MDJJREFnTFRrZ015QXRPU0E1ZGpjNE1tTXdJRFlnTXlBNUlEa2dPWHBOTVRVd0lEY3lNbXd0TnpJZ0xUY3liREV3TUNBdE1UQXdiQzB4TURBZ0xURXdNR3czTWlBdE56SnNNVGN5SURFM01ucE5OREF3SURVd01IWXRNVEF3YURNd01IWXhNREJvTFRNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZMkVpSUhWdWFXTnZaR1U5SWlZamVHVXdZMkU3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TWpBd2FDMDFNR013SURVMUlDMDBOU0F4TURBZ0xURXdNQ0F4TURCb0xURTFNSFl0TlRVd1l6QWdMVEk0SURJeUlDMDFNQ0ExTUNBdE5UQm9OVEIyTFRFd01HZ3ROREF3ZGpFd01HZzFNR015T0NBd0lEVXdJREl5SURVd0lEVXdkalUxTUdndE1UVXdZeTAxTlNBd0lDMHhNREFnTFRRMUlDMHhNREFnTFRFd01HZ3ROVEIyTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmpZaUlnZFc1cFkyOWtaVDBpSmlONFpUQmpZanNpSUFwa1BTSk5NQ0EzTURCb01UQXdkaTAwTURCb0xURXdNSFkwTURCNlRUSXdNQ0EzTURCb016VXdZekl4SURBZ016a2dMVEV6SURRM0lDMHpNV013SURBZ01UQXpJQzB5T1RFZ01UQXpJQzB6TVRsekxUSXlJQzAxTUNBdE5UQWdMVFV3YUMweE5UQmpMVEk0SURBZ0xUVXdJQzB5TlNBdE5UQWdMVFV3Y3pNNUlDMHhOVGdnTkRjZ0xURTROSE10TlNBdE5UVWdMVE14SUMwMk0zTXROVElnTlNBdE5qWWdNekZ6TFRFd09TQXlNVGtnTFRFeU9DQXlNemh6TFRRMElESTRJQzAzTWlBeU9IWTBNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1OaklpQjFibWxqYjJSbFBTSW1JM2hsTUdOak95SWdDbVE5SWswME1EQWdOalkyWXpFd0lERTVJREk0SURNeUlEUTNJRE0wYkRFNUlDMHpZekkySUMwNElETTVJQzB6TnlBek1TQXROak56TFRRM0lDMHhOVGtnTFRRM0lDMHhPRFJ6TWpJZ0xUVXdJRFV3SUMwMU1HZ3hOVEJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweE1ETWdMVE14T1NBdE1UQXpJQzB6TVRsakxUZ2dMVEU0SUMweU5pQXRNekVnTFRRM0lDMHpNV2d0TXpVd2RqUXdNR015T0NBd0lEVXpJRGtnTnpJZ01qaHpNVEUwSURJeE1pQXhNamdnTWpNNGVrMHdJRFF3TUdneE1EQjJMVFF3TUdndE1UQXdkalF3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVkyUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1kyUTdJaUFLWkQwaVRUSXdNQ0EzTURCb016QXdkaTB4TURCb0xURXdNSFl0Tm1NeU5TQXROQ0ExTUNBdE9DQTNNaUF0TVRac0xUTTBJQzA1TkdNdE1qZ2dNVEVnTFRVNElERTJJQzA0T0NBeE5tTXRNVE01SURBZ0xUSTFNQ0F0TVRFeElDMHlOVEFnTFRJMU1ITXhNVEVnTFRJMU1DQXlOVEFnTFRJMU1ITXlOVEFnTVRFeElESTFNQ0F5TlRCak1DQXpNU0F0TlNBMk1DQXRNVFlnT0Roc09URWdNemRqTVRRZ0xUTTRJREkxSUMwNE1TQXlOU0F0TVRJMVl6QWdMVEU1TXlBdE1UVTNJQzB6TlRBZ0xUTTFNQ0F0TXpVd2N5MHpOVEFnTVRVM0lDMHpOVEFnTXpVd1l6QWdNVGMySURFek1DQXpNak1nTXpBd0lETTBOM1l6Q21ndE1UQXdkakV3TUhwTk56QXdJRFU0TkdNd0lEQWdMVEk1TmlBdE16UTRJQzB6TVRZZ0xUTTJPSE10TkRnZ0xUSXdJQzAyT0NBd2N5MHlNQ0EwT0NBd0lEWTRjek00TkNBek1EQWdNemcwSURNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZMlVpSUhWdWFXTnZaR1U5SWlZamVHVXdZMlU3SWlBS1pEMGlUVFl3TUNBM01EQnNNakF3SUMweE5UQnNMVEl3TUNBdE1UVXdkakV3TUdndE5qQXdkakV3TUdnMk1EQjJNVEF3ZWsweU1EQWdNekF3ZGkweE1EQm9OakF3ZGkweE1EQm9MVFl3TUhZdE1UQXdiQzB5TURBZ01UVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0pqWmlJZ2RXNXBZMjlrWlQwaUppTjRaVEJqWmpzaUlBcGtQU0pOTXpBd0lEZ3dNR2d4TURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdhREV3TUdNMU5TQXdJREV3TUNBdE5EVWdNVEF3SUMweE1EQm9MVGN3TUdNd0lEVTFJRFExSURFd01DQXhNREFnTVRBd2FERXdNR013SURVMUlEUTFJREV3TUNBeE1EQWdNVEF3ZWsweE1EQWdOVEF3YURFd01IWXRNelV3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQjJNelV3YURFd01IWXRNelV3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQjJNelV3YURFd01IWXRORGd4WXpBZ0xURXhJQzA0SUMweE9TQXRNVGtnTFRFNWFDMDBOaklLWXkweE1TQXdJQzB4T1NBNElDMHhPU0F4T1hZME9ERjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVF3SWlCMWJtbGpiMlJsUFNJbUkzaGxNR1F3T3lJZ0NtUTlJazB4TURBZ09EQXdhREl3TUhZdE5EQXdZekFnTFRVMUlEUTFJQzB4TURBZ01UQXdJQzB4TURCek1UQXdJRFExSURFd01DQXhNREIyTkRBd2FERXdNSFl0TkRBd1l6QWdMVEV4TUNBdE9UQWdMVEl3TUNBdE1qQXdJQzB5TURCb0xUVXdZeTB4TXpnZ01DQXRNalV3SURrd0lDMHlOVEFnTWpBd2RqUXdNSHBOTUNBeE1EQm9OekF3ZGkweE1EQm9MVGN3TUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVF4SWlCMWJtbGpiMlJsUFNJbUkzaGxNR1F4T3lJZ0NtUTlJazA1SURjd01HZ3hPREpqTmlBd0lEa2dMVE1nT1NBdE9YWXRORGd5WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRFNE1tTXROaUF3SUMwNUlETWdMVGtnT1hZME9ESmpNQ0EySURNZ09TQTVJRGw2VFRZd09TQTNNREJvTVRneVl6WWdNQ0E1SUMweklEa2dMVGwyTFRRNE1tTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMHhPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJORGd5WXpBZ05pQXpJRGtnT1NBNWVrMHpNRGtnTlRBd2FERTRNbU0ySURBZ09TQXRNeUE1SUMwNWRpMHlPREpqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0TVRneVl5MDJJREFnTFRrZ015QXRPU0E1ZGpJNE1ncGpNQ0EySURNZ09TQTVJRGw2VFRBZ01UQXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0prTWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJrTWpzaUlBcGtQU0pOTVRBZ056QXdhREU0TVdNMklEQWdPU0F0TXlBNUlDMDVkaTB4T1RGb0xUSXdNSFl4T1RGak1DQTJJRFFnT1NBeE1DQTVlazAyTVRBZ056QXdhREU0TVdNMklEQWdPU0F0TXlBNUlDMDVkaTB4T1RGb0xUSXdNSFl4T1RGak1DQTJJRFVnT1NBeE1DQTVlazB6TVRBZ05qQXdhREU0TVdNMklEQWdPU0F0TXlBNUlDMDVkaTA1TVdndE1qQXdkamt4WXpBZ05pQTBJRGtnTVRBZ09YcE5NQ0EwTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUQWdNakF3YURJd01IWXRNVGt4WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRFNE1tTXROaUF3SUMwNUlETWdMVGtnT1hZeE9URjZUVE13TUNBeU1EQUthREl3TUhZdE9URmpNQ0F0TmlBdE15QXRPU0F0T1NBdE9XZ3RNVGd4WXkwMklEQWdMVEV3SURNZ0xURXdJRGwyT1RGNlRUWXdNQ0F5TURCb01qQXdkaTB4T1RGak1DQXROaUF0TXlBdE9TQXRPU0F0T1dndE1UZ3hZeTAySURBZ0xURXdJRE1nTFRFd0lEbDJNVGt4ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKa015SWdkVzVwWTI5a1pUMGlKaU40WlRCa016c2lJQXBrUFNKTk1DQTNNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRrZ05UQXdhREU0TW1NMklEQWdPU0F0TXlBNUlDMDVkaTAwT0RKak1DQXROaUF0TXlBdE9TQXRPU0F0T1dndE1UZ3lZeTAySURBZ0xUa2dNeUF0T1NBNWRqUTRNbU13SURZZ015QTVJRGtnT1hwTk16QTVJRFV3TUdneE9ESmpOaUF3SURrZ0xUTWdPU0F0T1hZdE1qZ3lZekFnTFRZZ0xUTWdMVGtnTFRrZ0xUbG9MVEU0TW1NdE5pQXdJQzA1SURNZ0xUa2dPWFl5T0RKak1DQTJJRE1nT1NBNUlEbDZUVFl3T1NBMU1EQm9NVGd5WXpZZ01DQTVJQzB6SURrZ0xUbDJMVFE0TW1Nd0lDMDJJQzB6SUMwNUlDMDVJQzA1YUMweE9ESUtZeTAySURBZ0xUa2dNeUF0T1NBNWRqUTRNbU13SURZZ015QTVJRGtnT1hvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVpEUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1pEUTdJaUFLWkQwaVRUVXdJRFl3TUdnMU1EQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTB4TlRCc01UQXdJREV3TUdneE1EQjJMVE13TUdndE1UQXdiQzB4TURBZ01UQXdkaTB4TlRCak1DQXRNamdnTFRJeUlDMDFNQ0F0TlRBZ0xUVXdhQzAxTURCakxUSTRJREFnTFRVd0lESXlJQzAxTUNBMU1IWTBNREJqTUNBeU9DQXlNaUExTUNBMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWkRVaUlIVnVhV052WkdVOUlpWWplR1V3WkRVN0lpQUtaRDBpVFRNek5DQTRNREJvTmpaMkxUZ3dNR2d0Tmpac0xURXpOQ0F5TURCb0xUSXdNSFkwTURCb01qQXdlazAxTURBZ05qQXdkakV3TUdNeU5pQXdJRFV5SUMwMElEYzFJQzB4TUdNeE16QWdMVE16SURJeU5TQXRNVFV3SURJeU5TQXRNamt3Y3kwNU5TQXRNalU0SUMweU1qVWdMVEk1TVdndE0yTXRNak1nTFRZZ0xUUTNJQzA1SUMwM01pQXRPWFl4TURCak1UY2dNQ0F6TkNBeUlEVXdJRFpqT0RZZ01qSWdNVFV3SURFd01DQXhOVEFnTVRrMGN5MDJOQ0F4TnpJZ0xURTFNQ0F4T1RSakxURTJJRFFnTFRNeklEWWdMVFV3SURaNlRUVXdNQ0ExTURCc01qVWdMVE1LWXpRMElDMHhNU0EzTlNBdE5URWdOelVnTFRrM2N5MHpNaUF0T0RZZ0xUYzFJQzA1TjJ3dE1qVWdMVE4yTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmtOaUlnZFc1cFkyOWtaVDBpSmlONFpUQmtOanNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5Nek0wSURnd01HZzJObll0T0RBd2FDMDJObXd0TVRNMElESXdNR2d0TWpBd2RqUXdNR2d5TURCNlRUVXdNQ0ExTURCc01qVWdMVE5qTkRRZ0xURXhJRGMxSUMwMU1TQTNOU0F0T1RkekxUTXlJQzA0TmlBdE56VWdMVGszYkMweU5TQXRNM1l5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltUTNJaUIxYm1samIyUmxQU0ltSTNobE1HUTNPeUlnYUc5eWFYb3RZV1IyTFhnOUlqUXdNQ0lnQ21ROUlrMHpNelFnT0RBd2FEWTJkaTA0TURCb0xUWTJiQzB4TXpRZ01qQXdhQzB5TURCMk5EQXdhREl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVpEZ2lJSFZ1YVdOdlpHVTlJaVlqZUdVd1pEZzdJaUFLWkQwaVRUTXdPU0E0TURCb09ESmpOaUF3SURFd0lDMDBJREV5SUMwNWJESTVOQ0F0TmpneWJETWdMVEU1ZGkwNE1XTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDJPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJPREZzTXlBeE9Xd3lPVFFnTmpneVl6SWdOU0EySURrZ01USWdPWHBOTXpBd0lEVXdNSFl0TWpBd2FERXdNSFl5TURCb0xURXdNSHBOTXpBd0lESXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWkRraUlIVnVhV052WkdVOUlpWWplR1V3WkRrN0lpQUtaRDBpVFRNM05TQTRNREJqTVRNNElEQWdNalk1SUMwek9TQXpOemdnTFRFd09Xd3ROVE1nTFRneVl5MDVNeUEyTUNBdE1qQTFJRGt4SUMwek1qVWdPVEZqTFRFeE9TQXdJQzB5TWprZ0xUTXlJQzB6TWpJZ0xUa3hiQzAxTXlBNE1tTXhNRGtnTnpBZ01qTTNJREV3T1NBek56VWdNVEE1ZWswek56VWdOVEF3WXpjNElEQWdNVFUwSUMweU15QXlNVFlnTFRZeWJDMDFNeUF0T0RWakxUUTJJRE13SUMweE1EUWdORGNnTFRFMk15QTBOMk10TmpBZ01DQXRNVEV5SUMweE55QXRNVFU1SUMwME4yd3ROVFFnT0RWak5qSWdOREFnTVRNMElEWXlJREl4TXlBMk1ucE5NemMxSURJd01BcGpOVFVnTUNBeE1EQWdMVFExSURFd01DQXRNVEF3Y3kwME5TQXRNVEF3SUMweE1EQWdMVEV3TUhNdE1UQXdJRFExSUMweE1EQWdNVEF3Y3pRMUlERXdNQ0F4TURBZ01UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0prWVNJZ2RXNXBZMjlrWlQwaUppTjRaVEJrWVRzaUlHaHZjbWw2TFdGa2RpMTRQU0k1TURBaUlBcGtQU0pOTlRVeElEZ3dNR014TmlBd0lETXlJREFnTkRjZ0xUTnNMVGszSUMwNU4zWXRNakF3YURJd01HdzVOeUE1TjJNeklDMHhOU0F6SUMwek1TQXpJQzAwTjJNd0lDMHhNemdnTFRFeE1pQXRNalV3SUMweU5UQWdMVEkxTUdNdE16SWdNQ0F0TmpJZ09DQXRPVEFnTVRsc0xUSTRPQ0F0TWpreFl5MHlNQ0F0TWpBZ0xUUTJJQzB5T0NBdE56SWdMVEk0Y3kwMU1pQTRJQzAzTWlBeU9HTXRNemtnTXprZ0xUTTVJREV3TlNBd0lERTBOR3d5T1RFZ01qZzNZeTB4TVNBeU9DQXRNVGtnTlRrZ0xURTVJRGt4WXpBZ01UTTRJREV4TWlBeU5UQWdNalV3SURJMU1IcE5NVEF4SURFMU1BcGpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3Y3pJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEJ6TFRJeUlEVXdJQzAxTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlaR0lpSUhWdWFXTnZaR1U5SWlZamVHVXdaR0k3SWlBS1pEMGlUVEUwTVNBM01EQmpPRFFnTFRnMElERTJPU0F0TVRZM0lESTFNeUF0TWpVd1l6Z3lJRGd6SURFMk55QXhOalVnTWpRM0lESTFNR3d4TkRNZ0xURTBNV3d0TWpVeklDMHlOVE5qT0RRZ0xUZ3lJREUyTnlBdE1UWTJJREkxTXlBdE1qUTNiQzB4TkRNZ0xURTBNMk10T0RFZ09EWWdMVEUyTlNBeE5qa2dMVEkwTnlBeU5UTnNMVEkxTXlBdE1qVXpiQzB4TkRFZ01UUXpZemcxSURnd0lERTJOeUF4TmpRZ01qVXdJREkwTjJNdE9ETWdPRFFnTFRFMk5pQXhOamtnTFRJMU1DQXlOVE42SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1SaklpQjFibWxqYjJSbFBTSW1JM2hsTUdSak95SWdDbVE5SWswd0lEZ3dNR2d4TURCc01qTXhJQzB6TURCb016aHNNak14SURNd01HZ3hNREJzTFRJeU5TQXRNekF3YURJeU5YWXRNVEF3YUMwek1EQjJMVEV3TUdnek1EQjJMVEV3TUdndE16QXdkaTB5TURCb0xURXdNSFl5TURCb0xUTXdNSFl4TURCb016QXdkakV3TUdndE16QXdkakV3TUdneU1qVjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVJrSWlCMWJtbGpiMlJsUFNJbUkzaGxNR1JrT3lJZ2FHOXlhWG90WVdSMkxYZzlJamt3TUNJZ0NtUTlJazB6TlRBZ09EQXdZekU1TXlBd0lETTFNQ0F0TVRVM0lETTFNQ0F0TXpVd1l6QWdMVFl4SUMweE55QXRNVEU1SUMwME5DQXRNVFk1WXpRZ0xUSWdNVEFnTFRZZ01UTWdMVGxzTVRBeklDMHhNREJqTVRZZ0xURTJJRE13SUMwME9TQXpNQ0F0TnpKak1DQXROVFlnTFRRMklDMHhNRElnTFRFd01pQXRNVEF5WXkweU15QXdJQzAxTmlBeE5DQXROeklnTXpCc0xURXdNQ0F4TUROakxUTWdNeUF0TnlBNUlDMDVJREV6WXkwMU1DQXRNamdnTFRFd09DQXRORFFnTFRFMk9TQXRORFJqTFRFNU15QXdJQzB6TlRBZ01UVTNJQzB6TlRBZ016VXdjekUxTnlBek5UQWdNelV3SURNMU1IcE5NelV3SURjd01BcGpMVEV6T1NBd0lDMHlOVEFnTFRFeE1TQXRNalV3SUMweU5UQnpNVEV4SUMweU5UQWdNalV3SUMweU5UQmpOaklnTUNBeE1Ua2dNak1nTVRZeklEWXdZemNnTVRFZ01Ua2dNalVnTXpFZ016RnNNeUF6WXpNMElEUXpJRFV6SURrM0lEVXpJREUxTm1Nd0lERXpPU0F0TVRFeElESTFNQ0F0TWpVd0lESTFNSHBOTXpBd0lEWXdNR2d4TURCMkxURXdNR2d4TURCMkxURXdNR2d0TVRBd2RpMHhNREJvTFRFd01IWXhNREJvTFRFd01IWXhNREJvTVRBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWkdVaUlIVnVhV052WkdVOUlpWWplR1V3WkdVN0lpQm9iM0pwZWkxaFpIWXRlRDBpT1RBd0lpQUtaRDBpVFRNMU1DQTRNREJqTVRreklEQWdNelV3SUMweE5UY2dNelV3SUMwek5UQmpNQ0F0TmpFZ0xURTNJQzB4TVRrZ0xUUTBJQzB4Tmpsak5DQXRNaUF4TUNBdE5pQXhNeUF0T1d3eE1ETWdMVEV3TUdNeE5pQXRNVFlnTXpBZ0xUUTVJRE13SUMwM01tTXdJQzAxTmlBdE5EWWdMVEV3TWlBdE1UQXlJQzB4TURKakxUSXpJREFnTFRVMklERTBJQzAzTWlBek1Hd3RNVEF3SURFd00yTXRNeUF6SUMwM0lEa2dMVGtnTVROakxUVXdJQzB5T0NBdE1UQTRJQzAwTkNBdE1UWTVJQzAwTkdNdE1Ua3pJREFnTFRNMU1DQXhOVGNnTFRNMU1DQXpOVEJ6TVRVM0lETTFNQ0F6TlRBZ016VXdlazB6TlRBZ056QXdDbU10TVRNNUlEQWdMVEkxTUNBdE1URXhJQzB5TlRBZ0xUSTFNSE14TVRFZ0xUSTFNQ0F5TlRBZ0xUSTFNR00yTWlBd0lERXhPU0F5TXlBeE5qTWdOakJqTnlBeE1TQXhPU0F5TlNBek1TQXpNV3d6SUROak16UWdORE1nTlRNZ09UY2dOVE1nTVRVMll6QWdNVE01SUMweE1URWdNalV3SUMweU5UQWdNalV3ZWsweU1EQWdOVEF3YURNd01IWXRNVEF3YUMwek1EQjJNVEF3ZWlJZ0x6NEtJQ0E4TDJadmJuUStDand2WkdWbWN6NDhMM04yWno0S1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuc3ZnXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5zdmdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtiYXNlNjQsQUFFQUFBQVBBSUFBQXdCd1JrWlVUV3Z3QWFRQUFBRDhBQUFBSEU5VEx6STBCbEZpQUFBQkdBQUFBR0JqYldGd0FBL2tpUUFBQVhnQUFBRkNZM1owSUFBQUFBQUFBR0dJQUFBQUNtWndaMjIrYitZNUFBQmhsQUFBQzJ4bllYTndBQUFBRUFBQVlZQUFBQUFJWjJ4NVpramw3cTRBQUFLOEFBQlNHR2hsWVdRQjg3dEZBQUJVMUFBQUFEWm9hR1ZoQm93RUFRQUFWUXdBQUFBa2FHMTBlSnFlQUJvQUFGVXdBQUFEaG14dlkyR2p1bzlFQUFCWXVBQUFBY1p0WVhod0Fad0wxZ0FBV29BQUFBQWdibUZ0Wlk3MkVNVUFBRnFnQUFBQ2ZIQnZjM1R0RURQK0FBQmRIQUFBQkdOd2NtVnczV3NEaFFBQWJRQUFBQUI3QUFBQUFRQUFBQURNUGFMUEFBQUFBTS9aTDJvQUFBQUF6OWt2YWdBRUF2NEJrQUFGQUFBQ0NBSXdBQUFBY0FJSUFqQUFBQUdBQUNjQXp3QUFBZ0FGQXdBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQlFaa1ZrQU1EZ0FPRGVBeUFBQUFCSUF5QUFaUUFBQUFFQUFBQUFBQUFBQUFBQUFDQUFBUUFBQUFNQUFBQURBQUFBSEFBQkFBQUFBQUE4QUFNQUFRQUFBQndBQkFBZ0FBQUFCQUFFQUFFQUFPRGUvLzhBQU9BQS8vOGdBd0FCQUFBQUFBQUFBUVlBQUFFQUFBQUFBQUFBQVFJQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUJvQUFBRHNBaFVBQXdBSEFBaTFCZ1FCQUFJdEt6TVJNeEVuTXhFakd0SzRucDRDRmYzckdnSGhBQUlBQUFBQUF5QUN2QUFIQUE0QUNMVUtDQUlBQWkwckFTRVJJVFVoRVNFZkFRYzFJVFVoQVN3QjlQNE1BWkQrY0dUSXlQNXdBWkFDdlAxRVpBSDBaSmFXWkdRQUFnQUFBQUFESUFLOEFBY0FEZ0FJdFEwSUFnQUNMU3NCSVJFaE5TRVJJUWNWSVJVaEZTY0JMQUgwL2d3QmtQNXdaQUdRL25ESUFyejlSR1FCOUdSa1pHU1dBQUFCQUFBQVpBTWdBcndBRHdBR3N3WUFBUzByRWlBV0hRRXpCeWN6TlRRbUlnWVZOTTBCSXMxa3lNaGtrdENTQXJ6TmtUTEl5REpva3BKb2tRQUJBQUFBWkFNZ0Fyd0FEd0FHc3dzQUFTMHJBQ0FXRlRRbUlnWWRBVE1ISnpNMU5BRXhBU0xOa3RDU1pNaklaQUs4elpGb2twSm9Nc2pJTXBFQUFBQUFCQUFBQUFBRElBSzhBQU1BQndBTEFBOEFEVUFLRGd3S0NBWUVBZ0FFTFNzUklSVWhGeUVWSVFjaEZTRVhJUlVoQXlEODRHUUNXUDJvWkFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUFBQUVBQUFBQUFNZ0Fyd0FBd0FIQUFzQUR3QU5RQW9PREFvSUJnUUNBQVF0S3hFaEZTRVZJUlVoRlNFVklSVWhGU0VESVB6Z0FsajlxQU1nL09BQ1dQMm9BcnhrWkdSa1pHUmtBQUFBQkFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRFVBS0Rnd0tDQVlFQWdBRUxTc1JJUlVoRnlFVklRY2hGU0VYSVJVaEF5RDg0TWdDV1Ayb3lBTWcvT0RJQWxqOXFBSzhaR1JrWkdSa1pBQUFBQUFGQUFEL253TWdBcndBQlFBTEFCRUFGZ0FiQUE5QURCc1hFeElRREFnR0F3QUZMU3NCTWhjSEpUWUhGd1VtTlRRbEZoVVVCeU1sRXk0Qkp3VWhEZ0VIQVpCc1lrdit2bHl3di83S0JnS3djQkRhL3FKd1hwY3FBVXNCZERHallnSzhPK0hxTW5DSzNpUWtxR3QxbmlSQU5mNmxFWGRXSEZOcENRQUFBUUFBQUFBQjlBTWdBQVlBQnJNRUFBRXRLeE16RVRNTEFUUElaTWozL2NnRElQNE0vdFFCTEFBQUFBQUNBQUFBQUFNZ0F5QUFCd0FPQUFpMUN3Z0VBQUl0S3hJZ0ZoQUdJQ1lRSlJFakNRRWpFZW9CVE9ycS9yVHFBU3pJQVN3QkxNZ0RJT3IrdE9ycUFVeUcvdFQrMUFFc0FTd0FBQUFBQWdBQUFBQURJQU1nQUFjQURnQUl0UW9JQkFBQ0xTc1NJQllRQmlBbUVDVUpBVFVoTlNIcUFVenE2djYwNmdHUS90UUJMQUVzL3RRRElPcit0T3JxQVV5Ry90VCsxTWpJQUFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTkNBUUFBaTByRWlBV0VBWWdKaEFsRlNFVklSVUI2Z0ZNNnVyK3RPb0JrUDdVQVN3QkxBTWc2djYwNnVvQlRJYkl5TWdCTEFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTENBUUFBaTByRWlBV0VBWWdKaEFsQVRNUk14RXo2Z0ZNNnVyK3RPb0JrUDdVeU1qSUF5RHEvclRxNmdGTWh2N1UvdFFCTEFBQUFBRUFBQUJrQXlBQ1dBQUdBQWF6QlFBQkxTc0JGU0VWSVJVbEFTd0I5UDRNL3RRQ1dNaGt5UGNBQUFBQUFRQUFBR1FESUFKWUFBWUFCck1DQUFFdEt3RU5BVFVoTlNFQjlBRXMvdFQrREFIMEFsajMvY2hrQUFBQkFBQUFBQUpZQXlBQUJnQUdzd1FBQVMwckV6TVJNd2tCTThqSXlQN1gvdEhJQXlEK0RQN1VBU3dBQUFFQUFBQmtBeUFDdkFBR0FBYXpCUUFCTFNzQkZTRVZJUlVCQVN3QjlQNE0vdFFDdk1qSXlBRXBBQUFBQVFBQUFHUURJQUs4QUFZQUJyTUNBQUV0S3drQ05TRTFJUUgwQVN6KzFQNE1BZlFDdlA3WC90SEl5QUFCQUFBQUFBSllBeUFBQmdBR3N3TUFBUzByQ1FFakVTTVJJd0VwQVMvSXlNZ0RJUDdVL2d3QjlBQUFBQUVBQUFBQUFmUURJQUFHQUFhekF3QUJMU3NiQVNNUkl4RWo5LzNJWk1nRElQN1UvZ3dCOUFBRUFBQUFBQUs4QXlBQUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLd0V6RVNNRE14RWpBVE1SSXdFekZTTUJrR1JreUdSa0FaQmtaUDJvWkdRRElQemdBcno5cUFIMC9uQUJMTWdBQUFRQUFBQWlBeUFDV0FBS0FCVUFId0FwQUExQUNpUWdIQllRQ3dZQUJDMHJFeGNHRlJRWEJ5NEJOVFFsRmhVVUJnY25OalUwSndVWEJoVVVGd2NtTlRRbEZoVVVCeWMyTlRRbmRFaFlXRWczUFFLc2REMDNTRmhZL3A5RkhCeEZPd0ZWT3p0RkhCd0NXRWhZZVgxWVNEZVVVcVYwZEtWU2xEZElXSDE1V0VSSUhDa3NIRWc3VlZJNk8xRlZPMGdjTENrY0FBQUNBQUFBQUFHUUF5QUFCd0FQQUFpMURRZ0VBQUl0S3hJeUZoUUdJaVkwRXhZek1qY1JKd2QycEhaMnBIWmtOaTR0TjJSa0F5QjJwSFoycFA2VkV4UCt3V1JrQUFNQUFBQUFBeUFESUFBSEFBOEFGd0FLdHhJUURRZ0VBQU10S3hJZ0ZoQUdJQ1lRSlNJR0ZSUVhBU1lYQVJZek1qWTFOT3NCU3V2ci9yYnJBWkI4c0RnQm8wNlQvbDFPWVh5d0F5RHIvcmJyNndGS2g3QjhZVTRCb3poOS9sMDRzSHhoQUFBREFBQUFBQU1nQXJ3QUJRQUpBQTBBQ3JjTUNnZ0dCQUFETFNzUk14RWhGU0VCTXhFakFUTVJJMlFDdlB6Z0FmVEl5UDdVeU1nQ3ZQMm9aQUs4L2d3QkxQN1VBQVFBQUFBQUF5QURJQUFYQUJvQUpnQXlBQTFBQ2kwbklSc1pHQXdCQkMwckFUWVhIZ0lYTXhVakVSUUdJeUVpSmpVUkl6VXpFellYQnlFRUlnWWRBUlFXTWpZOUFUUWtJZ1lkQVJRV01qWTlBVFFCalJFUkFXeDRESUJrRkE3OTdBNFVaSURxRGhpUUFTRCs3eW9kSFNvZEFROHFIUjBxSFFNZ0FRNEJnWTRQWlA2U0RoUVVEZ0Z1WkFFWkVYNnN5QjBWWkJVZEhSVmtGUjBkRldRVkhSMFZaQlVBQWdBQUFHUURJQUs4QUE4QUV3QUl0UkVRQ1FBQ0xTc1RJVElkQVRNVkl4VVVJeUVpTlJFMEZ4RWhFUWtDcWdsa1pBbjlWZ2xrQWZRQ3ZBcSt5TDhKQ1FKR0NXVCtjQUdRQUFBQUFBRUFBQUJrQXlBQ3ZBQVBBQWF6Q1FBQkxTc1RJVElkQVRNVkl4VVVJeUVpTlJFMENRS3FDV1JrQ2YxV0NRSzhDcjdJdndrSkFrWUpBQUFBQUFJQUFQK2NBeUFDdkFBbUFDOEFDTFVzSnhZQ0FpMHJFelEyT3dNaE1oWVVCaXNCRlJJWEZoVVVCeU1HSXlFaUpqVTBOellUTlNNaUJpTWlKZ1VqRlFjR0J5RXZBVndhRXdNRkJRSDBGUjBkRlRLT0dDSXBBeXM1L2dBK1VpSVlqaklCQmdFVkhRR1l5QVkvT0FIQ2R3WUNpaElnSFNvZGpmN3pLRGN6UGlrcFVqNHpOeWdCRFkwQkhoMmlDbnRwNUFvQUFBQUNBQUFBQUFNZ0F5QUFEUUFUQUFpMUVRNEhBQUl0S3dBeUZoVVVGeFlWSVRRM05qVTBFek1VQmlJbUFUNmtkb1pDL09CQ2htVElPMUk3QXlCMlVwdHZOMDlQTjIrYlV2MjZLVHM3QUFBQUFBTUFBQUFBQWlZRElBQU5BQkFBRXdBS3R4SVJEdzRGQUFNdEt4TXpCUWNYQlNNMUJ5YzNKemNYTnhVM0J4VTNsaklCWHVIaC9xSXlTMHVXbGt0TFpKYVdsZ01nK3BPWit2cExTNWFXUzB0a3lHVEl5R1FBQUFBREFBQUFBQU1nQXlBQUZRQWRBQ1VBQ3JjZkhoY1dDd0FETFNzUklUSVdGUlFISGdFVkZBWWpJVFV5TmpVUk5DWWpJUlV6TWpZMEppTURFVE15TmpRbUl3SDBVbllzUVUrU2FQM2FLVHM3S1FFc1pDazdPeWxrbGo1WVdENERJSFpTUmpjZmVFcG9rbVE3S1FHUUtUdklPMUk3L3RUKzFGaDhXQUFBQVFBQUFBQUI5QU1nQUFVQUJyTURBQUV0S3dFUk13RVJJd0VzeVA3VXlBTWcvdFQrREFFc0FBRUFBQUFBQXJ3RElBQWJBQWF6RWdBQkxTc1RJUkUzRnhFek1oWVZFU0VpQmhRV015RVZJU0ltTlJFM1BnRTNaQUVzWkdReUZSMzkyaFVkSFJVQ0p2M2FQbGdEQmlzZEF5RCsxR1JrQVN3ZEZmM2FIU29kWkZnK0FpWVRIU3NHQUFFQUFBQUFBWkFESUFBRUFBYXpBZ0FCTFNzUklSRW5Cd0dReU1nRElQemd5TWdBQUFJQUFBQUFBeUFESUFBREFBOEFDTFVMQkFJQUFpMHJFU0VWSVJVaEZUTTFJUkVVSXlFaU5RTWcvT0FCTE1zQktRbjg4Z2tESUdSa1oyZjlzUWtKQUFBREFBQUFBQU1nQXlBQUZ3QWJBQ2NBQ3JjakhCa1lDd0FETFNzQk16SVdIUUV6TWgwQkZBWWpJU0ltUFFFME93RTFORFlYRlRNMUFSWXpJVEkzRlJRaklTSTFBU3pJS1R1L0NSMFYvVVFWSFFtL095bkkvZ3dZR2dLOEdoZ0ovUElKQXlBN0tXUUo4UlVkSFJYeENXUXBPMlJrWlA0VkNRbklDUWtBQVFBQUFBQUNXQU1nQUNRQUJyTVZBQUV0S3dFeUZoVWpOQ1lqSWdjR0ZSUVdGek1WSXdZSElSVWhOVGMyTnlNMU15NENOVFEzTmdFc1htcGtNakl2R1J3WkE2eXlGMW9CNi8yb0VGY1RlbjBDRHdneU53TWdhbDR5TWg4ak94eDNIR1JoWjJSNkRGZFBaQTFIUEI5ZVBrVUFBQUFFQUFEL25BTWdBcndBRkFBY0FDZ0FMQUFOUUFvcUtTRWRHUlVMQUFRdEt4TTdBeUV5RmhVUkZBWWpJU0ltTlJFMU5EWVdJZ1lVRmpJMk5EY2lCaFFXTXlFeU5qUW1Jd1VSSVJFaUJBTUVCUUs4RlIwZEZmMUVGUjBVbHlvZEhTb2RsaFVkSFJVQkxCVWRIUlg5MmdKWUFyd2RGZjFFRlIwZEZRSzhBZzhkWUIwcUhSMHFIUjBxSFIwcUhjaitjQUdRQUFBQUFnQUFBQUFER2dNZEFBMEFHd0FJdFJNT0J3QUNMU3NCSHdFV0J3RVBBUzRCSno4QkNRRXlGaFVVQmlNaUp6NEJOVFEyQXVnR0xBVUYvdllQR1JGUE5nd05BWGYrS0RoT25HNUtQRDFKVFFNZEF5d0ZCLzZKRFF3MlR4RVpEd0VLL25aT09HNmNJaU44U1RoT0FBQUFBQUVBQVArN0FzNEN2QUJuQUFhek1nc0JMU3NUTkRZek1oOEJOeTRCUGdFeUhnRUdCeGMzTmpNeUZoVVVCZzhCRmhjek1oWVVCaXNCRkFjWEhnRVZGQVlqSWk4QkJnY21QUWMwSmlNaUJnY1dGQWNkQXhRSEppY0hCaU1pSmpVME5qOEJKalVyQVNJbU5UUTJPd0kyTnljdUFRa2JFdzRNZ3gwY0JpUkpWa2trQlJ3Y2d3c0tGUjBRQzNNVUJVUVZIUjBWTWdaT0R4WWRGUkFQUVNWQ1BCMFZFaHdFQVFFN1F5UkNEeEFWSFJZUFRnWXlCUlVkSFJVRlJRVVVkQXdRQWNNU0lBZENGaDFZVFRnM1RWZ2VGa0lISFJVTkdnWTRJdzhkS2gwaUlDZ0VIUkFWSFFzalNDWWhKNGNFQlFZRkJWY1ZIUmNSQXhBRFVnUUZrQ2dnS1VVakN4MFZFQjBFS0NBaUhSVVVIZzhqT0FVYUFBSUFBQUFDQXJ3Q3ZBQUhBQndBQ0xVU0NRVUFBaTByQVRNeUZSRVVLd0VCSlJFbkZTSUhGeFlPQVNZbkF5TWlQUUUwT3dFQ1dGc0pDVnYrZWdFaStoY0ZTd2dPSmlvSVoxc0pDYllDdkFuOXVna0JrNVArREgwREZySVRLaEFPRXdFUUNiWUpBQUFBQndBQUFBQUN2QU1nQUFzQUR3QVRBQmNBR3dBZkFDTUFFMEFRSVNBZEhCa1lGUlFSRUEwTUJRQUhMU3NUSVRJVkVSUWpJU0kxRVRRWEZTRTFBUlV6TlRNVk16VXpFVE1SQlJVek5UTVZNelVKQXFvSkNmMVdDV1FCOVA0TVpHUmtaR1QrREdSa1pBTWdDZnp5Q1FrRERnbGt5TWorMUdSa1pHVCsxQUVzeUdSa1pHUUFCd0FBQUFBQ3ZBTWdBQU1BQ3dBUEFCTUFGd0FiQUI4QUUwQVFIUndaR0JVVUVSQU5EQWNFQWdBSExTc1JJUlVoRlNFUkZDTWhJalVURlRNMU14VXpOVE1WTXpVRkZUTTFNeFV6TlFLOC9VUUN2QW45Vmdsa1pHUmtaR1QrREdSa1pBTWd5R1QrRlFrSkFZZGtaR1JrWkdUSVpHUmtaQUFBQkFBQUFBQURJQU1nQUJnQUlBQW9BREFBRFVBS0xTa2xJUjBaQ3dBRUxTc0JNeklmQVJZN0FUSVZFUlFqSVNJMUVUUTJPd0V5UHdFMkFpSUdGQll5TmpRa0lnWVVGakkyTkNZeUZoUUdJaVkwQVptMkNBUmVCQWhTQ1FuODhnbFlQbzBJQkY0RTVpb2RIU29kQVg2a2RuYWtkdkZTT3p0U093TWdDYllKQ2YyNkNRa0J1VDVZQ2JZSi90UWRLaDBkS2gxMnBIWjJwQkk3VWpzN1VnQUFBQUVBQUFESUF5QUNXQUFDQUFhekFnQUJMU3NSSVFFRElQNXdBbGorY0FBQUFRQUFBQUFCa0FNZ0FBSUFCck1CQUFFdEt3RVJBUUdRL25BRElQemdBWkFBQUFBQUFRQUFBQUFCa0FNZ0FBSUFCck1DQUFFdEt4RUpBUUdRL25BRElQNXcvbkFBQUFBQUFRQUFBTWdESUFKWUFBSUFCck1CQUFFdEt3a0JJUUdRQVpEODRBSlkvbkFBQUFBQUF3QUFBQUFESHdKWUFDRUFLUUF4QUFxM0xpb21JaElDQXkwckVUUTJPd1F5Rmg4QklUSVdEd0VPQVNNaElpWW5MZ0V2QVNNaUJpTWlKZ0F5RmhRR0lpWTBKRElXRkFZaUpqUWJFd01GQk1nTkdnVW1BYndLQ0FOUkF4VUwvcUlLRlFNT05nMEtsZ0VGQVJVZUFWRXFIUjBxSFFGSktoMGRLaDBDSmhJZ0VRdElEd3I2Q2c4UENpbW9LUmtCSHY1VEhTb2RIU29kSFNvZEhTb0FBZ0FBQUFBRElBSzhBQVlBQ3dBSXRRa0hCZ0FDTFNzUklSVWhFU01IQVNFUkp5RUI5UDdVWkdRQkxBSDBaUDV3QXJ4ay90UmtBU3orREdRQUFRQUFBRUlERUFLOEFBMEFCck1DQUFFdEt3RVhBUzRDTHdFM0ZoYytBZ0tCai80VElFbGFHRWlOUzA0bmpuUUN2STMrRXlKS1dSbEhqVXhLSjQ1MEFBRUFBQUF5QXlBQ1dBQUZBQWF6QkFBQkxTc1RGemNYQ1FHVyt2cVcvbkQrY0FKWSt2cVcvbkFCa0FBQUFRQUFBQUFDSmdNZ0FBVUFCck1FQUFFdEt3RVhCeGNIQVFHUWx2cjZsdjV3QXlDVyt2cVdBWkFBQUFBQkFBQUFBQUltQXlBQUJRQUdzd0lBQVMwckV3a0JKemNubGdHUS9uQ1crdm9ESVA1dy9uQ1crdm9BQUFFQUFBQXlBeUFDV0FBRkFBYXpBZ0FCTFNzSkFRY25CeWNCa0FHUWx2cjZsZ0pZL25DVyt2cVdBQUFBQWdBQUFBQURJQU1nQUFjQURRQUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVDVUhKd2NYQWVvQlRPcnEvclRxQWxqNlpFaXNBVUlESU9yK3RPcnFBVXc0K21SSXJBRkNBQUFBQWdBQUFBQURJQU1nQUFjQUV3QUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVEY0hGd2NYTnhjM0p6Y25CK29CVE9ycS9yVHEra2lXbGtpV2xraVdsa2lXQXlEcS9yVHE2Z0ZNT0VpV2xraVdsa2lXbGtpV0FBQUFBQUlBQUFBQUFyd0RJQUFSQUNVQUNMVWRFZ2tBQWkwckFESVdIUUV6TWhZZEFTRTFORFk3QVRVMEJUTVZJVFV6TWhZVkVSUUdJeUVpSmpVUk5EWUJTU29kU3dzTy90UU9DMHYrN1VzQjlFc0xEZzRML1hZTERnNERJQjBWTWc0TFMwc0xEaklWUjhqSURndjlkZ3NPRGdzQ2lnc09BQUFBQUFNQUFBQUFBeUFESUFBSEFBOEFHQUFLdHhVUURBZ0VBQU10S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFsTXhVV0Z3Y21Md0hyQVVycjYvNjI2d0lNK0xDdytMRCtvbVFpSmtna01CQURJT3YrdHV2ckFVcUhzUGl3c1BoTXRTUWhTQ2d3REFBQ0FBQUFBQU1nQXlBQUdRQXNBQWkxSmg0SkFBSXRLd0V5RmgwQkhnRVZGQWNqTlRRbUlnWWRBU0VtTlRRMk16NEJFenNCTWpZek1oWWRBak1ISnpNOUFUUTJBY0pva2lzNUNiOVlmRmorOEJ4MlVoR1BTZ01FQVFZQ0ZSMld5TWlXRkFNZ2ttZ3lFRlV4R2hneVBsaFlQakl4TTFKMlZuTCtjQUVkRlFHV3lNaVdBZzhkQUFBQUFnQUFBQUFESUFNZ0FCUUFId0FJdFJvVkNRQUNMU3NCTWhZZEFSNEJGUlFISXljSEl5WTFORFl6UGdFVEZ5TVZGQVlpSmowQkl3SENhSklyT1FtTnlNamVISFpTRVk5YStzZ2RLaDNJQXlDU2FESVFWVEVhR01qSU1UTlNkbFp5L2o3Nk1oVWRIUlV5QUFBQUFRQUFBR1FESUFLOEFCSUFCck1KQUFFdEt3RXlGaDBCSGdFVkZBWWpJU0ltTkRZelBnRUJ3bWlTS3psWVB2NCtVbloyVWhHUEFyeVNhRElRVlRFK1dIYWtkbFp5QUFBQUFnQUFBQUFESUFNZ0FBc0FIZ0FJdFJVTUJ3QUNMU3NUTWhjaUJnY0dCeVkxTkRZRk1oWWRBUjRCRlJRR0l5RWlKalEyTXo0QitudE5hckVxT2lvWmtnRXdhSklyT1ZnKy9qNVNkblpTRVk4RElHUnpYaEFmTkRab2tzaVNhRElRVlRFK1dIYWtkbFp5QUFBQUF3QUFBR1FESUFLOEFBTUFDUUFQQUFxM0RRb0hCQUlBQXkwckFUTUJJd016Qnhjakp5VXpGd2NqTndIMFpQN1VaR1JrWkdSa1pBSllaR1JrWkdRQ3ZQMm9BZlRJeU1qSXlNaklBQUlBQUFBQUF5QURJQUFmQUNjQUNMVWtJQkFBQWkwckFUTWZBVGNYQng4QkZROEJGd2NuRHdFakx3RUhKemN2QVRVL0FTYzNGemNXSWdZVUZqSTJOQUZlWkRJY2QwZ3lESGQzRERKSWR4d3laREljZDBneURIZDNEREpJZHh5aWZGaFlmRmdESUhjTU1raDNIREprTWh4M1NESU1kM2NNTWtoM0hESmtNaHgzU0RJTWcxaDhXRmg4QUFBQUF3QUFBQUFESUFNZ0FBTUFCZ0FLQUFxM0NRY0dCQUlBQXkwckVTRVZJUmNoQndVaEZTRURJUHpneUFHUXlQNXdBeUQ4NEFNZ3lHVEl5R1FBQXdBQUFBQURJQU1nQUFNQUJ3QUtBQXEzQ1FnR0JBSUFBeTByRVRNUkl3RXpFU01ERVNka1pBSll5TWhreUFNZy9PQURJUHpnQWxqK2NNZ0FBd0FBQUFBRElBTWdBQU1BQndBS0FBcTNDZ2dHQkFJQUF5MHJFVE1SSXdFekVTTUJGd2ZJeUFLOFpHVCtjTWpJQXlEODRBTWcvT0FDV01qSUFBQUFBQU1BQUFBQUF5QURJQUFEQUFZQUNnQUt0d2tIQlFRQ0FBTXRLeEVoRlNFRkZ5RUhJUlVoQXlEODRBR1F5UDV3eUFNZy9PQURJR1RJeUdUSUFBWUFBQUFBQXJ3Q3ZBQW5BREFBT1FBOUFFWUFUd0FSUUE1S1IwSStPem8xTVN3b0ZBQUdMU3NTTWhZZEFUTTFORFl5RmhRR0t3RVZNeklXRkFZaUpqMEJJeFVVQmlJbU5EWTdBVFVqSWlZMEZpSUdGQlk3QVRVMEpDSUdIUUV6TWpZMEJSVXpOUWNpQmhRV01qWTlBU0VWRkJZeU5qUW1JMWg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHhZV0Q0eU1qNVlxeW9kSFJVeUFYTXFIVElWSGY3VVpQb1ZIUjBxSFFFc0hTb2RIUlVDdkZnK01qSStXRmg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHdNSFNvZE1oVWRIUlV5SFNxclpHVElIU29kSFJVeU1oVWRIU29kQUFBQkFBQUFBQU1nQXlBQUNnQUdzd1lCQVMwckVUUXpJVElWRVNjaElqVUpBdzRKeVAyeENRTVhDUXI4NnNnSkFBQUVBQUFBQUFNZ0F5QUFCd0FQQUJNQUd3QU5RQW9ZRkJJUURBZ0VBQVF0S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFuQXdVVEZpSUdGQll5TmpUckFVcnI2LzYyNndJTStMQ3crTEJrWlA3VVpIa3FIUjBxSFFNZzYvNjI2K3NCU29ldytMQ3crRXorMUdRQkxESWRLaDBkS2dBQUFBSUFBQUFBQXlBRElBQUhBQTBBQ0xVSkNBUUFBaTByRWlBV0VBWWdKaEFsRVRJMk5DYnJBVXJyNi82MjZ3R1FmTEN3QXlEci9yYnI2d0ZLaC8yb3NQaXdBQUFBQlFBQUFBQURJQU1nQUFNQUJ3QUxBQThBRndBUFFBd1VFQTRNQ2dnR0JBSUFCUzByRVNFVklSVWhGU0VWSVJVaEZTRVZJU1F5RmhRR0lpWTBBeUQ4NEFIMC9nd0RJUHpnQWxqOXFBTFpLaDBkS2gwRElHUmtaTWhrWkdSa0hTb2RIU29BQUFRQUFBQmtBeUFDdkFBSkFCTUFGd0FiQUExQUNoa1lGUlFPQ2dVQUJDMHJFeUV5RmgwQklUVTBOZ2NoRVJRR0l5RWlKalUzRlRNMU14VXpOUmtDN2dzTy9PQU9EZ01nRGd2OUVnc09aR1JrWkFLOERndExTd3NPeVA2SkN3NE9DNjlrWkdSa0FBQUFBd0FBQUFBRElBTWdBQklBRlFBWUFBcTNGeFlVRXdzQUF5MHJFek1WSVRjWEJ4RXpGU01WSXpVaEVTTTFNeGNSQVJjQklXUmtBY0prTW1Sa1pHVCtER1JrWkFGZU12NmlBVjRESUdSa01tVCtQbVJrWkFIMFpHVCtvZ0ZlTXY2aUFBQUFBQVVBQUFBQUF5QURJQUFIQUE4QUZ3QXNBRFFBRDBBTU1TMG1HeFFRREFnRUFBVXRLeElnRmhBR0lDWVFKQ0lHRkJZeU5qUWtNaFlVQmlJbU5BYzBOamM3QWpJZkFUY3lGaFFHSWlZMU55Y21KRElXRkFZaUpqVHJBVXJyNi82MjZ3SU0rTEN3K0xEK3Z5b2RIU29kbGhRT0F3TUlGZzViR1NrN08xSTdCbG9RQVVrcUhSMHFIUU1nNi82MjYrc0JTb2V3K0xDdytFd2RLaDBkS25jUEhRUVFXZ1k3VWpzN0tSbGJEa1lkS2gwZEtnQUFBQUlBQUFBQUF5QURJQUFHQUFvQUNMVUpCd1FBQWkwckFUTVJNd2tCTXdFaEZTRUJMTWpJL3RUKzFNaisxQU1nL09BRElQN1UvdFFCTFA1d1pBQUFBQUFDQUFBQUFBTWdBeUFBQXdBS0FBaTFCd1FDQUFJdEt4RWhGU0VGQVNNUkl4RWpBeUQ4NEFHUUFTekl5TWdESUdSay90VCsxQUVzQUFJQUFBQmtBeUFDdkFBRUFCQUFDTFVKQlFJQUFpMHJFeUVSSVFNbEJ4Y0hGemNYTnljM0p3ZklBbGo5cU1nQlhraVdsa2lXbGtpV2xraVdBcno5cUFFczNraVdsa2lXbGtpV2xraVdBQUFBQWdBQUFHUURJQUs4QUFzQUdBQUl0Uk1NQXdBQ0xTc1NJQllWSXpRbUlnWVZJelFsRnpjZUFSVVVCaUltTlRRMjZ3Rks2MlN3K0xCa0FWVTdPejVQZHFSMlR3Szg2NlY4c0xCOHBScFlXQk5wUTFKMmRsSkRhUUFBQUFBRkFBQUFBQUs4QXlBQUJRQUlBQXdBRUFBVUFBOUFEQklSRGcwS0NRY0dCQUFGTFNzUklSRWhFU0VKQVNFbEZUTTFCeFV6TlFjVklUVUJMQUdRL1VRQmtBRXMvdFQrMUdSa1pHUUJrQU1nL25EK2NBTWcvdFJrWkdUSVpHVElaR1FBQUFBQUFRQUEvNXdCOUFLOEFEc0FCck1lQUFFdEt4TXpGVE15RnhZZEFTTTFKaXNCSWdZZEFSUVdGd1VlQVIwQkZBWXJBUlVqTlNNaUp5WTlBVE1WRmpzQk1qWTlBVFFtSnlVdUFUMEJORFk3QWNoa1N6RWdMR1FJRWZvTERoY0xBUUV4UEVvelMyUkxNU0FzWkFnUitnc09Gd3YrL3pFOFNqTkxBcnhrRmg4dlpGNEdEZ3N5Q3g0RFFReE9Nekl6U21Sa0ZoOHZaRjRHRGdzeUN4NERRUXhPTXpJelNnQUNBQUFBWkFNZ0Fyd0FBd0FIQUFpMUJ3UURBQUl0S3hFaEVRa0JJUkVCQVN6KzFBSDBBU3orMUFLOC90VCsxQUpZL3RUKzFBQUFBQUlBQUFCa0F5QUN2QUFEQUFjQUNMVUZCQUVBQWkwckFSRWhFUUVSSVJFQkxQN1VBeUQrMUFLOC9hZ0JMQUVzL2FnQkxBQUNBQUFBWkFNZ0Fyd0FDZ0FWQUFpMUVRc0dBQUl0S3dFVklnWVZNeEVoRVRRMklSVWlCaFV6RVNFUk5EWUJMRk4xeVA3VXNBSndVM1hJL3RTd0FyeGtkVlArMUFFc2ZMQmtkVlArMUFFc2ZMQUFBQUFDQUFBQVpBTWdBcndBQ2dBVkFBaTFEd3NFQUFJdEt4RWhFUlFHSXpVeU5qVWpBU0VSRkFZak5USTJOU01CTExCOFUzWElBZlFCTExCOFUzWElBcnorMUh5d1pIVlRBU3orMUh5d1pIVlRBQUlBQVAvcUFsZ0RJQUFTQUNJQUNMVVlFd2tBQWkwckFSY2VCQlVVQmlJbU5UUStBemNDSWdZVkZCWXpNalkwSmlNaUpqVTBBU3dpRFNoWlJUZXcrTEEzUlZrb0RWOHFIWFpTRlIwZEZTazdBeUFpRFN0eWI1STlmTEN3ZkQyU2IzSXJEZjVLSFJWU2RoMHFIVHNwRlFBQ0FBQUFBQU1nQXlBQUFnQUdBQWkxQlFNQkFBSXRLd2tCSVJVaEZTRUJrQUdRL09BRElQemdBeUQrREdUSUFBQUNBQUFBQUFKWUF5QUFBZ0FGQUFpMUJRTUJBQUl0S3drQklSVWhBUUVzQVN6OXFBSlkvdFFESVA3VXlQN1VBQUFEQUFBQkxBTWdBZlFBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSUFmVEl5TWpJeUFBQUFBQUNBQUFBWkFNZ0Fyd0FCQUFKQUFpMUNBVURBQUl0S3hFaEZRVWxGUVVsRVNFRElQNXcvbkFCa0FHUS9PQUN2R1RJeUdUSXlQNXdBQU1BQUFBQUF5QURJQUFFQUFvQUR3QUt0dzRMQ0FVQ0FBTXRLd0VGRVNFUkpRVVZCU1UxQlNFVkJ5Y0JrQUdRL09BQmtQN1VBU3dCTFA0TUFaREl5QU1neVAyb0FsaFlscnlXbHJ3bVpHUmtBQUFBQUFFQUFQK2NBeUFDdkFBakFBYXpGUUFCTFNzQk1oY0hKaUlHQnlFSElSUVhJUWNqRmpNeU54VUdJeUltSnlFM015WTFJemN6UGdFQ1dHTmNFRTdDbVI4QlN4RCtzaE1CS1JEZVdvUnlWbDVxYkxZMi93QVR4UkRJR2I4aTFBSzhNbW80YjFsa0xUZGtaRTU2T0cxYlpFQWtaSU9wQUFBQUFBWUFBQUFBQXlBQ3ZBQURBQWNBQ3dBUEFCTUFGd0FSUUE0V0ZCSVFEZ3dLQ0FZRUFnQUdMU3NSSVJVaEZTRVZJUlVoRlNFVk14VWpOek1WSXpjekZTTUN2UDFFQWZUK0RBTWcvT0JrWk1oa1pNaGtaQUs4WkdSa1pHUmtaR1JrWkdRQUFBQURBQUFBQUFNZ0F5QUFBd0FHQUFvQUNyY0pCd1lFQWdBRExTc1JJUlVoRnlFSEJTRVZJUU1nL09ESUFaREkvbkFESVB6Z0F5QmtaTWpJeUFBREFBQUFBQU1nQXlBQUF3QUhBQW9BQ3JjS0NBWUVBZ0FETFNzUk14RWpBVE1SSXdFWEIyUmtBbGpJeVA1d3lNZ0RJUHpnQXlEODRBSll5TWdBQUFBQUF3QUFBQUFESUFNZ0FBTUFCd0FLQUFxM0NRZ0dCQUlBQXkwckVUTVJJd0V6RVNNREVTZkl5QUs4WkdSa3lBTWcvT0FESVB6Z0FsaitjTWdBQXdBQUFBQURJQU1nQUFNQUJnQUtBQXEzQ1FjRkJBSUFBeTByRVNFVklRVVhJUWNoRlNFRElQemdBWkRJL25ESUF5RDg0QU1neU1qSVpHUUFBZ0FBQUFBRElBTWdBQWtBRUFBSXRRNEtDQUFDTFNzUk14VWpFU0UxTXhVaEFTRVJKd2NuTjhoa0FsaGsvT0FCa0FHUWx2cGsrZ01nWlAyb1pNZ0RJUDV3bHZwaytnQUFBd0FBQUdRRElBSzhBQnNBSXdBMUFBcTNNU1FnSEEwQUF5MHJBVEllQkI4QkRnUWpJaTRDTHdFK0JoWWlCaFFXTWpZMEp6SVhCaFVVRmpNeU54WVZGQVlpSmpRMkFaTXlZMHhGTVNRSkNRWVhUMWFHUlVlSFhFY1JFUU1NS1M1SVRXU0RwSFoycEhiSUNoSWNIUlVlRGdZN1VqczdBcndoTlVCQU5SRVFEQ2xuVDBFK1dGZ2ZId1lXUGpsRk1pSmtkcVIyZHFRU0JnNGVGUjBjRWdvcE96dFNPd0FDQUFEL25BTWlBcjBBSVFBbEFBaTFKQ0laQXdJdEt3RTdBVFl6TWg4Qk56WXlGeFlVRHdFWEZoVVVCaU1pTHdFQklSRUJKeVkxTkRZWEFSY0JBVXNEQXdNSEZnOWVRaXQrS3l3c1FWMFNIUlVaRHo3K2cvN3pBWGMvRUJXQy9zZUFBVHdDdkFFUlhVRXJLeXg4TEVKZURoZ1ZIUlJCL29NQkVBRjlQdzRXRHgzWC9zV0VBVHdBQWdBQUFBQUN2QU1nQUFVQUNBQUl0UWNHQkFBQ0xTc1JJUkVoRVNFSkFTRUJMQUdRL1VRQmtBRXMvdFFESVA1dy9uQURJUDdVQUFBQ0FBQUFBQUs4QXlBQUdnQXNBQWkxSXhzTkFBSXRLeE1lQkJVVURnUVhMZ1ExTkQ0RU5BRWVCQlVVQmlNaE5ENEVOTWdJRzBVMUt5czlRUzBMR1FnYlJUVXJJVEU1TVNBQkdBZ2JSVFVyUHlYKzFDRXhPVEVnQXlBRUVEaEFhRGd1WFVkU1Jsd3VCQkE0UUdnNEtGQkFRa0ZDVHY3OUJCQTRRR2c0Wm1Jb1VFQkNRVUpPQUFBQUFnQUFBQUFESUFNZ0FBTUFEQUFJdFFrRUFnQUNMU3NSTXhFakV5RVZJUWNYSVRValpHVElBU3dCTE1qSS9uRElBeUQ4NEFNZ1pNdkZaQUFBQVFBQUFBQUJrQU1nQUFvQUJyTUdBQUV0S3hNekJ6TURNd0VETXpjamxwWmt5SmFXL3RSa2hrTElBeURJL3RUKzFBRXN5QUFBQUFBQ0FBQUFBQU1nQXlBQUJRQVBBQWkxQ2dZRUFBSXRLeEVoRlNFVklSVWhFUlFHSXlFaUpqVUJMQUgwL09BRElCMFYvVVFWSFFNZ1pHUmsvajRWSFIwVkFBQUFBQUVBQUFBQUFyd0RJQUF3QUFhekpRQUJMU3NTTWhZVkZBWUhGVFk3QVRJMlBRRXVBVFUwTmpJV0ZSUUdCeFVVQmlzQklnY2VBUlVVQmlJbU5UUTJOelV1QVRVMFdIeFlOeTBiRjhnVkhTMDNXSHhZTnkxWVBzZ1NFQ1l1V0h4WU55MHROd01nV0Q0eFRROTJDUjBWT3c5Tk1UNVlXRDR4VFE4N1BsZ1FFa2dzUGxoWVBqRk5EOW9QVFRFK0FBQUFBQUlBQUFBQUF5QURJQUFHQUEwQUNMVUtCd1FBQWkwckVTRUhGd2NuQnlFWE54RWhOeWNCa0phV1pKYVdBZlNXbHY1d2xwWURJSmFXWkphV2xwYitjSmFXQUFBQUFnQUFBQUFESUFNZ0FBWUFEUUFJdFFzSEF3QUNMU3NURnpjUklUY25BU0VIRndjbkIyU1dsdjV3bHBZQmtBR1FscFprbHBZRElKYVcvbkNXbHY3VWxwWmtscFlBQUFBQUF3QUFBQUFESUFNZ0FBY0FSZ0JWQUFxM1VVY25DQVFBQXkwckVpQVdFQVlnSmhBbElnY1hGZ1lIQmlJR0Z4WUdMZ0VIQmg0QkJ5Y2lCeFlYSGdFWEhnRUhGak15TmpjMkppTWlMZ0kzUGdNbkpqNEJOVFFtSnlZK0F6Y21GdzRCRnhZMkZ4NERQd0UxSnVvQlRPcnEvclRxQVpCUVNSWVdEUllLS3hFRkJnb09Gd1lUR1NBSE93b0dBUklKVGcwbE5oQTZNRXVES1FJWEhSNHdNUnNCQVI4ZUVRME5CUlJFQVFFREN3WVRBem5DSXprRkF6WUlBd2tIRUFrV0VBTWc2djYwNnVvQlRJWXNFdzhqQ1FRT0Z4UUlDUWdFRWtOR0FTSUtIallEQ1EwV2FTQVdRem9VR0FjVEtSNFBMQ0VvQ3hJTkdRb1ZGd1lGQ3cwSEVnSVRiUW9mREFnQkJnTVVEUVlMRmdNbUFBQUNBQUFBQUFNZ0F5QUFCd0FMQUFpMUNnZ0VBQUl0S3dFWEFTY0hKd0VYQVNFVklRSy9ZZjV3Wk1oa0FTeGsvbkFESVB6Z0F5QmsvbkJreTJRQkwyVCtjR1FBQUJBQUFBQUFBcndDdkFBREFBY0FDd0FQQUJNQUZ3QWJBQjhBSXdBbkFDc0FMd0F6QURjQU93QS9BQ1ZBSWo0OE9qZzJOREl3TGl3cUtDWWtJaUFlSEJvWUZoUVNFQTRNQ2dnR0JBSUFFQzByRVRNVkl6Y3pGU00zTXhVak56TVZJd1V6RlNNM014VWpOek1WSXpjekZTTUZNeFVqTnpNVkl6Y3pGU00zTXhVakJUTVZJemN6RlNNM014VWpOek1WSTJSa3lHUmt5R1JreUdSay9haGtaTWhrWk1oa1pNaGtaUDJvWkdUSVpHVElaR1RJWkdUOXFHUmt5R1JreUdSa3lHUmtBcnhrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa0FBa0FBQUFBQXlBRElBQURBQWNBQ3dBUEFCTUFGd0FiQUI4QUl3QVhRQlFpSUI0Y0doZ1dGQklRRGd3S0NBWUVBZ0FKTFNzUk14VWpKVE1WSXlVekZTTUZNeFVqSlRNVkl5VXpGU01GTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSS9hakl5QUVzeU1nQkxNakkvYWpJeUFFc3lNZ0JMTWpJQXlESXlNakl5R1RJeU1qSXlHVEl5TWpJeUFBQUFBUUFBQUFBQXlBRElBQURBQWNBQ3dBUEFBMUFDZzRNQ2dnR0JBSUFCQzByRVNFUklRRWhFU0VGSVJFaEFTRVJJUUVzL3RRQjlBRXMvdFQrREFFcy90UUI5QUVzL3RRRElQN1VBU3orMU1qKzFBRXMvdFFBQUFBREFBQUFBQUs4QXlBQURRQVpBQ0VBQ3JjZUdoVU9CZ0FETFNzVElUSVZFUlFHSXlFaUpqVVJOQkVXTXlFeU54RVVJeUVpTlNRaUJoUVdNalkwRXdLV0V4MFYvYWdWSFJnYUFsZ2FHQlA5YWhNQ095b2RIU29kQXlBVC9yVVZIUjBWQVVzVC9oVUpDZjdlRXhPMUhTb2RIU29BQUFFQUFBQUFBcndDdkFBekFBYXpHZ0FCTFNzUklSVWpJZ1lkQVNFMU5DWXJBVFVoRlNNaUJoVVJGQlk3QVJVaE5UTXlOajBCSVJVVUZqc0JGU0UxTXpJMk5SRTBKaXNCQVN3eUZSMEJMQjBWTWdFc01oVWRIUlV5L3RReUZSMysxQjBWTXY3VU1oVWRIUlV5QXJ4a0hSV1dsaFVkWkdRZEZmNXdGUjFrWkIwVmxwWVZIV1JrSFJVQmtCVWRBQUFBQUFFQUFBQUFBeUFDdkFBbEFBYXpDd0FCTFNzQU1oWWRBVE15RmgwQkZBWXJBU0ltTlJFMEppSUdGUkVVQmlzQklpWTlBVFEyT3dFMU5BRVUrTEF5RlIwZEZXUVZIWFdtZFIwVlpCVWRIUlV5QXJ5d2ZHUWRGY2dWSFIwVkFWNVRkWFZUL3FJVkhSMFZ5QlVkWkh3QUFBQUJBQUFBRXdNZ0Fyd0FEUUFHc3d3Q0FTMHJFRFEyTWhZVk5EWXlGaFFIQ1FGMnBIWjJwSFk3L3F2K3F3R2lwSFoyVWxKMmRxUTcvcXdCVkFBQkFBQUFBQU1nQXJ3QUNnQUdzd01BQVMwckNRRW5FU00xSXhVakVTTUJrQUdRWk1qSXlHUUN2UDdVQS81dHlNZ0JrQUFBQWdBQUFBQURJQU1nQUFNQURRQUl0UWNFQWdBQ0xTc1JJUkVoRXhFM0FUTTFKemNYRVFNZy9PQmtaQUdRWk1oa1pBTWcvT0FDdlA3VVpQNXdaTWhrWkFFc0FBQUNBQUFBQUFNZ0F5QUFDd0FUQUFpMUR3d0ZBQUl0S3hNaE1oVVJGQ01oSWpVUk5CY1JNeGN6TnpNUkV3TDZFeFA5QmhOa1pHVElaR1FESUJQOUJoTVRBdm9UeVA3VVpHUUJMQUFBQXdBQUFNZ0RJQUpZQUJVQUlBQXJBQXEzSmlFYUZnb0FBeTByRXpJV0Z6NEJNeklXRkFZaklpWW5EZ0VqSWlZME5oY2lCaFFXTXpJMk55NEJJU0lHQng0Qk16STJOQ2JJTjE0ek0xNDNYV3RyWFRkZU16TmZObDFyYTEwek1URXpIVDhxS2o4QmN4MC9LaW8vSFRNeE1RSllRRG82UUhpZ2VFQTZPa0I0b0hoa1BGQThOREF3TkRRd01EUThVRHdBQWdBQUFBQUJrQU1nQUFjQUpRQUl0UllJQkFBQ0xTc0FNaFlVQmlJbU5BWXlGaFVVQmhVVUZqSTJOVE1VQmlNaUpqVTBQZ0UxTkNZaUJoVWpOQUVEVWpzN1VqdHdmRmhrSFNvZFpGZytQMWN5TWgwcUhXUURJRHRTT3p0U3YxazlKY2NPRlIwZEZUNVlWa0FsY1ZvS0ZSMGRGVDRBQUFBQUFRQUFBQUFDdkFNZ0FCQUFCck1IQUFFdEt4TWhGU01EQnpNVklUVXpQZ0kvQVNQSUFmUjY2Z2FpL2d4NklrNWdHZ2VqQXlCay9iUU1aR1JZeE85QkRBQUFBQUFFQUFBQUFBTWdBcndBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt4RWhGU0VWSVJVaEZTRVZJUmNoRlNFRElQemdBeUQ4NEFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUJBQUFBQUFESUFLOEFBTUFCd0FMQUE4QURVQUtEZ3dLQ0FZRUFnQUVMU3NSSVJVaEZTRVZJUlVoRlNFVklSVWhBeUQ4NEFNZy9PQURJUHpnQWxqOXFBSzhaR1JrWkdSa1pBQUFBQVFBQUFBQUF5QUN2QUFEQUFjQUN3QVBBQTFBQ2c0TUNnZ0dCQUlBQkMwckVTRVZJUlVoRlNFVklSVWhGeUVWSVFNZy9PQURJUHpnQXlEODRNZ0NXUDJvQXJ4a1pHUmtaR1JrQUFBQ0FBQUFBQU1nQXlBQUVRQVpBQWkxRmhJTEFBSXRLd0F5RmhRR0l5SW5CeFVqRlNFMUFTWTFOQ1FpQmhRV01qWTBBYjdRa3BKb0lBOER5UDdVQVM4REFWVlNPenRTT3dNZ2t0Q1NBd05reU1nQkx3OGdhQzQ3VWpzN1VnQUFBQUFDQUFBQUFBTWdBbGdBR0FBZ0FBaTFIQmtOQUFJdEt4TTdBeUV5RmhVUk14VVVCaU1oSWlZOUFUTVJOVFEyRnhFekZUTTFNeEdHQXdRRUJRSDBGUjFrSFJYOVJCVWRaQlJRWk1oa0FsZ2RGZjZpbGhVZEhSV1dBVjRDRHgxZy90UmtaQUVzQUFBQUFBTUFBQUFBQXlBRElBQURBQWtBRHdBS3R3d0tCZ1FDQUFNdEt4RWhFU0VsTXhFaE5TRTNNeEVoTlNFQmtQNXdBZlJrL25BQkxNaGsvbkFCTEFNZy9uREkvbkJrWlA1d1pBQUFBQUFFQUFEL213SDhBcjBBRVFBakFEMEFVQUFOUUFwTlFESWxIQk1LQVFRdEt3RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0R3RWVBUlVVQmlNaUppc0JMZ0UxTkRZM0Z6UTJPd1F5RmhRR0t3RWlCaU1pSmdGUkNnc1ZIUkFML3RRUEVCVWRGZzhCa0FzS0ZSMFFDLzV3RHhBVkhSWVBBWkFMQ2hVZEVBdHFFaGtlRlFFR0FjZ1RIUThMRGhzVEF3UUZaQlVkSFJWa0FRWUJGUjBDdGdjZEZRMGFCcFlMSFJVUUhRUUhIUlVOR2diSUN4MFZFQjBFQngwVkRSb0dPQU1kRWhVZUFRRWRGQXdhQnZRU0lCMHFIUUVlQUFRQUFBQUFBeDRESUFBRkFDY0FTZ0JRQUExQUNrOUxSUzBRQ0FJQUJDMHJFek1WSXpVekpUTTJGeFlYRmhRUEFRWWpJaVkxTkQ4Qk5pWW5KZ1lQQVFZaklpWTFORDhCTmdFMk93RXlOak15RmhRUEFRWVdGeFkyUHdFMk16SVdGUlFQQVFZSEJpWW5KalEzQlRNVkl4VWp4MlRJWkFHREFTSVdOeW82T3BZUEhCVWRHSlllQVIwZ1ZSc3NEeHNWSFJnck12N1VEUWtEQVFZQkZSME9saDRCSFNCVkd5d1BHeFVkR0NzZkxEUnlLVG82QWJuSVpHUURJTWhrWVFJRkRDbzZwRHVXR0IwVkhBK1dIbFVkSGdNYkxCZ2RGUndQTERUKzBSQUJIU29PbGg1VkhSNERHeXdZSFJVY0R5d2ZFQk1aS1R1a09veGtaQUFBQUFJQUFBQUZBeDRESFFBckFGUUFDTFZVVFFrQkFpMHJBVFlYRmhjV0ZBOEJCaWN1QlNNbU5UUTJNeklYRmhjV1B3RTJKaWNtQmdjR0l5SW1OVFEzTmdjZUFoY2VBUlVVQmlNaUp5WW5KZzhCQmhZWEZqWTNOak15RmhVVUJ3WUhCaVluSmpRL0FUWUNTaU1XTnlvNk9wWlVZZ3dXRFJFRkRnRWFIUlVPREE4YU56T1dIZ0VkSUZVYkR4d1ZIUmd5ZWhZZ0dBY1BGaDBWRUE4VEhEa3VsaDRCSFNCVkd3OGJGUjBYSHl3MGNpazZPcFpRQXgwQ0JRd3FPcVE3bGxRR0FRTURCd01JRGg0VkhnY0xBZ1F6bGg1VkhSNERHeGdkRlJ3UE5PTUJDQXNDQkIwUUZSMExDUUVDTHBZZVZSMGVBeHNZSFJVZERoOFFFeGtwTzZRNmxsQUFBQUFBQmdBQUFBQURJQUs4QUFNQUJ3QUxBQThBRXdBWEFCRkFEaFlVRWhBT0RBb0lCZ1FDQUFZdEt4RWhFU0VCSVJVaEZTRVZJUVVoRVNFQklSVWhGU0VWSVFFcy90UUJrQUdRL25BQkxQN1UvbkFCTFA3VUFaQUJrUDV3QVN6KzFBSzgvdFFCTEdSa1pHVCsxQUVzWkdSa0FBZ0FBQUFBQXlBQ3ZBQUhBQXNBRXdBWEFCOEFJd0FyQUM4QUZVQVNMaXdvSkNJZ0hCZ1dGQkFNQ2dnRUFBZ3RLeEl5RmhRR0lpWTBOeUVWSVFZeUZoUUdJaVkwTnlFVklRWXlGaFFHSWlZME55RVZJUVl5RmhRR0lpWTBOeUVWSVIwcUhSMHFIY2dDV1Ayb3F5b2RIU29keUFKWS9haXJLaDBkS2gzSUFsajlxS3NxSFIwcUhjZ0NXUDJvQXJ3ZEtoMGRLaDFrWkIwcUhSMHFIV1JrSFNvZEhTb2RaR1FkS2gwZEtoMWtBQUFBQVFBQUFBQURJQU1nQUFNQUJyTUJBQUV0S3drQkF5VURJUDV3WlA3VUF5RDg0QUVzWkFBQUFBSUFBQUFBQWxnQ3ZBQUxBQk1BQ0xVUURBWUFBaTByRWpJV0hRRXpFU0VSTXpVME5pSUdIUUV6TlRUYXBIWmsvYWhrOGxRNnlBSzhkbEprL25BQmtHUlNFam9xWkdRcUFBRUFBQUFBQWxnRElBQVJBQWF6QmdBQkxTc1NNaFlkQVRNUklSRWhOVFFtSWdZVkl6VGFwSFprL2FnQmtEcFVPbVFESUhaU3lQNXdBWkRJS2pvNktsSUFBQUFBQWdBQUFHUURJQUs4QUFvQUZRQUl0UThMQmdBQ0xTc0JGU0lHRlRNSEp6TTBOZ1VYSXhRR0l6VXlOalVqQVpCVGRXU1dsbVN3QVhhV1pMQjhVM1ZrQXJ4a2RWUEl5SHl3Wk1oOHNHUjFVd0FDQUFBQUFBTWdBeUFBQ2dBVkFBaTFFZ3NFQUFJdEt4TWhFVE1ISnpNMUlSVWpId0VqRlNFMU14VWhFU05rQWxoa2xwWmsvbkJrTXBaa0FaQmsvYWhrQXlEKzFQcjZ5R1F5K3Noa3lBRXNBQUlBQUFBQUF5QUN2QUFMQUJjQUNMVVdEQUlBQWkwckFSY0hOU0VWSXpVME5qTWhBUlVoTlRNVkZBWWpJUlVuQWxqSXlQNE1aRHNwQWZUK2NBSDBaRHNwL2d6SUFyeVdsbVJrWkNrNy90UmtaR1FwTzJTV0FBQUNBQUQvL2dNaUF5QUFHUUFqQUFpMUh4b05BQUl0S3hJZ0ZoVVVCeFlmQVI0QkZSUUdJeUltTHdFbUp3WWpJaVlRQVRJMk5UUW1JZ1lVRnMwQklzMHNDZ1prREJJOEtoRXJER1FGQjAxWmtjMEJYbXFRa3RDU2tnTWd6WkZXVUFZR1pBd3JFU284RWd4a0JBa3B6UUVpL25XUWFtaVNrdENTQUFBQUFnQUFBQUFDV0FNZ0FCQUFHQUFJdFJVUkNRQUNMU3NTTWhZVkZBNENEd0V1QkRVMEpDSUdGQll5TmpTdytMQStXRmdmSHd3cFowOUJBWDZrZG5ha2RnTWdzSHc0a0g1dUlDQU1LMzExa3poOFRIYWtkbmFrQUFRQUFBQUFBeUVESUFBSUFCY0FKZ0F1QUExQUNpc25IeGdSRHdjQUJDMHJFU0VSRmhVVUJ4VWhKVFEyT3dJUklSRWhOU3NCSWlZQ01oWVZGQVlQQVM0RU5UUVdJZ1lVRmpJMk5BTWdBUUg4NEFIdkhSVUZsdjJvQWxpV0JSVWR6M3hZU3lVbUJoUTBLQ0NyS2gwZEtoMERJUDNqQXdnSEErNzZGQjRCa1Ayb1pCMEJjMWcrTEgwcEtBWVdQanBLSEQ0TUhTb2RIU29BQWdBQUFHUUNXQUs4QUFNQUJ3QUl0UVlFQWdBQ0xTc1JNeEVqQVRNUkk4aklBWkRJeUFLOC9hZ0NXUDJvQUFBQUFRQUFBR1FDV0FLOEFBSUFCck1DQUFFdEt4RUpBUUpZL2FnQ3ZQN1UvdFFBQUFBQUFRQUFBR1FDV0FLOEFBY0FCck1FQUFFdEt4SXlGaFFHSWlZMHNQaXdzUGl3QXJ5dytMQ3crQUFBQUFBQ0FBQUFaQU1nQXJ3QUFnQUZBQWkxQlFRQkFBSXRLd0VSQVNFQkVRR1EvbkFCa0FHUUFyejlxQUVzQVN6OXFBQUNBQUFBWkFNZ0Fyd0FBZ0FGQUFpMUJBTUNBQUl0S3hFSkFTRVJBUUdRL25BQmtBR1FBcnorMVA3VUFsaisxQUFDQUFBQVpBSzhBcndBQXdBR0FBaTFCZ1VDQUFJdEt4RXpFU01UQVJISXlNZ0I5QUs4L2FnQkxBRXMvYWdBQUFBQ0FBQUFaQUs4QXJ3QUFnQUdBQWkxQkFNQ0FBSXRLeEVKQVNFUk14RUI5UDRNQWZUSUFyeisxUDdVQWxqOXFBQUJBQUFBWkFKWUFyd0FBd0FHc3dJQUFTMHJFU0VSSVFKWS9hZ0N2UDJvQUFFQUFBQUFBeUFESUFBTEFBYXpCZ0FCTFNzVElSVXpFU01WSVRVakVUUElBWkRJeVA1d3lNZ0RJTWorY01qSUFaQUFBQUFEQUFBQUF3TWdBcndBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSSVJVaEZTRVZJUlVoRlNFRElQemdBeUQ4NEFNZy9PQUN2R1RGWk1oa0FBQUNBQUQvbkFKWUFzQUFFQUE4QUFpMUx4VUpBUUl0S3dFMk16SVdIUUlVQmlJbVBRSTBOZ2M3QVRJMk16SVdIUUlVRmpJMlBRRTBOaklXSFFFVUJnY1ZNeklXRlNFME5qc0JOUzRCUFFJME5nRVdEZ2dwT3p0U095N1VCQU1CQmdJVkhYV21kUjBxSFk5ck1pazcvbkE3S1RKcmp4UUN2QVE3S1FUSUtUczdLY2dDSVRyQkFSMFZBVEpUZFhWVE1oVWRIUlV5YnFZU2Fqc3BLVHRxRXFadU1nSVBIUUFBQUFBQkFBQUJMQU1nQWZRQUF3QUdzd0lBQVMwckVTRVZJUU1nL09BQjlNZ0FBQUlBQVArY0F5QUN2QUFnQUNRQUNMVWlJUklBQWkwckV6c0RJVElXRlJFVUJpc0JGVE15RmhVaE5EWTdBVFVqSWlZMUVUVTBOaGNSSVJFaUJBTUVCUUs4RlIwZEZmcGtLVHY5cURzcFpQb1ZIUlJRQWxnQ3ZCMFYvZ3dWSFdRN0tTazdaQjBWQWZRQ0R4MWcvbkFCa0FBQkFBRC9zZ01LQXJ3QUR3QUdzd2tBQVMwckFRWVZGQll6TWpjT0FTTWlKalUwTmdFUUZ1cW1RVDhvMElLbTZwZ0N2RDlCcHVvV2VKanFwb0xRQUFBQUFRQUFBQUFDdkFLOEFCY0FCck1NQUFFdEt3RVhJeFV6TlJjSE5TTVZNd2NuTXpVakZTYzNGVE0xSXdGZWxtU1dscGFXWkphV1pKYVdscFprQXJ5V2xtU1dsbVNXbHBhV1pKYVdaSllBQUFBQkFBQUFBQU1nQXlBQUhRQUdzeEFBQVMwckFSRVVCaUltTkRZek1oYzFCQWNSRkFZaUpqUTJNeklYRVQ0RUF5QllmRmhZUGhjYi92V0ZXSHhZV0Q0WEd3UVVXSGprQXlEOTJqNVlXSHhZQ2M0SUt2NXpQbGhZZkZnSkFaa0VEaUlhRmdBQUFRQUEvNTBDdWdLOEFDd0FCck1uQUFFdEt3QXlGeFlVRHdFR0lpWTBQd0VYRHdFR0ZCWXlQd0UrQVNjdUFRY0JEZ0VYRmpJL0FoY0hCaUltTkRjQkFhR2tPem82K2lSblNDUmdSVm9IQnc0WUIvb2NBUjBkVlI3KzZqSUJNelNTTkFsMFJYMVE1S0JRQVJZQ3ZEczdwRHIwSkVobkpHRkZYZ01JRmhBSTl4NVJIaDBCSHY3dE5KQXpORFFNY1VWOVVLRGtVQUVRQUFBQ0FBQUFBQU1nQXlBQUF3QUlBQWkxQmdRQ0FBSXRLd0VYQnljSEZ3RWpOUUpZeUdUSVpNaitjTWdESU1oa3lHVEkvbkRJQUFBQUFBUUFBQUFBQXlBRElBQU1BQlFBSGdBcUFBMUFDaVlmR1JVUkRRUUFCQzByQVRJV0ZBWWpJaWMyTlRRbk5nUXlGaFFHSWlZMEJSNEJIUUVqTlRRbk5nVVdNamNlQVIwQklUVTBOZ0ltUGxoWVBob2hDVWd1L3VKOFdGaDhXQUp4SWluSUxHWDl1a2ZRUnlJcC9nd3BBeUIxcG5VVEp5cCtWbGhrZGFaMWRhYkhFVDhtcGtKSVBnTVRWRlFSUHlhbXBpWS9BQUFDQUFBQUFBTWdBeUFBQndBVEFBaTFEd2dFQUFJdEt3QXlGaFFHSWlZMEF4WXlOeDRCSFFFaE5UUTJBVDJtZFhXbWRRbFo4RmxRYi96Z2J3TWdrODZUazg3K24yUmtCSE5SWkdSUmN3QUFBQU1BQUFBQUFmUURJQUFMQUE4QUZ3QUt0eFFRRFF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjUklSRUNJZ1lVRmpJMk5CTUJ6aE1UL2pJVFpBRXNnU29kSFNvZEF5QVQvUVlURXdMNkUyVCtEQUgwL2RvZEtoMGRLZ0FBQXdBQUFBQURJQU1nQUFVQUR3QVdBQXEzRWhBTEJnTUFBeTByQVRJWEVRRTJCUjRCRlJRR0l5SW5BU1VYQnk0Qk5UUUJYaG9ZL3RkbEFTaUFyTTJSZTJNQkVQNW43ZFEyUGdNZ0EvNXpBU2xuYWhQQ2c1SE5VUUVRMGVyVUtucEdmQUFBQUFFQUFQK2NBcndDdkFBakFBYXpGUUlCTFNzVE5EWTdBeUV5RmhRR0t3RVZNeklXRlNFUkJ5Y1JJVFEyT3dFMUl5SUdJeUltWEJzVEF3UUZBWkFWSFIwVk1tUXBPLzdVT0N6KzFEc3BaRElCQmdFVkhRS0tFaUFkS2gzSU95bisxR1JrQVN3cE84Z0JIZ0FBQUFJQUFBQUFBeUFESUFBSEFBb0FDTFVKQ0FRQUFpMHJFaUFXRUFZZ0poQWxFU1hxQVV6cTZ2NjA2Z0VzQVN3RElPcit0T3JxQVV3aS9uRElBQUVBQUFBQUF5QURJQUFMQUFhekJnQUJMU3NCTXhFaEZTRVJJeEVoTlNFQkxNZ0JMUDdVeVA3VUFTd0RJUDdVeVA3VUFTeklBQUFBQWdBQUFBQUN2QU1nQUFNQUhnQUl0UmdFQWdBQ0xTc0JNeEVqQXhjSEJoVVVGakkyTlRRbUx3RTNGeDRCRlJRR0lDWTFORFkzQVN4a1pJQStLRjZTMEpJMExTVStKajVJemY3ZXpVZytBeUQrY0FFQVRoOUxlbWlTa21nN1p5TWZUaDh4a0ZLUnpjMlJVcEF4QUFBQUFBTUFBQUFBQXlBRElBQURBQk1BRndBS3R4WVVDUVFDQUFNdEt4TWhGU0VISVRJVkVSUXJBVFVoRlNNaU5SRTBGeUVSSWNnQmtQNXd2d01PQ1FsYi9haGJDY2dCa1A1d0F5RElaQW4rNWduSXlBa0JHZ25JL3RRQUFBQUFCUUFBQUFBRElBSzhBQU1BQndBTEFBOEFFd0FQUUF3U0VBNE1DZ2dHQkFJQUJTMHJFVE1SSXdFekVTTUJNeFVqRnpNVkl4Y3pGU05rWkFLOFpHVCtETWpJWk1qSVpNaklBcno5UkFLOC9VUUNXR1JrWkdSa0FBRUFBUC9oQXlBQ3ZBQWJBQWF6RWdBQkxTc0JGaE0rQVRjV0Z6TVZJeWNHQnlZREJnSUhKaWNqTlRNZkFUWVNBVVVhYVE4NkR4UkRxZWNOU2lZV1lSVlRGUnc0ZEx3SkF3OVdBcnhYL3JRbGxDVW1obVFjdUZ0SkFUaEQvdlpEV0s1a0lnWXhBUnNBQVFBQS81d0RJQUs4QURrQUJyTWZBZ0V0S3hNME5qSVdGUlFPQVFjR0ZUTVZNamMrQWpNeUZoUUdJeUl1QVNjbUl4VWpORGMrQWpVMEppSUdGUlFlQVJjV0ZTTVJNelFuTGdMSU9WWTVDUkFEQStjV0JnY2RGdzByT1RrckRSY2RCd1lXNXdNREVBazVWamtKRUFNRDUrY0RBeEFKQWxnck9Ua3JEUmNkQndZVzV3TURFQWs1VmprSkVBTUQ1eFlHQngwWERTczVPU3NORngwSEJoWUNXQllHQngwWEFBQUFBZ0FBLzV3QjhRSzhBQ3NBTHdBSXRTNHNEd0FDTFNzVE1oY1dGUlFPQVFjT0JCMEJJelUwUGdFM1BnZzFOQ2NtSXlJSEJnY25OamMyRXpNVkkvZCtRVHNyS2lJWEN4NElDV1FvS2lFQ0d3UVZCQThEQndJY0psUlBKUmdIWkFveFFraGtaQUs4T3paWE5sOHVIaFFMSVJZb0dCa1pObDR3SFFJWEJSUUlFdzRXRnc0cEdTSWxHQzBNVHpGQy9VUmtBQUFBQUFRQUFBQUFBeUFESUFBZkFETUFSd0JiQUExQUNsUk1RRGdzSkFvQUJDMHJBVElXSFFFZUFSVVVCZ2N1QVNNaUJ5NEJJZ1lISmlNaUJ5WTFORFl6UGdFRE93RXlOak15RmgwQ0ZBWWlKajBDTkRZSE93RXlOak15RmgwQ0ZBWWlKajBDTkRZbE93RXlOak15RmgwQ0ZBWWlKajBDTkRZQndtaVNLemsvTVJGTExoc2REVkJtVUEwZEd6a29OWFpTRVk4YUJBTUJCZ0lWSFIwcUhSUzZCQU1CQmdJVkhSMHFIUlFCbmdNRUFRWUNGUjBkS2gwVUF5Q1NhRElRVlRFelVBMHFOQXd4UHo4eERDSTZURkoyVm5MK0RBRWRGUUhJRlIwZEZjZ0NEeDFnQVIwVkFXUVZIUjBWWkFJUEhRUUJIUlVCWkJVZEhSVmtBZzhkQUFFQUFBQUFBeUFESUFBakFBYXpDd0FCTFNzQkZ3YzFJd2NmQVRNMUZ3YzFJeUl2QVFjR0t3RTFNemN2QVNNMU16SWZBVGMyT3dFQ1dNaklNcG12QmhiSXlCa3VJS2FaSHk5a1pLYWpBMlJrTGlDWmpSOHZNZ01nbHBaa3Y4NERaSmFXWkNhK3ZpWmt6cjhEWkNheXNpWUFBQUFBQVFBQUFBQURJQU1nQUJVQUJyTVFBQUV0S3dFeUZ6Y1JJVGNtSXlJR0ZCWXlOeGNHSXlJbUVEWUJrS0ozZC83VWJWbDRmTEN3K0ZoSWRLaWw2K3NESUhkMy90UnRXN0Q0c0ZoSWRPc0JTdXNBQUFBQUFRQUFBQUFESUFNZ0FBa0FCck1GQUFFdEt3RWhFU2NCRnlFUkZ3RUJrQUdRcHY1d3B2NXdwZ0dRQXlEK2NLYitjS1lCa0tZQmtBQUJBQUFBQUFIMEF5QUFDUUFHc3dVQUFTMHJHd0VqRlRNTEFUTTFJL3I2eU1qNitzaklBeUQrMU1qKzFBRXN5QUFCQUFBQVpBTWdBbGdBQ1FBR3N3VUFBUzByQVJVek5RMEJOU01WSlFFc3lBRXMvdFRJL3RRQ1dNakkrdnJJeVBvQUFBQUFBd0FBQUFBRElBTWdBQW9BRWdBWEFBcTNGaE1PQ3dVQUF5MHJFVElFRmhJVkl6UUNKQ01WTWdBVkl6UW1JeFV5RmhVam9nRXAxbi9Jb1A3c3BNNEJKc2l2ZlZKMnlBTWdmOWIrMTZLa0FSU2daUDdhem4ydlpIWlNBQUFFQUFBQUFBTWdBeUFBQ2dBVEFCc0FJd0FOUUFvZ0hCY1VEd3NFQUFRdEt4TXlCQklWSXpRdUFpTVZNaDRCRlNNMEppTVZNaFlWSXpRbUl3WXlGaFFHSWlZMFpMNEJRcnhrWDZEZmVvam1obVRxcG55d1pIVlRLVkk3TzFJN0F5QzgvcjYrZXQrZ1gyU0c1b2ltNm1Td2ZGTjFaRHRTT3p0U0FBQUFBUUFBQUFBRElBTWdBQ0VBQnJNUkFBRXRLd0VoTWhZZEFTRTFOQ1lpQmgwQklSRVVCaU1oSWlZOUFUTVZGQll5TmpVUk5EWUJMQUdRS1R2K2NCMHFIUUdRT3luK0RDazdaQjBxSFRzRElEc3B5SllWSFIwVit2N1VLVHM3S2NpV0ZSMGRGUUltS1RzQUFBQUFBZ0FBQUFBRElBSzhBQklBSFFBSXRSb1RDZ0FDTFNzVE14VWpFU0UxTXhVVUJpTWhJaVkxRVRRMklSY0hOU01pQmdjK0FUTkw0Y2dCa0dRc0gvNCtIeXdzQWl6SXlNaEdiQkFSNEprQ3ZHVCtER1I5SHl3c0h3SW1IeXpJeUdSV1E1YkxBQUVBQUFBQUF5QUN2QUFNQUFhekJ3QUJMU3NKQWpVaklnWUhORDRDTXdIMEFTeisxR1NZMGlZdGJjaVNBcnorNVA3RXlKcVNkcXlMUndBQUFBSUFBQUFBQXlBRElBQVVBQndBQ0xVV0ZRc0JBaTByQVRjWEZnUVhGUlFIQmdjR0lpY21KeVk5QVRZa0V4RUZGaGNXRnhZQmZSTVRKUUVPU3BNOVFFaHdTRUE5azBvQkRqaisyZ3h1T0RJckF4Y0pDUTl6SGgvZ3cxRXZOVFV2VWNYZUh4NXovVndDVDNxMWswb2tId0FFQUFBQUFBSzhBeUFBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt3RXpFU01ETXhFakF6TVJJd016RVNNQ1dHUmt5R1JreUdSa3lHUmtBeUQ4NEFLOC9VUUI5UDRNQVN6KzFBQUFBQUVBQUFBQUFyd0RJQUFOQUFhekJ3QUJMU3NCTXhVekZ3Y2pFU01SSXljM013RXNaTWhrWk1oa3lHUmt5QU1neUdSay9uQUI5R1JrQUFBQUFBUUFBQUFBQXlBRElBQUdBQW9BRGdBU0FBMUFDaEVQRFFzSkJ3UUFCQzByRXpNUk13Y25NeE16RlNNVklSVWhGU0VWSWNoa3lQcjZ5TWpJeUFFcy90UUJrUDV3QXlEOXFNaklBbGhrWkdSa1pBQUFBQVFBQUFBQUF5QURJQUFHQUFvQURnQVNBQTFBQ2hFUERRc0pCd1FBQkMwckV6TVJNd2NuTXhNaEZTRVZJUlVoRlRNVkk4aGt5UHI2eU1nQmtQNXdBU3orMU1qSUF5RDlxTWpJQWxoa1pHUmtaQUFBQUFjQUFBQUFBeUFDdkFBUEFCTUFGd0FiQUI4QUl3QW5BQk5BRUNVa0lTQWRIQmtZRlJRUkVBY0FCeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNWTXpVekZTRTFCUlV6TlRNVklUVUZGVE0xTXhVaE5Vc0NpaDhzTEIvOWRoOHNMRGhrWkFHUS9haGtaQUdRL2Foa1pBR1FBcndzSC8zYUh5d3NId0ltSHl4a1pHUmtaTWhrWkdSa3lHUmtaR1FBQUFFQUFBQUFBeUFESUFBSkFBYXpCQUFCTFNzQkV5RUhFeWNIRXljaEFaQmtBU3o2WlByNlpQb0JMQU1nL3RUSS90VEl5QUVzeUFBQUNRQUFBQUFESUFNZ0FBY0FEd0FYQUI4QUp3QXZBRGNBUHdCSEFCZEFGRVJBUERnME1Dd29KQ0FjR0JRUURBZ0VBQWt0S3dBeUZoUUdJaVkwQmpJV0ZBWWlKalFrTWhZVUJpSW1OQVF5RmhRR0lpWTBCaklXRkFZaUpqUWtNaFlVQmlJbU5BUXlGaFFHSWlZMEpESVdGQVlpSmpRR01oWVVCaUltTkFGN0toMGRLaDNkS2gwZEtoMENFU29kSFNvZC91YWtkbmFrZHFzcUhSMHFIUUxaS2gwZEtoMzl4U29kSFNvZEFoRXFIUjBxSGQwcUhSMHFIUU1nSFNvZEhTcEhIU29kSFNvZEhTb2RIU3BIZHFSMmRxUWdIU29kSFNvZEhTb2RIU3JkSFNvZEhTb2RIU29kSFNwSEhTb2RIU29BQXdBQUFBQUN2QU1nQUE4QUV3QVpBQXEzRnhRUkVBY0FBeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNSSVJFQ0lnWVdNallpQW5nT0ZCUU8vWWdPRkJSUUFmVGRPaDBjUEJ3RElCUU8vU1FPRkJRT0F0d09GR1QrREFIMC9kb3lNaklBQUFJQUFBQUFBeUFESUFBRUFBd0FDTFVKQlFNQUFpMHJFU0VKQWpZaUJoUVdNalkwQVN3QjlQN1UvZ3p4VWpzN1Vqc0RJUDRNL3RRQjlNZzdVanM3VWdBREFBQUFaQU1nQWxnQUJBQUtBQklBQ3JjUEN3Z0ZBd0FETFNzUk13RUhBU1V6QVFjbk55UWlCaFFXTWpZMHlBRXN5UDdVQVZTZ0FTeklUbmYrS2lvZEhTb2RBbGorMU1nQkxNaisxTWhPZXNnZEtoMGRLZ0FBQkFBQUFBQURJQU1nQUFjQUR3QVhBQjhBRFVBS0hCZ1VFQXdJQkFBRUxTc1NJQllRQmlBbUVDUWlCaFFXTWpZMEpESVdGQVlpSmpRMklnWVVGakkyTk9zQlN1dnIvcmJyQWd6NHNMRDRzUDZDcEhaMnBIYnlWRG82VkRvRElPdit0dXZyQVVxSHNQaXdzUGhNZHFSMmRxUVNPbFE2T2xRQUFnQUFBQUFESUFLOEFBa0FEd0FJdFF3S0NBQUNMU3NSSVFjaEVTRTFOeEVoQVJjQkp6Y1hBaTlrL3BrQjlHVDlSQUs4WlA1d3lHUmtBcnhrL2d5ZlpQNlpBcnhrL25ESVpHUUFBQU1BQUFBQUF5QURJQUFMQUJFQUZRQUt0eE1TRUF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjSEZ3Y1hOeGNWSVRVSkF3NEpDZnp5Q1paSVpHUklyRTRCTEFNZ0NmenlDUWtERGdsT1NHUmtTS3d5WkdRQUFBQUJBQUFBQUFNZ0F5QUFHUUFHc3cwQUFTMHJFU0VWSXpRbUt3RVJGQlk3QVJVaE5UTXlOalVSSXlJR0ZTTURJREk3S1pZZEZUTCtjRElWSFpZcE96SURJTWdwTy8zYUZSMWtaQjBWQWlZN0tRQUFBQUFDQUFBQUF3SzhBcndBQXdBZEFBaTFGUVFDQUFJdEt4RXpFU01USVRJWEVoVVVCaXNCSWdZVkZCY1dEZ0VtSnk0Q0p5WWpaR1RJQVY0aERtY2RGWllVSGk4R0VpWWtDd0krT0FnY0xBSzgvbkFCa0IvKzNSd1ZIUjhUSDVrVUpRd1JGQU43YUFnY0FBSUFBQUFBQXJ3Q3ZBQWNBQ0FBQ0xVZkhSUUNBaTByQVRZM0Z4NEJCd1lWRkJZN0FUSVdGUlFHRHdFR0l5RVJNamMrQWdFekVTTUJrQkFmRXhNU0JpOGVGSllWSFRRYUdRNGgvcUlzSEFnNFB2NXlaR1FDbWg4REF3WWxGSmtmRXg4ZEZReWdTa2tmQVpBY0NHaDcvdm4rY0FBQUFnQUEvNXdDdkFLOEFCOEFLZ0FJdFNNZ0Z3QUNMU3NUSVJVakZSWVhCeVlqSWdZVUZqSTJOVFFuTnhZVkZBWWdKalUwTmpjMUl3VUFCd1lpSmpRM1BnRTN5QUVzWkRJV0lpa3ZhSktTMEpJUVd4bk4vdDdOcklCa0FmVCsyQlFQSmg0UENjQmJBcnhrQmdnSVhoQ1MwSktTYUM4cEpVUTVrYzNOa1lQR0VnTVEvcVFVRHg0bUR3bVdSd0FDQUFBQUFBTWdBcndBQmdBTkFBaTFEQWNDQUFJdEt3RVhCelVoTlNFQkZTRVZJUlVuQWxqSXlQMm9BbGorY0FKWS9haklBcnlXbG1Say90UmtaR1NXQUFBQUFBSUFBQUFBQXJ3RElBQVBBQ2NBQ0xVakVBZ0FBaTByQVRNeUZoVXpNaFlWSVRRMk93RTBOZ016RVJRV01qWTFFVE1SRkJZeU5qVVJNeEVVSXlFaU5RRXNaQ2s3WkNrNy9VUTdLV1E3bjJRZEtoMWtIU29kWkJQK01oTURJRHNwT3lrcE95azcvdFQrb2hVZEhSVUJYdjZpRlIwZEZRRmUvaDhURXdBQ0FBQUFBQUs4QXlBQUVRQVZBQWkxRkJJTUFBSXRLeE16RVJRV01qWTFFVE1SRkFZckFTSW1OUU1oRlNGa3lEdFNPMlIyVWpKbmsyUUN2UDFFQXlEK2NDazdPeWtCa1A1d1VuWjFVLzdVWkFBQUFBQUVBQUFBQUFNZ0Fyd0FDd0FYQUNNQUp3QU5RQW9tSkIwWUVRd0ZBQVF0S3hNek1oVVJGQ3NCSWpVUk5DRXpNaFVSRkNzQklqVVJOQVV6TWhVUkZDc0JJalVSTkFFaEZTRUp0Z2tKdGdrQ1liWUpDYllKL3QyMkNRbTJDZjdVQXlEODRBSzhDZjRlQ1FrQjRna0ovaDRKQ1FIaUNjZ0ovdVlKQ1FFYUNmNXdaQUFBQUFBSEFBQUFBQU1nQXJ3QUJ3QVBBQmNBR3dBakFDc0FNd0FUUUJBdkxDY2tIeHdhR0JRUURBZ0VBQWN0S3hNek1oMEJJelUwSVRNeUhRRWpOVFFGTXpJZEFTTTFOQVVoRlNFVk14VVVLd0VpTlNVekZSUXJBU0kxSlRNVkZDc0JJalVLdFFuSUFtSzFDY2orM3JVSnlQN1VBeUQ4NE1nSnRna0JMTWdKdFFvQkxNZ0p0UW9DdkFtL3Z3a0p2NzhKWkFsYld3bklaR1MvQ1FtL1d3a0pXNzhKQ1FBQUFBUUFBQUFBQXlBQ3ZBQURBQThBR3dBbkFBMUFDaUVjRlJBSkJBSUFCQzByRVNFVklSY3pNaFVSRkNzQklqVVJOQ0V6TWhVUkZDc0JJalVSTkNFek1oVVJGQ3NCSWpVUk5BTWcvT0FKdGdrSnRna0JOYllKQ2JZSkFUVzJDUW0yQ1FLOFpHUUovaDRKQ1FIaUNRbis1Z2tKQVJvSkNmNGVDUWtCNGdrQUFBQUFBUUFBQUdRRElBSllBQlVBQnJNTkFBRXRLeE1oTWhZZEFUY3pFU01uRlJRR0l5RWlKalVSTkRZeUFmUVZIV1JrWkdRZEZmNE1GUjBkQWxnZEZaWmsvdFJrbGhVZEhSVUJrQlVkQUFNQUFBQUFBeUFESUFBSEFCd0FKQUFLdHlRZEVna0NBQU10S3dFekVTTW5JeEV6SVRVeUZ4NEJGQVlISXdZak5USTNQZ0UwSmljbUJ4Y2VBUlFHRHdFQlRrSkNoc2pJQVN3bEptSi9mMklESWlZYUdFRlZWVUVZR2hraEtpc2dHUU1nL09ESUFaQmtDaG1oMEtJWkNXUUdFV3VNYXhFR1pBTUlOMFEzQ0FNQUFnQUFBQUFDV0FNZ0FBY0FEd0FJdFE4SUFnQUNMU3NCTXhFakp5TVJNd1VYSGdFVUJnOEJBVTVDUW9iSXlBRXNHU0VxS3lBWkF5RDg0TWdCa0dRRENEZEVOd2dEQUFBQUFRQUFBQUFCa0FNZ0FBY0FCck1DQUFFdEt3RXpFU01uSXhFekFVNUNRb2JJeUFNZy9PRElBWkFBQUFBREFBQUFBQUs4QXlBQUR3QVRBQmNBQ3JjVkZCRVFCd0FETFNzQk16SVhBUmNWRkNNaElqMEJOd0UyQXhVek5RTVZNelVCTlZJSUJBRW1Bd245VmdrREFTWUVBV1JrWkFNZ0NmMVdFMUVKQ1ZFVEFxb0ovdFRJeVA3VVpHUUFBQUFEQUFBQUFBTHhBeUFBQ1FBU0FCb0FDcmNYRXcwS0F3QURMU3NCTWhjSEppTWlCeWMyRWpJWEJ5WWpJZ2NuRmpJV0ZBWWlKalFCZDlDcU5ZMjRzNDgxcWxqcVl6VklXMVZLTnF4U096dFNPd01nYlZKYlcxSnQvdFErVlM4dlZlNDdVanM3VWdBQUFBSUFBQUFBQXlFRElBQVpBQ0VBQ0xVZUdnOEFBaTByQVRJWEJ4VXpOeFlWRkFZaklpY0JCaUluSmpRM0FTWTFORFlBSWdZVUZqSTJOQUluSUE5aHlHRURrMmNxTVA3Z0hGZ2NIUjBCSXhPVC9yb3FIUjBxSFFNZ0EySElZUThnYUpJVC90MGNIQjFXSFFFZk1DdG9rdjEySFNvZEhTb0FBQUVBQVArc0F4QUN2QUFYQUFhekRRQUJMU3NURmhjK0FqY1hCeDRDRndjdUFpY0hKelkzSmllTkFmd2JabElrai8wY1psVW1qeVJUWlJ2OWpUUEgrUUVDdkFINUhHVlRKbzM5RzJWVEpJOG1WV1ljL1k4d3gvd0JBQUFBQVFBQUFBQUN2QU1nQUJjQUJyTU9BQUV0S3hFekV6TVRNd016RlNFVklSVWhGU00xSVRVaE5TRTFNMlRuSnVkazRlSCsxQUVzL3RSay90UUJMUDdVNFFNZy90UUJMUDdVWkdSa3lNaGtaR1FBQUFBQUF3QUEvLzRESWdNZ0FCa0FKd0F6QUFxM0xpZ2VHZzBBQXkwckVpQVdGUlFIRmg4QkhnRVZGQVlqSWlZdkFTWW5CaU1pSmhBa0lnWVVGak15TnpZL0FUWTFOQ1V6RlRNVkl4VWpOU00xTTgwQklzMHNDQVZuREJJOEtoRXJER1FGQkU5YWtjMEJ4dENTa21oY1J3NFJBelgrMUdSa1pHUmtaQU1nelpGWVVRUUZaQXdyRVNvOEVneG5CUWdzelFFaWFaTFFrandYQ0FORFdXZ3VaR1JrWkdRQUFBQURBQUQvL2dNaUF5QUFHUUFuQUNzQUNyY3FLQjRhRFFBRExTc1NJQllWRkFjV0h3RWVBUlVVQmlNaUppOEJKaWNHSXlJbUVDUWlCaFFXTXpJM05qOEJOalUwQlNFVkljMEJJczBzQ0FWbkRCSThLaEVyREdRRkJFOWFrYzBCeHRDU2ttaGNSdzRSQXpYK2NBRXMvdFFESU0yUldGRUVCV1FNS3hFcVBCSU1ad1VJTE0wQkltbVMwSkk4RndnRFExbG9ObVFBQVFBQUFBRVptU3NLMXpWZkR6ejFBQXNESUFBQUFBRFAyUzlxQUFBQUFNL1pMMm9BQVArYkF5SURJQUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUCtiQUVnRGhBQUFBQUFESWdBQkFBQUFBQUFBQUFBQUFBQUFBQUFBNFFFZ0FCb0FBQUFBQVFvQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBSllBQUFDV0FBQUF5QUFBQU1nQUFBQmtBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBbGdBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUFaQUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU9FQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQTRRQUFBSllBQUFEaEFBQUFsZ0FBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSzhBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBZlFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQVpBQUFBTWdBQUFESUFBQUE0UUFBQU1nQUFBRElBQUFBNFFBQUFBQUFBQUFBQUFXQUJZQUZnQTRBRm9BZUFDWUFNQUE1Z0VPQVV3QllnR0lBYTRCMGdIMkFnd0NJZ0k0QWs0Q1pBSjZBbzRDdGdNQUF5SURWQU4yQThnRDdnUU1CRllFZmdTcUJPZ0UvQVVzQlQ0RlhnV2NCZFlHSUFaWUJ1SUhGZ2RZQjVRSDVBZjBDQVlJR0FncUNIZ0lsZ2kyQ013STRnajRDUTRKTWdsZUNab0p6QW9RQ2tZS2FncWdDc1lMREFzcUMwZ0xhQXVHQy9vTUVneE1ERzRNb0F6VURRWU5ZQTJBRFp3TnhBM3lEaVFPZGc2U0Rxd08xZzcrRHpZUFRnOW1ENFFQb0EvS0VBWVFPQkJXRUhZUWxCQ3lFTllSS0JGc0VZZ1J6QkhxRWdZU0tCSndFcElTdGhNK0UyQVQwaFFhRkVZVWdCVElGUUFWSGhVNEZWb1ZnQlhJRmdRV0poWk1GbklXbUJiSUZ2d1hJaGVZR0JZWW1CalFHU2daUEJsZ0dZSVpxaG5TR2Y0YVBCcG9HclFhekJyZUd2UWJEQnNrR3p3YlZCdGtHMzRibkJ2d0hBQWNPQnhZSElBY3NoeitIUm9kWkIyTUhib2Q3QjRpSGtBZVhCNlVIc0llN2g4aUgzWWZ3Q0ErSUhnZ29pQytJTllnOENFZUlWd2hraUhFSWVJaUdpSkNJbUFpaWlLMEl2d2pHQ09RSThJajRpUU9KRW9rY0NTY0pNWWsraVUwSlhvbG5DWGFKZ1FtUmlhWUp0Z20vaWMrSjJJbmVDZW9KOXdvR0NoR0tIQW93aWtNQUFBQUFRQUFBT0lBYUFBUUFBQUFBQUFDQUFBQUFBQnpBQUFBTmd0c0FBQUFBQUFBQUE0QXJnQUJBQUFBQUFBQUFFSUFoZ0FCQUFBQUFBQUJBQVVBMVFBQkFBQUFBQUFDQUFZQTZRQUJBQUFBQUFBREFDUUJPZ0FCQUFBQUFBQUVBQWtCY3dBQkFBQUFBQUFGQUE0Qm13QUJBQUFBQUFBR0FBc0J3Z0FEQUFFRUNRQUFBSVFBQUFBREFBRUVDUUFCQUFvQXlRQURBQUVFQ1FBQ0FBd0Eyd0FEQUFFRUNRQURBRWdBOEFBREFBRUVDUUFFQUJJQlh3QURBQUVFQ1FBRkFCd0JmUUFEQUFFRUNRQUdBQllCcWdCREFISUFaUUJoQUhRQVpRQmtBQ0FBWWdCNUFDQUFVQUF1QUVvQUxnQWdBRThBYmdCdkFISUFhUUFnQUhjQWFRQjBBR2dBSUFCR0FHOEFiZ0IwQUVZQWJ3QnlBR2NBWlFBZ0FESUFMZ0F3QUNBQUtBQm9BSFFBZEFCd0FEb0FMd0F2QUdZQWJ3QnVBSFFBWmdCdkFISUFad0JsQUM0QWN3Qm1BQzRBYmdCbEFIUUFLUUFBUTNKbFlYUmxaQ0JpZVNCUUxrb3VJRTl1YjNKcElIZHBkR2dnUm05dWRFWnZjbWRsSURJdU1DQW9hSFIwY0RvdkwyWnZiblJtYjNKblpTNXpaaTV1WlhRcEFBQkpBR01BYndCdUFITUFBRWxqYjI1ekFBQnBBR01BYndCdUFHa0FZd0FBYVdOdmJtbGpBQUJHQUc4QWJnQjBBRVlBYndCeUFHY0FaUUFnQURJQUxnQXdBQ0FBT2dBZ0FGVUFiZ0IwQUdrQWRBQnNBR1VBWkFBeEFDQUFPZ0FnQURFQUxRQTNBQzBBTWdBd0FERUFOQUFBUm05dWRFWnZjbWRsSURJdU1DQTZJRlZ1ZEdsMGJHVmtNU0E2SURFdE55MHlNREUwQUFCVkFHNEFkQUJwQUhRQWJBQmxBR1FBTVFBQVZXNTBhWFJzWldReEFBQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREVBTGdBeEFDQUFBRlpsY25OcGIyNGdNUzR4TGpFZ0FBQnZBSEFBWlFCdUFDMEFhUUJqQUc4QWJnQnBBR01BQUc5d1pXNHRhV052Ym1sakFBQUNBQUFBQUFBQS80TUFNZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9JQUFBQUJBQUlCQWdFREFRUUJCUUVHQVFjQkNBRUpBUW9CQ3dCRUFFVUFSZ0JIQUVnQVNRRU1BUTBCRGdFUEFSQUJFUUVTQVJNQkZBRVZBUllCRndFWUFSa0JHZ0ViQVJ3QkhRRWVBUjhCSUFFaEFTSUJJd0VrQVNVQkpnRW5BU2dCS1FFcUFTc0JMQUV0QVM0Qkx3RXdBVEVCTWdFekFUUUJOUUUyQVRjQk9BRTVBVG9CT3dFOEFUMEJQZ0UvQVVBQlFRRkNBVU1CUkFGRkFVWUJSd0ZJQVVrQlNnRkxBVXdCVFFGT0FVOEJVQUZSQVZJQlV3RlVBVlVCVmdGWEFWZ0JXUUZhQVZzQlhBRmRBVjRCWHdGZ0FXRUJZZ0ZqQVdRQlpRRm1BV2NCYUFGcEFXb0Jhd0ZzQVcwQmJnRnZBWEFCY1FGeUFYTUJkQUYxQVhZQmR3RjRBWGtCZWdGN0FYd0JmUUYrQVg4QmdBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0FvQUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0FjTUJ4QUhGQWNZQnh3SElBY2tCeWdITEFjd0J6UUhPQWM4QjBBSFJBZElCMHdIVUFkVUIxZ0hYQWRnQjJRQUJNUUV5QVRNQk5BRTFBVFlCTndFNEFUa0NNVEFDTVRFQ01USUNNVE1DTVRRQ01UVUNNVFlDTVRjQ01UZ0NNVGtDTVdFQ01XSUNNV01DTVdRQ01XVUNNV1lDTWpBQ01qRUNNaklDTWpNQ01qUUNNalVDTWpZQ01qY0NNamdDTWprQ01tRUNNbUlDTW1NQ01tUUNNbVVDTW1ZQ016QUNNekVDTXpJQ016TUNNelFDTXpVQ016WUNNemNDTXpnQ016a0NNMkVDTTJJQ00yTUNNMlFDTTJVQ00yWUNOREFDTkRFQ05ESUNORE1DTkRRQ05EVUNORFlDTkRjQ05EZ0NORGtDTkdFQ05HSUNOR01DTkdRQ05HVUNOR1lDTlRBQ05URUNOVElDTlRNQ05UUUNOVFVDTlRZQ05UY0NOVGdDTlRrQ05XRUNOV0lDTldNQ05XUUNOV1VDTldZQ05qQUNOakVDTmpJQ05qTUNOalFDTmpVQ05qWUNOamNDTmpnQ05qa0NObUVDTm1JQ05tTUNObVFDTm1VQ05tWUNOekFDTnpFQ056SUNOek1DTnpRQ056VUNOellDTnpjQ056Z0NOemtDTjJFQ04ySUNOMk1DTjJRQ04yVUNOMllDT0RBQ09ERUNPRElDT0RNQ09EUUNPRFVDT0RZQ09EY0NPRGdDT0RrQ09HRUNPR0lDT0dNQ09HUUNPR1VDT0dZQ09UQUNPVEVDT1RJQ09UTUNPVFFDT1RVQ09UWUNPVGNDT1RnQ09Ua0NPV0VDT1dJQ09XTUNPV1FDT1dVQ09XWUNZVEFDWVRFQ1lUSUNZVE1DWVRRQ1lUVUNZVFlDWVRjQ1lUZ0NZVGtDWVdFQ1lXSUNZV01DWVdRQ1lXWUNZakFDWWpFQ1lqSUNZak1DWWpRQ1lqVUNZallDWWpjQ1lqZ0NZamtDWW1FQ1ltSUNZbU1DWW1RQ1ltVUNZbVlDWXpBQ1l6RUNZeklDWXpNQ1l6UUNZelVDWXpZQ1l6Y0NZemdDWXprQ1kyRUNZMklDWTJNQ1kyUUNZMlVDWTJZQ1pEQUNaREVDWkRJQ1pETUNaRFFDWkRVQ1pEWUNaRGNDWkRnQ1pEa0NaR0VDWkdJQ1pHTUNaR1FDWkdVQUFBRUFBZi8vQUE4QUFBQUFBQUFBQUFBQUFBQ3dBQ3dnc0FCVldFVlpJQ0JMdUFBT1VVdXdCbE5hV0xBMEc3QW9XV0JtSUlwVldMQUNKV0c1Q0FBSUFHTmpJMkliSVNHd0FGbXdBRU1qUkxJQUFRQkRZRUl0c0FFc3NDQmdaaTJ3QWl3Z1pDQ3d3RkN3QkNaYXNpZ0JDa05GWTBWU1cxZ2hJeUViaWxnZ3NGQlFXQ0d3UUZrYklMQTRVRmdoc0RoWldTQ3hBUXBEUldORllXU3dLRkJZSWJFQkNrTkZZMFVnc0RCUVdDR3dNRmtiSUxEQVVGZ2daaUNLaW1FZ3NBcFFXR0FiSUxBZ1VGZ2hzQXBnR3lDd05sQllJYkEyWUJ0Z1dWbFpHN0FCSzFsWkk3QUFVRmhsV1ZrdHNBTXNJRVVnc0FRbFlXUWdzQVZEVUZpd0JTTkNzQVlqUWhzaElWbXdBV0F0c0FRc0l5RWpJU0Jrc1FWaVFpQ3dCaU5Dc1FFS1EwVmpzQXBEc0FCZ1JiQURLaUVnc0FaRElJb2dpckFCSzdFd0JTV0tVVmhnVUJ0aFVsbFlJMWtoSUxCQVUxaXdBU3NiSWJCQVdTT3dBRkJZWlZrdHNBVXNzQWRESzdJQUFnQkRZRUl0c0FZc3NBY2pRaU1nc0FBalFtR3dBbUptc0FGanNBRmdzQVVxTGJBSExDQWdSU0N3QzBOanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ1JMQUJZQzJ3Q0N5eUJ3c0FRMFZDS2lHeUFBRUFRMkJDTGJBSkxMQUFReU5Fc2dBQkFFTmdRaTJ3Q2l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtJTEFnVUZnaHNBQWJzREJRV0xBZ0c3QkFXVmtqc0FCUVdHVlpzQU1sSTJGRVJMQUJZQzJ3Q3l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtzQ1JRV0xBQUc3QkFXU093QUZCWVpWbXdBeVVqWVVSRXNBRmdMYkFNTENDd0FDTkNzZ3NLQTBWWUlSc2pJVmtxSVMyd0RTeXhBZ0pGc0dSaFJDMndEaXl3QVdBZ0lMQU1RMHF3QUZCWUlMQU1JMEpac0ExRFNyQUFVbGdnc0EwalFsa3RzQThzSUxBUVltYXdBV01ndUFRQVk0b2pZYkFPUTJBZ2ltQWdzQTRqUWlNdHNCQXNTMVJZc1FSa1JGa2tzQTFsSTNndHNCRXNTMUZZUzFOWXNRUmtSRmtiSVZra3NCTmxJM2d0c0JJc3NRQVBRMVZZc1E4UFE3QUJZVUt3RHl0WnNBQkRzQUlsUXJFTUFpVkNzUTBDSlVLd0FSWWpJTEFESlZCWXNRRUFRMkN3QkNWQ2lvb2dpaU5oc0E0cUlTT3dBV0VnaWlOaHNBNHFJUnV4QVFCRFlMQUNKVUt3QWlWaHNBNHFJVm13REVOSHNBMURSMkN3QW1JZ3NBQlFXTEJBWUZsbXNBRmpJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDeEFBQVRJMFN3QVVPd0FENnlBUUVCUTJCQ0xiQVRMQUN4QUFKRlZGaXdEeU5DSUVXd0N5TkNzQW9qc0FCZ1FpQmdzQUZodFJBUUFRQU9BRUpDaW1DeEVnWXJzSElyR3lKWkxiQVVMTEVBRXlzdHNCVXNzUUVUS3kyd0ZpeXhBaE1yTGJBWExMRURFeXN0c0Jnc3NRUVRLeTJ3R1N5eEJSTXJMYkFhTExFR0V5c3RzQnNzc1FjVEt5MndIQ3l4Q0JNckxiQWRMTEVKRXlzdHNCNHNBTEFOSzdFQUFrVlVXTEFQSTBJZ1JiQUxJMEt3Q2lPd0FHQkNJR0N3QVdHMUVCQUJBQTRBUWtLS1lMRVNCaXV3Y2lzYklsa3RzQjhzc1FBZUt5MndJQ3l4QVI0ckxiQWhMTEVDSGlzdHNDSXNzUU1lS3kyd0l5eXhCQjRyTGJBa0xMRUZIaXN0c0NVc3NRWWVLeTJ3Sml5eEJ4NHJMYkFuTExFSUhpc3RzQ2dzc1FrZUt5MndLU3dnUExBQllDMndLaXdnWUxBUVlDQkRJN0FCWUVPd0FpVmhzQUZnc0NrcUlTMndLeXl3S2l1d0tpb3RzQ3dzSUNCSElDQ3dDME5qdUFRQVlpQ3dBRkJZc0VCZ1dXYXdBV05nSTJFNEl5Q0tWVmdnUnlBZ3NBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZQ05oT0JzaFdTMndMU3dBc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0xpd0FzQTByc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0x5d2dOYkFCWUMyd01Dd0FzQUZGWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqc0FFcnNBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpzQUVyc0FBV3RBQUFBQUFBUkQ0ak9MRXZBUlVxTGJBeExDQThJRWNnc0F0RFk3Z0VBR0lnc0FCUVdMQkFZRmxtc0FGallMQUFRMkU0TGJBeUxDNFhQQzJ3TXl3Z1BDQkhJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDd0FFTmhzQUZEWXpndHNEUXNzUUlBRmlVZ0xpQkhzQUFqUXJBQ0pVbUtpa2NqUnlOaElGaGlHeUZac0FFalFySXpBUUVWRkNvdHNEVXNzQUFXc0FRbHNBUWxSeU5ISTJHd0NVTXJaWW91SXlBZ1BJbzRMYkEyTExBQUZyQUVKYkFFSlNBdVJ5TkhJMkVnc0FRalFyQUpReXNnc0dCUVdDQ3dRRkZZc3dJZ0F5QWJzd0ltQXhwWlFrSWpJTEFJUXlDS0kwY2pSeU5oSTBaZ3NBUkRzQUppSUxBQVVGaXdRR0JaWnJBQlkyQWdzQUVySUlxS1lTQ3dBa05nWkNPd0EwTmhaRkJZc0FKRFlSdXdBME5nV2JBREpiQUNZaUN3QUZCWXNFQmdXV2F3QVdOaEl5QWdzQVFtSTBaaE9Cc2pzQWhEUnJBQ0piQUlRMGNqUnlOaFlDQ3dCRU93QW1JZ3NBQlFXTEJBWUZsbXNBRmpZQ01nc0FFckk3QUVRMkN3QVN1d0JTVmhzQVVsc0FKaUlMQUFVRml3UUdCWlpyQUJZN0FFSm1FZ3NBUWxZR1Fqc0FNbFlHUlFXQ0ViSXlGWkl5QWdzQVFtSTBaaE9Ga3RzRGNzc0FBV0lDQWdzQVVtSUM1SEkwY2pZU004T0Myd09DeXdBQllnc0FnalFpQWdJRVlqUjdBQkt5TmhPQzJ3T1N5d0FCYXdBeVd3QWlWSEkwY2pZYkFBVkZndUlEd2pJUnV3QWlXd0FpVkhJMGNqWVNDd0JTV3dCQ1ZISTBjalliQUdKYkFGSlVtd0FpVmh1UWdBQ0FCall5TWdXR0liSVZsanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ0l5NGpJQ0E4aWpnaklWa3RzRG9zc0FBV0lMQUlReUF1UnlOSEkyRWdZTEFnWUdhd0FtSWdzQUJRV0xCQVlGbG1zQUZqSXlBZ1BJbzRMYkE3TENNZ0xrYXdBaVZHVWxnZ1BGa3VzU3NCRkNzdHNEd3NJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UFN3aklDNUdzQUlsUmxKWUlEeFpJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UGl5d05Tc2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJMYkEvTExBMks0b2dJRHl3QkNOQ2lqZ2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJzQVJETHJBckt5MndRQ3l3QUJhd0JDV3dCQ1lnTGtjalJ5TmhzQWxES3lNZ1BDQXVJeml4S3dFVUt5MndRU3l4Q0FRbFFyQUFGckFFSmJBRUpTQXVSeU5ISTJFZ3NBUWpRckFKUXlzZ3NHQlFXQ0N3UUZGWXN3SWdBeUFic3dJbUF4cFpRa0lqSUVld0JFT3dBbUlnc0FCUVdMQkFZRmxtc0FGallDQ3dBU3NnaW9waElMQUNRMkJrSTdBRFEyRmtVRml3QWtOaEc3QURRMkJac0FNbHNBSmlJTEFBVUZpd1FHQlpackFCWTJHd0FpVkdZVGdqSUR3ak9Cc2hJQ0JHSTBld0FTc2pZVGdoV2JFckFSUXJMYkJDTExBMUt5NnhLd0VVS3kyd1F5eXdOaXNoSXlBZ1BMQUVJMElqT0xFckFSUXJzQVJETHJBckt5MndSQ3l3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckF4S2kyd1JTeXdBQlVnUjdBQUkwS3lBQUVCRlJRVExyQXhLaTJ3Uml5eEFBRVVFN0F5S2kyd1J5eXdOQ290c0Vnc3NBQVdSU01nTGlCR2lpTmhPTEVyQVJRckxiQkpMTEFJSTBLd1NDc3RzRW9zc2dBQVFTc3RzRXNzc2dBQlFTc3RzRXdzc2dFQVFTc3RzRTBzc2dFQlFTc3RzRTRzc2dBQVFpc3RzRThzc2dBQlFpc3RzRkFzc2dFQVFpc3RzRkVzc2dFQlFpc3RzRklzc2dBQVBpc3RzRk1zc2dBQlBpc3RzRlFzc2dFQVBpc3RzRlVzc2dFQlBpc3RzRllzc2dBQVFDc3RzRmNzc2dBQlFDc3RzRmdzc2dFQVFDc3RzRmtzc2dFQlFDc3RzRm9zc2dBQVF5c3RzRnNzc2dBQlF5c3RzRndzc2dFQVF5c3RzRjBzc2dFQlF5c3RzRjRzc2dBQVB5c3RzRjhzc2dBQlB5c3RzR0Fzc2dFQVB5c3RzR0Vzc2dFQlB5c3RzR0lzc0RjckxyRXJBUlFyTGJCakxMQTNLN0E3S3kyd1pDeXdOeXV3UENzdHNHVXNzQUFXc0RjcnNEMHJMYkJtTExBNEt5NnhLd0VVS3kyd1p5eXdPQ3V3T3lzdHNHZ3NzRGdyc0R3ckxiQnBMTEE0SzdBOUt5MndhaXl3T1NzdXNTc0JGQ3N0c0dzc3NEa3JzRHNyTGJCc0xMQTVLN0E4S3kyd2JTeXdPU3V3UFNzdHNHNHNzRG9yTHJFckFSUXJMYkJ2TExBNks3QTdLeTJ3Y0N5d09pdXdQQ3N0c0hFc3NEb3JzRDByTGJCeUxMTUpCQUlEUlZnaEd5TWhXVUlyc0FobHNBTWtVSGl3QVJVd0xRQkx1QURJVWxpeEFRR09XYkFCdVFnQUNBQmpjTEVBQlVLeEFBQXFzUUFGUXJFQUNDcXhBQVZDc1FBSUtyRUFCVUs1QUFBQUNTcXhBQVZDdVFBQUFBa3FzUU1BUkxFa0FZaFJXTEJBaUZpeEEyUkVzU1lCaUZGWXVnaUFBQUVFUUloalZGaXhBd0JFV1ZsWldiRUFEQ3E0QWYrRnNBU05zUUlBUkFBPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMudHRmXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy50dGZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBRHFJQUE4QUFBQUFiWHdBQVJtWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQldBQUFBQm9BQUFBY2EvQUJwRTlUTHpJQUFBRjBBQUFBUmdBQUFHQTBCbEZpWTIxaGNBQUFBYndBQUFCQ0FBQUJRZ0FQNUlsamRuUWdBQUFDQUFBQUFBb0FBQUFLQUFBQUFHWndaMjBBQUFJTUFBQUZrZ0FBQzJ5K2IrWTVaMkZ6Y0FBQUI2QUFBQUFJQUFBQUNBQUFBQkJuYkhsbUFBQUhxQUFBSzRNQUFGSVlTT1h1cm1obFlXUUFBRE1zQUFBQU1BQUFBRFlCODd0RmFHaGxZUUFBTTF3QUFBQWVBQUFBSkFhTUJBRm9iWFI0QUFBemZBQUFBR01BQUFPR21wNEFHbXh2WTJFQUFEUGdBQUFCeGdBQUFjYWp1bzlFYldGNGNBQUFOYWdBQUFBZUFBQUFJQUdjQzladVlXMWxBQUExeUFBQUFXa0FBQUo4anZZUXhYQnZjM1FBQURjMEFBQUM3QUFBQkdQdEVEUCtjSEpsY0FBQU9pQUFBQUJsQUFBQWU5MXJBNFY0bkdOZ1lHQmtBSUl6dG92T2cranpOL1d6WURRQVRQVUcvZ0FBZUp4allHSDZ4emlCZ1pXQmdZbUR5WUNCZ2FFQVFqTTJNS2d6bkFlS01yQXlNOENCQUlMSkVKRG1tc0p3NEFIRGczdk1Da0N1QjVCTUJkS01TRW9VR0JnQjlTUUo1Z0FBZUp4allHQmdab0JnR1FaR0JoQ3dBZklZd1h3V0JnVWd6UUtFUVA2RGUvLy9BMG1HLy84Vm1LRXFHUmpaR0dCTUJrWW1JTUhFZ0FvWUdZWTlBQUFiZVFkNUFBQUFBQUFBQUFBQUFBQUFBQUI0bksxV2FYUFVSaEFkN2VFVEg4RUhDVXBneEhnZHN4b3Q1aklHRm1Pa1hTL2dIT3Nya1NDSDVGMDc5OFVuZm9OK1RXdEpxc2czZmxwZXp4N1lZQ2RWVkNocSswM3JhYWI3ZFUvTEpMUWtzUmZXSXlrM1g0ckpyVTBhMm5rUzBnMmJscUw0VUtaN0llVkt5ZDhqWWtTMFdtcmZkaHdTRVlsQTFUckNFa0hzZTJScGt2R2hSemt0MjVKZU5hbXcrS1N6WkkwRjlWWjkrMm5vS01kT1Ewbk5adWpRZW1STFdtVzBHa1V5NjVLU05pM0IxVnRKV3Vibnk4eDgxUXdsZ2tnVFNXUE5NSVpIOHJNeFJpdU1WbUk3anFMSUpzdU5Ja1dpR1I1RWtVZDVMYkZQb1pRZ29HTFFES21vZkJwU1BzS1B5SW85S21pRnVHUTdLKzc3a3A5MEQ2ZXhnRVJjcDN6WmdUZVFxVXl4YzdaY0xLVmJZZHkwayswb1ZCR2VyZStFZUdCelFyMVRQU3BxR2c3Y2pzaDFaUm5DVXZrSzhpby9vZHorSVZrdG5FM0Zza2ZEV25LQTQwSHJaVUhzUzk2QjF1T0lLWEhOQkRpaU84UGpJcWo3WldjZzlLZytMdnhZZHhmTFJRZ0JzbzFsUFZVSkY4R29KR3hXa3FTTklQdFJVcjZra2xyM2lQRlRYcWNGdkNYczE2a2RmZW1NTmdsMXhzZnk5ZEN4bFJPVkhZOG1kSmJMMWFtZDFEeWExQ0JLU1dlQ3gvdzZnUElqbXVEVk5sWVRXSGswaFcybWpTUVNDclJ3TGswR3NVeGpTWk1RemFOcHZia2Jab1YyTFZxZ2lRUDEzS1AzOU9aV3VMblRkZG9PL0RQR2YxWm5ZaXJZQzdPcHFZQ3N4S2NwbHhzVWJldG5aL2huQWo5a3phTVMrVkl6ekZnOFpPdW5LQzRmVzNZVVh1dGp1L3VjWDBIZnN5ZENKZzNFMzREM2VLbE9LV0FteEl5Q1dtaWx0WTVsV2FaV00xcGtJbGZmRFdsSytiSk80MmpJTWVnYit6TEc4WDlOVDF0aVV2aCtHbWRuaDF4NjV0cVhJTk1zY3B0eFBaclRtY1YySGpxelBhZXpQTnYzZFZaZys0SE9pbXpQNjJ5SXJhMnpZYllmNm15RTdVYzZHMlY3UVF1YWNOOGhrSXNJNUFJMmtBaUVyWU5BMkY1Q0lHd1ZBbUc3Z0VEWWxoQUkyMFVFd3ZaakJNSjJDWUd3dmF4bDFmUlRXZVBZNlZnR0tFSWNHTTF4Unk1elU3bWF5aTZWY1YwME9yVWhUNUZiSmF1SzU5Uy9NdEF2SG5tREdsanpwTXRrelMyYjVDcEhWVG4rNklxV04wMmN5K0JZOWJjM3gvVTU4VkQyaS9rL0JmK3JyYW5WN0lvMWgweXVJbThFZW5LYzZOcGsxYU5ydW5LdTZ0SDEvNktpdzFxZzMwQXB4SHhKVm1TRGJ5WWtmSlNtRGRYQVZRNHhyekh2Y0Yydlc5YmNMTTYvaVJFeWorN0hmME9oMGNBOVNDdEt5bXFLdlZaZVA1YVY3aDVVd0o1Z1NZcjVNcTl2aFM5eU1pL3RGN25GL1BuSTV3RTNna0dwREZ0dDRHb0ZiOTZUbUlkTWQ0cm5ncml0S0I4a2JUek9CWWtOSFBPQWVmT2RCQ0hoUTZJMlVEdUZFemFRRjR3NUJmdWRjSWpxanJJQ2JpKzBMNktSaW0vdGloMDVvNUlKQXIvTjdnaDdmUlpLZm9zMWtQQVVGM3NhcUNxa1dUVnVHc0dsa1hKRE5mZ3dydFp0SXhrbjBGTlU3SVlWV2NWSGp5UHVPU1hIMHBkOHFJVFZvNk9mMVc2aFR1cmNYbVVVdCsrZFhnUkJ2elF4ZjNmZlRMRmZ5cnRheVFxcnRvR3BXNDBxbVd2TjR1SlZCKzdtVWZlOTQrd1RPV3VhYnJvbmJucGYwNHFiNG1CdUZrVDdOZ2RscVpBTDZ2cWd3L3JxY25NcHRIb0ZsNlM3M1FNTUN3em9kMmpGeHYvVmZSdyt6NVdxd3VnNFVtOG42c1hvc3hqOS9BUE8zMUU5QVhwNURGS3VJZVc1N3VYRXB4djNjS1pDVjNFWDY2ZjROekJycmRrWnVnYmMwSFFENWlHclZvZXVjZ1BmcWI1T2p6UzNJejBFZkt3N1Fqd0EyQVN3R0h5aU81YnhmQXBnUEo4eHh3ZjRuRGtNbXN4aHNNVWNCdHZNV1FQWVlRNkRYZVl3MkdNT2d5K1lzdzd3SlhNWWhNeGhFREdId1JQbUJBQlBtY1BnSytZdytKbzVETDVoem4yQWI1bkRJR1lPZzRRNURQWTEzUnJJM09JRjNRVnFHMVFGT2pEOWhNVTlMQTQxclE3WTMvSENzTDgzaU5rL0dNVFVIelhkSGxCLzRvV2gvbXdRVTM4eGlLbS9hcm96b1A3R0MwUDkzU0NtL21FUVU1L3BGNk9GWFA4dkk5K2xrUVBLTHpTZjgvZkUrd2NrZkVBQkFBQUFBUUFCLy84QUQzaWNuWHdMbEJ2bGxXYjlWWkpLcGZlclZQM1FXOTFTcTF2dWRrc3RxZDJ5MWJiQnVMSEJqOFkyQWtNbmtFcHNUSUFPRDVzWU95RmhsbVN5NDlDMHM1b3d5U2FNQXo1TTRHdzhURXd5YkMrZVlZYWh6dWFZSlhOOEpycytDd016T2NrZWs4Y2s0NTBrUG5TeDkvNS9sVlJxbXcyTTNWSzkvL29mOTcvM3UvZCt2emllNitNNDdtZTh6QW1jeURsUE8yeUU0MWVObElQbFlMNGN6UGI5L2ZlLzhRMWVYbjZuajd6TjhYQW5KNlQ0SmJqVEIvZTZuRHplUzlMQmRBVStTU0pXWUljVXlVWGRReGIwZVZYVDlIbXl3Qzh0WDYyU2kycXJwYXFYbGVIdExrT1UwL0EvYnlrRHZ6U3pDUGpYNGpnQ1JhaTBERC9uK0FzSFIxYU5oRkxST0NtTCtYSmxJcGR4eUJOblNlWXN2RjVkZkgyUlh6cjdlRW5UU3ZzWEYvYy92dUpaTno3THBhSXlQbVVXUU1iaFlYZ1FuOGVIOFVFczRIR3N1cTFkZit3dk41VGlYZS95ZVZ4T2g0M25iS3RHZ2xCL0JUNmlzUlZTNzc2bDhzM2xaOVQySHIra3NuOGZ0RHpyZnl3RkN6RzMxc0wrUFhYVHNCQ3R2ZGRWTnp2SHZmZE5XcDRkU2d0eVVhNmY4Ni8zOUN2aFVNRGpkQWljSFFhdXBJaURWVkd4NXlvVGcxRTVJbVlIdzZNa2IwLzdpRWdXUG5uN1Z2MmxXMDZkMGYrN2d6ODFIeml2bjVpZisrTmhzcFhjUC82dDIvbWwrdHNYU3ZOZmVuTmc0Sms3SC9qR3dQcUsvblR3MEo3WURYZEliSXc1Y2xGSWNRNFlKeHVPVXhpRTBrM0ttcXI5WmhscXJIdjBjNlNJdHhreUJmY3ltWEk3YlNoVElCTUJSeW9YR0F4bUpaSU5YaURYWGJpZ2YvY0NLV29nWGtVb0FZL2c3S1A2T1N6cHltVzVWcFFsRVpUeGRsa0w3RW45WEhkcG1uYWxzcndyeXFJalNsYVcxU2xKMHpSYXFkL1hQb0t6dFd3dEI1NWMyVHl1TTIrYXRFL3QyS2VFMW1HUXpUZjlITi9FM3VVdXU1ZW45M3BwMjhsRmJDL016b3Q4RXdaQ05jYUtiNjRjS3duR0NqVEFqL1FmV2thck0vOVcxSUcwNjdDRTdTNXdLKytsZFpENEZWVllvdVZySytvZzBIdGgwT0UvS1pBeDJoL3NDVzZsYk5GNys5bTkySjdPblhRKzhVdHczNVhuRS9SN1ZvQVBvUjg1U3haVVZWTlYzTUI4cHhNZUZOY3owS3g1a0RjMlB6TzBUMTJjekNXNUFwWTNrSXBGQTI0SGxoZFdISEpFRVVjSm0wb09NVit0VE9UdDdLdzV2K2k1KzJlYXpabmFPdjY1KzlmVllGZi81cVpZYkZPZDdLN1hZWWR2empRL2ZSU3VmMlgyNmZ2dmYzcjJLM0RMMFU4M3I1NkpGWXF4bWZydTJhbjZ6dDMxbVZpeEVETmtpeXhRMmZKYlpMUVVqVGd5dVlsd3RGeXFCZlBpd2FjT3dwOWFIVjFWdzRiUlEvMC9oY1A2WDRPcUVDenk2ZWNVenZXOVVBRExFU3d5bXNGR2tKeENvRUJvd1R0a3l6dnY2Qys4UXhhT25Kb2szOXAyWEw5MTIyMUhUZ2twUEFrWHYzRHF5RzNieUxjbWorcTNUc0l1Wjc2RDZpS0o4OEk3NkRqZ08wRDRRWUNJTVJDZ3N0OTlpMXdFd1lOWmdOMFBKMkEwUVY1TS9RajFWTURxNWJnUzl2K3FmTHEvdDhkRGNEeXJTb0pYWUNDREVVYzJuY2xWZ3RsS09WeFZ4TFFOclVNa1dxcXVJeE1EbG4xeUxCZ2tuM3pRODdBYThTMy96QmRSSDc3ZzYxa2dLZjJYdy9INGNKejQ2VVpJRVIvNTNKZjlxcjdvaTBSODVHNlY5QVkvODV3V2wxVTUzdjFGeDhPMFQyRVlqMkJBd3ZFSXAwdHhGREU1QWhXckJDZVVZRG9vOGQrV1ZGVmEzaU9wT0JGY0wybG5KSW0vUmxMUjZITGNTanNwMFhtNW9weE9HWllDRE4zMTN0ZnBzemx1RE9wUnpFZDVyTWRFdFM2a1VUaGcyb1lVcXZCWlgwM1VxdUZLTnVQSVpuTDJyQ3c2eFBRWXVhVXZMTmp0NUNLMnJmVGxua3hCR0ZtamM0M1pUTStYUzhSQjVEajVxdWFZbmlRdkgzTHdYd3Fsb0t1TzZmODZWQ3MzQ29YWlJyazJSTHpIU0NKK3d2WFFIVDkyZGVsQkwrc2JuNGg5dzVXZ0dsQ1ZORlNoTWhFdW8rQ1N4bE1ISDkzNDdsc2JIMVcxK213ZEpIYjJhL2ZVdG0rdjNmTzEyZVVYQy9VNkxZbzJORWZMQzBDSklMZEJ2OCtPTWhVdTI4R21aU3RpdnBhdktUVzVKc3ExVm9uTXZmMjJmcUswZFd1cnRYVXI0Sm1Xa0xwMC9JbExsNHdUR2lJR2pyUE1CNW1MYzROUWJqS2hSTjFVVnROWVdURkJaQlN4Q2t5RjRFUXVtNVpoVXNCV0NMSXR1VGg3c0xoaCsrTCs1Zk5RMVFJcHFyaFJXNDFtczRGTnVhYVdmSERML2tVVkxpMFU2dGhBMVBITkkwMnJick9idW8wRXl3VG1SaEZuaEtIYmlvYStSTjNXRC9lRm1Hd0Vhd3JVSUNvSDB4bEhKRnFHV1lXVG9OWWdOUlhxb0piaytQSjVIRXMrdDN5KzBSUWNJM0VzRHpSZU1TNHZuNGZoVTVzTlBoZU9qemlNZXFCZXNabTZHMFEyRDVoQVkyaERzNDZuUUhXUDIwYXhvQUY1eW9BSHFaVGk3YVQ0QTFLUTN2MjFKS1JVZGQrKzVUK1hKR3MvSzlDS1BQUnpOdGJiUS91WlFETkEwRUhZMlZTR3VWb0h0VnBWb0ZoUVFlbFNqYzBBNkpWQy9Zd0UxYjlhamt0bjZnVk45L1QwOFV0OVBleGwwT3ZTcjdESnY1SmdEQUFYNmJJa2FmRHlqcjBaZ1BiSnRKK2g1N0l3ZWhrUmRGMFU5WWdEa1ZhbFZxMkJIaG5sY1lxUTR0d0J0VlFhNjQzMUNzODlyOXhNM2xsK0puQmorUEJSM3U4czFZVFVnYmxTS1ptdHh3N0YxTnYycVljOU4yNVh2WnZYSnVjYW14aStNK1praEl0eFExd1I5ZGR3SVIzdmxkM1VmdENwS2JlMUY3UTNpZ01KTWxWakEwcWx5dzREa2JFSk5qdS9oQzNEbGtmK21DcXFGaDZUSWoxN25tL3lTK3dxRFBnUzc0OS9ORTV2WW4rYW9XVFlHUFlKY1poRC9UQ0dZVFluU1pKRVJlSW5BQVduaVlROUE1WEs1QnM0QnZ6L2NSVHRkdjNmL0wzQjdWV1BseHpTaHlhM2ZmM3VMV3ZYWFh1OUVCZUtkbEgvUTYrbnVqM1k2eWN1L2VDMnlidS9uc2tldVhaeW02SFQzdnV2L0d2UUIvdWczMHR1UW5WU3VaUWt0VkhTSUtVRWNZaEtyVnFtYi9RVEdBYW1yQ0tpd2laZFpnenV5SzBUY2FBY1lqUWl4b1dJbU11THFMaWdjdE1rVnhraGRMZk9WMnY1VVNMMWgzMmVSK0l4eDhDMWU2NGRzTWRpajdoZGNqemd2aTlpcDMxVGNtenpSK055d0w5aGNPUGF1QnlLMlFpcFh6V3cwUitRNDFIL05rZkpqbmZaTjlrajkzc0M1RzlDS1hGak5ONjhmckoyZlRNUjNTakdaVytmWXpMcmh6N05wSVpzY1hqS25aM0pwZk5mc05rZGR2dU5jbHdKQ2dGaDFtWmZHRW9WTm1YZDhLcTRiU2lWaWN1UmhEODdhZStqWThEREVLRlBGWU14Q0VsMk9nYmxFc2pDQ0NHRHdieWNFWldvaitUeVFqWkQ1d0xmM0N0SmUvWERKSE5Kc1c5MStuTER6bjF3NWdWK1NWcCtVU0xIait1ZW8wTDArZkJ3d0JjbUFla0ZOQXBpVzJlNHFYWENXWmZrc2x4NGZTQ2Rpc1BVa3lQQmdOZGo1MFJxYU9TZ2FheGdFaENZZUdYOGdMVzJHL3RvZkF6enBYdW8xMEUzUWdybm5pVDRKSFFnejlIemdCMDE2cFowNmlCMDFRTHEwS21CQ0lwRU5CVUpxMFhZZkQ5OHpQZWpWNG50aFJwWTM2N1JTVTYrd0U2eTExcXdRdytYZ3JtM21tS0h3aUJNUGpmRGdpQ0MwVHJwdExvS0I5T2t5aHN6Y01EWTVneGtSWjU0d1dtYnN6bG5KV3h0czNFTWozN0NZTU5uS05yNjFXeWRtaTdvZkJ3VGlmeGxvd243K2prMkF5a0dDOVh4SnNQV2F4UmI4aDE5UzBBOXovTk5mWjZ6NkdPOFRwaGRJT2hjVS9YYXhndWRlMWdaa25HUFBvK2xySHdQWVRnN1RSYklBdnFqN0I2bWw1TndUeG93N2pqbzVkSGhYQ2JFby8yRGJyR1Zva2tDaXNvUHFBZ1ZGY3l4TWNLUUEyZDB6b0N4N1FmOFlOTzhmZlljV1hJNWhaMkM3TlpQdUdUQlYvVzZXc1JPNUFUWnlicnNXcnJoYzZGVTBEM2pkMTF5K2YydXdqT0ZYcExRYjdEb0xVdjh3UUh5NHp3dGlRN1Q1Z1N6SWdFVEJkNEZzMm5rSWlBcGNJamhDT0NqUjZWdDN5Z0U0Rmx2MnlkU3lDZy9SbXBScGNIem4zdE1ENmV1dmJsbjV0aldiZmt2Mzg4dkhkUERtUzAzOVc0K2R0MFdPS2JQbDJqZjJkdCtrbEpUSk5LNmRLbUZIY3czNlE2T0JtbGprL2E5UkJFVkVZYUQzUzJrY0VzSHJ2dGVXcSt3UkFDNXRIRHM0RFkyZkxERHJhZ0Q4Nm1JbUJmek9JUllJZzRpYmxmNG5WN29LODhLdnhNZVU5cnVLOVJkblhtT2JHejduWlBzZUVVNTRjdkxxVUd6b0JzQWFPVkZzN1JMTTYyVytkY3AwWEt5N1Y5VFhSQUVsT1U4SFE5SkJoNk1NL3VmUmkwT0pzZGVCZzFVdHByR2lTcEt6RmEzVHovbmMyL1ZmNzZWWElRRG4zdjVJSHdMS2REcWNCck9sT1RObW1hY2R2TmZjdnM2OG0zNk96MGczM0xBMCszdm1MTjlzQ3hId1hjYkk2YkR3M3QrZStyVWIwL3BKOVJNYm1aZ2RjRGk4ZUNGNjA0UHBHZUdWbnNzZmRZTGR0NTVPcGVnYlNQWUxEUmtZcmJDWWxacE5GWGxCZ21EdWtHekYrY3hpZ1U2dmtwZTNyODRza1k2QTdoUS81Zll3ZG5nWTFzRUczSHdjcnlsYWEySWtGcmNYd3JzSHUvcktTR3VMSTJYWncvdXVSZWtEeUFBM2dBV3YydnNJcUJsbmFmNzVKWDF5SXRac3dvSytCVU9CRnRaNDkzSE5PMU4rdWFiTDJrSUdqcnYxRFRqZlkxTEpXcEZ1L3lWa09tdnROOUR4NDIraFJYZGJPaU4yWU5ZTkwvRXltdzBRU1B1dWJlcnptNHVBWFdXUFJTVGhFc0tXSHdIZXRKVisrWGxYbnJvK2dOL1BqdzEzTHRJVm5lL0FURG5mWE9CNUVSMS82SzI4bDFDdTg0QytLVitrQVd2QzgwUHhhQWtLNVJGSlpzZkxDdGl0b2I2NUp3Ulh1T2JiRVBEQXhyN1o2bDNFdENzOC9SQUtzRHNPSUFiUlV3UzJROHFJTzhuMlRHWXNiVXhVcGttNkp5WUdJL01xYVhZb1ptUzU5QWhUMm5tVUt6VWZYamlTQk1rUVVoZDhhSjUrRWdUNytxU2NRRTBwUXZhQlpxU3RZdUZFVVc3R1VFRVNNK3NDSnBPOUlDc3o0cnNXYWY1ck9HbEM4RThkb0pHd3kzNEpMTWUyaFdlZGExOEZqb0JQWHV3MS9PYTVXa1djN3RTdmUyZGV0c1ZHdjFrTmcrcWJUeVAxZGJnZnFwUFlDenpZTi9YY091NGE3anRYSEM5Yjh2bWpZMzZWR1c4T0JUaEhEUTRBZ29HcE1qd2c4dk1Xb0hZVS9Hbk9nZU0yUVFkR05RL05HU0FyaDBpRDVFTjF6cVNsaGtneUVLZnE5anZqUkxPUk92QnM4TTROY2g5dzNHWUpDQThsMlJxN0lwb3l3Q1VYK0VKZHVDSjB5ZmcyZmp3czRCaDZQMmxFbjNhc0JlMGoxd1lQeWRvNXlmS0NOanlnRndRZUduZ1lBbUs1SHIzZ2laWnNZOUlFVmMvWXArZVNJZ3FQZHZsU2k4djJNT21VSzdRZXdqbDFFOGJVWkZ1elVmTmJJbFo2Y3R0ajdReXBvczlaNDBpV1dKSHk4OUFpUnlOWDF0a3lVMWpVLzcxbmtqQWpPSFpMNCt2bThpRFNnakEwbmFjL1g4WmxUWWhvVkZSVzN2K1N3WVdoYjVCSE9wejJhbFBsallOa1pnMnJVL053Sis5L0MvY3ZuZmZRb01ESmliazlqR1Z3Q3lQcHY4aDJwenZHTUg0amx5SE9KbmFIQ1VhQ2J0WnJFSk9nMzRJWWxnbkMwNHpPSnRLRUlCSkdrRE15MnFwald6SlhFay9RZWF3Q1NWVmIrQ1ppM0RwQkQzUGRmVVhpK01WdVFuc3IvRlZ1ZjRJSFd2NzVXTnQ5cGM0VWEzVmVYVEQySWxLTFo4enI2MjBmV2VZc3hueENZSXo2dHZiVzBDYzY3ZzVZSUM0bFlKQmUvcVFQMjRMM094QXVGdm8zZXU3NW5JNXdkbU9lTTdHZENhTlB4TU1EQmJSaTlEUGFSaWt4OG5PNHVINnZNcHgzVEVJZkY3c3hDRHNMQ2JNZEFXV29tSFhHZEgwVHB6T3hnWHd2WGFleGVtQ2FXSFFBbWhZZm9YTVdhQUxWZnJGTjd2QlRLYzhONHd1K05FZXdaQjNqQ2xrSFBBOXFOU294YUxPS2ZhcGloTUtnNzZON1dDT3R2Tkw3endOOCtESTAzM05admlPcTlCMlhYVkhlMXdwVHJKelRzNEQ5WTNndUlhQ1BxOEx0VHFiQi9nZm9Qd2dxaWo2QWFldFNCYVdyOGJHWTZ0UmtOQTdRQ3pKNGo0NEV6U1dLMEsvL09zWWh1VHFvRk1TTEFjQW1sRUI2YzlXY3VCUzA2aXBZazhRak1tQTFzeUNqc3lEMGdTRWhOQUZFRXN1UHpoS0VMblVpYVp1SFU4VlZXZndrdHVudUFrWlg3dWx2TFhyblA0ZVBRZDJJSm9jVStjY1BuZkpuUkEyZUxhVlMrVXQ2cFZPV3ZxWTVUcEZtOERHR3J5Y05EaEQwRXFXV2VDWHNMMWdrT0M3YTJ6WWMzYVdJeVh3SVAzUTlBOCtoZU5LaXZodGVRWmovYzdUUVRmMU00Z01RMW1HaHlhcTZjNHVLZDd3QUlqbktYN2UyQzZwRDl5QVluYmtWSHVucXg2c1RML2JadFFmRkF2R0VyUEVzbHM4ZFFSS3d3YlJIV3dUTFE2clMzZG9qUGNDaldHRnVBeVUxeE5tMkU1SjJBd3hhd2cxSGlQM1VSYVh4Rk9rbVBFTzNiU3BCckpYMjNUVGtQY2o0SW5Pb3FrcGdLdWE4WTdjZTgvaU9wVENkWXYzM0R2aTFiZkU1ZG1ETUZuckJka3kxOEIzeEg0VWFEOUtoR3BlNWtNYVU5U2ptdkZCV2o4ZUpiZnJmc0o2R3NjSSsxN0RnUUlkaWVremN0SFE5MTNZUWM0T0doL01xaGtmQnIyNHJyNjFnU1ozbm5iYURkbVE3WVB3QjdPYXlyM2g2QzVSd0FENHdhS1hiVEFxaVA5OGJxZWQ0VDhNdEEzYTRla0tZQ1htWWFFcU1WS0dIaFlLMWJBUnpkWlNxN1dVVXkxemlkWWwyNGt0Z2hjQjZCWFFTd1FnVEJiVE1qSjZ6UGwwclp5clpHc0FZUG5teDI0SmJIdjVpU1RaR3RDZkQ1TkM0TTJiLytEZVBYTUhQdmxDOVQwdS9FcEE2ejJUQVNrdEhaaTg1eVlWRXpuYkRrL2V0VmRkUDZBKzhtZjRYa2ZiTnpidEpWbzB3RDlSc1BXbXpYU3NzSm5Rb1RYamcvRVUwMmFhdXFHZFVMN01qbjBZWEFsRmFSOFVHekpjK2Z1dzRmdmpVb1l0LzMrNDlJUGpTcWgxaC9NQXowclVWdmhjVGlwYm1Ha0N2eFNFR1NQaitacUdiZ0UxTnVDSnErQzFZeG9SUS9iemVHajFOZnBCTWlwUWgvR0JWTXhMWmEyVXNDV0p6NWJOWURpaTRURGhWNzZrc09sYml4cllsQnd2ZmV5NlRlTURrdVJRdHU5NWROUG1MOXl5T1JnVVBJWFJtZXZWUjJqZ1NYT0ZZbkU1NGFQV2xsOUtWOWF2cndRRG5zSys3UnNBWUNhVGptaGp6YVpTUm1VUktJY3ZJY2RqSVJlMTRrYmVLTVAvTnk1TmZmS0JUSytBT3FWT1dKQzJDaFloQW41TTFJakZvdUxObzBGVEFMR1FyWUlnaUZILzNNYVJ6NHdVaXh0dURjWGxYbjlEZjBUL1YzSm9PaUIvWG4vMVliS1dYeUxCV3plTWpCU1BGRGZPK1hya2VHU0QvZ2dKa0tQVHZxZy8vaVA5bFQ4Z2F5MnhBYlI1b09zZHBxNWtaczVxMmpvbXpScFQ2S04rZDdiZlMrMDZxa1NmVFJtMWdWSzBUUkNxSWJOcDNOZWMvWnNxSXlQck5xeHk5OUxkOVBpYThSVHBvZnZUZy9vNWVpeWtiSUhKOWZzblIyL2RQSHZOTGFQc1lHakgrbzBiTm03VGw5bmhKMjQzVHF6QUpSN0VGd1l1QVJrTkk0VkRTVmV5SUtTVXlXRHhZMzd3aW1xTjQ3bE1ma3k0TEphRk1oSEt0V3lycFdxdEZwanZSemVpK21GNFpnVmZ3VTd6TVM2enoyUWprTXJnSzBiRzhHVXNPVUFSc2Q1QUM4QzFZMUhZZjZ2aDNZT1VtME5qOGFKY1pXWWUwOXRWNHhRQ2dZellRVFcxQ2w0Rkg2YTJxbC9SNVBpcUd0MXZOclJRSURkSzkxZlZoRlN6TVg2OS82QVVsK3YrNjhjeGVBR0g5VVl6RUpvcEdrZm44VUozbXh6VWozQ0pScHNBbytYRnRGSUxwbXVnbWFGVFdpMXlFZnBsSHJONjlKQWRYS0VNdDBodFE5aDRtQldsc3R2cDVNV25zUkE4b1oramh5dmpSdGR3dTJIKzd0eWNYNWtuRjVXb1EzUmtITEFaSmFJakFhNStSb3dxQ2JES1JFUTdYS3ZtY0piWEdrSStoL21VSEd5RVdrN3h3YVNxS2dsaG1sUnlIUzdJam11alVXL1VOUkswTzF3K3hSSHVUWWwxbDRPRXBHM2V3V3BnYXZYV1J3cThFaytzSHU4bkpKa0llcjMyeU5XRUNHNUhXRmp6Y25hTlhhZzZCVWtNU05GQWgxQlNEUHV6a3MyblJKemdsWVd1dW9aa1hJbXFJSG1qZDZTaVYwMUZlc1J3SWVFdnBvZmNJVyt2UzFZY2RyZFhEUEhodTF4Smo1TTRoSWpYNFk0S3VXNGZ6OTNoMm9BaXdIaWtnbWFlUDNNYjhzZ3cvZGkyQlhEaUJ5b1pVeW1DRDdSOWRxdk5Zbm1KUERmQ2pYRmxyZ2FZZEpvYlhKOXBySjJhckU2VVZvOFdoNGR5QTVsVUl0YlhZN1Z0QWFhVWE1YVAvVU1lbTNaUFl4eVFEM0RRWlNHdjlJK1RMdk5qTzIxVTFrY3ViNGZVRFhqczc3UGZBVUxnb2x4eG4xb3dDblhhMzV3MUh2QitQTE1nbXJTMDNkaDJnRFVqWXJCOTFMZTQxZGpHbkI5VWQzaTVYckFmcnU4bCttU2ZnL3E0Tkoxa0JtK0ROSVBMRWkybUl4cm1XMkhRU00vSThaNCt2dG5YRTE0K0VPYnJoa01aMWsvVDFPYldNS1oyOURmRDRkT0dBMG5hOGxNR2ZkWEg4aVp5bGtaV1lXNk5rQW85Z3BlRGwwS2p5RWJreGp6Q0JQNElvTkdTakhFWnVVVDNZS3Vmb3lFYmN3KzJNTkJ4dWRXUzR5cHM5WG0yTlkvSmdoeHY2MDlxNHdmYi9NUjJQSnVxUyt5QUhLMFJQV0wrRXVEeXlHOVBsUXdteVFNbkh6QVlKZkRTVTBlZ2VJMDJmKzZHQjhDZE9JSDdjRUk5WXJ3dlROK0hPUTBQRCs4TFVQVk1vMXVpUkJqenA2NC9xejlMVHNEK0xQaVZUOVgxNThndVMxMWRIYzVWUGdpT25ZeThLOUNFS0RMSXZ6a242SGVCUkMxMDJ6V3YxZDhPcHNQQkdpbFg4alVseUFBa1BtNnlxTUJjVVQyZ0lvZk1HdC9GZklMZll6YzRNcDJVWTdDc2xHdmxZSmkvRkE0dk84TE1Wd1ZCZ0gwOHA3RVVENU01bHMrU3VSVG9DOWYzY3VtK3FJdktYQ21xTkFnTjdpSFE5aEdNNlZVVm1ra0hOVHhLMGdESUV6U3VsOU5xYytYeVhPM1dPKys4RmZjK1VzVzk4dmg0T1Q0OVBEeE43cU9iT0p6Z20rdW5wdFkvK09TRHhrWmR1MlB0eE9yVkUvaUJYYzdLeDBMOEZHVTYwVXlNT2FqaHBJSERTam5DY3RiVUNOQUlBUkZveW5EK1NGTmxaSXpwRzBzWVVZT0cwenpobVp2V0RiN3F3K0Z2TlBlc0gvelV6UzY2MzIyM0F6Q1dJdU9EeUZsQnBLbVRCajlOc3VBdUhiN2dPS0Y3RG1lMmZiUlAvQmJpMCs5NlZMWDV0Ny9jNE9HNEQ4ZGxOZm1uNW1jbE0vYmZ3NHZ0SVBZUHo0dDl2M3F0Wk1WMlpDOElPZ3JHSitSdWowODJreGZsTE1aTmNwVjJ2cGU4OVByaTR2NlVYMEE5TnlhUTNVWldkL0gxUlVHQStVSEcvS245bzJZYTF5d2Y1Qkh6ek03VHNWNkdQdzFxUjFrMitTeGxwSGVBbU5PYytxT0N6VVo1VmlvRFpXcGtoNHJlQk9pWkU1VFUwU0p6eU9Bd3BiN2JGMko1QzQrcjdZY0YwNE5sNUdQWDZEY21FV2t1RkhQdytJMTRHVENucWhveE5PU2xmSTI4QzVnL0NCWnBIYmNEKy9mNjlhWEJXTmpGZUhXTWppSGFEWkpGTGYyK1oveEdWaVlEU3BVaXhackNVc1pVMitGNXN0UGxSdjZGZm80eExNZ0M0MlBvODkzSEIwSzlDWms0aUJhTys5MisvckJnc3pPU0hXV2U4Uzh3NWtXTDhTbllnV1k5bUJUaUlUbEJTRHppNlhOY3BPdzBrakJrS1VFeGNwN2J3dHE2ZmV1bVZRRW5sYVV3Mk5WS2ViQmNWYUxVMFdIdG15WlZnR2tPeXlHcEd2azZ2QWR1clU0YnZRU0hvZ051bnFqWmFVRDNWVVEvajVCTXREWThOZFh5eDhDK3RSSWtudHJkWC9UM3c4RUkyQmV2Sk5CRyticXZKSXNUOXhhbXBzaGZhb3pXY0J0djl3eFBQVlZ2OWNUbG1MK1YyQjFQQ1AxRmVsQ2MwSDhZSVBGaFgvZlpaQ0RjVzZnL05mVkhkQjZoYk5xaDdYSFFrN3RBTm5kZEx4R2UwaWFOdHVaSDdTd1hXTUl6UnFNTlprMnRLaVo0azRPVGh3dEd1dzJ1am1pMEdoa1RXN0tzc2J0dTkwUzlRYnVQOU1WbG44ZmZWeXNiN2FPOVVEb2NUZldJakhvVGpxMFpOYTlCMHhXajVhMGRRdHhzOHk0SEFkOVNjSUszbWhEZHZLMXN0SlEyZE9LZmlSUE9VZklOdEdtMGN5M3VNL3VndGVQRHhVZ1ErekNkWXJmc1UveXpRS2NVNHFINTdtTTBkTWkwWTR3WFZEak85dnRFYXUwVWl2b1ExOHJyUTZQRklVQ3hNY0IrQVErQ1oyZUh1RnVEZHprK3dMN0I1a0l0OSt6djIrV1gyTjFHOHVQeUxXZk5MUWtkZm9nd2lDcERaUUY0YUJmWGp1M1JlRGZhOElESFlmQ09BZXRBNTJGNmpXYk5LaFBubnpxSWlQblh1NlkwZnVuZ0xLVzNxck9ocVdGVkhiYnc4SUx0dFNCbUdXblRMcklTeU1MVXJpa2tMODlTOHBvR0lqYmMxcm5kY1ZWTHJGYk1seWVxZGlYYmpxc3UzUEFBTG1VNVJRN0MxeEU0b05GYVRUdHlTdFhhY2RWMmZnM0xDN0U0YlJoYWhRdE13S3dtQ1pxSk1uSk9NT1lEeFVIM2xGb0llZWhLRWYzY3BVdWFXb0tQWnNTU09TTTNvS0ROOGJBMU00cUlaZUY4UzFNd1NtMkRuS2ZoTHcrU1F5OVN4VjB2NkI3b09WeCtveGJxTkc1ZnFPTTZHb3pWNkVLR2NneXlVRzZ5ejJ2bUhDSmlOTm5XeEdNa2w4ZHRnQ0IxTzRlR0RkZlhGRjBPMVJOYU94d2M4YWgyOGZxYkhqOUw1ZzRzZ0YxYkZGSm5IOSt6d3dHWFI0TERhME1lMVNZVjRBbjlnWVVEK3hmaEJzNGEydzNRZkljY2xJenhseU0rM2s4dzBHS2EwRk8vUFVYalRqUUNaWkNqaE5TcEk1TUxuN2s3bGZLTUhIM2crT1NSNnloUU5mUXptSENZT1FxWDQwWlJQNC9ra3oxQnYyajRKdGc2T1QySUJEOHFKSWlpZWNQNDRHdk4ySm1RSWdURTlaZHgyZDdDSUczTExzZi94NUhtMXNHY0l6SXhsSHJXOEMyVy8xbHdpc0l2TGtVU1pBRUdMMDd1YXphS1J3dERqbWhqYWt1czRlbndqbFFxNytZNnEzWThCK09PQ0k0WlhSMG5takdQMlAxV0xoYWJoVVphd25LUGFIS0V6T2xQTTJlbkFQemp0bHZHalZpNm1jTWdhZmdzc01oMko0TngyZjAyZ2RXWFpVcmE5NXQ1RXFOOXpBL0gyTDdEM29sWGtTQ3U2TGhvS1oyejNNOXlBZGJ5eTBHNit1dWlacFlQVHhCTC8zWDR4R25XSWNaMTB5Y3dZMTVwR2Q0T0V5TWJMTlB1WlRGaHVxRzhLY1JBZ2tXWFcrUEo3d2N0bDlSWFZFMDErUEZRbjc4QytWMEw5UitURFZ0SUtUaVVEc0JQVk1VMktjZFlNRkJsYnB5SW5BRTVUVDIzVVlKM2txalBTU09vbytkc0FpWHBvQk0zSEgvc3poTE0yZmw2b1hUbll4Rit5Vll2MkRRa2cydDhldXF2a2FwVFFwK09PWmgzbnd3ZHFCY0s5UU9oazNlWEdIMEgrNldkRTJuM214R292cWhaZWY3SVpIYWV6cVJEVnJ4cDhodU11bVlOV3JIU1RTRytCQXBsK1psNkFma0prUjJNT0t4N0FJWmliZEM1dlVqQkp4TGJNTGZ4dk9DeXJra2dSb1NhT2xoUU9BbEVMNXpjTUQzMCt1ZFBYdmdxdnpTOTRlU0Y2SU5mdlhEeTg2OXpWbjlkUVgrVjhlS3lBSUpCR1dhcHRvWk5IalBzV1RMSG9uaXFFYzFUcVE1c1dVNTIyYXM0bEJkZ3ZFZ1dLUWNVVTdHSm5ZTmd3eWFrS05GQzZkZi83Mzh3OW15UjVvTS9CaTF3bm5JdnBOZWN3L3A5YkpjOFlmTmwrcUlzbi9PZitSZWh6a1Y0UjU3NTlBd3haUkR4S0xBRDhqRk5HaVEvU2tTQ2tielNOSytJMUVnVDhxZFAxYWVtTGczc214bjQ2S2FiUmRIWEkxNktrWGg4ZDBLL1VDTGxpY1VKNmY1TlIzZjgrTWtkSk1vdjFRR3FYQnlZMlRkdzI2WTV3UmtOT0grVDJKa0E1S3IvZkdLaFBESGgrUlRjK3VTUGQ1QkF0eS91N09na0pCbUpDc2xXNkdvd2xVV1h6VDJMbndmUGViZ0lsK0NHVWNmbWtyMXkwRXY1SU1Sd2huQ2xVdFZtYUNTYStNM2lHWHUwVk1NREpFWHdPUXpZOXFXbG1WSDlueWhCaWY5VXBxQVZQNzc4NHViWE4yZkFjaFdFRk15RWNINzRNM3VhS3V3OWNQTFY0SFR1NU1hWmhoRGV0UXQzVCthbUwrY1krcnY5WnNIeVRySU9TM2xBdXVsZmJ0cHh6N3R2M1NPa2pyOTIvUGhyK2pkVjFYYmZUbFhkZVovcEg5RjFGRzVqVFZPRVVwdUZsWEdHZE5CaytJYkphK0d3WGdxRGgvVTVNKzVraEJ0VVZHZDBoUVRHbkRxK0Y4YlpvM1M5bE5zaHNEeU9FaVJWdXdtVHlTQmJEa2JtK25yMEgzMmNERDM4M05uSEgvb1lDZWo3Zm42dTJvQXk5UHRJWWQrQjhNdVBQSDUySnduODhNSzU0Y1BYR0hFZDBFOUxaZzZSSnl2Vzd0QTVIUlR6UVhOaW80Ry9oWHBKR0lvQ2JVS3h3aVNBVXBqWGJMV09zVVpIQTBCQi9jaENYUU9QcUx2dlhWZmk2Z3gyMWw1YTFqZG1VSnl1b0xkSm1iRnhxZStKaXpXTkdLR1I1MlhKaWs2ZVJxQWN2eDVEZGpHSHA0aEdoR1FDb0V1TitSd3A2bVVpcG42NE1UUUhHR1JpMVdBajE1ZzVxNzk1RmtRSjRDbmh0aVczSHNiRnZ2VjkyZVMyNVBqQzdPTm56ejQrdXpDKzBsOE9VM21JUmlSbUsyZytKczI0OWpSYWlISUJ0a2xETTNsRzhFblMzdVZuOWtvYUkxSnJxcVQvUk5JMGlmUkpHclBqOWl2NEZNalA2T0lwV2RZWktzYUh4WTRCM0drc0hjMzQ3UEJoNUVJcUEyOGIrVUpqalErSmhodklWb2FuOHc0eEp6aDRNWmNIaHpWSnFpR3lxZThPLzVRL2N0V2YvZFM3SlJlOVRiNUJqazNldnlRSi9qMzgwbzM2ZHdlL01waDdWSTE5ZisrMVpQSXEvZCt1YXY0WE5lTVlKLzJXZlBVYWVFL1NrRFdLNUFnTVJWa3UxUnE4RVVjYkpma2NlTFVUY0lhaGM0Qk5TbFFHRXoyUkgrVzFOWHZXU0FGQitHblVJY1lWNzhpYU5TTmVKUzQ2b2o4VmhJQmtYcVFIZlBOOXJxNThsRy9TTTV4aDY4aXZvSjRqZEUzYmFORnY4RUpaVlgwMnFxR2dneHBPVUZSMEpZK1lCdzhWbmZyZmZHWkRmV1E0bzdnVFRra2RHazd6L1RiWjVoZEVQcGJidFgyd1IxUmQ0eHRuY0VUcTFSdXJIeGxOUk56cDZGQlBiMjkxYm5XY1Yrd1JaOWdYVlh5RjNzeGd6eXJQOXZHTnkxZXIzYm8weVpXNXpkeGUxS1c3cmxzL1dSeHdHYnJVSUtxQ0lvQUtqWklNakJ2c0dKeGJvWU13THNjY3hwbkJ5ODR3RHUzMGVIRHJhSC9jdStNVE83engvalZERlNTNzlobndBeVo2NUVYTFB2bUdRUjdHQTVQSFc5N2hIWjd3akU5UGozc3lVOWRSUHE4SFFRa05OMnRvOVBHSWhWM2d5TloxWkpuN1dUUFdqVDVOVmt3U1pzOHpZeUEvTUtuS3RURVlHSlkveHFVcm1sWjY0anVPcUtiMWpxWk9QcEVjVTlXVDN4SlVkVFQxeExIa1dJbW03ODY4SnFDSno3MzBVazU5N1l5ZzVwNS9QdGVPY3hwcjgweDdYNktKUEZ3UEJGcWpwbEJYcDBvV1RodzZwSis3NjZZSGp3Q0ViczdjLzh6VDc3d2pwT2k1dlFDcjRReHlzTHJMbE5wcm10UEJQQUVsb0JERXlTZjFlZnhqNUNtMmQ1SmhJY1BHdEovckI4Y1FGN2xYc3VBQWF2aXhhTDNPbXV6T2V3RG9lRUY5NHhKdVUxTmkvOUNudS9XV2l3c3h2UlgydWFrZEM1WnMwUkJNUlg0Z0s1YzR1blJOeGlWc0owamhIejZyUGFuLzdLblhTRTc3enRIWmcxQ0p6LzZEL3FNVFQ1SElrNnArL3JXajMxRVB6bHBsMTBWWm9WbVUzVlJNaVNBeENXTmhKUnVXUDhwRHVTREM3UmZBMWd4QnFDK1JqVXZxUjU3OHg4TmYvTW1qNm9XVDFJRXVHQ0hTSmYybGx3Ny80NU1mVVIvOXlSZFBYbURPdG5XOUMzdDNHdm9peVByY29Gb3lYbnl3SFNsbHhvRHlySEM5cEQ2UG9id0ZkSXNSblE3SDY3ak9UNk54MGt2Nk9ZcXVXMnlaWTZGdWpja2lMejJPSFBpd2krb05rNy9SV1ZTUXBsTHJFQnVrdlBWdFVQaHFNYWsza3NVaWorekJhejRaQ0w3MUJDNG84YWhINFdTU3p5WGh2THJucXRZUExMa1VqeGwvbDNoYTFnVG9UcFl4VTcvNjk3bFZkMm1MNEJiOVdQOWI3VThXRHo3M0h6ZDMyZDhJWGY4VmxkM1VGNmtwVVp2Q1FtczA0cmFPVkFmQ1FYc1VnM1BrYURnOFNIeGJqcTliUHpNL3MzN2Q4UzNFTjZtZjk5dzlXUm9SRkVueTM1ZEl2dlUzTzhjcWxiR2RyN3laVE55M2ZBdS8vZkRwNDFzR2toOTRYYno1UVh2VVRuY2FxK0lwVWNqSSszVnlEMTZ6N1RCb3lKbEgvbVcrVmdhelRSL1dLQzFIdzhBelVsZTc5U2V5Y253d1FsQ1hvTi9yUmlLb2pmMFFBVGdGT0ZhbVB3Zmw0UFRRTkJaN1E2T01PVS9UYW43d01pMFVLS05NTTQ2SDA3YTdUTEU5dnQwWjZ2RDZ3T0JBWi9XY2FLeWQ2MXFxb2xDK2NOcFl0OWJaYnVXL2hHSzBmQkMrSnpGZmhubGw4NXRmZ2l2blRUSHJMR1V6MXJOMTZ5eTJ2aWljRnNONStFdUQ0SkxpSmZVUy9MVmhGMDBJYzVaY05PTUk0MHFGTWE3R1RZUHRVdFpIcmw2L2RuSmlkWEZvSUJYcllaeGhxU3Q1MWJXNnkvWjd6ZytzdUU0ZW9yRDZEYmJVSzBnMytrOW9PSWdGWXd5Uzl2SXIxanZlTUxBNEJkK2JMV3ZCTnRPSVVjcHk1ZzNyVlFiV096bHBITGRlNUYzVFlSS3VNRXpNRndCZGsrRWZ4SVgreTErRTd4M2s0aHRUOGRqYW1KQ0NNd040bnYvZnZvamhFWlJLSmV2OHRUR3VqOGs5bFBpcW1VWENIOGM0cDN2TU5ZSDA1elF1YWt3Ym1yeXdKdVVnaHFDT2ZqZnlGeW12RGZ6SndUS3VGekdqYVJwZENVNTJQUW5iYllmMFlkWlhUUmhodGtSODIySE53bTN2SG11WUIrYTRYb0gzYjQ1WDljcmNmLzN6ZEtoK3ZXdHFhdGZVU3BJMzQ1Sk40VFdMdnBVb0Q4bGo4T1VBWllPK0JWdU5ESkdhd28rcCtoT2dCeEQwNGxvUUNvZDF6emZockhuQ2F2L3dGMnhrNkJ2ODhackwvVGhHMllaSmhjc2ZjRVZtQzhEY3pIUGJVUDdONWFqYjZLbVMyaDNuN29YNTR6VjVBOGdGQ0ZySkFjZ2R5QXFwVXIzUVFpckFmRW1PdHdwMXdDaGFvWTZMNlRIM3orZnFCZFBPQ0VZTURlMk1iT1Y4bFpRUW8wdmhEMm5RcGJ5alBFQlU1SUROcFgzNzRuSXJraGh6aEhJRGJyNHg2WXdWd1VqTWs0V2sva1pNamlmRHlTY2lnNTVnUkhob3Z6Tm0razd3bmhqTk1TYmpFWjdHcnRCWG9yNVRuUmp4VUJEdUlLSjM2bm9zQkpMaGNNZ3hsb2lBZVp6bzYvV2w5UlBGbUhPeW9kOExmZjhuU1VGd0RFYWVnSmZGWmMrVFc2NU5rb1dZYy85RCt1OXdWU2pmOWtlVDNERHk2bElLaTRtRFhzWVZjZ3g4WWNTQU1oV1p1MWJKMmprV0JBRk1EdUtwbHFLWndoZ05JUWYyOXFMcjl0ekR1SGo0ZjBiOHVZUmYrcXU5TU80T3AzTXVnRUhvL1dPRndhdlhvQXYzeU4rRmhJRCtWTVNmeVBtbDFtYUxmREUrbDBmc3hOTXJhZlp6TkRTS1R2bkY4NVRCeitMbk5IaStZdTJobjY3VnlnYWN4cHJyYUNkZU5sRUY4OGZBaDJYTGZuY0FZL0FnQWxlRGQxMy9KazNYNHdmakI0aEdNSENHL2pjamE1QzU5aFpHd1BMdUlNMHZSRUllaGtjNjcyQkVFUUZhUW4vL0F1QmFhZDl4WEc1Mk5VSlErcU1TWUtwbUR5SzdmTVh2VUdHT0FTMFR4blFHNGoxQkQxdkhZaXdteDhtU3R1emJMZnVZNDhMRnlpOUkvRzEwbzcvQk51ZVkwWmYwaENTUmY1TE1yWWFlTVByQlJoNjVZeU9adnVtbm1hNHkyc2l4WW40Z0dlc3pkSTlJNjBPZHRiU3h0WnRiWnBCcGpRWlhiRjJuSlkyL0hiNzBOL0dMMWtxRCtvSGVrMDY3MkRmVThzd1pDVCtxdEJlY2RsWEZJMXdyZndaL2NxS0xTK0NudnpvQi9aU095UUhKOGh0Yjc5TlgxbjE4TitzclVyRnUwS1B2OUJQckh2UFk5RFZVZzY5aTZCMjJ4S2dHTXpSdmdhSWxTZ2RRS2RmSUE4S0RaSUFXQ2pEN2tRZWtHMW41aURGdUFIVGpRRHdrR1dzWG9UUnd5dE9WRXVnRWNENnptUDZDYVloMFE1R2U4aE95YmVQR1J4RVhET1p1Lyt4bmJ4Y3l1YjZlRGJ0M2IranA2MDBQajZSNkRSYTM2dXI5MDlkUDlFcXFJM2puSDkwWmRLaUNzM1oxelNsWWNrRHN0NGY4em5ZTUI5OXRYL21hN2xMTlVxeDhWN0c5THRzb3czaldlTWIwaDlyMkhQMGgyYlRuTUhjVm90RGZCVmxIYXFRcUFNekNENm5NT20wa0orQVBCUWdrWnlQc053cVc5NFIzU3RMT01QOXRDZEVScW9aMitiK2l1Q3JFOVNGZUNIdGRabXlQZXU3NWFzamNpNXJJNXREcjM2NGMrLzVmUEZiNWR2UEN4eW96ZTNkdnFUNW5tUHE3WnZmdW5iMUxQOWZZUFRhMit4ZW0vOE4wV0pyYW56VDBYYUxQejlibEtxSmNyaGsvdDBFUTkwL1VrSTVTNVF5anpPZFQvdHUwMjRUais0Wlg2Mi9GbXJFNHpKdndjZjFGQXlZSmNOR2YycjhZQnNzUmkrK0prK1Rxa2YyTHl3YzdmTG4zbnFOcjRKVzIvT0hpOTVxQzZYMFJiQkpHVEhMNVkrVGQvay9NRGp5MkhQdkU3dHhqQXpkOHZILzVXUG5WM3hGK2lmd3U5dkViY3NlVyt6OSt3OEJqdWQyZmlDMC90dnJWZDBtWEg0QmwrNmhOQmVRZUxndGxBMmxuVVVIRC83TDYwOXhQMWJmZlp0UkJsVzNlTmhtRmlISTFZeTJGWU1seDVrR1h1TDQzT3BUbzh4cWMyL2ZKY3c0d2psY05TUmtWWE1QTmx0WmxLMldhOTNUYTk3WHpucmJ0Tno5K2x2d2QycHRiTnZ1Q1FzVmM0b3M1ME9aT205M01nZTZ6TzR2dzlCMWdtdFlxVHVHcW0vYVBXdFpFV09xSUhMVGhEMXRIVkhzZm9HN3pqSGo1KzJwV1ZmOGZMQ0xhTWdCNG5HTmdaR0JnWUpTY3FjM2RJeG5QYi9PVmdadFpBU2pDY1A2bWZoYUMvaitiV1Frc3pzSEFCQklGQUJ0cUNjdDRuR05nWkdCZ1Z2Zy9tOEdEdVlVQkNKaVZHQmdaVU1GREFFeDJBNVVBQUhpY1kxUmdrR0lBQWtZdUJnWm1CZnlZS1lJNE9SQWJtYzg0Z1RoellUU3llbngySXB1UHl3NTB0OUFMWTdNVDNaOUU0eFpNLzFMRGpjVEdDMUZoMmdJVmEwSEk0d3NEdk9idkljNGRHUDc1UXJ3ZjZKMFdVTUs2QlpYTndBQUFPQThxTEFBQUFBQVdBQllBRmdBNEFGb0FlQUNZQU1BQTVnRU9BVXdCWWdHSUFhNEIwZ0gyQWd3Q0lnSTRBazRDWkFKNkFvNEN0Z01BQXlJRFZBTjJBOGdEN2dRTUJGWUVmZ1NxQk9nRS9BVXNCVDRGWGdXY0JkWUdJQVpZQnVJSEZnZFlCNVFINUFmMENBWUlHQWdxQ0hnSWxnaTJDTXdJNGdqNENRNEpNZ2xlQ1pvSnpBb1FDa1lLYWdxZ0NzWUxEQXNxQzBnTGFBdUdDL29NRWd4TURHNE1vQXpVRFFZTllBMkFEWndOeEEzeURpUU9kZzZTRHF3TzFnNytEellQVGc5bUQ0UVBvQS9LRUFZUU9CQldFSFlRbEJDeUVOWVJLQkZzRVlnUnpCSHFFZ1lTS0JKd0VwSVN0aE0rRTJBVDBoUWFGRVlVZ0JUSUZRQVZIaFU0RlZvVmdCWElGZ1FXSmhaTUZuSVdtQmJJRnZ3WEloZVlHQllZbUJqUUdTZ1pQQmxnR1lJWnFoblNHZjRhUEJwb0dyUWF6QnJlR3ZRYkRCc2tHendiVkJ0a0czNGJuQnZ3SEFBY09CeFlISUFjc2h6K0hSb2RaQjJNSGJvZDdCNGlIa0FlWEI2VUhzSWU3aDhpSDNZZndDQStJSGdnb2lDK0lOWWc4Q0VlSVZ3aGtpSEVJZUlpR2lKQ0ltQWlpaUswSXZ3akdDT1FJOElqNGlRT0pFb2tjQ1NjSk1ZaytpVTBKWG9sbkNYYUpnUW1SaWFZSnRnbS9pYytKMkluZUNlb0o5d29HQ2hHS0hBb3dpa01BQUI0bkdOZ1pHQmdlTVNRd1NEQUFBSk1ZTElZaU0yNGMwQk1BQ3lZQW40QUFIaWNmWkMvU2tNeEdNVlArZytxMHNIQnlTR0RReDF1Mm5zUkNuZTBVTFJMdTlSVitpZTNEWlRjY20rZ2RIQVRYOEkzY1BBaDNId0FKNS9BelVmdzNHc29GTUdFTDk4dkp5Zkpsd0JvNFJVQ3YrMGFUNTRGNnZqd1hFRURYNTZydUJDeDV4cWFJdmRjUjBzOGUyN2dXTHpSS1dwTnpoN0xYUVVMSE9IZGN3VW4rUFJjeFEyK1BkZHdLdTQ5MTNFdUhqdzNjQ1plMEVjR2pTa2N4d1VrWnRoeEhFTmh5SkFZd1NLbHg1QzNIQjFXcEFFMVN4NlVhMHZ1bFlqbzd6SzM2WERzRzhUb3NDZmVtK3k5Q2psbmlxcW1mZ24wTXoxMWVpRm5PemxXUXlWSE5zMk0zQnEza29QVXVrR2FMYldNVkZlMlY4NXQ0azRub1pvVXFzb1RaYlhqR2JlWWx4Zmx4SGxxbVl4WGlneER6VEQvVjNuTW1KU3J4VHZYNVkrRVhnOFJvTWVJNkF4eHhZTU9Db3ZseERyajFub1Jrc09nRjBUZGtLNi94MkZ2Qk82b1phellsRVVWbHlnZmtvczZ5MDFxWmFqWU9VLzVvNXEyNFBCaDZVYmJ3TC91QjZqdmJRRUFBQUI0bkcyUVF4ZGxSd0FHWDMyeGJkdkpiWGZIR01hMmJ2ZDlMN1k1U1NhMmpZbHQyN2FUYmY1SU1pZmJwTTZwVmUxcXBORy8vRDE3WkVmL3gxOXpaU1RFUE16TGZNelBBaXpJUWl6TUlxTXBvNm1qYWFQcG94bWptU3pLWWl6T0VpekpVaXpOTWl6TGNpelBDcXpJU3F6TUtxekthcXpPR3F6Sldxek5PcXpMZXF6UEJteklSbXpNSm16S1ptek9GblFZTEE1UElKTElGTFprSzdabUc3WmxPN1puQjNaa0o2WXdsV2xNWndZejJabGQySlhkMkowOTJKTzkySnQ5MkpmOTJKOERPSkNET0poRE9KVERPSndqT0pLZVNtTmd6SVNqT0pwak9KYmpPSjRUT0pHVE9KbFRPSlhUT0owek9KT3pPSnR6T0pmek9KOEx1SkJaWE1URlhNSnNMdVV5THVjS3J1UXFydVlhcnVVNnJ1Y0didVFtYnVZV2J1VTJidWNPN3VRdTd1WWU3dVUrN3VjQjV2QWdEL0V3ai9Bb2ovRTRUL0RrYUE1UDhUVFA4Q3pQOFR3djhDSXY4VEt2OENxdjhUcHY4Q1p2OFRidjhDN3Y4VDRmOENFZjhUR2Y4Q21mOFRsZjhDVmY4VFhmOEMzZjhUMC84Q00vOFRPLzhDdS84VHQvOE9mb3YxTmxPaGtqWTJXY2pKY0pNbEVteVdTWnViV1hxVEpOWnBBWnkweGtPMWtqYTJXZHJKY05zbEUyeVdiWkl0dkxWdGttTzhpT1pTZHluWnlSczNKT3pzc0Z1U2lYNUxKY2tldmxxbHlURytUR2NoUDVUdDdJVzNrbjcrV0RmSlJQOGxtK3lQZnlWYjdKRC9KaitZbENwMkFVcklKVDhBcEJJU29raGF4UUZIcUZxdEFVQm9XeHdrU3hVelNLVnRFcGVzV2dHQldUWWxZc2lyMWlWV3lLZytKWWNhTFVLUmtscStTVXZGSlFpa3BKS1NzVnBWNnBLaldsUVdtc05GSHVsSTJ5VlhiS1hqa29SK1drbkpXTGNxOWNsWnZ5b0R4V25xaDBLa2JGcWpnVnJ4SlVva3BTeVNwRnBWZXBLazFsVUJtclROUjM2bzE2cTk2cDkrcUQrcWcrcWMvcWkvcGVmVlhmMUEvcUo2cWRxbEcxcWs3VnF3YlZxSnBVczJwUjdWV3JhbE1kVk1lcUU3Vk96YWhaTmFmbTFZSmFWRXRxV2EybzlXcFZyYWtOYW1PMWlZWk9nOUZnTlRnTlhrUFFFRFVrRFZsRDBkQnJxQnFhaGtIRCtCL3g2OU43ZUp4ajhON0JjQ0lvWWlNalkxL2tCc2FkSEF3Y0RNa0ZHeGxZblRZeU1HaEJhQTRVZWljREF3TW5Nb3Vad1dXakNtTkhZTVFHaDQ2SWpjd3BMaHZWUUx4ZEhBME1qQ3dPSGNraEVTQWxrVUN3a1lGSGF3ZmovOVlOTEwwYm1SaGNBQWZUSXJnQUFBQT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLndvZmZcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLndvZmZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IENvbXBvbmVudCwgY2xvbmVFbGVtZW50LCBoLCBvcHRpb25zLCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuXG52YXIgdmVyc2lvbiA9ICcxNS4xLjAnOyAvLyB0cmljayBsaWJyYXJpZXMgdG8gdGhpbmsgd2UgYXJlIHJlYWN0XG5cbnZhciBFTEVNRU5UUyA9ICdhIGFiYnIgYWRkcmVzcyBhcmVhIGFydGljbGUgYXNpZGUgYXVkaW8gYiBiYXNlIGJkaSBiZG8gYmlnIGJsb2NrcXVvdGUgYm9keSBiciBidXR0b24gY2FudmFzIGNhcHRpb24gY2l0ZSBjb2RlIGNvbCBjb2xncm91cCBkYXRhIGRhdGFsaXN0IGRkIGRlbCBkZXRhaWxzIGRmbiBkaWFsb2cgZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWQgaGVhZGVyIGhncm91cCBociBodG1sIGkgaWZyYW1lIGltZyBpbnB1dCBpbnMga2JkIGtleWdlbiBsYWJlbCBsZWdlbmQgbGkgbGluayBtYWluIG1hcCBtYXJrIG1lbnUgbWVudWl0ZW0gbWV0YSBtZXRlciBuYXYgbm9zY3JpcHQgb2JqZWN0IG9sIG9wdGdyb3VwIG9wdGlvbiBvdXRwdXQgcCBwYXJhbSBwaWN0dXJlIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbCBzb3VyY2Ugc3BhbiBzdHJvbmcgc3R5bGUgc3ViIHN1bW1hcnkgc3VwIHRhYmxlIHRib2R5IHRkIHRleHRhcmVhIHRmb290IHRoIHRoZWFkIHRpbWUgdGl0bGUgdHIgdHJhY2sgdSB1bCB2YXIgdmlkZW8gd2JyIGNpcmNsZSBjbGlwUGF0aCBkZWZzIGVsbGlwc2UgZyBpbWFnZSBsaW5lIGxpbmVhckdyYWRpZW50IG1hc2sgcGF0aCBwYXR0ZXJuIHBvbHlnb24gcG9seWxpbmUgcmFkaWFsR3JhZGllbnQgcmVjdCBzdG9wIHN2ZyB0ZXh0IHRzcGFuJy5zcGxpdCgnICcpO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2whPT0ndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHwgMHhlYWM3O1xuXG52YXIgQ09NUE9ORU5UX1dSQVBQRVJfS0VZID0gdHlwZW9mIFN5bWJvbCE9PSd1bmRlZmluZWQnID8gU3ltYm9sLmZvcignX19wcmVhY3RDb21wYXRXcmFwcGVyJykgOiAnX19wcmVhY3RDb21wYXRXcmFwcGVyJztcblxuLy8gZG9uJ3QgYXV0b2JpbmQgdGhlc2UgbWV0aG9kcyBzaW5jZSB0aGV5IGFscmVhZHkgaGF2ZSBndWFyYW50ZWVkIGNvbnRleHQuXG52YXIgQVVUT0JJTkRfQkxBQ0tMSVNUID0ge1xuXHRjb25zdHJ1Y3RvcjogMSxcblx0cmVuZGVyOiAxLFxuXHRzaG91bGRDb21wb25lbnRVcGRhdGU6IDEsXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IDEsXG5cdGNvbXBvbmVudFdpbGxVcGRhdGU6IDEsXG5cdGNvbXBvbmVudERpZFVwZGF0ZTogMSxcblx0Y29tcG9uZW50V2lsbE1vdW50OiAxLFxuXHRjb21wb25lbnREaWRNb3VudDogMSxcblx0Y29tcG9uZW50V2lsbFVubW91bnQ6IDEsXG5cdGNvbXBvbmVudERpZFVubW91bnQ6IDFcbn07XG5cblxudmFyIENBTUVMX1BST1BTID0gL14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcHxjb2xvcnxmaWxsfGZsb29kfGZvbnR8Z2x5cGh8aG9yaXp8bWFya2VyfG92ZXJsaW5lfHBhaW50fHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dHx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KVtBLVpdLztcblxuXG52YXIgQllQQVNTX0hPT0sgPSB7fTtcblxuLypnbG9iYWwgcHJvY2VzcyovXG52YXIgREVWID0gdHlwZW9mIHByb2Nlc3M9PT0ndW5kZWZpbmVkJyB8fCAhcHJvY2Vzcy5lbnYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbic7XG5cbi8vIGEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBub3RoaW5nLiBVc2VkIHRvIHJlcGxhY2UgY29tcG9uZW50cyBmb3IgdW5tb3VudENvbXBvbmVudEF0Tm9kZS5cbmZ1bmN0aW9uIEVtcHR5Q29tcG9uZW50KCkgeyByZXR1cm4gbnVsbDsgfVxuXG5cblxuLy8gbWFrZSByZWFjdCB0aGluayB3ZSdyZSByZWFjdC5cbnZhciBWTm9kZSA9IGgoJ2EnLCBudWxsKS5jb25zdHJ1Y3RvcjtcblZOb2RlLnByb3RvdHlwZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblZOb2RlLnByb3RvdHlwZS5wcmVhY3RDb21wYXRVcGdyYWRlZCA9IGZhbHNlO1xuVk5vZGUucHJvdG90eXBlLnByZWFjdENvbXBhdE5vcm1hbGl6ZWQgPSBmYWxzZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZOb2RlLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vZGVOYW1lOyB9LFxuXHRzZXQ6IGZ1bmN0aW9uKHYpIHsgdGhpcy5ub2RlTmFtZSA9IHY7IH0sXG5cdGNvbmZpZ3VyYWJsZTp0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZOb2RlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzOyB9LFxuXHRzZXQ6IGZ1bmN0aW9uKHYpIHsgdGhpcy5hdHRyaWJ1dGVzID0gdjsgfSxcblx0Y29uZmlndXJhYmxlOnRydWVcbn0pO1xuXG5cblxudmFyIG9sZEV2ZW50SG9vayA9IG9wdGlvbnMuZXZlbnQ7XG5vcHRpb25zLmV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcblx0aWYgKG9sZEV2ZW50SG9vaykgeyBlID0gb2xkRXZlbnRIb29rKGUpOyB9XG5cdGUucGVyc2lzdCA9IE9iamVjdDtcblx0ZS5uYXRpdmVFdmVudCA9IGU7XG5cdHJldHVybiBlO1xufTtcblxuXG52YXIgb2xkVm5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSBmdW5jdGlvbiAodm5vZGUpIHtcblx0aWYgKCF2bm9kZS5wcmVhY3RDb21wYXRVcGdyYWRlZCkge1xuXHRcdHZub2RlLnByZWFjdENvbXBhdFVwZ3JhZGVkID0gdHJ1ZTtcblxuXHRcdHZhciB0YWcgPSB2bm9kZS5ub2RlTmFtZSxcblx0XHRcdGF0dHJzID0gdm5vZGUuYXR0cmlidXRlcyA9IGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyk7XG5cblx0XHRpZiAodHlwZW9mIHRhZz09PSdmdW5jdGlvbicpIHtcblx0XHRcdGlmICh0YWdbQ09NUE9ORU5UX1dSQVBQRVJfS0VZXT09PXRydWUgfHwgKHRhZy5wcm90b3R5cGUgJiYgJ2lzUmVhY3RDb21wb25lbnQnIGluIHRhZy5wcm90b3R5cGUpKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAmJiBTdHJpbmcodm5vZGUuY2hpbGRyZW4pPT09JycpIHsgdm5vZGUuY2hpbGRyZW4gPSB1bmRlZmluZWQ7IH1cblx0XHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuKSB7IGF0dHJzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47IH1cblxuXHRcdFx0XHRpZiAoIXZub2RlLnByZWFjdENvbXBhdE5vcm1hbGl6ZWQpIHtcblx0XHRcdFx0XHRub3JtYWxpemVWTm9kZSh2bm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFuZGxlQ29tcG9uZW50Vk5vZGUodm5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAmJiBTdHJpbmcodm5vZGUuY2hpbGRyZW4pPT09JycpIHsgdm5vZGUuY2hpbGRyZW4gPSB1bmRlZmluZWQ7IH1cblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbikgeyBhdHRycy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuOyB9XG5cblx0XHRcdGlmIChhdHRycy5kZWZhdWx0VmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhdHRycy52YWx1ZSAmJiBhdHRycy52YWx1ZSE9PTApIHtcblx0XHRcdFx0XHRhdHRycy52YWx1ZSA9IGF0dHJzLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgYXR0cnMuZGVmYXVsdFZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRoYW5kbGVFbGVtZW50Vk5vZGUodm5vZGUsIGF0dHJzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAob2xkVm5vZGVIb29rKSB7IG9sZFZub2RlSG9vayh2bm9kZSk7IH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbXBvbmVudFZOb2RlKHZub2RlKSB7XG5cdHZhciB0YWcgPSB2bm9kZS5ub2RlTmFtZSxcblx0XHRhID0gdm5vZGUuYXR0cmlidXRlcztcblxuXHR2bm9kZS5hdHRyaWJ1dGVzID0ge307XG5cdGlmICh0YWcuZGVmYXVsdFByb3BzKSB7IGV4dGVuZCh2bm9kZS5hdHRyaWJ1dGVzLCB0YWcuZGVmYXVsdFByb3BzKTsgfVxuXHRpZiAoYSkgeyBleHRlbmQodm5vZGUuYXR0cmlidXRlcywgYSk7IH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudFZOb2RlKHZub2RlLCBhKSB7XG5cdHZhciBzaG91bGRTYW5pdGl6ZSwgYXR0cnMsIGk7XG5cdGlmIChhKSB7XG5cdFx0Zm9yIChpIGluIGEpIHsgaWYgKChzaG91bGRTYW5pdGl6ZSA9IENBTUVMX1BST1BTLnRlc3QoaSkpKSB7IGJyZWFrOyB9IH1cblx0XHRpZiAoc2hvdWxkU2FuaXRpemUpIHtcblx0XHRcdGF0dHJzID0gdm5vZGUuYXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0Zm9yIChpIGluIGEpIHtcblx0XHRcdFx0aWYgKGEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRhdHRyc1sgQ0FNRUxfUFJPUFMudGVzdChpKSA/IGkucmVwbGFjZSgvKFtBLVowLTldKS8sICctJDEnKS50b0xvd2VyQ2FzZSgpIDogaSBdID0gYVtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cblxuLy8gcHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG5mdW5jdGlvbiByZW5kZXIkMSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHR2YXIgcHJldiA9IHBhcmVudCAmJiBwYXJlbnQuX3ByZWFjdENvbXBhdFJlbmRlcmVkICYmIHBhcmVudC5fcHJlYWN0Q29tcGF0UmVuZGVyZWQuYmFzZTtcblxuXHQvLyBpZ25vcmUgaW1wb3NzaWJsZSBwcmV2aW91cyByZW5kZXJzXG5cdGlmIChwcmV2ICYmIHByZXYucGFyZW50Tm9kZSE9PXBhcmVudCkgeyBwcmV2ID0gbnVsbDsgfVxuXG5cdC8vIGRlZmF1bHQgdG8gZmlyc3QgRWxlbWVudCBjaGlsZFxuXHRpZiAoIXByZXYgJiYgcGFyZW50KSB7IHByZXYgPSBwYXJlbnQuZmlyc3RFbGVtZW50Q2hpbGQ7IH1cblxuXHQvLyByZW1vdmUgdW5hZmZlY3RlZCBzaWJsaW5nc1xuXHRmb3IgKHZhciBpPXBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0hPT1wcmV2KSB7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmNoaWxkTm9kZXNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdHZhciBvdXQgPSByZW5kZXIodm5vZGUsIHBhcmVudCwgcHJldik7XG5cdGlmIChwYXJlbnQpIHsgcGFyZW50Ll9wcmVhY3RDb21wYXRSZW5kZXJlZCA9IG91dCAmJiAob3V0Ll9jb21wb25lbnQgfHwgeyBiYXNlOiBvdXQgfSk7IH1cblx0aWYgKHR5cGVvZiBjYWxsYmFjaz09PSdmdW5jdGlvbicpIHsgY2FsbGJhY2soKTsgfVxuXHRyZXR1cm4gb3V0ICYmIG91dC5fY29tcG9uZW50IHx8IG91dDtcbn1cblxuXG52YXIgQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24gKCkge307XG5cbkNvbnRleHRQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5wcm9wcy5jb250ZXh0O1xufTtcbkNvbnRleHRQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlblswXTtcbn07XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgdm5vZGUsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcblx0dmFyIHdyYXAgPSBoKENvbnRleHRQcm92aWRlciwgeyBjb250ZXh0OiBwYXJlbnRDb21wb25lbnQuY29udGV4dCB9LCB2bm9kZSk7XG5cdHZhciByZW5kZXJDb250YWluZXIgPSByZW5kZXIkMSh3cmFwLCBjb250YWluZXIpO1xuXHR2YXIgY29tcG9uZW50ID0gcmVuZGVyQ29udGFpbmVyLl9jb21wb25lbnQgfHwgcmVuZGVyQ29udGFpbmVyLmJhc2U7XG5cdGlmIChjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCwgcmVuZGVyQ29udGFpbmVyKTsgfVxuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG5cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XG5cdHZhciBleGlzdGluZyA9IGNvbnRhaW5lci5fcHJlYWN0Q29tcGF0UmVuZGVyZWQgJiYgY29udGFpbmVyLl9wcmVhY3RDb21wYXRSZW5kZXJlZC5iYXNlO1xuXHRpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcucGFyZW50Tm9kZT09PWNvbnRhaW5lcikge1xuXHRcdHJlbmRlcihoKEVtcHR5Q29tcG9uZW50KSwgY29udGFpbmVyLCBleGlzdGluZyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cblxudmFyIEFSUiA9IFtdO1xuXG4vLyBUaGlzIEFQSSBpcyBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGZvciBQcmVhY3QsIHNvIGl0J3MgYmFzaWNhbGx5IHBhc3N0aHJvdWdoLlxudmFyIENoaWxkcmVuID0ge1xuXHRtYXA6IGZ1bmN0aW9uKGNoaWxkcmVuLCBmbiwgY3R4KSB7XG5cdFx0aWYgKGNoaWxkcmVuID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRjaGlsZHJlbiA9IENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChjdHggJiYgY3R4IT09Y2hpbGRyZW4pIHsgZm4gPSBmbi5iaW5kKGN0eCk7IH1cblx0XHRyZXR1cm4gY2hpbGRyZW4ubWFwKGZuKTtcblx0fSxcblx0Zm9yRWFjaDogZnVuY3Rpb24oY2hpbGRyZW4sIGZuLCBjdHgpIHtcblx0XHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdGNoaWxkcmVuID0gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG5cdFx0aWYgKGN0eCAmJiBjdHghPT1jaGlsZHJlbikgeyBmbiA9IGZuLmJpbmQoY3R4KTsgfVxuXHRcdGNoaWxkcmVuLmZvckVhY2goZm4pO1xuXHR9LFxuXHRjb3VudDogZnVuY3Rpb24oY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoIHx8IDA7XG5cdH0sXG5cdG9ubHk6IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG5cdFx0Y2hpbGRyZW4gPSBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoIT09MSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLm9ubHkoKSBleHBlY3RzIG9ubHkgb25lIGNoaWxkLicpOyB9XG5cdFx0cmV0dXJuIGNoaWxkcmVuWzBdO1xuXHR9LFxuXHR0b0FycmF5OiBmdW5jdGlvbihjaGlsZHJlbikge1xuXHRcdGlmIChjaGlsZHJlbiA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuXHRcdHJldHVybiBBUlIuY29uY2F0KGNoaWxkcmVuKTtcblx0fVxufTtcblxuXG4vKiogVHJhY2sgY3VycmVudCByZW5kZXIoKSBjb21wb25lbnQgZm9yIHJlZiBhc3NpZ25tZW50ICovXG52YXIgY3VycmVudENvbXBvbmVudDtcblxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5KHR5cGUpIHtcblx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbn1cblxuXG52YXIgRE9NID0ge307XG5mb3IgKHZhciBpPUVMRU1FTlRTLmxlbmd0aDsgaS0tOyApIHtcblx0RE9NW0VMRU1FTlRTW2ldXSA9IGNyZWF0ZUZhY3RvcnkoRUxFTUVOVFNbaV0pO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlVG9WTm9kZXMoYXJyLCBvZmZzZXQpIHtcblx0Zm9yICh2YXIgaT1vZmZzZXQgfHwgMDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgb2JqID0gYXJyW2ldO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdHVwZ3JhZGVUb1ZOb2RlcyhvYmopO1xuXHRcdH1cblx0XHRlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaj09PSdvYmplY3QnICYmICFpc1ZhbGlkRWxlbWVudChvYmopICYmICgob2JqLnByb3BzICYmIG9iai50eXBlKSB8fCAob2JqLmF0dHJpYnV0ZXMgJiYgb2JqLm5vZGVOYW1lKSB8fCBvYmouY2hpbGRyZW4pKSB7XG5cdFx0XHRhcnJbaV0gPSBjcmVhdGVFbGVtZW50KG9iai50eXBlIHx8IG9iai5ub2RlTmFtZSwgb2JqLnByb3BzIHx8IG9iai5hdHRyaWJ1dGVzLCBvYmouY2hpbGRyZW4pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpc1N0YXRlbGVzc0NvbXBvbmVudChjKSB7XG5cdHJldHVybiB0eXBlb2YgYz09PSdmdW5jdGlvbicgJiYgIShjLnByb3RvdHlwZSAmJiBjLnByb3RvdHlwZS5yZW5kZXIpO1xufVxuXG5cbi8vIHdyYXBzIHN0YXRlbGVzcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMgaW4gYSBQcm9wVHlwZXMgdmFsaWRhdG9yXG5mdW5jdGlvbiB3cmFwU3RhdGVsZXNzQ29tcG9uZW50KFdyYXBwZWRDb21wb25lbnQpIHtcblx0cmV0dXJuIGNyZWF0ZUNsYXNzKHtcblx0XHRkaXNwbGF5TmFtZTogV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUsXG5cdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBXcmFwcGVkQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG5mdW5jdGlvbiBzdGF0ZWxlc3NDb21wb25lbnRIb29rKEN0b3IpIHtcblx0dmFyIFdyYXBwZWQgPSBDdG9yW0NPTVBPTkVOVF9XUkFQUEVSX0tFWV07XG5cdGlmIChXcmFwcGVkKSB7IHJldHVybiBXcmFwcGVkPT09dHJ1ZSA/IEN0b3IgOiBXcmFwcGVkOyB9XG5cblx0V3JhcHBlZCA9IHdyYXBTdGF0ZWxlc3NDb21wb25lbnQoQ3Rvcik7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWQsIENPTVBPTkVOVF9XUkFQUEVSX0tFWSwgeyBjb25maWd1cmFibGU6dHJ1ZSwgdmFsdWU6dHJ1ZSB9KTtcblx0V3JhcHBlZC5kaXNwbGF5TmFtZSA9IEN0b3IuZGlzcGxheU5hbWU7XG5cdFdyYXBwZWQucHJvcFR5cGVzID0gQ3Rvci5wcm9wVHlwZXM7XG5cdFdyYXBwZWQuZGVmYXVsdFByb3BzID0gQ3Rvci5kZWZhdWx0UHJvcHM7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEN0b3IsIENPTVBPTkVOVF9XUkFQUEVSX0tFWSwgeyBjb25maWd1cmFibGU6dHJ1ZSwgdmFsdWU6V3JhcHBlZCB9KTtcblxuXHRyZXR1cm4gV3JhcHBlZDtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuXHR2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHR3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG5cdHVwZ3JhZGVUb1ZOb2RlcyhhcmdzLCAyKTtcblx0cmV0dXJuIG5vcm1hbGl6ZVZOb2RlKGguYXBwbHkodm9pZCAwLCBhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUodm5vZGUpIHtcblx0dm5vZGUucHJlYWN0Q29tcGF0Tm9ybWFsaXplZCA9IHRydWU7XG5cblx0YXBwbHlDbGFzc05hbWUodm5vZGUpO1xuXG5cdGlmIChpc1N0YXRlbGVzc0NvbXBvbmVudCh2bm9kZS5ub2RlTmFtZSkpIHtcblx0XHR2bm9kZS5ub2RlTmFtZSA9IHN0YXRlbGVzc0NvbXBvbmVudEhvb2sodm5vZGUubm9kZU5hbWUpO1xuXHR9XG5cblx0dmFyIHJlZiA9IHZub2RlLmF0dHJpYnV0ZXMucmVmLFxuXHRcdHR5cGUgPSByZWYgJiYgdHlwZW9mIHJlZjtcblx0aWYgKGN1cnJlbnRDb21wb25lbnQgJiYgKHR5cGU9PT0nc3RyaW5nJyB8fCB0eXBlPT09J251bWJlcicpKSB7XG5cdFx0dm5vZGUuYXR0cmlidXRlcy5yZWYgPSBjcmVhdGVTdHJpbmdSZWZQcm94eShyZWYsIGN1cnJlbnRDb21wb25lbnQpO1xuXHR9XG5cblx0YXBwbHlFdmVudE5vcm1hbGl6YXRpb24odm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQkMShlbGVtZW50LCBwcm9wcykge1xuXHR2YXIgY2hpbGRyZW4gPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cdHdoaWxlICggbGVuLS0gPiAwICkgY2hpbGRyZW5bIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cblx0aWYgKCFpc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgeyByZXR1cm4gZWxlbWVudDsgfVxuXHR2YXIgZWxlbWVudFByb3BzID0gZWxlbWVudC5hdHRyaWJ1dGVzIHx8IGVsZW1lbnQucHJvcHM7XG5cdHZhciBub2RlID0gaChcblx0XHRlbGVtZW50Lm5vZGVOYW1lIHx8IGVsZW1lbnQudHlwZSxcblx0XHRlbGVtZW50UHJvcHMsXG5cdFx0ZWxlbWVudC5jaGlsZHJlbiB8fCBlbGVtZW50UHJvcHMgJiYgZWxlbWVudFByb3BzLmNoaWxkcmVuXG5cdCk7XG5cdC8vIE9ubHkgcHJvdmlkZSB0aGUgM3JkIGFyZ3VtZW50IGlmIG5lZWRlZC5cblx0Ly8gQXJndW1lbnRzIDMrIG92ZXJ3cml0ZSBlbGVtZW50LmNoaWxkcmVuIGluIHByZWFjdENsb25lRWxlbWVudFxuXHR2YXIgY2xvbmVBcmdzID0gW25vZGUsIHByb3BzXTtcblx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdGNsb25lQXJncy5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRlbHNlIGlmIChwcm9wcyAmJiBwcm9wcy5jaGlsZHJlbikge1xuXHRcdGNsb25lQXJncy5wdXNoKHByb3BzLmNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gbm9ybWFsaXplVk5vZGUoY2xvbmVFbGVtZW50LmFwcGx5KHZvaWQgMCwgY2xvbmVBcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuXHRyZXR1cm4gZWxlbWVudCAmJiAoKGVsZW1lbnQgaW5zdGFuY2VvZiBWTm9kZSkgfHwgZWxlbWVudC4kJHR5cGVvZj09PVJFQUNUX0VMRU1FTlRfVFlQRSk7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nUmVmUHJveHkobmFtZSwgY29tcG9uZW50KSB7XG5cdHJldHVybiBjb21wb25lbnQuX3JlZlByb3hpZXNbbmFtZV0gfHwgKGNvbXBvbmVudC5fcmVmUHJveGllc1tuYW1lXSA9IGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuXHRcdGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnJlZnMpIHtcblx0XHRcdGNvbXBvbmVudC5yZWZzW25hbWVdID0gcmVzb2x2ZWQ7XG5cdFx0XHRpZiAocmVzb2x2ZWQ9PT1udWxsKSB7XG5cdFx0XHRcdGRlbGV0ZSBjb21wb25lbnQuX3JlZlByb3hpZXNbbmFtZV07XG5cdFx0XHRcdGNvbXBvbmVudCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuXG5mdW5jdGlvbiBhcHBseUV2ZW50Tm9ybWFsaXphdGlvbihyZWYpIHtcblx0dmFyIG5vZGVOYW1lID0gcmVmLm5vZGVOYW1lO1xuXHR2YXIgYXR0cmlidXRlcyA9IHJlZi5hdHRyaWJ1dGVzO1xuXG5cdGlmICghYXR0cmlidXRlcyB8fCB0eXBlb2Ygbm9kZU5hbWUhPT0nc3RyaW5nJykgeyByZXR1cm47IH1cblx0dmFyIHByb3BzID0ge307XG5cdGZvciAodmFyIGkgaW4gYXR0cmlidXRlcykge1xuXHRcdHByb3BzW2kudG9Mb3dlckNhc2UoKV0gPSBpO1xuXHR9XG5cdGlmIChwcm9wcy5vbmRvdWJsZWNsaWNrKSB7XG5cdFx0YXR0cmlidXRlcy5vbmRibGNsaWNrID0gYXR0cmlidXRlc1twcm9wcy5vbmRvdWJsZWNsaWNrXTtcblx0XHRkZWxldGUgYXR0cmlidXRlc1twcm9wcy5vbmRvdWJsZWNsaWNrXTtcblx0fVxuXHQvLyBmb3IgKnRleHR1YWwgaW5wdXRzKiAoaW5jbCB0ZXh0YXJlYSksIG5vcm1hbGl6ZSBgb25DaGFuZ2VgIC0+IGBvbklucHV0YDpcblx0aWYgKHByb3BzLm9uY2hhbmdlICYmIChub2RlTmFtZT09PSd0ZXh0YXJlYScgfHwgKG5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT0naW5wdXQnICYmICEvXmZpbHxjaGV8cmFkL2kudGVzdChhdHRyaWJ1dGVzLnR5cGUpKSkpIHtcblx0XHR2YXIgbm9ybWFsaXplZCA9IHByb3BzLm9uaW5wdXQgfHwgJ29uaW5wdXQnO1xuXHRcdGlmICghYXR0cmlidXRlc1tub3JtYWxpemVkXSkge1xuXHRcdFx0YXR0cmlidXRlc1tub3JtYWxpemVkXSA9IG11bHRpaG9vayhbYXR0cmlidXRlc1tub3JtYWxpemVkXSwgYXR0cmlidXRlc1twcm9wcy5vbmNoYW5nZV1dKTtcblx0XHRcdGRlbGV0ZSBhdHRyaWJ1dGVzW3Byb3BzLm9uY2hhbmdlXTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBhcHBseUNsYXNzTmFtZSh2bm9kZSkge1xuXHR2YXIgYSA9IHZub2RlLmF0dHJpYnV0ZXMgfHwgKHZub2RlLmF0dHJpYnV0ZXMgPSB7fSk7XG5cdGNsYXNzTmFtZURlc2NyaXB0b3IuZW51bWVyYWJsZSA9ICdjbGFzc05hbWUnIGluIGE7XG5cdGlmIChhLmNsYXNzTmFtZSkgeyBhLmNsYXNzID0gYS5jbGFzc05hbWU7IH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcbn1cblxuXG52YXIgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbGFzczsgfSxcblx0c2V0OiBmdW5jdGlvbih2KSB7IHRoaXMuY2xhc3MgPSB2OyB9XG59O1xuXG5mdW5jdGlvbiBleHRlbmQoYmFzZSwgcHJvcHMpIHtcblx0dmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG5cdGZvciAodmFyIGk9MSwgb2JqID0gKHZvaWQgMCk7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKChvYmogPSBhcmd1bWVudHMkMVtpXSkpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0YmFzZVtrZXldID0gb2JqW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59XG5cblxuZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKHZhciBpIGluIGEpIHsgaWYgKCEoaSBpbiBiKSkgeyByZXR1cm4gdHJ1ZTsgfSB9XG5cdGZvciAodmFyIGkkMSBpbiBiKSB7IGlmIChhW2kkMV0hPT1iW2kkMV0pIHsgcmV0dXJuIHRydWU7IH0gfVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50KSB7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50LmJhc2UgfHwgY29tcG9uZW50O1xufVxuXG5cbmZ1bmN0aW9uIEYoKXt9XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzKG9iaikge1xuXHRmdW5jdGlvbiBjbChwcm9wcywgY29udGV4dCkge1xuXHRcdGJpbmRBbGwodGhpcyk7XG5cdFx0Q29tcG9uZW50JDEuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCwgQllQQVNTX0hPT0spO1xuXHRcdG5ld0NvbXBvbmVudEhvb2suY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XG5cdH1cblxuXHRvYmogPSBleHRlbmQoeyBjb25zdHJ1Y3RvcjogY2wgfSwgb2JqKTtcblxuXHQvLyBXZSBuZWVkIHRvIGFwcGx5IG1peGlucyBoZXJlIHNvIHRoYXQgZ2V0RGVmYXVsdFByb3BzIGlzIGNvcnJlY3RseSBtaXhlZFxuXHRpZiAob2JqLm1peGlucykge1xuXHRcdGFwcGx5TWl4aW5zKG9iaiwgY29sbGF0ZU1peGlucyhvYmoubWl4aW5zKSk7XG5cdH1cblx0aWYgKG9iai5zdGF0aWNzKSB7XG5cdFx0ZXh0ZW5kKGNsLCBvYmouc3RhdGljcyk7XG5cdH1cblx0aWYgKG9iai5wcm9wVHlwZXMpIHtcblx0XHRjbC5wcm9wVHlwZXMgPSBvYmoucHJvcFR5cGVzO1xuXHR9XG5cdGlmIChvYmouZGVmYXVsdFByb3BzKSB7XG5cdFx0Y2wuZGVmYXVsdFByb3BzID0gb2JqLmRlZmF1bHRQcm9wcztcblx0fVxuXHRpZiAob2JqLmdldERlZmF1bHRQcm9wcykge1xuXHRcdGNsLmRlZmF1bHRQcm9wcyA9IG9iai5nZXREZWZhdWx0UHJvcHMoKTtcblx0fVxuXG5cdEYucHJvdG90eXBlID0gQ29tcG9uZW50JDEucHJvdG90eXBlO1xuXHRjbC5wcm90b3R5cGUgPSBleHRlbmQobmV3IEYoKSwgb2JqKTtcblxuXHRjbC5kaXNwbGF5TmFtZSA9IG9iai5kaXNwbGF5TmFtZSB8fCAnQ29tcG9uZW50JztcblxuXHRyZXR1cm4gY2w7XG59XG5cblxuLy8gRmxhdHRlbiBhbiBBcnJheSBvZiBtaXhpbnMgdG8gYSBtYXAgb2YgbWV0aG9kIG5hbWUgdG8gbWl4aW4gaW1wbGVtZW50YXRpb25zXG5mdW5jdGlvbiBjb2xsYXRlTWl4aW5zKG1peGlucykge1xuXHR2YXIga2V5ZWQgPSB7fTtcblx0Zm9yICh2YXIgaT0wOyBpPG1peGlucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBtaXhpbiA9IG1peGluc1tpXTtcblx0XHRmb3IgKHZhciBrZXkgaW4gbWl4aW4pIHtcblx0XHRcdGlmIChtaXhpbi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBtaXhpbltrZXldPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHQoa2V5ZWRba2V5XSB8fCAoa2V5ZWRba2V5XT1bXSkpLnB1c2gobWl4aW5ba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBrZXllZDtcbn1cblxuXG4vLyBhcHBseSBhIG1hcHBpbmcgb2YgQXJyYXlzIG9mIG1peGluIG1ldGhvZHMgdG8gYSBjb21wb25lbnQgcHJvdG90eXBlXG5mdW5jdGlvbiBhcHBseU1peGlucyhwcm90bywgbWl4aW5zKSB7XG5cdGZvciAodmFyIGtleSBpbiBtaXhpbnMpIHsgaWYgKG1peGlucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0cHJvdG9ba2V5XSA9IG11bHRpaG9vayhcblx0XHRcdG1peGluc1trZXldLmNvbmNhdChwcm90b1trZXldIHx8IEFSUiksXG5cdFx0XHRrZXk9PT0nZ2V0RGVmYXVsdFByb3BzJyB8fCBrZXk9PT0nZ2V0SW5pdGlhbFN0YXRlJyB8fCBrZXk9PT0nZ2V0Q2hpbGRDb250ZXh0J1xuXHRcdCk7XG5cdH0gfVxufVxuXG5cbmZ1bmN0aW9uIGJpbmRBbGwoY3R4KSB7XG5cdGZvciAodmFyIGkgaW4gY3R4KSB7XG5cdFx0dmFyIHYgPSBjdHhbaV07XG5cdFx0aWYgKHR5cGVvZiB2PT09J2Z1bmN0aW9uJyAmJiAhdi5fX2JvdW5kICYmICFBVVRPQklORF9CTEFDS0xJU1QuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdChjdHhbaV0gPSB2LmJpbmQoY3R4KSkuX19ib3VuZCA9IHRydWU7XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gY2FsbE1ldGhvZChjdHgsIG0sIGFyZ3MpIHtcblx0aWYgKHR5cGVvZiBtPT09J3N0cmluZycpIHtcblx0XHRtID0gY3R4LmNvbnN0cnVjdG9yLnByb3RvdHlwZVttXTtcblx0fVxuXHRpZiAodHlwZW9mIG09PT0nZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIG0uYXBwbHkoY3R4LCBhcmdzKTtcblx0fVxufVxuXG5mdW5jdGlvbiBtdWx0aWhvb2soaG9va3MsIHNraXBEdXBsaWNhdGVzKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHR2YXIgcmV0O1xuXHRcdGZvciAodmFyIGk9MDsgaTxob29rcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHIgPSBjYWxsTWV0aG9kKHRoaXMkMSwgaG9va3NbaV0sIGFyZ3VtZW50cyQxKTtcblxuXHRcdFx0aWYgKHNraXBEdXBsaWNhdGVzICYmIHIhPW51bGwpIHtcblx0XHRcdFx0aWYgKCFyZXQpIHsgcmV0ID0ge307IH1cblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHIpIHsgaWYgKHIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdHJldFtrZXldID0gcltrZXldO1xuXHRcdFx0XHR9IH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiByIT09J3VuZGVmaW5lZCcpIHsgcmV0ID0gcjsgfVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufVxuXG5cbmZ1bmN0aW9uIG5ld0NvbXBvbmVudEhvb2socHJvcHMsIGNvbnRleHQpIHtcblx0cHJvcHNIb29rLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR0aGlzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBtdWx0aWhvb2soW3Byb3BzSG9vaywgdGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHx8ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJ10pO1xuXHR0aGlzLnJlbmRlciA9IG11bHRpaG9vayhbcHJvcHNIb29rLCBiZWZvcmVSZW5kZXIsIHRoaXMucmVuZGVyIHx8ICdyZW5kZXInLCBhZnRlclJlbmRlcl0pO1xufVxuXG5cbmZ1bmN0aW9uIHByb3BzSG9vayhwcm9wcywgY29udGV4dCkge1xuXHRpZiAoIXByb3BzKSB7IHJldHVybjsgfVxuXG5cdC8vIFJlYWN0IGFubm95aW5nbHkgc3BlY2lhbC1jYXNlcyBzaW5nbGUgY2hpbGRyZW4sIGFuZCBzb21lIHJlYWN0IGNvbXBvbmVudHMgYXJlIHJpZGljdWxvdXNseSBzdHJpY3QgYWJvdXQgdGhpcy5cblx0dmFyIGMgPSBwcm9wcy5jaGlsZHJlbjtcblx0aWYgKGMgJiYgQXJyYXkuaXNBcnJheShjKSAmJiBjLmxlbmd0aD09PTEgJiYgKHR5cGVvZiBjWzBdPT09J3N0cmluZycgfHwgdHlwZW9mIGNbMF09PT0nZnVuY3Rpb24nIHx8IGNbMF0gaW5zdGFuY2VvZiBWTm9kZSkpIHtcblx0XHRwcm9wcy5jaGlsZHJlbiA9IGNbMF07XG5cblx0XHQvLyBidXQgaXRzIHRvdGFsbHkgc3RpbGwgZ29pbmcgdG8gYmUgYW4gQXJyYXkuXG5cdFx0aWYgKHByb3BzLmNoaWxkcmVuICYmIHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdvYmplY3QnKSB7XG5cdFx0XHRwcm9wcy5jaGlsZHJlbi5sZW5ndGggPSAxO1xuXHRcdFx0cHJvcHMuY2hpbGRyZW5bMF0gPSBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH1cblxuXHQvLyBhZGQgcHJvcHR5cGUgY2hlY2tpbmdcblx0aWYgKERFVikge1xuXHRcdHZhciBjdG9yID0gdHlwZW9mIHRoaXM9PT0nZnVuY3Rpb24nID8gdGhpcyA6IHRoaXMuY29uc3RydWN0b3IsXG5cdFx0XHRwcm9wVHlwZXMgPSB0aGlzLnByb3BUeXBlcyB8fCBjdG9yLnByb3BUeXBlcztcblx0XHR2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZTtcblxuXHRcdGlmIChwcm9wVHlwZXMpIHtcblx0XHRcdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIGRpc3BsYXlOYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBiZWZvcmVSZW5kZXIocHJvcHMpIHtcblx0Y3VycmVudENvbXBvbmVudCA9IHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFmdGVyUmVuZGVyKCkge1xuXHRpZiAoY3VycmVudENvbXBvbmVudD09PXRoaXMpIHtcblx0XHRjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcblx0fVxufVxuXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50JDEocHJvcHMsIGNvbnRleHQsIG9wdHMpIHtcblx0Q29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDoge307XG5cdHRoaXMucmVmcyA9IHt9O1xuXHR0aGlzLl9yZWZQcm94aWVzID0ge307XG5cdGlmIChvcHRzIT09QllQQVNTX0hPT0spIHtcblx0XHRuZXdDb21wb25lbnRIb29rLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR9XG59XG5leHRlbmQoQ29tcG9uZW50JDEucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpLCB7XG5cdGNvbnN0cnVjdG9yOiBDb21wb25lbnQkMSxcblxuXHRpc1JlYWN0Q29tcG9uZW50OiB7fSxcblxuXHRyZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKHN0YXRlLCBjYWxsYmFjaykge1xuXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcyQxLnN0YXRlKSB7XG5cdFx0XHRpZiAoIShpIGluIHN0YXRlKSkge1xuXHRcdFx0XHRkZWxldGUgdGhpcyQxLnN0YXRlW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRET01Ob2RlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5iYXNlO1xuXHR9LFxuXG5cdGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5iYXNlO1xuXHR9XG59KTtcblxuXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0Q29tcG9uZW50JDEuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XG59XG5GLnByb3RvdHlwZSA9IENvbXBvbmVudCQxLnByb3RvdHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IEYoKTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKTtcbn07XG5cbnZhciBpbmRleCA9IHtcblx0dmVyc2lvbjogdmVyc2lvbixcblx0RE9NOiBET00sXG5cdFByb3BUeXBlczogUHJvcFR5cGVzLFxuXHRDaGlsZHJlbjogQ2hpbGRyZW4sXG5cdHJlbmRlcjogcmVuZGVyJDEsXG5cdGNyZWF0ZUNsYXNzOiBjcmVhdGVDbGFzcyxcblx0Y3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblx0Y2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQkMSxcblx0aXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXHRmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGU6IHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdENvbXBvbmVudDogQ29tcG9uZW50JDEsXG5cdFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG5cdHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcixcblx0X19zcHJlYWQ6IGV4dGVuZFxufTtcblxuZXhwb3J0IHsgdmVyc2lvbiwgRE9NLCBQcm9wVHlwZXMsIENoaWxkcmVuLCByZW5kZXIkMSBhcyByZW5kZXIsIGNyZWF0ZUNsYXNzLCBjcmVhdGVGYWN0b3J5LCBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQkMSBhcyBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50LCBmaW5kRE9NTm9kZSwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgQ29tcG9uZW50JDEgYXMgQ29tcG9uZW50LCBQdXJlQ29tcG9uZW50LCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciBhcyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgZXh0ZW5kIGFzIF9fc3ByZWFkIH07ZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QtY29tcGF0LmVzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3ByZWFjdC1jb21wYXQvZGlzdC9wcmVhY3QtY29tcGF0LmVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJlYWN0LWNvbXBhdC9kaXN0L3ByZWFjdC1jb21wYXQuZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFZpcnR1YWwgRE9NIE5vZGUgKi9cbmZ1bmN0aW9uIFZOb2RlKCkge31cblxuLyoqIEdsb2JhbCBvcHRpb25zXG4gKlx0QHB1YmxpY1xuICpcdEBuYW1lc3BhY2Ugb3B0aW9ucyB7T2JqZWN0fVxuICovXG52YXIgb3B0aW9ucyA9IHtcblxuXHQvKiogSWYgYHRydWVgLCBgcHJvcGAgY2hhbmdlcyB0cmlnZ2VyIHN5bmNocm9ub3VzIGNvbXBvbmVudCB1cGRhdGVzLlxuICAqXHRAbmFtZSBzeW5jQ29tcG9uZW50VXBkYXRlc1xuICAqXHRAdHlwZSBCb29sZWFuXG4gICpcdEBkZWZhdWx0IHRydWVcbiAgKi9cblx0Ly9zeW5jQ29tcG9uZW50VXBkYXRlczogdHJ1ZSxcblxuXHQvKiogUHJvY2Vzc2VzIGFsbCBjcmVhdGVkIFZOb2Rlcy5cbiAgKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdEEgbmV3bHktY3JlYXRlZCBWTm9kZSB0byBub3JtYWxpemUvcHJvY2Vzc1xuICAqL1xuXHQvL3Zub2RlKHZub2RlKSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGFmdGVyIGEgY29tcG9uZW50IGlzIG1vdW50ZWQuICovXG5cdC8vIGFmdGVyTW91bnQoY29tcG9uZW50KSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGFmdGVyIHRoZSBET00gaXMgdXBkYXRlZCB3aXRoIGEgY29tcG9uZW50J3MgbGF0ZXN0IHJlbmRlci4gKi9cblx0Ly8gYWZ0ZXJVcGRhdGUoY29tcG9uZW50KSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuICovXG5cdC8vIGJlZm9yZVVubW91bnQoY29tcG9uZW50KSB7IH1cbn07XG5cbnZhciBzdGFjayA9IFtdO1xuXG52YXIgRU1QVFlfQ0hJTERSRU4gPSBbXTtcblxuLyoqIEpTWC9oeXBlcnNjcmlwdCByZXZpdmVyXG4qXHRCZW5jaG1hcmtzOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3ZWU4ZjhlMzMwYWIwOTkwMGExYTFhMFxuICpcdEBzZWUgaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4XG4gKlx0QHB1YmxpY1xuICovXG5mdW5jdGlvbiBoKG5vZGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHZhciBjaGlsZHJlbiA9IEVNUFRZX0NISUxEUkVOLFxuXHQgICAgbGFzdFNpbXBsZSxcblx0ICAgIGNoaWxkLFxuXHQgICAgc2ltcGxlLFxuXHQgICAgaTtcblx0Zm9yIChpID0gYXJndW1lbnRzLmxlbmd0aDsgaS0tID4gMjspIHtcblx0XHRzdGFjay5wdXNoKGFyZ3VtZW50c1tpXSk7XG5cdH1cblx0aWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0aWYgKCFzdGFjay5sZW5ndGgpIHN0YWNrLnB1c2goYXR0cmlidXRlcy5jaGlsZHJlbik7XG5cdFx0ZGVsZXRlIGF0dHJpYnV0ZXMuY2hpbGRyZW47XG5cdH1cblx0d2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuXHRcdGlmICgoY2hpbGQgPSBzdGFjay5wb3AoKSkgJiYgY2hpbGQucG9wICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAoaSA9IGNoaWxkLmxlbmd0aDsgaS0tOykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGNoaWxkW2ldKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSBjaGlsZCA9IG51bGw7XG5cblx0XHRcdGlmIChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKGNoaWxkID09IG51bGwpIGNoaWxkID0gJyc7ZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykgY2hpbGQgPSBTdHJpbmcoY2hpbGQpO2Vsc2UgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycpIHNpbXBsZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2ltcGxlICYmIGxhc3RTaW1wbGUpIHtcblx0XHRcdFx0Y2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gKz0gY2hpbGQ7XG5cdFx0XHR9IGVsc2UgaWYgKGNoaWxkcmVuID09PSBFTVBUWV9DSElMRFJFTikge1xuXHRcdFx0XHRjaGlsZHJlbiA9IFtjaGlsZF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHRcdH1cblxuXHRcdFx0bGFzdFNpbXBsZSA9IHNpbXBsZTtcblx0XHR9XG5cdH1cblxuXHR2YXIgcCA9IG5ldyBWTm9kZSgpO1xuXHRwLm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cdHAuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0cC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXR0cmlidXRlcztcblx0cC5rZXkgPSBhdHRyaWJ1dGVzID09IG51bGwgPyB1bmRlZmluZWQgOiBhdHRyaWJ1dGVzLmtleTtcblxuXHQvLyBpZiBhIFwidm5vZGUgaG9va1wiIGlzIGRlZmluZWQsIHBhc3MgZXZlcnkgY3JlYXRlZCBWTm9kZSB0byBpdFxuXHRpZiAob3B0aW9ucy52bm9kZSAhPT0gdW5kZWZpbmVkKSBvcHRpb25zLnZub2RlKHApO1xuXG5cdHJldHVybiBwO1xufVxuXG4vKiogQ29weSBvd24tcHJvcGVydGllcyBmcm9tIGBwcm9wc2Agb250byBgb2JqYC5cbiAqXHRAcmV0dXJucyBvYmpcbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRlbmQob2JqLCBwcm9wcykge1xuICBmb3IgKHZhciBpIGluIHByb3BzKSB7XG4gICAgb2JqW2ldID0gcHJvcHNbaV07XG4gIH1yZXR1cm4gb2JqO1xufVxuXG4vKiogQ2FsbCBhIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5LCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICpcdEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbnZhciBkZWZlciA9IHR5cGVvZiBQcm9taXNlID09ICdmdW5jdGlvbicgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KHZub2RlLCBwcm9wcykge1xuXHRyZXR1cm4gaCh2bm9kZS5ub2RlTmFtZSwgZXh0ZW5kKGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyksIHByb3BzKSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiB2bm9kZS5jaGlsZHJlbik7XG59XG5cbi8vIERPTSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIE5PVCBoYXZlIFwicHhcIiBhZGRlZCB3aGVuIG51bWVyaWNcbnZhciBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcblxuLyoqIE1hbmFnZWQgcXVldWUgb2YgZGlydHkgY29tcG9uZW50cyB0byBiZSByZS1yZW5kZXJlZCAqL1xuXG52YXIgaXRlbXMgPSBbXTtcblxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpIHtcblx0aWYgKCFjb21wb25lbnQuX2RpcnR5ICYmIChjb21wb25lbnQuX2RpcnR5ID0gdHJ1ZSkgJiYgaXRlbXMucHVzaChjb21wb25lbnQpID09IDEpIHtcblx0XHQob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyB8fCBkZWZlcikocmVyZW5kZXIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyKCkge1xuXHR2YXIgcCxcblx0ICAgIGxpc3QgPSBpdGVtcztcblx0aXRlbXMgPSBbXTtcblx0d2hpbGUgKHAgPSBsaXN0LnBvcCgpKSB7XG5cdFx0aWYgKHAuX2RpcnR5KSByZW5kZXJDb21wb25lbnQocCk7XG5cdH1cbn1cblxuLyoqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgZXF1aXZhbGVudC5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqXHRAcGFyYW0ge1ZOb2RlfSB2bm9kZVxuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZU5vZGVUeXBlKG5vZGUsIHZub2RlLCBoeWRyYXRpbmcpIHtcblx0aWYgKHR5cGVvZiB2bm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZub2RlID09PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiBub2RlLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmICh0eXBlb2Ygdm5vZGUubm9kZU5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICFub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciAmJiBpc05hbWVkTm9kZShub2RlLCB2bm9kZS5ub2RlTmFtZSk7XG5cdH1cblx0cmV0dXJuIGh5ZHJhdGluZyB8fCBub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG59XG5cbi8qKiBDaGVjayBpZiBhbiBFbGVtZW50IGhhcyBhIGdpdmVuIG5vcm1hbGl6ZWQgbmFtZS5cbipcdEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuKlx0QHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGlzTmFtZWROb2RlKG5vZGUsIG5vZGVOYW1lKSB7XG5cdHJldHVybiBub2RlLm5vcm1hbGl6ZWROb2RlTmFtZSA9PT0gbm9kZU5hbWUgfHwgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIFJlY29uc3RydWN0IENvbXBvbmVudC1zdHlsZSBgcHJvcHNgIGZyb20gYSBWTm9kZS5cbiAqIEVuc3VyZXMgZGVmYXVsdC9mYWxsYmFjayB2YWx1ZXMgZnJvbSBgZGVmYXVsdFByb3BzYDpcbiAqIE93bi1wcm9wZXJ0aWVzIG9mIGBkZWZhdWx0UHJvcHNgIG5vdCBwcmVzZW50IGluIGB2bm9kZS5hdHRyaWJ1dGVzYCBhcmUgYWRkZWQuXG4gKiBAcGFyYW0ge1ZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge09iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKHZub2RlKSB7XG5cdHZhciBwcm9wcyA9IGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyk7XG5cdHByb3BzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cblx0dmFyIGRlZmF1bHRQcm9wcyA9IHZub2RlLm5vZGVOYW1lLmRlZmF1bHRQcm9wcztcblx0aWYgKGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiBkZWZhdWx0UHJvcHMpIHtcblx0XHRcdGlmIChwcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHByb3BzW2ldID0gZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwcm9wcztcbn1cblxuLyoqIENyZWF0ZSBhbiBlbGVtZW50IHdpdGggdGhlIGdpdmVuIG5vZGVOYW1lLlxuICpcdEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gW2lzU3ZnPWZhbHNlXVx0SWYgYHRydWVgLCBjcmVhdGVzIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBTVkcgbmFtZXNwYWNlLlxuICpcdEByZXR1cm5zIHtFbGVtZW50fSBub2RlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUobm9kZU5hbWUsIGlzU3ZnKSB7XG5cdHZhciBub2RlID0gaXNTdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbm9kZU5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG5cdG5vZGUubm9ybWFsaXplZE5vZGVOYW1lID0gbm9kZU5hbWU7XG5cdHJldHVybiBub2RlO1xufVxuXG4vKiogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuXG4gKlx0QHBhcmFtIHtFbGVtZW50fSBub2RlXHRcdFRoZSBub2RlIHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0dmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG4vKiogU2V0IGEgbmFtZWQgYXR0cmlidXRlIG9uIHRoZSBnaXZlbiBOb2RlLCB3aXRoIHNwZWNpYWwgYmVoYXZpb3IgZm9yIHNvbWUgbmFtZXMgYW5kIGV2ZW50IGhhbmRsZXJzLlxuICpcdElmIGB2YWx1ZWAgaXMgYG51bGxgLCB0aGUgYXR0cmlidXRlL2hhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gbm9kZVx0QW4gZWxlbWVudCB0byBtdXRhdGVcbiAqXHRAcGFyYW0ge3N0cmluZ30gbmFtZVx0VGhlIG5hbWUva2V5IHRvIHNldCwgc3VjaCBhcyBhbiBldmVudCBvciBhdHRyaWJ1dGUgbmFtZVxuICpcdEBwYXJhbSB7YW55fSBvbGRcdFRoZSBsYXN0IHZhbHVlIHRoYXQgd2FzIHNldCBmb3IgdGhpcyBuYW1lL25vZGUgcGFpclxuICpcdEBwYXJhbSB7YW55fSB2YWx1ZVx0QW4gYXR0cmlidXRlIHZhbHVlLCBzdWNoIGFzIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBhcyBhbiBldmVudCBoYW5kbGVyXG4gKlx0QHBhcmFtIHtCb29sZWFufSBpc1N2Z1x0QXJlIHdlIGN1cnJlbnRseSBkaWZmaW5nIGluc2lkZSBhbiBzdmc/XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0QWNjZXNzb3Iobm9kZSwgbmFtZSwgb2xkLCB2YWx1ZSwgaXNTdmcpIHtcblx0aWYgKG5hbWUgPT09ICdjbGFzc05hbWUnKSBuYW1lID0gJ2NsYXNzJztcblxuXHRpZiAobmFtZSA9PT0gJ2tleScpIHtcblx0XHQvLyBpZ25vcmVcblx0fSBlbHNlIGlmIChuYW1lID09PSAncmVmJykge1xuXHRcdGlmIChvbGQpIG9sZChudWxsKTtcblx0XHRpZiAodmFsdWUpIHZhbHVlKG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIWlzU3ZnKSB7XG5cdFx0bm9kZS5jbGFzc05hbWUgPSB2YWx1ZSB8fCAnJztcblx0fSBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvbGQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRub2RlLnN0eWxlLmNzc1RleHQgPSB2YWx1ZSB8fCAnJztcblx0XHR9XG5cdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGkgaW4gdmFsdWUpKSBub2RlLnN0eWxlW2ldID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0bm9kZS5zdHlsZVtpXSA9IHR5cGVvZiB2YWx1ZVtpXSA9PT0gJ251bWJlcicgJiYgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3QoaSkgPT09IGZhbHNlID8gdmFsdWVbaV0gKyAncHgnIDogdmFsdWVbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAodmFsdWUpIG5vZGUuaW5uZXJIVE1MID0gdmFsdWUuX19odG1sIHx8ICcnO1xuXHR9IGVsc2UgaWYgKG5hbWVbMF0gPT0gJ28nICYmIG5hbWVbMV0gPT0gJ24nKSB7XG5cdFx0dmFyIHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGQpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50UHJveHksIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0XHQobm9kZS5fbGlzdGVuZXJzIHx8IChub2RlLl9saXN0ZW5lcnMgPSB7fSkpW25hbWVdID0gdmFsdWU7XG5cdH0gZWxzZSBpZiAobmFtZSAhPT0gJ2xpc3QnICYmIG5hbWUgIT09ICd0eXBlJyAmJiAhaXNTdmcgJiYgbmFtZSBpbiBub2RlKSB7XG5cdFx0c2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIG5zID0gaXNTdmcgJiYgbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpO1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0aWYgKG5zKSBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgbmFtZS50b0xvd2VyQ2FzZSgpKTtlbHNlIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZiAobnMpIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtlbHNlIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIEF0dGVtcHQgdG8gc2V0IGEgRE9NIHByb3BlcnR5IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXHRJRSAmIEZGIHRocm93IGZvciBjZXJ0YWluIHByb3BlcnR5LXZhbHVlIGNvbWJpbmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcblx0dHJ5IHtcblx0XHRub2RlW25hbWVdID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8qKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGVdKG9wdGlvbnMuZXZlbnQgJiYgb3B0aW9ucy5ldmVudChlKSB8fCBlKTtcbn1cblxuLyoqIFF1ZXVlIG9mIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gbW91bnRlZCBhbmQgYXJlIGF3YWl0aW5nIGNvbXBvbmVudERpZE1vdW50ICovXG52YXIgbW91bnRzID0gW107XG5cbi8qKiBEaWZmIHJlY3Vyc2lvbiBjb3VudCwgdXNlZCB0byB0cmFjayB0aGUgZW5kIG9mIHRoZSBkaWZmIGN5Y2xlLiAqL1xudmFyIGRpZmZMZXZlbCA9IDA7XG5cbi8qKiBHbG9iYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBkaWZmIGlzIGN1cnJlbnRseSB3aXRoaW4gYW4gU1ZHICovXG52YXIgaXNTdmdNb2RlID0gZmFsc2U7XG5cbi8qKiBHbG9iYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBkaWZmIGlzIHBlcmZvcm1pbmcgaHlkcmF0aW9uICovXG52YXIgaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKiBJbnZva2UgcXVldWVkIGNvbXBvbmVudERpZE1vdW50IGxpZmVjeWNsZSBtZXRob2RzICovXG5mdW5jdGlvbiBmbHVzaE1vdW50cygpIHtcblx0dmFyIGM7XG5cdHdoaWxlIChjID0gbW91bnRzLnBvcCgpKSB7XG5cdFx0aWYgKG9wdGlvbnMuYWZ0ZXJNb3VudCkgb3B0aW9ucy5hZnRlck1vdW50KGMpO1xuXHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50KSBjLmNvbXBvbmVudERpZE1vdW50KCk7XG5cdH1cbn1cblxuLyoqIEFwcGx5IGRpZmZlcmVuY2VzIGluIGEgZ2l2ZW4gdm5vZGUgKGFuZCBpdCdzIGRlZXAgY2hpbGRyZW4pIHRvIGEgcmVhbCBET00gTm9kZS5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IFtkb209bnVsbF1cdFx0QSBET00gbm9kZSB0byBtdXRhdGUgaW50byB0aGUgc2hhcGUgb2YgdGhlIGB2bm9kZWBcbiAqXHRAcGFyYW0ge1ZOb2RlfSB2bm9kZVx0XHRcdEEgVk5vZGUgKHdpdGggZGVzY2VuZGFudHMgZm9ybWluZyBhIHRyZWUpIHJlcHJlc2VudGluZyB0aGUgZGVzaXJlZCBET00gc3RydWN0dXJlXG4gKlx0QHJldHVybnMge0VsZW1lbnR9IGRvbVx0XHRcdFRoZSBjcmVhdGVkL211dGF0ZWQgZWxlbWVudFxuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIHBhcmVudCwgY29tcG9uZW50Um9vdCkge1xuXHQvLyBkaWZmTGV2ZWwgaGF2aW5nIGJlZW4gMCBoZXJlIGluZGljYXRlcyBpbml0aWFsIGVudHJ5IGludG8gdGhlIGRpZmYgKG5vdCBhIHN1YmRpZmYpXG5cdGlmICghZGlmZkxldmVsKyspIHtcblx0XHQvLyB3aGVuIGZpcnN0IHN0YXJ0aW5nIHRoZSBkaWZmLCBjaGVjayBpZiB3ZSdyZSBkaWZmaW5nIGFuIFNWRyBvciB3aXRoaW4gYW4gU1ZHXG5cdFx0aXNTdmdNb2RlID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0Ly8gaHlkcmF0aW9uIGlzIGluZGljYXRlZCBieSB0aGUgZXhpc3RpbmcgZWxlbWVudCB0byBiZSBkaWZmZWQgbm90IGhhdmluZyBhIHByb3AgY2FjaGVcblx0XHRoeWRyYXRpbmcgPSBkb20gIT0gbnVsbCAmJiAhKCdfX3ByZWFjdGF0dHJfJyBpbiBkb20pO1xuXHR9XG5cblx0dmFyIHJldCA9IGlkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBjb21wb25lbnRSb290KTtcblxuXHQvLyBhcHBlbmQgdGhlIGVsZW1lbnQgaWYgaXRzIGEgbmV3IHBhcmVudFxuXHRpZiAocGFyZW50ICYmIHJldC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChyZXQpO1xuXG5cdC8vIGRpZmZMZXZlbCBiZWluZyByZWR1Y2VkIHRvIDAgbWVhbnMgd2UncmUgZXhpdGluZyB0aGUgZGlmZlxuXHRpZiAoISAtLWRpZmZMZXZlbCkge1xuXHRcdGh5ZHJhdGluZyA9IGZhbHNlO1xuXHRcdC8vIGludm9rZSBxdWV1ZWQgY29tcG9uZW50RGlkTW91bnQgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRpZiAoIWNvbXBvbmVudFJvb3QpIGZsdXNoTW91bnRzKCk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG4vKiogSW50ZXJuYWxzIG9mIGBkaWZmKClgLCBzZXBhcmF0ZWQgdG8gYWxsb3cgYnlwYXNzaW5nIGRpZmZMZXZlbCAvIG1vdW50IGZsdXNoaW5nLiAqL1xuZnVuY3Rpb24gaWRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIGNvbXBvbmVudFJvb3QpIHtcblx0dmFyIG91dCA9IGRvbSxcblx0ICAgIHByZXZTdmdNb2RlID0gaXNTdmdNb2RlO1xuXG5cdC8vIGVtcHR5IHZhbHVlcyAobnVsbCwgdW5kZWZpbmVkLCBib29sZWFucykgcmVuZGVyIGFzIGVtcHR5IFRleHQgbm9kZXNcblx0aWYgKHZub2RlID09IG51bGwgfHwgdHlwZW9mIHZub2RlID09PSAnYm9vbGVhbicpIHZub2RlID0gJyc7XG5cblx0Ly8gRmFzdCBjYXNlOiBTdHJpbmdzICYgTnVtYmVycyBjcmVhdGUvdXBkYXRlIFRleHQgbm9kZXMuXG5cdGlmICh0eXBlb2Ygdm5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2bm9kZSA9PT0gJ251bWJlcicpIHtcblxuXHRcdC8vIHVwZGF0ZSBpZiBpdCdzIGFscmVhZHkgYSBUZXh0IG5vZGU6XG5cdFx0aWYgKGRvbSAmJiBkb20uc3BsaXRUZXh0ICE9PSB1bmRlZmluZWQgJiYgZG9tLnBhcmVudE5vZGUgJiYgKCFkb20uX2NvbXBvbmVudCB8fCBjb21wb25lbnRSb290KSkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovIC8qIEJyb3dzZXIgcXVpcmsgdGhhdCBjYW4ndCBiZSBjb3ZlcmVkOiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9jb21taXQvZmQ0ZjIxZjVjNDVkZmQ3NTE1MWJkMjdiNGMyMTdkODAwM2FhNWViOSAqL1xuXHRcdFx0aWYgKGRvbS5ub2RlVmFsdWUgIT0gdm5vZGUpIHtcblx0XHRcdFx0ZG9tLm5vZGVWYWx1ZSA9IHZub2RlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpdCB3YXNuJ3QgYSBUZXh0IG5vZGU6IHJlcGxhY2UgaXQgd2l0aCBvbmUgYW5kIHJlY3ljbGUgdGhlIG9sZCBFbGVtZW50XG5cdFx0XHRvdXQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZSk7XG5cdFx0XHRpZiAoZG9tKSB7XG5cdFx0XHRcdGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcblx0XHRcdFx0cmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdXRbJ19fcHJlYWN0YXR0cl8nXSA9IHRydWU7XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0Ly8gSWYgdGhlIFZOb2RlIHJlcHJlc2VudHMgYSBDb21wb25lbnQsIHBlcmZvcm0gYSBjb21wb25lbnQgZGlmZjpcblx0dmFyIHZub2RlTmFtZSA9IHZub2RlLm5vZGVOYW1lO1xuXHRpZiAodHlwZW9mIHZub2RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBidWlsZENvbXBvbmVudEZyb21WTm9kZShkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdH1cblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aXNTdmdNb2RlID0gdm5vZGVOYW1lID09PSAnc3ZnJyA/IHRydWUgOiB2bm9kZU5hbWUgPT09ICdmb3JlaWduT2JqZWN0JyA/IGZhbHNlIDogaXNTdmdNb2RlO1xuXG5cdC8vIElmIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgZWxlbWVudCBvciBpdCdzIHRoZSB3cm9uZyB0eXBlLCBjcmVhdGUgYSBuZXcgb25lOlxuXHR2bm9kZU5hbWUgPSBTdHJpbmcodm5vZGVOYW1lKTtcblx0aWYgKCFkb20gfHwgIWlzTmFtZWROb2RlKGRvbSwgdm5vZGVOYW1lKSkge1xuXHRcdG91dCA9IGNyZWF0ZU5vZGUodm5vZGVOYW1lLCBpc1N2Z01vZGUpO1xuXG5cdFx0aWYgKGRvbSkge1xuXHRcdFx0Ly8gbW92ZSBjaGlsZHJlbiBpbnRvIHRoZSByZXBsYWNlbWVudCBub2RlXG5cdFx0XHR3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0b3V0LmFwcGVuZENoaWxkKGRvbS5maXJzdENoaWxkKTtcblx0XHRcdH0gLy8gaWYgdGhlIHByZXZpb3VzIEVsZW1lbnQgd2FzIG1vdW50ZWQgaW50byB0aGUgRE9NLCByZXBsYWNlIGl0IGlubGluZVxuXHRcdFx0aWYgKGRvbS5wYXJlbnROb2RlKSBkb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQob3V0LCBkb20pO1xuXG5cdFx0XHQvLyByZWN5Y2xlIHRoZSBvbGQgZWxlbWVudCAoc2tpcHMgbm9uLUVsZW1lbnQgbm9kZSB0eXBlcylcblx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGZjID0gb3V0LmZpcnN0Q2hpbGQsXG5cdCAgICBwcm9wcyA9IG91dFsnX19wcmVhY3RhdHRyXyddLFxuXHQgICAgdmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cblx0aWYgKHByb3BzID09IG51bGwpIHtcblx0XHRwcm9wcyA9IG91dFsnX19wcmVhY3RhdHRyXyddID0ge307XG5cdFx0Zm9yICh2YXIgYSA9IG91dC5hdHRyaWJ1dGVzLCBpID0gYS5sZW5ndGg7IGktLTspIHtcblx0XHRcdHByb3BzW2FbaV0ubmFtZV0gPSBhW2ldLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8vIE9wdGltaXphdGlvbjogZmFzdC1wYXRoIGZvciBlbGVtZW50cyBjb250YWluaW5nIGEgc2luZ2xlIFRleHROb2RlOlxuXHRpZiAoIWh5ZHJhdGluZyAmJiB2Y2hpbGRyZW4gJiYgdmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmNoaWxkcmVuWzBdID09PSAnc3RyaW5nJyAmJiBmYyAhPSBudWxsICYmIGZjLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkICYmIGZjLm5leHRTaWJsaW5nID09IG51bGwpIHtcblx0XHRpZiAoZmMubm9kZVZhbHVlICE9IHZjaGlsZHJlblswXSkge1xuXHRcdFx0ZmMubm9kZVZhbHVlID0gdmNoaWxkcmVuWzBdO1xuXHRcdH1cblx0fVxuXHQvLyBvdGhlcndpc2UsIGlmIHRoZXJlIGFyZSBleGlzdGluZyBvciBuZXcgY2hpbGRyZW4sIGRpZmYgdGhlbTpcblx0ZWxzZSBpZiAodmNoaWxkcmVuICYmIHZjaGlsZHJlbi5sZW5ndGggfHwgZmMgIT0gbnVsbCkge1xuXHRcdFx0aW5uZXJEaWZmTm9kZShvdXQsIHZjaGlsZHJlbiwgY29udGV4dCwgbW91bnRBbGwsIGh5ZHJhdGluZyB8fCBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKTtcblx0XHR9XG5cblx0Ly8gQXBwbHkgYXR0cmlidXRlcy9wcm9wcyBmcm9tIFZOb2RlIHRvIHRoZSBET00gRWxlbWVudDpcblx0ZGlmZkF0dHJpYnV0ZXMob3V0LCB2bm9kZS5hdHRyaWJ1dGVzLCBwcm9wcyk7XG5cblx0Ly8gcmVzdG9yZSBwcmV2aW91cyBTVkcgbW9kZTogKGluIGNhc2Ugd2UncmUgZXhpdGluZyBhbiBTVkcgbmFtZXNwYWNlKVxuXHRpc1N2Z01vZGUgPSBwcmV2U3ZnTW9kZTtcblxuXHRyZXR1cm4gb3V0O1xufVxuXG4vKiogQXBwbHkgY2hpbGQgYW5kIGF0dHJpYnV0ZSBjaGFuZ2VzIGJldHdlZW4gYSBWTm9kZSBhbmQgYSBET00gTm9kZSB0byB0aGUgRE9NLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRcdFx0RWxlbWVudCB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgY29tcGFyZWQgJiBtdXRhdGVkXG4gKlx0QHBhcmFtIHtBcnJheX0gdmNoaWxkcmVuXHRcdEFycmF5IG9mIFZOb2RlcyB0byBjb21wYXJlIHRvIGBkb20uY2hpbGROb2Rlc2BcbiAqXHRAcGFyYW0ge09iamVjdH0gY29udGV4dFx0XHRcdEltcGxpY2l0bHkgZGVzY2VuZGFudCBjb250ZXh0IG9iamVjdCAoZnJvbSBtb3N0IHJlY2VudCBgZ2V0Q2hpbGRDb250ZXh0KClgKVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gbW91bnRBbGxcbiAqXHRAcGFyYW0ge0Jvb2xlYW59IGlzSHlkcmF0aW5nXHRJZiBgdHJ1ZWAsIGNvbnN1bWVzIGV4dGVybmFsbHkgY3JlYXRlZCBlbGVtZW50cyBzaW1pbGFyIHRvIGh5ZHJhdGlvblxuICovXG5mdW5jdGlvbiBpbm5lckRpZmZOb2RlKGRvbSwgdmNoaWxkcmVuLCBjb250ZXh0LCBtb3VudEFsbCwgaXNIeWRyYXRpbmcpIHtcblx0dmFyIG9yaWdpbmFsQ2hpbGRyZW4gPSBkb20uY2hpbGROb2Rlcyxcblx0ICAgIGNoaWxkcmVuID0gW10sXG5cdCAgICBrZXllZCA9IHt9LFxuXHQgICAga2V5ZWRMZW4gPSAwLFxuXHQgICAgbWluID0gMCxcblx0ICAgIGxlbiA9IG9yaWdpbmFsQ2hpbGRyZW4ubGVuZ3RoLFxuXHQgICAgY2hpbGRyZW5MZW4gPSAwLFxuXHQgICAgdmxlbiA9IHZjaGlsZHJlbiA/IHZjaGlsZHJlbi5sZW5ndGggOiAwLFxuXHQgICAgaixcblx0ICAgIGMsXG5cdCAgICBmLFxuXHQgICAgdmNoaWxkLFxuXHQgICAgY2hpbGQ7XG5cblx0Ly8gQnVpbGQgdXAgYSBtYXAgb2Yga2V5ZWQgY2hpbGRyZW4gYW5kIGFuIEFycmF5IG9mIHVua2V5ZWQgY2hpbGRyZW46XG5cdGlmIChsZW4gIT09IDApIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgX2NoaWxkID0gb3JpZ2luYWxDaGlsZHJlbltpXSxcblx0XHRcdCAgICBwcm9wcyA9IF9jaGlsZFsnX19wcmVhY3RhdHRyXyddLFxuXHRcdFx0ICAgIGtleSA9IHZsZW4gJiYgcHJvcHMgPyBfY2hpbGQuX2NvbXBvbmVudCA/IF9jaGlsZC5fY29tcG9uZW50Ll9fa2V5IDogcHJvcHMua2V5IDogbnVsbDtcblx0XHRcdGlmIChrZXkgIT0gbnVsbCkge1xuXHRcdFx0XHRrZXllZExlbisrO1xuXHRcdFx0XHRrZXllZFtrZXldID0gX2NoaWxkO1xuXHRcdFx0fSBlbHNlIGlmIChwcm9wcyB8fCAoX2NoaWxkLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkID8gaXNIeWRyYXRpbmcgPyBfY2hpbGQubm9kZVZhbHVlLnRyaW0oKSA6IHRydWUgOiBpc0h5ZHJhdGluZykpIHtcblx0XHRcdFx0Y2hpbGRyZW5bY2hpbGRyZW5MZW4rK10gPSBfY2hpbGQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKHZsZW4gIT09IDApIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuXHRcdFx0dmNoaWxkID0gdmNoaWxkcmVuW2ldO1xuXHRcdFx0Y2hpbGQgPSBudWxsO1xuXG5cdFx0XHQvLyBhdHRlbXB0IHRvIGZpbmQgYSBub2RlIGJhc2VkIG9uIGtleSBtYXRjaGluZ1xuXHRcdFx0dmFyIGtleSA9IHZjaGlsZC5rZXk7XG5cdFx0XHRpZiAoa2V5ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGtleWVkTGVuICYmIGtleWVkW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNoaWxkID0ga2V5ZWRba2V5XTtcblx0XHRcdFx0XHRrZXllZFtrZXldID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGtleWVkTGVuLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGF0dGVtcHQgdG8gcGx1Y2sgYSBub2RlIG9mIHRoZSBzYW1lIHR5cGUgZnJvbSB0aGUgZXhpc3RpbmcgY2hpbGRyZW5cblx0XHRcdGVsc2UgaWYgKCFjaGlsZCAmJiBtaW4gPCBjaGlsZHJlbkxlbikge1xuXHRcdFx0XHRcdGZvciAoaiA9IG1pbjsgaiA8IGNoaWxkcmVuTGVuOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZHJlbltqXSAhPT0gdW5kZWZpbmVkICYmIGlzU2FtZU5vZGVUeXBlKGMgPSBjaGlsZHJlbltqXSwgdmNoaWxkLCBpc0h5ZHJhdGluZykpIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBjO1xuXHRcdFx0XHRcdFx0XHRjaGlsZHJlbltqXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0aWYgKGogPT09IGNoaWxkcmVuTGVuIC0gMSkgY2hpbGRyZW5MZW4tLTtcblx0XHRcdFx0XHRcdFx0aWYgKGogPT09IG1pbikgbWluKys7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBtb3JwaCB0aGUgbWF0Y2hlZC9mb3VuZC9jcmVhdGVkIERPTSBjaGlsZCB0byBtYXRjaCB2Y2hpbGQgKGRlZXApXG5cdFx0XHRjaGlsZCA9IGlkaWZmKGNoaWxkLCB2Y2hpbGQsIGNvbnRleHQsIG1vdW50QWxsKTtcblxuXHRcdFx0ZiA9IG9yaWdpbmFsQ2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgJiYgY2hpbGQgIT09IGRvbSAmJiBjaGlsZCAhPT0gZikge1xuXHRcdFx0XHRpZiAoZiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZG9tLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaGlsZCA9PT0gZi5uZXh0U2libGluZykge1xuXHRcdFx0XHRcdHJlbW92ZU5vZGUoZik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9tLmluc2VydEJlZm9yZShjaGlsZCwgZik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyByZW1vdmUgdW51c2VkIGtleWVkIGNoaWxkcmVuOlxuXHRpZiAoa2V5ZWRMZW4pIHtcblx0XHRmb3IgKHZhciBpIGluIGtleWVkKSB7XG5cdFx0XHRpZiAoa2V5ZWRbaV0gIT09IHVuZGVmaW5lZCkgcmVjb2xsZWN0Tm9kZVRyZWUoa2V5ZWRbaV0sIGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHQvLyByZW1vdmUgb3JwaGFuZWQgdW5rZXllZCBjaGlsZHJlbjpcblx0d2hpbGUgKG1pbiA8PSBjaGlsZHJlbkxlbikge1xuXHRcdGlmICgoY2hpbGQgPSBjaGlsZHJlbltjaGlsZHJlbkxlbi0tXSkgIT09IHVuZGVmaW5lZCkgcmVjb2xsZWN0Tm9kZVRyZWUoY2hpbGQsIGZhbHNlKTtcblx0fVxufVxuXG4vKiogUmVjdXJzaXZlbHkgcmVjeWNsZSAob3IganVzdCB1bm1vdW50KSBhIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cy5cbiAqXHRAcGFyYW0ge05vZGV9IG5vZGVcdFx0XHRcdFx0XHRET00gbm9kZSB0byBzdGFydCB1bm1vdW50L3JlbW92YWwgZnJvbVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gW3VubW91bnRPbmx5PWZhbHNlXVx0SWYgYHRydWVgLCBvbmx5IHRyaWdnZXJzIHVubW91bnQgbGlmZWN5Y2xlLCBza2lwcyByZW1vdmFsXG4gKi9cbmZ1bmN0aW9uIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsIHVubW91bnRPbmx5KSB7XG5cdHZhciBjb21wb25lbnQgPSBub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjb21wb25lbnQpIHtcblx0XHQvLyBpZiBub2RlIGlzIG93bmVkIGJ5IGEgQ29tcG9uZW50LCB1bm1vdW50IHRoYXQgY29tcG9uZW50IChlbmRzIHVwIHJlY3Vyc2luZyBiYWNrIGhlcmUpXG5cdFx0dW5tb3VudENvbXBvbmVudChjb21wb25lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSBub2RlJ3MgVk5vZGUgaGFkIGEgcmVmIGZ1bmN0aW9uLCBpbnZva2UgaXQgd2l0aCBudWxsIGhlcmUuXG5cdFx0Ly8gKHRoaXMgaXMgcGFydCBvZiB0aGUgUmVhY3Qgc3BlYywgYW5kIHNtYXJ0IGZvciB1bnNldHRpbmcgcmVmZXJlbmNlcylcblx0XHRpZiAobm9kZVsnX19wcmVhY3RhdHRyXyddICE9IG51bGwgJiYgbm9kZVsnX19wcmVhY3RhdHRyXyddLnJlZikgbm9kZVsnX19wcmVhY3RhdHRyXyddLnJlZihudWxsKTtcblxuXHRcdGlmICh1bm1vdW50T25seSA9PT0gZmFsc2UgfHwgbm9kZVsnX19wcmVhY3RhdHRyXyddID09IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUobm9kZSk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlQ2hpbGRyZW4obm9kZSk7XG5cdH1cbn1cblxuLyoqIFJlY29sbGVjdC91bm1vdW50IGFsbCBjaGlsZHJlbi5cbiAqXHQtIHdlIHVzZSAubGFzdENoaWxkIGhlcmUgYmVjYXVzZSBpdCBjYXVzZXMgbGVzcyByZWZsb3cgdGhhbiAuZmlyc3RDaGlsZFxuICpcdC0gaXQncyBhbHNvIGNoZWFwZXIgdGhhbiBhY2Nlc3NpbmcgdGhlIC5jaGlsZE5vZGVzIExpdmUgTm9kZUxpc3RcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuXHRub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0dmFyIG5leHQgPSBub2RlLnByZXZpb3VzU2libGluZztcblx0XHRyZWNvbGxlY3ROb2RlVHJlZShub2RlLCB0cnVlKTtcblx0XHRub2RlID0gbmV4dDtcblx0fVxufVxuXG4vKiogQXBwbHkgZGlmZmVyZW5jZXMgaW4gYXR0cmlidXRlcyBmcm9tIGEgVk5vZGUgdG8gdGhlIGdpdmVuIERPTSBFbGVtZW50LlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRcdEVsZW1lbnQgd2l0aCBhdHRyaWJ1dGVzIHRvIGRpZmYgYGF0dHJzYCBhZ2FpbnN0XG4gKlx0QHBhcmFtIHtPYmplY3R9IGF0dHJzXHRcdFRoZSBkZXNpcmVkIGVuZC1zdGF0ZSBrZXktdmFsdWUgYXR0cmlidXRlIHBhaXJzXG4gKlx0QHBhcmFtIHtPYmplY3R9IG9sZFx0XHRcdEN1cnJlbnQvcHJldmlvdXMgYXR0cmlidXRlcyAoZnJvbSBwcmV2aW91cyBWTm9kZSBvciBlbGVtZW50J3MgcHJvcCBjYWNoZSlcbiAqL1xuZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMoZG9tLCBhdHRycywgb2xkKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIHJlbW92ZSBhdHRyaWJ1dGVzIG5vIGxvbmdlciBwcmVzZW50IG9uIHRoZSB2bm9kZSBieSBzZXR0aW5nIHRoZW0gdG8gdW5kZWZpbmVkXG5cdGZvciAobmFtZSBpbiBvbGQpIHtcblx0XHRpZiAoIShhdHRycyAmJiBhdHRyc1tuYW1lXSAhPSBudWxsKSAmJiBvbGRbbmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0c2V0QWNjZXNzb3IoZG9tLCBuYW1lLCBvbGRbbmFtZV0sIG9sZFtuYW1lXSA9IHVuZGVmaW5lZCwgaXNTdmdNb2RlKTtcblx0XHR9XG5cdH1cblxuXHQvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuXHRmb3IgKG5hbWUgaW4gYXR0cnMpIHtcblx0XHRpZiAobmFtZSAhPT0gJ2NoaWxkcmVuJyAmJiBuYW1lICE9PSAnaW5uZXJIVE1MJyAmJiAoIShuYW1lIGluIG9sZCkgfHwgYXR0cnNbbmFtZV0gIT09IChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdjaGVja2VkJyA/IGRvbVtuYW1lXSA6IG9sZFtuYW1lXSkpKSB7XG5cdFx0XHRzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gYXR0cnNbbmFtZV0sIGlzU3ZnTW9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKiBSZXRhaW5zIGEgcG9vbCBvZiBDb21wb25lbnRzIGZvciByZS11c2UsIGtleWVkIG9uIGNvbXBvbmVudCBuYW1lLlxuICpcdE5vdGU6IHNpbmNlIGNvbXBvbmVudCBuYW1lcyBhcmUgbm90IHVuaXF1ZSBvciBldmVuIG5lY2Vzc2FyaWx5IGF2YWlsYWJsZSwgdGhlc2UgYXJlIHByaW1hcmlseSBhIGZvcm0gb2Ygc2hhcmRpbmcuXG4gKlx0QHByaXZhdGVcbiAqL1xudmFyIGNvbXBvbmVudHMgPSB7fTtcblxuLyoqIFJlY2xhaW0gYSBjb21wb25lbnQgZm9yIGxhdGVyIHJlLXVzZSBieSB0aGUgcmVjeWNsZXIuICovXG5mdW5jdGlvbiBjb2xsZWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuXHR2YXIgbmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuXHQoY29tcG9uZW50c1tuYW1lXSB8fCAoY29tcG9uZW50c1tuYW1lXSA9IFtdKSkucHVzaChjb21wb25lbnQpO1xufVxuXG4vKiogQ3JlYXRlIGEgY29tcG9uZW50LiBOb3JtYWxpemVzIGRpZmZlcmVuY2VzIGJldHdlZW4gUEZDJ3MgYW5kIGNsYXNzZnVsIENvbXBvbmVudHMuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ3RvciwgcHJvcHMsIGNvbnRleHQpIHtcblx0dmFyIGxpc3QgPSBjb21wb25lbnRzW0N0b3IubmFtZV0sXG5cdCAgICBpbnN0O1xuXG5cdGlmIChDdG9yLnByb3RvdHlwZSAmJiBDdG9yLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRpbnN0ID0gbmV3IEN0b3IocHJvcHMsIGNvbnRleHQpO1xuXHRcdENvbXBvbmVudC5jYWxsKGluc3QsIHByb3BzLCBjb250ZXh0KTtcblx0fSBlbHNlIHtcblx0XHRpbnN0ID0gbmV3IENvbXBvbmVudChwcm9wcywgY29udGV4dCk7XG5cdFx0aW5zdC5jb25zdHJ1Y3RvciA9IEN0b3I7XG5cdFx0aW5zdC5yZW5kZXIgPSBkb1JlbmRlcjtcblx0fVxuXG5cdGlmIChsaXN0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07KSB7XG5cdFx0XHRpZiAobGlzdFtpXS5jb25zdHJ1Y3RvciA9PT0gQ3Rvcikge1xuXHRcdFx0XHRpbnN0Lm5leHRCYXNlID0gbGlzdFtpXS5uZXh0QmFzZTtcblx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gaW5zdDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuXG4vKiogU2V0IGEgY29tcG9uZW50J3MgYHByb3BzYCAoZ2VuZXJhbGx5IGRlcml2ZWQgZnJvbSBKU1ggYXR0cmlidXRlcykuXG4gKlx0QHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKlx0QHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucmVuZGVyU3luYz1mYWxzZV1cdElmIGB0cnVlYCBhbmQge0BsaW5rIG9wdGlvbnMuc3luY0NvbXBvbmVudFVwZGF0ZXN9IGlzIGB0cnVlYCwgdHJpZ2dlcnMgc3luY2hyb25vdXMgcmVuZGVyaW5nLlxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucmVuZGVyPXRydWVdXHRcdFx0SWYgYGZhbHNlYCwgbm8gcmVuZGVyIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICovXG5mdW5jdGlvbiBzZXRDb21wb25lbnRQcm9wcyhjb21wb25lbnQsIHByb3BzLCBvcHRzLCBjb250ZXh0LCBtb3VudEFsbCkge1xuXHRpZiAoY29tcG9uZW50Ll9kaXNhYmxlKSByZXR1cm47XG5cdGNvbXBvbmVudC5fZGlzYWJsZSA9IHRydWU7XG5cblx0aWYgKGNvbXBvbmVudC5fX3JlZiA9IHByb3BzLnJlZikgZGVsZXRlIHByb3BzLnJlZjtcblx0aWYgKGNvbXBvbmVudC5fX2tleSA9IHByb3BzLmtleSkgZGVsZXRlIHByb3BzLmtleTtcblxuXHRpZiAoIWNvbXBvbmVudC5iYXNlIHx8IG1vdW50QWxsKSB7XG5cdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0fSBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuXHRcdGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzLCBjb250ZXh0KTtcblx0fVxuXG5cdGlmIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGNvbXBvbmVudC5jb250ZXh0KSB7XG5cdFx0aWYgKCFjb21wb25lbnQucHJldkNvbnRleHQpIGNvbXBvbmVudC5wcmV2Q29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuXHRcdGNvbXBvbmVudC5jb250ZXh0ID0gY29udGV4dDtcblx0fVxuXG5cdGlmICghY29tcG9uZW50LnByZXZQcm9wcykgY29tcG9uZW50LnByZXZQcm9wcyA9IGNvbXBvbmVudC5wcm9wcztcblx0Y29tcG9uZW50LnByb3BzID0gcHJvcHM7XG5cblx0Y29tcG9uZW50Ll9kaXNhYmxlID0gZmFsc2U7XG5cblx0aWYgKG9wdHMgIT09IDApIHtcblx0XHRpZiAob3B0cyA9PT0gMSB8fCBvcHRpb25zLnN5bmNDb21wb25lbnRVcGRhdGVzICE9PSBmYWxzZSB8fCAhY29tcG9uZW50LmJhc2UpIHtcblx0XHRcdHJlbmRlckNvbXBvbmVudChjb21wb25lbnQsIDEsIG1vdW50QWxsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb21wb25lbnQuX19yZWYpIGNvbXBvbmVudC5fX3JlZihjb21wb25lbnQpO1xufVxuXG4vKiogUmVuZGVyIGEgQ29tcG9uZW50LCB0cmlnZ2VyaW5nIG5lY2Vzc2FyeSBsaWZlY3ljbGUgZXZlbnRzIGFuZCB0YWtpbmcgSGlnaC1PcmRlciBDb21wb25lbnRzIGludG8gYWNjb3VudC5cbiAqXHRAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gKlx0QHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYnVpbGQ9ZmFsc2VdXHRcdElmIGB0cnVlYCwgY29tcG9uZW50IHdpbGwgYnVpbGQgYW5kIHN0b3JlIGEgRE9NIG5vZGUgaWYgbm90IGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIG9uZS5cbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCBvcHRzLCBtb3VudEFsbCwgaXNDaGlsZCkge1xuXHRpZiAoY29tcG9uZW50Ll9kaXNhYmxlKSByZXR1cm47XG5cblx0dmFyIHByb3BzID0gY29tcG9uZW50LnByb3BzLFxuXHQgICAgc3RhdGUgPSBjb21wb25lbnQuc3RhdGUsXG5cdCAgICBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQsXG5cdCAgICBwcmV2aW91c1Byb3BzID0gY29tcG9uZW50LnByZXZQcm9wcyB8fCBwcm9wcyxcblx0ICAgIHByZXZpb3VzU3RhdGUgPSBjb21wb25lbnQucHJldlN0YXRlIHx8IHN0YXRlLFxuXHQgICAgcHJldmlvdXNDb250ZXh0ID0gY29tcG9uZW50LnByZXZDb250ZXh0IHx8IGNvbnRleHQsXG5cdCAgICBpc1VwZGF0ZSA9IGNvbXBvbmVudC5iYXNlLFxuXHQgICAgbmV4dEJhc2UgPSBjb21wb25lbnQubmV4dEJhc2UsXG5cdCAgICBpbml0aWFsQmFzZSA9IGlzVXBkYXRlIHx8IG5leHRCYXNlLFxuXHQgICAgaW5pdGlhbENoaWxkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9jb21wb25lbnQsXG5cdCAgICBza2lwID0gZmFsc2UsXG5cdCAgICByZW5kZXJlZCxcblx0ICAgIGluc3QsXG5cdCAgICBjYmFzZTtcblxuXHQvLyBpZiB1cGRhdGluZ1xuXHRpZiAoaXNVcGRhdGUpIHtcblx0XHRjb21wb25lbnQucHJvcHMgPSBwcmV2aW91c1Byb3BzO1xuXHRcdGNvbXBvbmVudC5zdGF0ZSA9IHByZXZpb3VzU3RhdGU7XG5cdFx0Y29tcG9uZW50LmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG5cdFx0aWYgKG9wdHMgIT09IDIgJiYgY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJiBjb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlKHByb3BzLCBzdGF0ZSwgY29udGV4dCkgPT09IGZhbHNlKSB7XG5cdFx0XHRza2lwID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG5cdFx0XHRjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuXHRcdH1cblx0XHRjb21wb25lbnQucHJvcHMgPSBwcm9wcztcblx0XHRjb21wb25lbnQuc3RhdGUgPSBzdGF0ZTtcblx0XHRjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG5cdH1cblxuXHRjb21wb25lbnQucHJldlByb3BzID0gY29tcG9uZW50LnByZXZTdGF0ZSA9IGNvbXBvbmVudC5wcmV2Q29udGV4dCA9IGNvbXBvbmVudC5uZXh0QmFzZSA9IG51bGw7XG5cdGNvbXBvbmVudC5fZGlydHkgPSBmYWxzZTtcblxuXHRpZiAoIXNraXApIHtcblx0XHRyZW5kZXJlZCA9IGNvbXBvbmVudC5yZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcblxuXHRcdC8vIGNvbnRleHQgdG8gcGFzcyB0byB0aGUgY2hpbGQsIGNhbiBiZSB1cGRhdGVkIHZpYSAoZ3JhbmQtKXBhcmVudCBjb21wb25lbnRcblx0XHRpZiAoY29tcG9uZW50LmdldENoaWxkQ29udGV4dCkge1xuXHRcdFx0Y29udGV4dCA9IGV4dGVuZChleHRlbmQoe30sIGNvbnRleHQpLCBjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdH1cblxuXHRcdHZhciBjaGlsZENvbXBvbmVudCA9IHJlbmRlcmVkICYmIHJlbmRlcmVkLm5vZGVOYW1lLFxuXHRcdCAgICB0b1VubW91bnQsXG5cdFx0ICAgIGJhc2U7XG5cblx0XHRpZiAodHlwZW9mIGNoaWxkQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBzZXQgdXAgaGlnaCBvcmRlciBjb21wb25lbnQgbGlua1xuXG5cdFx0XHR2YXIgY2hpbGRQcm9wcyA9IGdldE5vZGVQcm9wcyhyZW5kZXJlZCk7XG5cdFx0XHRpbnN0ID0gaW5pdGlhbENoaWxkQ29tcG9uZW50O1xuXG5cdFx0XHRpZiAoaW5zdCAmJiBpbnN0LmNvbnN0cnVjdG9yID09PSBjaGlsZENvbXBvbmVudCAmJiBjaGlsZFByb3BzLmtleSA9PSBpbnN0Ll9fa2V5KSB7XG5cdFx0XHRcdHNldENvbXBvbmVudFByb3BzKGluc3QsIGNoaWxkUHJvcHMsIDEsIGNvbnRleHQsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvVW5tb3VudCA9IGluc3Q7XG5cblx0XHRcdFx0Y29tcG9uZW50Ll9jb21wb25lbnQgPSBpbnN0ID0gY3JlYXRlQ29tcG9uZW50KGNoaWxkQ29tcG9uZW50LCBjaGlsZFByb3BzLCBjb250ZXh0KTtcblx0XHRcdFx0aW5zdC5uZXh0QmFzZSA9IGluc3QubmV4dEJhc2UgfHwgbmV4dEJhc2U7XG5cdFx0XHRcdGluc3QuX3BhcmVudENvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0XHRcdFx0c2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMCwgY29udGV4dCwgZmFsc2UpO1xuXHRcdFx0XHRyZW5kZXJDb21wb25lbnQoaW5zdCwgMSwgbW91bnRBbGwsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRiYXNlID0gaW5zdC5iYXNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYmFzZSA9IGluaXRpYWxCYXNlO1xuXG5cdFx0XHQvLyBkZXN0cm95IGhpZ2ggb3JkZXIgY29tcG9uZW50IGxpbmtcblx0XHRcdHRvVW5tb3VudCA9IGluaXRpYWxDaGlsZENvbXBvbmVudDtcblx0XHRcdGlmICh0b1VubW91bnQpIHtcblx0XHRcdFx0Y2Jhc2UgPSBjb21wb25lbnQuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbml0aWFsQmFzZSB8fCBvcHRzID09PSAxKSB7XG5cdFx0XHRcdGlmIChjYmFzZSkgY2Jhc2UuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0XHRcdGJhc2UgPSBkaWZmKGNiYXNlLCByZW5kZXJlZCwgY29udGV4dCwgbW91bnRBbGwgfHwgIWlzVXBkYXRlLCBpbml0aWFsQmFzZSAmJiBpbml0aWFsQmFzZS5wYXJlbnROb2RlLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaW5pdGlhbEJhc2UgJiYgYmFzZSAhPT0gaW5pdGlhbEJhc2UgJiYgaW5zdCAhPT0gaW5pdGlhbENoaWxkQ29tcG9uZW50KSB7XG5cdFx0XHR2YXIgYmFzZVBhcmVudCA9IGluaXRpYWxCYXNlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoYmFzZVBhcmVudCAmJiBiYXNlICE9PSBiYXNlUGFyZW50KSB7XG5cdFx0XHRcdGJhc2VQYXJlbnQucmVwbGFjZUNoaWxkKGJhc2UsIGluaXRpYWxCYXNlKTtcblxuXHRcdFx0XHRpZiAoIXRvVW5tb3VudCkge1xuXHRcdFx0XHRcdGluaXRpYWxCYXNlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKGluaXRpYWxCYXNlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodG9Vbm1vdW50KSB7XG5cdFx0XHR1bm1vdW50Q29tcG9uZW50KHRvVW5tb3VudCk7XG5cdFx0fVxuXG5cdFx0Y29tcG9uZW50LmJhc2UgPSBiYXNlO1xuXHRcdGlmIChiYXNlICYmICFpc0NoaWxkKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50LFxuXHRcdFx0ICAgIHQgPSBjb21wb25lbnQ7XG5cdFx0XHR3aGlsZSAodCA9IHQuX3BhcmVudENvbXBvbmVudCkge1xuXHRcdFx0XHQoY29tcG9uZW50UmVmID0gdCkuYmFzZSA9IGJhc2U7XG5cdFx0XHR9XG5cdFx0XHRiYXNlLl9jb21wb25lbnQgPSBjb21wb25lbnRSZWY7XG5cdFx0XHRiYXNlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9IGNvbXBvbmVudFJlZi5jb25zdHJ1Y3Rvcjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWlzVXBkYXRlIHx8IG1vdW50QWxsKSB7XG5cdFx0bW91bnRzLnVuc2hpZnQoY29tcG9uZW50KTtcblx0fSBlbHNlIGlmICghc2tpcCkge1xuXHRcdC8vIEVuc3VyZSB0aGF0IHBlbmRpbmcgY29tcG9uZW50RGlkTW91bnQoKSBob29rcyBvZiBjaGlsZCBjb21wb25lbnRzXG5cdFx0Ly8gYXJlIGNhbGxlZCBiZWZvcmUgdGhlIGNvbXBvbmVudERpZFVwZGF0ZSgpIGhvb2sgaW4gdGhlIHBhcmVudC5cblx0XHQvLyBOb3RlOiBkaXNhYmxlZCBhcyBpdCBjYXVzZXMgZHVwbGljYXRlIGhvb2tzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvaXNzdWVzLzc1MFxuXHRcdC8vIGZsdXNoTW91bnRzKCk7XG5cblx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZSkge1xuXHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlLCBwcmV2aW91c0NvbnRleHQpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5hZnRlclVwZGF0ZSkgb3B0aW9ucy5hZnRlclVwZGF0ZShjb21wb25lbnQpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzICE9IG51bGwpIHtcblx0XHR3aGlsZSAoY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5wb3AoKS5jYWxsKGNvbXBvbmVudCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFkaWZmTGV2ZWwgJiYgIWlzQ2hpbGQpIGZsdXNoTW91bnRzKCk7XG59XG5cbi8qKiBBcHBseSB0aGUgQ29tcG9uZW50IHJlZmVyZW5jZWQgYnkgYSBWTm9kZSB0byB0aGUgRE9NLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRUaGUgRE9NIG5vZGUgdG8gbXV0YXRlXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdEEgQ29tcG9uZW50LXJlZmVyZW5jaW5nIFZOb2RlXG4gKlx0QHJldHVybnMge0VsZW1lbnR9IGRvbVx0VGhlIGNyZWF0ZWQvbXV0YXRlZCBlbGVtZW50XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRDb21wb25lbnRGcm9tVk5vZGUoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwpIHtcblx0dmFyIGMgPSBkb20gJiYgZG9tLl9jb21wb25lbnQsXG5cdCAgICBvcmlnaW5hbENvbXBvbmVudCA9IGMsXG5cdCAgICBvbGREb20gPSBkb20sXG5cdCAgICBpc0RpcmVjdE93bmVyID0gYyAmJiBkb20uX2NvbXBvbmVudENvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZSxcblx0ICAgIGlzT3duZXIgPSBpc0RpcmVjdE93bmVyLFxuXHQgICAgcHJvcHMgPSBnZXROb2RlUHJvcHModm5vZGUpO1xuXHR3aGlsZSAoYyAmJiAhaXNPd25lciAmJiAoYyA9IGMuX3BhcmVudENvbXBvbmVudCkpIHtcblx0XHRpc093bmVyID0gYy5jb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG5cdH1cblxuXHRpZiAoYyAmJiBpc093bmVyICYmICghbW91bnRBbGwgfHwgYy5fY29tcG9uZW50KSkge1xuXHRcdHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAzLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdFx0ZG9tID0gYy5iYXNlO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChvcmlnaW5hbENvbXBvbmVudCAmJiAhaXNEaXJlY3RPd25lcikge1xuXHRcdFx0dW5tb3VudENvbXBvbmVudChvcmlnaW5hbENvbXBvbmVudCk7XG5cdFx0XHRkb20gPSBvbGREb20gPSBudWxsO1xuXHRcdH1cblxuXHRcdGMgPSBjcmVhdGVDb21wb25lbnQodm5vZGUubm9kZU5hbWUsIHByb3BzLCBjb250ZXh0KTtcblx0XHRpZiAoZG9tICYmICFjLm5leHRCYXNlKSB7XG5cdFx0XHRjLm5leHRCYXNlID0gZG9tO1xuXHRcdFx0Ly8gcGFzc2luZyBkb20vb2xkRG9tIGFzIG5leHRCYXNlIHdpbGwgcmVjeWNsZSBpdCBpZiB1bnVzZWQsIHNvIGJ5cGFzcyByZWN5Y2xpbmcgb24gTDIyOTpcblx0XHRcdG9sZERvbSA9IG51bGw7XG5cdFx0fVxuXHRcdHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAxLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdFx0ZG9tID0gYy5iYXNlO1xuXG5cdFx0aWYgKG9sZERvbSAmJiBkb20gIT09IG9sZERvbSkge1xuXHRcdFx0b2xkRG9tLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0cmVjb2xsZWN0Tm9kZVRyZWUob2xkRG9tLCBmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHJlY3ljbGUgaXQuXG4gKlx0QHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudFx0VGhlIENvbXBvbmVudCBpbnN0YW5jZSB0byB1bm1vdW50XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudChjb21wb25lbnQpIHtcblx0aWYgKG9wdGlvbnMuYmVmb3JlVW5tb3VudCkgb3B0aW9ucy5iZWZvcmVVbm1vdW50KGNvbXBvbmVudCk7XG5cblx0dmFyIGJhc2UgPSBjb21wb25lbnQuYmFzZTtcblxuXHRjb21wb25lbnQuX2Rpc2FibGUgPSB0cnVlO1xuXG5cdGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXG5cdGNvbXBvbmVudC5iYXNlID0gbnVsbDtcblxuXHQvLyByZWN1cnNpdmVseSB0ZWFyIGRvd24gJiByZWNvbGxlY3QgaGlnaC1vcmRlciBjb21wb25lbnQgY2hpbGRyZW46XG5cdHZhciBpbm5lciA9IGNvbXBvbmVudC5fY29tcG9uZW50O1xuXHRpZiAoaW5uZXIpIHtcblx0XHR1bm1vdW50Q29tcG9uZW50KGlubmVyKTtcblx0fSBlbHNlIGlmIChiYXNlKSB7XG5cdFx0aWYgKGJhc2VbJ19fcHJlYWN0YXR0cl8nXSAmJiBiYXNlWydfX3ByZWFjdGF0dHJfJ10ucmVmKSBiYXNlWydfX3ByZWFjdGF0dHJfJ10ucmVmKG51bGwpO1xuXG5cdFx0Y29tcG9uZW50Lm5leHRCYXNlID0gYmFzZTtcblxuXHRcdHJlbW92ZU5vZGUoYmFzZSk7XG5cdFx0Y29sbGVjdENvbXBvbmVudChjb21wb25lbnQpO1xuXG5cdFx0cmVtb3ZlQ2hpbGRyZW4oYmFzZSk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50Ll9fcmVmKSBjb21wb25lbnQuX19yZWYobnVsbCk7XG59XG5cbi8qKiBCYXNlIENvbXBvbmVudCBjbGFzcy5cbiAqXHRQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2ggdHJpZ2dlciByZW5kZXJpbmcuXG4gKlx0QHB1YmxpY1xuICpcbiAqXHRAZXhhbXBsZVxuICpcdGNsYXNzIE15Rm9vIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqXHRcdHJlbmRlcihwcm9wcywgc3RhdGUpIHtcbiAqXHRcdFx0cmV0dXJuIDxkaXYgLz47XG4gKlx0XHR9XG4gKlx0fVxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXG5cdC8qKiBAcHVibGljXG4gICpcdEB0eXBlIHtvYmplY3R9XG4gICovXG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cblx0LyoqIEBwdWJsaWNcbiAgKlx0QHR5cGUge29iamVjdH1cbiAgKi9cblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXG5cdC8qKiBAcHVibGljXG4gICpcdEB0eXBlIHtvYmplY3R9XG4gICovXG5cdHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xufVxuXG5leHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwge1xuXG5cdC8qKiBSZXR1cm5zIGEgYGJvb2xlYW5gIGluZGljYXRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgcmUtcmVuZGVyIHdoZW4gcmVjZWl2aW5nIHRoZSBnaXZlbiBgcHJvcHNgIGFuZCBgc3RhdGVgLlxuICAqXHRAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICpcdEBwYXJhbSB7b2JqZWN0fSBuZXh0U3RhdGVcbiAgKlx0QHBhcmFtIHtvYmplY3R9IG5leHRDb250ZXh0XG4gICpcdEByZXR1cm5zIHtCb29sZWFufSBzaG91bGQgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJcbiAgKlx0QG5hbWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gICpcdEBmdW5jdGlvblxuICAqL1xuXG5cdC8qKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGJ5IGNvcHlpbmcgcHJvcGVydGllcyBmcm9tIGBzdGF0ZWAgdG8gYHRoaXMuc3RhdGVgLlxuICAqXHRAcGFyYW0ge29iamVjdH0gc3RhdGVcdFx0QSBoYXNoIG9mIHN0YXRlIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlc1xuICAqXHRAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1x0QSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXMgdXBkYXRlZFxuICAqL1xuXHRzZXRTdGF0ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHMgPSB0aGlzLnN0YXRlO1xuXHRcdGlmICghdGhpcy5wcmV2U3RhdGUpIHRoaXMucHJldlN0YXRlID0gZXh0ZW5kKHt9LCBzKTtcblx0XHRleHRlbmQocywgdHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nID8gc3RhdGUocywgdGhpcy5wcm9wcykgOiBzdGF0ZSk7XG5cdFx0aWYgKGNhbGxiYWNrKSAodGhpcy5fcmVuZGVyQ2FsbGJhY2tzID0gdGhpcy5fcmVuZGVyQ2FsbGJhY2tzIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9LFxuXG5cblx0LyoqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudC5cbiAgKlx0QHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcdFx0QSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHJlLXJlbmRlcmVkLlxuICAqXHRAcHJpdmF0ZVxuICAqL1xuXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoY2FsbGJhY2spIHtcblx0XHRpZiAoY2FsbGJhY2spICh0aGlzLl9yZW5kZXJDYWxsYmFja3MgPSB0aGlzLl9yZW5kZXJDYWxsYmFja3MgfHwgW10pLnB1c2goY2FsbGJhY2spO1xuXHRcdHJlbmRlckNvbXBvbmVudCh0aGlzLCAyKTtcblx0fSxcblxuXG5cdC8qKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gICpcdFZpcnR1YWwgRE9NIGlzIGdlbmVyYWxseSBjb25zdHJ1Y3RlZCB2aWEgW0pTWF0oaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4KS5cbiAgKlx0QHBhcmFtIHtvYmplY3R9IHByb3BzXHRcdFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50IGVsZW1lbnQvY29tcG9uZW50XG4gICpcdEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVx0XHRUaGUgY29tcG9uZW50J3MgY3VycmVudCBzdGF0ZVxuICAqXHRAcGFyYW0ge29iamVjdH0gY29udGV4dFx0XHRDb250ZXh0IG9iamVjdCAoaWYgYSBwYXJlbnQgY29tcG9uZW50IGhhcyBwcm92aWRlZCBjb250ZXh0KVxuICAqXHRAcmV0dXJucyBWTm9kZVxuICAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHt9XG59KTtcblxuLyoqIFJlbmRlciBKU1ggaW50byBhIGBwYXJlbnRgIEVsZW1lbnQuXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdFx0QSAoSlNYKSBWTm9kZSB0byByZW5kZXJcbiAqXHRAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFx0XHRET00gZWxlbWVudCB0byByZW5kZXIgaW50b1xuICpcdEBwYXJhbSB7RWxlbWVudH0gW21lcmdlXVx0QXR0ZW1wdCB0byByZS11c2UgYW4gZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGBtZXJnZWBcbiAqXHRAcHVibGljXG4gKlxuICpcdEBleGFtcGxlXG4gKlx0Ly8gcmVuZGVyIGEgZGl2IGludG8gPGJvZHk+OlxuICpcdHJlbmRlcig8ZGl2IGlkPVwiaGVsbG9cIj5oZWxsbyE8L2Rpdj4sIGRvY3VtZW50LmJvZHkpO1xuICpcbiAqXHRAZXhhbXBsZVxuICpcdC8vIHJlbmRlciBhIFwiVGhpbmdcIiBjb21wb25lbnQgaW50byAjZm9vOlxuICpcdGNvbnN0IFRoaW5nID0gKHsgbmFtZSB9KSA9PiA8c3Bhbj57IG5hbWUgfTwvc3Bhbj47XG4gKlx0cmVuZGVyKDxUaGluZyBuYW1lPVwib25lXCIgLz4sIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmb28nKSk7XG4gKi9cbmZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBtZXJnZSkge1xuICByZXR1cm4gZGlmZihtZXJnZSwgdm5vZGUsIHt9LCBmYWxzZSwgcGFyZW50LCBmYWxzZSk7XG59XG5cbnZhciBwcmVhY3QgPSB7XG5cdGg6IGgsXG5cdGNyZWF0ZUVsZW1lbnQ6IGgsXG5cdGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuXHRDb21wb25lbnQ6IENvbXBvbmVudCxcblx0cmVuZGVyOiByZW5kZXIsXG5cdHJlcmVuZGVyOiByZXJlbmRlcixcblx0b3B0aW9uczogb3B0aW9uc1xufTtcblxuZXhwb3J0IHsgaCwgaCBhcyBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQsIENvbXBvbmVudCwgcmVuZGVyLCByZXJlbmRlciwgb3B0aW9ucyB9O2V4cG9ydCBkZWZhdWx0IHByZWFjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5lc20uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0LmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5lc20uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc2FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nXG4gIHZhciByZXNcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdXG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV1cbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoXG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XVxuICAgIHZhciBwcmVmaXggPSByZXNbMl1cbiAgICB2YXIgbmFtZSA9IHJlc1szXVxuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdXG4gICAgdmFyIGdyb3VwID0gcmVzWzVdXG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddXG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKVxuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KVxuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KVxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpXG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fVxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXVxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKVxuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXNcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlXG4gIHZhciByb3V0ZSA9ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KVxuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSdcblxuICAgICAga2V5cy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmVcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJylcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXJcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/J1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJ1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSdcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpXG52YXIgc3BsaWNlT25lID0gZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkge1xuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICB9bGlzdC5wb3AoKTtcbn07XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG52YXIgcmVzb2x2ZVBhdGhuYW1lID0gZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHRvKSB7XG4gIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICB2YXIgdG9QYXJ0cyA9IHRvICYmIHRvLnNwbGl0KCcvJykgfHwgW107XG4gIHZhciBmcm9tUGFydHMgPSBmcm9tICYmIGZyb20uc3BsaXQoJy8nKSB8fCBbXTtcblxuICB2YXIgaXNUb0FicyA9IHRvICYmIGlzQWJzb2x1dGUodG8pO1xuICB2YXIgaXNGcm9tQWJzID0gZnJvbSAmJiBpc0Fic29sdXRlKGZyb20pO1xuICB2YXIgbXVzdEVuZEFicyA9IGlzVG9BYnMgfHwgaXNGcm9tQWJzO1xuXG4gIGlmICh0byAmJiBpc0Fic29sdXRlKHRvKSkge1xuICAgIC8vIHRvIGlzIGFic29sdXRlXG4gICAgZnJvbVBhcnRzID0gdG9QYXJ0cztcbiAgfSBlbHNlIGlmICh0b1BhcnRzLmxlbmd0aCkge1xuICAgIC8vIHRvIGlzIHJlbGF0aXZlLCBkcm9wIHRoZSBmaWxlbmFtZVxuICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICBmcm9tUGFydHMgPSBmcm9tUGFydHMuY29uY2F0KHRvUGFydHMpO1xuICB9XG5cbiAgaWYgKCFmcm9tUGFydHMubGVuZ3RoKSByZXR1cm4gJy8nO1xuXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gdm9pZCAwO1xuICBpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0ID0gZnJvbVBhcnRzW2Zyb21QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gbGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicgfHwgbGFzdCA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBmcm9tUGFydHNbaV07XG5cbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXN0RW5kQWJzKSBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICBmcm9tUGFydHMudW5zaGlmdCgnLi4nKTtcbiAgfWlmIChtdXN0RW5kQWJzICYmIGZyb21QYXJ0c1swXSAhPT0gJycgJiYgKCFmcm9tUGFydHNbMF0gfHwgIWlzQWJzb2x1dGUoZnJvbVBhcnRzWzBdKSkpIGZyb21QYXJ0cy51bnNoaWZ0KCcnKTtcblxuICB2YXIgcmVzdWx0ID0gZnJvbVBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiByZXN1bHQuc3Vic3RyKC0xKSAhPT0gJy8nKSByZXN1bHQgKz0gJy8nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVQYXRobmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDIzIDI3XFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiPjxnIGlkPVxcXCJNVlBcXFwiIHN0cm9rZT1cXFwibm9uZVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxXFxcIiBmaWxsPVxcXCJub25lXFxcIiBmaWxsLXJ1bGU9XFxcImV2ZW5vZGRcXFwiPjxnIGlkPVxcXCJsaW5rU3RhdHVzMlxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTg5OS4wMDAwMDAsIC02MzguMDAwMDAwKVxcXCIgZmlsbD1cXFwiIzFCMjQzN1xcXCI+PGcgaWQ9XFxcIkdyb3VwLTZcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDY1NS4wMDAwMDAsIDYzMS4wMDAwMDApXFxcIj48cGF0aCBkPVxcXCJNMjU1LjQ1Miw2Ljk5OTIgTDI0NCwxNS44MTUyIEwyNDQsMjQuNDY4MiBMMjU1LjQ1MiwzMy4yODQyIEwyNjYuOTA0LDI0LjQ2ODIgTDI2Ni45MDQsMTUuODE1MiBMMjU1LjQ1Miw2Ljk5OTIgWiBNMjU5Ljg3NCwxOC4xMzcyIEwyNTYuMjI0LDE1LjMyODIgTDI1Ni4yMjQsOS43MDMyIEwyNjQuNzYxLDE2LjI3NDIgTDI2MS4yNjEsMTguOTcwMiBMMjU4Ljk2NSwyMC43MzkyIEwyNTguOTYzLDIwLjczNzIgTDI1NS40NTIsMjMuNDQxMiBMMjUyLjQsMjEuMDkyMiBMMjUxLjAzMSwyMi4xNDYyIEwyNTQuNjc5LDI0Ljk1NjIgTDI1NC42NzksMzAuNTgxMiBMMjQ2LjE0MiwyNC4wMDkyIEwyNDkuNzk2LDIxLjE5NjIgTDI1MS45NDEsMTkuNTQ0MiBMMjUxLjk0MSwxOS41NDUyIEwyNTUuNDUyLDE2Ljg0MjIgTDI1OC41MDQsMTkuMTkxMiBMMjU5Ljg3NCwxOC4xMzcyIFogTTI0OC41NjIsMTguMTM3MiBMMjQ2LjE0MiwxNi4yNzQyIEwyNTQuNjc5LDkuNzAzMiBMMjU0LjY3OSwxNS4zMjgyIEwyNDkuNzk2LDE5LjA4NzIgTDI0OC40MjcsMjAuMTQxMiBMMjQ4LjM4MSwyMC4xNzcyIEwyNDcuNjUyLDIwLjczODIgTDI0NS41NDYsMjIuMzU5MiBMMjQ1LjU0NiwxNy45MjMyIEwyNDcuMTkzLDE5LjE5MDIgTDI0OC41NjIsMTguMTM3MiBaIE0yNTYuMjI0LDI0Ljk1NjIgTDI2MS4xMDgsMjEuMTk2MiBMMjYzLjA4MSwxOS42NzYyIEwyNjUuMzU4LDE3LjkyMzIgTDI2NS4zNTgsMjIuMzU5MiBMMjYzLjcxMSwyMS4wOTIyIEwyNjIuMzQyLDIyLjE0NjIgTDI2NC43NjEsMjQuMDA5MiBMMjU2LjIyNCwzMC41ODEyIEwyNTYuMjI0LDI0Ljk1NjIgWlxcXCIgaWQ9XFxcIlBhZ2UtMVxcXCI+PC9wYXRoPjwvZz48L2c+PC9nPjwvc3ZnPlwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3N2Zy1pbmxpbmUtbG9hZGVyP3JlbW92ZVRhZ3M9dHJ1ZSZyZW1vdmVTVkdUYWdBdHRycz10cnVlIS4vaW1hZ2VzL2N1YmUuc3ZnXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvc3ZnLWlubGluZS1sb2FkZXIvaW5kZXguanM/cmVtb3ZlVGFncz10cnVlJnJlbW92ZVNWR1RhZ0F0dHJzPXRydWUhLi9pbWFnZXMvY3ViZS5zdmdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hZHNMaXN0X19zZWxmLS0xQ09qOSAuYWRzTGlzdF9fcm93LS0yZU01ZntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzoxMHB4fS5hZHNMaXN0X19zZWxmLS0xQ09qOSAuYWRzTGlzdF9fYnV0dG9uLS1vLUNuOHttYXJnaW4tbGVmdDphdXRvfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9hZHNMaXN0LnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsMkNBQVcsb0JBQW9CLG9CQUFvQixhQUFhLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQixZQUFZLENBQUMsOENBQWMsZ0JBQWdCLENBQUNcIixcImZpbGVcIjpcImFkc0xpc3Quc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZiAucm93e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdztwYWRkaW5nOjEwcHh9LnNlbGYgLmJ1dHRvbnttYXJnaW4tbGVmdDphdXRvfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwiYWRzTGlzdF9fc2VsZi0tMUNPajlcIixcblx0XCJyb3dcIjogXCJhZHNMaXN0X19yb3ctLTJlTTVmXCIsXG5cdFwiYnV0dG9uXCI6IFwiYWRzTGlzdF9fYnV0dG9uLS1vLUNuOFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9hZHNMaXN0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9hZHNMaXN0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5idXR0b25fX3NlbGYtLTFIQlZze2JvcmRlcjpub25lO291dGxpbmU6bm9uZTtmb250LWZhbWlseTpQVCBTYW5zOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZjtsZXR0ZXItc3BhY2luZzouMDFlbX0uYnV0dG9uX19zZWxmLS0xSEJWcy5idXR0b25fX3ByaW1hcnktLTJtckt2e2ZvbnQtd2VpZ2h0OjMwMDtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxNXB4O2JvcmRlci1yYWRpdXM6M3B4O3BhZGRpbmc6MTNweCAyNXB4IWltcG9ydGFudH0uYnV0dG9uX19zZWxmLS0xSEJWcy5idXR0b25fX3NlY29uZGFyeS0tMkltb3h7ZmxvYXQ6cmlnaHQ7YmFja2dyb3VuZC1jb2xvcjojY2ZkOWZhO2JvcmRlci1yYWRpdXM6NTBweDtjb2xvcjojMjYzZmZmO2hlaWdodDoyMHB4O3dpZHRoOjUwcHg7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NzAwOy13ZWJraXQtYm94LXNoYWRvdzowIDVweCAxMnB4IHJnYmEoMTg0LDE4OCwyMDYsLjUpO2JveC1zaGFkb3c6MCA1cHggMTJweCByZ2JhKDE4NCwxODgsMjA2LC41KX0uYnV0dG9uX19zZWxmLS0xSEJWcy5idXR0b25fX3NlY29uZGFyeS0tMkltb3g6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojODk5MzlmO29wYWNpdHk6LjQ7Y3Vyc29yOm5vdC1hbGxvd2VkO2NvbG9yOiNmZmZ9LmJ1dHRvbl9fc2VsZi0tMUhCVnMuYnV0dG9uX19zZWNvbmRhcnktLTJJbW94Om5vdChbZGlzYWJsZWRdKTpob3Zlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0ycHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0ycHgpfS5idXR0b25fX3NlbGYtLTFIQlZzOmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6Izg5OTM5ZjtvcGFjaXR5Oi40O2N1cnNvcjpub3QtYWxsb3dlZDtjb2xvcjojZmZmfS5idXR0b25fX3NlbGYtLTFIQlZzOm5vdChbZGlzYWJsZWRdKTpob3ZlcntjdXJzb3I6cG9pbnRlcjtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZjstd2Via2l0LWJveC1zaGFkb3c6MCA1cHggMTVweCByZ2JhKDUwLDkzLDI1NSwuNDUpO2JveC1zaGFkb3c6MCA1cHggMTVweCByZ2JhKDUwLDkzLDI1NSwuNDUpOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTFweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTFweCl9LmJ1dHRvbl9fc2VsZi0tMUhCVnM6YWN0aXZle2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZn1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYnV0dG9uLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEscUJBQU0sWUFBWSxhQUFhLG9CQUFzQixtQ0FBbUMsa0NBQWtDLHlCQUF5QixvQkFBcUIsQ0FBQyw0Q0FBYyxnQkFBZ0IsV0FBVyxlQUFlLGtCQUFrQiwyQkFBNEIsQ0FBQyw4Q0FBZ0IsWUFBWSx5QkFBeUIsbUJBQW1CLGNBQWMsWUFBWSxXQUFXLGtCQUFrQixlQUFlLGdCQUFnQixtREFBc0QsMENBQTZDLENBQUMsdURBQXlCLHlCQUF5QixXQUFZLG1CQUFtQixVQUFVLENBQUMsb0VBQXNDLG1DQUFtQywwQkFBMEIsQ0FBQyw4QkFBZSx5QkFBeUIsV0FBWSxtQkFBbUIsVUFBVSxDQUFDLDJDQUE0QixlQUFlLFdBQVcseUJBQXlCLGtEQUFxRCwwQ0FBNkMsbUNBQW1DLDBCQUEwQixDQUFDLDRCQUFhLHdCQUF3QixDQUFDXCIsXCJmaWxlXCI6XCJidXR0b24uc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmU7Zm9udC1mYW1pbHk6J1BUIFNhbnMnOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZjtsZXR0ZXItc3BhY2luZzowLjAxZW19LnNlbGYucHJpbWFyeXtmb250LXdlaWdodDozMDA7Y29sb3I6I2ZmZjtmb250LXNpemU6MTVweDtib3JkZXItcmFkaXVzOjNweDtwYWRkaW5nOjEzcHggMjVweCAhaW1wb3J0YW50fS5zZWxmLnNlY29uZGFyeXtmbG9hdDpyaWdodDtiYWNrZ3JvdW5kLWNvbG9yOiNjZmQ5ZmE7Ym9yZGVyLXJhZGl1czo1MHB4O2NvbG9yOiMyNjNmZmY7aGVpZ2h0OjIwcHg7d2lkdGg6NTBweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo3MDA7LXdlYmtpdC1ib3gtc2hhZG93OjBweCA1cHggMTJweCByZ2JhKDE4NCwxODgsMjA2LDAuNSk7Ym94LXNoYWRvdzowcHggNXB4IDEycHggcmdiYSgxODQsMTg4LDIwNiwwLjUpfS5zZWxmLnNlY29uZGFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOiM4OTkzOWY7b3BhY2l0eTowLjQ7Y3Vyc29yOm5vdC1hbGxvd2VkO2NvbG9yOiNmZmZ9LnNlbGYuc2Vjb25kYXJ5Om5vdChbZGlzYWJsZWRdKTpob3Zlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0ycHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0ycHgpfS5zZWxmOmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6Izg5OTM5ZjtvcGFjaXR5OjAuNDtjdXJzb3I6bm90LWFsbG93ZWQ7Y29sb3I6I2ZmZn0uc2VsZjpub3QoW2Rpc2FibGVkXSk6aG92ZXJ7Y3Vyc29yOnBvaW50ZXI7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMyNjNmZmY7LXdlYmtpdC1ib3gtc2hhZG93OjBweCA1cHggMTVweCByZ2JhKDUwLDkzLDI1NSwwLjQ1KTtib3gtc2hhZG93OjBweCA1cHggMTVweCByZ2JhKDUwLDkzLDI1NSwwLjQ1KTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xcHgpfS5zZWxmOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiMyNjNmZmZ9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJidXR0b25fX3NlbGYtLTFIQlZzXCIsXG5cdFwicHJpbWFyeVwiOiBcImJ1dHRvbl9fcHJpbWFyeS0tMm1yS3ZcIixcblx0XCJzZWNvbmRhcnlcIjogXCJidXR0b25fX3NlY29uZGFyeS0tMkltb3hcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYnV0dG9uLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmljb25fX3NlbGYtLTFodE5Ie2ZvbnQtc2l6ZTouOGVtfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pY29uLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsbUJBQU0sY0FBZSxDQUFDXCIsXCJmaWxlXCI6XCJpY29uLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7Zm9udC1zaXplOjAuOGVtfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwiaWNvbl9fc2VsZi0tMWh0TkhcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaW5wdXRfX3NlbGYtLVN0YTZVe3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1ib3R0b206MjBweDttYXJnaW4tdG9wOjIwcHg7d2lkdGg6MTAwJTtmb250LWZhbWlseTpQVCBTYW5zOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDt0cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50fS5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19pbnB1dC0tMWg2S017Zm9udC1zaXplOjE1cHg7cGFkZGluZzoxMHB4O3dpZHRoOmNhbGMoMTAwJSAtIDMwcHgpO2JhY2tncm91bmQtY29sb3I6I2Y1ZjdmYTtib3JkZXI6MXB4IHNvbGlkICNlZWYxZjI7Ym9yZGVyLXJhZGl1czozcHg7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19pbnB1dC0tMWg2S006Zm9jdXN7b3V0bGluZTpub25lO2JvcmRlcjoxcHggc29saWQgIzI2M2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmlucHV0X19zZWxmLS1TdGE2VSAuaW5wdXRfX2lucHV0LS0xaDZLTTotbW96LXBsYWNlaG9sZGVye2JveC1zaGFkb3c6bm9uZSFpbXBvcnRhbnR9LmlucHV0X19zZWxmLS1TdGE2VS5pbnB1dF9faW52YWxpZC0tM1ZtaG97bWFyZ2luLWJvdHRvbTpjYWxjKDMwcHggLSAxZW0pfS5pbnB1dF9fc2VsZi0tU3RhNlUuaW5wdXRfX2ludmFsaWQtLTNWbWhvPi5pbnB1dF9faW5wdXQtLTFoNktNey13ZWJraXQtYm94LXNoYWRvdzowIDAgNXB4IDFweCByZWQ7Ym94LXNoYWRvdzowIDAgNXB4IDFweCByZWR9LmlucHV0X19zZWxmLS1TdGE2VSAuaW5wdXRfX3BsYWNlaG9sZGVyLS0yNks4eXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTBweDtsZWZ0OjVweDtjb2xvcjojODk5MzlmO2ZvbnQtc2l6ZToxNXB4Oy13ZWJraXQtdHJhbnNpdGlvbjouMnM7dHJhbnNpdGlvbjouMnN9LmlucHV0X19zZWxmLS1TdGE2VSAuaW5wdXRfX2lucHV0LS0xaDZLTTpkaXNhYmxlZH4uaW5wdXRfX3BsYWNlaG9sZGVyLS0yNks4eSwuaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9faW5wdXQtLTFoNktNOmZvY3Vzfi5pbnB1dF9fcGxhY2Vob2xkZXItLTI2Szh5LC5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19pbnB1dC0tMWg2S006dmFsaWR+LmlucHV0X19wbGFjZWhvbGRlci0tMjZLOHl7Y29sb3I6IzFiMjQzNztmb250LXNpemU6MTFweDt0b3A6LTE2cHg7bGVmdDowfS5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19lcnJvci0tM21Vbzh7Y29sb3I6cmVkO2hlaWdodDoxZW07Zm9udC1zaXplOi44ZW07Zm9udC13ZWlnaHQ6NjAwfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG9CQUFNLGtCQUFrQixtQkFBbUIsZ0JBQWdCLFdBQVcsb0JBQXNCLG1DQUFtQyxrQ0FBa0Msa0NBQW1DLHlCQUEwQixDQUFDLHlDQUFhLGVBQWUsYUFBYSx3QkFBd0IseUJBQXlCLHlCQUF5QixrQkFBa0Isd0JBQXdCLGVBQWUsQ0FBQywrQ0FBbUIsYUFBYSx5QkFBeUIscUJBQXFCLENBQUMsMERBQThCLHlCQUEwQixDQUFDLDBDQUFjLDhCQUE4QixDQUFDLCtEQUFxQixtQ0FBbUMsMEJBQTBCLENBQUMsK0NBQW1CLGtCQUFrQixTQUFTLFNBQVMsY0FBYyxlQUFlLHVCQUF3QixjQUFlLENBQUMsaU9BQXlHLGNBQWMsZUFBZSxVQUFVLE1BQVEsQ0FBQyx5Q0FBYSxVQUFVLFdBQVcsZUFBZ0IsZUFBZSxDQUFDXCIsXCJmaWxlXCI6XCJpbnB1dC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1ib3R0b206MjBweDttYXJnaW4tdG9wOjIwcHg7d2lkdGg6MTAwJTtmb250LWZhbWlseTonUFQgU2Fucyc7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC10cmFuc2l0aW9uOm5vbmUgIWltcG9ydGFudDt0cmFuc2l0aW9uOm5vbmUgIWltcG9ydGFudH0uc2VsZiAuaW5wdXR7Zm9udC1zaXplOjE1cHg7cGFkZGluZzoxMHB4O3dpZHRoOmNhbGMoMTAwJSAtIDMwcHgpO2JhY2tncm91bmQtY29sb3I6I2Y1ZjdmYTtib3JkZXI6MXB4IHNvbGlkICNlZWYxZjI7Ym9yZGVyLXJhZGl1czozcHg7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5zZWxmIC5pbnB1dDpmb2N1c3tvdXRsaW5lOm5vbmU7Ym9yZGVyOjFweCBzb2xpZCAjMjYzZmZmO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uc2VsZiAuaW5wdXQ6LW1vei1wbGFjZWhvbGRlcntib3gtc2hhZG93Om5vbmUgIWltcG9ydGFudH0uc2VsZi5pbnZhbGlke21hcmdpbi1ib3R0b206Y2FsYygzMHB4IC0gMWVtKX0uc2VsZi5pbnZhbGlkPi5pbnB1dHstd2Via2l0LWJveC1zaGFkb3c6MCAwIDVweCAxcHggcmVkO2JveC1zaGFkb3c6MCAwIDVweCAxcHggcmVkfS5zZWxmIC5wbGFjZWhvbGRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTBweDtsZWZ0OjVweDtjb2xvcjojODk5MzlmO2ZvbnQtc2l6ZToxNXB4Oy13ZWJraXQtdHJhbnNpdGlvbjowLjJzO3RyYW5zaXRpb246MC4yc30uc2VsZiAuaW5wdXQ6Zm9jdXMgfiAucGxhY2Vob2xkZXIsLnNlbGYgLmlucHV0OnZhbGlkIH4gLnBsYWNlaG9sZGVyLC5zZWxmIC5pbnB1dDpkaXNhYmxlZCB+IC5wbGFjZWhvbGRlcntjb2xvcjojMWIyNDM3O2ZvbnQtc2l6ZToxMXB4O3RvcDotMTZweDtsZWZ0OjBweH0uc2VsZiAuZXJyb3J7Y29sb3I6cmVkO2hlaWdodDoxZW07Zm9udC1zaXplOjAuOGVtO2ZvbnQtd2VpZ2h0OjYwMH1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImlucHV0X19zZWxmLS1TdGE2VVwiLFxuXHRcImlucHV0XCI6IFwiaW5wdXRfX2lucHV0LS0xaDZLTVwiLFxuXHRcImludmFsaWRcIjogXCJpbnB1dF9faW52YWxpZC0tM1ZtaG9cIixcblx0XCJwbGFjZWhvbGRlclwiOiBcImlucHV0X19wbGFjZWhvbGRlci0tMjZLOHlcIixcblx0XCJlcnJvclwiOiBcImlucHV0X19lcnJvci0tM21VbzhcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaW5wdXQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5sYWJlbF9fc2VsZi0tMzNwQnV7Zm9udC1zaXplOjE1cHg7dGV4dC1hbGlnbjpsZWZ0O2ZvbnQtZmFtaWx5OlBUIFNhbnM7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7Y29sb3I6Izg5OTM5Zn1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGFiZWwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxvQkFBTSxlQUFlLGdCQUFnQixvQkFBc0IsbUNBQW1DLGtDQUFrQyxhQUFhLENBQUNcIixcImZpbGVcIjpcImxhYmVsLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7Zm9udC1zaXplOjE1cHg7dGV4dC1hbGlnbjpsZWZ0O2ZvbnQtZmFtaWx5OidQVCBTYW5zJzstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtjb2xvcjojODk5MzlmfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwibGFiZWxfX3NlbGYtLTMzcEJ1XCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubGlua19fc2VsZi0tMmxMYUx7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttaW4td2lkdGg6NzUlO2ZvbnQtd2VpZ2h0OjMwMH0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX3RpdGxlLS0zV2hxdXt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7Y29sb3I6IzI2M2ZmZjtmb250LXdlaWdodDo3MDA7Zm9udC1zaXplOjEuMmVtOy1tcy1mbGV4LW5lZ2F0aXZlOjA7ZmxleC1zaHJpbms6MH0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX2hlYWRlci0tRGJVUVB7LXdlYmtpdC1ib3gtcGFjazpqdXN0aWZ5Oy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX3N1bW1hcnktLTMtVjJDe2NvbG9yOiM1NDU0NTR9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19zdW1tYXJ5LS0zLVYyQy5saW5rX19saW5lczItLUlYMlNKe292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTtsaW5lLWhlaWdodDoxLjJlbTttYXgtaGVpZ2h0OjIuNGVtO3RleHQtYWxpZ246anVzdGlmeX0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX3N1bW1hcnktLTMtVjJDLmxpbmtfX2xpbmVzMi0tSVgyU0o6YmVmb3Jle2NvbnRlbnQ6XFxcIi4uLlxcXCI7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19zdW1tYXJ5LS0zLVYyQy5saW5rX19saW5lczItLUlYMlNKOmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt3aWR0aDoxZW07aGVpZ2h0OjFlbTttYXJnaW4tdG9wOi4yZW07YmFja2dyb3VuZC1jb2xvcjojZmZmfS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXM4LS0zQlhqOHtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7bGluZS1oZWlnaHQ6MS4yZW07bWF4LWhlaWdodDo5LjZlbTt0ZXh0LWFsaWduOmp1c3RpZnl9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19zdW1tYXJ5LS0zLVYyQy5saW5rX19saW5lczgtLTNCWGo4OmJlZm9yZXtjb250ZW50OlxcXCIuLi5cXFwiO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7Ym90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXM4LS0zQlhqODphZnRlcntjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7d2lkdGg6MWVtO2hlaWdodDoxZW07bWFyZ2luLXRvcDouMmVtO2JhY2tncm91bmQtY29sb3I6I2ZmZn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX2Zvb3Rlci0tM2xJOTB7LXdlYmtpdC1ib3gtYWxpZ246ZW5kOy1tcy1mbGV4LWFsaWduOmVuZDthbGlnbi1pdGVtczpmbGV4LWVuZDstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5saW5rX19zZWxmLS0ybExhTCAubGlua19fbGluay0tMi1BWjF7ZGlzcGxheTpibG9jazt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7Y29sb3I6IzAwNjYyMTtmb250LXNpemU6LjhlbTstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjA7b3V0bGluZTpub25lfS5saW5rX19zZWxmLS0ybExhTCAubGlua19fbGluay0tMi1BWjE6bGluaywubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX2xpbmstLTItQVoxOnZpc2l0ZWR7dGV4dC1kZWNvcmF0aW9uOm5vbmV9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmsuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxtQkFBTSxvQkFBb0Isb0JBQW9CLGFBQWEsNEJBQTRCLDZCQUE2QiwwQkFBMEIsc0JBQXNCLGNBQWMsZUFBZSxDQUFDLHVDQUFhLG1CQUFtQixnQkFBZ0IsdUJBQXVCLGNBQWMsZ0JBQWdCLGdCQUFnQixvQkFBb0IsYUFBYSxDQUFDLHdDQUFjLHlCQUF5QixzQkFBc0IsNkJBQTZCLENBQUMseUNBQWUsYUFBYSxDQUFDLDZEQUFzQixnQkFBZ0Isa0JBQWtCLGtCQUFrQixpQkFBaUIsa0JBQWtCLENBQUMsb0VBQTZCLGNBQWMsa0JBQWtCLFFBQVEsU0FBUyxxQkFBcUIsQ0FBQyxtRUFBNEIsV0FBVyxrQkFBa0IsUUFBUSxVQUFVLFdBQVcsZ0JBQWlCLHFCQUFxQixDQUFDLDZEQUFzQixnQkFBZ0Isa0JBQWtCLGtCQUFrQixpQkFBaUIsa0JBQWtCLENBQUMsb0VBQTZCLGNBQWMsa0JBQWtCLFFBQVEsU0FBUyxxQkFBcUIsQ0FBQyxtRUFBNEIsV0FBVyxrQkFBa0IsUUFBUSxVQUFVLFdBQVcsZ0JBQWlCLHFCQUFxQixDQUFDLHdDQUFjLHNCQUFzQixtQkFBbUIscUJBQXFCLHlCQUF5QixzQkFBc0IsNkJBQTZCLENBQUMsc0NBQVksY0FBYyxtQkFBbUIsZ0JBQWdCLHVCQUF1QixjQUFjLGVBQWdCLG9CQUFvQixjQUFjLFlBQVksQ0FBQyxBQUFzQyx5RkFBb0Isb0JBQW9CLENBQUNcIixcImZpbGVcIjpcImxpbmsuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uO21pbi13aWR0aDo3NSU7Zm9udC13ZWlnaHQ6MzAwfS5zZWxmIC50aXRsZXt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7Y29sb3I6IzI2M2ZmZjtmb250LXdlaWdodDo3MDA7Zm9udC1zaXplOjEuMmVtOy1tcy1mbGV4LW5lZ2F0aXZlOjA7ZmxleC1zaHJpbms6MH0uc2VsZiAuaGVhZGVyey13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LnNlbGYgLnN1bW1hcnl7Y29sb3I6IzU0NTQ1NH0uc2VsZiAuc3VtbWFyeS5saW5lczJ7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2xpbmUtaGVpZ2h0OjEuMmVtO21heC1oZWlnaHQ6Mi40ZW07dGV4dC1hbGlnbjpqdXN0aWZ5fS5zZWxmIC5zdW1tYXJ5LmxpbmVzMjpiZWZvcmV7Y29udGVudDonLi4uJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uc2VsZiAuc3VtbWFyeS5saW5lczI6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3dpZHRoOjFlbTtoZWlnaHQ6MWVtO21hcmdpbi10b3A6MC4yZW07YmFja2dyb3VuZC1jb2xvcjojZmZmfS5zZWxmIC5zdW1tYXJ5LmxpbmVzOHtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7bGluZS1oZWlnaHQ6MS4yZW07bWF4LWhlaWdodDo5LjZlbTt0ZXh0LWFsaWduOmp1c3RpZnl9LnNlbGYgLnN1bW1hcnkubGluZXM4OmJlZm9yZXtjb250ZW50OicuLi4nO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7Ym90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5zZWxmIC5zdW1tYXJ5LmxpbmVzODphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7d2lkdGg6MWVtO2hlaWdodDoxZW07bWFyZ2luLXRvcDowLjJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnNlbGYgLmZvb3Rlcnstd2Via2l0LWJveC1hbGlnbjplbmQ7LW1zLWZsZXgtYWxpZ246ZW5kO2FsaWduLWl0ZW1zOmZsZXgtZW5kOy13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LnNlbGYgLmxpbmt7ZGlzcGxheTpibG9jazt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7Y29sb3I6IzAwNjYyMTtmb250LXNpemU6MC44ZW07LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowO291dGxpbmU6bm9uZX0uc2VsZiAubGluazpsaW5re3RleHQtZGVjb3JhdGlvbjpub25lfS5zZWxmIC5saW5rOnZpc2l0ZWR7dGV4dC1kZWNvcmF0aW9uOm5vbmV9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJsaW5rX19zZWxmLS0ybExhTFwiLFxuXHRcInRpdGxlXCI6IFwibGlua19fdGl0bGUtLTNXaHF1XCIsXG5cdFwiaGVhZGVyXCI6IFwibGlua19faGVhZGVyLS1EYlVRUFwiLFxuXHRcInN1bW1hcnlcIjogXCJsaW5rX19zdW1tYXJ5LS0zLVYyQ1wiLFxuXHRcImxpbmVzMlwiOiBcImxpbmtfX2xpbmVzMi0tSVgyU0pcIixcblx0XCJsaW5lczhcIjogXCJsaW5rX19saW5lczgtLTNCWGo4XCIsXG5cdFwiZm9vdGVyXCI6IFwibGlua19fZm9vdGVyLS0zbEk5MFwiLFxuXHRcImxpbmtcIjogXCJsaW5rX19saW5rLS0yLUFaMVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5saW5rTGlzdF9fc2VsZi0tWThRT3EgLmxpbmtMaXN0X19yb3ctLUx4cHJYe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdztwYWRkaW5nOjEwcHh9LmxpbmtMaXN0X19zZWxmLS1ZOFFPcSAubGlua0xpc3RfX2J1dHRvbi0tZWx6MVh7bWFyZ2luLWxlZnQ6YXV0b31cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGlua0xpc3Quc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSw2Q0FBVyxvQkFBb0Isb0JBQW9CLGFBQWEsOEJBQThCLDZCQUE2Qix1QkFBdUIsbUJBQW1CLFlBQVksQ0FBQyxnREFBYyxnQkFBZ0IsQ0FBQ1wiLFwiZmlsZVwiOlwibGlua0xpc3Quc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZiAucm93e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdztwYWRkaW5nOjEwcHh9LnNlbGYgLmJ1dHRvbnttYXJnaW4tbGVmdDphdXRvfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwibGlua0xpc3RfX3NlbGYtLVk4UU9xXCIsXG5cdFwicm93XCI6IFwibGlua0xpc3RfX3Jvdy0tTHhwclhcIixcblx0XCJidXR0b25cIjogXCJsaW5rTGlzdF9fYnV0dG9uLS1lbHoxWFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rTGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGlua0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmxvYWRlcl9fc2VsZi0tMlU5YXN7Ym9yZGVyOjFweCBzb2xpZCAjZWVmMWYyO2JvcmRlci10b3A6MXB4IHNvbGlkICMyNjNmZmY7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDstd2Via2l0LWFuaW1hdGlvbjpsb2FkZXJfX3NwaW4tLTFXc20yIDJzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246bG9hZGVyX19zcGluLS0xV3NtMiAycyBsaW5lYXIgaW5maW5pdGV9QC13ZWJraXQta2V5ZnJhbWVzIGxvYWRlcl9fc3Bpbi0tMVdzbTJ7MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKTt0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QGtleWZyYW1lcyBsb2FkZXJfX3NwaW4tLTFXc20yezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxdHVybik7dHJhbnNmb3JtOnJvdGF0ZSgxdHVybil9fVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sb2FkZXIuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxxQkFBTSx5QkFBeUIsNkJBQTZCLGtCQUFrQixXQUFXLFlBQVkseURBQTBDLGdEQUFpQyxDQUFDLHVDQUF3QixHQUFHLCtCQUErQixzQkFBc0IsQ0FBQyxHQUFLLGdDQUFpQyx1QkFBd0IsQ0FBQyxDQUFDLCtCQUFnQixHQUFHLCtCQUErQixzQkFBc0IsQ0FBQyxHQUFLLGdDQUFpQyx1QkFBd0IsQ0FBQyxDQUFDXCIsXCJmaWxlXCI6XCJsb2FkZXIuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntib3JkZXI6MXB4IHNvbGlkICNlZWYxZjI7Ym9yZGVyLXRvcDoxcHggc29saWQgIzI2M2ZmZjtib3JkZXItcmFkaXVzOjUwJTt3aWR0aDo0MHB4O2hlaWdodDo0MHB4Oy13ZWJraXQtYW5pbWF0aW9uOnNwaW4gMnMgbGluZWFyIGluZmluaXRlO2FuaW1hdGlvbjpzcGluIDJzIGxpbmVhciBpbmZpbml0ZX1ALXdlYmtpdC1rZXlmcmFtZXMgc3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBzcGluezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImxvYWRlcl9fc2VsZi0tMlU5YXNcIixcblx0XCJzcGluXCI6IFwibG9hZGVyX19zcGluLS0xV3NtMlwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sb2FkZXIuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xvYWRlci5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIucGFwZXJfX3NlbGYtLTFxdE5pey13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDoxO2ZsZXg6MTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7LXdlYmtpdC1ib3gtc2hhZG93OjAgNXB4IDIwcHggMCByZ2JhKDE5LDM4LDExMCwuMDgpO2JveC1zaGFkb3c6MCA1cHggMjBweCAwIHJnYmEoMTksMzgsMTEwLC4wOCk7bWFyZ2luLXRvcDoyMHB4O2JvcmRlci1yYWRpdXM6M3B4fVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9wYXBlci5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG9CQUFNLG1CQUFtQixXQUFXLE9BQU8sc0JBQXNCLG9EQUF5RCw0Q0FBaUQsZ0JBQWdCLGlCQUFpQixDQUFDXCIsXCJmaWxlXCI6XCJwYXBlci5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxmey13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDoxO2ZsZXg6MTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7LXdlYmtpdC1ib3gtc2hhZG93OjBweCA1cHggMjBweCAwcHggcmdiYSgxOSwzOCwxMTAsMC4wOCk7Ym94LXNoYWRvdzowcHggNXB4IDIwcHggMHB4IHJnYmEoMTksMzgsMTEwLDAuMDgpO21hcmdpbi10b3A6MjBweDtib3JkZXItcmFkaXVzOjNweH1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcInBhcGVyX19zZWxmLS0xcXROaVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9wYXBlci5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRleHRXaXRoTGFiZWxfX3NlbGYtLTNTZUJLe3BhZGRpbmc6MWVtfS50ZXh0V2l0aExhYmVsX19zZWxmLS0zU2VCSyAudGV4dFdpdGhMYWJlbF9fdGV4dC0tMmxNRnp7bWFyZ2luLXRvcDo1cHg7Zm9udC1zaXplOjE1cHg7Y29sb3I6IzFiMjQzNzt0ZXh0LWFsaWduOmxlZnR9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3RleHRXaXRoTGFiZWwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSw0QkFBTSxXQUFXLENBQUMsd0RBQVksZUFBZSxlQUFlLGNBQWMsZUFBZSxDQUFDXCIsXCJmaWxlXCI6XCJ0ZXh0V2l0aExhYmVsLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7cGFkZGluZzoxZW19LnNlbGYgLnRleHR7bWFyZ2luLXRvcDo1cHg7Zm9udC1zaXplOjE1cHg7Y29sb3I6IzFiMjQzNzt0ZXh0LWFsaWduOmxlZnR9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJ0ZXh0V2l0aExhYmVsX19zZWxmLS0zU2VCS1wiLFxuXHRcInRleHRcIjogXCJ0ZXh0V2l0aExhYmVsX190ZXh0LS0ybE1GelwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90ZXh0V2l0aExhYmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90ZXh0V2l0aExhYmVsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50b29sdGlwX19zZWxmLS0yaDhwM3twb3NpdGlvbjpyZWxhdGl2ZX0udG9vbHRpcF9fc2VsZi0tMmg4cDMgLnRvb2x0aXBfX3RleHQtLTFjejRle3Zpc2liaWxpdHk6aGlkZGVuO3dpZHRoOjEyMHB4O2JhY2tncm91bmQtY29sb3I6IzFiMjQzNztjb2xvcjojZmZmO3RleHQtYWxpZ246Y2VudGVyO3BhZGRpbmc6NXB4IDA7Ym9yZGVyLXJhZGl1czo2cHg7cG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5OjBzO3RyYW5zaXRpb24tZGVsYXk6MHN9LnRvb2x0aXBfX3NlbGYtLTJoOHAzOmhvdmVyIC50b29sdGlwX190ZXh0LS0xY3o0ZXt2aXNpYmlsaXR5OnZpc2libGU7LXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5Oi41czt0cmFuc2l0aW9uLWRlbGF5Oi41c31cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdG9vbHRpcC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHNCQUFNLGlCQUFpQixDQUFDLDRDQUFZLGtCQUFrQixZQUFZLHlCQUF5QixXQUFXLGtCQUFrQixjQUFjLGtCQUFrQixrQkFBa0IsNEJBQTRCLG1CQUFtQixDQUFDLGtEQUFrQixtQkFBbUIsNkJBQThCLG9CQUFxQixDQUFDXCIsXCJmaWxlXCI6XCJ0b29sdGlwLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7cG9zaXRpb246cmVsYXRpdmV9LnNlbGYgLnRleHR7dmlzaWJpbGl0eTpoaWRkZW47d2lkdGg6MTIwcHg7YmFja2dyb3VuZC1jb2xvcjojMWIyNDM3O2NvbG9yOiNmZmY7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzo1cHggMDtib3JkZXItcmFkaXVzOjZweDtwb3NpdGlvbjphYnNvbHV0ZTstd2Via2l0LXRyYW5zaXRpb24tZGVsYXk6MHM7dHJhbnNpdGlvbi1kZWxheTowc30uc2VsZjpob3ZlciAudGV4dHt2aXNpYmlsaXR5OnZpc2libGU7LXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5OjAuNXM7dHJhbnNpdGlvbi1kZWxheTowLjVzfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwidG9vbHRpcF9fc2VsZi0tMmg4cDNcIixcblx0XCJ0ZXh0XCI6IFwidG9vbHRpcF9fdGV4dC0tMWN6NGVcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdG9vbHRpcC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdG9vbHRpcC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuU3RhdHVzX19zZWxmLS0yanR3b3t3aWR0aDoxMDB2dztoZWlnaHQ6MTAwdmg7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246c3RhcnQ7LW1zLWZsZXgtYWxpZ246c3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LlN0YXR1c19fc2VsZi0tMmp0d297LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1ib3gtcGFjazpzdGFydDstbXMtZmxleC1wYWNrOnN0YXJ0O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfX0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19wcmV2aWV3LS0xSVVWMHt3aWR0aDozMDBweDtoZWlnaHQ6MjUwcHg7bWFyZ2luLXJpZ2h0OjMwcHg7cGFkZGluZzoxMHB4Oy13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDphdXRvO2ZsZXg6YXV0bzstd2Via2l0LWJveC1mbGV4OjA7LW1zLWZsZXgtcG9zaXRpdmU6MDtmbGV4LWdyb3c6MDstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjA7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fcHJldmlldy0tMUlVVjB7d2lkdGg6Y2FsYygxMDB2dyAtIDIwcHgpO2hlaWdodDp1bnNldDttYXJnaW46MDttYXJnaW4tYm90dG9tOjIwcHh9fS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2xvYWRlci0tMkZrc1B7d2lkdGg6MTAwJTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19jb250ZW50LS0xUnVZN3t0ZXh0LWFsaWduOmNlbnRlcjttYXgtd2lkdGg6NDB2dztwYWRkaW5nOjEwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2NvbnRlbnQtLTFSdVk3e21heC13aWR0aDpjYWxjKDEwMHZ3IC0gMjBweCk7bWFyZ2luOjB9fS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2xhYmVsLS1sR1FwWXt3aWR0aDoxMDAlO3BhZGRpbmc6MDttYXJnaW4tdG9wOi0xZW19LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fbGluay1sYWJlbC0tMmNjNWR7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93fS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2xpbmstLTJXYXVVe292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcH0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19hZGQtYm9va21hcmstLUg2X0pLey13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDphdXRvO2ZsZXg6YXV0bzstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL2FwcHMvbGlua3Mvc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxxQkFBTSxZQUFZLGFBQWEsb0JBQW9CLG9CQUFvQixhQUFhLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQix3QkFBd0IscUJBQXFCLHVCQUF1Qix3QkFBd0IscUJBQXFCLHNCQUFzQixDQUFDLHFDQUFzQyxxQkFBTSw0QkFBNEIsNkJBQTZCLDBCQUEwQixzQkFBc0IsdUJBQXVCLG9CQUFvQiwyQkFBMkIseUJBQXlCLHNCQUFzQixrQkFBa0IsQ0FBQyxDQUFDLDZDQUFlLFlBQVksYUFBYSxrQkFBa0IsYUFBYSxtQkFBbUIsY0FBYyxVQUFVLG1CQUFtQixvQkFBb0IsWUFBWSxvQkFBb0IsY0FBYyxvQkFBb0Isb0JBQW9CLGFBQWEseUJBQXlCLHNCQUFzQixrQkFBa0IsQ0FBQyxxQ0FBc0MsNkNBQWUseUJBQXlCLGFBQWEsU0FBUyxrQkFBa0IsQ0FBQyxDQUFDLDRDQUFjLFdBQVcsb0JBQW9CLG9CQUFvQixhQUFhLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQix3QkFBd0IscUJBQXFCLHVCQUF1Qix5QkFBeUIsc0JBQXNCLGtCQUFrQixDQUFDLDZDQUFlLGtCQUFrQixlQUFlLFlBQVksQ0FBQyxxQ0FBc0MsNkNBQWUsNkJBQTZCLFFBQVEsQ0FBQyxDQUFDLDJDQUFhLFdBQVcsVUFBVSxlQUFlLENBQUMsZ0RBQWtCLG9CQUFvQixvQkFBb0IsYUFBYSw4QkFBOEIsNkJBQTZCLHVCQUF1QixrQkFBa0IsQ0FBQywwQ0FBWSxnQkFBZ0IsdUJBQXVCLGtCQUFrQixDQUFDLGtEQUFvQixtQkFBbUIsY0FBYyxVQUFVLG9CQUFvQixhQUFhLENBQUNcIixcImZpbGVcIjpcIlN0YXR1cy5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpzdGFydDstbXMtZmxleC1hbGlnbjpzdGFydDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGZ7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1ib3gtcGFjazpzdGFydDstbXMtZmxleC1wYWNrOnN0YXJ0O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfX0uc2VsZiAucHJldmlld3t3aWR0aDozMDBweDtoZWlnaHQ6MjUwcHg7bWFyZ2luLXJpZ2h0OjMwcHg7cGFkZGluZzoxMHB4Oy13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDphdXRvO2ZsZXg6YXV0bzstd2Via2l0LWJveC1mbGV4OjA7LW1zLWZsZXgtcG9zaXRpdmU6MDtmbGV4LWdyb3c6MDstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjA7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmIC5wcmV2aWV3e3dpZHRoOmNhbGMoMTAwdncgLSAyMHB4KTtoZWlnaHQ6dW5zZXQ7bWFyZ2luOjA7bWFyZ2luLWJvdHRvbToyMHB4fX0uc2VsZiAubG9hZGVye3dpZHRoOjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LnNlbGYgLmNvbnRlbnR7dGV4dC1hbGlnbjpjZW50ZXI7bWF4LXdpZHRoOjQwdnc7cGFkZGluZzoxMHB4fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLmNvbnRlbnR7bWF4LXdpZHRoOmNhbGMoMTAwdncgLSAyMHB4KTttYXJnaW46MH19LnNlbGYgLmxhYmVse3dpZHRoOjEwMCU7cGFkZGluZzowO21hcmdpbi10b3A6LTFlbX0uc2VsZiAubGluay1sYWJlbHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3d9LnNlbGYgLmxpbmt7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwfS5zZWxmIC5hZGQtYm9va21hcmt7LXdlYmtpdC1ib3gtZmxleDoxOy1tcy1mbGV4OmF1dG87ZmxleDphdXRvOy1tcy1mbGV4LW5lZ2F0aXZlOjA7ZmxleC1zaHJpbms6MH1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcIlN0YXR1c19fc2VsZi0tMmp0d29cIixcblx0XCJwcmV2aWV3XCI6IFwiU3RhdHVzX19wcmV2aWV3LS0xSVVWMFwiLFxuXHRcImxvYWRlclwiOiBcIlN0YXR1c19fbG9hZGVyLS0yRmtzUFwiLFxuXHRcImNvbnRlbnRcIjogXCJTdGF0dXNfX2NvbnRlbnQtLTFSdVk3XCIsXG5cdFwibGFiZWxcIjogXCJTdGF0dXNfX2xhYmVsLS1sR1FwWVwiLFxuXHRcImxpbmstbGFiZWxcIjogXCJTdGF0dXNfX2xpbmstbGFiZWwtLTJjYzVkXCIsXG5cdFwibGlua0xhYmVsXCI6IFwiU3RhdHVzX19saW5rLWxhYmVsLS0yY2M1ZFwiLFxuXHRcImxpbmtcIjogXCJTdGF0dXNfX2xpbmstLTJXYXVVXCIsXG5cdFwiYWRkLWJvb2ttYXJrXCI6IFwiU3RhdHVzX19hZGQtYm9va21hcmstLUg2X0pLXCIsXG5cdFwiYWRkQm9va21hcmtcIjogXCJTdGF0dXNfX2FkZC1ib29rbWFyay0tSDZfSktcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvU3RhdHVzL1N0YXR1cy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvU3RhdHVzL1N0YXR1cy5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc3RlcHNfX3NlbGYtLTNLeUhte3dpZHRoOjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LnN0ZXBzX19zZWxmLS0zS3lIbXstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93fX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fcHJvZ3Jlc3MtY290YWluZXItLTFtMmxQe3Bvc2l0aW9uOnJlbGF0aXZlfS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19wcm9ncmVzcy0tMzJmYUJ7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDoyMHB4O3otaW5kZXg6MTt3aWR0aDoxMDAlO2hlaWdodDoxZW07Ym9yZGVyLXJhZGl1czoxZW07YmFja2dyb3VuZC1jb2xvcjojZWVmMWYyfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MTIwMHB4KXsuc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fcHJvZ3Jlc3MtLTMyZmFCe3dpZHRoOjFlbTtoZWlnaHQ6MTAwJTt0b3A6MDtsZWZ0OjIwcHh9fS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwcy1jb250YWluZXItLTFGeE5Xe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MTIwMHB4KXsuc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcHMtY29udGFpbmVyLS0xRnhOV3std2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn19LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47ei1pbmRleDoyO21hcmdpbi10b3A6Y2FsYygyMHB4ICsgLjVlbSAtIDEuNWVtKX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSey13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7bWFyZ2luLXRvcDowO21hcmdpbi1sZWZ0OmNhbGMoMjBweCArIC41ZW0gLSAxLjVlbSl9fS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUi5zdGVwc19fZGlzYWJsZWQtLWdWUklxe29wYWNpdHk6LjU7Y3Vyc29yOm5vdC1hbGxvd2VkfS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUi5zdGVwc19fd2FpdGluZy0tWkg0Nm17b3BhY2l0eTouNX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlIuc3RlcHNfX2RvbmUtLTJDdk1EIC5zdGVwc19faWNvbi0tMmJvNXMsLnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSLnN0ZXBzX19kb25lLS0yQ3ZNRCBwYXRoe2NvbG9yOmxpbWU7ZmlsbDpsaW1lfS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUiAuc3RlcHNfX2ljb24tLTJibzVzey1tcy1mbGV4LWl0ZW0tYWxpZ246Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyO3dpZHRoOjNlbTtoZWlnaHQ6M2VtO2JhY2tncm91bmQtY29sb3I6I2VlZjFmMjtib3JkZXItcmFkaXVzOjNlbTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSIC5zdGVwc19fY29udGVudC0tMWFLbHp7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSIC5zdGVwc19fY29udGVudC0tMWFLbHp7LXdlYmtpdC1ib3gtYWxpZ246c3RhcnQ7LW1zLWZsZXgtYWxpZ246c3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydDtwYWRkaW5nLWxlZnQ6MjBweH19LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX2ljb24tLTJibzVze2ZvbnQtc2l6ZToxZW19XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL2FwcHMvbGlua3Mvc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL3N0ZXBzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsb0JBQU0sV0FBVyxvQkFBb0Isb0JBQW9CLGFBQWEsNEJBQTRCLDZCQUE2QiwwQkFBMEIscUJBQXFCLENBQUMscUNBQXNDLG9CQUFNLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLGtCQUFrQixDQUFDLENBQUMscURBQXlCLGlCQUFpQixDQUFDLDRDQUFnQixrQkFBa0IsT0FBTyxTQUFTLFVBQVUsV0FBVyxXQUFXLGtCQUFrQix3QkFBd0IsQ0FBQyxxQ0FBc0MsNENBQWdCLFVBQVUsWUFBWSxNQUFNLFNBQVMsQ0FBQyxDQUFDLG1EQUF1QixvQkFBb0Isb0JBQW9CLGFBQWEsOEJBQThCLDZCQUE2Qix1QkFBdUIsbUJBQW1CLHlCQUF5QixzQkFBc0IsNkJBQTZCLENBQUMscUNBQXNDLG1EQUF1Qiw0QkFBNEIsNkJBQTZCLDBCQUEwQixxQkFBcUIsQ0FBQyxDQUFDLHdDQUFZLG9CQUFvQixvQkFBb0IsYUFBYSw0QkFBNEIsNkJBQTZCLDBCQUEwQixzQkFBc0IsVUFBVSxvQ0FBcUMsQ0FBQyxxQ0FBc0Msd0NBQVksOEJBQThCLDZCQUE2Qix1QkFBdUIsbUJBQW1CLGFBQWEscUNBQXNDLENBQUMsQ0FBQywrREFBcUIsV0FBWSxrQkFBa0IsQ0FBQyw4REFBb0IsVUFBVyxDQUFDLCtJQUE2QyxXQUFXLFNBQVMsQ0FBQyw0REFBa0IsMkJBQTJCLGtCQUFrQixVQUFVLFdBQVcseUJBQXlCLGtCQUFrQixvQkFBb0Isb0JBQW9CLGFBQWEsd0JBQXdCLHFCQUFxQix1QkFBdUIseUJBQXlCLHNCQUFzQixrQkFBa0IsQ0FBQywrREFBcUIsb0JBQW9CLG9CQUFvQixhQUFhLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLHNCQUFzQix5QkFBeUIsc0JBQXNCLGtCQUFrQixDQUFDLHFDQUFzQywrREFBcUIsd0JBQXdCLHFCQUFxQix1QkFBdUIsaUJBQWlCLENBQUMsQ0FBQyx3Q0FBWSxhQUFhLENBQUNcIixcImZpbGVcIjpcInN0ZXBzLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7d2lkdGg6MTAwJTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1ufUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGZ7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd319LnNlbGYgLnByb2dyZXNzLWNvdGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlfS5zZWxmIC5wcm9ncmVzc3twb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjIwcHg7ei1pbmRleDoxO3dpZHRoOjEwMCU7aGVpZ2h0OjFlbTtib3JkZXItcmFkaXVzOjFlbTtiYWNrZ3JvdW5kLWNvbG9yOiNlZWYxZjJ9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZiAucHJvZ3Jlc3N7d2lkdGg6MWVtO2hlaWdodDoxMDAlO3RvcDowO2xlZnQ6MjBweH19LnNlbGYgLnN0ZXBzLWNvbnRhaW5lcntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7LXdlYmtpdC1ib3gtcGFjazpqdXN0aWZ5Oy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmIC5zdGVwcy1jb250YWluZXJ7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59fS5zZWxmIC5zdGVwe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47ei1pbmRleDoyO21hcmdpbi10b3A6Y2FsYygyMHB4ICsgMC41ZW0gLSAxLjVlbSl9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZiAuc3RlcHstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93O21hcmdpbi10b3A6MDttYXJnaW4tbGVmdDpjYWxjKDIwcHggKyAwLjVlbSAtIDEuNWVtKX19LnNlbGYgLnN0ZXAuZGlzYWJsZWR7b3BhY2l0eTowLjU7Y3Vyc29yOm5vdC1hbGxvd2VkfS5zZWxmIC5zdGVwLndhaXRpbmd7b3BhY2l0eTowLjV9LnNlbGYgLnN0ZXAuZG9uZSAuaWNvbiwuc2VsZiAuc3RlcC5kb25lIHBhdGh7Y29sb3I6bGltZTtmaWxsOmxpbWV9LnNlbGYgLnN0ZXAgLmljb257LW1zLWZsZXgtaXRlbS1hbGlnbjpjZW50ZXI7YWxpZ24tc2VsZjpjZW50ZXI7d2lkdGg6M2VtO2hlaWdodDozZW07YmFja2dyb3VuZC1jb2xvcjojZWVmMWYyO2JvcmRlci1yYWRpdXM6M2VtO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uc2VsZiAuc3RlcCAuY29udGVudHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLnN0ZXAgLmNvbnRlbnR7LXdlYmtpdC1ib3gtYWxpZ246c3RhcnQ7LW1zLWZsZXgtYWxpZ246c3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydDtwYWRkaW5nLWxlZnQ6MjBweH19LnNlbGYgLmljb257Zm9udC1zaXplOjFlbX1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcInN0ZXBzX19zZWxmLS0zS3lIbVwiLFxuXHRcInByb2dyZXNzLWNvdGFpbmVyXCI6IFwic3RlcHNfX3Byb2dyZXNzLWNvdGFpbmVyLS0xbTJsUFwiLFxuXHRcInByb2dyZXNzQ290YWluZXJcIjogXCJzdGVwc19fcHJvZ3Jlc3MtY290YWluZXItLTFtMmxQXCIsXG5cdFwicHJvZ3Jlc3NcIjogXCJzdGVwc19fcHJvZ3Jlc3MtLTMyZmFCXCIsXG5cdFwic3RlcHMtY29udGFpbmVyXCI6IFwic3RlcHNfX3N0ZXBzLWNvbnRhaW5lci0tMUZ4TldcIixcblx0XCJzdGVwc0NvbnRhaW5lclwiOiBcInN0ZXBzX19zdGVwcy1jb250YWluZXItLTFGeE5XXCIsXG5cdFwic3RlcFwiOiBcInN0ZXBzX19zdGVwLS0zQkVmUlwiLFxuXHRcImRpc2FibGVkXCI6IFwic3RlcHNfX2Rpc2FibGVkLS1nVlJJcVwiLFxuXHRcIndhaXRpbmdcIjogXCJzdGVwc19fd2FpdGluZy0tWkg0Nm1cIixcblx0XCJkb25lXCI6IFwic3RlcHNfX2RvbmUtLTJDdk1EXCIsXG5cdFwiaWNvblwiOiBcInN0ZXBzX19pY29uLS0yYm81c1wiLFxuXHRcImNvbnRlbnRcIjogXCJzdGVwc19fY29udGVudC0tMWFLbHpcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL3N0ZXBzLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5XaGl0ZWxpc3RfX3NlbGYtLTFCa016e3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDttYXJnaW4tdG9wOjEwcHg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uV2hpdGVsaXN0X19zZWxmLS0xQmtNeiAuV2hpdGVsaXN0X19wYXBlci0tMlpDc3V7d2lkdGg6NzAlO3BhZGRpbmc6MTBweH1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvYXBwcy9saW5rcy9zcmMvcGFnZXMvV2hpdGVsaXN0LnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsd0JBQU0sV0FBVyxZQUFZLG9CQUFvQixvQkFBb0IsYUFBYSxnQkFBZ0IsNEJBQTRCLDZCQUE2QiwwQkFBMEIsc0JBQXNCLHdCQUF3QixxQkFBcUIsdUJBQXVCLHlCQUF5QixzQkFBc0Isa0JBQWtCLENBQUMsaURBQWEsVUFBVSxZQUFZLENBQUNcIixcImZpbGVcIjpcIldoaXRlbGlzdC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDttYXJnaW4tdG9wOjEwcHg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uc2VsZiAucGFwZXJ7d2lkdGg6NzAlO3BhZGRpbmc6MTBweH1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcIldoaXRlbGlzdF9fc2VsZi0tMUJrTXpcIixcblx0XCJwYXBlclwiOiBcIldoaXRlbGlzdF9fcGFwZXItLTJaQ3N1XCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAaW1wb3J0IHVybChodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9UFQrU2Fuczo0MDAsNzAwKTtcIiwgXCJcIl0pO1xuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImJvZHl7Zm9udC1mYW1pbHk6UFQgU2FucyxzYW5zLXNlcmlmfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9hcHBzL2xpbmtzL3N0eWxlcy9hbGwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBdUUsS0FBSyw4QkFBaUMsQ0FBQ1wiLFwiZmlsZVwiOlwiYWxsLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGltcG9ydCB1cmwoXFxcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1QVCtTYW5zOjQwMCw3MDBcXFwiKTtib2R5e2ZvbnQtZmFtaWx5OidQVCBTYW5zJywgc2Fucy1zZXJpZn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi9zdHlsZXMvYWxsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3R5bGVzL2FsbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjEuMicsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3V0ZjgvdXRmOC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3V0ZjgvdXRmOC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIHZhbHVlRXF1YWwgPSBmdW5jdGlvbiB2YWx1ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiB2YWx1ZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgfSk7XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gdmFsdWVFcXVhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdlYjMgPSByZXF1aXJlKCcuL2xpYi93ZWIzJyk7XG5cbi8vIGRvbnQgb3ZlcnJpZGUgZ2xvYmFsIHZhcmlhYmxlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5XZWIzID09PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5XZWIzID0gV2ViMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWIzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW3tcImNvbnN0YW50XCI6dHJ1ZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfb3duZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwibmFtZVwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJvX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcIm93bmVyXCIsXCJvdXRwdXRzXCI6W3tcIm5hbWVcIjpcIlwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOnRydWUsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiY29udGVudFwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcImFkZHJcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwicmVzZXJ2ZVwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcInN1YlJlZ2lzdHJhclwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfbmV3T3duZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwidHJhbnNmZXJcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwiX3JlZ2lzdHJhclwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJuYW1lXCI6XCJzZXRTdWJSZWdpc3RyYXJcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbXSxcIm5hbWVcIjpcIlJlZ2lzdHJhclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfYVwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJuYW1lXCI6XCJfcHJpbWFyeVwiLFwidHlwZVwiOlwiYm9vbFwifV0sXCJuYW1lXCI6XCJzZXRBZGRyZXNzXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcIl9jb250ZW50XCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcInNldENvbnRlbnRcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiZGlzb3duXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcIl93aW5uZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwiQXVjdGlvbkVuZGVkXCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcIl9iaWRkZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wiaW5kZXhlZFwiOmZhbHNlLFwibmFtZVwiOlwiX3ZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIk5ld0JpZFwiLFwidHlwZVwiOlwiZXZlbnRcIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJuYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcIkNoYW5nZWRcIixcInR5cGVcIjpcImV2ZW50XCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwibmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImFkZHJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwiUHJpbWFyeUNoYW5nZWRcIixcInR5cGVcIjpcImV2ZW50XCJ9XVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb25cbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb25cbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBbe1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcIm93bmVyXCIsXCJvdXRwdXRzXCI6W3tcIm5hbWVcIjpcIlwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcIl9yZWZ1bmRcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwiZGlzb3duXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOnRydWUsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiYWRkclwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJyZXNlcnZlXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcIl9uZXdPd25lclwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJuYW1lXCI6XCJ0cmFuc2ZlclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfYVwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJuYW1lXCI6XCJzZXRBZGRyXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIm5hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiQ2hhbmdlZFwiLFwidHlwZVwiOlwiZXZlbnRcIn1dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb25cbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW3tcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDI1NlwifV0sXCJuYW1lXCI6XCJ0cmFuc2ZlclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJmcm9tXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LHtcIm5hbWVcIjpcImluZGlyZWN0SWRcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjpcInVpbnQyNTZcIn1dLFwibmFtZVwiOlwiaWNhcFRyYW5zZmVyXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcImRlcG9zaXRcIixcIm91dHB1dHNcIjpbXSxcInBheWFibGVcIjp0cnVlLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJmcm9tXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIkFub255bW91c0RlcG9zaXRcIixcInR5cGVcIjpcImV2ZW50XCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIkRlcG9zaXRcIixcInR5cGVcIjpcImV2ZW50XCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIlRyYW5zZmVyXCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImZyb21cIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJpbmRpcmVjdElkXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIkljYXBUcmFuc2ZlclwiLFwidHlwZVwiOlwiZXZlbnRcIn1dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvU21hcnRFeGNoYW5nZS5qc29uXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlQWRkcmVzcyBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyBhZGRyZXNzIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBhZGRyZXNzXG4gKiBhZGRyZXNzW11cbiAqIGFkZHJlc3NbNF1cbiAqIGFkZHJlc3NbXVtdXG4gKiBhZGRyZXNzWzNdW11cbiAqIGFkZHJlc3NbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0SW50O1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0QWRkcmVzcztcbn07XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVBZGRyZXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvYWRkcmVzcyhcXFsoWzAtOV0qKVxcXSk/Lyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYWRkcmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2FkZHJlc3MuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVCb29sIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIGJvb2wgdHlwZVxuICogSXQgbWF0Y2hlczpcbiAqIGJvb2xcbiAqIGJvb2xbXVxuICogYm9vbFs0XVxuICogYm9vbFtdW11cbiAqIGJvb2xbM11bXVxuICogYm9vbFtdWzZdW10sIC4uLlxuICovXG52YXIgU29saWRpdHlUeXBlQm9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRCb29sO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0Qm9vbDtcbn07XG5cblNvbGlkaXR5VHlwZUJvb2wucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVCb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUJvb2w7XG5cblNvbGlkaXR5VHlwZUJvb2wucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXmJvb2woXFxbKFswLTldKilcXF0pKiQvKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlQm9vbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9ib29sLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYm9vbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZUJ5dGVzIGlzIGEgcHJvdG90eXBlIHRoYXQgcmVwcmVzZW50cyB0aGUgYnl0ZXMgdHlwZS5cbiAqIEl0IG1hdGNoZXM6XG4gKiBieXRlc1xuICogYnl0ZXNbXVxuICogYnl0ZXNbNF1cbiAqIGJ5dGVzW11bXVxuICogYnl0ZXNbM11bXVxuICogYnl0ZXNbXVs2XVtdLCAuLi5cbiAqIGJ5dGVzMzJcbiAqIGJ5dGVzOFs0XVxuICogYnl0ZXNbM11bXVxuICovXG52YXIgU29saWRpdHlUeXBlQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0Qnl0ZXM7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRCeXRlcztcbn07XG5cblNvbGlkaXR5VHlwZUJ5dGVzLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlQnl0ZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlQnl0ZXM7XG5cblNvbGlkaXR5VHlwZUJ5dGVzLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15ieXRlcyhbMC05XXsxLH0pKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUJ5dGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2J5dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYnl0ZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgY29kZXIuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcblxudmFyIFNvbGlkaXR5VHlwZUFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcbnZhciBTb2xpZGl0eVR5cGVCb29sID0gcmVxdWlyZSgnLi9ib29sJyk7XG52YXIgU29saWRpdHlUeXBlSW50ID0gcmVxdWlyZSgnLi9pbnQnKTtcbnZhciBTb2xpZGl0eVR5cGVVSW50ID0gcmVxdWlyZSgnLi91aW50Jyk7XG52YXIgU29saWRpdHlUeXBlRHluYW1pY0J5dGVzID0gcmVxdWlyZSgnLi9keW5hbWljYnl0ZXMnKTtcbnZhciBTb2xpZGl0eVR5cGVTdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZycpO1xudmFyIFNvbGlkaXR5VHlwZVJlYWwgPSByZXF1aXJlKCcuL3JlYWwnKTtcbnZhciBTb2xpZGl0eVR5cGVVUmVhbCA9IHJlcXVpcmUoJy4vdXJlYWwnKTtcbnZhciBTb2xpZGl0eVR5cGVCeXRlcyA9IHJlcXVpcmUoJy4vYnl0ZXMnKTtcblxudmFyIGlzRHluYW1pYyA9IGZ1bmN0aW9uIChzb2xpZGl0eVR5cGUsIHR5cGUpIHtcbiAgIHJldHVybiBzb2xpZGl0eVR5cGUuaXNEeW5hbWljVHlwZSh0eXBlKSB8fFxuICAgICAgICAgIHNvbGlkaXR5VHlwZS5pc0R5bmFtaWNBcnJheSh0eXBlKTtcbn07XG5cbi8qKlxuICogU29saWRpdHlDb2RlciBwcm90b3R5cGUgc2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlL2RlY29kZSBzb2xpZGl0eSBwYXJhbXMgb2YgYW55IHR5cGVcbiAqL1xudmFyIFNvbGlkaXR5Q29kZXIgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICB0aGlzLl90eXBlcyA9IHR5cGVzO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byB0cmFuc2Zvcm0gdHlwZSB0byBTb2xpZGl0eVR5cGVcbiAqXG4gKiBAbWV0aG9kIF9yZXF1aXJlVHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm5zIHtTb2xpZGl0eVR5cGV9XG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3dzIGlmIG5vIG1hdGNoaW5nIHR5cGUgaXMgZm91bmRcbiAqL1xuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuX3JlcXVpcmVUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgc29saWRpdHlUeXBlID0gdGhpcy5fdHlwZXMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzVHlwZSh0eXBlKTtcbiAgICB9KVswXTtcblxuICAgIGlmICghc29saWRpdHlUeXBlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdpbnZhbGlkIHNvbGlkaXR5IHR5cGUhOiAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvbGlkaXR5VHlwZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIHBsYWluIHBhcmFtXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZVBhcmFtID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1zKFt0eXBlXSwgW3BhcmFtXSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBsaXN0IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFyYW1zXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgbGlzdCBvZiBwYXJhbXNcbiAqL1xuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZW5jb2RlUGFyYW1zID0gZnVuY3Rpb24gKHR5cGVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc29saWRpdHlUeXBlcyA9IHRoaXMuZ2V0U29saWRpdHlUeXBlcyh0eXBlcyk7XG5cbiAgICB2YXIgZW5jb2RlZHMgPSBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLmVuY29kZShwYXJhbXNbaW5kZXhdLCB0eXBlc1tpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGR5bmFtaWNPZmZzZXQgPSBzb2xpZGl0eVR5cGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzb2xpZGl0eVR5cGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBzdGF0aWNQYXJ0TGVuZ3RoID0gc29saWRpdHlUeXBlLnN0YXRpY1BhcnRMZW5ndGgodHlwZXNbaW5kZXhdKTtcbiAgICAgICAgdmFyIHJvdW5kZWRTdGF0aWNQYXJ0TGVuZ3RoID0gTWF0aC5mbG9vcigoc3RhdGljUGFydExlbmd0aCArIDMxKSAvIDMyKSAqIDMyO1xuXG4gICAgICAgIHJldHVybiBhY2MgKyAoaXNEeW5hbWljKHNvbGlkaXR5VHlwZXNbaW5kZXhdLCB0eXBlc1tpbmRleF0pID9cbiAgICAgICAgICAgIDMyIDpcbiAgICAgICAgICAgIHJvdW5kZWRTdGF0aWNQYXJ0TGVuZ3RoKTtcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLmVuY29kZU11bHRpV2l0aE9mZnNldCh0eXBlcywgc29saWRpdHlUeXBlcywgZW5jb2RlZHMsIGR5bmFtaWNPZmZzZXQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZU11bHRpV2l0aE9mZnNldCA9IGZ1bmN0aW9uICh0eXBlcywgc29saWRpdHlUeXBlcywgZW5jb2RlZHMsIGR5bmFtaWNPZmZzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgICAgIGlmIChpc0R5bmFtaWMoc29saWRpdHlUeXBlc1tpXSwgdHlwZXNbaV0pKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZi5mb3JtYXRJbnB1dEludChkeW5hbWljT2Zmc2V0KS5lbmNvZGUoKTtcbiAgICAgICAgICAgIHZhciBlID0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICBkeW5hbWljT2Zmc2V0ICs9IGUubGVuZ3RoIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGFkZCBsZW5ndGggdG8gZHluYW1pY09mZnNldC4gaXQncyBhbHJlYWR5IGNvdW50ZWRcbiAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQodHlwZXNbaV0sIHNvbGlkaXR5VHlwZXNbaV0sIGVuY29kZWRzW2ldLCBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgbmVzdGVkIGFycmF5c1xuICAgIH0pO1xuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICBpZiAoaXNEeW5hbWljKHNvbGlkaXR5VHlwZXNbaV0sIHR5cGVzW2ldKSkge1xuICAgICAgICAgICAgdmFyIGUgPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQodHlwZXNbaV0sIHNvbGlkaXR5VHlwZXNbaV0sIGVuY29kZWRzW2ldLCBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIGR5bmFtaWNPZmZzZXQgKz0gZS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gVE9ETzogcmVmYWN0b3Igd2hvbGUgZW5jb2RpbmchXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVXaXRoT2Zmc2V0ID0gZnVuY3Rpb24gKHR5cGUsIHNvbGlkaXR5VHlwZSwgZW5jb2RlZCwgb2Zmc2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBvZmZzZXQgd2FzIGFscmVhZHkgc2V0XG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNvbGlkaXR5VHlwZS5uZXN0ZWROYW1lKHR5cGUpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGUuc3RhdGljUGFydExlbmd0aChuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbmNvZGVkWzBdO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0xlbmd0aCA9IDI7IC8vIGluIGludFxuICAgICAgICAgICAgICAgIGlmIChzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkobmVzdGVkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0xlbmd0aCArPSArKGVuY29kZWRbaSAtIDFdKVswXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGYuZm9ybWF0SW5wdXRJbnQob2Zmc2V0ICsgaSAqIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggKyBwcmV2aW91c0xlbmd0aCAqIDMyKS5lbmNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgbGVuZ3RoLCBza2lwIGl0XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxPZmZzZXQgPSByZXN1bHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KG5lc3RlZE5hbWUsIHNvbGlkaXR5VHlwZSwgZW5jb2RlZFtpICsgMV0sIG9mZnNldCArICBhZGRpdGlvbmFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuXG4gICAgfSBlbHNlIGlmIChzb2xpZGl0eVR5cGUuaXNTdGF0aWNBcnJheSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc29saWRpdHlUeXBlLm5lc3RlZE5hbWUodHlwZSk7XG4gICAgICAgICAgICB2YXIgbmVzdGVkU3RhdGljUGFydExlbmd0aCA9IHNvbGlkaXR5VHlwZS5zdGF0aWNQYXJ0TGVuZ3RoKG5lc3RlZE5hbWUpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cblxuICAgICAgICAgICAgaWYgKHNvbGlkaXR5VHlwZS5pc0R5bmFtaWNBcnJheShuZXN0ZWROYW1lKSkge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0xlbmd0aCA9IDA7IC8vIGluIGludFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBsZW5ndGggb2YgcHJldmlvdXMgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNMZW5ndGggKz0gKyhlbmNvZGVkW2kgLSAxXSB8fCBbXSlbMF0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmLmZvcm1hdElucHV0SW50KG9mZnNldCArIGkgKiBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgcHJldmlvdXNMZW5ndGggKiAzMikuZW5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbE9mZnNldCA9IHJlc3VsdCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQobmVzdGVkTmFtZSwgc29saWRpdHlUeXBlLCBlbmNvZGVkW2ldLCBvZmZzZXQgKyBhZGRpdGlvbmFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgYnl0ZXMgdG8gcGxhaW4gcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBsYWluIHBhcmFtXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtID0gZnVuY3Rpb24gKHR5cGUsIGJ5dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1zKFt0eXBlXSwgYnl0ZXMpWzBdO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtcyA9IGZ1bmN0aW9uICh0eXBlcywgYnl0ZXMpIHtcbiAgICB2YXIgc29saWRpdHlUeXBlcyA9IHRoaXMuZ2V0U29saWRpdHlUeXBlcyh0eXBlcyk7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLmdldE9mZnNldHModHlwZXMsIHNvbGlkaXR5VHlwZXMpO1xuXG4gICAgcmV0dXJuIHNvbGlkaXR5VHlwZXMubWFwKGZ1bmN0aW9uIChzb2xpZGl0eVR5cGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzb2xpZGl0eVR5cGUuZGVjb2RlKGJ5dGVzLCBvZmZzZXRzW2luZGV4XSwgIHR5cGVzW2luZGV4XSwgaW5kZXgpO1xuICAgIH0pO1xufTtcblxuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uICh0eXBlcywgc29saWRpdHlUeXBlcykge1xuICAgIHZhciBsZW5ndGhzID0gIHNvbGlkaXR5VHlwZXMubWFwKGZ1bmN0aW9uIChzb2xpZGl0eVR5cGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzb2xpZGl0eVR5cGUuc3RhdGljUGFydExlbmd0aCh0eXBlc1tpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAvLyBzdW0gd2l0aCBsZW5ndGggb2YgcHJldmlvdXMgZWxlbWVudFxuICAgICAgICBsZW5ndGhzW2ldICs9IGxlbmd0aHNbaSAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBsZW5ndGhzLm1hcChmdW5jdGlvbiAobGVuZ3RoLCBpbmRleCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGN1cnJlbnQgbGVuZ3RoLCBzbyB0aGUgbGVuZ3RoIGlzIHN1bSBvZiBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICB2YXIgc3RhdGljUGFydExlbmd0aCA9IHNvbGlkaXR5VHlwZXNbaW5kZXhdLnN0YXRpY1BhcnRMZW5ndGgodHlwZXNbaW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCAtIHN0YXRpY1BhcnRMZW5ndGg7XG4gICAgfSk7XG59O1xuXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5nZXRTb2xpZGl0eVR5cGVzID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3JlcXVpcmVUeXBlKHR5cGUpO1xuICAgIH0pO1xufTtcblxudmFyIGNvZGVyID0gbmV3IFNvbGlkaXR5Q29kZXIoW1xuICAgIG5ldyBTb2xpZGl0eVR5cGVBZGRyZXNzKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUJvb2woKSxcbiAgICBuZXcgU29saWRpdHlUeXBlSW50KCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZVVJbnQoKSxcbiAgICBuZXcgU29saWRpdHlUeXBlRHluYW1pY0J5dGVzKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUJ5dGVzKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZVN0cmluZygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVSZWFsKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZVVSZWFsKClcbl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2NvZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvY29kZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxudmFyIFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXREeW5hbWljQnl0ZXM7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXREeW5hbWljQnl0ZXM7XG59O1xuXG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlRHluYW1pY0J5dGVzO1xuXG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXmJ5dGVzKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlLmlzRHluYW1pY1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9keW5hbWljYnl0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9keW5hbWljYnl0ZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZm9ybWF0dGVycy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIGMgPSByZXF1aXJlKCcuLi91dGlscy9jb25maWcnKTtcbnZhciBTb2xpZGl0eVBhcmFtID0gcmVxdWlyZSgnLi9wYXJhbScpO1xuXG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIGludFxuICogSWYgdmFsdWUgaXMgbmVnYXRpdmUsIHJldHVybiBpdCdzIHR3bydzIGNvbXBsZW1lbnRcbiAqIElmIHRoZSB2YWx1ZSBpcyBmbG9hdGluZyBwb2ludCwgcm91bmQgaXQgZG93blxuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRJbnRcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ9IHZhbHVlIHRoYXQgbmVlZHMgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0SW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgQmlnTnVtYmVyLmNvbmZpZyhjLkVUSF9CSUdOVU1CRVJfUk9VTkRJTkdfTU9ERSk7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLnBhZExlZnQodXRpbHMudG9Ud29zQ29tcGxlbWVudCh2YWx1ZSkudG9TdHJpbmcoMTYpLCA2NCk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgaW5wdXQgYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0Qnl0ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dEJ5dGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLnRvSGV4KHZhbHVlKS5zdWJzdHIoMik7XG4gICAgdmFyIGwgPSBNYXRoLmZsb29yKChyZXN1bHQubGVuZ3RoICsgNjMpIC8gNjQpO1xuICAgIHJlc3VsdCA9IHV0aWxzLnBhZFJpZ2h0KHJlc3VsdCwgbCAqIDY0KTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0ocmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0RHluYW1pY0lucHV0Qnl0ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dER5bmFtaWNCeXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB1dGlscy50b0hleCh2YWx1ZSkuc3Vic3RyKDIpO1xuICAgIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoIC8gMjtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IoKHJlc3VsdC5sZW5ndGggKyA2MykgLyA2NCk7XG4gICAgcmVzdWx0ID0gdXRpbHMucGFkUmlnaHQocmVzdWx0LCBsICogNjQpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShmb3JtYXRJbnB1dEludChsZW5ndGgpLnZhbHVlICsgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dFN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB1dGlscy5mcm9tVXRmOCh2YWx1ZSkuc3Vic3RyKDIpO1xuICAgIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoIC8gMjtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IoKHJlc3VsdC5sZW5ndGggKyA2MykgLyA2NCk7XG4gICAgcmVzdWx0ID0gdXRpbHMucGFkUmlnaHQocmVzdWx0LCBsICogNjQpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShmb3JtYXRJbnB1dEludChsZW5ndGgpLnZhbHVlICsgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIGJvb2xcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0Qm9vbFxuICogQHBhcmFtIHtCb29sZWFufVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dEJvb2wgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgKyAodmFsdWUgPyAgJzEnIDogJzAnKTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0ocmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIHJlYWxcbiAqIFZhbHVlcyBhcmUgbXVsdGlwbGllZCBieSAyXm0gYW5kIGVuY29kZWQgYXMgaW50ZWdlcnNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0UmVhbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXRSZWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdElucHV0SW50KG5ldyBCaWdOdW1iZXIodmFsdWUpLnRpbWVzKG5ldyBCaWdOdW1iZXIoMikucG93KDEyOCkpKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaW5wdXQgdmFsdWUgaXMgbmVnYXRpdmVcbiAqXG4gKiBAbWV0aG9kIHNpZ25lZElzTmVnYXRpdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBpcyBoZXggZm9ybWF0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBzaWduZWRJc05lZ2F0aXZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQmlnTnVtYmVyKHZhbHVlLnN1YnN0cigwLCAxKSwgMTYpLnRvU3RyaW5nKDIpLnN1YnN0cigwLCAxKSkgPT09ICcxJztcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byBpbnRcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dEludFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBwYXJhbVxuICogQHJldHVybnMge0JpZ051bWJlcn0gcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIGJpZyBudW1iZXJcbiAqL1xudmFyIGZvcm1hdE91dHB1dEludCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcmFtLnN0YXRpY1BhcnQoKSB8fCBcIjBcIjtcblxuICAgIC8vIGNoZWNrIGlmIGl0J3MgbmVnYXRpdmUgbnVtYmVyXG4gICAgLy8gaXQgaXQgaXMsIHJldHVybiB0d28ncyBjb21wbGVtZW50XG4gICAgaWYgKHNpZ25lZElzTmVnYXRpdmUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbHVlLCAxNikubWludXMobmV3IEJpZ051bWJlcignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KSkubWludXMoMSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbHVlLCAxNik7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgdG8gdWludFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0VUludFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfVxuICogQHJldHVybnMge0JpZ051bWViZXJ9IHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIGZvcm1hdHRlZCB0byB1aW50XG4gKi9cbnZhciBmb3JtYXRPdXRwdXRVSW50ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyYW0uc3RhdGljUGFydCgpIHx8IFwiMFwiO1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbHVlLCAxNik7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgdG8gcmVhbFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0UmVhbFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfVxuICogQHJldHVybnMge0JpZ051bWJlcn0gaW5wdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIHJlYWxcbiAqL1xudmFyIGZvcm1hdE91dHB1dFJlYWwgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gZm9ybWF0T3V0cHV0SW50KHBhcmFtKS5kaXZpZGVkQnkobmV3IEJpZ051bWJlcigyKS5wb3coMTI4KSk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgdG8gdXJlYWxcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFVSZWFsXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBpbnB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gdXJlYWxcbiAqL1xudmFyIGZvcm1hdE91dHB1dFVSZWFsID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIGZvcm1hdE91dHB1dFVJbnQocGFyYW0pLmRpdmlkZWRCeShuZXcgQmlnTnVtYmVyKDIpLnBvdygxMjgpKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBib29sXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRCb29sXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmlnaHQtYWxpZ25lZCBpbnB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gYm9vbFxuICovXG52YXIgZm9ybWF0T3V0cHV0Qm9vbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbS5zdGF0aWNQYXJ0KCkgPT09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyA/IHRydWUgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0Qnl0ZXNcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gbGVmdC1hbGlnbmVkIGhleCByZXByZXNlbnRhdGlvbiBvZiBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHR5cGUgbmFtZVxuICogQHJldHVybnMge1N0cmluZ30gaGV4IHN0cmluZ1xuICovXG52YXIgZm9ybWF0T3V0cHV0Qnl0ZXMgPSBmdW5jdGlvbiAocGFyYW0sIG5hbWUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IG5hbWUubWF0Y2goL15ieXRlcyhbMC05XSopLyk7XG4gICAgdmFyIHNpemUgPSBwYXJzZUludChtYXRjaGVzWzFdKTtcbiAgICByZXR1cm4gJzB4JyArIHBhcmFtLnN0YXRpY1BhcnQoKS5zbGljZSgwLCAyICogc2l6ZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dER5bmFtaWNCeXRlc1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBsZWZ0LWFsaWduZWQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHN0cmluZ1xuICovXG52YXIgZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIGxlbmd0aCA9IChuZXcgQmlnTnVtYmVyKHBhcmFtLmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCwgNjQpLCAxNikpLnRvTnVtYmVyKCkgKiAyO1xuICAgIHJldHVybiAnMHgnICsgcGFyYW0uZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsIGxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRTdHJpbmdcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gbGVmdC1hbGlnbmVkIGhleCByZXByZXNlbnRhdGlvbiBvZiBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZ1xuICovXG52YXIgZm9ybWF0T3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIGxlbmd0aCA9IChuZXcgQmlnTnVtYmVyKHBhcmFtLmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCwgNjQpLCAxNikpLnRvTnVtYmVyKCkgKiAyO1xuICAgIHJldHVybiB1dGlscy50b1V0ZjgocGFyYW0uZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsIGxlbmd0aCkpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dEFkZHJlc3NcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gcmlnaHQtYWxpZ25lZCBpbnB1dCBieXRlc1xuICogQHJldHVybnMge1N0cmluZ30gYWRkcmVzc1xuICovXG52YXIgZm9ybWF0T3V0cHV0QWRkcmVzcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcmFtLnN0YXRpY1BhcnQoKTtcbiAgICByZXR1cm4gXCIweFwiICsgdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gNDAsIHZhbHVlLmxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb3JtYXRJbnB1dEludDogZm9ybWF0SW5wdXRJbnQsXG4gICAgZm9ybWF0SW5wdXRCeXRlczogZm9ybWF0SW5wdXRCeXRlcyxcbiAgICBmb3JtYXRJbnB1dER5bmFtaWNCeXRlczogZm9ybWF0SW5wdXREeW5hbWljQnl0ZXMsXG4gICAgZm9ybWF0SW5wdXRTdHJpbmc6IGZvcm1hdElucHV0U3RyaW5nLFxuICAgIGZvcm1hdElucHV0Qm9vbDogZm9ybWF0SW5wdXRCb29sLFxuICAgIGZvcm1hdElucHV0UmVhbDogZm9ybWF0SW5wdXRSZWFsLFxuICAgIGZvcm1hdE91dHB1dEludDogZm9ybWF0T3V0cHV0SW50LFxuICAgIGZvcm1hdE91dHB1dFVJbnQ6IGZvcm1hdE91dHB1dFVJbnQsXG4gICAgZm9ybWF0T3V0cHV0UmVhbDogZm9ybWF0T3V0cHV0UmVhbCxcbiAgICBmb3JtYXRPdXRwdXRVUmVhbDogZm9ybWF0T3V0cHV0VVJlYWwsXG4gICAgZm9ybWF0T3V0cHV0Qm9vbDogZm9ybWF0T3V0cHV0Qm9vbCxcbiAgICBmb3JtYXRPdXRwdXRCeXRlczogZm9ybWF0T3V0cHV0Qnl0ZXMsXG4gICAgZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzOiBmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXMsXG4gICAgZm9ybWF0T3V0cHV0U3RyaW5nOiBmb3JtYXRPdXRwdXRTdHJpbmcsXG4gICAgZm9ybWF0T3V0cHV0QWRkcmVzczogZm9ybWF0T3V0cHV0QWRkcmVzc1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9mb3JtYXR0ZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvZm9ybWF0dGVycy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZUludCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyBpbnQgdHlwZVxuICogSXQgbWF0Y2hlczpcbiAqIGludFxuICogaW50W11cbiAqIGludFs0XVxuICogaW50W11bXVxuICogaW50WzNdW11cbiAqIGludFtdWzZdW10sIC4uLlxuICogaW50MzJcbiAqIGludDY0W11cbiAqIGludDhbNF1cbiAqIGludDI1NltdW11cbiAqIGludFszXVtdXG4gKiBpbnQ2NFtdWzZdW10sIC4uLlxuICovXG52YXIgU29saWRpdHlUeXBlSW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEludDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dEludDtcbn07XG5cblNvbGlkaXR5VHlwZUludC5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZUludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVJbnQ7XG5cblNvbGlkaXR5VHlwZUludC5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9eaW50KFswLTldKik/KFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9pbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIHBhcmFtLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbi8qKlxuICogU29saWRpdHlQYXJhbSBvYmplY3QgcHJvdG90eXBlLlxuICogU2hvdWxkIGJlIHVzZWQgd2hlbiBlbmNvZGluZywgZGVjb2Rpbmcgc29saWRpdHkgYnl0ZXNcbiAqL1xudmFyIFNvbGlkaXR5UGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDsgLy8gb2Zmc2V0IGluIGJ5dGVzXG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGdldCBsZW5ndGggb2YgcGFyYW1zJ3MgZHluYW1pYyBwYXJ0XG4gKiBcbiAqIEBtZXRob2QgZHluYW1pY1BhcnRMZW5ndGhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBkeW5hbWljIHBhcnQgKGluIGJ5dGVzKVxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5keW5hbWljUGFydExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5keW5hbWljUGFydCgpLmxlbmd0aCAvIDI7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBjb3B5IG9mIHNvbGlkaXR5IHBhcmFtIHdpdGggZGlmZmVyZW50IG9mZnNldFxuICpcbiAqIEBtZXRob2Qgd2l0aE9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBsZW5ndGggaW4gYnl0ZXNcbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfSBuZXcgc29saWRpdHkgcGFyYW0gd2l0aCBhcHBsaWVkIG9mZnNldFxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS53aXRoT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbSh0aGlzLnZhbHVlLCBvZmZzZXQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjb21iaW5lIHNvbGlkaXR5IHBhcmFtcyB0b2dldGhlclxuICogZWcuIHdoZW4gYXBwZW5kaW5nIGFuIGFycmF5XG4gKlxuICogQG1ldGhvZCBjb21iaW5lXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IHBhcmFtIHdpdGggd2hpY2ggd2Ugc2hvdWxkIGNvbWJpbmVcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gcmVzdWx0IG9mIGNvbWJpbmF0aW9uXG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0odGhpcy52YWx1ZSArIHBhcmFtLnZhbHVlKTsgXG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgcGFyYW0gaGFzIGR5bmFtaWMgc2l6ZS5cbiAqIElmIGl0IGhhcywgaXQgcmV0dXJucyB0cnVlLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRHluYW1pY1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmlzRHluYW1pYyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgIT09IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byB0cmFuc2Zvcm0gb2Zmc2V0IHRvIGJ5dGVzXG4gKlxuICogQG1ldGhvZCBvZmZzZXRBc0J5dGVzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBieXRlcyByZXByZXNlbnRhdGlvbiBvZiBvZmZzZXRcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUub2Zmc2V0QXNCeXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNEeW5hbWljKCkgPyAnJyA6IHV0aWxzLnBhZExlZnQodXRpbHMudG9Ud29zQ29tcGxlbWVudCh0aGlzLm9mZnNldCkudG9TdHJpbmcoMTYpLCA2NCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHN0YXRpYyBwYXJ0IG9mIHBhcmFtXG4gKlxuICogQG1ldGhvZCBzdGF0aWNQYXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBvZmZzZXQgaWYgaXQgaXMgYSBkeW5hbWljIHBhcmFtLCBvdGhlcndpc2UgdmFsdWVcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuc3RhdGljUGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEeW5hbWljKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7IFxuICAgIH0gXG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0QXNCeXRlcygpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGdldCBkeW5hbWljIHBhcnQgb2YgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGR5bmFtaWNQYXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSByZXR1cm5zIGEgdmFsdWUgaWYgaXQgaXMgYSBkeW5hbWljIHBhcmFtLCBvdGhlcndpc2UgZW1wdHkgc3RyaW5nXG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmR5bmFtaWNQYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzRHluYW1pYygpID8gdGhpcy52YWx1ZSA6ICcnO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGVuY29kZSBwYXJhbVxuICpcbiAqIEBtZXRob2QgZW5jb2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljUGFydCgpICsgdGhpcy5keW5hbWljUGFydCgpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGVuY29kZSBhcnJheSBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGVuY29kZUxpc3RcbiAqIEBwYXJhbSB7QXJyYXlbU29saWRpdHlQYXJhbV19IHBhcmFtc1xuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuU29saWRpdHlQYXJhbS5lbmNvZGVMaXN0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIFxuICAgIC8vIHVwZGF0aW5nIG9mZnNldHNcbiAgICB2YXIgdG90YWxPZmZzZXQgPSBwYXJhbXMubGVuZ3RoICogMzI7XG4gICAgdmFyIG9mZnNldFBhcmFtcyA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIGlmICghcGFyYW0uaXNEeW5hbWljKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gdG90YWxPZmZzZXQ7XG4gICAgICAgIHRvdGFsT2Zmc2V0ICs9IHBhcmFtLmR5bmFtaWNQYXJ0TGVuZ3RoKCk7XG4gICAgICAgIHJldHVybiBwYXJhbS53aXRoT2Zmc2V0KG9mZnNldCk7XG4gICAgfSk7XG5cbiAgICAvLyBlbmNvZGUgZXZlcnl0aGluZyFcbiAgICByZXR1cm4gb2Zmc2V0UGFyYW1zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwYXJhbSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcGFyYW0uZHluYW1pY1BhcnQoKTtcbiAgICB9LCBvZmZzZXRQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhcmFtKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBwYXJhbS5zdGF0aWNQYXJ0KCk7XG4gICAgfSwgJycpKTtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5UGFyYW07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9wYXJhbS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3BhcmFtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlUmVhbCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyByZWFsIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiByZWFsXG4gKiByZWFsW11cbiAqIHJlYWxbNF1cbiAqIHJlYWxbXVtdXG4gKiByZWFsWzNdW11cbiAqIHJlYWxbXVs2XVtdLCAuLi5cbiAqIHJlYWwzMlxuICogcmVhbDY0W11cbiAqIHJlYWw4WzRdXG4gKiByZWFsMjU2W11bXVxuICogcmVhbFszXVtdXG4gKiByZWFsNjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVJlYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0UmVhbDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFJlYWw7XG59O1xuXG5Tb2xpZGl0eVR5cGVSZWFsLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlUmVhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVSZWFsO1xuXG5Tb2xpZGl0eVR5cGVSZWFsLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL3JlYWwoWzAtOV0qKT8oXFxbKFswLTldKilcXF0pPy8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVSZWFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3JlYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9yZWFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0U3RyaW5nO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0U3RyaW5nO1xufTtcblxuU29saWRpdHlUeXBlU3RyaW5nLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZVN0cmluZztcblxuU29saWRpdHlUeXBlU3RyaW5nLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15zdHJpbmcoXFxbKFswLTldKilcXF0pKiQvKTtcbn07XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuaXNEeW5hbWljVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3N0cmluZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5UGFyYW0gPSByZXF1aXJlKCcuL3BhcmFtJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlIHByb3RvdHlwZSBpcyB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGNlcnRhaW4gdHlwZVxuICovXG52YXIgU29saWRpdHlUeXBlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gY29uZmlnLmlucHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGNvbmZpZy5vdXRwdXRGb3JtYXR0ZXI7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0aGlzIFNvbGlkaXR5VHlwZSBkbyBtYXRjaCBnaXZlbiBuYW1lXG4gKlxuICogQG1ldGhvZCBpc1R5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIHR5cGUgbWF0Y2ggdGhpcyBTb2xpZGl0eVR5cGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgXCJ0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJ3cml0dGVuIGZvciB0eXBlIFwiICsgbmFtZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoYXQgaXMgdGhlIGxlbmd0aCBvZiBzdGF0aWMgcGFydCBpbiBnaXZlbiB0eXBlXG4gKlxuICogQG1ldGhvZCBzdGF0aWNQYXJ0TGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2Ygc3RhdGljIHBhcnQgaW4gYnl0ZXNcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5zdGF0aWNQYXJ0TGVuZ3RoID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBJZiBuYW1lIGlzbid0IGFuIGFycmF5IHRoZW4gdHJlYXQgaXQgbGlrZSBhIHNpbmdsZSBlbGVtZW50IGFycmF5LlxuICAgIHJldHVybiAodGhpcy5uZXN0ZWRUeXBlcyhuYW1lKSB8fCBbJ1sxXSddKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIG9mIHRoZSBuZXN0ZWQgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0eXBlLnNsaWNlKDEsIC0xKSwgMTApIHx8IDE7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKiBjdXJyZW50O1xuICAgICAgICAvLyBhbGwgYmFzaWMgdHlwZXMgYXJlIDMyIGJ5dGVzIGxvbmdcbiAgICAgICAgfSwgMzIpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdHlwZSBpcyBkeW5hbWljIGFycmF5XG4gKiBlZzpcbiAqIFwidHlwZVtdXCIgPT4gdHJ1ZVxuICogXCJ0eXBlWzRdXCIgPT4gZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRHluYW1pY0FycmF5XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBkeW5hbWljIGFycmF5XG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuaXNEeW5hbWljQXJyYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBuZXN0ZWRUeXBlcyA9IHRoaXMubmVzdGVkVHlwZXMobmFtZSk7XG4gICAgcmV0dXJuICEhbmVzdGVkVHlwZXMgJiYgIW5lc3RlZFR5cGVzW25lc3RlZFR5cGVzLmxlbmd0aCAtIDFdLm1hdGNoKC9bMC05XXsxLH0vZyk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0eXBlIGlzIHN0YXRpYyBhcnJheVxuICogZWc6XG4gKiBcInR5cGVbXVwiID0+IGZhbHNlXG4gKiBcInR5cGVbNF1cIiA9PiB0cnVlXG4gKlxuICogQG1ldGhvZCBpc1N0YXRpY0FycmF5XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBzdGF0aWMgYXJyYXlcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5pc1N0YXRpY0FycmF5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbmVzdGVkVHlwZXMgPSB0aGlzLm5lc3RlZFR5cGVzKG5hbWUpO1xuICAgIHJldHVybiAhIW5lc3RlZFR5cGVzICYmICEhbmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1swLTldezEsfS9nKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiBsZW5ndGggb2Ygc3RhdGljIGFycmF5XG4gKiBlZy5cbiAqIFwiaW50WzMyXVwiID0+IDMyXG4gKiBcImludDI1NlsxNF1cIiA9PiAxNFxuICogXCJpbnRbMl1bM11cIiA9PiAzXG4gKiBcImludFwiID0+IDFcbiAqIFwiaW50WzFdXCIgPT4gMVxuICogXCJpbnRbXVwiID0+IDFcbiAqXG4gKiBAbWV0aG9kIHN0YXRpY0FycmF5TGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7TnVtYmVyfSBzdGF0aWMgYXJyYXkgbGVuZ3RoXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuc3RhdGljQXJyYXlMZW5ndGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBuZXN0ZWRUeXBlcyA9IHRoaXMubmVzdGVkVHlwZXMobmFtZSk7XG4gICAgaWYgKG5lc3RlZFR5cGVzKSB7XG4gICAgICAgcmV0dXJuIHBhcnNlSW50KG5lc3RlZFR5cGVzW25lc3RlZFR5cGVzLmxlbmd0aCAtIDFdLm1hdGNoKC9bMC05XXsxLH0vZykgfHwgMSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIG5lc3RlZCB0eXBlXG4gKiBlZy5cbiAqIFwiaW50WzMyXVwiID0+IFwiaW50XCJcbiAqIFwiaW50MjU2WzE0XVwiID0+IFwiaW50MjU2XCJcbiAqIFwiaW50WzJdWzNdXCIgPT4gXCJpbnRbMl1cIlxuICogXCJpbnRcIiA9PiBcImludFwiXG4gKiBcImludFtdXCIgPT4gXCJpbnRcIlxuICpcbiAqIEBtZXRob2QgbmVzdGVkTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gbmVzdGVkIG5hbWVcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5uZXN0ZWROYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyByZW1vdmUgbGFzdCBbXSBpbiBuYW1lXG4gICAgdmFyIG5lc3RlZFR5cGVzID0gdGhpcy5uZXN0ZWRUeXBlcyhuYW1lKTtcbiAgICBpZiAoIW5lc3RlZFR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIG5lc3RlZFR5cGVzW25lc3RlZFR5cGVzLmxlbmd0aCAtIDFdLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0eXBlIGhhcyBkeW5hbWljIHNpemUgYnkgZGVmYXVsdFxuICogc3VjaCB0eXBlcyBhcmUgXCJzdHJpbmdcIiwgXCJieXRlc1wiXG4gKlxuICogQG1ldGhvZCBpc0R5bmFtaWNUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiBpcyBkeW5hbWljLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiBhcnJheSBvZiBuZXN0ZWQgdHlwZXNcbiAqIGVnLlxuICogXCJpbnRbMl1bM11bXVwiID0+IFtcIlsyXVwiLCBcIlszXVwiLCBcIltdXCJdXG4gKiBcImludFtdID0+IFtcIltdXCJdXG4gKiBcImludFwiID0+IG51bGxcbiAqXG4gKiBAbWV0aG9kIG5lc3RlZFR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIG5lc3RlZCB0eXBlc1xuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLm5lc3RlZFR5cGVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyByZXR1cm4gbGlzdCBvZiBzdHJpbmdzIGVnLiBcIltdXCIsIFwiWzNdXCIsIFwiW11cIiwgXCJbMl1cIlxuICAgIHJldHVybiBuYW1lLm1hdGNoKC8oXFxbWzAtOV0qXFxdKS9nKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHRoZSB2YWx1ZVxuICpcbiAqIEBtZXRob2QgZW5jb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgdmFsdWVcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuaXNEeW5hbWljQXJyYXkobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc2VsZi5uZXN0ZWROYW1lKG5hbWUpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICByZXN1bHQucHVzaChmLmZvcm1hdElucHV0SW50KGxlbmd0aCkuZW5jb2RlKCkpO1xuXG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5lbmNvZGUodiwgbmVzdGVkTmFtZSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdGF0aWNBcnJheShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHNlbGYuc3RhdGljQXJyYXlMZW5ndGgobmFtZSk7ICAgICAgICAgIC8vIGluIGludFxuICAgICAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzZWxmLm5lc3RlZE5hbWUobmFtZSk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLmVuY29kZSh2YWx1ZVtpXSwgbmVzdGVkTmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lucHV0Rm9ybWF0dGVyKHZhbHVlLCBuYW1lKS5lbmNvZGUoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIHZhbHVlIGZyb20gYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IGluIGJ5dGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0eXBlIG5hbWVcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlY29kZWQgdmFsdWVcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMsIG9mZnNldCwgbmFtZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzRHluYW1pY0FycmF5KG5hbWUpKSB7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXlPZmZzZXQgPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKG9mZnNldCAqIDIsIDY0KSk7IC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoJzB4JyArIGJ5dGVzLnN1YnN0cihhcnJheU9mZnNldCAqIDIsIDY0KSk7IC8vIGluIGludFxuICAgICAgICAgICAgdmFyIGFycmF5U3RhcnQgPSBhcnJheU9mZnNldCArIDMyOyAvLyBhcnJheSBzdGFydHMgYWZ0ZXIgbGVuZ3RoOyAvLyBpbiBieXRlc1xuXG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNlbGYubmVzdGVkTmFtZShuYW1lKTtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gc2VsZi5zdGF0aWNQYXJ0TGVuZ3RoKG5lc3RlZE5hbWUpOyAgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aCA9IE1hdGguZmxvb3IoKG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggKyAzMSkgLyAzMikgKiAzMjtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggKiByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aDsgaSArPSByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuZGVjb2RlKGJ5dGVzLCBhcnJheVN0YXJ0ICsgaSwgbmVzdGVkTmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGljQXJyYXkobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBzZWxmLnN0YXRpY0FycmF5TGVuZ3RoKG5hbWUpOyAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBhcnJheVN0YXJ0ID0gb2Zmc2V0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBieXRlc1xuXG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNlbGYubmVzdGVkTmFtZShuYW1lKTtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gc2VsZi5zdGF0aWNQYXJ0TGVuZ3RoKG5lc3RlZE5hbWUpOyAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gTWF0aC5mbG9vcigobmVzdGVkU3RhdGljUGFydExlbmd0aCArIDMxKSAvIDMyKSAqIDMyO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAqIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoOyBpICs9IHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5kZWNvZGUoYnl0ZXMsIGFycmF5U3RhcnQgKyBpLCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRHluYW1pY1R5cGUobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gcGFyc2VJbnQoJzB4JyArIGJ5dGVzLnN1YnN0cihvZmZzZXQgKiAyLCA2NCkpOyAgICAgIC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoJzB4JyArIGJ5dGVzLnN1YnN0cihkeW5hbWljT2Zmc2V0ICogMiwgNjQpKTsgICAgICAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIHJvdW5kZWRMZW5ndGggPSBNYXRoLmZsb29yKChsZW5ndGggKyAzMSkgLyAzMik7ICAgICAgICAgICAgICAgICAgICAgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBuZXcgU29saWRpdHlQYXJhbShieXRlcy5zdWJzdHIoZHluYW1pY09mZnNldCAqIDIsICggMSArIHJvdW5kZWRMZW5ndGgpICogNjQpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9vdXRwdXRGb3JtYXR0ZXIocGFyYW0sIG5hbWUpO1xuICAgICAgICB9KSgpO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSB0aGlzLnN0YXRpY1BhcnRMZW5ndGgobmFtZSk7XG4gICAgdmFyIHBhcmFtID0gbmV3IFNvbGlkaXR5UGFyYW0oYnl0ZXMuc3Vic3RyKG9mZnNldCAqIDIsIGxlbmd0aCAqIDIpKTtcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0Rm9ybWF0dGVyKHBhcmFtLCBuYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS90eXBlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlVUludCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyB1aW50IHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiB1aW50XG4gKiB1aW50W11cbiAqIHVpbnRbNF1cbiAqIHVpbnRbXVtdXG4gKiB1aW50WzNdW11cbiAqIHVpbnRbXVs2XVtdLCAuLi5cbiAqIHVpbnQzMlxuICogdWludDY0W11cbiAqIHVpbnQ4WzRdXG4gKiB1aW50MjU2W11bXVxuICogdWludFszXVtdXG4gKiB1aW50NjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVVJbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0SW50O1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0VUludDtcbn07XG5cblNvbGlkaXR5VHlwZVVJbnQucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZVVJbnQ7XG5cblNvbGlkaXR5VHlwZVVJbnQucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXnVpbnQoWzAtOV0qKT8oXFxbKFswLTldKilcXF0pKiQvKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlVUludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91aW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdWludC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVVSZWFsIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIHVyZWFsIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiB1cmVhbFxuICogdXJlYWxbXVxuICogdXJlYWxbNF1cbiAqIHVyZWFsW11bXVxuICogdXJlYWxbM11bXVxuICogdXJlYWxbXVs2XVtdLCAuLi5cbiAqIHVyZWFsMzJcbiAqIHVyZWFsNjRbXVxuICogdXJlYWw4WzRdXG4gKiB1cmVhbDI1NltdW11cbiAqIHVyZWFsWzNdW11cbiAqIHVyZWFsNjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVVSZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFJlYWw7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRVUmVhbDtcbn07XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlVVJlYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlVVJlYWw7XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL151cmVhbChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVVUmVhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91cmVhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3VyZWFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gZ28gZW52IGRvZXNuJ3QgaGF2ZSBhbmQgbmVlZCBYTUxIdHRwUmVxdWVzdFxuaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0ge307XG59IGVsc2Uge1xuICAgIGV4cG9ydHMuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9icm93c2VyLXhoci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL2Jyb3dzZXIteGhyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgY29uZmlnLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuLyoqXG4gKiBVdGlsc1xuICogXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICogXG4gKiBAY2xhc3MgW3V0aWxzXSBjb25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxuLy8vIHJlcXVpcmVkIHRvIGRlZmluZSBFVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREVcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxudmFyIEVUSF9VTklUUyA9IFtcbiAgICAnd2VpJyxcbiAgICAna3dlaScsXG4gICAgJ013ZWknLFxuICAgICdHd2VpJyxcbiAgICAnc3phYm8nLFxuICAgICdmaW5uZXknLFxuICAgICdmZW10b2V0aGVyJyxcbiAgICAncGljb2V0aGVyJyxcbiAgICAnbmFub2V0aGVyJyxcbiAgICAnbWljcm9ldGhlcicsXG4gICAgJ21pbGxpZXRoZXInLFxuICAgICduYW5vJyxcbiAgICAnbWljcm8nLFxuICAgICdtaWxsaScsXG4gICAgJ2V0aGVyJyxcbiAgICAnZ3JhbmQnLFxuICAgICdNZXRoZXInLFxuICAgICdHZXRoZXInLFxuICAgICdUZXRoZXInLFxuICAgICdQZXRoZXInLFxuICAgICdFZXRoZXInLFxuICAgICdaZXRoZXInLFxuICAgICdZZXRoZXInLFxuICAgICdOZXRoZXInLFxuICAgICdEZXRoZXInLFxuICAgICdWZXRoZXInLFxuICAgICdVZXRoZXInXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFVEhfUEFERElORzogMzIsXG4gICAgRVRIX1NJR05BVFVSRV9MRU5HVEg6IDQsXG4gICAgRVRIX1VOSVRTOiBFVEhfVU5JVFMsXG4gICAgRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFOiB7IFJPVU5ESU5HX01PREU6IEJpZ051bWJlci5ST1VORF9ET1dOIH0sXG4gICAgRVRIX1BPTExJTkdfVElNRU9VVDogMTAwMC8yLFxuICAgIGRlZmF1bHRCbG9jazogJ2xhdGVzdCcsXG4gICAgZGVmYXVsdEFjY291bnQ6IHVuZGVmaW5lZFxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgc2hhMy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCdjcnlwdG8tanMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnY3J5cHRvLWpzL3NoYTMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAmJiB2YWx1ZS5zdWJzdHIoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYTModmFsdWUsIHtcbiAgICAgICAgb3V0cHV0TGVuZ3RoOiAyNTZcbiAgICB9KS50b1N0cmluZygpO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL3NoYTMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9zaGEzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIHV0aWxzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbi8qKlxuICogVXRpbHNcbiAqXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICpcbiAqIEBjbGFzcyBbdXRpbHNdIHV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi9zaGEzLmpzJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxudmFyIHVuaXRNYXAgPSB7XG4gICAgJ25vZXRoZXInOiAgICAgICcwJyxcbiAgICAnd2VpJzogICAgICAgICAgJzEnLFxuICAgICdrd2VpJzogICAgICAgICAnMTAwMCcsXG4gICAgJ0t3ZWknOiAgICAgICAgICcxMDAwJyxcbiAgICAnYmFiYmFnZSc6ICAgICAgJzEwMDAnLFxuICAgICdmZW10b2V0aGVyJzogICAnMTAwMCcsXG4gICAgJ213ZWknOiAgICAgICAgICcxMDAwMDAwJyxcbiAgICAnTXdlaSc6ICAgICAgICAgJzEwMDAwMDAnLFxuICAgICdsb3ZlbGFjZSc6ICAgICAnMTAwMDAwMCcsXG4gICAgJ3BpY29ldGhlcic6ICAgICcxMDAwMDAwJyxcbiAgICAnZ3dlaSc6ICAgICAgICAgJzEwMDAwMDAwMDAnLFxuICAgICdHd2VpJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3NoYW5ub24nOiAgICAgICcxMDAwMDAwMDAwJyxcbiAgICAnbmFub2V0aGVyJzogICAgJzEwMDAwMDAwMDAnLFxuICAgICduYW5vJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3N6YWJvJzogICAgICAgICcxMDAwMDAwMDAwMDAwJyxcbiAgICAnbWljcm9ldGhlcic6ICAgJzEwMDAwMDAwMDAwMDAnLFxuICAgICdtaWNybyc6ICAgICAgICAnMTAwMDAwMDAwMDAwMCcsXG4gICAgJ2Zpbm5leSc6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWlsbGlldGhlcic6ICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWlsbGknOiAgICAgICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnZXRoZXInOiAgICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdrZXRoZXInOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2dyYW5kJzogICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWV0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdnZXRoZXInOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ3RldGhlcic6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCBwYWRMZWZ0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJhY3RlcnMgdGhhdCByZXN1bHQgc3RyaW5nIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbiwgYnkgZGVmYXVsdCAwXG4gKiBAcmV0dXJucyB7U3RyaW5nfSByaWdodCBhbGlnbmVkIHN0cmluZ1xuICovXG52YXIgcGFkTGVmdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpICsgc3RyaW5nO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCBwYWRSaWdodFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFyYWN0ZXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIHBhZFJpZ2h0ID0gZnVuY3Rpb24gKHN0cmluZywgY2hhcnMsIHNpZ24pIHtcbiAgICByZXR1cm4gc3RyaW5nICsgKG5ldyBBcnJheShjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbnZhciB0b1V0ZjggPSBmdW5jdGlvbihoZXgpIHtcbi8vIEZpbmQgdGVybWluYXRpb25cbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDAsIGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgIGkgPSAyO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkrPTIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIGlmIChjb2RlID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGY4LmRlY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgdG9Bc2NpaSA9IGZ1bmN0aW9uKGhleCkge1xuLy8gRmluZCB0ZXJtaW5hdGlvblxuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMCwgbCA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgaSA9IDI7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbDsgaSs9Mikge1xuICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgZnJvbVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgICBzdHIgPSB1dGY4LmVuY29kZShzdHIpO1xuICAgIHZhciBoZXggPSBcIlwiO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgIH1cblxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgZnJvbUFzY2lpID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGhleCA9IFwiXCI7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZSBmcm9tIGpzb24gYWJpXG4gKlxuICogQG1ldGhvZCB0cmFuc2Zvcm1Ub0Z1bGxOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbi1hYmlcbiAqIEByZXR1cm4ge1N0cmluZ30gZnVsbCBmbmN0aW9uL2V2ZW50IG5hbWVcbiAqL1xudmFyIHRyYW5zZm9ybVRvRnVsbE5hbWUgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIGlmIChqc29uLm5hbWUuaW5kZXhPZignKCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ganNvbi5uYW1lO1xuICAgIH1cblxuICAgIHZhciB0eXBlTmFtZSA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gaS50eXBlOyB9KS5qb2luKCk7XG4gICAgcmV0dXJuIGpzb24ubmFtZSArICcoJyArIHR5cGVOYW1lICsgJyknO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBkaXNwbGF5IG5hbWUgb2YgY29udHJhY3QgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3REaXNwbGF5TmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgZnVuY3Rpb24vZXZlbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGRpc3BsYXkgbmFtZSBmb3IgZnVuY3Rpb24vZXZlbnQgZWcuIG11bHRpcGx5KHVpbnQyNTYpIC0+IG11bHRpcGx5XG4gKi9cbnZhciBleHRyYWN0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBsZW5ndGggPSBuYW1lLmluZGV4T2YoJygnKTtcbiAgICByZXR1cm4gbGVuZ3RoICE9PSAtMSA/IG5hbWUuc3Vic3RyKDAsIGxlbmd0aCkgOiBuYW1lO1xufTtcblxuLy8vIEByZXR1cm5zIG92ZXJsb2FkZWQgcGFydCBvZiBmdW5jdGlvbi9ldmVudCBuYW1lXG52YXIgZXh0cmFjdFR5cGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLy8gVE9ETzogbWFrZSBpdCBpbnZ1bG5lcmFibGVcbiAgICB2YXIgbGVuZ3RoID0gbmFtZS5pbmRleE9mKCcoJyk7XG4gICAgcmV0dXJuIGxlbmd0aCAhPT0gLTEgPyBuYW1lLnN1YnN0cihsZW5ndGggKyAxLCBuYW1lLmxlbmd0aCAtIDEgLSAobGVuZ3RoICsgMSkpLnJlcGxhY2UoJyAnLCAnJykgOiBcIlwiO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gaW4gc3RyaW5nXG4gKlxuICogQG1ldGhvZCB0b0RlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b0RlY2ltYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdG9CaWdOdW1iZXIodmFsdWUpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCBmcm9tRGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGZyb21EZWNpbWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG51bWJlciA9IHRvQmlnTnVtYmVyKHZhbHVlKTtcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyLnRvU3RyaW5nKDE2KTtcblxuICAgIHJldHVybiBudW1iZXIubGVzc1RoYW4oMCkgPyAnLTB4JyArIHJlc3VsdC5zdWJzdHIoMSkgOiAnMHgnICsgcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBdXRvIGNvbnZlcnRzIGFueSBnaXZlbiB2YWx1ZSBpbnRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEFuZCBldmVuIHN0cmluZ2lmeXMgb2JqZWN0cyBiZWZvcmUuXG4gKlxuICogQG1ldGhvZCB0b0hleFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcnxPYmplY3R9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b0hleCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG5cbiAgICBpZiAoaXNCb29sZWFuKHZhbCkpXG4gICAgICAgIHJldHVybiBmcm9tRGVjaW1hbCgrdmFsKTtcblxuICAgIGlmIChpc0JpZ051bWJlcih2YWwpKVxuICAgICAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcblxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZyb21VdGY4KEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuXG4gICAgLy8gaWYgaXRzIGEgbmVnYXRpdmUgbnVtYmVyLCBwYXNzIGl0IHRocm91Z2ggZnJvbURlY2ltYWxcbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgICBpZiAodmFsLmluZGV4T2YoJy0weCcpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21EZWNpbWFsKHZhbCk7XG4gICAgICAgIGVsc2UgaWYodmFsLmluZGV4T2YoJzB4JykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBlbHNlIGlmICghaXNGaW5pdGUodmFsKSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQXNjaWkodmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZSBvZiB1bml0IGluIFdlaVxuICpcbiAqIEBtZXRob2QgZ2V0VmFsdWVPZlVuaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHZhbHVlIG9mIHRoZSB1bml0IChpbiBXZWkpXG4gKiBAdGhyb3dzIGVycm9yIGlmIHRoZSB1bml0IGlzIG5vdCBjb3JyZWN0OndcbiAqL1xudmFyIGdldFZhbHVlT2ZVbml0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB1bml0ID0gdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6ICdldGhlcic7XG4gICAgdmFyIHVuaXRWYWx1ZSA9IHVuaXRNYXBbdW5pdF07XG4gICAgaWYgKHVuaXRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IGRvZXNuXFwndCBleGlzdHMsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzJyArIEpTT04uc3RyaW5naWZ5KHVuaXRNYXAsIG51bGwsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodW5pdFZhbHVlLCAxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIHdlaSBhbmQgY29udmVydHMgaXQgdG8gYW55IG90aGVyIGV0aGVyIHVuaXQuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIGZyb21XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9IFdoZW4gZ2l2ZW4gYSBCaWdOdW1iZXIgb2JqZWN0IGl0IHJldHVybnMgb25lIGFzIHdlbGwsIG90aGVyd2lzZSBhIG51bWJlclxuKi9cbnZhciBmcm9tV2VpID0gZnVuY3Rpb24obnVtYmVyLCB1bml0KSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gdG9CaWdOdW1iZXIobnVtYmVyKS5kaXZpZGVkQnkoZ2V0VmFsdWVPZlVuaXQodW5pdCkpO1xuXG4gICAgcmV0dXJuIGlzQmlnTnVtYmVyKG51bWJlcikgPyByZXR1cm5WYWx1ZSA6IHJldHVyblZhbHVlLnRvU3RyaW5nKDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYSB1bml0IGFuZCBjb252ZXJ0cyBpdCB0byB3ZWkuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIHRvV2VpXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8QmlnTnVtYmVyfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCBmcm9tLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSBXaGVuIGdpdmVuIGEgQmlnTnVtYmVyIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiovXG52YXIgdG9XZWkgPSBmdW5jdGlvbihudW1iZXIsIHVuaXQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSB0b0JpZ051bWJlcihudW1iZXIpLnRpbWVzKGdldFZhbHVlT2ZVbml0KHVuaXQpKTtcblxuICAgIHJldHVybiBpc0JpZ051bWJlcihudW1iZXIpID8gcmV0dXJuVmFsdWUgOiByZXR1cm5WYWx1ZS50b1N0cmluZygxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGlucHV0IGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gYW4gYmlnbnVtYmVyXG4gKlxuICogQG1ldGhvZCB0b0JpZ051bWJlclxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJpZ051bWJlcn0gYSBudW1iZXIsIHN0cmluZywgSEVYIHN0cmluZyBvciBCaWdOdW1iZXJcbiAqIEByZXR1cm4ge0JpZ051bWJlcn0gQmlnTnVtYmVyXG4qL1xudmFyIHRvQmlnTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG4gICAgbnVtYmVyID0gbnVtYmVyIHx8IDA7XG4gICAgaWYgKGlzQmlnTnVtYmVyKG51bWJlcikpXG4gICAgICAgIHJldHVybiBudW1iZXI7XG5cbiAgICBpZiAoaXNTdHJpbmcobnVtYmVyKSAmJiAobnVtYmVyLmluZGV4T2YoJzB4JykgPT09IDAgfHwgbnVtYmVyLmluZGV4T2YoJy0weCcpID09PSAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihudW1iZXIucmVwbGFjZSgnMHgnLCcnKSwgMTYpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG51bWJlci50b1N0cmluZygxMCksIDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW5kIGlucHV0IHRyYW5zZm9ybXMgaXQgaW50byBiaWdudW1iZXIgYW5kIGlmIGl0IGlzIG5lZ2F0aXZlIHZhbHVlLCBpbnRvIHR3bydzIGNvbXBsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIHRvVHdvc0NvbXBsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCaWdOdW1iZXJ9XG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9XG4gKi9cbnZhciB0b1R3b3NDb21wbGVtZW50ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHZhciBiaWdOdW1iZXIgPSB0b0JpZ051bWJlcihudW1iZXIpLnJvdW5kKCk7XG4gICAgaWYgKGJpZ051bWJlci5sZXNzVGhhbigwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIiwgMTYpLnBsdXMoYmlnTnVtYmVyKS5wbHVzKDEpO1xuICAgIH1cbiAgICByZXR1cm4gYmlnTnVtYmVyO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBzdHJpY3RseSBhbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc1N0cmljdEFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cbnZhciBpc1N0cmljdEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHJldHVybiAvXjB4WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xudmFyIGlzQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaGFzIHRoZSBiYXNpYyByZXF1aXJlbWVudHMgb2YgYW4gYWRkcmVzc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NDB9JC8udGVzdChhZGRyZXNzKSB8fCAvXigweCk/WzAtOUEtRl17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICAvLyBJZiBpdCdzIGFsbCBzbWFsbCBjYXBzIG9yIGFsbCBhbGwgY2FwcywgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGVhY2ggY2FzZVxuICAgICAgICByZXR1cm4gaXNDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiovXG52YXIgaXNDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIC8vIENoZWNrIGVhY2ggY2FzZVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrICkge1xuICAgICAgICAvLyB0aGUgbnRoIGxldHRlciBzaG91bGQgYmUgdXBwZXJjYXNlIGlmIHRoZSBudGggZGlnaXQgb2YgY2FzZW1hcCBpcyAxXG4gICAgICAgIGlmICgocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcgJiYgYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpICE9PSBhZGRyZXNzW2ldKSB8fCAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA8PSA3ICYmIGFkZHJlc3NbaV0udG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vKipcbiAqIE1ha2VzIGEgY2hlY2tzdW0gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgdG9DaGVja3N1bUFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4qL1xudmFyIHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG5cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzKTtcbiAgICB2YXIgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA5IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtQWRkcmVzcztcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBnaXZlbiBzdHJpbmcgdG8gdmFsaWQgMjAgYnl0ZXMtbGVuZ3RoIGFkZHJlcyB3aXRoIDB4IHByZWZpeFxuICpcbiAqIEBtZXRob2QgdG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgYWRkcmVzc1xuICovXG52YXIgdG9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNTdHJpY3RBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cblxuICAgIGlmICgvXlswLTlhLWZdezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBhZGRyZXNzO1xuICAgIH1cblxuICAgIHJldHVybiAnMHgnICsgcGFkTGVmdCh0b0hleChhZGRyZXNzKS5zdWJzdHIoMiksIDQwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBCaWdOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCaWdOdW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBCaWdOdW1iZXIgfHxcbiAgICAgICAgKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCaWdOdW1iZXInKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNTdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAob2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvciAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ1N0cmluZycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgT2JqZXQsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgIT09IG51bGwgJiYgIShvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0Jvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Jvb2xlYW4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzQXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEFycmF5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIHZhbGlkIGpzb24gb2JqZWN0XG4gKlxuICogQG1ldGhvZCBpc0pzb25cbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSnNvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFKU09OLnBhcnNlKHN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgRXRoZXJldW0gYmxvY2sgaGVhZGVyIGJsb29tLlxuICpcbiAqIEBtZXRob2QgaXNCbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGhleCBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmxvb20gPSBmdW5jdGlvbiAoYmxvb20pIHtcbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs1MTJ9JC9pLnRlc3QoYmxvb20pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKC9eKDB4KT9bMC05YS1mXXs1MTJ9JC8udGVzdChibG9vbSkgfHwgL14oMHgpP1swLTlBLUZdezUxMn0kLy50ZXN0KGJsb29tKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgbG9nIHRvcGljLlxuICpcbiAqIEBtZXRob2QgaXNUb3BpY1xuICogQHBhcmFtIHtTdHJpbmd9IGhleCBlbmNvZGVkIHRvcGljXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUb3BpYyA9IGZ1bmN0aW9uICh0b3BpYykge1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezY0fSQvaS50ZXN0KHRvcGljKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NjR9JC8udGVzdCh0b3BpYykgfHwgL14oMHgpP1swLTlBLUZdezY0fSQvLnRlc3QodG9waWMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYWRMZWZ0OiBwYWRMZWZ0LFxuICAgIHBhZFJpZ2h0OiBwYWRSaWdodCxcbiAgICB0b0hleDogdG9IZXgsXG4gICAgdG9EZWNpbWFsOiB0b0RlY2ltYWwsXG4gICAgZnJvbURlY2ltYWw6IGZyb21EZWNpbWFsLFxuICAgIHRvVXRmODogdG9VdGY4LFxuICAgIHRvQXNjaWk6IHRvQXNjaWksXG4gICAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICAgIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICAgIHRyYW5zZm9ybVRvRnVsbE5hbWU6IHRyYW5zZm9ybVRvRnVsbE5hbWUsXG4gICAgZXh0cmFjdERpc3BsYXlOYW1lOiBleHRyYWN0RGlzcGxheU5hbWUsXG4gICAgZXh0cmFjdFR5cGVOYW1lOiBleHRyYWN0VHlwZU5hbWUsXG4gICAgdG9XZWk6IHRvV2VpLFxuICAgIGZyb21XZWk6IGZyb21XZWksXG4gICAgdG9CaWdOdW1iZXI6IHRvQmlnTnVtYmVyLFxuICAgIHRvVHdvc0NvbXBsZW1lbnQ6IHRvVHdvc0NvbXBsZW1lbnQsXG4gICAgdG9BZGRyZXNzOiB0b0FkZHJlc3MsXG4gICAgaXNCaWdOdW1iZXI6IGlzQmlnTnVtYmVyLFxuICAgIGlzU3RyaWN0QWRkcmVzczogaXNTdHJpY3RBZGRyZXNzLFxuICAgIGlzQWRkcmVzczogaXNBZGRyZXNzLFxuICAgIGlzQ2hlY2tzdW1BZGRyZXNzOiBpc0NoZWNrc3VtQWRkcmVzcyxcbiAgICB0b0NoZWNrc3VtQWRkcmVzczogdG9DaGVja3N1bUFkZHJlc3MsXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgaXNKc29uOiBpc0pzb24sXG4gICAgaXNCbG9vbTogaXNCbG9vbSxcbiAgICBpc1RvcGljOiBpc1RvcGljLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL3V0aWxzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1widmVyc2lvblwiOlwiMC4yMC4xXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3ZlcnNpb24uanNvblxuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3ZlcnNpb24uanNvblxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSB3ZWIzLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiAgIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqICAgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgUmVxdWVzdE1hbmFnZXIgPSByZXF1aXJlKCcuL3dlYjMvcmVxdWVzdG1hbmFnZXInKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnLi93ZWIzL2liYW4nKTtcbnZhciBFdGggPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9ldGgnKTtcbnZhciBEQiA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL2RiJyk7XG52YXIgU2hoID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvc2hoJyk7XG52YXIgTmV0ID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvbmV0Jyk7XG52YXIgUGVyc29uYWwgPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9wZXJzb25hbCcpO1xudmFyIFN3YXJtID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvc3dhcm0nKTtcbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vd2ViMy9zZXR0aW5ncycpO1xudmFyIHZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24uanNvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91dGlscycpO1xudmFyIHNoYTMgPSByZXF1aXJlKCcuL3V0aWxzL3NoYTMnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3dlYjMvZXh0ZW5kJyk7XG52YXIgQmF0Y2ggPSByZXF1aXJlKCcuL3dlYjMvYmF0Y2gnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vd2ViMy9wcm9wZXJ0eScpO1xudmFyIEh0dHBQcm92aWRlciA9IHJlcXVpcmUoJy4vd2ViMy9odHRwcHJvdmlkZXInKTtcbnZhciBJcGNQcm92aWRlciA9IHJlcXVpcmUoJy4vd2ViMy9pcGNwcm92aWRlcicpO1xudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuXG5cblxuZnVuY3Rpb24gV2ViMyAocHJvdmlkZXIpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IG5ldyBSZXF1ZXN0TWFuYWdlcihwcm92aWRlcik7XG4gICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLmV0aCA9IG5ldyBFdGgodGhpcyk7XG4gICAgdGhpcy5kYiA9IG5ldyBEQih0aGlzKTtcbiAgICB0aGlzLnNoaCA9IG5ldyBTaGgodGhpcyk7XG4gICAgdGhpcy5uZXQgPSBuZXcgTmV0KHRoaXMpO1xuICAgIHRoaXMucGVyc29uYWwgPSBuZXcgUGVyc29uYWwodGhpcyk7XG4gICAgdGhpcy5ienogPSBuZXcgU3dhcm0odGhpcyk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuICAgIHRoaXMudmVyc2lvbiA9IHtcbiAgICAgICAgYXBpOiB2ZXJzaW9uLnZlcnNpb25cbiAgICB9O1xuICAgIHRoaXMucHJvdmlkZXJzID0ge1xuICAgICAgICBIdHRwUHJvdmlkZXI6IEh0dHBQcm92aWRlcixcbiAgICAgICAgSXBjUHJvdmlkZXI6IElwY1Byb3ZpZGVyXG4gICAgfTtcbiAgICB0aGlzLl9leHRlbmQgPSBleHRlbmQodGhpcyk7XG4gICAgdGhpcy5fZXh0ZW5kKHtcbiAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcygpXG4gICAgfSk7XG59XG5cbi8vIGV4cG9zZSBwcm92aWRlcnMgb24gdGhlIGNsYXNzXG5XZWIzLnByb3ZpZGVycyA9IHtcbiAgICBIdHRwUHJvdmlkZXI6IEh0dHBQcm92aWRlcixcbiAgICBJcGNQcm92aWRlcjogSXBjUHJvdmlkZXJcbn07XG5cbldlYjMucHJvdG90eXBlLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIuc2V0UHJvdmlkZXIocHJvdmlkZXIpO1xuICAgIHRoaXMuY3VycmVudFByb3ZpZGVyID0gcHJvdmlkZXI7XG59O1xuXG5XZWIzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChrZWVwSXNTeW5jaW5nKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIucmVzZXQoa2VlcElzU3luY2luZyk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xufTtcblxuV2ViMy5wcm90b3R5cGUuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xuV2ViMy5wcm90b3R5cGUudG9IZXggPSB1dGlscy50b0hleDtcbldlYjMucHJvdG90eXBlLnRvQXNjaWkgPSB1dGlscy50b0FzY2lpO1xuV2ViMy5wcm90b3R5cGUudG9VdGY4ID0gdXRpbHMudG9VdGY4O1xuV2ViMy5wcm90b3R5cGUuZnJvbUFzY2lpID0gdXRpbHMuZnJvbUFzY2lpO1xuV2ViMy5wcm90b3R5cGUuZnJvbVV0ZjggPSB1dGlscy5mcm9tVXRmODtcbldlYjMucHJvdG90eXBlLnRvRGVjaW1hbCA9IHV0aWxzLnRvRGVjaW1hbDtcbldlYjMucHJvdG90eXBlLmZyb21EZWNpbWFsID0gdXRpbHMuZnJvbURlY2ltYWw7XG5XZWIzLnByb3RvdHlwZS50b0JpZ051bWJlciA9IHV0aWxzLnRvQmlnTnVtYmVyO1xuV2ViMy5wcm90b3R5cGUudG9XZWkgPSB1dGlscy50b1dlaTtcbldlYjMucHJvdG90eXBlLmZyb21XZWkgPSB1dGlscy5mcm9tV2VpO1xuV2ViMy5wcm90b3R5cGUuaXNBZGRyZXNzID0gdXRpbHMuaXNBZGRyZXNzO1xuV2ViMy5wcm90b3R5cGUuaXNDaGVja3N1bUFkZHJlc3MgPSB1dGlscy5pc0NoZWNrc3VtQWRkcmVzcztcbldlYjMucHJvdG90eXBlLnRvQ2hlY2tzdW1BZGRyZXNzID0gdXRpbHMudG9DaGVja3N1bUFkZHJlc3M7XG5XZWIzLnByb3RvdHlwZS5pc0lCQU4gPSB1dGlscy5pc0lCQU47XG5XZWIzLnByb3RvdHlwZS5wYWRMZWZ0ID0gdXRpbHMucGFkTGVmdDtcbldlYjMucHJvdG90eXBlLnBhZFJpZ2h0ID0gdXRpbHMucGFkUmlnaHQ7XG5cblxuV2ViMy5wcm90b3R5cGUuc2hhMyA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiAnMHgnICsgc2hhMyhzdHJpbmcsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGRpcmVjdCBpY2FwIHRvIGFkZHJlc3NcbiAqL1xuV2ViMy5wcm90b3R5cGUuZnJvbUlDQVAgPSBmdW5jdGlvbiAoaWNhcCkge1xuICAgIHZhciBpYmFuID0gbmV3IEliYW4oaWNhcCk7XG4gICAgcmV0dXJuIGliYW4uYWRkcmVzcygpO1xufTtcblxudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLm5vZGUnLFxuICAgICAgICAgICAgZ2V0dGVyOiAnd2ViM19jbGllbnRWZXJzaW9uJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLm5ldHdvcmsnLFxuICAgICAgICAgICAgZ2V0dGVyOiAnbmV0X3ZlcnNpb24nLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLmV0aGVyZXVtJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9wcm90b2NvbFZlcnNpb24nLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLndoaXNwZXInLFxuICAgICAgICAgICAgZ2V0dGVyOiAnc2hoX3ZlcnNpb24nLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5XZWIzLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRQcm92aWRlciAmJiB0aGlzLmN1cnJlbnRQcm92aWRlci5pc0Nvbm5lY3RlZCgpKTtcbn07XG5cbldlYjMucHJvdG90eXBlLmNyZWF0ZUJhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQmF0Y2godGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYjM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBhbGxldmVudHMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIHNoYTMgPSByZXF1aXJlKCcuLi91dGlscy9zaGEzJyk7XG52YXIgU29saWRpdHlFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgd2F0Y2hlcyA9IHJlcXVpcmUoJy4vbWV0aG9kcy93YXRjaGVzJyk7XG5cbnZhciBBbGxTb2xpZGl0eUV2ZW50cyA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwganNvbiwgYWRkcmVzcykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5fanNvbiA9IGpzb247XG4gICAgdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG59O1xuXG5BbGxTb2xpZGl0eUV2ZW50cy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBbJ2Zyb21CbG9jaycsICd0b0Jsb2NrJ10uZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2ZdICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXN1bHRbZl0gPSBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9uc1tmXSk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQuYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3M7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8ICcnO1xuICAgIGRhdGEudG9waWNzID0gZGF0YS50b3BpY3MgfHwgW107XG5cbiAgICB2YXIgZXZlbnRUb3BpYyA9IGRhdGEudG9waWNzWzBdLnNsaWNlKDIpO1xuICAgIHZhciBtYXRjaCA9IHRoaXMuX2pzb24uZmlsdGVyKGZ1bmN0aW9uIChqKSB7XG4gICAgICAgIHJldHVybiBldmVudFRvcGljID09PSBzaGEzKHV0aWxzLnRyYW5zZm9ybVRvRnVsbE5hbWUoaikpO1xuICAgIH0pWzBdO1xuXG4gICAgaWYgKCFtYXRjaCkgeyAvLyBjYW5ub3QgZmluZCBtYXRjaGluZyBldmVudD9cbiAgICAgICAgY29uc29sZS53YXJuKCdjYW5ub3QgZmluZCBldmVudCBmb3IgbG9nJyk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHZhciBldmVudCA9IG5ldyBTb2xpZGl0eUV2ZW50KHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCBtYXRjaCwgdGhpcy5fYWRkcmVzcyk7XG4gICAgcmV0dXJuIGV2ZW50LmRlY29kZShkYXRhKTtcbn07XG5cbkFsbFNvbGlkaXR5RXZlbnRzLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbyA9IHRoaXMuZW5jb2RlKG9wdGlvbnMpO1xuICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmRlY29kZS5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBuZXcgRmlsdGVyKG8sICdldGgnLCB0aGlzLl9yZXF1ZXN0TWFuYWdlciwgd2F0Y2hlcy5ldGgoKSwgZm9ybWF0dGVyLCBjYWxsYmFjayk7XG59O1xuXG5BbGxTb2xpZGl0eUV2ZW50cy5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgY29udHJhY3QuYWxsRXZlbnRzID0gZXhlY3V0ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsU29saWRpdHlFdmVudHM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2FsbGV2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvYWxsZXZlbnRzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBiYXRjaC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgSnNvbnJwYyA9IHJlcXVpcmUoJy4vanNvbnJwYycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbnZhciBCYXRjaCA9IGZ1bmN0aW9uICh3ZWIzKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMucmVxdWVzdHMgPSBbXTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgY3JlYXRlIG5ldyByZXF1ZXN0IHRvIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtPYmplY3R9IGpzb25ycGMgcmVxdWV0IG9iamVjdFxuICovXG5CYXRjaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICB0aGlzLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZXhlY3V0ZSBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBleGVjdXRlXG4gKi9cbkJhdGNoLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXF1ZXN0cyA9IHRoaXMucmVxdWVzdHM7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5zZW5kQmF0Y2gocmVxdWVzdHMsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gICAgICAgIHJlcXVlc3RzLm1hcChmdW5jdGlvbiAocmVxdWVzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzW2luZGV4XSB8fCB7fTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RzW2luZGV4XS5jYWxsYmFjaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0c1tpbmRleF0uY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0c1tpbmRleF0uY2FsbGJhY2sobnVsbCwgKHJlcXVlc3RzW2luZGV4XS5mb3JtYXQgPyByZXF1ZXN0c1tpbmRleF0uZm9ybWF0KHJlc3VsdC5yZXN1bHQpIDogcmVzdWx0LnJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTsgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhdGNoO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9iYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvYmF0Y2guanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgY29udHJhY3QuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjb2RlciA9IHJlcXVpcmUoJy4uL3NvbGlkaXR5L2NvZGVyJyk7XG52YXIgU29saWRpdHlFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcbnZhciBTb2xpZGl0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9mdW5jdGlvbicpO1xudmFyIEFsbEV2ZW50cyA9IHJlcXVpcmUoJy4vYWxsZXZlbnRzJyk7XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBlbmNvZGUgY29uc3RydWN0b3IgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtc1xuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJ1Y3RvciBwYXJhbXNcbiAqL1xudmFyIGVuY29kZUNvbnN0cnVjdG9yUGFyYW1zID0gZnVuY3Rpb24gKGFiaSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiBqc29uLmlucHV0cy5sZW5ndGggPT09IHBhcmFtcy5sZW5ndGg7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQudHlwZTtcbiAgICAgICAgfSk7XG4gICAgfSkubWFwKGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICByZXR1cm4gY29kZXIuZW5jb2RlUGFyYW1zKHR5cGVzLCBwYXJhbXMpO1xuICAgIH0pWzBdIHx8ICcnO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFkZCBmdW5jdGlvbnMgdG8gY29udHJhY3Qgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBhZGRGdW5jdGlvbnNUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fSBjb250cmFjdFxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKi9cbnZhciBhZGRGdW5jdGlvbnNUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgY29udHJhY3QuYWJpLmZpbHRlcihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4ganNvbi50eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IFNvbGlkaXR5RnVuY3Rpb24oY29udHJhY3QuX2V0aCwganNvbiwgY29udHJhY3QuYWRkcmVzcyk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICBmLmF0dGFjaFRvQ29udHJhY3QoY29udHJhY3QpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFkZCBldmVudHMgdG8gY29udHJhY3Qgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBhZGRFdmVudHNUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fSBjb250cmFjdFxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKi9cbnZhciBhZGRFdmVudHNUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV2ZW50cyA9IGNvbnRyYWN0LmFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2V2ZW50JztcbiAgICB9KTtcblxuICAgIHZhciBBbGwgPSBuZXcgQWxsRXZlbnRzKGNvbnRyYWN0Ll9ldGguX3JlcXVlc3RNYW5hZ2VyLCBldmVudHMsIGNvbnRyYWN0LmFkZHJlc3MpO1xuICAgIEFsbC5hdHRhY2hUb0NvbnRyYWN0KGNvbnRyYWN0KTtcblxuICAgIGV2ZW50cy5tYXAoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb2xpZGl0eUV2ZW50KGNvbnRyYWN0Ll9ldGguX3JlcXVlc3RNYW5hZ2VyLCBqc29uLCBjb250cmFjdC5hZGRyZXNzKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuYXR0YWNoVG9Db250cmFjdChjb250cmFjdCk7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiB0aGUgY29udHJhY3QgZ2V0cyBwcm9wZXJseSBkZXBsb3llZCBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7VW5kZWZpbmVkfVxuICovXG52YXIgY2hlY2tGb3JDb250cmFjdEFkZHJlc3MgPSBmdW5jdGlvbihjb250cmFjdCwgY2FsbGJhY2spe1xuICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgIGNhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblxuICAgIC8vIHdhaXQgZm9yIHJlY2VpcHRcbiAgICB2YXIgZmlsdGVyID0gY29udHJhY3QuX2V0aC5maWx0ZXIoJ2xhdGVzdCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZiAoIWUgJiYgIWNhbGxiYWNrRmlyZWQpIHtcbiAgICAgICAgICAgIGNvdW50Kys7XG5cbiAgICAgICAgICAgIC8vIHN0b3Agd2F0Y2hpbmcgYWZ0ZXIgNTAgYmxvY2tzICh0aW1lb3V0KVxuICAgICAgICAgICAgaWYgKGNvdW50ID4gNTApIHtcblxuICAgICAgICAgICAgICAgIGZpbHRlci5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGaXJlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignQ29udHJhY3QgdHJhbnNhY3Rpb24gY291bGRuXFwndCBiZSBmb3VuZCBhZnRlciA1MCBibG9ja3MnKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkblxcJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzJyk7XG5cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNvbnRyYWN0Ll9ldGguZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGNvbnRyYWN0LnRyYW5zYWN0aW9uSGFzaCwgZnVuY3Rpb24oZSwgcmVjZWlwdCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlY2VpcHQgJiYgIWNhbGxiYWNrRmlyZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3QuX2V0aC5nZXRDb2RlKHJlY2VpcHQuY29udHJhY3RBZGRyZXNzLCBmdW5jdGlvbihlLCBjb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA2ICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFja0ZpcmVkIHx8ICFjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuc3RvcFdhdGNoaW5nKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29kZS5sZW5ndGggPiAzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgZGVwbG95ZWQhJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3QuYWRkcmVzcyA9IHJlY2VpcHQuY29udHJhY3RBZGRyZXNzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBldmVudHMgYW5kIG1ldGhvZHMgYWdhaW4gYWZ0ZXIgd2UgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGdW5jdGlvbnNUb0NvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRzVG9Db250cmFjdChjb250cmFjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBjYWxsYmFjayBmb3IgdGhlIHNlY29uZCB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY29udHJhY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjb250cmFjdCBjb2RlIGNvdWxkblxcJ3QgYmUgc3RvcmVkLCBwbGVhc2UgY2hlY2sgeW91ciBnYXMgYW1vdW50LicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29udHJhY3QgY29kZSBjb3VsZG5cXCd0IGJlIHN0b3JlZCwgcGxlYXNlIGNoZWNrIHlvdXIgZ2FzIGFtb3VudC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBDb250cmFjdEZhY3RvcnkgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIENvbnRyYWN0RmFjdG9yeVxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKi9cbnZhciBDb250cmFjdEZhY3RvcnkgPSBmdW5jdGlvbiAoZXRoLCBhYmkpIHtcbiAgICB0aGlzLmV0aCA9IGV0aDtcbiAgICB0aGlzLmFiaSA9IGFiaTtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBjb250cmFjdCBvbiBhIGJsb2NrY2hhaW5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV3XG4gICAgICogQHBhcmFtIHtBbnl9IGNvbnRyYWN0IGNvbnN0cnVjdG9yIHBhcmFtMSAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHtBbnl9IGNvbnRyYWN0IGNvbnN0cnVjdG9yIHBhcmFtMiAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRyYWN0IHRyYW5zYWN0aW9uIG9iamVjdCAocmVxdWlyZWQpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7Q29udHJhY3R9IHJldHVybnMgY29udHJhY3QgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNyAqL1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHRoaXMuZXRoLCB0aGlzLmFiaSk7XG5cbiAgICAgICAgLy8gcGFyc2UgYXJndW1lbnRzXG4gICAgICAgIHZhciBvcHRpb25zID0ge307IC8vIHJlcXVpcmVkIVxuICAgICAgICB2YXIgY2FsbGJhY2s7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHV0aWxzLmlzT2JqZWN0KGxhc3QpICYmICF1dGlscy5pc0FycmF5KGxhc3QpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnZhbHVlID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yQWJpID0gYWJpLmZpbHRlcihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicgJiYganNvbi5pbnB1dHMubGVuZ3RoID09PSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgIH0pWzBdIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIWNvbnN0cnVjdG9yQWJpLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtcyh0aGlzLmFiaSwgYXJncyk7XG4gICAgICAgIG9wdGlvbnMuZGF0YSArPSBieXRlcztcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcblxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNvbnRyYWN0IGFkZHJlc3MgYWRuIGNoZWNrIGlmIHRoZSBjb2RlIHdhcyBkZXBsb3llZFxuICAgICAgICAgICAgdGhpcy5ldGguc2VuZFRyYW5zYWN0aW9uKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0LnRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBjYWxsYmFjayBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY29udHJhY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzKGNvbnRyYWN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuZXRoLnNlbmRUcmFuc2FjdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAgICAgY29udHJhY3QudHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcbiAgICAgICAgICAgIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzKGNvbnRyYWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9O1xuXG4gICAgdGhpcy5uZXcuZ2V0RGF0YSA9IHRoaXMuZ2V0RGF0YS5iaW5kKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgQ29udHJhY3RGYWN0b3J5XG4gKlxuICogQG1ldGhvZCBjb250cmFjdFxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKiBAcmV0dXJucyB7Q29udHJhY3RGYWN0b3J5fSBuZXcgY29udHJhY3QgZmFjdG9yeVxuICovXG4vL3ZhciBjb250cmFjdCA9IGZ1bmN0aW9uIChhYmkpIHtcbiAgICAvL3JldHVybiBuZXcgQ29udHJhY3RGYWN0b3J5KGFiaSk7XG4vL307XG5cblxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFjY2VzcyB0byBleGlzdGluZyBjb250cmFjdCBvbiBhIGJsb2NrY2hhaW5cbiAqXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0ge0FkZHJlc3N9IGNvbnRyYWN0IGFkZHJlc3MgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sge29wdGlvbmFsKVxuICogQHJldHVybnMge0NvbnRyYWN0fSByZXR1cm5zIGNvbnRyYWN0IGlmIG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQsXG4gKiBvdGhlcndpc2UgY2FsbHMgY2FsbGJhY2sgZnVuY3Rpb24gKGVyciwgY29udHJhY3QpXG4gKi9cbkNvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoYWRkcmVzcywgY2FsbGJhY2spIHtcbiAgICB2YXIgY29udHJhY3QgPSBuZXcgQ29udHJhY3QodGhpcy5ldGgsIHRoaXMuYWJpLCBhZGRyZXNzKTtcblxuICAgIC8vIHRoaXMgZnVuY3Rpb25zIGFyZSBub3QgcGFydCBvZiBwcm90b3R5cGUsXG4gICAgLy8gYmVjYXVzZSB3ZSBkb250IHdhbnQgdG8gc3BvaWwgdGhlIGludGVyZmFjZVxuICAgIGFkZEZ1bmN0aW9uc1RvQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGFkZEV2ZW50c1RvQ29udHJhY3QoY29udHJhY3QpO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRyYWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyYWN0O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhLCB3aGljaCBpcyBkYXRhIHRvIGRlcGxveSBwbHVzIGNvbnN0cnVjdG9yIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZ2V0RGF0YVxuICovXG5Db250cmFjdEZhY3RvcnkucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gcmVxdWlyZWQhXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgdmFyIGxhc3QgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGxhc3QpICYmICF1dGlscy5pc0FycmF5KGxhc3QpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzLnBvcCgpO1xuICAgIH1cblxuICAgIHZhciBieXRlcyA9IGVuY29kZUNvbnN0cnVjdG9yUGFyYW1zKHRoaXMuYWJpLCBhcmdzKTtcbiAgICBvcHRpb25zLmRhdGEgKz0gYnl0ZXM7XG5cbiAgICByZXR1cm4gb3B0aW9ucy5kYXRhO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgY29udHJhY3QgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIENvbnRyYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhYmlcbiAqIEBwYXJhbSB7QWRkcmVzc30gY29udHJhY3QgYWRkcmVzc1xuICovXG52YXIgQ29udHJhY3QgPSBmdW5jdGlvbiAoZXRoLCBhYmksIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9ldGggPSBldGg7XG4gICAgdGhpcy50cmFuc2FjdGlvbkhhc2ggPSBudWxsO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyYWN0RmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2NvbnRyYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9jb250cmFjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgZXJyb3JzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEludmFsaWROdW1iZXJPZlNvbGlkaXR5QXJnczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgdG8gU29saWRpdHkgZnVuY3Rpb24nKTtcbiAgICB9LFxuICAgIEludmFsaWROdW1iZXJPZlJQQ1BhcmFtczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBpbnB1dCBwYXJhbWV0ZXJzIHRvIFJQQyBtZXRob2QnKTtcbiAgICB9LFxuICAgIEludmFsaWRDb25uZWN0aW9uOiBmdW5jdGlvbiAoaG9zdCl7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0NPTk5FQ1RJT04gRVJST1I6IENvdWxkblxcJ3QgY29ubmVjdCB0byBub2RlICcrIGhvc3QgKycuJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkUHJvdmlkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignUHJvdmlkZXIgbm90IHNldCBvciBpbnZhbGlkJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXN1bHQpe1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICEhcmVzdWx0ICYmICEhcmVzdWx0LmVycm9yICYmICEhcmVzdWx0LmVycm9yLm1lc3NhZ2UgPyByZXN1bHQuZXJyb3IubWVzc2FnZSA6ICdJbnZhbGlkIEpTT04gUlBDIHJlc3BvbnNlOiAnICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9LFxuICAgIENvbm5lY3Rpb25UaW1lb3V0OiBmdW5jdGlvbiAobXMpe1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdDT05ORUNUSU9OIFRJTUVPVVQ6IHRpbWVvdXQgb2YgJyArIG1zICsgJyBtcyBhY2hpdmVkJyk7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Vycm9ycy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXJyb3JzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV2ZW50LmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgd2F0Y2hlcyA9IHJlcXVpcmUoJy4vbWV0aG9kcy93YXRjaGVzJyk7XG5cbi8qKlxuICogVGhpcyBwcm90b3R5cGUgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGV2ZW50IGZpbHRlcnNcbiAqL1xudmFyIFNvbGlkaXR5RXZlbnQgPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMuX3BhcmFtcyA9IGpzb24uaW5wdXRzO1xuICAgIHRoaXMuX25hbWUgPSB1dGlscy50cmFuc2Zvcm1Ub0Z1bGxOYW1lKGpzb24pO1xuICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMuX2Fub255bW91cyA9IGpzb24uYW5vbnltb3VzO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZmlsdGVyZWQgcGFyYW0gdHlwZXNcbiAqXG4gKiBAbWV0aG9kIHR5cGVzXG4gKiBAcGFyYW0ge0Jvb2x9IGRlY2lkZSBpZiByZXR1cm5lZCB0eXBlZCBzaG91bGQgYmUgaW5kZXhlZFxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHR5cGVzXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLnR5cGVzID0gZnVuY3Rpb24gKGluZGV4ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS5pbmRleGVkID09PSBpbmRleGVkO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZXZlbnQgZGlzcGxheSBuYW1lXG4gKlxuICogQG1ldGhvZCBkaXNwbGF5TmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBldmVudCBkaXNwbGF5IG5hbWVcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuZGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmV4dHJhY3REaXNwbGF5TmFtZSh0aGlzLl9uYW1lKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGV2ZW50IHR5cGUgbmFtZVxuICpcbiAqIEBtZXRob2QgdHlwZU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZXZlbnQgdHlwZSBuYW1lXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5leHRyYWN0VHlwZU5hbWUodGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBldmVudCBzaWduYXR1cmVcbiAqXG4gKiBAbWV0aG9kIHNpZ25hdHVyZVxuICogQHJldHVybiB7U3RyaW5nfSBldmVudCBzaWduYXR1cmVcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuc2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzaGEzKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgaW5kZXhlZCBwYXJhbXMgYW5kIG9wdGlvbnMgdG8gb25lIGZpbmFsIG9iamVjdFxuICpcbiAqIEBtZXRob2QgZW5jb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5kZXhlZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlcnl0aGluZyBjb21iaW5lZCB0b2dldGhlciBhbmQgZW5jb2RlZFxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoaW5kZXhlZCwgb3B0aW9ucykge1xuICAgIGluZGV4ZWQgPSBpbmRleGVkIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIFsnZnJvbUJsb2NrJywgJ3RvQmxvY2snXS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbZl0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJlc3VsdFtmXSA9IGZvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihvcHRpb25zW2ZdKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC50b3BpY3MgPSBbXTtcblxuICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fYWRkcmVzcztcbiAgICBpZiAoIXRoaXMuX2Fub255bW91cykge1xuICAgICAgICByZXN1bHQudG9waWNzLnB1c2goJzB4JyArIHRoaXMuc2lnbmF0dXJlKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleGVkVG9waWNzID0gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS5pbmRleGVkID09PSB0cnVlO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleGVkW2kubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMHgnICsgY29kZXIuZW5jb2RlUGFyYW0oaS50eXBlLCB2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnMHgnICsgY29kZXIuZW5jb2RlUGFyYW0oaS50eXBlLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQudG9waWNzID0gcmVzdWx0LnRvcGljcy5jb25jYXQoaW5kZXhlZFRvcGljcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgaW5kZXhlZCBwYXJhbXMgYW5kIG9wdGlvbnNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0IG9iamVjdCB3aXRoIGRlY29kZWQgaW5kZXhlZCAmJiBub3QgaW5kZXhlZCBwYXJhbXNcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCAnJztcbiAgICBkYXRhLnRvcGljcyA9IGRhdGEudG9waWNzIHx8IFtdO1xuXG4gICAgdmFyIGFyZ1RvcGljcyA9IHRoaXMuX2Fub255bW91cyA/IGRhdGEudG9waWNzIDogZGF0YS50b3BpY3Muc2xpY2UoMSk7XG4gICAgdmFyIGluZGV4ZWREYXRhID0gYXJnVG9waWNzLm1hcChmdW5jdGlvbiAodG9waWNzKSB7IHJldHVybiB0b3BpY3Muc2xpY2UoMik7IH0pLmpvaW4oXCJcIik7XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBjb2Rlci5kZWNvZGVQYXJhbXModGhpcy50eXBlcyh0cnVlKSwgaW5kZXhlZERhdGEpO1xuXG4gICAgdmFyIG5vdEluZGV4ZWREYXRhID0gZGF0YS5kYXRhLnNsaWNlKDIpO1xuICAgIHZhciBub3RJbmRleGVkUGFyYW1zID0gY29kZXIuZGVjb2RlUGFyYW1zKHRoaXMudHlwZXMoZmFsc2UpLCBub3RJbmRleGVkRGF0YSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIoZGF0YSk7XG4gICAgcmVzdWx0LmV2ZW50ID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIHJlc3VsdC5hZGRyZXNzID0gZGF0YS5hZGRyZXNzO1xuXG4gICAgcmVzdWx0LmFyZ3MgPSB0aGlzLl9wYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnJlbnQpIHtcbiAgICAgICAgYWNjW2N1cnJlbnQubmFtZV0gPSBjdXJyZW50LmluZGV4ZWQgPyBpbmRleGVkUGFyYW1zLnNoaWZ0KCkgOiBub3RJbmRleGVkUGFyYW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgZGVsZXRlIHJlc3VsdC5kYXRhO1xuICAgIGRlbGV0ZSByZXN1bHQudG9waWNzO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIG5ldyBmaWx0ZXIgb2JqZWN0IGZyb20gZXZlbnRcbiAqXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmRleGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSBmaWx0ZXIgb2JqZWN0XG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoaW5kZXhlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIGluZGV4ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUoaW5kZXhlZCwgb3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIobywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXIsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gYXR0YWNoIGV2ZW50IHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH1cbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIGlmICghY29udHJhY3RbZGlzcGxheU5hbWVdKSB7XG4gICAgICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXSA9IGV4ZWN1dGU7XG4gICAgfVxuICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXVt0aGlzLnR5cGVOYW1lKCldID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcywgY29udHJhY3QpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eUV2ZW50O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXZlbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBNZXRob2QgPSByZXF1aXJlKCcuL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vLyBUT0RPOiByZWZhY3Rvciwgc28gdGhlIGlucHV0IHBhcmFtcyBhcmUgbm90IGFsdGVyZWQuXG4vLyBpdCdzIG5lY2Vzc2FyeSB0byBtYWtlIHNhbWUgJ2V4dGVuc2lvbicgd29yayB3aXRoIG11bHRpcGxlIHByb3ZpZGVyc1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uICh3ZWIzKSB7XG4gICAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6NSAqL1xuICAgIHZhciBleCA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcblxuICAgICAgICB2YXIgZXh0ZW5kZWRPYmplY3Q7XG4gICAgICAgIGlmIChleHRlbnNpb24ucHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmICghd2ViM1tleHRlbnNpb24ucHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgd2ViM1tleHRlbnNpb24ucHJvcGVydHldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbmRlZE9iamVjdCA9IHdlYjNbZXh0ZW5zaW9uLnByb3BlcnR5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuZGVkT2JqZWN0ID0gd2ViMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb24ubWV0aG9kcykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KGV4dGVuZGVkT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0ZW5zaW9uLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbi5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkuYXR0YWNoVG9PYmplY3QoZXh0ZW5kZWRPYmplY3QpO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFJlcXVlc3RNYW5hZ2VyKHdlYjMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGV4LmZvcm1hdHRlcnMgPSBmb3JtYXR0ZXJzOyBcbiAgICBleC51dGlscyA9IHV0aWxzO1xuICAgIGV4Lk1ldGhvZCA9IE1ldGhvZDtcbiAgICBleC5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xuXG4gICAgcmV0dXJuIGV4O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9leHRlbmQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2V4dGVuZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGZpbHRlci5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEplZmZyZXkgV2lsY2tlIDxqZWZmQGV0aGRldi5jb20+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBNYXJpYW4gT2FuY2VhIDxtYXJpYW5AZXRoZGV2LmNvbT5cbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiAgIEdhdiBXb29kIDxnQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbi8qKlxuKiBDb252ZXJ0cyBhIGdpdmVuIHRvcGljIHRvIGEgaGV4IHN0cmluZywgYnV0IGFsc28gYWxsb3dzIG51bGwgdmFsdWVzLlxuKlxuKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuKiBAcmV0dXJuIHtTdHJpbmd9XG4qL1xudmFyIHRvVG9waWMgPSBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICBpZih2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblxuICAgIGlmKHZhbHVlLmluZGV4T2YoJzB4JykgPT09IDApXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB1dGlscy5mcm9tVXRmOCh2YWx1ZSk7XG59O1xuXG4vLy8gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbiBvcHRpb25zIG9iamVjdCwgdG8gdmVyaWZ5IGRlcHJlY2F0ZWQgcHJvcGVydGllcyAmJiBsYXp5IGxvYWQgZHluYW1pYyBvbmVzXG4vLy8gQHBhcmFtIHNob3VsZCBiZSBzdHJpbmcgb3Igb2JqZWN0XG4vLy8gQHJldHVybnMgb3B0aW9ucyBzdHJpbmcgb3Igb2JqZWN0XG52YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zLCB0eXBlKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuXG4gICAgaWYgKHV0aWxzLmlzU3RyaW5nKG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlICdldGgnOlxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG9waWNzLCBnZXQgY29udmVydGVkIHRvIGhleFxuICAgICAgICAgICAgb3B0aW9ucy50b3BpY3MgPSBvcHRpb25zLnRvcGljcyB8fCBbXTtcbiAgICAgICAgICAgIG9wdGlvbnMudG9waWNzID0gb3B0aW9ucy50b3BpY3MubWFwKGZ1bmN0aW9uKHRvcGljKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHV0aWxzLmlzQXJyYXkodG9waWMpKSA/IHRvcGljLm1hcCh0b1RvcGljKSA6IHRvVG9waWModG9waWMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9waWNzOiBvcHRpb25zLnRvcGljcyxcbiAgICAgICAgICAgICAgICBmcm9tOiBvcHRpb25zLmZyb20sXG4gICAgICAgICAgICAgICAgdG86IG9wdGlvbnMudG8sXG4gICAgICAgICAgICAgICAgYWRkcmVzczogb3B0aW9ucy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZyb21CbG9jazogZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKG9wdGlvbnMuZnJvbUJsb2NrKSxcbiAgICAgICAgICAgICAgICB0b0Jsb2NrOiBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9ucy50b0Jsb2NrKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnc2hoJzpcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbn07XG5cbi8qKlxuQWRkcyB0aGUgY2FsbGJhY2sgYW5kIHNldHMgdXAgdGhlIG1ldGhvZHMsIHRvIGl0ZXJhdGUgb3ZlciB0aGUgcmVzdWx0cy5cblxuQG1ldGhvZCBnZXRMb2dzQXRTdGFydFxuQHBhcmFtIHtPYmplY3R9IHNlbGZcbkBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4qL1xudmFyIGdldExvZ3NBdFN0YXJ0ID0gZnVuY3Rpb24oc2VsZiwgY2FsbGJhY2spe1xuICAgIC8vIGNhbGwgZ2V0RmlsdGVyTG9ncyBmb3IgdGhlIGZpcnN0IHdhdGNoIGNhbGxiYWNrIHN0YXJ0XG4gICAgaWYgKCF1dGlscy5pc1N0cmluZyhzZWxmLm9wdGlvbnMpKSB7XG4gICAgICAgIHNlbGYuZ2V0KGZ1bmN0aW9uIChlcnIsIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBzZW5kIGFsbCB0aGUgcmVzcG9uc2VzIHRvIGFsbCB0aGUgd2F0Y2hlcyBhZ2Fpbi4uLiBqdXN0IHRvIHNlbGYgb25lXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodXRpbHMuaXNBcnJheShtZXNzYWdlcykpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbkFkZHMgdGhlIGNhbGxiYWNrIGFuZCBzZXRzIHVwIHRoZSBtZXRob2RzLCB0byBpdGVyYXRlIG92ZXIgdGhlIHJlc3VsdHMuXG5cbkBtZXRob2QgcG9sbEZpbHRlclxuQHBhcmFtIHtPYmplY3R9IHNlbGZcbiovXG52YXIgcG9sbEZpbHRlciA9IGZ1bmN0aW9uKHNlbGYpIHtcblxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyb3IsIG1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih1dGlscy5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzZWxmLmZvcm1hdHRlciA/IHNlbGYuZm9ybWF0dGVyKG1lc3NhZ2UpIDogbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYucmVxdWVzdE1hbmFnZXIuc3RhcnRQb2xsaW5nKHtcbiAgICAgICAgbWV0aG9kOiBzZWxmLmltcGxlbWVudGF0aW9uLnBvbGwuY2FsbCxcbiAgICAgICAgcGFyYW1zOiBbc2VsZi5maWx0ZXJJZF0sXG4gICAgfSwgc2VsZi5maWx0ZXJJZCwgb25NZXNzYWdlLCBzZWxmLnN0b3BXYXRjaGluZy5iaW5kKHNlbGYpKTtcblxufTtcblxudmFyIEZpbHRlciA9IGZ1bmN0aW9uIChvcHRpb25zLCB0eXBlLCByZXF1ZXN0TWFuYWdlciwgbWV0aG9kcywgZm9ybWF0dGVyLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IHt9O1xuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihyZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChpbXBsZW1lbnRhdGlvbik7XG4gICAgfSk7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMub3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucywgdHlwZSk7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbiA9IGltcGxlbWVudGF0aW9uO1xuICAgIHRoaXMuZmlsdGVySWQgPSBudWxsO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5nZXRMb2dzQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5wb2xsRmlsdGVycyA9IFtdO1xuICAgIHRoaXMuZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb24ubmV3RmlsdGVyKHRoaXMub3B0aW9ucywgZnVuY3Rpb24oZXJyb3IsIGlkKXtcbiAgICAgICAgaWYoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oY2Ipe1xuICAgICAgICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZmlsdGVySWQgPSBpZDtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGdldCBwZW5kaW5nIGNhbGxiYWNrcyBhcyBhIGNvbnNlcXVlbmNlXG4gICAgICAgICAgICAvLyBvZiBjYWxsaW5nIGdldCgpIHdpdGggZmlsdGVySWQgdW5hc3NpZ25lZC5cbiAgICAgICAgICAgIHNlbGYuZ2V0TG9nc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYil7XG4gICAgICAgICAgICAgICAgc2VsZi5nZXQoY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmdldExvZ3NDYWxsYmFja3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gZ2V0IGZpbHRlciBsb2dzIGZvciB0aGUgYWxyZWFkeSBleGlzdGluZyB3YXRjaCBjYWxsc1xuICAgICAgICAgICAgc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYil7XG4gICAgICAgICAgICAgICAgZ2V0TG9nc0F0U3RhcnQoc2VsZiwgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZihzZWxmLmNhbGxiYWNrcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHBvbGxGaWx0ZXIoc2VsZik7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRvIHdhdGNoIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi53YXRjaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG4gICAgaWYodGhpcy5maWx0ZXJJZCkge1xuICAgICAgICBnZXRMb2dzQXRTdGFydCh0aGlzLCBjYWxsYmFjayk7XG4gICAgICAgIHBvbGxGaWx0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnN0b3BXYXRjaGluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIuc3RvcFBvbGxpbmcodGhpcy5maWx0ZXJJZCk7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICAvLyByZW1vdmUgZmlsdGVyIGFzeW5jXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24udW5pbnN0YWxsRmlsdGVyKHRoaXMuZmlsdGVySWQsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBsZW1lbnRhdGlvbi51bmluc3RhbGxGaWx0ZXIodGhpcy5maWx0ZXJJZCk7XG4gICAgfVxufTtcblxuRmlsdGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBmaWx0ZXJJZCBpcyBub3Qgc2V0IHlldCwgY2FsbCBpdCBiYWNrXG4gICAgICAgICAgICAvLyB3aGVuIG5ld0ZpbHRlcigpIGFzc2lnbnMgaXQuXG4gICAgICAgICAgICB0aGlzLmdldExvZ3NDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCwgZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMubWFwKGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdHRlciA/IHNlbGYuZm9ybWF0dGVyKGxvZykgOiBsb2c7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlciBJRCBFcnJvcjogZmlsdGVyKCkuZ2V0KCkgY2FuXFwndCBiZSBjaGFpbmVkIHN5bmNocm9ub3VzLCBwbGVhc2UgcHJvdmlkZSBhIGNhbGxiYWNrIGZvciB0aGUgZ2V0KCkgbWV0aG9kLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2dzID0gdGhpcy5pbXBsZW1lbnRhdGlvbi5nZXRMb2dzKHRoaXMuZmlsdGVySWQpO1xuICAgICAgICByZXR1cm4gbG9ncy5tYXAoZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobG9nKSA6IGxvZztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9maWx0ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGZvcm1hdHRlcnMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgSWJhbiA9IHJlcXVpcmUoJy4vaWJhbicpO1xuXG4vKipcbiAqIFNob3VsZCB0aGUgZm9ybWF0IG91dHB1dCB0byBhIGJpZyBudW1iZXJcbiAqXG4gKiBAbWV0aG9kIG91dHB1dEJpZ051bWJlckZvcm1hdHRlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IG9iamVjdFxuICovXG52YXIgb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHJldHVybiB1dGlscy50b0JpZ051bWJlcihudW1iZXIpO1xufTtcblxudmFyIGlzUHJlZGVmaW5lZEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgcmV0dXJuIGJsb2NrTnVtYmVyID09PSAnbGF0ZXN0JyB8fCBibG9ja051bWJlciA9PT0gJ3BlbmRpbmcnIHx8IGJsb2NrTnVtYmVyID09PSAnZWFybGllc3QnO1xufTtcblxudmFyIGlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgaWYgKGJsb2NrTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5kZWZhdWx0QmxvY2s7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKGJsb2NrTnVtYmVyKTtcbn07XG5cbnZhciBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgaWYgKGJsb2NrTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGlzUHJlZGVmaW5lZEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy50b0hleChibG9ja051bWJlcik7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIGlucHV0IG9mIGEgdHJhbnNhY3Rpb24gYW5kIGNvbnZlcnRzIGFsbCB2YWx1ZXMgdG8gSEVYXG4gKlxuICogQG1ldGhvZCBpbnB1dENhbGxGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBvYmplY3RcbiovXG52YXIgaW5wdXRDYWxsRm9ybWF0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpe1xuXG4gICAgb3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tIHx8IGNvbmZpZy5kZWZhdWx0QWNjb3VudDtcblxuICAgIGlmIChvcHRpb25zLmZyb20pIHtcbiAgICAgICAgb3B0aW9ucy5mcm9tID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudG8pIHsgLy8gaXQgbWlnaHQgYmUgY29udHJhY3QgY3JlYXRpb25cbiAgICAgICAgb3B0aW9ucy50byA9IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLnRvKTtcbiAgICB9XG5cbiAgICBbJ2dhc1ByaWNlJywgJ2dhcycsICd2YWx1ZScsICdub25jZSddLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHV0aWxzLmZyb21EZWNpbWFsKG9wdGlvbnNba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB0cmFuc2FjdGlvbiBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBvYmplY3RcbiovXG52YXIgaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlciA9IGZ1bmN0aW9uIChvcHRpb25zKXtcblxuICAgIG9wdGlvbnMuZnJvbSA9IG9wdGlvbnMuZnJvbSB8fCBjb25maWcuZGVmYXVsdEFjY291bnQ7XG4gICAgb3B0aW9ucy5mcm9tID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMuZnJvbSk7XG5cbiAgICBpZiAob3B0aW9ucy50bykgeyAvLyBpdCBtaWdodCBiZSBjb250cmFjdCBjcmVhdGlvblxuICAgICAgICBvcHRpb25zLnRvID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMudG8pO1xuICAgIH1cblxuICAgIFsnZ2FzUHJpY2UnLCAnZ2FzJywgJ3ZhbHVlJywgJ25vbmNlJ10uZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgb3B0aW9uc1trZXldID0gdXRpbHMuZnJvbURlY2ltYWwob3B0aW9uc1trZXldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSB0cmFuc2FjdGlvbiB0byBpdHMgcHJvcGVyIHZhbHVlc1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFxuICogQHJldHVybnMge09iamVjdH1cbiovXG52YXIgb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIgPSBmdW5jdGlvbiAodHgpe1xuICAgIGlmKHR4LmJsb2NrTnVtYmVyICE9PSBudWxsKVxuICAgICAgICB0eC5ibG9ja051bWJlciA9IHV0aWxzLnRvRGVjaW1hbCh0eC5ibG9ja051bWJlcik7XG4gICAgaWYodHgudHJhbnNhY3Rpb25JbmRleCAhPT0gbnVsbClcbiAgICAgICAgdHgudHJhbnNhY3Rpb25JbmRleCA9IHV0aWxzLnRvRGVjaW1hbCh0eC50cmFuc2FjdGlvbkluZGV4KTtcbiAgICB0eC5ub25jZSA9IHV0aWxzLnRvRGVjaW1hbCh0eC5ub25jZSk7XG4gICAgdHguZ2FzID0gdXRpbHMudG9EZWNpbWFsKHR4Lmdhcyk7XG4gICAgdHguZ2FzUHJpY2UgPSB1dGlscy50b0JpZ051bWJlcih0eC5nYXNQcmljZSk7XG4gICAgdHgudmFsdWUgPSB1dGlscy50b0JpZ051bWJlcih0eC52YWx1ZSk7XG4gICAgcmV0dXJuIHR4O1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSB0cmFuc2FjdGlvbiByZWNlaXB0IHRvIGl0cyBwcm9wZXIgdmFsdWVzXG4gKlxuICogQG1ldGhvZCBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNlaXB0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbnZhciBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXIgPSBmdW5jdGlvbiAocmVjZWlwdCl7XG4gICAgaWYocmVjZWlwdC5ibG9ja051bWJlciAhPT0gbnVsbClcbiAgICAgICAgcmVjZWlwdC5ibG9ja051bWJlciA9IHV0aWxzLnRvRGVjaW1hbChyZWNlaXB0LmJsb2NrTnVtYmVyKTtcbiAgICBpZihyZWNlaXB0LnRyYW5zYWN0aW9uSW5kZXggIT09IG51bGwpXG4gICAgICAgIHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCA9IHV0aWxzLnRvRGVjaW1hbChyZWNlaXB0LnRyYW5zYWN0aW9uSW5kZXgpO1xuICAgIHJlY2VpcHQuY3VtdWxhdGl2ZUdhc1VzZWQgPSB1dGlscy50b0RlY2ltYWwocmVjZWlwdC5jdW11bGF0aXZlR2FzVXNlZCk7XG4gICAgcmVjZWlwdC5nYXNVc2VkID0gdXRpbHMudG9EZWNpbWFsKHJlY2VpcHQuZ2FzVXNlZCk7XG5cbiAgICBpZih1dGlscy5pc0FycmF5KHJlY2VpcHQubG9ncykpIHtcbiAgICAgICAgcmVjZWlwdC5sb2dzID0gcmVjZWlwdC5sb2dzLm1hcChmdW5jdGlvbihsb2cpe1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExvZ0Zvcm1hdHRlcihsb2cpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWlwdDtcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgYmxvY2sgdG8gaXRzIHByb3BlciB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kIG91dHB1dEJsb2NrRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gYmxvY2tcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4qL1xudmFyIG91dHB1dEJsb2NrRm9ybWF0dGVyID0gZnVuY3Rpb24oYmxvY2spIHtcblxuICAgIC8vIHRyYW5zZm9ybSB0byBudW1iZXJcbiAgICBibG9jay5nYXNMaW1pdCA9IHV0aWxzLnRvRGVjaW1hbChibG9jay5nYXNMaW1pdCk7XG4gICAgYmxvY2suZ2FzVXNlZCA9IHV0aWxzLnRvRGVjaW1hbChibG9jay5nYXNVc2VkKTtcbiAgICBibG9jay5zaXplID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLnNpemUpO1xuICAgIGJsb2NrLnRpbWVzdGFtcCA9IHV0aWxzLnRvRGVjaW1hbChibG9jay50aW1lc3RhbXApO1xuICAgIGlmKGJsb2NrLm51bWJlciAhPT0gbnVsbClcbiAgICAgICAgYmxvY2subnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLm51bWJlcik7XG5cbiAgICBibG9jay5kaWZmaWN1bHR5ID0gdXRpbHMudG9CaWdOdW1iZXIoYmxvY2suZGlmZmljdWx0eSk7XG4gICAgYmxvY2sudG90YWxEaWZmaWN1bHR5ID0gdXRpbHMudG9CaWdOdW1iZXIoYmxvY2sudG90YWxEaWZmaWN1bHR5KTtcblxuICAgIGlmICh1dGlscy5pc0FycmF5KGJsb2NrLnRyYW5zYWN0aW9ucykpIHtcbiAgICAgICAgYmxvY2sudHJhbnNhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICBpZighdXRpbHMuaXNTdHJpbmcoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIGxvZ1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0TG9nRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbG9nIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gbG9nXG4qL1xudmFyIG91dHB1dExvZ0Zvcm1hdHRlciA9IGZ1bmN0aW9uKGxvZykge1xuICAgIGlmKGxvZy5ibG9ja051bWJlcilcbiAgICAgICAgbG9nLmJsb2NrTnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKGxvZy5ibG9ja051bWJlcik7XG4gICAgaWYobG9nLnRyYW5zYWN0aW9uSW5kZXgpXG4gICAgICAgIGxvZy50cmFuc2FjdGlvbkluZGV4ID0gdXRpbHMudG9EZWNpbWFsKGxvZy50cmFuc2FjdGlvbkluZGV4KTtcbiAgICBpZihsb2cubG9nSW5kZXgpXG4gICAgICAgIGxvZy5sb2dJbmRleCA9IHV0aWxzLnRvRGVjaW1hbChsb2cubG9nSW5kZXgpO1xuXG4gICAgcmV0dXJuIGxvZztcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB3aGlzcGVyIHBvc3QgYW5kIGNvbnZlcnRzIGFsbCB2YWx1ZXMgdG8gSEVYXG4gKlxuICogQG1ldGhvZCBpbnB1dFBvc3RGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4qL1xudmFyIGlucHV0UG9zdEZvcm1hdHRlciA9IGZ1bmN0aW9uKHBvc3QpIHtcblxuICAgIC8vIHBvc3QucGF5bG9hZCA9IHV0aWxzLnRvSGV4KHBvc3QucGF5bG9hZCk7XG4gICAgcG9zdC50dGwgPSB1dGlscy5mcm9tRGVjaW1hbChwb3N0LnR0bCk7XG4gICAgcG9zdC53b3JrVG9Qcm92ZSA9IHV0aWxzLmZyb21EZWNpbWFsKHBvc3Qud29ya1RvUHJvdmUpO1xuICAgIHBvc3QucHJpb3JpdHkgPSB1dGlscy5mcm9tRGVjaW1hbChwb3N0LnByaW9yaXR5KTtcblxuICAgIC8vIGZhbGxiYWNrXG4gICAgaWYgKCF1dGlscy5pc0FycmF5KHBvc3QudG9waWNzKSkge1xuICAgICAgICBwb3N0LnRvcGljcyA9IHBvc3QudG9waWNzID8gW3Bvc3QudG9waWNzXSA6IFtdO1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCB0aGUgZm9sbG93aW5nIG9wdGlvbnNcbiAgICBwb3N0LnRvcGljcyA9IHBvc3QudG9waWNzLm1hcChmdW5jdGlvbih0b3BpYyl7XG4gICAgICAgIC8vIGNvbnZlcnQgb25seSBpZiBub3QgaGV4XG4gICAgICAgIHJldHVybiAodG9waWMuaW5kZXhPZignMHgnKSA9PT0gMCkgPyB0b3BpYyA6IHV0aWxzLmZyb21VdGY4KHRvcGljKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwb3N0O1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSByZWNlaXZlZCBwb3N0IG1lc3NhZ2VcbiAqXG4gKiBAbWV0aG9kIG91dHB1dFBvc3RGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xudmFyIG91dHB1dFBvc3RGb3JtYXR0ZXIgPSBmdW5jdGlvbihwb3N0KXtcblxuICAgIHBvc3QuZXhwaXJ5ID0gdXRpbHMudG9EZWNpbWFsKHBvc3QuZXhwaXJ5KTtcbiAgICBwb3N0LnNlbnQgPSB1dGlscy50b0RlY2ltYWwocG9zdC5zZW50KTtcbiAgICBwb3N0LnR0bCA9IHV0aWxzLnRvRGVjaW1hbChwb3N0LnR0bCk7XG4gICAgcG9zdC53b3JrUHJvdmVkID0gdXRpbHMudG9EZWNpbWFsKHBvc3Qud29ya1Byb3ZlZCk7XG4gICAgLy8gcG9zdC5wYXlsb2FkUmF3ID0gcG9zdC5wYXlsb2FkO1xuICAgIC8vIHBvc3QucGF5bG9hZCA9IHV0aWxzLnRvQXNjaWkocG9zdC5wYXlsb2FkKTtcblxuICAgIC8vIGlmICh1dGlscy5pc0pzb24ocG9zdC5wYXlsb2FkKSkge1xuICAgIC8vICAgICBwb3N0LnBheWxvYWQgPSBKU09OLnBhcnNlKHBvc3QucGF5bG9hZCk7XG4gICAgLy8gfVxuXG4gICAgLy8gZm9ybWF0IHRoZSBmb2xsb3dpbmcgb3B0aW9uc1xuICAgIGlmICghcG9zdC50b3BpY3MpIHtcbiAgICAgICAgcG9zdC50b3BpY3MgPSBbXTtcbiAgICB9XG4gICAgcG9zdC50b3BpY3MgPSBwb3N0LnRvcGljcy5tYXAoZnVuY3Rpb24odG9waWMpe1xuICAgICAgICByZXR1cm4gdXRpbHMudG9Bc2NpaSh0b3BpYyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcG9zdDtcbn07XG5cbnZhciBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHZhciBpYmFuID0gbmV3IEliYW4oYWRkcmVzcyk7XG4gICAgaWYgKGliYW4uaXNWYWxpZCgpICYmIGliYW4uaXNEaXJlY3QoKSkge1xuICAgICAgICByZXR1cm4gJzB4JyArIGliYW4uYWRkcmVzcygpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNTdHJpY3RBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgYWRkcmVzcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHJlc3MnKTtcbn07XG5cblxudmFyIG91dHB1dFN5bmNpbmdGb3JtYXR0ZXIgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5zdGFydGluZ0Jsb2NrID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5zdGFydGluZ0Jsb2NrKTtcbiAgICByZXN1bHQuY3VycmVudEJsb2NrID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5jdXJyZW50QmxvY2spO1xuICAgIHJlc3VsdC5oaWdoZXN0QmxvY2sgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0LmhpZ2hlc3RCbG9jayk7XG4gICAgaWYgKHJlc3VsdC5rbm93blN0YXRlcykge1xuICAgICAgICByZXN1bHQua25vd25TdGF0ZXMgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0Lmtub3duU3RhdGVzKTtcbiAgICAgICAgcmVzdWx0LnB1bGxlZFN0YXRlcyA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQucHVsbGVkU3RhdGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXI6IGlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyLFxuICAgIGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXI6IGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsXG4gICAgaW5wdXRDYWxsRm9ybWF0dGVyOiBpbnB1dENhbGxGb3JtYXR0ZXIsXG4gICAgaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcjogaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcixcbiAgICBpbnB1dEFkZHJlc3NGb3JtYXR0ZXI6IGlucHV0QWRkcmVzc0Zvcm1hdHRlcixcbiAgICBpbnB1dFBvc3RGb3JtYXR0ZXI6IGlucHV0UG9zdEZvcm1hdHRlcixcbiAgICBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXI6IG91dHB1dEJpZ051bWJlckZvcm1hdHRlcixcbiAgICBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcjogb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIsXG4gICAgb3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyOiBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXIsXG4gICAgb3V0cHV0QmxvY2tGb3JtYXR0ZXI6IG91dHB1dEJsb2NrRm9ybWF0dGVyLFxuICAgIG91dHB1dExvZ0Zvcm1hdHRlcjogb3V0cHV0TG9nRm9ybWF0dGVyLFxuICAgIG91dHB1dFBvc3RGb3JtYXR0ZXI6IG91dHB1dFBvc3RGb3JtYXR0ZXIsXG4gICAgb3V0cHV0U3luY2luZ0Zvcm1hdHRlcjogb3V0cHV0U3luY2luZ0Zvcm1hdHRlclxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZm9ybWF0dGVycy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZm9ybWF0dGVycy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmdW5jdGlvbi5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNhbGwvc2VuZFRyYW5zYWN0aW9uIHRvIHNvbGlkaXR5IGZ1bmN0aW9uc1xuICovXG52YXIgU29saWRpdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIChldGgsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9ldGggPSBldGg7XG4gICAgdGhpcy5faW5wdXRUeXBlcyA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX291dHB1dFR5cGVzID0ganNvbi5vdXRwdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX2NvbnN0YW50ID0ganNvbi5jb25zdGFudDtcbiAgICB0aGlzLl9wYXlhYmxlID0ganNvbi5wYXlhYmxlO1xuICAgIHRoaXMuX25hbWUgPSB1dGlscy50cmFuc2Zvcm1Ub0Z1bGxOYW1lKGpzb24pO1xuICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xufTtcblxuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcblxuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZXh0cmFjdERlZmF1bHRCbG9jayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gdGhpcy5faW5wdXRUeXBlcy5sZW5ndGggJiYgIXV0aWxzLmlzT2JqZWN0KGFyZ3NbYXJncy5sZW5ndGggLTFdKSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcihhcmdzLnBvcCgpKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBjb3JyZWN0XG4gKlxuICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIG5vdFxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS52YWxpZGF0ZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBpbnB1dEFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgLy8gZmlsdGVyIHRoZSBvcHRpb25zIG9iamVjdCBidXQgbm90IGFyZ3VtZW50cyB0aGF0IGFyZSBhcnJheXNcbiAgICAgIHJldHVybiAhKCAodXRpbHMuaXNPYmplY3QoYSkgPT09IHRydWUpICYmXG4gICAgICAgICAgICAgICAgKHV0aWxzLmlzQXJyYXkoYSkgPT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICAgICh1dGlscy5pc0JpZ051bWJlcihhKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKGlucHV0QXJncy5sZW5ndGggIT09IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3MoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBwYXlsb2FkIGZyb20gYXJndW1lbnRzXG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IHNvbGlkaXR5IGZ1bmN0aW9uIHBhcmFtc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbmFsIHBheWxvYWQgb3B0aW9uc1xuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS50b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gdGhpcy5faW5wdXRUeXBlcy5sZW5ndGggJiYgdXRpbHMuaXNPYmplY3QoYXJnc1thcmdzLmxlbmd0aCAtMV0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVBcmdzKGFyZ3MpO1xuICAgIG9wdGlvbnMudG8gPSB0aGlzLl9hZGRyZXNzO1xuICAgIG9wdGlvbnMuZGF0YSA9ICcweCcgKyB0aGlzLnNpZ25hdHVyZSgpICsgY29kZXIuZW5jb2RlUGFyYW1zKHRoaXMuX2lucHV0VHlwZXMsIGFyZ3MpO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKlxuICogQG1ldGhvZCBzaWduYXR1cmVcbiAqIEByZXR1cm4ge1N0cmluZ30gZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnNpZ25hdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2hhMyh0aGlzLl9uYW1lKS5zbGljZSgwLCA4KTtcbn07XG5cblxuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudW5wYWNrT3V0cHV0ID0gZnVuY3Rpb24gKG91dHB1dCkge1xuICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvdXRwdXQgPSBvdXRwdXQubGVuZ3RoID49IDIgPyBvdXRwdXQuc2xpY2UoMikgOiBvdXRwdXQ7XG4gICAgdmFyIHJlc3VsdCA9IGNvZGVyLmRlY29kZVBhcmFtcyh0aGlzLl9vdXRwdXRUeXBlcywgb3V0cHV0KTtcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBjb250cmFjdCBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGNhbGxcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBDb250cmFjdCBmdW5jdGlvbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IElmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIHRoZSBjb250cmFjdCBmdW5jdGlvblxuICogICBjYWxsIHdpbGwgYmUgYXN5bmNocm9ub3VzLCBhbmQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgcGFzc2VkIHRoZVxuICogICBlcnJvciBhbmQgcmVzdWx0LlxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXQgYnl0ZXNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChhKSB7cmV0dXJuIGEgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIGRlZmF1bHRCbG9jayA9IHRoaXMuZXh0cmFjdERlZmF1bHRCbG9jayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9ldGguY2FsbChwYXlsb2FkLCBkZWZhdWx0QmxvY2spO1xuICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tPdXRwdXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fZXRoLmNhbGwocGF5bG9hZCwgZGVmYXVsdEJsb2NrLCBmdW5jdGlvbiAoZXJyb3IsIG91dHB1dCkge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG5cbiAgICAgICAgdmFyIHVucGFja2VkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVucGFja2VkID0gc2VsZi51bnBhY2tPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHVucGFja2VkKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc2VuZFRyYW5zYWN0aW9uIHRvIHNvbGlkaXR5IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBzZW5kVHJhbnNhY3Rpb25cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtyZXR1cm4gYSAhPT0gdW5kZWZpbmVkOyB9KTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgaWYgKHBheWxvYWQudmFsdWUgPiAwICYmICF0aGlzLl9wYXlhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2V0aC5zZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlc3RpbWF0ZUdhcyBvZiBzb2xpZGl0eSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgZXN0aW1hdGVHYXNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZXN0aW1hdGVHYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy50b1BheWxvYWQoYXJncyk7XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGguZXN0aW1hdGVHYXMocGF5bG9hZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXRoLmVzdGltYXRlR2FzKHBheWxvYWQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBlbmNvZGVkIGRhdGEgb2YgdGhlIGNhbGxcbiAqXG4gKiBAbWV0aG9kIGdldERhdGFcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGVuY29kZWQgZGF0YVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZ1bmN0aW9uIGRpc3BsYXkgbmFtZVxuICpcbiAqIEBtZXRob2QgZGlzcGxheU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZGlzcGxheSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZnVuY3Rpb24gdHlwZSBuYW1lXG4gKlxuICogQG1ldGhvZCB0eXBlTmFtZVxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5leHRyYWN0VHlwZU5hbWUodGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHJwYyByZXF1ZXN0cyBmcm9tIHNvbGlkaXR5IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnVucGFja091dHB1dC5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLl9jb25zdGFudCA/ICdldGhfY2FsbCcgOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcGFyYW1zOiBbcGF5bG9hZF0sXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgfTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBleGVjdXRlIGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBleGVjdXRlXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uID0gIXRoaXMuX2NvbnN0YW50O1xuXG4gICAgLy8gc2VuZCB0cmFuc2FjdGlvblxuICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgLy8gY2FsbFxuICAgIHJldHVybiB0aGlzLmNhbGwuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gYXR0YWNoIGZ1bmN0aW9uIHRvIGNvbnRyYWN0XG4gKlxuICogQG1ldGhvZCBhdHRhY2hUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV4ZWN1dGUgPSB0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmNhbGwgPSB0aGlzLmNhbGwuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLnNlbmRUcmFuc2FjdGlvbiA9IHRoaXMuc2VuZFRyYW5zYWN0aW9uLmJpbmQodGhpcyk7XG4gICAgZXhlY3V0ZS5lc3RpbWF0ZUdhcyA9IHRoaXMuZXN0aW1hdGVHYXMuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmdldERhdGEgPSB0aGlzLmdldERhdGEuYmluZCh0aGlzKTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lKCk7XG4gICAgaWYgKCFjb250cmFjdFtkaXNwbGF5TmFtZV0pIHtcbiAgICAgICAgY29udHJhY3RbZGlzcGxheU5hbWVdID0gZXhlY3V0ZTtcbiAgICB9XG4gICAgY29udHJhY3RbZGlzcGxheU5hbWVdW3RoaXMudHlwZU5hbWUoKV0gPSBleGVjdXRlOyAvLyBjaXJjdWxhciEhISFcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlGdW5jdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Z1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGh0dHBwcm92aWRlci5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBNYXJpYW4gT2FuY2VhIDxtYXJpYW5AZXRoZGV2LmNvbT5cbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbi8vIHdvcmthcm91bmQgdG8gdXNlIGh0dHBwcm92aWRlciBpbiBkaWZmZXJlbnQgZW52c1xuXG4vLyBicm93c2VyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gIFhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0OyAvLyBqc2hpbnQgaWdub3JlOiBsaW5lXG4vLyBub2RlXG59IGVsc2Uge1xuICBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0JykuWE1MSHR0cFJlcXVlc3Q7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcbn1cblxudmFyIFhIUjIgPSByZXF1aXJlKCd4aHIyJyk7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcblxuLyoqXG4gKiBIdHRwUHJvdmlkZXIgc2hvdWxkIGJlIHVzZWQgdG8gc2VuZCBycGMgY2FsbHMgb3ZlciBodHRwXG4gKi9cbnZhciBIdHRwUHJvdmlkZXIgPSBmdW5jdGlvbiAoaG9zdCwgdGltZW91dCwgdXNlciwgcGFzc3dvcmQpIHtcbiAgdGhpcy5ob3N0ID0gaG9zdCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JztcbiAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCAwO1xuICB0aGlzLnVzZXIgPSB1c2VyO1xuICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcHJlcGFyZSBuZXcgWE1MSHR0cFJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHByZXBhcmVSZXF1ZXN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUgaWYgcmVxdWVzdCBzaG91bGQgYmUgYXN5bmNcbiAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fSBvYmplY3RcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5wcmVwYXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChhc3luYykge1xuICB2YXIgcmVxdWVzdDtcblxuICBpZiAoYXN5bmMpIHtcbiAgICByZXF1ZXN0ID0gbmV3IFhIUjIoKTtcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG5cbiAgcmVxdWVzdC5vcGVuKCdQT1NUJywgdGhpcy5ob3N0LCBhc3luYyk7XG4gIGlmICh0aGlzLnVzZXIgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgIHZhciBhdXRoID0gJ0Jhc2ljICcgKyBuZXcgQnVmZmVyKHRoaXMudXNlciArICc6JyArIHRoaXMucGFzc3dvcmQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBhdXRoKTtcbiAgfSByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIHJldHVybiByZXF1ZXN0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3luYyByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgdmFyIHJlcXVlc3QgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KGZhbHNlKTtcblxuICB0cnkge1xuICAgIHJlcXVlc3Quc2VuZChKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKHRoaXMuaG9zdCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZEFzeW5jXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGVuZCB3aXRoIChlcnIsIHJlc3VsdClcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgdmFyIHJlcXVlc3QgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KHRydWUpO1xuXG4gIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgJiYgcmVxdWVzdC50aW1lb3V0ICE9PSAxKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gICAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yID0gZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhlcnJvcnMuQ29ubmVjdGlvblRpbWVvdXQodGhpcy50aW1lb3V0KSk7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0LnNlbmQoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHRyaWVzIHRvIG1ha2UgSHR0cCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBpc0Nvbm5lY3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHJlcXVlc3QgaGF2ZW4ndCBmYWlsZWQuIE90aGVyd2lzZSBmYWxzZVxuICovXG5IdHRwUHJvdmlkZXIucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHRoaXMuc2VuZCh7XG4gICAgICBpZDogOTk5OTk5OTk5OSxcbiAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgbWV0aG9kOiAnbmV0X2xpc3RlbmluZycsXG4gICAgICBwYXJhbXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHR0cFByb3ZpZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaHR0cHByb3ZpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9odHRwcHJvdmlkZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGliYW4uanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuXG52YXIgcGFkTGVmdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGJ5dGVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHN0cmluZztcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGJ5dGVzICogMikge1xuICAgICAgICByZXN1bHQgPSAnMCcgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgYW4gSUJBTiBmb3IgbW9kIDk3IGNvbXB1dGF0aW9uIGJ5IG1vdmluZyB0aGUgZmlyc3QgNCBjaGFycyB0byB0aGUgZW5kIGFuZCB0cmFuc2Zvcm1pbmcgdGhlIGxldHRlcnMgdG9cbiAqIG51bWJlcnMgKEEgPSAxMCwgQiA9IDExLCAuLi4sIFogPSAzNSksIGFzIHNwZWNpZmllZCBpbiBJU08xMzYxNi5cbiAqXG4gKiBAbWV0aG9kIGlzbzEzNjE2UHJlcGFyZVxuICogQHBhcmFtIHtTdHJpbmd9IGliYW4gdGhlIElCQU5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBwcmVwYXJlZCBJQkFOXG4gKi9cbnZhciBpc28xMzYxNlByZXBhcmUgPSBmdW5jdGlvbiAoaWJhbikge1xuICAgIHZhciBBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIFogPSAnWicuY2hhckNvZGVBdCgwKTtcblxuICAgIGliYW4gPSBpYmFuLnRvVXBwZXJDYXNlKCk7XG4gICAgaWJhbiA9IGliYW4uc3Vic3RyKDQpICsgaWJhbi5zdWJzdHIoMCw0KTtcblxuICAgIHJldHVybiBpYmFuLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24obil7XG4gICAgICAgIHZhciBjb2RlID0gbi5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAoY29kZSA+PSBBICYmIGNvZGUgPD0gWil7XG4gICAgICAgICAgICAvLyBBID0gMTAsIEIgPSAxMSwgLi4uIFogPSAzNVxuICAgICAgICAgICAgcmV0dXJuIGNvZGUgLSBBICsgMTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBNT0QgOTcgMTAgb2YgdGhlIHBhc3NlZCBJQkFOIGFzIHNwZWNpZmllZCBpbiBJU083MDY0LlxuICpcbiAqIEBtZXRob2QgbW9kOTcxMFxuICogQHBhcmFtIHtTdHJpbmd9IGliYW5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbnZhciBtb2Q5NzEwID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICB2YXIgcmVtYWluZGVyID0gaWJhbixcbiAgICAgICAgYmxvY2s7XG5cbiAgICB3aGlsZSAocmVtYWluZGVyLmxlbmd0aCA+IDIpe1xuICAgICAgICBibG9jayA9IHJlbWFpbmRlci5zbGljZSgwLCA5KTtcbiAgICAgICAgcmVtYWluZGVyID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgcmVtYWluZGVyLnNsaWNlKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlSW50KHJlbWFpbmRlciwgMTApICUgOTc7XG59O1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBpYmFuIG9iamVjdCBmcm9tIGliYW4gY29ycmVjdCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhblxuICovXG52YXIgSWJhbiA9IGZ1bmN0aW9uIChpYmFuKSB7XG4gICAgdGhpcy5faWJhbiA9IGliYW47XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBpYmFuIG9iamVjdCBmcm9tIGV0aGVyZXVtIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGZyb21BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7SWJhbn0gdGhlIElCQU4gb2JqZWN0XG4gKi9cbkliYW4uZnJvbUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHZhciBhc0JuID0gbmV3IEJpZ051bWJlcihhZGRyZXNzLCAxNik7XG4gICAgdmFyIGJhc2UzNiA9IGFzQm4udG9TdHJpbmcoMzYpO1xuICAgIHZhciBwYWRkZWQgPSBwYWRMZWZ0KGJhc2UzNiwgMTUpO1xuICAgIHJldHVybiBJYmFuLmZyb21CYmFuKHBhZGRlZC50b1VwcGVyQ2FzZSgpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcGFzc2VkIEJCQU4gdG8gYW4gSUJBTiBmb3IgdGhpcyBjb3VudHJ5IHNwZWNpZmljYXRpb24uXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IDxpPlwiZ2VuZXJhdGlvbiBvZiB0aGUgSUJBTiBzaGFsbCBiZSB0aGUgZXhjbHVzaXZlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBiYW5rL2JyYW5jaCBzZXJ2aWNpbmcgdGhlIGFjY291bnRcIjwvaT4uXG4gKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBwcmVmZXJyZWQgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlciNHZW5lcmF0aW5nX0lCQU5fY2hlY2tfZGlnaXRzXG4gKlxuICogQG1ldGhvZCBmcm9tQmJhblxuICogQHBhcmFtIHtTdHJpbmd9IGJiYW4gdGhlIEJCQU4gdG8gY29udmVydCB0byBJQkFOXG4gKiBAcmV0dXJucyB7SWJhbn0gdGhlIElCQU4gb2JqZWN0XG4gKi9cbkliYW4uZnJvbUJiYW4gPSBmdW5jdGlvbiAoYmJhbikge1xuICAgIHZhciBjb3VudHJ5Q29kZSA9ICdYRSc7XG5cbiAgICB2YXIgcmVtYWluZGVyID0gbW9kOTcxMChpc28xMzYxNlByZXBhcmUoY291bnRyeUNvZGUgKyAnMDAnICsgYmJhbikpO1xuICAgIHZhciBjaGVja0RpZ2l0ID0gKCcwJyArICg5OCAtIHJlbWFpbmRlcikpLnNsaWNlKC0yKTtcblxuICAgIHJldHVybiBuZXcgSWJhbihjb3VudHJ5Q29kZSArIGNoZWNrRGlnaXQgKyBiYmFuKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIElCQU4gb2JqZWN0IGZvciBnaXZlbiBpbnN0aXR1dGlvbiBhbmQgaWRlbnRpZmllclxuICpcbiAqIEBtZXRob2QgY3JlYXRlSW5kaXJlY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLCByZXF1aXJlZCBvcHRpb25zIGFyZSBcImluc3RpdHV0aW9uXCIgYW5kIFwiaWRlbnRpZmllclwiXG4gKiBAcmV0dXJuIHtJYmFufSB0aGUgSUJBTiBvYmplY3RcbiAqL1xuSWJhbi5jcmVhdGVJbmRpcmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEliYW4uZnJvbUJiYW4oJ0VUSCcgKyBvcHRpb25zLmluc3RpdHV0aW9uICsgb3B0aW9ucy5pZGVudGlmaWVyKTtcbn07XG5cbi8qKlxuICogVGhvcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gY2hlY2sgaWYgZ2l2ZW4gc3RyaW5nIGlzIHZhbGlkIGliYW4gb2JqZWN0XG4gKlxuICogQG1ldGhvZCBpc1ZhbGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhbiBzdHJpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMgdmFsaWQgSUJBTlxuICovXG5JYmFuLmlzVmFsaWQgPSBmdW5jdGlvbiAoaWJhbikge1xuICAgIHZhciBpID0gbmV3IEliYW4oaWJhbik7XG4gICAgcmV0dXJuIGkuaXNWYWxpZCgpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIGliYW4gaXMgY29ycmVjdFxuICpcbiAqIEBtZXRob2QgaXNWYWxpZFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5JYmFuLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvXlhFWzAtOV17Mn0oRVRIWzAtOUEtWl17MTN9fFswLTlBLVpdezMwLDMxfSkkLy50ZXN0KHRoaXMuX2liYW4pICYmXG4gICAgICAgIG1vZDk3MTAoaXNvMTM2MTZQcmVwYXJlKHRoaXMuX2liYW4pKSA9PT0gMTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIG51bWJlciBpcyBkaXJlY3RcbiAqXG4gKiBAbWV0aG9kIGlzRGlyZWN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbkliYW4ucHJvdG90eXBlLmlzRGlyZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pYmFuLmxlbmd0aCA9PT0gMzQgfHwgdGhpcy5faWJhbi5sZW5ndGggPT09IDM1O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIGliYW4gbnVtYmVyIGlmIGluZGlyZWN0XG4gKlxuICogQG1ldGhvZCBpc0luZGlyZWN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbkliYW4ucHJvdG90eXBlLmlzSW5kaXJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2liYW4ubGVuZ3RoID09PSAyMDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaWJhbiBjaGVja3N1bVxuICogVXNlcyB0aGUgbW9kLTk3LTEwIGNoZWNrc3VtbWluZyBwcm90b2NvbCAoSVNPL0lFQyA3MDY0OjIwMDMpXG4gKlxuICogQG1ldGhvZCBjaGVja3N1bVxuICogQHJldHVybnMge1N0cmluZ30gY2hlY2tzdW1cbiAqL1xuSWJhbi5wcm90b3R5cGUuY2hlY2tzdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2liYW4uc3Vic3RyKDIsIDIpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBpbnN0aXR1dGlvbiBpZGVudGlmaWVyXG4gKiBlZy4gWFJFR1xuICpcbiAqIEBtZXRob2QgaW5zdGl0dXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGluc3RpdHV0aW9uIGlkZW50aWZpZXJcbiAqL1xuSWJhbi5wcm90b3R5cGUuaW5zdGl0dXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpID8gdGhpcy5faWJhbi5zdWJzdHIoNywgNCkgOiAnJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgY2xpZW50IGlkZW50aWZpZXIgd2l0aGluIGluc3RpdHV0aW9uXG4gKiBlZy4gR0FWT0ZZT1JLXG4gKlxuICogQG1ldGhvZCBjbGllbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGNsaWVudCBpZGVudGlmaWVyXG4gKi9cbkliYW4ucHJvdG90eXBlLmNsaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luZGlyZWN0KCkgPyB0aGlzLl9pYmFuLnN1YnN0cigxMSkgOiAnJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgY2xpZW50IGRpcmVjdCBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBhZGRyZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBjbGllbnQgZGlyZWN0IGFkZHJlc3NcbiAqL1xuSWJhbi5wcm90b3R5cGUuYWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0RpcmVjdCgpKSB7XG4gICAgICAgIHZhciBiYXNlMzYgPSB0aGlzLl9pYmFuLnN1YnN0cig0KTtcbiAgICAgICAgdmFyIGFzQm4gPSBuZXcgQmlnTnVtYmVyKGJhc2UzNiwgMzYpO1xuICAgICAgICByZXR1cm4gcGFkTGVmdChhc0JuLnRvU3RyaW5nKDE2KSwgMjApO1xuICAgIH0gXG5cbiAgICByZXR1cm4gJyc7XG59O1xuXG5JYmFuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWJhbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWJhbjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaWJhbi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaWJhbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGlwY3Byb3ZpZGVyLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuXG52YXIgSXBjUHJvdmlkZXIgPSBmdW5jdGlvbiAocGF0aCwgbmV0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICBcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXQuY29ubmVjdCh7cGF0aDogdGhpcy5wYXRofSk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0lQQyBDb25uZWN0aW9uIEVycm9yJywgZSk7XG4gICAgICAgIF90aGlzLl90aW1lb3V0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIF90aGlzLl90aW1lb3V0KCk7XG4gICAgfSk7IFxuXG5cbiAgICAvLyBMSVNURU4gRk9SIENPTk5FQ1RJT04gUkVTUE9OU0VTXG4gICAgdGhpcy5jb25uZWN0aW9uLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA2ICovXG5cbiAgICAgICAgX3RoaXMuX3BhcnNlUmVzcG9uc2UoZGF0YS50b1N0cmluZygpKS5mb3JFYWNoKGZ1bmN0aW9uKHJlc3VsdCl7XG5cbiAgICAgICAgICAgIHZhciBpZCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgaWQgd2hpY2ggbWF0Y2hlcyB0aGUgcmV0dXJuZWQgaWRcbiAgICAgICAgICAgIGlmKHV0aWxzLmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uKGxvYWQpe1xuICAgICAgICAgICAgICAgICAgICBpZihfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tsb2FkLmlkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gbG9hZC5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWQgPSByZXN1bHQuaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICBpZihfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0obnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuV2lsbCBwYXJzZSB0aGUgcmVzcG9uc2UgYW5kIG1ha2UgYW4gYXJyYXkgb3V0IG9mIGl0LlxuXG5AbWV0aG9kIF9wYXJzZVJlc3BvbnNlXG5AcGFyYW0ge1N0cmluZ30gZGF0YVxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICByZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICBcbiAgICAvLyBERS1DSFVOS0VSXG4gICAgdmFyIGRlY2h1bmtlZERhdGEgPSBkYXRhXG4gICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXHsvZywnfXwtLXx7JykgLy8gfXtcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcW1xcey9nLCd9XXwtLXxbeycpIC8vIH1dW3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcW1xcey9nLCd9fC0tfFt7JykgLy8gfVt7XG4gICAgICAgIC5yZXBsYWNlKC9cXH1cXF1bXFxuXFxyXT9cXHsvZywnfV18LS18eycpIC8vIH1de1xuICAgICAgICAuc3BsaXQoJ3wtLXwnKTtcblxuICAgIGRlY2h1bmtlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhKXtcblxuICAgICAgICAvLyBwcmVwZW5kIHRoZSBsYXN0IGNodW5rXG4gICAgICAgIGlmKF90aGlzLmxhc3RDaHVuaylcbiAgICAgICAgICAgIGRhdGEgPSBfdGhpcy5sYXN0Q2h1bmsgKyBkYXRhO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAgIH0gY2F0Y2goZSkge1xuXG4gICAgICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBkYXRhO1xuXG4gICAgICAgICAgICAvLyBzdGFydCB0aW1lb3V0IHRvIGNhbmNlbCBhbGwgcmVxdWVzdHNcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVua1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKGRhdGEpO1xuICAgICAgICAgICAgfSwgMTAwMCAqIDE1KTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FuY2VsIHRpbWVvdXQgYW5kIHNldCBjaHVuayB0byBudWxsXG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgX3RoaXMubGFzdENodW5rID0gbnVsbDtcblxuICAgICAgICBpZihyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm5WYWx1ZXMucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbn07XG5cblxuLyoqXG5HZXQgdGhlIGFkZHMgYSBjYWxsYmFjayB0byB0aGUgcmVzcG9uc2VDYWxsYmFja3Mgb2JqZWN0LFxud2hpY2ggd2lsbCBiZSBjYWxsZWQgaWYgYSByZXNwb25zZSBtYXRjaGluZyB0aGUgcmVzcG9uc2UgSWQgd2lsbCBhcnJpdmUuXG5cbkBtZXRob2QgX2FkZFJlc3BvbnNlQ2FsbGJhY2tcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuX2FkZFJlc3BvbnNlQ2FsbGJhY2sgPSBmdW5jdGlvbihwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IHBheWxvYWQuaWQgfHwgcGF5bG9hZFswXS5pZDtcbiAgICB2YXIgbWV0aG9kID0gcGF5bG9hZC5tZXRob2QgfHwgcGF5bG9hZFswXS5tZXRob2Q7XG5cbiAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdLm1ldGhvZCA9IG1ldGhvZDtcbn07XG5cbi8qKlxuVGltZW91dCBhbGwgcmVxdWVzdHMgd2hlbiB0aGUgZW5kL2Vycm9yIGV2ZW50IGlzIGZpcmVkXG5cbkBtZXRob2QgX3RpbWVvdXRcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuX3RpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIGtleSBpbiB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzKSB7XG4gICAgICAgIGlmKHRoaXMucmVzcG9uc2VDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2tleV0oZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKCdvbiBJUEMnKSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1trZXldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbkNoZWNrIGlmIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gaXMgc3RpbGwgdmFsaWQuXG5cbkBtZXRob2QgaXNDb25uZWN0ZWRcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICBpZighX3RoaXMuY29ubmVjdGlvbi53cml0YWJsZSlcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOiBfdGhpcy5wYXRofSk7XG5cbiAgICByZXR1cm4gISF0aGlzLmNvbm5lY3Rpb24ud3JpdGFibGU7XG59O1xuXG5JcGNQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG5cbiAgICBpZih0aGlzLmNvbm5lY3Rpb24ud3JpdGVTeW5jKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICAgICAgaWYoIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZSlcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOiB0aGlzLnBhdGh9KTtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UoZGF0YSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHRyaWVkIHRvIHNlbmQgXCInKyBwYXlsb2FkLm1ldGhvZCArJ1wiIHN5bmNocm9ub3VzbHkuIFN5bmNocm9ub3VzIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUEMgcHJvdmlkZXIuJyk7XG4gICAgfVxufTtcblxuSXBjUHJvdmlkZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIC8vIHRyeSByZWNvbm5lY3QsIHdoZW4gY29ubmVjdGlvbiBpcyBnb25lXG4gICAgaWYoIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZSlcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IHRoaXMucGF0aH0pO1xuXG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ud3JpdGUoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgIHRoaXMuX2FkZFJlc3BvbnNlQ2FsbGJhY2socGF5bG9hZCwgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJcGNQcm92aWRlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaXBjcHJvdmlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2lwY3Byb3ZpZGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUganNvbnJwYy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBBYXJvbiBLdW1hdmlzIDxhYXJvbkBrdW1hdmlzLm1lPlxuICogQGRhdGUgMjAxNVxuICovXG5cbi8vIEluaXRpYWxpemUgSnNvbnJwYyBhcyBhIHNpbXBsZSBvYmplY3Qgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucy5cbnZhciBKc29ucnBjID0ge1xuICAgIG1lc3NhZ2VJZDogMFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHZhbGlkIGpzb24gY3JlYXRlIHBheWxvYWQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBvZiBqc29ucnBjIGNhbGwsIHJlcXVpcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMsIGFuIGFycmF5IG9mIG1ldGhvZCBwYXJhbXMsIG9wdGlvbmFsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWxpZCBqc29ucnBjIHBheWxvYWQgb2JqZWN0XG4gKi9cbkpzb25ycGMudG9QYXlsb2FkID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgaWYgKCFtZXRob2QpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzb25ycGMgbWV0aG9kIHNob3VsZCBiZSBzcGVjaWZpZWQhJyk7XG5cbiAgICAvLyBhZHZhbmNlIG1lc3NhZ2UgSURcbiAgICBKc29ucnBjLm1lc3NhZ2VJZCsrO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGlkOiBKc29ucnBjLm1lc3NhZ2VJZCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHBhcmFtczogcGFyYW1zIHx8IFtdXG4gICAgfTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBqc29ucnBjIHJlc3BvbnNlIGlzIHZhbGlkXG4gKlxuICogQG1ldGhvZCBpc1ZhbGlkUmVzcG9uc2VcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgcmVzcG9uc2UgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5Kc29ucnBjLmlzVmFsaWRSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSA/IHJlc3BvbnNlLmV2ZXJ5KHZhbGlkYXRlU2luZ2xlTWVzc2FnZSkgOiB2YWxpZGF0ZVNpbmdsZU1lc3NhZ2UocmVzcG9uc2UpO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTaW5nbGVNZXNzYWdlKG1lc3NhZ2Upe1xuICAgICAgcmV0dXJuICEhbWVzc2FnZSAmJlxuICAgICAgICAhbWVzc2FnZS5lcnJvciAmJlxuICAgICAgICBtZXNzYWdlLmpzb25ycGMgPT09ICcyLjAnICYmXG4gICAgICAgIHR5cGVvZiBtZXNzYWdlLmlkID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkOyAvLyBvbmx5IHVuZGVmaW5lZCBpcyBub3QgdmFsaWQganNvbiBvYmplY3RcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIGJhdGNoIHBheWxvYWQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCB0b0JhdGNoUGF5bG9hZFxuICogQHBhcmFtIHtBcnJheX0gbWVzc2FnZXMsIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBtZXRob2QgKHJlcXVpcmVkKSBhbmQgcGFyYW1zIChvcHRpb25hbCkgZmllbGRzXG4gKiBAcmV0dXJucyB7QXJyYXl9IGJhdGNoIHBheWxvYWRcbiAqL1xuSnNvbnJwYy50b0JhdGNoUGF5bG9hZCA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIEpzb25ycGMudG9QYXlsb2FkKG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25ycGM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2pzb25ycGMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2pzb25ycGMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgbWV0aG9kLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxudmFyIE1ldGhvZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuY2FsbCA9IG9wdGlvbnMuY2FsbDtcbiAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zIHx8IDA7XG4gICAgdGhpcy5pbnB1dEZvcm1hdHRlciA9IG9wdGlvbnMuaW5wdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5vdXRwdXRGb3JtYXR0ZXIgPSBvcHRpb25zLm91dHB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gbnVsbDtcbn07XG5cbk1ldGhvZC5wcm90b3R5cGUuc2V0UmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocm0pIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcm07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBuYW1lIG9mIHRoZSBqc29ucnBjIG1ldGhvZCBiYXNlZCBvbiBhcmd1bWVudHNcbiAqXG4gKiBAbWV0aG9kIGdldENhbGxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7U3RyaW5nfSBuYW1lIG9mIGpzb25ycGMgbWV0aG9kXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZ2V0Q2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzRnVuY3Rpb24odGhpcy5jYWxsKSA/IHRoaXMuY2FsbChhcmdzKSA6IHRoaXMuY2FsbDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZXh0cmFjdCBjYWxsYmFjayBmcm9tIGFycmF5IG9mIGFyZ3VtZW50cy4gTW9kaWZpZXMgaW5wdXQgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3RDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxOdWxsfSBjYWxsYmFjaywgaWYgZXhpc3RzXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGlzIGNvcnJlY3RcbiAqIFxuICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIG5vdFxuICovXG5NZXRob2QucHJvdG90eXBlLnZhbGlkYXRlQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSB0aGlzLnBhcmFtcykge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZE51bWJlck9mUlBDUGFyYW1zKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBpbnB1dCBhcmdzIG9mIG1ldGhvZFxuICogXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0XG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0SW5wdXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICghdGhpcy5pbnB1dEZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnB1dEZvcm1hdHRlci5tYXAoZnVuY3Rpb24gKGZvcm1hdHRlciwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlcihhcmdzW2luZGV4XSkgOiBhcmdzW2luZGV4XTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgb3V0cHV0KHJlc3VsdCkgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5NZXRob2QucHJvdG90eXBlLmZvcm1hdE91dHB1dCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzdWx0ID8gdGhpcy5vdXRwdXRGb3JtYXR0ZXIocmVzdWx0KSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBwYXlsb2FkIGZyb20gZ2l2ZW4gaW5wdXQgYXJnc1xuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9QYXlsb2FkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgY2FsbCA9IHRoaXMuZ2V0Q2FsbChhcmdzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5mb3JtYXRJbnB1dChhcmdzKTtcbiAgICB0aGlzLnZhbGlkYXRlQXJncyhwYXJhbXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiBjYWxsLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfTtcbn07XG5cbk1ldGhvZC5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGZ1bmMgPSB0aGlzLmJ1aWxkQ2FsbCgpO1xuICAgIGZ1bmMuY2FsbCA9IHRoaXMuY2FsbDsgLy8gVE9ETyEhISB0aGF0J3MgdWdseS4gZmlsdGVyLmpzIHVzZXMgaXRcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZS5zcGxpdCgnLicpO1xuICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gb2JqW25hbWVbMF1dIHx8IHt9O1xuICAgICAgICBvYmpbbmFtZVswXV1bbmFtZVsxXV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtuYW1lWzBdXSA9IGZ1bmM7IFxuICAgIH1cbn07XG5cbk1ldGhvZC5wcm90b3R5cGUuYnVpbGRDYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXM7XG4gICAgdmFyIHNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbWV0aG9kLnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHBheWxvYWQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QucmVxdWVzdE1hbmFnZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2soZXJyLCBtZXRob2QuZm9ybWF0T3V0cHV0KHJlc3VsdCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5mb3JtYXRPdXRwdXQobWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmQocGF5bG9hZCkpO1xuICAgIH07XG4gICAgc2VuZC5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHNlbmQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIHB1cmUgSlNPTlJQQyByZXF1ZXN0IHdoaWNoIGNhbiBiZSB1c2VkIGluIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RcbiAqIEBwYXJhbSB7Li4ufSBwYXJhbXNcbiAqIEByZXR1cm4ge09iamVjdH0ganNvbnJwYyByZXF1ZXN0XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHBheWxvYWQuZm9ybWF0ID0gdGhpcy5mb3JtYXRPdXRwdXQuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBkYi5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcblxudmFyIERCID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIG1ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkgeyBcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufTtcblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHB1dFN0cmluZyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncHV0U3RyaW5nJyxcbiAgICAgICAgY2FsbDogJ2RiX3B1dFN0cmluZycsXG4gICAgICAgIHBhcmFtczogM1xuICAgIH0pO1xuXG4gICAgdmFyIGdldFN0cmluZyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0U3RyaW5nJyxcbiAgICAgICAgY2FsbDogJ2RiX2dldFN0cmluZycsXG4gICAgICAgIHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgdmFyIHB1dEhleCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncHV0SGV4JyxcbiAgICAgICAgY2FsbDogJ2RiX3B1dEhleCcsXG4gICAgICAgIHBhcmFtczogM1xuICAgIH0pO1xuXG4gICAgdmFyIGdldEhleCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0SGV4JyxcbiAgICAgICAgY2FsbDogJ2RiX2dldEhleCcsXG4gICAgICAgIHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHV0U3RyaW5nLCBnZXRTdHJpbmcsIHB1dEhleCwgZ2V0SGV4XG4gICAgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gREI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2RiLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2RiLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG52YXIgYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbmZpZycpO1xudmFyIENvbnRyYWN0ID0gcmVxdWlyZSgnLi4vY29udHJhY3QnKTtcbnZhciB3YXRjaGVzID0gcmVxdWlyZSgnLi93YXRjaGVzJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyJyk7XG52YXIgSXNTeW5jaW5nID0gcmVxdWlyZSgnLi4vc3luY2luZycpO1xudmFyIG5hbWVyZWcgPSByZXF1aXJlKCcuLi9uYW1lcmVnJyk7XG52YXIgSWJhbiA9IHJlcXVpcmUoJy4uL2liYW4nKTtcbnZhciB0cmFuc2ZlciA9IHJlcXVpcmUoJy4uL3RyYW5zZmVyJyk7XG5cbnZhciBibG9ja0NhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/IFwiZXRoX2dldEJsb2NrQnlIYXNoXCIgOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCI7XG59O1xuXG52YXIgdHJhbnNhY3Rpb25Gcm9tQmxvY2tDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHV0aWxzLmlzU3RyaW5nKGFyZ3NbMF0pICYmIGFyZ3NbMF0uaW5kZXhPZignMHgnKSA9PT0gMCkgPyAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCcgOiAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4Jztcbn07XG5cbnZhciB1bmNsZUNhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JyA6ICdldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgnO1xufTtcblxudmFyIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJyA6ICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXInO1xufTtcblxudmFyIHVuY2xlQ291bnRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHV0aWxzLmlzU3RyaW5nKGFyZ3NbMF0pICYmIGFyZ3NbMF0uaW5kZXhPZignMHgnKSA9PT0gMCkgPyAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCcgOiAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJztcbn07XG5cbmZ1bmN0aW9uIEV0aCh3ZWIzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIG1ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG5cbiAgICBwcm9wZXJ0aWVzKCkuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgIHAuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIHAuc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG5cbiAgICB0aGlzLmliYW4gPSBJYmFuO1xuICAgIHRoaXMuc2VuZElCQU5UcmFuc2FjdGlvbiA9IHRyYW5zZmVyLmJpbmQobnVsbCwgdGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdGgucHJvdG90eXBlLCAnZGVmYXVsdEJsb2NrJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYy5kZWZhdWx0QmxvY2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgYy5kZWZhdWx0QmxvY2sgPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdGgucHJvdG90eXBlLCAnZGVmYXVsdEFjY291bnQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjLmRlZmF1bHRBY2NvdW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGMuZGVmYXVsdEFjY291bnQgPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufSk7XG5cbnZhciBtZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZXRCYWxhbmNlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCYWxhbmNlJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJpZ051bWJlckZvcm1hdHRlclxuICAgIH0pO1xuXG4gICAgdmFyIGdldFN0b3JhZ2VBdCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0U3RvcmFnZUF0JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRTdG9yYWdlQXQnLFxuICAgICAgICBwYXJhbXM6IDMsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgdXRpbHMudG9IZXgsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0Q29kZSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0Q29kZScsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0Q29kZScsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBnZXRCbG9jayA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0QmxvY2snLFxuICAgICAgICBjYWxsOiBibG9ja0NhbGwsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsIGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICEhdmFsOyB9XSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VW5jbGUgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFVuY2xlJyxcbiAgICAgICAgY2FsbDogdW5jbGVDYWxsLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCB1dGlscy50b0hleF0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRCbG9ja0Zvcm1hdHRlcixcblxuICAgIH0pO1xuXG4gICAgdmFyIGdldENvbXBpbGVycyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0Q29tcGlsZXJzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRDb21waWxlcnMnLFxuICAgICAgICBwYXJhbXM6IDBcbiAgICB9KTtcblxuICAgIHZhciBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgIGNhbGw6IGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudENhbGwsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrVW5jbGVDb3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0QmxvY2tVbmNsZUNvdW50JyxcbiAgICAgICAgY2FsbDogdW5jbGVDb3VudENhbGwsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIGdldFRyYW5zYWN0aW9uID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgIH0pO1xuXG4gICAgdmFyIGdldFRyYW5zYWN0aW9uRnJvbUJsb2NrID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkZyb21CbG9jaycsXG4gICAgICAgIGNhbGw6IHRyYW5zYWN0aW9uRnJvbUJsb2NrQ2FsbCxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciwgdXRpbHMudG9IZXhdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRUcmFuc2FjdGlvblJlY2VpcHQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb25Db3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICB9KTtcblxuICAgIHZhciBzZW5kUmF3VHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRSYXdUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgc2VuZFRyYW5zYWN0aW9uID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBjYWxsOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgc2lnblRyYW5zYWN0aW9uID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduVHJhbnNhY3Rpb24nLFxuICAgICAgICBjYWxsOiAnZXRoX3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgc2lnbiA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc2lnbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2lnbicsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBjYWxsID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjYWxsJyxcbiAgICAgICAgY2FsbDogJ2V0aF9jYWxsJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRDYWxsRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgIH0pO1xuXG4gICAgdmFyIGVzdGltYXRlR2FzID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdlc3RpbWF0ZUdhcycsXG4gICAgICAgIGNhbGw6ICdldGhfZXN0aW1hdGVHYXMnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIGNvbXBpbGVTb2xpZGl0eSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnY29tcGlsZS5zb2xpZGl0eScsXG4gICAgICAgIGNhbGw6ICdldGhfY29tcGlsZVNvbGlkaXR5JyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgY29tcGlsZUxMTCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnY29tcGlsZS5sbGwnLFxuICAgICAgICBjYWxsOiAnZXRoX2NvbXBpbGVMTEwnLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBjb21waWxlU2VycGVudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnY29tcGlsZS5zZXJwZW50JyxcbiAgICAgICAgY2FsbDogJ2V0aF9jb21waWxlU2VycGVudCcsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIHN1Ym1pdFdvcmsgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3N1Ym1pdFdvcmsnLFxuICAgICAgICBjYWxsOiAnZXRoX3N1Ym1pdFdvcmsnLFxuICAgICAgICBwYXJhbXM6IDNcbiAgICB9KTtcblxuICAgIHZhciBnZXRXb3JrID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRXb3JrJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRXb3JrJyxcbiAgICAgICAgcGFyYW1zOiAwXG4gICAgfSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBnZXRCYWxhbmNlLFxuICAgICAgICBnZXRTdG9yYWdlQXQsXG4gICAgICAgIGdldENvZGUsXG4gICAgICAgIGdldEJsb2NrLFxuICAgICAgICBnZXRVbmNsZSxcbiAgICAgICAgZ2V0Q29tcGlsZXJzLFxuICAgICAgICBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQsXG4gICAgICAgIGdldEJsb2NrVW5jbGVDb3VudCxcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb24sXG4gICAgICAgIGdldFRyYW5zYWN0aW9uRnJvbUJsb2NrLFxuICAgICAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQsXG4gICAgICAgIGdldFRyYW5zYWN0aW9uQ291bnQsXG4gICAgICAgIGNhbGwsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBzZW5kUmF3VHJhbnNhY3Rpb24sXG4gICAgICAgIHNpZ25UcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZFRyYW5zYWN0aW9uLFxuICAgICAgICBzaWduLFxuICAgICAgICBjb21waWxlU29saWRpdHksXG4gICAgICAgIGNvbXBpbGVMTEwsXG4gICAgICAgIGNvbXBpbGVTZXJwZW50LFxuICAgICAgICBzdWJtaXRXb3JrLFxuICAgICAgICBnZXRXb3JrXG4gICAgXTtcbn07XG5cblxudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdjb2luYmFzZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfY29pbmJhc2UnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ21pbmluZycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfbWluaW5nJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdoYXNocmF0ZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfaGFzaHJhdGUnLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnc3luY2luZycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfc3luY2luZycsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0U3luY2luZ0Zvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdnYXNQcmljZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJpZ051bWJlckZvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdhY2NvdW50cycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfYWNjb3VudHMnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9ibG9ja051bWJlcicsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdwcm90b2NvbFZlcnNpb24nLFxuICAgICAgICAgICAgZ2V0dGVyOiAnZXRoX3Byb3RvY29sVmVyc2lvbidcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuRXRoLnByb3RvdHlwZS5jb250cmFjdCA9IGZ1bmN0aW9uIChhYmkpIHtcbiAgICB2YXIgZmFjdG9yeSA9IG5ldyBDb250cmFjdCh0aGlzLCBhYmkpO1xuICAgIHJldHVybiBmYWN0b3J5O1xufTtcblxuRXRoLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2ssIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKG9wdGlvbnMsICdldGgnLCB0aGlzLl9yZXF1ZXN0TWFuYWdlciwgd2F0Y2hlcy5ldGgoKSwgZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spO1xufTtcblxuRXRoLnByb3RvdHlwZS5uYW1lcmVnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0KG5hbWVyZWcuZ2xvYmFsLmFiaSkuYXQobmFtZXJlZy5nbG9iYWwuYWRkcmVzcyk7XG59O1xuXG5FdGgucHJvdG90eXBlLmljYXBOYW1lcmVnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0KG5hbWVyZWcuaWNhcC5hYmkpLmF0KG5hbWVyZWcuaWNhcC5hZGRyZXNzKTtcbn07XG5cbkV0aC5wcm90b3R5cGUuaXNTeW5jaW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBJc1N5bmNpbmcodGhpcy5fcmVxdWVzdE1hbmFnZXIsIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9ldGguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZXRoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgZXRoLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG5cbnZhciBOZXQgPSBmdW5jdGlvbiAod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBwcm9wZXJ0aWVzKCkuZm9yRWFjaChmdW5jdGlvbihwKSB7IFxuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHdlYjMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn07XG5cbi8vLyBAcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgd2ViMy5ldGggYXBpIHByb3BlcnRpZXNcbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbGlzdGVuaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ25ldF9saXN0ZW5pbmcnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3BlZXJDb3VudCcsXG4gICAgICAgICAgICBnZXR0ZXI6ICduZXRfcGVlckNvdW50JyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pXG4gICAgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9uZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvbmV0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4uL2Zvcm1hdHRlcnMnKTtcblxuZnVuY3Rpb24gUGVyc29uYWwod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfbmV3QWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGltcG9ydFJhd0tleSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnaW1wb3J0UmF3S2V5Jyxcblx0XHRjYWxsOiAncGVyc29uYWxfaW1wb3J0UmF3S2V5Jyxcblx0XHRwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHZhciBzaWduID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduJyxcblx0XHRjYWxsOiAncGVyc29uYWxfc2lnbicsXG5cdFx0cGFyYW1zOiAzLFxuXHRcdGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgZWNSZWNvdmVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdlY1JlY292ZXInLFxuXHRcdGNhbGw6ICdwZXJzb25hbF9lY1JlY292ZXInLFxuXHRcdHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgdmFyIHVubG9ja0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VubG9ja0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfdW5sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzZW5kVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGxvY2tBY2NvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdsb2NrQWNjb3VudCcsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ld0FjY291bnQsXG4gICAgICAgIGltcG9ydFJhd0tleSxcbiAgICAgICAgdW5sb2NrQWNjb3VudCxcbiAgICAgICAgZWNSZWNvdmVyLFxuICAgICAgICBzaWduLFxuICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgIGxvY2tBY2NvdW50XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbGlzdEFjY291bnRzJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3BlcnNvbmFsX2xpc3RBY2NvdW50cydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnNvbmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9wZXJzb25hbC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9wZXJzb25hbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIHNoaC5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhjb3JlLmlvPlxuICogQGRhdGUgMjAxN1xuICovXG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuLi9maWx0ZXInKTtcbnZhciB3YXRjaGVzID0gcmVxdWlyZSgnLi93YXRjaGVzJyk7XG5cbnZhciBTaGggPSBmdW5jdGlvbiAod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufTtcblxuU2hoLnByb3RvdHlwZS5uZXdNZXNzYWdlRmlsdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihvcHRpb25zLCAnc2hoJywgdGhpcy5fcmVxdWVzdE1hbmFnZXIsIHdhdGNoZXMuc2hoKCksIG51bGwsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spO1xufTtcblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfdmVyc2lvbicsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2luZm8nLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9pbmZvJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnc2V0TWF4TWVzc2FnZVNpemUnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9zZXRNYXhNZXNzYWdlU2l6ZScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3NldE1pblBvVycsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3NldE1pblBvVycsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ21hcmtUcnVzdGVkUGVlcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX21hcmtUcnVzdGVkUGVlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ25ld0tleVBhaXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdLZXlQYWlyJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnYWRkUHJpdmF0ZUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2FkZFByaXZhdGVLZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdkZWxldGVLZXlQYWlyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlS2V5UGFpcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc0tleVBhaXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9oYXNLZXlQYWlyJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UHVibGljS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZ2V0UHVibGljS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UHJpdmF0ZUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldFByaXZhdGVLZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICduZXdTeW1LZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdTeW1LZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAwXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdhZGRTeW1LZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9hZGRTeW1LZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCcsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dlbmVyYXRlU3ltS2V5RnJvbVBhc3N3b3JkJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnaGFzU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfaGFzU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0U3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZ2V0U3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZGVsZXRlU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcblxuICAgICAgICAvLyBzdWJzY3JpYmUgYW5kIHVuc3Vic2NyaWJlIG1pc3NpbmdcblxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdwb3N0JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfcG9zdCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgICAgIH0pXG4gICAgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2hoO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3NoaC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zaGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgYnp6LmpzXG4gKiBAYXV0aG9yIEFsZXggQmVyZWdzemFzemkgPGFsZXhAcnRmcy5odT5cbiAqIEBkYXRlIDIwMTZcbiAqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9ibG9iL3N3YXJtL2ludGVybmFsL3dlYjNleHQvd2ViM2V4dC5nbyNMMzNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcblxuZnVuY3Rpb24gU3dhcm0od2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJsb2NrTmV0d29ya1JlYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBjYWxsOiAnYnp6X2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzeW5jRW5hYmxlZCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3luY0VuYWJsZWQnLFxuICAgICAgICBjYWxsOiAnYnp6X3N5bmNFbmFibGVkJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgc3dhcEVuYWJsZWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3N3YXBFbmFibGVkJyxcbiAgICAgICAgY2FsbDogJ2J6el9zd2FwRW5hYmxlZCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGRvd25sb2FkID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdkb3dubG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfZG93bmxvYWQnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciB1cGxvYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VwbG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfdXBsb2FkJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcmV0cmlldmUgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3JldHJpZXZlJyxcbiAgICAgICAgY2FsbDogJ2J6el9yZXRyaWV2ZScsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIHN0b3JlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzdG9yZScsXG4gICAgICAgIGNhbGw6ICdienpfc3RvcmUnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBnZXQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldCcsXG4gICAgICAgIGNhbGw6ICdienpfZ2V0JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcHV0ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgICBjYWxsOiAnYnp6X3B1dCcsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIG1vZGlmeSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnbW9kaWZ5JyxcbiAgICAgICAgY2FsbDogJ2J6el9tb2RpZnknLFxuICAgICAgICBwYXJhbXM6IDQsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGJsb2NrTmV0d29ya1JlYWQsXG4gICAgICAgIHN5bmNFbmFibGVkLFxuICAgICAgICBzd2FwRW5hYmxlZCxcbiAgICAgICAgZG93bmxvYWQsXG4gICAgICAgIHVwbG9hZCxcbiAgICAgICAgcmV0cmlldmUsXG4gICAgICAgIHN0b3JlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHB1dCxcbiAgICAgICAgbW9kaWZ5XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaGl2ZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaGl2ZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaW5mbycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaW5mbydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN3YXJtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zd2FybS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zd2FybS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIHdhdGNoZXMuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZSgnLi4vbWV0aG9kJyk7XG5cbi8vLyBAcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgd2ViMy5ldGguZmlsdGVyIGFwaSBtZXRob2RzXG52YXIgZXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdGaWx0ZXJDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmdzWzBdO1xuXG4gICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdsYXRlc3QnOlxuICAgICAgICAgICAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdldGhfbmV3QmxvY2tGaWx0ZXInO1xuICAgICAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgICAgICAgICAgYXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2V0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXInO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2V0aF9uZXdGaWx0ZXInO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBuZXdGaWx0ZXIgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0ZpbHRlcicsXG4gICAgICAgIGNhbGw6IG5ld0ZpbHRlckNhbGwsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIHVuaW5zdGFsbEZpbHRlciA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAndW5pbnN0YWxsRmlsdGVyJyxcbiAgICAgICAgY2FsbDogJ2V0aF91bmluc3RhbGxGaWx0ZXInLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBnZXRMb2dzID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRMb2dzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRGaWx0ZXJMb2dzJyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgcG9sbCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncG9sbCcsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0RmlsdGVyQ2hhbmdlcycsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3RmlsdGVyLFxuICAgICAgICB1bmluc3RhbGxGaWx0ZXIsXG4gICAgICAgIGdldExvZ3MsXG4gICAgICAgIHBvbGxcbiAgICBdO1xufTtcblxuLy8vIEByZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyB3ZWIzLnNoaC53YXRjaCBhcGkgbWV0aG9kc1xudmFyIHNoaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ25ld0ZpbHRlcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX25ld01lc3NhZ2VGaWx0ZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICd1bmluc3RhbGxGaWx0ZXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9kZWxldGVNZXNzYWdlRmlsdGVyJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0TG9ncycsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldEZpbHRlck1lc3NhZ2VzJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAncG9sbCcsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldEZpbHRlck1lc3NhZ2VzJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBldGg6IGV0aCxcbiAgICBzaGg6IHNoaFxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy93YXRjaGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3dhdGNoZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIG5hbWVyZWcuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGdsb2JhbFJlZ2lzdHJhckFiaSA9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9HbG9iYWxSZWdpc3RyYXIuanNvbicpO1xudmFyIGljYXBSZWdpc3RyYXJBYmk9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb24nKTtcblxudmFyIGdsb2JhbE5hbWVyZWdBZGRyZXNzID0gJzB4YzZkOWQyY2Q0NDlhNzU0YzQ5NDI2NGUxODA5YzUwZTM0ZDY0NTYyYic7XG52YXIgaWNhcE5hbWVyZWdBZGRyZXNzID0gJzB4YTFhMTExYmMwNzRjOWNmYTc4MWYwYzM4ZTYzYmQ1MWM5MWI4YWYwMCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdsb2JhbDoge1xuICAgICAgICBhYmk6IGdsb2JhbFJlZ2lzdHJhckFiaSxcbiAgICAgICAgYWRkcmVzczogZ2xvYmFsTmFtZXJlZ0FkZHJlc3NcbiAgICB9LFxuICAgIGljYXA6IHtcbiAgICAgICAgYWJpOiBpY2FwUmVnaXN0cmFyQWJpLFxuICAgICAgICBhZGRyZXNzOiBpY2FwTmFtZXJlZ0FkZHJlc3NcbiAgICB9XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9uYW1lcmVnLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9uYW1lcmVnLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIHByb3BlcnR5LmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBmcm96ZW1hbi5kZT5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxudmFyIFByb3BlcnR5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5nZXR0ZXIgPSBvcHRpb25zLmdldHRlcjtcbiAgICB0aGlzLnNldHRlciA9IG9wdGlvbnMuc2V0dGVyO1xuICAgIHRoaXMub3V0cHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5vdXRwdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5pbnB1dEZvcm1hdHRlciA9IG9wdGlvbnMuaW5wdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IG51bGw7XG59O1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuc2V0UmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocm0pIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcm07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IGlucHV0IGFyZ3Mgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dFxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUuZm9ybWF0SW5wdXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRGb3JtYXR0ZXIgPyB0aGlzLmlucHV0Rm9ybWF0dGVyKGFyZykgOiBhcmc7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IG91dHB1dChyZXN1bHQpIG9mIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLmZvcm1hdE91dHB1dCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkID8gdGhpcy5vdXRwdXRGb3JtYXR0ZXIocmVzdWx0KSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZXh0cmFjdCBjYWxsYmFjayBmcm9tIGFycmF5IG9mIGFyZ3VtZW50cy4gTW9kaWZpZXMgaW5wdXQgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3RDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxOdWxsfSBjYWxsYmFjaywgaWYgZXhpc3RzXG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MucG9wKCk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG5cbi8qKlxuICogU2hvdWxkIGF0dGFjaCBmdW5jdGlvbiB0byBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGF0dGFjaFRvT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5hdHRhY2hUb09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcHJvdG8gPSB7XG4gICAgICAgIGdldDogdGhpcy5idWlsZEdldCgpLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfTtcblxuICAgIHZhciBuYW1lcyA9IHRoaXMubmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciBuYW1lID0gbmFtZXNbMF07XG4gICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb2JqW25hbWVzWzBdXSA9IG9ialtuYW1lc1swXV0gfHwge307XG4gICAgICAgIG9iaiA9IG9ialtuYW1lc1swXV07XG4gICAgICAgIG5hbWUgPSBuYW1lc1sxXTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBwcm90byk7XG4gICAgb2JqW2FzeW5jR2V0dGVyTmFtZShuYW1lKV0gPSB0aGlzLmJ1aWxkQXN5bmNHZXQoKTtcbn07XG5cbnZhciBhc3luY0dldHRlck5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnZ2V0JyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xufTtcblxuUHJvcGVydHkucHJvdG90eXBlLmJ1aWxkR2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5LmZvcm1hdE91dHB1dChwcm9wZXJ0eS5yZXF1ZXN0TWFuYWdlci5zZW5kKHtcbiAgICAgICAgICAgIG1ldGhvZDogcHJvcGVydHkuZ2V0dGVyXG4gICAgICAgIH0pKTtcbiAgICB9O1xufTtcblxuUHJvcGVydHkucHJvdG90eXBlLmJ1aWxkQXN5bmNHZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcztcbiAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHByb3BlcnR5LnJlcXVlc3RNYW5hZ2VyLnNlbmRBc3luYyh7XG4gICAgICAgICAgICBtZXRob2Q6IHByb3BlcnR5LmdldHRlclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcHJvcGVydHkuZm9ybWF0T3V0cHV0KHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGdldC5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIGdldDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgcHVyZSBKU09OUlBDIHJlcXVlc3Qgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFxuICogQHBhcmFtIHsuLi59IHBhcmFtc1xuICogQHJldHVybiB7T2JqZWN0fSBqc29ucnBjIHJlcXVlc3RcbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIG1ldGhvZDogdGhpcy5nZXR0ZXIsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIGNhbGxiYWNrOiB0aGlzLmV4dHJhY3RDYWxsYmFjayhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgIH07XG4gICAgcGF5bG9hZC5mb3JtYXQgPSB0aGlzLmZvcm1hdE91dHB1dC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9wZXJ0eTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3Byb3BlcnR5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSByZXF1ZXN0bWFuYWdlci5qc1xuICogQGF1dGhvciBKZWZmcmV5IFdpbGNrZSA8amVmZkBldGhkZXYuY29tPlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgTWFyaWFuIE9hbmNlYSA8bWFyaWFuQGV0aGRldi5jb20+XG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogQGF1dGhvciBHYXYgV29vZCA8Z0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciBKc29ucnBjID0gcmVxdWlyZSgnLi9qc29ucnBjJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIGMgPSByZXF1aXJlKCcuLi91dGlscy9jb25maWcnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vKipcbiAqIEl0J3MgcmVzcG9uc2libGUgZm9yIHBhc3NpbmcgbWVzc2FnZXMgdG8gcHJvdmlkZXJzXG4gKiBJdCdzIGFsc28gcmVzcG9uc2libGUgZm9yIHBvbGxpbmcgdGhlIGV0aGVyZXVtIG5vZGUgZm9yIGluY29taW5nIG1lc3NhZ2VzXG4gKiBEZWZhdWx0IHBvbGwgdGltZW91dCBpcyAxIHNlY29uZFxuICogU2luZ2xldG9uXG4gKi9cbnZhciBSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLnBvbGxzID0ge307XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc3luY2hyb25vdXNseSBzZW5kIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHNlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGF5bG9hZCA9IEpzb25ycGMudG9QYXlsb2FkKGRhdGEubWV0aG9kLCBkYXRhLnBhcmFtcyk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucHJvdmlkZXIuc2VuZChwYXlsb2FkKTtcblxuICAgIGlmICghSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGFzeW5jaHJvbm91c2x5IHNlbmQgcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZEFzeW5jXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICB9XG5cbiAgICB2YXIgcGF5bG9hZCA9IEpzb25ycGMudG9QYXlsb2FkKGRhdGEubWV0aG9kLCBkYXRhLnBhcmFtcyk7XG4gICAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gYXN5bmNocm9ub3VzbHkgc2VuZCBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kQmF0Y2hcbiAqIEBwYXJhbSB7QXJyYXl9IGJhdGNoIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZW5kQmF0Y2ggPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUHJvdmlkZXIoKSk7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvQmF0Y2hQYXlsb2FkKGRhdGEpO1xuXG4gICAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXRpbHMuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVzdWx0cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTsgXG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHNldCBwcm92aWRlciBvZiByZXF1ZXN0IG1hbmFnZXJcbiAqXG4gKiBAbWV0aG9kIHNldFByb3ZpZGVyXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKHApIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc3RhcnQgcG9sbGluZ1xuICpcbiAqIEBtZXRob2Qgc3RhcnRQb2xsaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IHBvbGxJZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHVuaW5zdGFsbFxuICpcbiAqIEB0b2RvIGNsZWFudXAgbnVtYmVyIG9mIHBhcmFtc1xuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc3RhcnRQb2xsaW5nID0gZnVuY3Rpb24gKGRhdGEsIHBvbGxJZCwgY2FsbGJhY2ssIHVuaW5zdGFsbCkge1xuICAgIHRoaXMucG9sbHNbcG9sbElkXSA9IHtkYXRhOiBkYXRhLCBpZDogcG9sbElkLCBjYWxsYmFjazogY2FsbGJhY2ssIHVuaW5zdGFsbDogdW5pbnN0YWxsfTtcblxuXG4gICAgLy8gc3RhcnQgcG9sbGluZ1xuICAgIGlmICghdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc3RvcCBwb2xsaW5nIGZvciBmaWx0ZXIgd2l0aCBnaXZlbiBpZFxuICpcbiAqIEBtZXRob2Qgc3RvcFBvbGxpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb2xsSWRcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnN0b3BQb2xsaW5nID0gZnVuY3Rpb24gKHBvbGxJZCkge1xuICAgIGRlbGV0ZSB0aGlzLnBvbGxzW3BvbGxJZF07XG5cbiAgICAvLyBzdG9wIHBvbGxpbmdcbiAgICBpZihPYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGggPT09IDAgJiYgdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byByZXNldCB0aGUgcG9sbGluZyBtZWNoYW5pc20gb2YgdGhlIHJlcXVlc3QgbWFuYWdlclxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGtlZXBJc1N5bmNpbmcpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjUgKi9cblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnBvbGxzKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgcG9sbHMsIGV4Y2VwdCBzeW5jIHBvbGxzLFxuICAgICAgICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVtb3ZlZCBtYW51YWxseSBieSBjYWxsaW5nIHN5bmNpbmcuc3RvcFdhdGNoaW5nKClcbiAgICAgICAgaWYoIWtlZXBJc1N5bmNpbmcgfHwga2V5LmluZGV4T2YoJ3N5bmNQb2xsXycpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb2xsc1trZXldLnVuaW5zdGFsbCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucG9sbHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0b3AgcG9sbGluZ1xuICAgIGlmKE9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBvbGwgZm9yIGNoYW5nZXMgb24gZmlsdGVyIHdpdGggZ2l2ZW4gaWRcbiAqXG4gKiBAbWV0aG9kIHBvbGxcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5wb2xsLmJpbmQodGhpcyksIGMuRVRIX1BPTExJTkdfVElNRU9VVCk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvbGxzRGF0YSA9IFtdO1xuICAgIHZhciBwb2xsc0lkcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnBvbGxzKSB7XG4gICAgICAgIHBvbGxzRGF0YS5wdXNoKHRoaXMucG9sbHNba2V5XS5kYXRhKTtcbiAgICAgICAgcG9sbHNJZHMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGlmIChwb2xsc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF5bG9hZCA9IEpzb25ycGMudG9CYXRjaFBheWxvYWQocG9sbHNEYXRhKTtcbiAgICBcbiAgICAvLyBtYXAgdGhlIHJlcXVlc3QgaWQgdG8gdGhleSBwb2xsIGlkXG4gICAgdmFyIHBvbGxzSWRNYXAgPSB7fTtcbiAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24obG9hZCwgaW5kZXgpe1xuICAgICAgICBwb2xsc0lkTWFwW2xvYWQuaWRdID0gcG9sbHNJZHNbaW5kZXhdO1xuICAgIH0pO1xuXG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVycm9yLCByZXN1bHRzKSB7XG5cblxuICAgICAgICAvLyBUT0RPOiBjb25zb2xlIGxvZz9cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGlkID0gcG9sbHNJZE1hcFtyZXN1bHQuaWRdO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGZpbHRlciBpcyBzdGlsbCBpbnN0YWxsZWQgYWZ0ZXIgYXJyaXZhbCBvZiB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHNlbGYucG9sbHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNhbGxiYWNrID0gc2VsZi5wb2xsc1tpZF0uY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXJlc3VsdDsgXG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSBKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayhudWxsLCByZXN1bHQucmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RNYW5hZ2VyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9yZXF1ZXN0bWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcmVxdWVzdG1hbmFnZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbnZhciBTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRCbG9jayA9ICdsYXRlc3QnO1xuICAgIHRoaXMuZGVmYXVsdEFjY291bnQgPSB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdzO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9zZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc2V0dGluZ3MuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBzeW5jaW5nLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbnZhciBjb3VudCA9IDE7XG5cbi8qKlxuQWRkcyB0aGUgY2FsbGJhY2sgYW5kIHNldHMgdXAgdGhlIG1ldGhvZHMsIHRvIGl0ZXJhdGUgb3ZlciB0aGUgcmVzdWx0cy5cblxuQG1ldGhvZCBwb2xsU3luY2luZ1xuQHBhcmFtIHtPYmplY3R9IHNlbGZcbiovXG52YXIgcG9sbFN5bmNpbmcgPSBmdW5jdGlvbihzZWxmKSB7XG5cbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24gKGVycm9yLCBzeW5jKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih1dGlscy5pc09iamVjdChzeW5jKSAmJiBzeW5jLnN0YXJ0aW5nQmxvY2spXG4gICAgICAgICAgICBzeW5jID0gZm9ybWF0dGVycy5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyKHN5bmMpO1xuXG4gICAgICAgIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5sYXN0U3luY1N0YXRlICE9PSBzeW5jKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0cnVlIGZpcnN0IHNvIHRoZSBhcHAgY2FuIHN0b3AgYW55dGhpbmcsIGJlZm9yZSByZWNlaXZpbmcgdGhlIHN5bmMgZGF0YVxuICAgICAgICAgICAgICAgIGlmKCFzZWxmLmxhc3RTeW5jU3RhdGUgJiYgdXRpbHMuaXNPYmplY3Qoc3luYykpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNhbGwgb24gdGhlIG5leHQgQ1BVIGN5Y2xlLCBzbyB0aGUgYWN0aW9ucyBvZiB0aGUgc3luYyBzdG9wIGNhbiBiZSBwcm9jZXNzZXMgZmlyc3RcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzeW5jKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RTeW5jU3RhdGUgPSBzeW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe1xuICAgICAgICBtZXRob2Q6ICdldGhfc3luY2luZycsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgfSwgc2VsZi5wb2xsSWQsIG9uTWVzc2FnZSwgc2VsZi5zdG9wV2F0Y2hpbmcuYmluZChzZWxmKSk7XG5cbn07XG5cbnZhciBJc1N5bmNpbmcgPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMucG9sbElkID0gJ3N5bmNQb2xsXycrIGNvdW50Kys7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmFkZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB0aGlzLmxhc3RTeW5jU3RhdGUgPSBmYWxzZTtcbiAgICBwb2xsU3luY2luZyh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuSXNTeW5jaW5nLnByb3RvdHlwZS5hZGRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbklzU3luY2luZy5wcm90b3R5cGUuc3RvcFdhdGNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIuc3RvcFBvbGxpbmcodGhpcy5wb2xsSWQpO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzU3luY2luZztcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgdHJhbnNmZXIuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEliYW4gPSByZXF1aXJlKCcuL2liYW4nKTtcbnZhciBleGNoYW5nZUFiaSA9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb24nKTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBtYWtlIEliYW4gdHJhbnNmZXJcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvIGliYW5cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5mZXJlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2ssIGNhbGxiYWNrXG4gKi9cbnZhciB0cmFuc2ZlciA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKHRvKTsgXG4gICAgaWYgKCFpYmFuLmlzVmFsaWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaWJhbiBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKGliYW4uaXNEaXJlY3QoKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmZXJUb0FkZHJlc3MoZXRoLCBmcm9tLCBpYmFuLmFkZHJlc3MoKSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB2YXIgYWRkcmVzcyA9IGV0aC5pY2FwTmFtZXJlZygpLmFkZHIoaWJhbi5pbnN0aXR1dGlvbigpKTtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSk7XG4gICAgfVxuXG4gICAgZXRoLmljYXBOYW1lcmVnKCkuYWRkcihpYmFuLmluc3RpdHV0aW9uKCksIGZ1bmN0aW9uIChlcnIsIGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byB0cmFuc2ZlciBmdW5kcyB0byBjZXJ0YWluIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyVG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSB0byBiZSB0cmFuZmVyZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgdHJhbnNmZXJUb0FkZHJlc3MgPSBmdW5jdGlvbiAoZXRoLCBmcm9tLCB0bywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV0aC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICBhZGRyZXNzOiB0byxcbiAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXBvc2l0IGZ1bmRzIHRvIGdlbmVyaWMgRXhjaGFuZ2UgY29udHJhY3QgKG11c3QgaW1wbGVtZW50IGRlcG9zaXQoYnl0ZXMzMikgbWV0aG9kISlcbiAqXG4gKiBAbWV0aG9kIGRlcG9zaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5zZmVyZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGllbnQgdW5pcXVlIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgZGVwb3NpdCA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2xpZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBhYmkgPSBleGNoYW5nZUFiaTtcbiAgICByZXR1cm4gZXRoLmNvbnRyYWN0KGFiaSkuYXQodG8pLmRlcG9zaXQoY2xpZW50LCB7XG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3RyYW5zZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy90cmFuc2Zlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy94aHIyL2xpYi9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMveGhyMi9saWIvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2Fkc0xpc3Quc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2Fkc0xpc3Quc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2Fkc0xpc3Quc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9hZHNMaXN0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9idXR0b24uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2J1dHRvbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vYnV0dG9uLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2J1dHRvbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2ljb24uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2ljb24uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2ljb24uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pY29uLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9pbnB1dC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vaW5wdXQuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2lucHV0LnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9sYWJlbC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGFiZWwuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xhYmVsLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmsuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGlua0xpc3Quc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xpbmtMaXN0LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rTGlzdC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rTGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rTGlzdC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbG9hZGVyLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9sb2FkZXIuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xvYWRlci5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sb2FkZXIuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9wYXBlci5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vcGFwZXIuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3BhcGVyLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3BhcGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3BhcGVyLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi90ZXh0V2l0aExhYmVsLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi90ZXh0V2l0aExhYmVsLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi90ZXh0V2l0aExhYmVsLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3RleHRXaXRoTGFiZWwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdG9vbHRpcC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdG9vbHRpcC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdG9vbHRpcC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90b29sdGlwLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lQejRLUEhOMlp5QjNhV1IwYUQwaU1UUXhjSGdpSUdobGFXZG9kRDBpTVRNeGNIZ2lJSFpwWlhkQ2IzZzlJakFnTUNBeE5ERWdNVE14SWlCMlpYSnphVzl1UFNJeExqRWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaVBnb2dJQ0FnUENFdExTQkhaVzVsY21GMGIzSTZJRk5yWlhSamFDQTBOaTR5SUNnME5EUTVOaWtnTFNCb2RIUndPaTh2ZDNkM0xtSnZhR1Z0YVdGdVkyOWthVzVuTG1OdmJTOXphMlYwWTJnZ0xTMCtDaUFnSUNBOGRHbDBiR1UrUjNKdmRYQWdNend2ZEdsMGJHVStDaUFnSUNBOFpHVnpZejVEY21WaGRHVmtJSGRwZEdnZ1UydGxkR05vTGp3dlpHVnpZejRLSUNBZ0lEeGtaV1p6UGdvZ0lDQWdJQ0FnSUR4amFYSmpiR1VnYVdROUluQmhkR2d0TVNJZ1kzZzlJall3TGpjNE5qRXpNamdpSUdONVBTSTFPUzQzT0RZeE16STRJaUJ5UFNJME5TNDNPRFl4TXpJNElqNDhMMk5wY21Oc1pUNEtJQ0FnSUNBZ0lDQThabWxzZEdWeUlIZzlJaTB6TlM0MUpTSWdlVDBpTFRNd0xqQWxJaUIzYVdSMGFEMGlNVGN4TGpBbElpQm9aV2xuYUhROUlqRTNNUzR3SlNJZ1ptbHNkR1Z5Vlc1cGRITTlJbTlpYW1WamRFSnZkVzVrYVc1blFtOTRJaUJwWkQwaVptbHNkR1Z5TFRJaVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Wm1WUFptWnpaWFFnWkhnOUlqQWlJR1I1UFNJMUlpQnBiajBpVTI5MWNtTmxRV3h3YUdFaUlISmxjM1ZzZEQwaWMyaGhaRzkzVDJabWMyVjBUM1YwWlhJeElqNDhMMlpsVDJabWMyVjBQZ29nSUNBZ0lDQWdJQ0FnSUNBOFptVkhZWFZ6YzJsaGJrSnNkWElnYzNSa1JHVjJhV0YwYVc5dVBTSXhNQ0lnYVc0OUluTm9ZV1J2ZDA5bVpuTmxkRTkxZEdWeU1TSWdjbVZ6ZFd4MFBTSnphR0ZrYjNkQ2JIVnlUM1YwWlhJeElqNDhMMlpsUjJGMWMzTnBZVzVDYkhWeVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Wm1WRGIyeHZjazFoZEhKcGVDQjJZV3gxWlhNOUlqQWdNQ0F3SURBZ01DNHdNelV5T1RReE1UYzJJQ0FnTUNBd0lEQWdNQ0F3TGpnek5USTVOREV4T0NBZ0lEQWdNQ0F3SURBZ01DNDBPRFl5TnpRMU1TQWdNQ0F3SURBZ01DNDBOU0F3SWlCMGVYQmxQU0p0WVhSeWFYZ2lJR2x1UFNKemFHRmtiM2RDYkhWeVQzVjBaWEl4SWo0OEwyWmxRMjlzYjNKTllYUnlhWGcrQ2lBZ0lDQWdJQ0FnUEM5bWFXeDBaWEkrQ2lBZ0lDQThMMlJsWm5NK0NpQWdJQ0E4WnlCcFpEMGlUVlpRSWlCemRISnZhMlU5SW01dmJtVWlJSE4wY205clpTMTNhV1IwYUQwaU1TSWdabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWo0S0lDQWdJQ0FnSUNBOFp5QnBaRDBpWTNKbFlYUmxUbVYzUVdSRGIyNW1hWEp0WVhScGIyNGlJSFJ5WVc1elptOXliVDBpZEhKaGJuTnNZWFJsS0MwM016WXVNREF3TURBd0xDQXRNell4TGpBd01EQXdNQ2tpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThaeUJwWkQwaVIzSnZkWEF0TWlJZ2RISmhibk5tYjNKdFBTSjBjbUZ1YzJ4aGRHVW9OelF4TGpBd01EQXdNQ3dnTXpZeUxqQXdNREF3TUNraVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWtkeWIzVndMVE1pUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeGphWEpqYkdVZ2FXUTlJazkyWVd3dE1pSWdabWxzYkMxdmNHRmphWFI1UFNJd0xqSWlJR1pwYkd3OUlpTXdPVVExTjBNaUlHTjRQU0l4TURNaUlHTjVQU0l6TXlJZ2NqMGlNek1pUGp3dlkybHlZMnhsUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeGphWEpqYkdVZ2FXUTlJazkyWVd3dE1pSWdabWxzYkMxdmNHRmphWFI1UFNJd0xqSWlJR1pwYkd3OUlpTXdPVVExTjBNaUlHTjRQU0l6TXlJZ1kzazlJamN6SWlCeVBTSXpNeUkrUEM5amFYSmpiR1UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWs5MllXd2lQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThkWE5sSUdacGJHdzlJbUpzWVdOcklpQm1hV3hzTFc5d1lXTnBkSGs5SWpFaUlHWnBiSFJsY2owaWRYSnNLQ05tYVd4MFpYSXRNaWtpSUhoc2FXNXJPbWh5WldZOUlpTndZWFJvTFRFaVBqd3ZkWE5sUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4ZFhObElHWnBiR3c5SWlNd09VUTFOME1pSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ2VHeHBibXM2YUhKbFpqMGlJM0JoZEdndE1TSStQQzkxYzJVK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeG5JR2xrUFNKdWIzVnVYemMwTnpNd01sOWpZeUlnZEhKaGJuTm1iM0p0UFNKMGNtRnVjMnhoZEdVb016WXVNREF3TURBd0xDQTBNaTR3TURBd01EQXBJaUJtYVd4c0xYSjFiR1U5SW01dmJucGxjbThpSUdacGJHdzlJaU5HUmtaR1JrWWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NVE11T1RVMk1EUTBMREF1TVRBNU9Ea3dNVEVnUXpFMkxqY3dNekk1Tmpjc0xUTXVNRFF3TmpJek16RmxMVEUwSURFNUxqQTJOVGt6TkRFc01DNDVPRGt3TVRBNU9Ea2dNakF1T0RJME1UYzFPQ3d5TGpnMU56RTBNamcySUV3eU5DNDRPVEF4TURrNUxEY3VNVFF5T0RVM01UUWdRekl6TGpjek5qSTJNemNzT0M0ME5qRTFNemcwTmlBeU1pNDROVGN4TkRJNUxEa3VNemsxTmpBME5DQXlNaTQxTWpjME56STFMRGt1T0RNMU1UWTBPRFFnUXpJeExqa3lNekEzTmprc09TNHhOelU0TWpReE9DQXlNQzQwTXprMU5qQTBMRGN1TkRjeU5USTNORGNnTVRndU9UVTJNRFEwTERVdU9EYzVNVEl3T0RnZ1F6RTNMalU0TWpReE56WXNOQzR6T1RVMk1EUTBJREUxTGpjeE5ESTROVGNzTXk0Mk9ERXpNVGcyT0NBeE15NDNNell5TmpNM0xETXVOemt4TWpBNE56a2dRekV4TGpnMk9ERXpNVGtzTXk0NU1ERXdPVGc1SURFd0xqRTJORGd6TlRJc05DNDNPREF5TVRrM09DQTVMakk0TlRjeE5ESTVMRFV1T1RnNU1ERXdPVGtnUXpVdU9UZzVNREV3T1Rrc01UQXVOVFE1TkRVd05TQTVMakk0TlRjeE5ESTVMREUwTGpZeE5UTTRORFlnT1M0eU9EVTNNVFF5T1N3eE5DNDJOekF6TWprM0lFd3lOQzQ0TXpVeE5qUTRMRE15TGpZek56TTJNallnUXpJekxqWTRNVE14T0Rjc016TXVPVFUyTURRMElESXlMamcxTnpFME1qa3NNelF1T1RRMU1EVTBPU0F5TWk0ME56STFNamMxTERNMUxqTXlPVFkzTURNZ1F6SXdMamczT1RFeU1Ea3NNek11TXpVeE5qUTROQ0F4TUM0ek9EUTJNVFUwTERJeExqUXlPRFUzTVRRZ05pNHlNRGczT1RFeU1Td3hOaTQxT1RNME1EWTJJRU0xTGpJeE9UYzRNREl5TERFMUxqUTVORFV3TlRVZ015NHhNekU0TmpneE15d3hNUzQxT1RNME1EWTJJRFF1T0RNMU1UWTBPRFFzTmk0M05UZ3lOREUzTmlCRE5pNDBPRE0xTVRZME9Dd3lMakF6TWprMk56QXpJREV3TGpjMk9USXpNRGdzTUM0eU1UazNPREF5TWlBeE15NDVOVFl3TkRRc01DNHhNRGs0T1RBeE1TQmFJaUJwWkQwaVUyaGhjR1VpUGp3dmNHRjBhRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEl6TGpBM05qa3lNekVzTVRZdU16RTROamd4TXlCRE1qUXVORFV3TlRRNU5Td3hOQzQzTWpVeU56UTNJREk0TGprMU5qQTBOQ3c1TGpRMU1EVTBPVFExSURNeExqYzFPREkwTVRnc05pNHpOek0yTWpZek55QkRNekl1T0RVM01UUXlPU3cxTGpFMk5EZ3pOVEUySURNMExqSTROVGN4TkRNc05DNDBOVEExTkRrME5TQXpOUzQ1T0Rrd01URXNOQzR6T1RVMk1EUTBJRU16Tnk0ek1EYzJPVEl6TERRdU16UXdOalU1TXpRZ016Z3VOamd4TXpFNE55dzBMamN5TlRJM05EY3pJRE01TGpjeU5USTNORGNzTlM0ME16azFOakEwTkNCRE16WXVOVGt6TkRBMk5pdzFMalkxT1RNME1EWTJJRE0xTGpBMU5EazBOVEVzTnk0MU1qYzBOekkxTXlBek5TdzNMalU0TWpReE56VTRJRXd5Tnk0Mk16Y3pOakkyTERFMkxqTXhPRFk0TVRNZ1RESXpMakEzTmpreU16RXNNVFl1TXpFNE5qZ3hNeUJhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRNdU1EYzJPVEl6TURnc01Ua3VORFV3TlRRNU5TQkRNQzQ1T0Rrd01UQTVPRGtzTVRjdU1ETXlPVFkzSURBdU1UWTBPRE0xTVRZMUxERXpMamM1TVRJd09EZ2dNQzQzTVRReU9EVTNNVFFzTVRBdU1UWTBPRE0xTWlCRE1TNHhOVE00TkRZeE5TdzNMakF6TWprMk56QXpJRE11TnpNMk1qWXpOelFzTkM0d05qVTVNelF3TnlBMkxqWTBPRE0xTVRZMUxESXVOelEzTWpVeU56VWdRelV1TmpVNU16UXdOallzTXk0M09URXlNRGczT1NBMExqZ3pOVEUyTkRnMExEVXVNRFUwT1RRMU1EVWdOQzR5T0RVM01UUXlPU3cyTGpVNU16UXdOalU1SUVNeUxqUTNNalV5TnpRM0xERXhMalU1TXpRd05qWWdOQzQzTWpVeU56UTNNeXd4TlM0NE1qUXhOelU0SURVdU56WTVNak13Tnpjc01UWXVPVGM0TURJeUlFTXhNQzR5TnpRM01qVXpMREl5TGpFNU56Z3dNaklnTWpJdU1UUXlPRFUzTVN3ek5TNDRNalF4TnpVNElESXlMakkxTWpjME56TXNNelV1T1RNME1EWTFPU0JNTWpJdU5USTNORGN5TlN3ek5pNHlOak0zTXpZeklFd3lNaTQzTkRjeU5USTNMRE0yTGpBME16azFOaUJETWpJdU9URXlNRGczT1N3ek5TNDROemt4TWpBNUlETTNMalEzTWpVeU56VXNNVGt1TURZMU9UTTBNU0EwTUM0M01UUXlPRFUzTERFMUxqUXpPVFUyTURRZ1F6UXpMalEyTVRVek9EVXNNVEl1TXpBM05qa3lNeUEwTXk0d056WTVNak14TERjdU5qTTNNell5TmpRZ05EQXVPREkwTVRjMU9DdzFMalUwT1RRMU1EVTFJRU16T1M0Mk1UVXpPRFEyTERRdU16azFOakEwTkNBek55NDRNREl4T1RjNExETXVOek0yTWpZek56UWdNell1TURRek9UVTJMRE11T1RBeE1EazRPU0JETXpRdU1qTXdOelk1TWl3ekxqazFOakEwTXprMklETXlMall6TnpNMk1qWXNOQzQzT0RBeU1UazNPQ0F6TVM0ME1qZzFOekUwTERZdU1EUXpPVFUyTURRZ1F6STRMalV4TmpRNE16VXNPUzR5TXpBM05qa3lNeUF5TXk0Mk1qWXpOek0yTERFMExqZzVNREV3T1RrZ01qSXVOVEkzTkRjeU5Td3hOaTR4TlRNNE5EWXlJRU15TVM0MU16ZzBOakUxTERFMExqazBOVEExTkRrZ01UY3VNVGszT0RBeU1pdzVMalkzTURNeU9UWTNJREUwTGprME5UQTFORGtzTnk0eE9UYzRNREl5SUVNeE5DNHlNekEzTmpreUxEWXVOREk0TlRjeE5ETWdNVE11TURJeE9UYzRMRFV1TmpBME16azFOaUF4TUM0M05qa3lNekE0TERVdU16ZzBOakUxTXpnZ1F6RXhMalU1TXpRd05qWXNOQzQzT0RBeU1UazNPQ0F4TWk0Mk9USXpNRGMzTERRdU5EVXdOVFE1TkRVZ01UTXVOemt4TWpBNE9DdzBMak0wTURZMU9UTTBJRU14TlM0d05UUTVORFV4TERRdU1qZzFOekUwTWprZ01UWXVPVEl6TURjMk9TdzBMalV3TlRRNU5EVXhJREU0TGpVeE5qUTRNelVzTmk0eU5qTTNNell5TmlCRE1qQXVNemcwTmpFMU5DdzRMakkwTVRjMU9ESTBJREl5TGpJMU1qYzBOek1zTVRBdU5ETTVOVFl3TkNBeU1pNHlOVEkzTkRjekxERXdMalF6T1RVMk1EUWdUREl5TGpRM01qVXlOelVzTVRBdU5qVTVNelF3TnlCTU1qSXVOamt5TXpBM055d3hNQzQwTXprMU5qQTBJRU15TWk0Mk9USXpNRGMzTERFd0xqUXpPVFUyTURRZ01qVXNOeTQ0TURJeE9UYzRJREk0TGpFNE5qZ3hNeklzTkM0eE56VTRNalF4T0NCRE16QXVPVE0wTURZMU9Td3hMakE1T0Rrd01URWdNelF1TWpNd056WTVNaXd3SURNMkxqUTRNelV4TmpVc01DQkRNemd1TnpNMk1qWXpOeXd3SURRekxqUTJNVFV6T0RVc01TNHpOek0yTWpZek55QTBOUzQwT1RRMU1EVTFMRFl1TmpRNE16VXhOalVnUXpRMkxqY3dNekk1Tmpjc09TNDRNelV4TmpRNE5DQTBOaTR4TlRNNE5EWXlMREUwTGpBMk5Ua3pOREVnTkRRdU1UYzFPREkwTWl3eE5pNHpNVGcyT0RFeklFTXpPQzQxTnpFME1qZzJMREl5TGpnMU56RTBNamtnTWpRdU1UYzFPREkwTWl3ek9TNHlPRFUzTVRReklESXlMak13TnpZNU1qTXNOREV1TkRnek5URTJOU0JETWpBdU16ZzBOakUxTkN3ek9TNHlPRFUzTVRReklEVXVNamMwTnpJMU1qY3NNakV1T1RJek1EYzJPU0F6TGpBM05qa3lNekE0TERFNUxqUTFNRFUwT1RVZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHdZWFJvSUdROUlrMDBOeTQ1Tmpjd016TXNNVGd1TkRZeE5UTTROU0JETkRNdU5UY3hOREk0Tml3eU15NDBNRFkxT1RNMElESTVMakUzTlRneU5ESXNOREF1TXpJNU5qY3dNeUF5Tnk0NU1USXdPRGM1TERReExqYzFPREkwTVRnZ1RESXpMakF5TVRrM09DdzBNUzQzTlRneU5ERTRJRU15TlM0MU5EazBOVEExTERNNExqYzVNVEl3T0RnZ016a3VNamcxTnpFME15d3lNeTR4TXpFNE5qZ3hJRFEwTGpjeU5USTNORGNzTVRZdU9ERXpNVGcyT0NCRE5EWXVPRFk0TVRNeE9Td3hOQzR6T1RVMk1EUTBJRFEzTGpReE56VTRNalFzTVRBZ05EWXVNRGs0T1RBeE1TdzJMalU1TXpRd05qVTVJRU0wTlM0ME16azFOakEwTERVZ05EUXVOakUxTXpnME5pd3pMalk0TVRNeE9EWTRJRFF6TGpZeU5qTTNNellzTWk0M05EY3lOVEkzTlNCRE5EWXVNRFF6T1RVMkxETXVOemt4TWpBNE56a2dORGN1T1RFeU1EZzNPU3cxTGpRNU5EVXdOVFE1SURRNUxqQXhNRGs0T1N3M0xqa3hNakE0TnpreElFdzBPUzR3TmpVNU16UXhMRGd1TURJeE9UYzRNRElnUXpRNUxqQXhNRGs0T1N3M0xqazJOekF6TWprM0lEVXhMamd4TXpFNE5qZ3NNVFF1TURFd09UZzVJRFEzTGprMk56QXpNeXd4T0M0ME5qRTFNemcxSUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUNBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lEd3ZaejRLUEM5emRtYytcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW1hZ2VzL2hlYXJ0LnN2Z1xuLy8gbW9kdWxlIGlkID0gLi9pbWFnZXMvaGVhcnQuc3ZnXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHV0dGluZyBoaXN0b3J5IG9uIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICBoaXN0b3J5OiB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2gocGF0aG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogJy8nLFxuICAgICAgdXJsOiAnLycsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNFeGFjdDogcGF0aG5hbWUgPT09ICcvJ1xuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcblxuXG4gICAgaW52YXJpYW50KGNoaWxkcmVuID09IG51bGwgfHwgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAxLCAnQSA8Um91dGVyPiBtYXkgaGF2ZSBvbmx5IG9uZSBjaGlsZCBlbGVtZW50Jyk7XG5cbiAgICAvLyBEbyB0aGlzIGhlcmUgc28gd2UgY2FuIHNldFN0YXRlIHdoZW4gYSA8UmVkaXJlY3Q+IGNoYW5nZXMgdGhlXG4gICAgLy8gbG9jYXRpb24gaW4gY29tcG9uZW50V2lsbE1vdW50LiBUaGlzIGhhcHBlbnMgZS5nLiB3aGVuIGRvaW5nXG4gICAgLy8gc2VydmVyIHJlbmRlcmluZyB1c2luZyBhIDxTdGF0aWNSb3V0ZXI+LlxuICAgIHRoaXMudW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICBtYXRjaDogX3RoaXMyLmNvbXB1dGVNYXRjaChoaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKHRoaXMucHJvcHMuaGlzdG9yeSA9PT0gbmV4dFByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+Jyk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtb3J5Um91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbW9yeVJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTWVtb3J5Um91dGVyLnByb3BUeXBlcyA9IHtcbiAgaW5pdGlhbEVudHJpZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgaW5pdGlhbEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHJvbXB0aW5nIHRoZSB1c2VyIGJlZm9yZSBuYXZpZ2F0aW5nIGF3YXlcbiAqIGZyb20gYSBzY3JlZW4gd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUHJvbXB0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb21wdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUHJvbXB0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9tcHQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBQcm9tcHQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykgdGhpcy51bmJsb2NrKCk7XG5cbiAgICB0aGlzLnVuYmxvY2sgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuYmxvY2sobWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB7XG4gICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgIHRoaXMudW5ibG9jayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLndoZW4pIHRoaXMuZW5hYmxlKHRoaXMucHJvcHMubWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLndoZW4pIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy53aGVuIHx8IHRoaXMucHJvcHMubWVzc2FnZSAhPT0gbmV4dFByb3BzLm1lc3NhZ2UpIHRoaXMuZW5hYmxlKG5leHRQcm9wcy5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUHJvbXB0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Qcm9tcHQucHJvcFR5cGVzID0ge1xuICB3aGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgbWVzc2FnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKS5pc1JlcXVpcmVkXG59O1xuUHJvbXB0LmRlZmF1bHRQcm9wcyA9IHtcbiAgd2hlbjogdHJ1ZVxufTtcblByb21wdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgYmxvY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgdXBkYXRpbmcgdGhlIGxvY2F0aW9uIHByb2dyYW1hdGljYWxseVxuICogd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUmVkaXJlY3QgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVkaXJlY3QsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlZGlyZWN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWRpcmVjdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5pc1N0YXRpYyA9IGZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm91dGVyICYmIHRoaXMuY29udGV4dC5yb3V0ZXIuc3RhdGljQ29udGV4dDtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGlmICh0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIHBlcmZvcm0oKSB7XG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHB1c2ggPSBfcHJvcHMucHVzaCxcbiAgICAgICAgdG8gPSBfcHJvcHMudG87XG5cblxuICAgIGlmIChwdXNoKSB7XG4gICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgIH1cbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZWRpcmVjdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVkaXJlY3QucHJvcFR5cGVzID0ge1xuICBwdXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKVxufTtcblJlZGlyZWN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgcHVzaDogZmFsc2Vcbn07XG5SZWRpcmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tICdwYXRoLXRvLXJlZ2V4cCc7XG5cbnZhciBwYXR0ZXJuQ2FjaGUgPSB7fTtcbnZhciBjYWNoZUxpbWl0ID0gMTAwMDA7XG52YXIgY2FjaGVDb3VudCA9IDA7XG5cbnZhciBjb21waWxlUGF0aCA9IGZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlS2V5ID0gJycgKyBvcHRpb25zLmVuZCArIG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgY2FjaGUgPSBwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldIHx8IChwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldID0ge30pO1xuXG4gIGlmIChjYWNoZVtwYXR0ZXJuXSkgcmV0dXJuIGNhY2hlW3BhdHRlcm5dO1xuXG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZSA9IHBhdGhUb1JlZ2V4cChwYXR0ZXJuLCBrZXlzLCBvcHRpb25zKTtcbiAgdmFyIGNvbXBpbGVkUGF0dGVybiA9IHsgcmU6IHJlLCBrZXlzOiBrZXlzIH07XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0dGVybl0gPSBjb21waWxlZFBhdHRlcm47XG4gICAgY2FjaGVDb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVkUGF0dGVybjtcbn07XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBVUkwgcGF0aG5hbWUgdG8gYSBwYXRoIHBhdHRlcm4uXG4gKi9cbnZhciBtYXRjaFBhdGggPSBmdW5jdGlvbiBtYXRjaFBhdGgocGF0aG5hbWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMgPSB7IHBhdGg6IG9wdGlvbnMgfTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGF0aCA9IF9vcHRpb25zLnBhdGgsXG4gICAgICBwYXRoID0gX29wdGlvbnMkcGF0aCA9PT0gdW5kZWZpbmVkID8gJy8nIDogX29wdGlvbnMkcGF0aCxcbiAgICAgIF9vcHRpb25zJGV4YWN0ID0gX29wdGlvbnMuZXhhY3QsXG4gICAgICBleGFjdCA9IF9vcHRpb25zJGV4YWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJGV4YWN0LFxuICAgICAgX29wdGlvbnMkc3RyaWN0ID0gX29wdGlvbnMuc3RyaWN0LFxuICAgICAgc3RyaWN0ID0gX29wdGlvbnMkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHN0cmljdDtcblxuICB2YXIgX2NvbXBpbGVQYXRoID0gY29tcGlsZVBhdGgocGF0aCwgeyBlbmQ6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCB9KSxcbiAgICAgIHJlID0gX2NvbXBpbGVQYXRoLnJlLFxuICAgICAga2V5cyA9IF9jb21waWxlUGF0aC5rZXlzO1xuXG4gIHZhciBtYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciB1cmwgPSBtYXRjaFswXSxcbiAgICAgIHZhbHVlcyA9IG1hdGNoLnNsaWNlKDEpO1xuXG4gIHZhciBpc0V4YWN0ID0gcGF0aG5hbWUgPT09IHVybDtcblxuICBpZiAoZXhhY3QgJiYgIWlzRXhhY3QpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCwgLy8gdGhlIHBhdGggcGF0dGVybiB1c2VkIHRvIG1hdGNoXG4gICAgdXJsOiBwYXRoID09PSAnLycgJiYgdXJsID09PSAnJyA/ICcvJyA6IHVybCwgLy8gdGhlIG1hdGNoZWQgcG9ydGlvbiBvZiB0aGUgVVJMXG4gICAgaXNFeGFjdDogaXNFeGFjdCwgLy8gd2hldGhlciBvciBub3Qgd2UgbWF0Y2hlZCBleGFjdGx5XG4gICAgcGFyYW1zOiBrZXlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywga2V5LCBpbmRleCkge1xuICAgICAgbWVtb1trZXkubmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBzaW5nbGUgcGF0aCBhbmQgcmVuZGVyaW5nLlxuICovXG5cbnZhciBSb3V0ZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGUoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLCBfdGhpcy5jb250ZXh0LnJvdXRlcilcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjogX2V4dGVuZHMoe30sIHRoaXMuY29udGV4dC5yb3V0ZXIsIHtcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcHV0ZU1hdGNoID0gZnVuY3Rpb24gY29tcHV0ZU1hdGNoKF9yZWYsIF9yZWYyKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICAgIGV4YWN0ID0gX3JlZi5leGFjdDtcbiAgICB2YXIgcm91dGUgPSBfcmVmMi5yb3V0ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICB2YXIgcGF0aG5hbWUgPSAobG9jYXRpb24gfHwgcm91dGUubG9jYXRpb24pLnBhdGhuYW1lO1xuXG4gICAgcmV0dXJuIHBhdGggPyBtYXRjaFBhdGgocGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgc3RyaWN0OiBzdHJpY3QsIGV4YWN0OiBleGFjdCB9KSA6IHJvdXRlLm1hdGNoO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wcy5jb21wb25lbnQsXG4gICAgICAgIHJlbmRlciA9IF9wcm9wcy5yZW5kZXIsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xuXG5cbiAgICB3YXJuaW5nKCEoY29tcG9uZW50ICYmIHJlbmRlciksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSByZW5kZXI+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgcmVuZGVyPiB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIHdhcm5pbmcoIShjb21wb25lbnQgJiYgY2hpbGRyZW4pLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgd2FybmluZyghKHJlbmRlciAmJiBjaGlsZHJlbiksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIHJlbmRlcj4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJyk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHdhcm5pbmcoISghbmV4dFByb3BzLmxvY2F0aW9uICYmIHRoaXMucHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1hdGNoOiB0aGlzLmNvbXB1dGVNYXRjaChuZXh0UHJvcHMsIG5leHRDb250ZXh0LnJvdXRlcilcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMuc3RhdGUubWF0Y2g7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wczIuY29tcG9uZW50LFxuICAgICAgICByZW5kZXIgPSBfcHJvcHMyLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICByZXR1cm4gY29tcG9uZW50ID8gLy8gY29tcG9uZW50IHByb3AgZ2V0cyBmaXJzdCBwcmlvcml0eSwgb25seSBjYWxsZWQgaWYgdGhlcmUncyBhIG1hdGNoXG4gICAgbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbCA6IHJlbmRlciA/IC8vIHJlbmRlciBwcm9wIGlzIG5leHQsIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gcmVuZGVyKHByb3BzKSA6IG51bGwgOiBjaGlsZHJlbiA/IC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHByb3BzKSA6ICFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSB8fCBjaGlsZHJlbi5sZW5ndGggPyAvLyBQcmVhY3QgZGVmYXVsdHMgdG8gZW1wdHkgY2hpbGRyZW4gYXJyYXlcbiAgICBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IG51bGwgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUm91dGUucHJvcFR5cGVzID0ge1xuICBjb21wdXRlZE1hdGNoOiBQcm9wVHlwZXMub2JqZWN0LCAvLyBwcml2YXRlLCBmcm9tIDxTd2l0Y2g+XG4gIHBhdGg6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgY29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgcmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubm9kZV0pLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblJvdXRlLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSlcbn07XG5Sb3V0ZS5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUm91dGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgY3JlYXRlUGF0aCwgcGFyc2VQYXRoIH0gZnJvbSAnaGlzdG9yeS9QYXRoVXRpbHMnO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbnZhciBub3JtYWxpemVMb2NhdGlvbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uKG9iamVjdCkge1xuICB2YXIgX29iamVjdCRwYXRobmFtZSA9IG9iamVjdC5wYXRobmFtZSxcbiAgICAgIHBhdGhuYW1lID0gX29iamVjdCRwYXRobmFtZSA9PT0gdW5kZWZpbmVkID8gJy8nIDogX29iamVjdCRwYXRobmFtZSxcbiAgICAgIF9vYmplY3Qkc2VhcmNoID0gb2JqZWN0LnNlYXJjaCxcbiAgICAgIHNlYXJjaCA9IF9vYmplY3Qkc2VhcmNoID09PSB1bmRlZmluZWQgPyAnJyA6IF9vYmplY3Qkc2VhcmNoLFxuICAgICAgX29iamVjdCRoYXNoID0gb2JqZWN0Lmhhc2gsXG4gICAgICBoYXNoID0gX29iamVjdCRoYXNoID09PSB1bmRlZmluZWQgPyAnJyA6IF9vYmplY3QkaGFzaDtcblxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBhZGRCYXNlbmFtZSA9IGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICB2YXIgYmFzZSA9IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSk7XG5cbiAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZSkgIT09IDApIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihiYXNlLmxlbmd0aClcbiAgfSk7XG59O1xuXG52YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aChsb2NhdGlvbikgOiBub3JtYWxpemVMb2NhdGlvbihsb2NhdGlvbik7XG59O1xuXG52YXIgY3JlYXRlVVJMID0gZnVuY3Rpb24gY3JlYXRlVVJMKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gbG9jYXRpb24gOiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbn07XG5cbnZhciBzdGF0aWNIYW5kbGVyID0gZnVuY3Rpb24gc3RhdGljSGFuZGxlcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnWW91IGNhbm5vdCAlcyB3aXRoIDxTdGF0aWNSb3V0ZXI+JywgbWV0aG9kTmFtZSk7XG4gIH07XG59O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuLyoqXG4gKiBUaGUgcHVibGljIHRvcC1sZXZlbCBBUEkgZm9yIGEgXCJzdGF0aWNcIiA8Um91dGVyPiwgc28tY2FsbGVkIGJlY2F1c2UgaXRcbiAqIGNhbid0IGFjdHVhbGx5IGNoYW5nZSB0aGUgY3VycmVudCBsb2NhdGlvbi4gSW5zdGVhZCwgaXQganVzdCByZWNvcmRzXG4gKiBsb2NhdGlvbiBjaGFuZ2VzIGluIGEgY29udGV4dCBvYmplY3QuIFVzZWZ1bCBtYWlubHkgaW4gdGVzdGluZyBhbmRcbiAqIHNlcnZlci1yZW5kZXJpbmcgc2NlbmFyaW9zLlxuICovXG5cbnZhciBTdGF0aWNSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3RhdGljUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdGF0aWNSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0aWNSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmNyZWF0ZUhyZWYgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdTbGFzaChfdGhpcy5wcm9wcy5iYXNlbmFtZSArIGNyZWF0ZVVSTChwYXRoKSk7XG4gICAgfSwgX3RoaXMuaGFuZGxlUHVzaCA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMuY29udGV4dDtcblxuICAgICAgY29udGV4dC5hY3Rpb24gPSAnUFVTSCc7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVSZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzMi5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZUxpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH0sIF90aGlzLmhhbmRsZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiB7XG4gICAgICAgIHN0YXRpY0NvbnRleHQ6IHRoaXMucHJvcHMuY29udGV4dFxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGJhc2VuYW1lID0gX3Byb3BzLmJhc2VuYW1lLFxuICAgICAgICBjb250ZXh0ID0gX3Byb3BzLmNvbnRleHQsXG4gICAgICAgIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnYmFzZW5hbWUnLCAnY29udGV4dCcsICdsb2NhdGlvbiddKTtcblxuICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgY3JlYXRlSHJlZjogdGhpcy5jcmVhdGVIcmVmLFxuICAgICAgYWN0aW9uOiAnUE9QJyxcbiAgICAgIGxvY2F0aW9uOiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpLFxuICAgICAgcHVzaDogdGhpcy5oYW5kbGVQdXNoLFxuICAgICAgcmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgZ286IHN0YXRpY0hhbmRsZXIoJ2dvJyksXG4gICAgICBnb0JhY2s6IHN0YXRpY0hhbmRsZXIoJ2dvQmFjaycpLFxuICAgICAgZ29Gb3J3YXJkOiBzdGF0aWNIYW5kbGVyKCdnb0ZvcndhcmQnKSxcbiAgICAgIGxpc3RlbjogdGhpcy5oYW5kbGVMaXN0ZW4sXG4gICAgICBibG9jazogdGhpcy5oYW5kbGVCbG9ja1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBoaXN0b3J5OiBoaXN0b3J5IH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5TdGF0aWNSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG59O1xuU3RhdGljUm91dGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgYmFzZW5hbWU6ICcnLFxuICBsb2NhdGlvbjogJy8nXG59O1xuU3RhdGljUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIHRoZSBmaXJzdCA8Um91dGU+IHRoYXQgbWF0Y2hlcy5cbiAqL1xuXG52YXIgU3dpdGNoID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN3aXRjaCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3dpdGNoKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTd2l0Y2gpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBTd2l0Y2gucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHdhcm5pbmcoIShuZXh0UHJvcHMubG9jYXRpb24gJiYgIXRoaXMucHJvcHMubG9jYXRpb24pLCAnPFN3aXRjaD4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHdhcm5pbmcoISghbmV4dFByb3BzLmxvY2F0aW9uICYmIHRoaXMucHJvcHMubG9jYXRpb24pLCAnPFN3aXRjaD4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciByb3V0ZSA9IHRoaXMuY29udGV4dC5yb3V0ZXIucm91dGU7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMucHJvcHMubG9jYXRpb24gfHwgcm91dGUubG9jYXRpb247XG5cbiAgICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICAgIGNoaWxkID0gdm9pZCAwO1xuICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSByZXR1cm47XG5cbiAgICAgIHZhciBfZWxlbWVudCRwcm9wcyA9IGVsZW1lbnQucHJvcHMsXG4gICAgICAgICAgcGF0aFByb3AgPSBfZWxlbWVudCRwcm9wcy5wYXRoLFxuICAgICAgICAgIGV4YWN0ID0gX2VsZW1lbnQkcHJvcHMuZXhhY3QsXG4gICAgICAgICAgc3RyaWN0ID0gX2VsZW1lbnQkcHJvcHMuc3RyaWN0LFxuICAgICAgICAgIGZyb20gPSBfZWxlbWVudCRwcm9wcy5mcm9tO1xuXG4gICAgICB2YXIgcGF0aCA9IHBhdGhQcm9wIHx8IGZyb207XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gZWxlbWVudDtcbiAgICAgICAgbWF0Y2ggPSBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIGV4YWN0OiBleGFjdCwgc3RyaWN0OiBzdHJpY3QgfSkgOiByb3V0ZS5tYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaCA/IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgeyBsb2NhdGlvbjogbG9jYXRpb24sIGNvbXB1dGVkTWF0Y2g6IG1hdGNoIH0pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU3dpdGNoO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Td2l0Y2guY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuU3dpdGNoLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgWyd3cmFwcGVkQ29tcG9uZW50UmVmJ10pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHsgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocm91dGVDb21wb25lbnRQcm9wcykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgcm91dGVDb21wb25lbnRQcm9wcywgeyByZWY6IHdyYXBwZWRDb21wb25lbnRSZWYgfSkpO1xuICAgICAgfSB9KTtcbiAgfTtcblxuICBDLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgJyknO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgX01lbW9yeVJvdXRlciBmcm9tICcuL01lbW9yeVJvdXRlcic7XG5leHBvcnQgeyBfTWVtb3J5Um91dGVyIGFzIE1lbW9yeVJvdXRlciB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnknO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgSFRNTDUgaGlzdG9yeS5cbiAqL1xuXG52YXIgQnJvd3NlclJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCcm93c2VyUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCcm93c2VyUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJvd3NlclJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gQnJvd3NlclJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQnJvd3NlclJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmb3JjZVJlZnJlc2g6IFByb3BUeXBlcy5ib29sLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnknO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgd2luZG93LmxvY2F0aW9uLmhhc2guXG4gKi9cblxudmFyIEhhc2hSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSGFzaFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSGFzaFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhc2hSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkhhc2hSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGhhc2hUeXBlOiBQcm9wVHlwZXMub25lT2YoWydoYXNoYmFuZycsICdub3NsYXNoJywgJ3NsYXNoJ10pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgSGFzaFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG52YXIgaXNNb2RpZmllZEV2ZW50ID0gZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExpbmssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2xpY2spIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgLy8gb25DbGljayBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIGlnbm9yZSByaWdodCBjbGlja3NcbiAgICAgICFfdGhpcy5wcm9wcy50YXJnZXQgJiYgLy8gbGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIGlnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgdmFyIGhpc3RvcnkgPSBfdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5O1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgICByZXBsYWNlID0gX3RoaXMkcHJvcHMucmVwbGFjZSxcbiAgICAgICAgICAgICAgdG8gPSBfdGhpcyRwcm9wcy50bztcblxuXG4gICAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHJlcGxhY2UgPSBfcHJvcHMucmVwbGFjZSxcbiAgICAgICAgdG8gPSBfcHJvcHMudG8sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydyZXBsYWNlJywgJ3RvJ10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB2YXIgaHJlZiA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5jcmVhdGVIcmVmKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB7IHBhdGhuYW1lOiB0byB9IDogdG8pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljaywgaHJlZjogaHJlZiB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkxpbmsucHJvcFR5cGVzID0ge1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkXG59O1xuTGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIHJlcGxhY2U6IGZhbHNlXG59O1xuTGluay5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBjcmVhdGVIcmVmOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IExpbms7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmltcG9ydCBMaW5rIGZyb20gJy4vTGluayc7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG8nLCAnZXhhY3QnLCAnc3RyaWN0JywgJ2xvY2F0aW9uJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnc3R5bGUnLCAnaXNBY3RpdmUnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiAodHlwZW9mIHRvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0bykpID09PSAnb2JqZWN0JyA/IHRvLnBhdGhuYW1lIDogdG8sXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZjIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWYyLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoID0gX3JlZjIubWF0Y2g7XG5cbiAgICAgIHZhciBpc0FjdGl2ZSA9ICEhKGdldElzQWN0aXZlID8gZ2V0SXNBY3RpdmUobWF0Y2gsIGxvY2F0aW9uKSA6IG1hdGNoKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe1xuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNsYXNzTmFtZTogaXNBY3RpdmUgPyBbYWN0aXZlQ2xhc3NOYW1lLCBjbGFzc05hbWVdLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5qb2luKCcgJykgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGVcbiAgICAgIH0sIHJlc3QpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuTmF2TGluay5wcm9wVHlwZXMgPSB7XG4gIHRvOiBMaW5rLnByb3BUeXBlcy50byxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5OYXZMaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWN0aXZlQ2xhc3NOYW1lOiAnYWN0aXZlJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2TGluaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gJy4vQnJvd3NlclJvdXRlcic7XG5leHBvcnQgeyBfQnJvd3NlclJvdXRlciBhcyBCcm93c2VyUm91dGVyIH07XG5pbXBvcnQgX0hhc2hSb3V0ZXIgZnJvbSAnLi9IYXNoUm91dGVyJztcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfTmF2TGluayBmcm9tICcuL05hdkxpbmsnO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2J1dHRvbi5zY3NzJztcblxuY29uc3QgY3ggPSBjbGFzc25hbWVzLmJpbmQoc3R5bGUpO1xuXG50eXBlIFRCdXR0b25Qcm9wcyA9IEpTWC5IVE1MQXR0cmlidXRlcyAmIHtcbiAgc2Vjb25kYXJ5PzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IEJ1dHRvbiA9ICh7IGNsYXNzOiBjbGFzc05hbWUsIHNlY29uZGFyeSA9IGZhbHNlLCAuLi5yZXN0UHJvcHMgfTogVEJ1dHRvblByb3BzKSA9PiAoXG4gIDxidXR0b24gY2xhc3M9e2N4KHN0eWxlLnNlbGYsIGNsYXNzTmFtZSwgeyBwcmltYXJ5OiAhc2Vjb25kYXJ5LCBzZWNvbmRhcnkgfSl9IHsuLi5yZXN0UHJvcHN9IC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvQnV0dG9uLnRzeCIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG5pbXBvcnQgQnV0dG9uIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9CdXR0b24nO1xuXG5jb25zdCBIb21lID0gKCkgPT4gKFxuICA8ZGl2PlxuICAgIDxMaW5rIHRvPVwiL3doaXRlbGlzdFwiPjxCdXR0b24+V2hpdGVsaXN0PC9CdXR0b24+PC9MaW5rPlxuICAgIDxMaW5rIHRvPVwiL3N0YXR1c1wiPjxCdXR0b24+U3RhdHVzPC9CdXR0b24+PC9MaW5rPlxuICAgIDxMaW5rIHRvPVwiL2xpbmtsaXN0XCI+PEJ1dHRvbj5MaW5rTGlzdDwvQnV0dG9uPjwvTGluaz5cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BhZ2VzL0hvbWUudHN4IiwiaW1wb3J0ICogYXMgV2ViMyBmcm9tICd3ZWIzJztcblxubGV0IHdlYjM7XG5cbmlmICh0eXBlb2Ygd2luZG93LndlYjMgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdlYjMgPSBuZXcgV2ViMyh3aW5kb3cud2ViMy5jdXJyZW50UHJvdmlkZXIpO1xufSBlbHNlIHtcbiAgd2ViMyA9IG5ldyBXZWIzKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdlYjM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvdXRpbHMvc3JjL3dlYjMudHMiLCJleHBvcnQgeyBkZWZhdWx0IGFzIHdlYjMgfSBmcm9tICcuL3dlYjMnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL3V0aWxzL3NyYy9pbmRleC50cyIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgeyBJTGluayB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9saW5rLnNjc3MnO1xuXG5jb25zdCBjeCA9IGNsYXNzbmFtZXMuYmluZChzdHlsZSk7XG5cbmludGVyZmFjZSBJTGlua1Byb3BzIHtcbiAgbGluazogSUxpbms7XG4gIGNsYXNzPzogc3RyaW5nO1xuICBsaW5lcz86IG51bWJlcjtcbiAgc3R5bGU/OiBzdHJpbmcgfCB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgc3RyaW5nfTtcbn1cblxuY29uc3Qgc3RvcFByb3BhZ2F0aW9uID0gKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbmNvbnN0IExpbmsgPSAoeyBjbGFzczogY2xhc3NOYW1lLCBsaW5rLCBsaW5lcyA9IDIsIHN0eWxlOiBleHRlcm5hbFN0eWxlIH06IElMaW5rUHJvcHMpID0+IHtcbiAgaWYgKCEobGluZXMgPT09IDIgfHwgbGluZXMgPT09IDgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDIgYW5kIDggbGluZXMgbGlua3MgYXJlIGF2YWlsYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPXtjbGFzc25hbWVzKHN0eWxlLnNlbGYsIGNsYXNzTmFtZSl9IHN0eWxlPXtleHRlcm5hbFN0eWxlfT5cbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnRpdGxlfT57bGluay50aXRsZX08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9e2N4KCdzdW1tYXJ5JywgeyBsaW5lczI6IGxpbmVzID09PSAyLCBsaW5lczg6IGxpbmVzID09PSA4IH0pfT57bGluay5zdW1tYXJ5fTwvZGl2PlxuICAgICAgPGFcbiAgICAgICAgY2xhc3M9e3N0eWxlLmxpbmt9XG4gICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgIGhyZWY9e2xpbmsudGFyZ2V0fVxuICAgICAgICBvbkNsaWNrPXtzdG9wUHJvcGFnYXRpb259XG4gICAgICA+XG4gICAgICAgIHtsaW5rLnRhcmdldH1cbiAgICAgIDwvYT5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExpbms7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGluay50c3giLCJpbXBvcnQgeyBoLCBGdW5jdGlvbmFsQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vcGFwZXIuc2Nzcyc7XG5cbmNvbnN0IFBhcGVyOiBGdW5jdGlvbmFsQ29tcG9uZW50PEpTWC5IVE1MQXR0cmlidXRlcz4gPSAoeyBjbGFzczogY2xhc3NOYW1lLCAuLi5yZXN0UHJvcHMgfSkgPT4gKFxuICA8ZGl2IHsuLi5yZXN0UHJvcHN9IGNsYXNzPXtjbGFzc25hbWVzKGNsYXNzTmFtZSwgc3R5bGUuc2VsZil9IC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBQYXBlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9QYXBlci50c3giLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vbG9hZGVyLnNjc3MnO1xuXG5pbnRlcmZhY2UgSUxvYWRlclByb3BzIHtcbiAgY2xhc3M/OiBzdHJpbmc7XG59XG5cbmNvbnN0IExvYWRlciA9ICh7IGNsYXNzOiBjbGFzc05hbWV9OiBJTG9hZGVyUHJvcHMpID0+IHtcbiAgcmV0dXJuIDxkaXYgY2xhc3M9e2NsYXNzbmFtZXMoc3R5bGUuc2VsZiwgY2xhc3NOYW1lKX0gLz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2FkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTG9hZGVyLnRzeCIsImltcG9ydCB7IGgsIEZ1bmN0aW9uYWxDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2xhYmVsLnNjc3MnO1xuXG5jb25zdCBMYWJlbDogRnVuY3Rpb25hbENvbXBvbmVudDx7fT4gPSAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIDxwIGNsYXNzPXtzdHlsZS5zZWxmfT57cHJvcHMuY2hpbGRyZW59PC9wPjtcbiAgfVxuXG4gIHJldHVybiA8cCBjbGFzcz17c3R5bGUuc2VsZn0gLz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYWJlbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9MYWJlbC50c3giLCJpbXBvcnQgeyBoLCBGdW5jdGlvbmFsQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vdGV4dFdpdGhMYWJlbC5zY3NzJztcblxuaW1wb3J0IExhYmVsIGZyb20gJy4vTGFiZWwnO1xuXG5pbnRlcmZhY2UgSVRleHRXaXRoTGFiZWxQcm9wcyB7XG4gIGxhYmVsOiBzdHJpbmcgfEpTWC5FbGVtZW50O1xuICB0ZXh0Pzogc3RyaW5nIHwgbnVtYmVyO1xuICBjbGFzcz86IHN0cmluZztcbn1cblxuY29uc3QgVGV4dFdpdGhMYWJlbDogRnVuY3Rpb25hbENvbXBvbmVudDxJVGV4dFdpdGhMYWJlbFByb3BzPiA9ICh7IGxhYmVsLCB0ZXh0LCBjbGFzczogY2xhc3NOYW1lLCBjaGlsZHJlbiB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz17Y2xhc3NuYW1lcyhzdHlsZS5zZWxmLCBjbGFzc05hbWUpfT5cbiAgICAgIDxMYWJlbD57bGFiZWx9PC9MYWJlbD5cbiAgICAgIDxwIGNsYXNzPXtzdHlsZS50ZXh0fT57dGV4dCB8fCBjaGlsZHJlbn08L3A+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0V2l0aExhYmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1RleHRXaXRoTGFiZWwudHN4IiwiaW1wb3J0IHsgaCwgRnVuY3Rpb25hbENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IGdldFN2Z0NvbnRlbnRSZWd4cCA9IC88c3ZnW14+XSo+KC4qKTxcXC9zdmc+LztcblxuaW50ZXJmYWNlIElTdmdQcm9wcyB7XG4gIGNsYXNzPzogc3RyaW5nO1xuICBzdmc6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyIHwgc3RyaW5nO1xuICB2aWV3Qm94OiBzdHJpbmc7XG59XG5cbmNvbnN0IFN2ZyA9ICh7IHN2Zywgc2l6ZSwgdmlld0JveCwgY2xhc3M6IGNsYXNzTmFtZSB9OiBJU3ZnUHJvcHMpID0+IHtcbiAgbGV0IHN2Z0NvbnRlbnQ7XG4gIGNvbnN0IHJlZ2V4cFJlc3VsdCA9IGdldFN2Z0NvbnRlbnRSZWd4cC5leGVjKHN2Zyk7XG4gIGlmIChyZWdleHBSZXN1bHQpIHtcbiAgICBzdmdDb250ZW50ID0gcmVnZXhwUmVzdWx0WzFdO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzcz17Y2xhc3NOYW1lfVxuICAgICAgc3R5bGU9e3sgd2lkdGg6IHNpemUgfX1cbiAgICAgIGFsdD17bmFtZX1cbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogc3ZnQ29udGVudCB9fVxuICAgICAgdmlld0JveD17dmlld0JveH1cbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgIC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTdmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvU3ZnLnRzeCIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCAnb3Blbi1pY29uaWMvZm9udC9jc3Mvb3Blbi1pY29uaWMubWluLmNzcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vaWNvbi5zY3NzJztcblxuaW50ZXJmYWNlIElJY29uUHJvcHMge1xuICBuYW1lOiBzdHJpbmc7XG4gIGNsYXNzPzogc3RyaW5nO1xufVxuXG5jb25zdCBJY29uID0gKHsgbmFtZSwgY2xhc3M6IGNsYXNzTmFtZSB9OiBJSWNvblByb3BzKSA9PiAoXG4gIDxzcGFuIGNsYXNzPXtjbGFzc25hbWVzKHN0eWxlLnNlbGYsIGNsYXNzTmFtZSwgJ29pJyl9IGRhdGEtZ2x5cGg9e25hbWV9IGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBJY29uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0ljb24udHN4IiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL3Rvb2x0aXAuc2Nzcyc7XG5cbmludGVyZmFjZSBJVG9vbHRpcFByb3BzIHtcbiAgdGV4dD86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBKU1guRWxlbWVudDtcbiAgY2xhc3M/OiBzdHJpbmc7XG4gIHN0eWxlPzogc3RyaW5nIHwgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCBzdHJpbmcgfTtcbn1cblxuY29uc3QgVG9vbHRpcCA9ICh7IGNsYXNzOiBjbGFzc05hbWUsIHN0eWxlOiBleHRlcm5hbFN0eWxlLCB0ZXh0LCBjaGlsZHJlbiB9OiBJVG9vbHRpcFByb3BzKSA9PiAoXG4gIDxkaXYgc3R5bGU9e2V4dGVybmFsU3R5bGV9IGNsYXNzPXtjbGFzc25hbWVzKHN0eWxlLnNlbGYsIGNsYXNzTmFtZSl9PlxuICAgIHtjaGlsZHJlbn1cbiAgICB7dGV4dCAmJiA8ZGl2IGNsYXNzPXtzdHlsZS50ZXh0fT57dGV4dH08L2Rpdj59XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9Ub29sdGlwLnRzeCIsImltcG9ydCB7IGgsIEZ1bmN0aW9uYWxDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgU3ZnIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9TdmcnO1xuaW1wb3J0IEljb24gZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0ljb24nO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL1Rvb2x0aXAnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL3N0ZXBzLnNjc3MnO1xuY29uc3QgY3ggPSBjbGFzc25hbWVzLmJpbmQoc3R5bGUpO1xuXG5jb25zdCBjdWJlU3ZnID0gcmVxdWlyZSgnISFzdmctaW5saW5lLWxvYWRlcj9yZW1vdmVUYWdzPXRydWUmcmVtb3ZlU1ZHVGFnQXR0cnM9dHJ1ZSEuLi8uLi8uLi8uLi9pbWFnZXMvY3ViZS5zdmcnKTtcblxuaW50ZXJmYWNlIElTdGVwUHJvcHMge1xuICBpY29uOiBKU1guRWxlbWVudDtcbiAgc3RhdGU6ICdkaXNhYmxlZCcgfCAnd2FpdGluZycgfCAnZG9uZSc7XG59XG5cbmNvbnN0IFN0ZXA6IEZ1bmN0aW9uYWxDb21wb25lbnQ8SVN0ZXBQcm9wcz4gPSAoeyBpY29uLCBzdGF0ZSwgY2hpbGRyZW4gfSkgPT4gKFxuICA8ZGl2IGNsYXNzPXtjeChzdHlsZS5zdGVwLCB7IFtzdGF0ZV06IHRydWUgfSl9PlxuICAgIDxkaXYgY2xhc3M9e3N0eWxlLmljb259PntpY29ufTwvZGl2PlxuICAgIDxkaXYgY2xhc3M9e3N0eWxlLmNvbnRlbnR9PntjaGlsZHJlbn08L2Rpdj5cbiAgPC9kaXY+XG4pO1xuXG5pbnRlcmZhY2UgSVN0ZXBzUHJvcHMge1xuICBjb250ZXh0OiBzdHJpbmc7XG4gIGxpbmtJZDogc3RyaW5nO1xuICBsaW5rPzogYW55O1xuICBibG9ja2NoYWluU3RhdGU6IHtcbiAgICB3ZWIzQXZhaWxhYmxlOiBib29sZWFuO1xuICAgIGJsb2NrTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICAgIGN1cnJlbnRCbG9ja051bWJlcjogbnVtYmVyIHwgbnVsbDtcbiAgfTtcbn1cblxuY29uc3QgU3RlcHMgPSAoeyBjb250ZXh0LCBsaW5rSWQsIGxpbmssIGJsb2NrY2hhaW5TdGF0ZSB9OiBJU3RlcHNQcm9wcykgPT4ge1xuICBsZXQgc3RlcDBTdGF0ZTtcbiAgbGV0IHN0ZXAwUmVhc29uO1xuICBpZiAoYmxvY2tjaGFpblN0YXRlLndlYjNBdmFpbGFibGUpIHtcbiAgICBpZiAoYmxvY2tjaGFpblN0YXRlLmJsb2NrTnVtYmVyKSB7XG4gICAgICBzdGVwMFN0YXRlID0gJ2RvbmUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwMFN0YXRlID0gJ3dhaXRpbmcnO1xuICAgICAgc3RlcDBSZWFzb24gPSAnV2FpdGluZyBmb3IgYmxvY2tjaGFpbic7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgc3RlcDBTdGF0ZSA9ICdkaXNhYmxlZCc7XG4gICAgc3RlcDBSZWFzb24gPSAnV2ViIGlzIHVuYXZhaWxhYmxlJztcbiAgfVxuXG4gIGNvbnN0IHN0ZXAxU3RhdGUgPSBsaW5rID8gJ2RvbmUnIDogJ3dhaXRpbmcnO1xuICBjb25zdCBzdGVwMlN0YXRlID0gbGluayAmJiBsaW5rLndoaXRlbGlzdGVkID8gJ2RvbmUnIDogJ3dhaXRpbmcnO1xuXG4gIGNvbnN0IFtuZXR3b3JrXSA9IGNvbnRleHQuc3BsaXQoJzonKTtcbiAgY29uc3QgbmV0d29ya1ByZWZpeCA9IG5ldHdvcmsgIT09ICdldGgnID8gYCR7bmV0d29ya30uYCA6ICcnO1xuICBjb25zdCBbLCB0eF0gPSBsaW5rSWQuc3BsaXQoJzonKTtcbiAgY29uc3QgZXRoZXJzY2FuVXJsID0gbGluayA/IGBodHRwczovLyR7bmV0d29ya1ByZWZpeH1ldGhlcnNjYW4uaW8vdHgvJHt0eH1gIDogJyc7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPXtzdHlsZS5zZWxmfT5cbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnByb2dyZXNzQ290YWluZXJ9PlxuICAgICAgICA8ZGl2IGNsYXNzPXtzdHlsZS5wcm9ncmVzc30gLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz17c3R5bGUuc3RlcHNDb250YWluZXJ9PlxuICAgICAgICA8U3RlcFxuICAgICAgICAgIHN0YXRlPXtzdGVwMFN0YXRlfVxuICAgICAgICAgIGljb249ezxUb29sdGlwIHRleHQ9e3N0ZXAwUmVhc29ufT48SWNvbiBjbGFzcz17c3R5bGUuaWNvbn0gbmFtZT1cImV5ZVwiIC8+PC9Ub29sdGlwPn1cbiAgICAgICAgPlxuICAgICAgICAgIDxwPlZpc2libGUgb24gYmxvY2tjaGFpbjwvcD5cbiAgICAgICAgICA8YSBocmVmPXtldGhlcnNjYW5Vcmx9IHRhcmdldD1cIl9ibGFua1wiPkV0aGVyc2NhbiA8SWNvbiBuYW1lPVwiZXh0ZXJuYWwtbGlua1wiIC8+PC9hPlxuICAgICAgICA8L1N0ZXA+XG4gICAgICAgIDxTdGVwXG4gICAgICAgICAgc3RhdGU9e3N0ZXAxU3RhdGV9XG4gICAgICAgICAgaWNvbj17PFN2ZyBzdmc9e2N1YmVTdmd9IHNpemU9XCIxLjJlbVwiIHZpZXdCb3g9XCIwIDAgMjMgMjdcIiAvPn1cbiAgICAgICAgPlxuICAgICAgICAgIDxwPlVzZXJmZWVkcyBBZGRyZXNzPC9wPlxuICAgICAgICAgIDxzcGFuPlZpc2libGUgdG8gcHVibGlzaGVyPC9zcGFuPlxuICAgICAgICA8L1N0ZXA+XG4gICAgICAgIDxTdGVwXG4gICAgICAgICAgc3RhdGU9e3N0ZXAyU3RhdGV9XG4gICAgICAgICAgaWNvbj17PEljb24gY2xhc3M9e3N0eWxlLmljb259IG5hbWU9XCJjaGVja1wiIC8+fVxuICAgICAgICA+XG4gICAgICAgICAgPHA+UHV0IG9uIHdoaXRlbGlzdDwvcD5cbiAgICAgICAgICA8c3Bhbj5BbGwgc2V0ITwvc3Bhbj5cbiAgICAgICAgPC9TdGVwPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTdGVwcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9TdGVwcy50c3giLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5pbXBvcnQgeyB3ZWIzIH0gZnJvbSAnQHVzZXJmZWVkcy91dGlscyc7XG5pbXBvcnQgU3ZnIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9TdmcnO1xuaW1wb3J0IExpbmsgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0xpbmsnO1xuaW1wb3J0IFBhcGVyIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9QYXBlcic7XG5pbXBvcnQgTG9hZGVyIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9Mb2FkZXInO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvQnV0dG9uJztcbmltcG9ydCBUZXh0V2l0aExhYmVsIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9UZXh0V2l0aExhYmVsJztcblxuaW1wb3J0IFN0ZXBzIGZyb20gJy4vY29tcG9uZW50cy9TdGVwcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vU3RhdHVzLnNjc3MnO1xuXG5jb25zdCBoZWFydFN2ZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2ltYWdlcy9oZWFydC5zdmcnKTtcblxuY29uc3QgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gKHR4OiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3ZWIzLmV0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHgsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5jb25zdCBnZXRCbG9ja051bWJlcjogKCkgPT4gUHJvbWlzZTxudW1iZXI+ID0gKCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdlYjMuZXRoLmdldEJsb2NrTnVtYmVyKChlcnJvciwgY3VycmVudEJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3VycmVudEJsb2NrTnVtYmVyKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5jb25zdCB3YWl0ID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbmludGVyZmFjZSBJU3RhdHVzUHJvcHMge1xuICBsb2NhdGlvbjogYW55O1xufVxuXG5pbnRlcmZhY2UgSVN0YXR1c1N0YXRlIHtcbiAgbGluaz86IGFueTtcbiAgbGlua0lkOiBzdHJpbmc7XG4gIGNvbnRleHQ6IHN0cmluZztcbiAgYWxnb3JpdGhtOiBzdHJpbmc7XG4gIHdoaXRlbGlzdDogc3RyaW5nO1xuICBwdWJsaXNoZXJOb3RlOiBzdHJpbmc7XG4gIHdpZGdldExvY2F0aW9uOiBzdHJpbmc7XG4gIGJsb2NrY2hhaW46IHtcbiAgICB3ZWIzQXZhaWxhYmxlOiBib29sZWFuO1xuICAgIGJsb2NrTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICAgIGN1cnJlbnRCbG9ja051bWJlcjogbnVtYmVyIHwgbnVsbDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdHVzIGV4dGVuZHMgQ29tcG9uZW50PElTdGF0dXNQcm9wcywgSVN0YXR1c1N0YXRlPiB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwcm9wcy5sb2NhdGlvbi5zZWFyY2gpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHBhcmFtcy5nZXQoJ2NvbnRleHQnKSB8fCAnJztcbiAgICBjb25zdCBhbGdvcml0aG0gPSBwYXJhbXMuZ2V0KCdhbGdvcml0aG0nKSB8fCAnJztcbiAgICBjb25zdCB3aGl0ZWxpc3QgPSBwYXJhbXMuZ2V0KCd3aGl0ZWxpc3QnKSB8fCAnJztcbiAgICBjb25zdCBsaW5rSWQgPSBwYXJhbXMuZ2V0KCdsaW5rSWQnKSB8fCAnJztcbiAgICBjb25zdCBwdWJsaXNoZXJOb3RlID0gcGFyYW1zLmdldCgncHVibGlzaGVyTm90ZScpIHx8ICcnO1xuICAgIGNvbnN0IHdpZGdldExvY2F0aW9uID0gcGFyYW1zLmdldCgnd2lkZ2V0TG9jYXRpb24nKSB8fCAnJztcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsaW5rSWQsXG4gICAgICBjb250ZXh0LFxuICAgICAgYWxnb3JpdGhtLFxuICAgICAgd2hpdGVsaXN0LFxuICAgICAgcHVibGlzaGVyTm90ZSxcbiAgICAgIHdpZGdldExvY2F0aW9uLFxuICAgICAgYmxvY2tjaGFpbjoge1xuICAgICAgICB3ZWIzQXZhaWxhYmxlOiBmYWxzZSxcbiAgICAgICAgYmxvY2tOdW1iZXI6IG51bGwsXG4gICAgICAgIGN1cnJlbnRCbG9ja051bWJlcjogbnVsbCxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHRoaXMuX29ic2VydmVCbG9ja2NoYWluU3RhdGUobGlua0lkKTtcbiAgICB0aGlzLl9mZXRjaExpbmtzKGNvbnRleHQsIGFsZ29yaXRobSwgd2hpdGVsaXN0KVxuICAgICAgLnRoZW4odGhpcy5fZmluZExpbmtCeUlkKGxpbmtJZCkpXG4gICAgICAudGhlbigobGluaykgPT4ge1xuICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICBjb25zdCBzZXRUaW1lb3V0Rm9yRmV0Y2ggPSAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fZmV0Y2hMaW5rcyhjb250ZXh0LCBhbGdvcml0aG0sIHdoaXRlbGlzdClcbiAgICAgICAgICAgICAgICAudGhlbih0aGlzLl9maW5kTGlua0J5SWQobGlua0lkKSlcbiAgICAgICAgICAgICAgICAudGhlbigobGluaykgPT4gIWxpbmsgJiYgc2V0VGltZW91dEZvckZldGNoKCkpO1xuICAgICAgICAgICAgfSwgNTAwMCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNldFRpbWVvdXRGb3JGZXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuY29udGV4dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsaW5rSWQsIGNvbnRleHQsIGxpbmssIGJsb2NrY2hhaW4sIHdpZGdldExvY2F0aW9uIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPXtzdHlsZS5zZWxmfT5cbiAgICAgICAgPFBhcGVyIGNsYXNzPXtzdHlsZS5wcmV2aWV3fT5cbiAgICAgICAgICB7bGluayAmJiA8TGluayBsaW5rPXtsaW5rfSAvPn1cbiAgICAgICAgICB7IWxpbmsgJiYgPGRpdiBjbGFzcz17c3R5bGUubG9hZGVyfT48TG9hZGVyIC8+PC9kaXY+fVxuICAgICAgICA8L1BhcGVyPlxuICAgICAgICA8UGFwZXIgY2xhc3M9e3N0eWxlLmNvbnRlbnR9PlxuICAgICAgICAgIDxpbWcgc3JjPXtoZWFydFN2Z30gLz5cbiAgICAgICAgICA8aDI+WW91ciBsaW5rIGhhcyBiZWVuIHN1Y2Nlc2Z1bGx5IHN1Ym1pdGVkITwvaDI+XG4gICAgICAgICAgPHA+SW4gb3JkZXIgdG8gdHJhY2sgaXRzIHByb2dyZXNzIHBsZWFzZSBzYXZlIHRoZSBsaW5rPC9wPlxuICAgICAgICAgIDxUZXh0V2l0aExhYmVsIGNsYXNzPXtzdHlsZS5sYWJlbH0gbGFiZWw9XCJMaW5rIHN0YXR1czpcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLmxpbmtMYWJlbH0+XG4gICAgICAgICAgICAgIDxhIGNsYXNzPXtzdHlsZS5saW5rfSBocmVmPXt3aW5kb3cubG9jYXRpb24uaHJlZn0+e3dpbmRvdy5sb2NhdGlvbi5ocmVmfTwvYT5cbiAgICAgICAgICAgICAgPEJ1dHRvbiBzZWNvbmRhcnkgY2xhc3M9e3N0eWxlLmFkZEJvb2ttYXJrfT5BZGQgdG8gYm9va21hcmtzPC9CdXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L1RleHRXaXRoTGFiZWw+XG4gICAgICAgICAgPFRleHRXaXRoTGFiZWwgY2xhc3M9e3N0eWxlLmxhYmVsfSBsYWJlbD1cIldpZGdldCBsb2NhdGlvbjpcIj5cbiAgICAgICAgICAgIDxhIGhyZWY9e3dpZGdldExvY2F0aW9ufT57d2lkZ2V0TG9jYXRpb259PC9hPlxuICAgICAgICAgIDwvVGV4dFdpdGhMYWJlbD5cbiAgICAgICAgICA8U3RlcHNcbiAgICAgICAgICAgIGxpbmtJZD17bGlua0lkfVxuICAgICAgICAgICAgY29udGV4dD17Y29udGV4dH1cbiAgICAgICAgICAgIGxpbms9e2xpbmt9XG4gICAgICAgICAgICBibG9ja2NoYWluU3RhdGU9e2Jsb2NrY2hhaW59XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9QYXBlcj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBfZmV0Y2hMaW5rcyA9IGFzeW5jIChjb250ZXh0LCBhbGdvcml0aG0sIHdoaXRlbGlzdCkgPT4ge1xuICAgIGNvbnN0IGJhc2VVUkwgPSAnaHR0cHM6Ly9hcGkudXNlcmZlZWRzLmlvL3JhbmtpbmcnO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFsbExpbmtzUmVxdWVzdCA9IGZldGNoKGAke2Jhc2VVUkx9LyR7Y29udGV4dH0vJHthbGdvcml0aG19L2ApXG4gICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpO1xuICAgICAgY29uc3Qgd2hpdGVsaXN0ZWRMaW5rc1JlcXVlc3QgPSBmZXRjaChgJHtiYXNlVVJMfS8ke2NvbnRleHR9LyR7YWxnb3JpdGhtfS8/d2hpdGVsaXN0PSR7d2hpdGVsaXN0fWApXG4gICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpO1xuXG4gICAgICBjb25zdCBbYWxsTGlua3MsIHdoaXRlbGlzdGVkTGlua3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FsbExpbmtzUmVxdWVzdCxcbiAgICAgICAgd2hpdGVsaXN0ZWRMaW5rc1JlcXVlc3RdKTtcbiAgICAgIGNvbnN0IGxpbmtzID0gYWxsTGlua3MuaXRlbXMubWFwKChsaW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IHdoaXRlbGlzdGVkID0gd2hpdGVsaXN0ZWRMaW5rcy5pdGVtcy5maW5kKChhKSA9PiBsaW5rLmlkID09PSBhLmlkKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmxpbmssXG4gICAgICAgICAgd2hpdGVsaXN0ZWQ6ICEhd2hpdGVsaXN0ZWQsXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGxpbmtzO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBfb2JzZXJ2ZUJsb2NrY2hhaW5TdGF0ZSA9IGFzeW5jIChsaW5rSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghd2ViMy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZSh7IGJsb2NrY2hhaW46IHsgLi4udGhpcy5zdGF0ZS5ibG9ja2NoYWluLCB3ZWIzQXZhaWxhYmxlOiBmYWxzZSB9fSk7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoeyBibG9ja2NoYWluOiB7IC4uLnRoaXMuc3RhdGUuYmxvY2tjaGFpbiwgd2ViM0F2YWlsYWJsZTogdHJ1ZSB9fSk7XG5cbiAgICBjb25zdCBbLCB0eF0gPSBsaW5rSWQuc3BsaXQoJzonKTtcblxuICAgIGxldCByZWNlaXB0O1xuICAgIGRvIHtcbiAgICAgIHJlY2VpcHQgPSBhd2FpdCBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHgpO1xuICAgICAgYXdhaXQgd2FpdCgxMDAwKTtcbiAgICB9IHdoaWxlICghcmVjZWlwdCk7XG5cbiAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBhd2FpdCBnZXRCbG9ja051bWJlcigpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYmxvY2tjaGFpbjoge1xuICAgICAgICAuLi50aGlzLnN0YXRlLmJsb2NrY2hhaW4sXG4gICAgICAgIGJsb2NrTnVtYmVyOiByZWNlaXB0LmJsb2NrTnVtYmVyLFxuICAgICAgICBjdXJyZW50QmxvY2tOdW1iZXIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGF3YWl0IHdhaXQoMTAwMDApO1xuICAgICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gYXdhaXQgZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBibG9ja2NoYWluOiB7IC4uLnRoaXMuc3RhdGUuYmxvY2tjaGFpbiwgY3VycmVudEJsb2NrTnVtYmVyIH19KTtcbiAgICB9XG4gIH1cblxuICBfZmluZExpbmtCeUlkID0gKGxpbmtJZCkgPT4gKGxpbmtzKSA9PiB7XG4gICAgY29uc3QgbGluayA9IGxpbmtzLmZpbmQoKGwpID0+IGwuaWQgPT09IGxpbmtJZCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxpbmsgfSk7XG5cbiAgICByZXR1cm4gbGluaztcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BhZ2VzL1N0YXR1cy9pbmRleC50c3giLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2lucHV0LnNjc3MnO1xuXG5jb25zdCBjeCA9IGNsYXNzbmFtZXMuYmluZChzdHlsZSk7XG5cbnR5cGUgVElucHV0UHJvcHMgPSBKU1guSFRNTEF0dHJpYnV0ZXMgJiB7XG4gIHBsYWNlaG9sZGVyOiBzdHJpbmc7XG4gIG9uQ2hhbmdlKHZhbHVlOiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpOiB2b2lkO1xuICBtdWx0aWxpbmU/OiBib29sZWFuO1xuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCBleHRlbmRzIENvbXBvbmVudDxUSW5wdXRQcm9wcywge30+IHtcblxuICBpbnB1dDoge1xuICAgIGZvY3VzKCk6IHZvaWQ7XG4gIH0gfCB1bmRlZmluZWQ7XG5cbiAgcmVuZGVyKHsgY2xhc3M6IGNsYXNzTmFtZSwgcGxhY2Vob2xkZXIsIGVycm9yTWVzc2FnZSwgdmFsdWUsIG9uQ2hhbmdlLCBtdWx0aWxpbmUsIGRpc2FibGVkID0gZmFsc2UsIC4uLnJlc3RQcm9wcyB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e2N4KHN0eWxlLnNlbGYsIHsgaW52YWxpZDogISFlcnJvck1lc3NhZ2UgfSl9PlxuICAgICAgICB7IW11bHRpbGluZSA/IChcbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHJlZj17dGhpcy5fb25JbnB1dFJlZn1cbiAgICAgICAgICAgIGNsYXNzPXtzdHlsZS5pbnB1dH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICBvbklucHV0PXt0aGlzLl9vbkNoYW5nZX1cbiAgICAgICAgICAgIHsuLi5yZXN0UHJvcHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgIHJlZj17dGhpcy5fb25JbnB1dFJlZn1cbiAgICAgICAgICAgIGNsYXNzPXtzdHlsZS5pbnB1dH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICBvbklucHV0PXt0aGlzLl9vbkNoYW5nZX1cbiAgICAgICAgICAgIHJvd3M9ezN9XG4gICAgICAgICAgICB7Li4ucmVzdFByb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIDxzcGFuIGNsYXNzPXtzdHlsZS5wbGFjZWhvbGRlcn0gb25DbGljaz17dGhpcy5fb25QbGFjZWhvbGRlckNsaWNrfT57cGxhY2Vob2xkZXJ9PC9zcGFuPlxuICAgICAgICB7ZXJyb3JNZXNzYWdlICYmIDxzcGFuIGNsYXNzPXtzdHlsZS5lcnJvcn0+e2Vycm9yTWVzc2FnZX08L3NwYW4+fVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIF9vbkNoYW5nZSA9IChlKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZShlLnRhcmdldC52YWx1ZSwgdGhpcy5wcm9wcy5uYW1lKTtcbiAgfVxuXG4gIF9vbklucHV0UmVmID0gKHJlZikgPT4gdGhpcy5pbnB1dCA9IHJlZjtcblxuICBfb25QbGFjZWhvbGRlckNsaWNrID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvSW5wdXQudHN4IiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9hZHNMaXN0LnNjc3MnO1xuXG5jb25zdCBub29wID0gKCkgPT4gbnVsbDtcblxuaW50ZXJmYWNlIElBZFByb3BzIHtcbiAgYWQ6IGFueTtcbiAgb25DbGljayhpdGVtOiBhbnkpOiB2b2lkO1xufVxuXG5jb25zdCBBZCA9ICh7IGFkLCBvbkNsaWNrIH06IElBZFByb3BzKSA9PiAoXG4gIDxkaXYgY2xhc3M9e3N0eWxlLnJvd30+XG4gICAgPGRpdj5cbiAgICAgIDxkaXY+VVJMOiA8YSBocmVmPXthZC50YXJnZXR9PnthZC50YXJnZXR9PC9hPjwvZGl2PlxuICAgICAgPGRpdj5zY29yZToge3dlYjMuZnJvbVdlaShhZC5zY29yZSwgJ2V0aGVyJyl9PC9kaXY+XG4gICAgICA8ZGl2PnthZC50aXRsZX08L2Rpdj5cbiAgICAgIDxkaXY+e2FkLnN1bW1hcnl9PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz17c3R5bGUuYnV0dG9ufT5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgb25DbGljaz17b25DbGljay5iaW5kKG51bGwsIGFkKX1cbiAgICAgICAgZGlzYWJsZWQ9e2FkLndoaXRlbGlzdGVkfVxuICAgICAgPlxuICAgICAgICBBZGQgdG8gd2hpdGVsaXN0XG4gICAgICA8L0J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4pO1xuXG5pbnRlcmZhY2UgSUFkc0xpc3RQcm9wcyB7XG4gIGFkczogYW55W107XG4gIG9uSXRlbUNsaWNrPzogKGl0ZW06IGFueSkgPT4gdm9pZDtcbn1cblxuY29uc3QgQWRzTGlzdCA9ICh7IGFkcyA9IFtdLCBvbkl0ZW1DbGljayA9IG5vb3AgfTogSUFkc0xpc3RQcm9wcykgPT4gKFxuICA8ZGl2IGNsYXNzPXtzdHlsZS5zZWxmfT5cbiAgICB7YWRzLm1hcCgoYWQpID0+ICg8QWQgYWQ9e2FkfSBvbkNsaWNrPXtvbkl0ZW1DbGlja30gLz4pKX1cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBBZHNMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0Fkc0xpc3QudHN4IiwiaW1wb3J0IHsgaCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnQHVzZXJmZWVkcy9jb3JlJztcblxuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSc7XG5cbi8vIGltcG9ydCBDaXJjdWxhclByb2dyZXNzIGZyb20gJ21hdGVyaWFsLXVpL0NpcmN1bGFyUHJvZ3Jlc3MnO1xuXG5pbXBvcnQgSW5wdXQgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0lucHV0JztcbmltcG9ydCBQYXBlciBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvUGFwZXInO1xuaW1wb3J0IEFkc0xpc3QgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0Fkc0xpc3QnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL1doaXRlbGlzdC5zY3NzJztcblxuaW50ZXJmYWNlIElXaGl0ZWxpc3RQcm9wcyB7XG4gIGxvY2F0aW9uOiBhbnk7XG59XG5cbmludGVyZmFjZSBJV2hpdGVsaXN0U3RhdGUge1xuICBsaW5rczogYW55W107XG4gIGZldGNoaW5nOiBib29sZWFuO1xuICBjb250ZXh0OiBzdHJpbmc7XG4gIGFsZ29yaXRobTogc3RyaW5nO1xuICB3aGl0ZWxpc3Q6IHN0cmluZztcbiAgY29udGV4dEZyb21QYXJhbXM6IGJvb2xlYW47XG4gIHdoaXRlbGlzdEZyb21QYXJhbXM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyZWF0b3IgZXh0ZW5kcyBDb21wb25lbnQ8SVdoaXRlbGlzdFByb3BzLCBJV2hpdGVsaXN0U3RhdGU+IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocHJvcHMubG9jYXRpb24uc2VhcmNoKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsaW5rczogW10sXG4gICAgICBmZXRjaGluZzogZmFsc2UsXG4gICAgICBjb250ZXh0OiBwYXJhbXMuZ2V0KCdjb250ZXh0JykgfHwgJycsXG4gICAgICBhbGdvcml0aG06IHBhcmFtcy5nZXQoJ2FsZ29yaXRobScpIHx8ICdsaW5rcycsXG4gICAgICB3aGl0ZWxpc3Q6IHBhcmFtcy5nZXQoJ3doaXRlbGlzdCcpIHx8ICcnLFxuICAgICAgY29udGV4dEZyb21QYXJhbXM6IHBhcmFtcy5oYXMoJ2NvbnRleHQnKSxcbiAgICAgIHdoaXRlbGlzdEZyb21QYXJhbXM6IHBhcmFtcy5oYXMoJ3doaXRlbGlzdCcpLFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuY29udGV4dEZyb21QYXJhbXMpIHtcbiAgICAgIHRoaXMuX2ZldGNoTGlua3MoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgICAgICA8UGFwZXIgY2xhc3M9e3N0eWxlLnBhcGVyfT5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVXNlcmZlZWQgSURcIlxuICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuY29udGV4dH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkNvbnRleHRDaGFuZ2V9XG4gICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5zdGF0ZS5jb250ZXh0RnJvbVBhcmFtc31cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJXaGl0ZWxpc3QgSURcIlxuICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUud2hpdGVsaXN0fVxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uV2hpdGVsaXN0Q2hhbmdlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUud2hpdGVsaXN0RnJvbVBhcmFtc31cbiAgICAgICAgICAvPlxuXG4gICAgICAgICAgPEFkc0xpc3QgYWRzPXt0aGlzLnN0YXRlLmxpbmtzfSBvbkl0ZW1DbGljaz17dGhpcy5fb25MaW5rQ2xpY2t9IC8+XG4gICAgICAgICAgey8qIHt0aGlzLnN0YXRlLmZldGNoaW5nICYmIDxDaXJjdWxhclByb2dyZXNzIC8+fSAqL31cbiAgICAgICAgPC9QYXBlcj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBfb25Db250ZXh0Q2hhbmdlID0gKGNvbnRleHQpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgY29udGV4dCB9KTtcbiAgICB0aGlzLl9mZXRjaExpbmtzKCk7XG4gIH1cblxuICBfb25XaGl0ZWxpc3RDaGFuZ2UgPSAod2hpdGVsaXN0KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHdoaXRlbGlzdCB9KTtcbiAgICB0aGlzLl9mZXRjaExpbmtzKCk7XG4gIH1cblxuICBfZmV0Y2hMaW5rcyA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGFsZ29yaXRobSwgd2hpdGVsaXN0IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZldGNoaW5nOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgYmFzZVVSTCA9ICdodHRwczovL2FwaS51c2VyZmVlZHMuaW8vcmFua2luZyc7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsTGlua3NSZXF1ZXN0ID0gZmV0Y2goYCR7YmFzZVVSTH0vJHtjb250ZXh0fS8ke2FsZ29yaXRobX0vYClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG4gICAgICBjb25zdCB3aGl0ZWxpc3RlZExpbmtzUmVxdWVzdCA9IGZldGNoKGAke2Jhc2VVUkx9LyR7Y29udGV4dH0vJHthbGdvcml0aG19Lz93aGl0ZWxpc3Q9JHt3aGl0ZWxpc3R9YClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG5cbiAgICAgIGNvbnN0IFthbGxMaW5rcywgd2hpdGVsaXN0ZWRMaW5rc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGFsbExpbmtzUmVxdWVzdCxcbiAgICAgICAgd2hpdGVsaXN0ZWRMaW5rc1JlcXVlc3QsXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgbGlua3MgPSBhbGxMaW5rcy5pdGVtcy5tYXAoKGxpbmspID0+IHtcbiAgICAgICAgY29uc3Qgd2hpdGVsaXN0ZWQgPSAhIXdoaXRlbGlzdGVkTGlua3MuaXRlbXMuZmluZCgoYSkgPT4gbGluay5pZCA9PT0gYS5pZCk7XG5cbiAgICAgICAgcmV0dXJuIHsgLi4ubGluaywgd2hpdGVsaXN0ZWQgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxpbmtzLCBmZXRjaGluZzogZmFsc2UgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZldGNoaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gIH0sIDUwMCk7XG5cbiAgX29uTGlua0NsaWNrID0gKGxpbmspID0+IHtcbiAgICBjb25zdCBbXywgYWRkcmVzc10gPSB0aGlzLnN0YXRlLndoaXRlbGlzdC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IGNsYWltID0ge1xuICAgICAgY2xhaW06IHsgdGFyZ2V0OiBsaW5rLmlkIH0sXG4gICAgICBjcmVkaXRzOiBbe1xuICAgICAgICB0eXBlOiAnaW50ZXJmYWNlJyxcbiAgICAgICAgdmFsdWU6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgfV0sXG4gICAgfTtcblxuICAgIGNvcmUuZXRoZXJldW0uY2xhaW1zLnNlbmRDbGFpbShhZGRyZXNzLCBjbGFpbSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wYWdlcy9XaGl0ZWxpc3QudHN4IiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vbGlua0xpc3Quc2Nzcyc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiBudWxsO1xuXG5pbnRlcmZhY2UgSUxpbmtQcm9wcyB7XG4gIGxpbms6IGFueTtcbn1cblxuY29uc3QgTGluayA9ICh7IGxpbmsgfTogSUxpbmtQcm9wcykgPT4gKFxuICA8ZGl2IGNsYXNzPXtzdHlsZS5yb3d9PlxuICAgIDxkaXY+XG4gICAgICA8ZGl2PlVSTDogPGEgaHJlZj17bGluay50YXJnZXR9PntsaW5rLnRhcmdldH08L2E+PC9kaXY+XG4gICAgICA8ZGl2PntsaW5rLnN1bW1hcnl9PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuKTtcblxuaW50ZXJmYWNlIElMaW5rTGlzdFByb3BzIHtcbiAgbGlua3M6IGFueVtdO1xuICBvbkl0ZW1DbGljaz86IChpdGVtOiBhbnkpID0+IHZvaWQ7XG59XG5cbmNvbnN0IExpbmtMaXN0ID0gKHsgbGlua3MgPSBbXX06IElMaW5rTGlzdFByb3BzKSA9PiAoXG4gIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgIHtsaW5rcy5tYXAoKGxpbmspID0+ICg8TGluayBsaW5rPXtsaW5rfSAvPikpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0xpbmtMaXN0LnRzeCIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcblxuLy8gaW1wb3J0IENpcmN1bGFyUHJvZ3Jlc3MgZnJvbSAnbWF0ZXJpYWwtdWkvQ2lyY3VsYXJQcm9ncmVzcyc7XG5cbmltcG9ydCBJbnB1dCBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvSW5wdXQnO1xuaW1wb3J0IFBhcGVyIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9QYXBlcic7XG5pbXBvcnQgTGlua0xpc3RDb21wb25lbnQgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0xpbmtMaXN0JztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9XaGl0ZWxpc3Quc2Nzcyc7XG5cbmludGVyZmFjZSBJTGlua0xpc3RQcm9wcyB7XG4gIGxvY2F0aW9uOiBhbnk7XG59XG5cbmludGVyZmFjZSBJTGlua0xpc3RTdGF0ZSB7XG4gIGxpbmtzOiBhbnlbXTtcbiAgZmV0Y2hpbmc6IGJvb2xlYW47XG4gIGNvbnRleHQ6IHN0cmluZztcbiAgY29udGV4dEZyb21QYXJhbXM6IGJvb2xlYW47XG4gIGFsZ29yaXRobTogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rTGlzdCBleHRlbmRzIENvbXBvbmVudDxJTGlua0xpc3RQcm9wcywgSUxpbmtMaXN0U3RhdGU+IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocHJvcHMubG9jYXRpb24uc2VhcmNoKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsaW5rczogW10sXG4gICAgICBmZXRjaGluZzogZmFsc2UsXG4gICAgICBjb250ZXh0OiBwYXJhbXMuZ2V0KCdjb250ZXh0JykgfHwgJycsXG4gICAgICBhbGdvcml0aG06IHBhcmFtcy5nZXQoJ2FsZ29yaXRobScpIHx8ICdsaW5rcycsXG4gICAgICBjb250ZXh0RnJvbVBhcmFtczogcGFyYW1zLmhhcygnY29udGV4dCcpLFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuY29udGV4dEZyb21QYXJhbXMpIHtcbiAgICAgIHRoaXMuX2ZldGNoTGlua3MoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgICAgICA8UGFwZXIgY2xhc3M9e3N0eWxlLnBhcGVyfT5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQWR2ZXJ0aXNlciBJRFwiXG4gICAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5jb250ZXh0fVxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uQ29udGV4dENoYW5nZX1cbiAgICAgICAgICAgIGRpc2FibGVkPXt0aGlzLnN0YXRlLmNvbnRleHRGcm9tUGFyYW1zfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPExpbmtMaXN0Q29tcG9uZW50IGxpbmtzPXt0aGlzLnN0YXRlLmxpbmtzfSAvPlxuICAgICAgICAgIHsvKiB7dGhpcy5zdGF0ZS5mZXRjaGluZyAmJiA8Q2lyY3VsYXJQcm9ncmVzcyAvPn0gKi99XG4gICAgICAgIDwvUGFwZXI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgX29uQ29udGV4dENoYW5nZSA9IChjb250ZXh0KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGNvbnRleHQgfSk7XG4gICAgdGhpcy5fZmV0Y2hMaW5rcygpO1xuICB9XG5cbiAgX2ZldGNoTGlua3MgPSBkZWJvdW5jZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjb250ZXh0IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZldGNoaW5nOiB0cnVlIH0pO1xuICAgIGNvbnN0IGZldGNoVXJsID0gJ2h0dHBzOi8vYXBpLnVzZXJmZWVkcy5pby9yYW5raW5nJztcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhbGxMaW5rc1JlcXVlc3QgPSBmZXRjaChgJHtmZXRjaFVybH0vJHtjb250ZXh0fS9hdXRob3JlZC8/dHlwZT1saW5rYClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG5cbiAgICAgIGNvbnN0IFthbGxMaW5rc10gPSBhd2FpdCBQcm9taXNlLmFsbChbYWxsTGlua3NSZXF1ZXN0XSk7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsaW5rczogYWxsTGlua3MuaXRlbXMsIGZldGNoaW5nOiBmYWxzZSB9KTtcblxuICAgICAgcmV0dXJuIGFsbExpbmtzO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmZXRjaGluZzogZmFsc2UgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIDUwMCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGFnZXMvTGlua0xpc3QudHN4IiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQge1xuICBIYXNoUm91dGVyIGFzIFJvdXRlcixcbiAgUm91dGUsXG59IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG5pbXBvcnQgSG9tZSBmcm9tICcuL3BhZ2VzL0hvbWUnO1xuaW1wb3J0IFN0YXR1cyBmcm9tICcuL3BhZ2VzL1N0YXR1cyc7XG5pbXBvcnQgV2hpdGVsaXN0IGZyb20gJy4vcGFnZXMvV2hpdGVsaXN0JztcbmltcG9ydCBMaW5rTGlzdCBmcm9tICcuL3BhZ2VzL0xpbmtMaXN0JztcblxuY29uc3QgQXBwID0gKCkgPT4gKFxuICA8Um91dGVyPlxuICAgIDxkaXY+XG4gICAgICA8Um91dGUgZXhhY3QgcGF0aD1cIi9cIiBjb21wb25lbnQ9e0hvbWV9IC8+XG4gICAgICA8Um91dGUgcGF0aD1cIi9zdGF0dXNcIiBjb21wb25lbnQ9e1N0YXR1c30gLz5cbiAgICAgIDxSb3V0ZSBwYXRoPVwiL3doaXRlbGlzdFwiIGNvbXBvbmVudD17V2hpdGVsaXN0fSAvPlxuICAgICAgPFJvdXRlIHBhdGg9XCIvbGlua2xpc3RcIiBjb21wb25lbnQ9e0xpbmtMaXN0fSAvPlxuICAgIDwvZGl2PlxuICA8L1JvdXRlcj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9BcHAudHN4IiwiaW1wb3J0IHsgaCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAnbm9ybWFsaXplLmNzcyc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuaW1wb3J0ICcuLi9zdHlsZXMvYWxsLnNjc3MnO1xuXG5jb25zdCByb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJvb3QnKTtcblxuaWYgKHJvb3QpIHtcbiAgcmVuZGVyKDxBcHAgLz4sIHJvb3QpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LnRzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vU3RhdHVzLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9TdGF0dXMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL1N0YXR1cy5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wYWdlcy9TdGF0dXMvU3RhdHVzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3N0ZXBzLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9zdGVwcy5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vc3RlcHMuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL1doaXRlbGlzdC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vV2hpdGVsaXN0LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9XaGl0ZWxpc3Quc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vYWxsLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9hbGwuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2FsbC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy9hbGwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zdHlsZXMvYWxsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==