/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/apps/links/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@userfeeds/core/index.js":
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
  ethereum: {
    claims: __webpack_require__("../../node_modules/@userfeeds/core/src/ethereumClaims.js"),
  },
  utils: __webpack_require__("../../node_modules/@userfeeds/core/src/utils/index.js"),
};


/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/ethereumClaims.js":
/***/ (function(module, exports, __webpack_require__) {

const { getCurrentNetworkName } = __webpack_require__("../../node_modules/@userfeeds/core/src/utils/index.js");
const {
  payableAbi,
  notpayableAbi,
  getContractAddress,
} = __webpack_require__("../../node_modules/@userfeeds/core/src/utils/contract.js");

function sendPayableClaim(address, claim, value) {
  const contract = web3.eth.contract(payableAbi)
    .at(getContractAddress(getCurrentNetworkName(), true));

  return new Promise((resolve, reject) => {
    contract.post(
      address,
      JSON.stringify(claim),
      { value: web3.toWei(value, 'ether') },
      (errror, result) => {
        if (errror) {
          return reject(errror);
        }
        return resolve(result);
      },
    );
  });
}

function sendNotpayableClaim(address, claim) {
  const contract = web3.eth.contract(notpayableAbi)
    .at(getContractAddress(getCurrentNetworkName(), false));

  return new Promise((resolve, reject) => {
    contract.post(
      JSON.stringify(claim),
      (errror, result) => {
        if (errror) {
          return reject(errror);
        }
        return resolve(result);
      },
    );
  });
}

function sendClaim(address, claim, value) {
  const payable = value !== undefined;

  return payable
    ? sendPayableClaim(address, claim, value)
    : sendNotpayableClaim(address, claim);
}

module.exports = {
  sendClaim,
  sendPayableClaim,
  sendNotpayableClaim,
};



/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/utils/contract.js":
/***/ (function(module, exports) {


const payableContractAddressMapping = {
  ropsten: '0xa845c686a696c3d33988917c387d8ab939c66226',
  rinkeby: '0x0a48ac8263d9d79768d10cf9d7e82a19c49f0002',
};

const notpayableContractAddressMapping = {
  ropsten: '0x5c3fe6b94b57c1e294000403340f12f083e71b83',
  rinkeby: '0x09dcdf34e0c28b106fdfe51009cb71ae92bf8bbc',
};

function getContractAddress(networkName, payable = true) {
  let contract;
  if (payable) {
    contract = payableContractAddressMapping[networkName];
  } else {
    contract = notpayableContractAddressMapping[networkName];
  }

  if (!contract) {
    throw new Error('Contract is not available');
  }

  return contract;
}

const payableAbi = [{
  constant: false,
  inputs: [
    { name: 'userfeed', type: 'address' },
    { name: 'data', type: 'string' },
  ],
  name: 'post',
  outputs: [],
  payable: true,
  type: 'function',
}, {
  anonymous: false,
  inputs: [
    { name: 'sender', type: 'address', indexed: false },
    { name: 'userfeed', type: 'address', indexed: false },
    { name: 'data', type: 'string', indexed: false },
  ],
  name: 'Claim',
  type: 'event',
}];

const notpayableAbi = [{
  constant: false,
  inputs: [
    { name: 'data', type: 'string' },
  ],
  name: 'post',
  outputs: [],
  payable: false,
  type: 'function',
}, {
  anonymous: false,
  inputs: [
    { name: 'sender', type: 'address', indexed: false },
    { name: 'data', type: 'string', indexed: false },
  ],
  name: 'Claim',
  type: 'event'
}];

module.exports = {
  payableAbi,
  notpayableAbi,
  getContractAddress,
};


/***/ }),

/***/ "../../node_modules/@userfeeds/core/src/utils/index.js":
/***/ (function(module, exports) {


const networkMapping = {
  '1': 'ethereum',
  '3': 'ropsten',
  '4': 'rinkeby',
  '42': 'kovan',
};

function getCurrentNetworkName() {
  if (!web3) {
    throw new Error('web3 not available');
  }

  return networkMapping[web3.version.network];
}

module.exports = {
  getCurrentNetworkName,
};



/***/ }),

/***/ "../../node_modules/base64-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ "../../node_modules/bignumber.js/bignumber.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! bignumber.js v2.0.7 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (global) {
    'use strict';

    /*
      bignumber.js v2.0.7
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2015 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var BigNumber, crypto, parseNumeric,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32


    /*
     * Create and return a BigNumber constructor.
     */
    function another(configObj) {
        var div,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 100,                     // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 ) raise( id, tooManyDigits, x.s * n );

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = another;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    CRYPTO = !!( v && crypto && typeof crypto == 'object' );
                    if ( v && !CRYPTO && ERRORS ) raise( 2, 'crypto unavailable', crypto );
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if ( crypto && crypto.getRandomValues ) {

                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = crypto.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if ( crypto && crypto.randomBytes ) {

                        // buffer
                        a = crypto.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                crypto.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else if (ERRORS) {
                        raise( 14, 'crypto unavailable', crypto );
                    }
                }

                // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
                if (!i) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc.unshift(1);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x.unshift(carry);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.shift() );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz.unshift(0);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod.unshift(0);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.shift();
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix = /^(-?)0([xbo])/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on ±Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ sd % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is ±Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.shift(), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return ±Infinity if either ±Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] %= BASE;
            }

            if (a) {
                xc.unshift(a);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be ±0 if k < 0, or ±Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, ±Infinity or ±0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return ±Infinity if either is ±Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return ±0 if either is ±0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.shift();
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            var x = this;

            // Ensure zero has correct sign.
            return +x || ( x.s ? x.s * 0 : NaN );
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is not 0, round to POW_PRECISION using ROUNDING_MODE.
         *
         * n {number} Integer, -9007199254740992 to 9007199254740992 inclusive.
         * (Performs 54 loop iterations for n of 9007199254740992.)
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         */
        P.toPower = P.pow = function (n) {
            var k, y,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            // Pass ±Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) ) {
                return new BigNumber( Math.pow( +x, n ) );
            }

            // Truncating each coefficient array to a length of k after each multiplication equates
            // to truncating significant digits to POW_PRECISION + [28, 41], i.e. there will be a
            // minimum of 28 guard digits retained. (Using + 1.5 would give [9, 21] guard digits.)
            k = POW_PRECISION ? mathceil( POW_PRECISION / LOG_BASE + 2 ) : 0;
            y = new BigNumber(ONE);

            for ( ; ; ) {

                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if ( k && y.c.length > k ) y.c.length = k;
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;

                x = x.times(x);
                if ( k && x.c && x.c.length > k ) x.c.length = k;
            }

            if ( n < 0 ) y = ONE.div(y);
            return k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };



        /*
         * Return as toString, but do not accept a base argument.
         */
        P.valueOf = P.toJSON = function () {
            return this.toString();
        };


        // Aliases for BigDecimal methods.
        //P.add = P.plus;         // P.add included above
        //P.subtract = P.minus;   // P.sub included above
        //P.multiply = P.times;   // P.mul included above
        //P.divide = P.div;
        //P.remainder = P.mod;
        //P.compareTo = P.cmp;
        //P.negate = P.neg;


        if ( configObj != null ) BigNumber.config(configObj);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


    BigNumber = another();

    // AMD.
    if ( true ) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return BigNumber; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

    // Node and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = BigNumber;
        if ( !crypto ) try { crypto = require('crypto'); } catch (e) {}

    // Browser.
    } else {
        global.BigNumber = BigNumber;
    }
})(this);


/***/ }),

/***/ "../../node_modules/buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("../../node_modules/base64-js/index.js")
var ieee754 = __webpack_require__("../../node_modules/ieee754/index.js")
var isArray = __webpack_require__("../../node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/classnames/bind.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(this && this[arg] || arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(this, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(this && this[key] || key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),

/***/ "../../node_modules/classnames/index.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),

/***/ "../../node_modules/crypto-js/aes.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/cipher-core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;

	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }
	            this._mode = modeCreator.call(mode, this, iv && iv.words);
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ "../../node_modules/crypto-js/core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/enc-base64.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/enc-utf16.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/evpkdf.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/format-hex.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/hmac.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ "../../node_modules/crypto-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"), __webpack_require__("../../node_modules/crypto-js/lib-typedarrays.js"), __webpack_require__("../../node_modules/crypto-js/enc-utf16.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/sha256.js"), __webpack_require__("../../node_modules/crypto-js/sha224.js"), __webpack_require__("../../node_modules/crypto-js/sha512.js"), __webpack_require__("../../node_modules/crypto-js/sha384.js"), __webpack_require__("../../node_modules/crypto-js/sha3.js"), __webpack_require__("../../node_modules/crypto-js/ripemd160.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"), __webpack_require__("../../node_modules/crypto-js/pbkdf2.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"), __webpack_require__("../../node_modules/crypto-js/mode-cfb.js"), __webpack_require__("../../node_modules/crypto-js/mode-ctr.js"), __webpack_require__("../../node_modules/crypto-js/mode-ctr-gladman.js"), __webpack_require__("../../node_modules/crypto-js/mode-ofb.js"), __webpack_require__("../../node_modules/crypto-js/mode-ecb.js"), __webpack_require__("../../node_modules/crypto-js/pad-ansix923.js"), __webpack_require__("../../node_modules/crypto-js/pad-iso10126.js"), __webpack_require__("../../node_modules/crypto-js/pad-iso97971.js"), __webpack_require__("../../node_modules/crypto-js/pad-zeropadding.js"), __webpack_require__("../../node_modules/crypto-js/pad-nopadding.js"), __webpack_require__("../../node_modules/crypto-js/format-hex.js"), __webpack_require__("../../node_modules/crypto-js/aes.js"), __webpack_require__("../../node_modules/crypto-js/tripledes.js"), __webpack_require__("../../node_modules/crypto-js/rc4.js"), __webpack_require__("../../node_modules/crypto-js/rabbit.js"), __webpack_require__("../../node_modules/crypto-js/rabbit-legacy.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/lib-typedarrays.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/md5.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-cfb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ctr-gladman.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ctr.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ecb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/mode-ofb.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-ansix923.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-iso10126.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-iso97971.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-nopadding.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pad-zeropadding.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/pbkdf2.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha1.js"), __webpack_require__("../../node_modules/crypto-js/hmac.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rabbit-legacy.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rabbit.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/rc4.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/ripemd160.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha1.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha224.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/sha256.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha256.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha3.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha384.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"), __webpack_require__("../../node_modules/crypto-js/sha512.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/sha512.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/x64-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/tripledes.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"), __webpack_require__("../../node_modules/crypto-js/enc-base64.js"), __webpack_require__("../../node_modules/crypto-js/md5.js"), __webpack_require__("../../node_modules/crypto-js/evpkdf.js"), __webpack_require__("../../node_modules/crypto-js/cipher-core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));

/***/ }),

/***/ "../../node_modules/crypto-js/x64-core.js":
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__("../../node_modules/crypto-js/core.js"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));

/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/normalize.css/normalize.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}[hidden],template{display:none}", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/open-iconic/font/css/open-iconic.min.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, "@font-face{font-family:Icons;src:url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.eot") + ");src:url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.eot") + "?#iconic-sm) format(\"embedded-opentype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.woff") + ") format(\"woff\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.ttf") + ") format(\"truetype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.otf") + ") format(\"opentype\"),url(" + __webpack_require__("../../node_modules/open-iconic/font/fonts/open-iconic.svg") + "#iconic-sm) format(\"svg\");font-weight:400;font-style:normal}.oi[data-glyph].oi-text-replace{font-size:0;line-height:0}.oi[data-glyph].oi-text-replace:before{width:1em;text-align:center}.oi[data-glyph]:before{font-family:Icons;display:inline-block;speak:none;line-height:1;vertical-align:baseline;font-weight:400;font-style:normal;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.oi[data-glyph]:empty:before{width:1em;text-align:center;box-sizing:content-box}.oi[data-glyph].oi-align-left:before{text-align:left}.oi[data-glyph].oi-align-right:before{text-align:right}.oi[data-glyph].oi-align-center:before{text-align:center}.oi[data-glyph].oi-flip-horizontal:before{-webkit-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1)}.oi[data-glyph].oi-flip-vertical:before{-webkit-transform:scaleY(-1);-ms-transform:scaleX(-1);transform:scaleY(-1)}.oi[data-glyph].oi-flip-horizontal-vertical:before{-webkit-transform:scale(-1);-ms-transform:scaleX(-1);transform:scale(-1)}.oi[data-glyph=account-login]:before{content:\"\\E000\"}.oi[data-glyph=account-logout]:before{content:\"\\E001\"}.oi[data-glyph=action-redo]:before{content:\"\\E002\"}.oi[data-glyph=action-undo]:before{content:\"\\E003\"}.oi[data-glyph=align-center]:before{content:\"\\E004\"}.oi[data-glyph=align-left]:before{content:\"\\E005\"}.oi[data-glyph=align-right]:before{content:\"\\E006\"}.oi[data-glyph=aperture]:before{content:\"\\E007\"}.oi[data-glyph=arrow-bottom]:before{content:\"\\E008\"}.oi[data-glyph=arrow-circle-bottom]:before{content:\"\\E009\"}.oi[data-glyph=arrow-circle-left]:before{content:\"\\E00A\"}.oi[data-glyph=arrow-circle-right]:before{content:\"\\E00B\"}.oi[data-glyph=arrow-circle-top]:before{content:\"\\E00C\"}.oi[data-glyph=arrow-left]:before{content:\"\\E00D\"}.oi[data-glyph=arrow-right]:before{content:\"\\E00E\"}.oi[data-glyph=arrow-thick-bottom]:before{content:\"\\E00F\"}.oi[data-glyph=arrow-thick-left]:before{content:\"\\E010\"}.oi[data-glyph=arrow-thick-right]:before{content:\"\\E011\"}.oi[data-glyph=arrow-thick-top]:before{content:\"\\E012\"}.oi[data-glyph=arrow-top]:before{content:\"\\E013\"}.oi[data-glyph=audio-spectrum]:before{content:\"\\E014\"}.oi[data-glyph=audio]:before{content:\"\\E015\"}.oi[data-glyph=badge]:before{content:\"\\E016\"}.oi[data-glyph=ban]:before{content:\"\\E017\"}.oi[data-glyph=bar-chart]:before{content:\"\\E018\"}.oi[data-glyph=basket]:before{content:\"\\E019\"}.oi[data-glyph=battery-empty]:before{content:\"\\E01A\"}.oi[data-glyph=battery-full]:before{content:\"\\E01B\"}.oi[data-glyph=beaker]:before{content:\"\\E01C\"}.oi[data-glyph=bell]:before{content:\"\\E01D\"}.oi[data-glyph=bluetooth]:before{content:\"\\E01E\"}.oi[data-glyph=bold]:before{content:\"\\E01F\"}.oi[data-glyph=bolt]:before{content:\"\\E020\"}.oi[data-glyph=book]:before{content:\"\\E021\"}.oi[data-glyph=bookmark]:before{content:\"\\E022\"}.oi[data-glyph=box]:before{content:\"\\E023\"}.oi[data-glyph=briefcase]:before{content:\"\\E024\"}.oi[data-glyph=british-pound]:before{content:\"\\E025\"}.oi[data-glyph=browser]:before{content:\"\\E026\"}.oi[data-glyph=brush]:before{content:\"\\E027\"}.oi[data-glyph=bug]:before{content:\"\\E028\"}.oi[data-glyph=bullhorn]:before{content:\"\\E029\"}.oi[data-glyph=calculator]:before{content:\"\\E02A\"}.oi[data-glyph=calendar]:before{content:\"\\E02B\"}.oi[data-glyph=camera-slr]:before{content:\"\\E02C\"}.oi[data-glyph=caret-bottom]:before{content:\"\\E02D\"}.oi[data-glyph=caret-left]:before{content:\"\\E02E\"}.oi[data-glyph=caret-right]:before{content:\"\\E02F\"}.oi[data-glyph=caret-top]:before{content:\"\\E030\"}.oi[data-glyph=cart]:before{content:\"\\E031\"}.oi[data-glyph=chat]:before{content:\"\\E032\"}.oi[data-glyph=check]:before{content:\"\\E033\"}.oi[data-glyph=chevron-bottom]:before{content:\"\\E034\"}.oi[data-glyph=chevron-left]:before{content:\"\\E035\"}.oi[data-glyph=chevron-right]:before{content:\"\\E036\"}.oi[data-glyph=chevron-top]:before{content:\"\\E037\"}.oi[data-glyph=circle-check]:before{content:\"\\E038\"}.oi[data-glyph=circle-x]:before{content:\"\\E039\"}.oi[data-glyph=clipboard]:before{content:\"\\E03A\"}.oi[data-glyph=clock]:before{content:\"\\E03B\"}.oi[data-glyph=cloud-download]:before{content:\"\\E03C\"}.oi[data-glyph=cloud-upload]:before{content:\"\\E03D\"}.oi[data-glyph=cloud]:before{content:\"\\E03E\"}.oi[data-glyph=cloudy]:before{content:\"\\E03F\"}.oi[data-glyph=code]:before{content:\"\\E040\"}.oi[data-glyph=cog]:before{content:\"\\E041\"}.oi[data-glyph=collapse-down]:before{content:\"\\E042\"}.oi[data-glyph=collapse-left]:before{content:\"\\E043\"}.oi[data-glyph=collapse-right]:before{content:\"\\E044\"}.oi[data-glyph=collapse-up]:before{content:\"\\E045\"}.oi[data-glyph=command]:before{content:\"\\E046\"}.oi[data-glyph=comment-square]:before{content:\"\\E047\"}.oi[data-glyph=compass]:before{content:\"\\E048\"}.oi[data-glyph=contrast]:before{content:\"\\E049\"}.oi[data-glyph=copywriting]:before{content:\"\\E04A\"}.oi[data-glyph=credit-card]:before{content:\"\\E04B\"}.oi[data-glyph=crop]:before{content:\"\\E04C\"}.oi[data-glyph=dashboard]:before{content:\"\\E04D\"}.oi[data-glyph=data-transfer-download]:before{content:\"\\E04E\"}.oi[data-glyph=data-transfer-upload]:before{content:\"\\E04F\"}.oi[data-glyph=delete]:before{content:\"\\E050\"}.oi[data-glyph=dial]:before{content:\"\\E051\"}.oi[data-glyph=document]:before{content:\"\\E052\"}.oi[data-glyph=dollar]:before{content:\"\\E053\"}.oi[data-glyph=double-quote-sans-left]:before{content:\"\\E054\"}.oi[data-glyph=double-quote-sans-right]:before{content:\"\\E055\"}.oi[data-glyph=double-quote-serif-left]:before{content:\"\\E056\"}.oi[data-glyph=double-quote-serif-right]:before{content:\"\\E057\"}.oi[data-glyph=droplet]:before{content:\"\\E058\"}.oi[data-glyph=eject]:before{content:\"\\E059\"}.oi[data-glyph=elevator]:before{content:\"\\E05A\"}.oi[data-glyph=ellipses]:before{content:\"\\E05B\"}.oi[data-glyph=envelope-closed]:before{content:\"\\E05C\"}.oi[data-glyph=envelope-open]:before{content:\"\\E05D\"}.oi[data-glyph=euro]:before{content:\"\\E05E\"}.oi[data-glyph=excerpt]:before{content:\"\\E05F\"}.oi[data-glyph=expand-down]:before{content:\"\\E060\"}.oi[data-glyph=expand-left]:before{content:\"\\E061\"}.oi[data-glyph=expand-right]:before{content:\"\\E062\"}.oi[data-glyph=expand-up]:before{content:\"\\E063\"}.oi[data-glyph=external-link]:before{content:\"\\E064\"}.oi[data-glyph=eye]:before{content:\"\\E065\"}.oi[data-glyph=eyedropper]:before{content:\"\\E066\"}.oi[data-glyph=file]:before{content:\"\\E067\"}.oi[data-glyph=fire]:before{content:\"\\E068\"}.oi[data-glyph=flag]:before{content:\"\\E069\"}.oi[data-glyph=flash]:before{content:\"\\E06A\"}.oi[data-glyph=folder]:before{content:\"\\E06B\"}.oi[data-glyph=fork]:before{content:\"\\E06C\"}.oi[data-glyph=fullscreen-enter]:before{content:\"\\E06D\"}.oi[data-glyph=fullscreen-exit]:before{content:\"\\E06E\"}.oi[data-glyph=globe]:before{content:\"\\E06F\"}.oi[data-glyph=graph]:before{content:\"\\E070\"}.oi[data-glyph=grid-four-up]:before{content:\"\\E071\"}.oi[data-glyph=grid-three-up]:before{content:\"\\E072\"}.oi[data-glyph=grid-two-up]:before{content:\"\\E073\"}.oi[data-glyph=hard-drive]:before{content:\"\\E074\"}.oi[data-glyph=header]:before{content:\"\\E075\"}.oi[data-glyph=headphones]:before{content:\"\\E076\"}.oi[data-glyph=heart]:before{content:\"\\E077\"}.oi[data-glyph=home]:before{content:\"\\E078\"}.oi[data-glyph=image]:before{content:\"\\E079\"}.oi[data-glyph=inbox]:before{content:\"\\E07A\"}.oi[data-glyph=infinity]:before{content:\"\\E07B\"}.oi[data-glyph=info]:before{content:\"\\E07C\"}.oi[data-glyph=italic]:before{content:\"\\E07D\"}.oi[data-glyph=justify-center]:before{content:\"\\E07E\"}.oi[data-glyph=justify-left]:before{content:\"\\E07F\"}.oi[data-glyph=justify-right]:before{content:\"\\E080\"}.oi[data-glyph=key]:before{content:\"\\E081\"}.oi[data-glyph=laptop]:before{content:\"\\E082\"}.oi[data-glyph=layers]:before{content:\"\\E083\"}.oi[data-glyph=lightbulb]:before{content:\"\\E084\"}.oi[data-glyph=link-broken]:before{content:\"\\E085\"}.oi[data-glyph=link-intact]:before{content:\"\\E086\"}.oi[data-glyph=list-rich]:before{content:\"\\E087\"}.oi[data-glyph=list]:before{content:\"\\E088\"}.oi[data-glyph=location]:before{content:\"\\E089\"}.oi[data-glyph=lock-locked]:before{content:\"\\E08A\"}.oi[data-glyph=lock-unlocked]:before{content:\"\\E08B\"}.oi[data-glyph=loop-circular]:before{content:\"\\E08C\"}.oi[data-glyph=loop-square]:before{content:\"\\E08D\"}.oi[data-glyph=loop]:before{content:\"\\E08E\"}.oi[data-glyph=magnifying-glass]:before{content:\"\\E08F\"}.oi[data-glyph=map-marker]:before{content:\"\\E090\"}.oi[data-glyph=map]:before{content:\"\\E091\"}.oi[data-glyph=media-pause]:before{content:\"\\E092\"}.oi[data-glyph=media-play]:before{content:\"\\E093\"}.oi[data-glyph=media-record]:before{content:\"\\E094\"}.oi[data-glyph=media-skip-backward]:before{content:\"\\E095\"}.oi[data-glyph=media-skip-forward]:before{content:\"\\E096\"}.oi[data-glyph=media-step-backward]:before{content:\"\\E097\"}.oi[data-glyph=media-step-forward]:before{content:\"\\E098\"}.oi[data-glyph=media-stop]:before{content:\"\\E099\"}.oi[data-glyph=medical-cross]:before{content:\"\\E09A\"}.oi[data-glyph=menu]:before{content:\"\\E09B\"}.oi[data-glyph=microphone]:before{content:\"\\E09C\"}.oi[data-glyph=minus]:before{content:\"\\E09D\"}.oi[data-glyph=monitor]:before{content:\"\\E09E\"}.oi[data-glyph=moon]:before{content:\"\\E09F\"}.oi[data-glyph=move]:before{content:\"\\E0A0\"}.oi[data-glyph=musical-note]:before{content:\"\\E0A1\"}.oi[data-glyph=paperclip]:before{content:\"\\E0A2\"}.oi[data-glyph=pencil]:before{content:\"\\E0A3\"}.oi[data-glyph=people]:before{content:\"\\E0A4\"}.oi[data-glyph=person]:before{content:\"\\E0A5\"}.oi[data-glyph=phone]:before{content:\"\\E0A6\"}.oi[data-glyph=pie-chart]:before{content:\"\\E0A7\"}.oi[data-glyph=pin]:before{content:\"\\E0A8\"}.oi[data-glyph=play-circle]:before{content:\"\\E0A9\"}.oi[data-glyph=plus]:before{content:\"\\E0AA\"}.oi[data-glyph=power-standby]:before{content:\"\\E0AB\"}.oi[data-glyph=print]:before{content:\"\\E0AC\"}.oi[data-glyph=project]:before{content:\"\\E0AD\"}.oi[data-glyph=pulse]:before{content:\"\\E0AE\"}.oi[data-glyph=puzzle-piece]:before{content:\"\\E0AF\"}.oi[data-glyph=question-mark]:before{content:\"\\E0B0\"}.oi[data-glyph=rain]:before{content:\"\\E0B1\"}.oi[data-glyph=random]:before{content:\"\\E0B2\"}.oi[data-glyph=reload]:before{content:\"\\E0B3\"}.oi[data-glyph=resize-both]:before{content:\"\\E0B4\"}.oi[data-glyph=resize-height]:before{content:\"\\E0B5\"}.oi[data-glyph=resize-width]:before{content:\"\\E0B6\"}.oi[data-glyph=rss-alt]:before{content:\"\\E0B7\"}.oi[data-glyph=rss]:before{content:\"\\E0B8\"}.oi[data-glyph=script]:before{content:\"\\E0B9\"}.oi[data-glyph=share-boxed]:before{content:\"\\E0BA\"}.oi[data-glyph=share]:before{content:\"\\E0BB\"}.oi[data-glyph=shield]:before{content:\"\\E0BC\"}.oi[data-glyph=signal]:before{content:\"\\E0BD\"}.oi[data-glyph=signpost]:before{content:\"\\E0BE\"}.oi[data-glyph=sort-ascending]:before{content:\"\\E0BF\"}.oi[data-glyph=sort-descending]:before{content:\"\\E0C0\"}.oi[data-glyph=spreadsheet]:before{content:\"\\E0C1\"}.oi[data-glyph=star]:before{content:\"\\E0C2\"}.oi[data-glyph=sun]:before{content:\"\\E0C3\"}.oi[data-glyph=tablet]:before{content:\"\\E0C4\"}.oi[data-glyph=tag]:before{content:\"\\E0C5\"}.oi[data-glyph=tags]:before{content:\"\\E0C6\"}.oi[data-glyph=target]:before{content:\"\\E0C7\"}.oi[data-glyph=task]:before{content:\"\\E0C8\"}.oi[data-glyph=terminal]:before{content:\"\\E0C9\"}.oi[data-glyph=text]:before{content:\"\\E0CA\"}.oi[data-glyph=thumb-down]:before{content:\"\\E0CB\"}.oi[data-glyph=thumb-up]:before{content:\"\\E0CC\"}.oi[data-glyph=timer]:before{content:\"\\E0CD\"}.oi[data-glyph=transfer]:before{content:\"\\E0CE\"}.oi[data-glyph=trash]:before{content:\"\\E0CF\"}.oi[data-glyph=underline]:before{content:\"\\E0D0\"}.oi[data-glyph=vertical-align-bottom]:before{content:\"\\E0D1\"}.oi[data-glyph=vertical-align-center]:before{content:\"\\E0D2\"}.oi[data-glyph=vertical-align-top]:before{content:\"\\E0D3\"}.oi[data-glyph=video]:before{content:\"\\E0D4\"}.oi[data-glyph=volume-high]:before{content:\"\\E0D5\"}.oi[data-glyph=volume-low]:before{content:\"\\E0D6\"}.oi[data-glyph=volume-off]:before{content:\"\\E0D7\"}.oi[data-glyph=warning]:before{content:\"\\E0D8\"}.oi[data-glyph=wifi]:before{content:\"\\E0D9\"}.oi[data-glyph=wrench]:before{content:\"\\E0DA\"}.oi[data-glyph=x]:before{content:\"\\E0DB\"}.oi[data-glyph=yen]:before{content:\"\\E0DC\"}.oi[data-glyph=zoom-in]:before{content:\"\\E0DD\"}.oi[data-glyph=zoom-out]:before{content:\"\\E0DE\"}", ""]);

// exports


/***/ }),

/***/ "../../node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "../../node_modules/fbjs/lib/emptyFunction.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "../../node_modules/fbjs/lib/invariant.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "../../node_modules/history/DOMUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),

/***/ "../../node_modules/history/LocationUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _resolvePathname = __webpack_require__("../../node_modules/resolve-pathname/index.js");

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__("../../node_modules/value-equal/index.js");

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),

/***/ "../../node_modules/history/PathUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),

/***/ "../../node_modules/history/createBrowserHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__("../../node_modules/invariant/browser.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__("../../node_modules/history/DOMUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),

/***/ "../../node_modules/history/createHashHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__("../../node_modules/invariant/browser.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__("../../node_modules/history/DOMUtils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),

/***/ "../../node_modules/history/createMemoryHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");

var _LocationUtils = __webpack_require__("../../node_modules/history/LocationUtils.js");

var _createTransitionManager = __webpack_require__("../../node_modules/history/createTransitionManager.js");

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),

/***/ "../../node_modules/history/createTransitionManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__("../../node_modules/warning/browser.js");

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};


/***/ }),

/***/ "../../node_modules/ieee754/index.js":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../../node_modules/invariant/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "../../node_modules/isarray/index.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../../node_modules/lodash.debounce/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/normalize.css/normalize.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/normalize.css/normalize.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css", function() {
			var newContent = require("!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../node_modules/open-iconic/font/css/open-iconic.min.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!../../node_modules/open-iconic/font/css/open-iconic.min.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./open-iconic.min.css", function() {
			var newContent = require("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./open-iconic.min.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.eot":
/***/ (function(module, exports) {

module.exports = "data:application/vnd.ms-fontobject;base64,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KyNhOC2wOSywABawAyWwAiVHI0cjYbAAVFguIDwjIRuwAiWwAiVHI0cjYSCwBSWwBCVHI0cjYbAGJbAFJUmwAiVhuQgACABjYyMgWGIbIVljuAQAYiCwAFBYsEBgWWawAWNgIy4jICA8ijgjIVktsDossAAWILAIQyAuRyNHI2EgYLAgYGawAmIgsABQWLBAYFlmsAFjIyAgPIo4LbA7LCMgLkawAiVGUlggPFkusSsBFCstsDwsIyAuRrACJUZQWCA8WS6xKwEUKy2wPSwjIC5GsAIlRlJYIDxZIyAuRrACJUZQWCA8WS6xKwEUKy2wPiywNSsjIC5GsAIlRlJYIDxZLrErARQrLbA/LLA2K4ogIDywBCNCijgjIC5GsAIlRlJYIDxZLrErARQrsARDLrArKy2wQCywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixKwEUKy2wQSyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbErARQrLbBCLLA1Ky6xKwEUKy2wQyywNishIyAgPLAEI0IjOLErARQrsARDLrArKy2wRCywABUgR7AAI0KyAAEBFRQTLrAxKi2wRSywABUgR7AAI0KyAAEBFRQTLrAxKi2wRiyxAAEUE7AyKi2wRyywNCotsEgssAAWRSMgLiBGiiNhOLErARQrLbBJLLAII0KwSCstsEossgAAQSstsEsssgABQSstsEwssgEAQSstsE0ssgEBQSstsE4ssgAAQistsE8ssgABQistsFAssgEAQistsFEssgEBQistsFIssgAAPistsFMssgABPistsFQssgEAPistsFUssgEBPistsFYssgAAQCstsFcssgABQCstsFgssgEAQCstsFkssgEBQCstsFossgAAQystsFsssgABQystsFwssgEAQystsF0ssgEBQystsF4ssgAAPystsF8ssgABPystsGAssgEAPystsGEssgEBPystsGIssDcrLrErARQrLbBjLLA3K7A7Ky2wZCywNyuwPCstsGUssAAWsDcrsD0rLbBmLLA4Ky6xKwEUKy2wZyywOCuwOystsGgssDgrsDwrLbBpLLA4K7A9Ky2waiywOSsusSsBFCstsGsssDkrsDsrLbBsLLA5K7A8Ky2wbSywOSuwPSstsG4ssDorLrErARQrLbBvLLA6K7A7Ky2wcCywOiuwPCstsHEssDorsD0rLbByLLMJBAIDRVghGyMhWUIrsAhlsAMkUHiwARUwLQBLuADIUlixAQGOWbABuQgACABjcLEABUKxAAAqsQAFQrEACCqxAAVCsQAIKrEABUK5AAAACSqxAAVCuQAAAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWbEADCq4Af+FsASNsQIARAA="

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.otf":
/***/ (function(module, exports) {

module.exports = "data:font/opentype;base64,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VgFYAVoBXAFeAWABYgFkAWYBaAFqAWwBbgFwAXIBdAF2AXgBegF8AX4BgAGCAYQBhgGIAYoBjAGOAZABkgGUAZYBmAGaAZwBngGgAaIBpAGmAasB7QH2AfsxMjM0NTY3ODkxMDExMTIxMzE0MTUxNjE3MTgxOTFhMWIxYzFkMWUxZjIwMjEyMjIzMjQyNTI2MjcyODI5MmEyYjJjMmQyZTJmMzAzMTMyMzMzNDM1MzYzNzM4MzkzYTNiM2MzZDNlM2Y0MDQxNDI0MzQ0NDU0NjQ3NDg0OTRhNGI0YzRkNGU0ZjUwNTE1MjUzNTQ1NTU2NTc1ODU5NWE1YjVjNWQ1ZTVmNjA2MTYyNjM2NDY1NjY2NzY4Njk2YTZiNmM2ZDZlNmY3MDcxNzI3Mzc0NzU3Njc3Nzg3OTdhN2I3YzdkN2U3ZjgwODE4MjgzODQ4NTg2ODc4ODg5OGE4YjhjOGQ4ZThmOTA5MTkyOTM5NDk1OTY5Nzk4OTk5YTliOWM5ZDllOWZhMGExYTJhM2E0YTVhNmE3YThhOWFhYWJhY2FkYWZiMGIxYjJiM2I0YjViNmI3YjhiOWJhYmJiY2JkYmViZmMwYzFjMmMzYzRjNWM2YzdjOGM5Y2FjYmNjY2RjZWNmZDBkMWQyZDNkNGQ1ZDZkN2Q4ZDlkYWRiZGNkZGRlMS4xLjFDcmVhdGVkIGJ5IFAuSi4gT25vcmkgd2l0aCBGb250Rm9yZ2UgMi4wIChodHRwOi8vZm9udGZvcmdlLnNmLm5ldClVbnRpdGxlZDFJY29ucwAAAAGHAYgBiQGKAYsBjAGNAY4BjwGQAEIAQwBEAEUARgBHAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgCQAi8CMAIxAjICMwI0AjUCNgI3AjgCOQI6AjsCPAI9Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAOACAAEAIwBMAHsAvAD8ASABRAFoAd8CAQItAlMCfQKmAsQC3QMAAyADOwNeA38DrQRIBHgExwT3BV0FpwXTBnEGtQcAB3AHjAfUB+8IFwiPCRcJhQncCvELTAuzDBEMtAzBDNQM5AzyDWsNng3KDeUOBA4jDj4OXg51DtQPDg+WD/sQBxA9EHMQ7xERETQRVhF2EikSWBKEEqwS3RMpE24UAhQrFFUUcBTNFRAVqBW7FdIWFBZJFqIWuhbaFvkXGxddF+gYKRhLGG0YkBiwGOgZShm9GdsaLhpSGn4atRtHG1YbZxwWHD0cuhz8HSMdgR3tHmIelh7FHvgfPR+xIDQgayCPILMg1yExIYYhrSKZI4kkfSS5JPUlCSVHJYIlzyYZJmAm5ScbJ5InpiezJ+Mn/SgVKCooRShZKIIonylRKVwpuSn8KlEqoCssK1Ar9yxMLJgs9S1NLWotky37Lk8ujC7tL4kv+DD4MW4xzzH6MicyUTKjMwczbTO+M+k0UzSHNMk0+jUrNYg1sTYcNm82kTbINv83OzeGN8k4HziCORc5Sjm5Ofo6JjrNOvY7KzuJO6E7sTv4PGE80j0cPWw9nT3GLouz+FmzAbOz94SzA7MW99T4qfvUBrP8gRX4WfeE/FkHDovv91zv91zvAflQ7wMU4PfA+VAVIAr8JPtcFSf8JCf4JCcH91z3KgUOi+/3XO/3XO8B+VDvAxTg98D5UBUgCvzs+1wV+1z7Kvdc+yqL7/gki4vv/CSLBQ747O8B+Ij3XAP38vlQFftV+zH7MftV9x73BPcE9x73HvcE+wT7Hh9ZJwf3XPtc91z3XCeLi70F91X7Mfcx+1UeDvjs7wHv91wD+Fb5UBX7Vfsx+zH7VR9ZJwf3XPtc91z3XCeLi70F9x73BPcE9x73HvcE+wT7HvdV+zH3MftVHg6L7+/v7+/v7wH5UAQhCv1Q+1wVIgr9UPtcFSEK/VD7XBUiCg6L7+/v7+/v7wH5UAQhCv20+1wVIgr87PtcFSEK/bT7XBUiCg6L7+/v7+/v7wH5UAQhCvzs+1wVIgr9tPtcFSEK/Oz7XBUiCg6L+bQD+CT5UBVGi0p4UmwI99b7ftb3dQVPr0SiQIsI+6f7BBU/Qlomi/sGi3KNdI9zCPfK93IF+Aj3ERX7DvwL926LBZOrk6yLrov2YOtG0wj8bPvWFftD+xEFwvsF8zX3FHQIt/dWFcn7WQX3GZf3BdfL9wEIDvagdgH3XO8D91z5tBX8iPtcB/eR+8D3i/fA+1yLi/iIBQ6gdvlQ7wGL98D3XPfAA/gk+bQVIwonJxX3XPvA91wG+8D7wPvA98D3XIsFDov3wPdc98AB+VDvA/gk+bQVIwonBPtc98D7XPvA+1wH+8D3wAUOi/fA91z3wAGL7wP4JPm0FSMKJwT3wPvA+8D7wIv3XPvAi4v3XPfAiwUOi+8Bi/fA91z3wAP4JPm0FSMKJwT3wPvA+1yLi/vA+1yLi/fA+1yLBQ73wO8B98D47BX7wPuR98D7i4v3XPiIi4vv/IiLBQ73wO8B+Ij47BX7XPyIJ/iI+1wH98D3kQUO9qB2Afdc91wD91z5tBX8iPtcB/fD+8D3vffA+1yLi/iIBQ73wPdcAffA+VAV+8D7w/fA+72L91z4iIuL91z8iIsFDvfA91wB+Ij5UBX7XPyI+1z4iPtcB/fA98MFDvagdgH3XPdcA/e9+bQV+737wPdci4v8iPdci4v4iPdciwUO9qB2Afdc7wP3i/m0FfuL+8D3XIuL/Ijvi4v4iPdciwUOoHYBi+/v7+/v7+8D+CT5tBUkCvvAJxX87O/47Af3wCcVJQr9UCcV+1zv91wHDovv7+/3XO/v7wP3CPjsFUNDXyiL+wKL+wK3JNNDCNPTBVXBadeL3overdPBwQj4hNMVQ0MFwVWtQ4s4izhpP1VVCNNDBdPTt/KL9wKL9wJf7kPTCPw9+yAVZ2d0WYtUi1SiVq9nCNDTBXmdgaWLp4unlaKdnQj3adIVRkQFnXmVdItvi2+BcXl5CNBDBa+vosCLwovCdLxnrwgOLqB2+CT4JAGL+CQD91z5tBUmCif8dRWL+9Pv7+8ni/fTBWuAaoNoi2iLaZNslggOi+/47O8Bi+/47O8D+CT5tBUnCicEzYvHdrxoCPw3/DcFaLx2x4vNi/c69xr3Gvc6iwj3iPsRFa5aoE+LSYv7Ovsa+xr7OotJi0+gWq4IDovvAYvv7/dc7/dcA/lQBP1Q+bTv/VD47Af4JBb8iPdc+IgH/Ij7XBX7wPdc98AHDovv98DvAe/v7/dc7+8DFDj4Ifm0FX6KfoSCgAj7fvut+xSLiyfvi4v8AgV5m3udHvioBp2bm50f+ALv7/sUB3Cs+2j3kImNgJSBkH6KCI77FBX3JPtA+7SLBYX7XBUoCvfAFigKDu/v+CTvEovv+Ij3XPtc7xPolPlQFYWIiIUf/NoHhY6IkR75PgaRjo6RH/dTBxPw7/dcBhPoJ/dSBpGIj4Ue/OMnFfiI/CT8iAYO7/jsAZT5UBWFiIiFH/zaB4WOiJEe+T4GkY6OkR/3U+/3XCf3UgeRiI+FHg4n98D4JO8B91zv91zvA+f5HhVvoXSnHo2Lj4yNiwi9+yEGgnr7A/tqXT17cXlpi12LZJplpXGlcbF8sosI+JQGsYuvm6WkCI4GpaWasYuyi7h5rnulXdn7A/dqgpwI9yG9B6ehoaendaFvH/yIi4aLhouIiwVxeHB0H/gsWRWL+zaRgQWLi8r7D8MiCPxWBsP0yvcPi4sIkZWL9zYFDovv7/jsAfgk+bQV+wIxMfsCH4sjVy05R2JpcluLVwj5tAaLv3K7Yq05z1fpi/MI9wIx5fsCHif9UBVUuF7Cwri4wh4O9qB2Afcq7wP3Kvm0FYv7jkDWQED3Kvsq+yr7KtZA1taL+469i/fy9477dfct93X3J/vy944FvfsqFfcqJ/sqJwUnBPcqJ/sqJwUOi+/3wO/3XO8S7/dc91z3XCf3XBP0+bQEJwfCuF5UH/wkB1ReXlQeJ/i6B/ce9wT3BPceH4vvUOA2swgT+KatnLeLugj3AjHl+wIe+1wnFe8GwrheVFReXlQfJwYnBPcqBhP03s5IODhISDgf+yoGDvagdgH3wPm0FfvA/Ij3XIuL+8D3wPiI+1yLBQ6L7wGL7/iI7wPv+bQVeIgFZINsbINkCIh4i/y6BTjOSN4e+Lrv/LoGb3Whp6ehoacf+Lr4ugandaFvHln7wAYn7ycni/fABQ4uoHYBi/gkA/m0BIv9tPdc91z3XPtci/m0BQ75UO8B+bQEIQr9tPtcFfzjB4WOiJEe+aIGkY6OkR/44/u9JPtf8gcOi/dc7/fA7+8B91zv91zvA/fA+bQVVF5eVB8n+1MHhYiIhR/7hQdvoXWnHvlQBqehoacf94UHkYiOhR77U+8Gwl64VB77XCcV91wn+1wG+8D8GxX7XAeFjoiRHvmiBpGOjpEf91wHe4V7iHmLCP1QBnmLe457kQgO9ovv91zv98DvEu/vPe/3Ru8T9PfA+bQVTYtVcWlgaWF7U4tRi0acU5NZCPsRJwYT7PcOBoBecVdGRgh7f4v7Dvjsi4vv/H+LBcvUrs6Zxwj3Ru/7QAYT9IPPd8OLvouylq2coJygn5Wui7KLoYCZfZl9lnWLZAjvBovFe79msAhmsFebUYsIDifv+CTv7+8Bi+/v7/gk7wOt+VAVeIV8dYt3CIuJi/1QBW+hdace+VAGp6Ghpx/5UAendaFvHv1Qi4aLh4uIiwX3BCcVKQr3XBb3wAanoXVvb3V1bx/7wAZvdaGnp6Ghpx/7jvtcFfjs/CT87AYOoHYB9xr3ngP5fPmxFYWI/Av7nn58f3IF03TCVKJDCKSXmpj3nvgLBY6PjI+HjwhftwX8ePweFUFRT0EfiyhVNDtdsnW6f7uLCPcn9wv3C/cn1U/HQR8Ohu717wH4LffAA5T4VxWLeZd3m4QI9whTBYJ7gXqFeghGi4aLBW91c3FvoXWnH5CLvYsFi3SNdY92CD1jBXaGe3SLdotvoXWni5WLmJCTkQjNrgWjXbFktHKunqOki6cIi/cki5CLj4vdBYyOi5CLjouOi5CKjpCioJyjiwinoXVvH4s0i4aLhouFi4aLh4v7GwWLcKRxrni0o7Gzo7kIzGgFk4WYhpWLp4uhoYuni6B7onaQCD2zBY+gjaGLogi9BqehoaendaFvH0cGhZyBnIKbCPcHwwWak5efi5yLp3Whb4uCi4WIhYcI+xdJb6EF2d499zv7C4v7C4s9+z3aOghudfsXzQWEj4COg4twi3hwi3QIDvjs7wP47PlQFfzs5geRjo6RH/jaB5GIjoUe/HX7WRV4iPtKiwWFiIiFH/tKB4WOiJEe5ovy+6QFlnKsgKSWpJaWrICkCED3RgWOmZWTmosIi473jvsRi/iIBQ6L7+/v7+/3XO8Bi+/v7+/v7+8DlPm0FYWIiIUf/aIHhY6IkR75PgaRjo6RH/miB5GIjoUe/OMnFfiI+1z8iAYnBO8nJwb3XO8V7ycnBvdc7xXv+8AnBvwk7xXvJycG91zvFe8nJwYOi+/v7+/v7/dcAYvv7+/v7+/vA/m0BPtc+VD3XAf9UPvAFfx/B4WOiJEe+T4GkY6OkR/4fwf87CcV7ycnBvdc7xXvJycG91zvFe8nJwb8JCcV7ycnBvdc7xXvJycGDovv7/dc7/fA+8DvEovv7+/v91zv7xPv+C35tBWFi4eHiYYILftKBRPfiYaHh4WLCPshBjhISDgf/E0HhY6IkR75ogaRjo6RH/jaB5GIjoUeOQaFi4ePiZAILfdKBRPviZCHj4WLCBPf/E37wBWnoXVvb3V1b291oacfp6Ghpx4T7/fyFvcC5TH7AvsCMTH7AvsCMeX3Ah/3AuXl9wIeJwQqCg747AT4JPwk+CT4JAUOLqB2Afgk+bQV/CT8JPgk/CQFDi6gdgH5tASL/bT4JPgkBQ74JPjsFfwk/CT5tIsFDovv7/fAi+8S98jv91zvE7j4ugRvonSnHo2LjoyNiwj3KouVcgWmOKY3pjgIE9iPfpt/mYsI9/IGmYucl4+YCNz3jgUTuI+Yhpd9iwgT2PxQi2XTBRO4hJp3mHqLCPtci4eLhouIiwVxd3B0H/f6/FYVKwr3wBYrCg6gdu/4JO/vAYv3XO/4iAP5UASL/Ijv7++Li/fA98CLi+8F+1z7XBX8JPgkB+8ni/iIBQ75FflQFfsF+wv7CvsG+wj7CVe8WL1Zvgj7Ifsh00QF1EHWQ9I/CPiB+IEFDvcq+OwV+yr7Kvgk/CT4JPgk+yr3KvuO+44FDvagdgH4JPm0Ffwk/CT4JPwk9yr3KvuO9473jveOBQ72oHYB9yr5tBX7Kvsq9477jvuO+473Kvsq+CT4JAUO+CT47BX8JPwk9yr7KveO9473jvuO9yr3KgUOi/m0Afgk+bQVIwr3XPtGFdND+9b71vtA90DT0+8nBQ6L+bQBi/m0A/gk+bQVIwr7KvtGFSwKDov4iO/vAYvv91zv91zvAxQ49/L5tBVvdXVvH1lAB32AgH0fQPfA1geZgJZ9HkC9Bqd1oW8e+9knFX2AgH0f/R4HfZaAmR75HgaZlpaZH/keB5mAln0eQPtc/Ij3XAYOi+/47O8Bi+/3ju/3ju8DFDj4JPm0FScKJwQtClknFYv7cpt/Bahup26mbQjT0wVyoXOidKMI90kHDqB2+Ij3wAGL98Dv7+/3XAP4Vvm0FfsNiyE1dPsG+wKLMTGL+wKLZpZqnG0I96S9Bt7Ozt7ezkg4Hln3UweRm46bi52LzGHLUaAIvQf3HvsE9wT7Hh57/CQVeIV8dYt3CIuJi/sq+yqL91z7XPdc91z7KouL9yqLjAWndaFvHoiLiIqIiwiHBg6gdgH4JO8D+Fb5tBX7DYshNXT7BvsCizExi/sCi2aWapxtCPdyi/dc91z3XPtc9yGLBZGbjpuLnYvMYctRoAi9B/ce+wT3BPseHvxWBPuO+473XIuLWQVvoXWnp6Ghpx6991wHDu/47AH4VvlQFS4KDov47AH3jvm0Ffse+wT7BPseH4tklGmbaqmhrZqvlcL3EPcT4Pcji13HQ7M5iwj3XPtcFS4KDviI+VAV+8D87O+L98D47AX8iCcVJ/tc7/tc74sn91zv91wF+CQW7/tcJ/tc74vv91wn91wFDov3jvfA944Bi/eO98D3jgP38vm0FVn7C29/+wu9Q0O9+wt/b/sLWYsn9wtZl29Z+wvTQ/cLvad/vfsLBe+LvfcLp5f3C1nT01n3C5en9wu9i+/7C71/p733C0PT+wtZb5cFWfcLBVn7jhXezkg4OEhIODhIzt7ezs7eHw6L7/iI91wB+bQELwr87PvAFfdc+1z3XPdcBfzs/CQVIQoOoHYBi+/4iPdcA/m0BCQK+IgWMAr7wPtcFftc+1z3XPtcBQ6gdgGL91z4iO8D+bQEMAr4iBYkCvyI+1wVi/wk91z3XAUOi/dc+IjvAfm0BCEK/CT7wBX7XPtc+CSLBfzsJxUvCg6L7+/v7+/v7wGL7+/v7+/v7wP3KvlQFThISDg4zkjeH70nWQY4SEg4OM5I3t7Ozt4fve9ZBzjOSN7ezs7e3kjOOB5Z770G3s7O3t5Izjg4SEg4H1knvQfeSM44HicEp6F1bx9ZWQdvdaGnp6Ghpx/4JBanoXVvb3V1bx9ZvQanoaGnHvuO+1wV7ycnBvsqJxW9WQZvdXVvb3Whp6ehoace9/IWvQanoXVvb3V1b291oacfDqB291z47AGL+bQD+asE/NoHhY6IkR7444v3XPtci/mqBZGIj4Ue/aIGhoeHhh8Oi+/47O8Bi+/47O8D+CT5tBUnCicELQr3XCcV+8AnJ/vA98DvBSf3KhUpCg6L7/js7wGL+CT3wO8D+CT5tBUnCicE9zr3Gvsa+zr7Ovsa+xr7Oh8Oi+/v7/dc7+/vAflQ7wP5tAQhCv20+1wVJ/iI7wf8iPvAFSEK/bT7XBUiCvcqFisKDu/v7/dc7+8Bi+/v7wMU4KT5UBV9gIB9H0D5tNYHmYCWfR79m/tcFfwLB32WgJke+YIGmZaWmR/4Cwf9UPtcFe8nJwb3XO8V7ycnBg6gdu/v+CTvAe/v+CTvA+/5tBUnJyfv/Ij4iCfv7+/vJ/hWB+/vWb0nJ/xWi4vvBftcBPfyi/vy+/IF+CT3wBX78vvyBw6L7+/3XIvvi+/v7xKL7/dc91z7Ku+97+/vE6xA+CT5tBX7cPtI+0j7cPtw90j7SPdw93D3SPdI93Af93D7SPdI+3AeJwQtChOdQCcEMQr7XPsoFYt/knuUgwjlMAUT3kCFcgVUuF7Cwri4wsJeuFQecoUw5QWDlHuSf4sIg4uIi4iLBXiFfHWLdwgTrMD38rsVMQoOi+8B98D3XAP3wPm0FfvA+1wH98D7wPfA98D7XIuL98AF/Ij9UBUhCg6gdvlQ7wH3wPdcA/m0BCEK/CT7XBX7wPvA91yLi/vA91yLi/fA91yLBQ73XPlQFftc+8D3XPvA+OyLi/jsBfxWPRUsCg747O8Bi+/v+CTv7wMUcPgk+VAV+3D7SPtI+3Af7wb3Ovca9xr3Ovc69xr7Gvs6Hu8G93D7SPdI+3AeUPtlFTpyTz+LMQj7AuUx9wL3AuXl9wIei+VP1zqkCFAzBQ6L7+/3XPtc7+/vEovv7+8TnPm0BP20+VD4JAcTzPwk+CQG7xYTnPvA98AH/OzvFe8nJwYnBO8GE7wnJwcnBBPMMgoO9ovv+CTvAYvv7+/v7wMUOPdc+VAVJ0AHR1JSRx9ZB4tHtlLNewj3lUoFmYefcot8CFkHfYCAfR77jgZ/i4KOh44I6ScnB4tpoG+ie6J7p4WpiwjWJ+/v1gbPxMTPH70Hi89gxEmbCPuVzAV9j3eki5oIvQeZlpaZHveOBpeLlIiPiAgt7+8Hi612p3SbdJtvkW2LCEDvBg6L98D3XPfAA/lQBDMK91wWMwoOi/fA91z3wAP3wPlQFTQK+Ij47BU0Cg7v98D3XO8Si/fA+8Dv+CT3wPvA7xPg98D5UBU1ChPQ+1wGE+D3A+Tk9wMeE8j4iO8VNQoTxPtcBhPI9wPk5PcDHg7v7/dc98ASi/fAJ+/3XPfAJ+8T4PlQBPvABxPQ91wGE+A2ChPI91wW+8AHE8T3XAYTyDYKDvZ17wGL7/eO944D98D5tBVpaQWAgPuT+5eL+24I+zn3G/sb9zn3Ofcb9xv3OR6L9277k/eXgJYI+0z8ShWnoXVvVLhewqehdW9vdXVv+wIx5fcCp6Ghpx8Oi/dcAfgk+bQV/CT8iPm0iwX9tCcVLwoO9qB2AffA+bQV+8D7wPjsiwX87PtcFffA+8D3wPfABQ73wPdcAYv3XO/3XO/3XAMUcPiIBDcK7xY3Cu8WNwoO+VAEiyf4JPtc+CT3XIvvBf20+1wV/CT5tPgkB/wk+1wFDqB2AYvv+OzvA/gk+bQV/CT7XIv87Pm0i4v47AX8JOMV98D7Kov7UPvA+yr7wPcqi/dQBe9lFYsn91wn91zvi+8FDifv7+/v7/dc7wH3XO8D+Oz5UBX7Tov7LfsUXvtACPtTi3In91yLBYtpk2mTawj7WYt4J/eUiwXR+wr3Ezn3J4vUi8+gxq4I9w4HVltGbT2LMos9slTICPdyi5vv+72LBYCrg6uLrwj34oub7/vfiwW09wj3Ad/3F4vNi8d2vGgIm/UFUqpKnkaLCA6L7+/v7+/v7wGL7+/v7+8DFA75UAQn+VDvB/1Q+1wVJ/iI7wf8iPtcFSEK/bT7XBUn7+8H7xYn7+8H7xYn7+8HDov3XPiI7wH5tAQhCvzs+1wV91z7XPdc91wF/Oz8JBUvCg6gdgGL7/iI91wD+bQEJAr4iBYwCvzs+1wVi/wk91z3XAUOoHYBi/dc+IjvA/m0BDAK+IgWJAr7XPtcFftc+1z3XPtcBQ6L7/iI91wB+bQELwr8JPwkFftc+1z4JIsF/OwnFSEKDovv+OzvAYvv+OzvA/m0BP20+bT3XCcn/Oz47O/vB/dcFvcq+yr7jvuO7yf3jveO9yr7Kov4JAUO7+/v7/dc7wH3wO8D+Cf5UBX7kfsq+8CLi/cq+8D3kfeL9yr3wIuL+yr3wPuLH4gnFTgKJwRUXl5UVLhewsK4uMIfi5WIlIiUg3t7f3eLb4t1oYuni5+Xm5uTgo6CjoGLCA74K/ff+VAVeIV7dYt3i3+Se5SDCMpM/Av8EYv7pPehi/gR+BHJSgWTgJ6CmIuni6Ghi6eLmIOcgZMILunMzQXFxYvrUcVSxCmLUlIISUot6AWDlHqTf4uIi4eLiIoIiAb3BftvFfcX+xf70PvQ+xT3GAUOi/gkAYv3wAP5tAT9tPlQ+CT8JPgkB+8W+8D3wAcOoHYSi/gkJ/gkE8D3XPm0Fe/7XPvAJ4v7XIv7XPdcJ4uLKfda977xi/dcCPdc+1zvix73wPvAFROg7/tc+8Ani/tcCPfABrPHvfcq91z7XO+LHw6gdgGL7wP5tAQkCu8W/CT3XCf4JAf7XPdZ91z3X/vAi4vvBQ4uoHYB9yr5tBX7KvvA91yLSftc+xqL7/vA98D3wPsqi/cq98D7XIvv91wFDov4iO/3XPtc7xITwPm0BPtcBxOg+bTv/IgGE8DvB/vA+8AV/FYHb6F1px75UAanoaGnH/hWBw6gdvfA7xKL98D7XO/3XPfA+1zvE+D3Kvm0FThISDgfE9CLSbRUxncI+24HE+RQd2JUi0kIOM5I3t7Ozt4ei8dpvVmjlJSWkpmLCPdcBt3Pz90fxgcTyMaftMKLzQjeSM44OEhIOB4T1ItJtFTGdwhQB291dW8e+1wGeot5h3yGCPcKBxPgxp+0wovNCN5IzjgeDqB2Afm0BDkK7/wkFToKDqB2Ae/5tBU6Cvcq+44VOQoOi+/47O8Bi+8D+CT5tBUjCicErYupgqmBdndzeY95j3nMkItmi3BhgqltrmgoTYldiDfiftCLCLWLlneIc1U+L1smi2WLaZRpmKG3WeJcp3SiWoJvloKmgqaKqQiOkJCQk4sIxmkFnY8w9xK1pZ+Xs1d+wn++unSpmKWWn6lqnQh1ngW4pr+cw4sI93v7ARWddZpzlnEIi4h1dQVvb4a8gJV+l119hZqEncOjsZYIDovvAflT+bQV+8P7wCfv+8D7w+8n91z3X+8n+CT4JAX9tPzsFSEKDovv7+/v7+/vAYvv7+/v7+/vA/lQBCfv7wfvFifv7wfvFifv7wfvFifv7wf9UPtcFSfv7wfvFifv7wfvFifv7wfvFifv7wf9UPtcFSfv7wfvFifv7wfvFifv7wfvFifv7wf9UPtcFSfv7wfvFifv7wfvFifv7wfvFifv7wcOi/dc7/dc7/dcAYv3XO/3XO/3XAMU/Pm0BDcK7xY3Cu8WNwr9tPvAFTcK7xY3Cu8WNwr9tPvAFTcK7xY3Cu8WNwoOi/fA91z3wAGL98D3XPfAA/m0BDsK91wWOwr9tPyIFTsK91wWOwoOi+/v7+/4JAH47O8Dnvm0FYCDg4Af+98Hb6F1px747AanoaGnH/ffB5aDk4Ae/T38fxX7tgeAk4OWHvkqBpaTk5Yf97YHe4V7iHmLCPzsBnmLe457kQj4uvsBFSkKDovv91zv91zvAe/v98DvAxTg+VAEJ70Hp6F1bx/8JAdvdXVvHlkn98DvWQZvdaGnH/cq98D7KgdvdXVvHlkn98DvWQZvdaGnH/gkB6ehoaceve/7wCe9BqehdW8f+yr7wPcqB6ehoaceve8GDqB2+OzvEov3XCfv+CT3XPtc7xPQ+CT5UBX7Ofsb+xv7OR8nWQcT4G91dW8f+1wHb6F1px7vBqehoacfE9T38gf3A+Tk9wP3A+Qy+wMeE8j78gdvoXWnHu8Gp6Ghpx/3XAendaFvHhPUWe8G9zn7G/cb+zkeDviIBItUolmvZwj36fvo9+n36AWvr6K9i8II9wEw5vsB+wEwMPsB9wEw5vsB+wEwMPsBHg6gdgHv91z3XPdcA/gk+VAV/CT7wO+Li/wk91yLi/dc91yLi/tc91yLi/gn74gFDovv+OzvAYvv+OzvA/m0BP20+bT5tAf9UCcV+Oz7wAYn7ycn91z7XIsnJ4v8JPgkJycFDov3XPgk91wBi+/47O8Dnvm0FYCDg4Af/Y4HgJODlh75jgaWk5OWH/mOB5aDk4Ae/T37XBX47PvAJwYnJ/tciyfvJ4sFDvdc7/dc7wGL7/js7wP3XPjsFfsXRiYoKNAm9xcf2ovKw8XNxUnIU9yLCPcX0PDu7kbw+xcfOotOU1FJUc1NwzuLCCcEtYu5XLlWXVZdXGGLCEFxwbm5pcHVH/gkFtWlVV1dcVVBH2CLXrpdwLnAuLq2iwgOLovv9/LvvfdcEu/vi/dc+1zvE+T3wPm0FRPoVF5eVB8T5FS4XsIeE+jCuLjCH8JeuFQe+yr7jhU4SEg4HxPw7wanoaGnHhPkp6F1bx8T8ItvJ/scizUINc5L3h4T6N7Ozt4fE+QnBm91dW8eE/BvdaGnHxPki6/v9yiLzQjcSNA4Hg6L7/js7wH3XPm0FSf3NweEfwU9+1g8+1c++1kI+w4n+Ijv+zYGkZcF2fdY2vdX2PdZCPcO7wYOi+/v7+/v7+8B+VAEIQr9tPtcFSEK/bT7XBUhCv1Q+1wVIgoOi+/v7+/v7+8B+VAEIQr9tPtcFSEK/bT7XBUhCv20+1wVIgoOi+/v7+/v7+8B+VAEIQr9tPtcFSEK/bT7XBUhCvzs+1wVIgoOoHb3wPdc91zvAffA91z3XO8D+Lr5tBX7HvsE+wT7Hh+Le4t7jnwI+8P7w4v7XPfAi4v3XPdci4vvjo4Fmoibi5uLCPce9wT3BPce9x77BPcE+x4fvScVPAoOi/dc98DvAe/v+CTvA/ca+OwVeIV8dYt3CIuJi/vyJ4uL+yoFb6F1px75UAanoaGnH/cqJ/fyB6d1oW8e/IiLhouHi4eLBconFfgk+8AnJ/tc7ycGDovv7+/v+CQBi/gk7+/v7wP5tAT8JPgk+CQH7/tcFT0K7/tcFT0KDvYn7xL3A/fH+5/3ZBOA9+X5ShX7wPsqBXaGe3SLdotvoXWni5WLmJCTkQj3wPcqBZqTl5+LnIundaFviwiCi4WIhYcI7/sqFfwk+1wFdoZ7dIt2i2+hdaeLlYuYkJORCPgk91wFmpOXn4uci6d1oW+LgouFiIWHCPtcBPvA+yoFE8B9g393i3uLcaF0pYoIE6D3XAaNi4+KjYsIE8CnoqKnH4ujeKFzjwj1wwWak5efi5yLp3Whb4uCi4WIhYcIE6D7svweFW+hdKcejYuPjI2LCO8Gp6Ghp6d1oW8fJ4uGi4eLiIsFcXdwdB8OoHbv7/gk7wH3W+/3XO8D91v5tBUnJyf3XPdcB/eziBVTiGN3a2oIYF8FfoOAd4t8i2+hdaeLmouelpOYCLe3Ba2t0JK0YrJkjEpjYwj7KvsqBX6DgHeLfItvoXWni5qLn5aTmAj3KvcqBdnZi/cRPdlvp2qdZ5N5j3eLeYoI/A/7xxX7KvsqBT09i/sR2T3DU9x70aSmlaWaoaEItrcFmJOWn4uai6d1oW+LfIt4gIN+CF9fBWlpRoRitGSyisyzswj3KvcqBZOTkZuLloundaFvi4mLh4qJiwiIBoOLgYCHhgj3t/u2Fftc7+/v7wcO95Tq6e497xITgPje+bEVU4hjd2tqfoOAd4t8i2+hdaeLmouflpOYra3QkrRismSMSmNjCPsq+yoFX19nhnGNcY18louLhI+AjoOLb4t1dItvi3qWeJqDmoOefb2ICL2I0Z7JyQj3KvcqBdnZi/cRPdlvp2qdZ5MIeY92i3mKCBOg+1z7exVZjUd5T08I+yr7KgU9PYv7Edk9w1Pce9GkppWlmqGhmJOVn4uai6d1oW+LfIt4gIN+CGlpRoRitGSyisyzswj3KvcqBbOzrpCniqeKnoKLiwgTwJOFmIaVi6eLoaGLp4uge6J2kAh2kH2aWY0IDovv7+/v7+/vAYv3wAP5UAQ7Cu8WJ/gk7wf8JPtcFSf3wO8H/VD7XBU7Cu8WJ/gk7wf8JPtcFSf3wO8HDovv7+/v7+/vAYvvA735UBUrCvcqFiIK/YL7XBUrCvcqFiIK/YL7XBUrCvcqFiIK/YL7XBUrCvcqFiIKDqB2Afm0+bQV/bT8JPfAJ+/7wAUO9ov4JPdc7wHv7/dc7wP3wPlQFfsCMTH7Ah8nJ/wk+Oz4JCfvB/cCMeX7Ah4nBMO3X1MfJ/tc7wfDt7fDHg72i/gk98DvAe/v91zvA/fA+bQV+wIxMfsCH+8Gw7e3w8O3X1Me+1z8JPwk+Oz4JCf3XAf3AjHl+wIeDu/v+CTvAe/v+CTvA/gk+VAV+zn7G/sb+zkfJ4v3Kvtc9yr3XCeLBfcD5OT3Ax73jhb7Kvtc74sF+wMyMvsDHicH9zn3G/cb9zkf7wYOi+/47O8B7+/4JO8D7/m0Fftc7+/4JPtcJwf3KvuO9yr3jieLi/fABfy6+44V+yr7ju+Li/vA+OyLi/dcJ4uLJ/wki4v3XO+LBQ6gdu/v98DvAYvv+OzvA/js+VAVJ/yIB1ReXlQfJ+/v+IgnB/dc9yoF/Oz7jhX7XPsq91z7Kovv+IiLBcK4uMIf7ycn/IgHDvgr7+/4iO8Bi+/4iO8D9/L5tBX7Vfsx+zH7VftV9zH7MfdVH8aLxZq8pY6HkIWPiAjvJwWbe6x9oovDi7m5i8OLon2se5sIJ+8Fh4+EkIaOprycxIvHCPdV+zH3MftVHvzsBPsf+wP3A/cf9x/3A/cD9x/3H/cD+wP7H/si+wD7APsiHw72oHb5UO8Bi+/4JO8D98D5tBX7Ovsa+xr7Ovtc98D7wIuL98D3wPdc9zr7Gvca+zofJwQ4Cg74K4vv7+/3XO/v7wGL7+/v7+/3XO8D+bQE/bT5tPeCB4yOi4+LjouOi5CKjgj4sQf7xfy6FW+hdacekIv3KouLJ/zsi4v47Pjsi4v8JPsqi4aLBW91c3Ef+yX38hU4SEg4J/cq+yqLi/cq9yrv3kjOOB8nBCkKDvaL91z3XPdcA/lQBD4K91wWPgoO9vlQBIv87Pjs98AFDvbv+OwBi/jsA/fA+VAV+zr7Gvsa+zr7Ovca+xr3Ovc69xr3Gvc69zr7Gvca+zofDvgk+VAV/CT7wPgk+8AF98AE+CT7wIv47AUO+VAEi/zs+CT3wAX7wAT4JPfA/CT3wAUOi/dcA/lQBD4K+8AE+Ij7wIv47AUO+Ij3XAP5UASL/Oz4iPfABfvABPdc+Oz7XAYO9u/47AGL+OwD+VAE/Oz47PjsBw6gdvdc+CQB91z4JAP3XPm0Fftc+1z8JPdc+1z4JPdc91z4JPtc91wHDo7v91zv91nvAflQBCEK/bT7vRUhCv20+8AVIQoO9ifv9env+CgSi+/v91z7Ku/3Ku8T+veq+VAVYIFoX4tfCIuJi/tcBVS4XsLCuLjCHov3XIuPBcJeuFQegouFiYSJCPuI+1wVeIV8dYt3CIuJi1kFE/aL+yj3AfsO9yFzCCEHE/pZBlReXlQf+CQGwl64VB4T9ln1Bvcho/cB9w6L9ygIvQendaFvb3V1bx5ZB/sDMjL7A/sDMuT3Ax6LvYuMBad1oW8eiIuIioiLCIgGDvfA91wB+IgELwoOJ+/v7/gk7wGL7/js7wOt+VAVeIV8dYt3CIuJi/yIBW+hdace944nJwZUXl5UH/jsBsJeuFQeJ+/3jganoaGnH/iIB6d1oW8e/VCLhouHi4iLBcknFfjs/CT87AYOPfeOAYv3jgP3pPlQFfsyVvsG+ymL+0SL+3H3R/tH93GL90SL9yn3BsD3MmN9YINei/txi/tH90eL93GLuJO2mbMIDqB298DvAffA7wP38vlQFfsq+yrvi4v7Kvsqi4vv+yr7Kvcq+yqL7/cqi4v7KieL9yr7Kvcq9yoni4v3KgX3KicG9yr3Kvsq9yqLJ/sqi4v3Ku+LBQ6L98D7XPfA91n3XxKL98An7/dc98An7xOq+bT5tBX8iCcnix/8LQd8kHmPeosIE7A/ChNq+CEH1KL3EqD3XZEI+2IHfJB5j3qLCBNkPwoO92P4h/lQFViLWHdkZAj7qvukBSAgi/tC9iD2IPdCi/b2CPcR9xFG0PsI+wWCfwVGRvsEi0bQR8+N9wLN0Aj3qvenBbOzzIqyZLJkiU1mYwj7jvuLBYGBeYuBlYGVi52VlQiSjuXpRtArKgVbW4s8u1u7W9qLu7sI9473iAXZ2Yv3ET3ZZLJYn1iLCA6gdgH47Pm0FScn91z7XO/vBfwkFvwk/CSL+1z3XIv4JPgkBQ6L91zv+CT7wPgkEu/3wO/3XCf3XBO4+Lr5tBVYi19ncFe4VaZBizeLbohxhXGegJ2DoYsI3s7l9wIf9wJI5TgeE9D7wCcVOEgx+wL7As4x3t7O5fcCH/cCSOU4Hvhv+9AVYFhPbEmJCBPUpmWcXYtZCEn3XPc6B4u/bLdfoQj9HicVX3VsX4tXCPs6BxOY+Ij3OgaLv2y3X6FeVk5sRotGi06qXsAIDov3XO/4iAH3XPgkA/gk+bQV+wIx+wT7Hvse5fsE9wL3AuX3BPce9x4x9wT7Ah/7ZfyIFSGGNjSL+wAIJ/m07weL9wA24iGQVU5BZDqLOotBslXICA72i73vvfiI7xKL91z7XO/3XPdcJ+8T6p75tBWAg4OAH/2OB4CTg5Ye+GIGlpOTlh/5jgeWg5OAHvwRJxX3wPyI+8AG9ypZFRP0KQoOoHYB9/L5tBUqizRkTEsI9737vYv4IQV7jXqMeosI9yohFYv76fuk+6QFyFnXbOCL91WL9zH3MYv3VYv3RPsX9yP7PaQI/C37GBVTVWhBizeLK7k40VQI92j3aAUO98Dv91zvAffA7wPn+R4Vb6F0px6Ni4+MjYsIvftcJwZUXl5UH/fA+8AGtyfD74v3wPfAiwXCXrhUHif3XL0Gp6Ghp6d1oW8f/CSLhouHi4iLBXF3cHQfDov5tAGL98AD+CT5tBUjCif7XBX3wPtc+8D7XAUOoHb3wPdcAffA91wD98D5tBX7wPvA+1z3wPvA91z3wPfA91z7wPfABw6L7wGL7/dc7/dc7wMUcPfA+bQVJQr7ePskFWVsBTpLVieL+wMI+1X3Mfsx91X3Vfcx9zH3VR6L9wNX7znLCGWqTT2wbAXFXbJEizsI+x/7A/sD+x/7H/sD9wP3Hx6L26/SxbkIs6oFDov3wO/v7/dcAYvv7/gk7+8DFBz3XPm0Fftc+CT3XAf84/vAFYWIiIUf+64HhY6IkR7m91z47Ptc5gaRjo6RH/euB5GIjoUe/OP7XBX7wPgk98AHDqB27+/v7+/vAYvv+OzvA/lQBP1Q7/lQB/jsFv1Q7/lQB/zsJxUn91zvByf7XBUn91zvByf7XBUn91zvBw73e+8B99n5UBVh+xxi+xxh+x0IiJGCrftQi4sn9wiLBac0pzSnM7X3GbT3GrX3GbP7FLT7FLH7FbHmsOew5wiYb/d7i4vv+z2LBW7Fb8RtxG5BbUFuQV/3H173H2H3IQgO7/js/Oz3XBKL91yL91yL91wTkPdc+OwVi2+dd5VzjoWLgYt/CBOo+3v87Pd7BouXi5WIkYGjeZ+LpwjEtrbExLZgUh6Lb3l3gXOIhYuBi38I93v3ewaXi5WLkYgIE0ijgZ95p4sIxLa2xMRgtlIfb4t3eXOBhYiBi3+LCPd7+3sHi5eLlY6RCBOQlaOdn4unCMRgtlIeUmBgUh8Okifv+OzvAfdZ7+/vA/eL+VAVNotMcWNjY2N9WYZlCO9/BY+lk6Oenp6eqp3Ni82Lr3ufeZ95k3SLcos4aHRZX1lfSkuL+wkIcu+kB4veqqK9t7230MuL9wmLu3vBYLJgskufN4sIWf1QFSfv7wcOi/dc7/fA+1z4JBLv7+/v7+8UHBO8+Fb5tBUT3PsNiyE1dPsGCBO8+wIxMfsCH4tXn12sZwgT3KWhrZewi5+LnoachAgTvJzLxbvQi9CLxVucSwgT3JySnpCfi8qLwGShVMucu8WL0IvMYctRoAi9B/ce+wT3BPseHvsI/IgVeIV8dYt3CIuJi/tcBW+hdaenoaGnHov3XIuMBad1oW8eiIuIioiLCIgG+2AnFXiFfHWLdwiLiYsnBW+hdaenoaGnHovvi4wFp3Whbx6Ii4iKiIsIiAb4IBZ4hXx1i3cIi4mLJwVvoXWnp6Ghpx6L74uMBad1oW8eiIuIioiLCIcGDqB27+/4JO8B+Oz5tBUnWQdoi3aAdXAI+yH7Rvst90YFdaV1l2mLCCcn7waOiPc3+1P7OvtiJ4uLJ++LBa6LoJahpgj3LfdS9zr7UgWhcaB/rosIpCcG91z3Kvtc9yqLJ3WLhY77Q/di9y33U72Liyf3XPcqBQ6L7/js7wGL7wP4JPm0Fftw+0j7SPtw+3D3SPtI93Af9wKL8bfT0whD0wVVVUBpOIsI+zr7Gvca9zr3Ovca9xr3Oh/ei9NnwVQI+wH7AffAi4v3wPsL+wsFQ9MouvsCiwgOoHYB+CT5tBX3Ovs6/CT8JPs69zqL/CT4JIv7Ovc6+CT4JPc6+zqL+CQFDvagdgH3XO8D9475tBX7jvvA91yLi/tc+1yL9477wPeO98D7XIuL91z3XIsFDvfA7wH3wPjsFfvA+473wPuOi/dc91yLi/tc98D3jvvA946L+1z7XIsFDqB2+Oz3XAH47PdcA/m0BPtcB/fh95/7n/vhH/dcBvhN+/v3+/xNHvvABPtcB/c79xn7Gfs7H/dcBven+3X3dfunHvvABPtc91wH9wIx5fsCHg6L91zv7+/v7+8Bi/dc7+/v7+/vA+/5tBUnB/fg96D7oPvgH+8G+Bb7zvfO/BYe+1wEJwf3cvdG+0b7ch/vBveo+3T3dPuoHvtcBCcH9wPkMvsDH+8G9zn7G/cb+zke+1wEKgoOi/gk/CTv+CT3wCfvEovv7+8TXPfA+bQVVF5eVB/8ugdvdXVvb3Whpx73Kif7XAdUuF7CHhOM+IgGE0zCuLjCHxOc98D8JPeOB6ehoaenoXVvHhMs+yr4JAcTHPdcBxMswl64VB4Oi+/4iO8Bi+/4JO8D1vlQFWJpaWIf/LoHYq1ptB74Vga0ra20H/cRJyf8JPiI91zvB/fAFicH+2GL+zr7LnT7W6Dj2szpiwj3XCcG91z3XAUOoHb3wPdcAfiI+VAV+1wH/CQn+2H7ux+/91r3KPH3XIsI7/tcBvfA99AFDovvAfgR+asV+xNW+xJU+xRXCGwHi/s6zvsm2yCzVrZftWy1bLN1uYu5i7Ohtaq1qra3s8Db9c73J4v3OgiqB/sUv/sSwvsTwAh4lAX9UASHi26SaqNqo2WzaLlL4Fn3CYP3Egj3uvcOBQ6gdgGL7+/v7+/v7wP47Pm0FSQK+8AnFf1Q7/lQB/vA+1wV/Ijv+IgH+8D7XBX7wO/3wAcOoHb4JPdcJ/dcEvfA7xOw98D5tBUn+1wHE9AnJwUTsO8n91yLi/yI74sFE9D4JPdcBxOw7+8FE9An7/tci4v3XAUOoHb3wO/v7+/vAfdc7wP3XPm0FUAK7xYn91zvB/tc+1wVJ/fA7wf7wPtcFSf4JO8HDqB298Dv7+/v7wH3XO8D91z5tBVACu8WJ/gk7wf8JPtcFSf3wO8H+8D7XBUn91zvBw6L7+/v7+/v7wGL7+/v+CTvA9b5UBViaWliH/y6B2KtabQe+R4GtK2ttB/4uge0aa1iHv0FJxXvJycG91zvFTIK+1wnFe8nJwb3XO8VMgr7XCcV7ycnBvdc7xUyCg6gdgH4JPm0FSf7wPvAi/eO+1wn+8D3jvdc9477XCf3wPeO91z7wIsFDovvi+/3Ku/3Ku+L7xKL74vv9yrv9yrvi+8TKQD4JPm0FTEKEzMA+44nFTEK+IgWEzGAKwr7jicVE3OAJgr78vsqFRMlACsK+VAWEyFAKwoTYwD87PuOFTEK+IgWE2GAKwoToQD7jicVMQoOoHb3Kr34iO8Bi+/4iO8Drfm0FXl7e3kf/XAHeZt7nR75DAadm5udH/lwB517m3ke/MonFfiI/Ij8iAb3jlkVsYukYXhqeGpZi3iseKyktbGLCA6gdvlQ7wGL7wP5tASL+8D4iPyI98D3wPyI+IgFJycVPAoO+IjvAYvvA/jsBIv7XPfA+8D3XPdc+8D3wAX3IBb3wfvA+wv7Dtk991z3XPvA98AF+/InFSkKDovv7+/3XO/v7wGL7+/v91zv7+8D+CT5tBUnCicELQonBCYKJwTDt19TU19fU1Nft8PDt7fDHw6L7/iI7wGL7/iI7wP5UAT9UPlQ9/sHJyeL+zP8iIuL+Ij3+4vv7wX3IRb7wPvAJ+8nJ/dc+1z4JPgkBQ6L+CTv98AB+VDvA5T5tBWFiIiFH/2iB4WOiJEe+aIGkY6OkR/5ogeRiI6FHv0VPRX3QPtA+0D7QEPT7+8n7wX31vsqFffAJ/vABg6L7/js7wGLvfeO91z3jr0DFDj5tAT7XL0Hwri4wh73Kvy6Bm91dW8eWSf4JO9ZBm91oacf+Lr3KgfCuF5UH733XAYOi+/v+Ij7wOwTgPlQBCUKE8DvFvwkB6eLpIKeeAgToJ546vtVmXGZcaV+pZOlk5iog6WDpWT3GYukCKShpKce9yoGE8CnoaGnpyT3t4sfg515mHaLCA6gdhKL7+/4iPvA7BPQ+CT5LhV9cSz7VXh4CBPgeHhygm+LCPwk9/IHoIudmJOdCIvy97enp3Whbx/7KgZvdaSkHxPQi6Sy9xmTpZOlfqhxkwh4jgV4iXl+gXgI/CT7nhUlCg4n7/iI7I7vAYvv+IjvA/dc+VAVJ++IB/s+c/sW+yeL+0QI+1X3Mfsx91X3Vfcx9zH3VR6Lt4C2fbEIMGYFlm+QbotsCPsf+wP7A/sf+x/7A/cD9x/3H/cD9wP3Hx6pi6mGp4AIrekFdZNyj3KPCJHv7wf3XPsIFYuL/AD7rHd3d3eLb593n3eni5+fn5/3vPfwi4sIDqB27+/3wO8B+Oz5UBUn/Own+OwnB/dc9yoF/Oz7jhX7XPsq91z7Kovv+OyLi+/87IsFDovv+Ij3XPtc7xLv7+/v7+8UHBPc98D5tBUTvFReXlQfJwZUXl5UH/lQBsJeuFQeJwYT3MJeuFQe+8D7wBX8dQeAk4OWHvhiBpaTk5Yf+HUn+/IHb3V1b291oace9/In+/IHb3V1b291oace9/IHDovv7+8B7/dc91zvA+/5tBX8JAf7AvcEMfceHr0G9wLl5fcCH/gkJ/wkB1ReXlRUXrjCHvgkB/vA/VAVJ/lQ7wcOi+/v+IgBi/dc7/dc7/dcAxQ4lPlQFUEK+DYWQQr8dvtcFUIK/H/8JBUhCg6L91wn7+/v7/dc+1zvEov3XO/3XO/3XBQHEzeV+VAVhYeIhR/7U/dc91MHkYiOhR74NxaGhoiFH/tT91z3UweRiI6FHhMv/HUnFYWHiIUfMPdc5geRiI6FHvx/+1wVIQoTp/20+1wV+1MHhY6IkR73SgaRjo6RH/dTBxNn7xYwB4WPiJEe90kGkY6OkR/mBxOn7xb7UweFj4iRHvdJBpGOjpEf91MHDov4iO/vAYv3XO/3XO/3XAMUOPlQBCEK/av7XBVBCvcKFkIK9woWQQoO7/iIAb347BVvdXVvH/wkB2+hdace+IgGp6Ghpx+L9yrvJ++Li/fAJ4snJ4v3KgWndaFvHg6gdu/v+CTvAYv4JO/v7+8D9+L5tBVDCu/7XBWci5yJm4fhdcs9iy2LLUs9NXV7h3qJeosIJweki6OOopEIjgb3Fqzq9wqL9yCL9yAs9wn7Fqx0kXGPcYsI+1wERAoO9qB2AYv4JO/vA/fi+bQVQwrv+8AVRAoOLqB2AYv4JAP34vm0FUMKDovv7+8B98n5tBWFi4eHiYYI+7r9Poh4izoFhY6IkR75PgaRjo6RH4vciJ77uvk+BYmQh4+Fiwgw+8AV7/tcJwYnBO8nJwYOi/dc91zv91zvAfen91wD+Av5tBX7Hov7FGT7AUUIwDkF6Mb3Aqv3C4v3DIv3BGzoTwjA3QX7AdH7F7L7HosI+8AEPItDdU1jCME2Bbqpv5zHi8aLxXq5bQjA4AVNsj+iPYsI+8AEKgoO+CuLvfeO91wB98H3XAP4u/m0Ffse+wT7BPseH4trk2yWbwj7t/uzBWRki0myZJ93pYOli6WLpZOfnwj3tPe3BaeAqYOri/cei/cE9wSL9x6Lm4ubiJoIKir7XIuL91zs7AV8jnuLe4sI/Fb9HhUpCg73IflQFfsh+yEF3zfeNt43ODg5NzY7CPch+yP3kfeRBd033zjcNQj3I/cjBTXcON833Qj3kfeR+yP3IQU7NjY5OTg33jbeN98IDqB291zv7+8B98DvA/m0BPd1+8D7dYuLJ/fAi4sn+8CLiyf3wIuL+1zvi4v3XPfAi4vv+8CLi+8F98Dv+3UG93X3wCeL+3v7wGWL+3v3wAUO+Cvv7/dc7/dc7wGL7/dc7/dc7wMU/Pfy+bQVRQonBEYKWScVJycn7yfv7+/vJ+8HDvgr7+/3XO/3XO8Bi+/4iO8DFOD38vm0FUUKJwRGCvsq+1wVJ/fA7wcO+bQU+IEVngwK7wq9t5Hvvb3vj+vv91wMDO8Lvb3vk7WbrZLo7+/3XAwNHAAuEwAnAgABAA8AFQAbAD0ARABLAGUAhwCfALEAwwDVAP0BHwFQAVgBYAFzAXoBhgGSAaMBuQHBAdsB8gIIAhACIgItAjUCQwJYAnYClAKsAsADDgNAJ/gk/Ij8JCf4iPlQBwsn+bTvBwsn+OzvBwv7cftH+0f7cftx90f7R/dx93H3R/dH93H3cftH90f7cR8L/bTv+bQHC/wk7/gkBwv7AjEx+wL7AuUx9wL3AuXl9wL3AjHl+wIfC/tw+0j7SPtw+3D3SPtI93D3cPdI90j3cPdw+0j3SPtwHwunoXVvHycHb3V1b291oace7wenoaGnHgunoXVvb3V1b291oaenoaGnHwtUXl5UVLhewsK4uMLCXrhUHwtvdXVvb6F1p6ehoaendaFvHwv3Kvsq9yr3KtND+yr7Kvcq+ypDQ/sq9yr7KvsqQ9P3Kvcq+yr3KgUL9zr3Gvsa+zr7Ovsa+xr7Ovs6+xr3Gvc69zr3Gvca9zofC/sNiyE1dPsGCPsCMTH7AvsC5TH3Ah/4Vgbezs7eH4vMYctRoAi9B/ce+wT3BPseHgv7XPm091wHC/2091z5tAcLb3V1b2+hdaenoaGnH6d1oW8eC/gkJ/wkBguL/Oz3wPfAi/fABQv7wPvAi/vA98CLBQv7Ofsb+xv7OR/7wPfA98AHC/sDMjL7Ax4nB/c59xv3G/c5H/fABwv7XPdc91wHC/cC5TH7AvsCMTH7AvsCMeX3AvcC5eX3Ah8Li/wk9yr3Kvcq+yrv7/sq9yr3KvcqBQsnJ/cq+yr7Kvsq+CSLi/gk+yr7KgUL+8D3wPfABwvCuF5UVF5eVFReuMLCuLjCHwv7wPvAJ/gk+CQHC/zs91z47AcLOEhIODjOSN7ezs7eHwv87PtcB/eO+1z3jvdc+1yLi/jsBQuFiIiFH/x2B4WOiJEe90oGkY6OkR/4dgeRiI6FHguFiIiFH/uuB4WOiJEe90oGkY6OkR/3rgeRiI6FHgv7Gvtc+1yLi/wk91yL9xr7XM2Li/m0BQuL+1ykjgW2lquzi7mLuWyzX5YIC/tV+zH7MftV+1X3Mfsx91UfyIvFm72njYePhY6ICO8kBZt7rH2ii8OLubmLw4uifax7mwgk7wWIjoWPh42mvZzFi8gI91X7Mfcx+1UeC/cf9wP7A/sfH4tQeFVpYAiIiAV/hX99hIBfZlJ0TYsI+x/7A/cD9x/3H/cD9wP3Hx8LAAABkAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAACWAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAlgAAAMgAAADIAAAAlgAAAJYAAADIAAAAyAAAAGQAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAlgAAAMgAAACWAAAAyAAAAGQAAADIAAAAyAAAAJYAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAGQAAABkAAAAyAAAAMgAAADIAAAAyAAAAMgAAACWAAAAlgAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAACWAAAAyAAAAMgAAADIAAAAyAAAAJYAAADIAAAAlgAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAA4QAAAMgAAADIAAAAyAAAAGQAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAGQAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAlgAAAMgAAADIAAAAyAAAAMgAAADIAAAAlgAAAJYAAADIAAAAyAAAAMgAAADhAAAAlgAAAOEAAACWAAAAlgAAAJYAAADIAAAAyAAAAMgAAADIAAAAlgAAAMgAAADIAAAAlgAAAMgAAADIAAAAyAAAAMgAAADIAAAArwAAAMgAAADIAAAAyAAAAJYAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAAB9AAAAyAAAAMgAAADIAAAAyAAAAJYAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAJYAAABkAAAAyAAAAMgAAADhAAAAyAAAAMgAAADhAAAAAAAAAAAAAEAAAAAzD2izwAAAADP2S9qAAAAAM/ZL2o="

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.svg":
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiID4KPCEtLQoyMDE0LTctMTogQ3JlYXRlZC4KLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPG1ldGFkYXRhPgpDcmVhdGVkIGJ5IEZvbnRGb3JnZSAyMDEyMDczMSBhdCBUdWUgSnVsICAxIDIwOjM5OjIyIDIwMTQKIEJ5IFAuSi4gT25vcmkKQ3JlYXRlZCBieSBQLkouIE9ub3JpIHdpdGggRm9udEZvcmdlIDIuMCAoaHR0cDovL2ZvbnRmb3JnZS5zZi5uZXQpCjwvbWV0YWRhdGE+CjxkZWZzPgo8Zm9udCBpZD0ib3Blbi1pY29uaWMiIGhvcml6LWFkdi14PSI4MDAiID4KICA8Zm9udC1mYWNlIAogICAgZm9udC1mYW1pbHk9Ikljb25zIgogICAgZm9udC13ZWlnaHQ9IjQwMCIKICAgIGZvbnQtc3RyZXRjaD0ibm9ybWFsIgogICAgdW5pdHMtcGVyLWVtPSI4MDAiCiAgICBwYW5vc2UtMT0iMiAwIDUgMyAwIDAgMCAwIDAgMCIKICAgIGFzY2VudD0iODAwIgogICAgZGVzY2VudD0iMCIKICAgIGJib3g9Ii0wLjUgLTEwMSA4MDIgODAwLjEyNiIKICAgIHVuZGVybGluZS10aGlja25lc3M9IjUwIgogICAgdW5kZXJsaW5lLXBvc2l0aW9uPSItMTAwIgogICAgdW5pY29kZS1yYW5nZT0iVStFMDAwLUUwREUiCiAgLz4KICAgIDxtaXNzaW5nLWdseXBoIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iIiB1bmljb2RlPSImI3hlMDAwOyIgCmQ9Ik0zMDAgNzAwaDUwMHYtNzAwaC01MDB2MTAwaDQwMHY1MDBoLTQwMHYxMDB6TTQwMCA1MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNDAwdjEwMGg0MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxIiB1bmljb2RlPSImI3hlMDAxOyIgCmQ9Ik0zMDAgNzAwaDUwMHYtNzAwaC01MDB2MTAwaDQwMHY1MDBoLTQwMHYxMDB6TTIwMCA1MDB2LTEwMGg0MDB2LTEwMGgtNDAwdi0xMDBsLTIwMCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIiIHVuaWNvZGU9IiYjeGUwMDI7IiAKZD0iTTM1MCA3MDBjMTkzIDAgMzUwIC0xNTcgMzUwIC0zNTB2LTUwaDEwMGwtMjAwIC0yMDBsLTIwMCAyMDBoMTAwdjUwYzAgMTM4IC0xMTIgMjUwIC0yNTAgMjUwcy0yNTAgLTExMiAtMjUwIC0yNTBjMCAxOTMgMTU3IDM1MCAzNTAgMzUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzIiB1bmljb2RlPSImI3hlMDAzOyIgCmQ9Ik00NTAgNzAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgMTM4IC0xMTIgMjUwIC0yNTAgMjUwcy0yNTAgLTExMiAtMjUwIC0yNTB2LTUwaDEwMGwtMjAwIC0yMDBsLTIwMCAyMDBoMTAwdjUwYzAgMTkzIDE1NyAzNTAgMzUwIDM1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNCIgdW5pY29kZT0iJiN4ZTAwNDsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTEwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0xMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1IiB1bmljb2RlPSImI3hlMDA1OyIgCmQ9Ik0wIDcwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNiIgdW5pY29kZT0iJiN4ZTAwNjsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTIwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0yMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3IiB1bmljb2RlPSImI3hlMDA3OyIgCmQ9Ik00MDAgNzAwYzc1IDAgMTQ2IC0yMyAyMDYgLTU5bC03NSAtMjI1bC0zMjIgMjM0YzU3IDMxIDEyMiA1MCAxOTEgNTB6TTEyNSA1ODhsMTkxIC0xMzhsLTMxMCAtMjIyYy00IDI0IC02IDQ3IC02IDcyYzAgMTE0IDQ5IDIxNSAxMjUgMjg4ek02ODggNTc1YzY5IC03MiAxMTIgLTE2OCAxMTIgLTI3NWMwIC0zNSAtOCAtNjggLTE2IC0xMDBoLTIxOHpNMjE2IDI1M2wxMTIgLTM0N2MtMTI4IDIzIC0yMzIgMTA5IC0yODcgMjIyek0zNzIgMTAwCmgzNzJjLTY0IC0xMDkgLTE3NyAtMTg1IC0zMTAgLTE5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOCIgdW5pY29kZT0iJiN4ZTAwODsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjAwIDgwMGgxMDB2LTUwMGgyMDBsLTI0NyAtMzAwbC0yNTMgMzAwaDIwMHY1MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjkiIHVuaWNvZGU9IiYjeGUwMDk7IiAKZD0iTTQwMCA4MDBjMjIxIDAgNDAwIC0xNzkgNDAwIC00MDBzLTE3OSAtNDAwIC00MDAgLTQwMHMtNDAwIDE3OSAtNDAwIDQwMHMxNzkgNDAwIDQwMCA0MDB6TTMwMCA3MDB2LTMwMGgtMjAwbDMwMCAtMzAwbDMwMCAzMDBoLTIwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYSIgdW5pY29kZT0iJiN4ZTAwYTsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGwtMzAwIC0zMDBsMzAwIC0zMDB2MjAwaDMwMHYyMDBoLTMwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImIiIHVuaWNvZGU9IiYjeGUwMGI7IiAKZD0iTTQwMCA4MDBjMjIxIDAgNDAwIC0xNzkgNDAwIC00MDBzLTE3OSAtNDAwIC00MDAgLTQwMHMtNDAwIDE3OSAtNDAwIDQwMHMxNzkgNDAwIDQwMCA0MDB6TTQwMCA3MDB2LTIwMGgtMzAwdi0yMDBoMzAwdi0yMDBsMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYyIgdW5pY29kZT0iJiN4ZTAwYzsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGwtMzAwIC0zMDBoMjAwdi0zMDBoMjAwdjMwMGgyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQiIHVuaWNvZGU9IiYjeGUwMGQ7IiAKZD0iTTMwMCA2MDB2LTIwMGg1MDB2LTEwMGgtNTAwdi0yMDBsLTMwMCAyNDd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImUiIHVuaWNvZGU9IiYjeGUwMGU7IiAKZD0iTTUwMCA2MDBsMzAwIC0yNDdsLTMwMCAtMjUzdjIwMGgtNTAwdjEwMGg1MDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmIiB1bmljb2RlPSImI3hlMDBmOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yMDAgODAwaDIwMHYtNTAwaDIwMGwtMjk3IC0zMDBsLTMwMyAzMDBoMjAwdjUwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTAiIHVuaWNvZGU9IiYjeGUwMTA7IiAKZD0iTTMwMCA3MDB2LTIwMGg1MDB2LTIwMGgtNTAwdi0yMDBsLTMwMCAyOTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjExIiB1bmljb2RlPSImI3hlMDExOyIgCmQ9Ik01MDAgNzAwbDMwMCAtMjk3bC0zMDAgLTMwM3YyMDBoLTUwMHYyMDBoNTAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTIiIHVuaWNvZGU9IiYjeGUwMTI7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTI5NyA4MDBsMzAzIC0zMDBoLTIwMHYtNTAwaC0yMDB2NTAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjEzIiB1bmljb2RlPSImI3hlMDEzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yNDcgODAwbDI1MyAtMzAwaC0yMDB2LTUwMGgtMTAwdjUwMGgtMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxNCIgdW5pY29kZT0iJiN4ZTAxNDsiIApkPSJNNDAwIDgwMGgxMDB2LTgwMGgtMTAwdjgwMHpNMjAwIDcwMGgxMDB2LTYwMGgtMTAwdjYwMHpNNjAwIDYwMGgxMDB2LTQwMGgtMTAwdjQwMHpNMCA1MDBoMTAwdi0yMDBoLTEwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE1IiB1bmljb2RlPSImI3hlMDE1OyIgCmQ9Ik0xMTYgNjAwbDcyIC03MmMtNTQgLTU0IC04OCAtMTI2IC04OCAtMjA5czM0IC0xNTkgODggLTIxM2wtNzIgLTcyYy03MiA3MiAtMTE2IDE3NSAtMTE2IDI4NXM0NCAyMDkgMTE2IDI4MXpNNjg0IDYwMGM3MiAtNzIgMTE2IC0xNzEgMTE2IC0yODFzLTQ0IC0yMTMgLTExNiAtMjg1bC03MiA3MmM1NCA1NCA4OCAxMzAgODggMjEzcy0zNCAxNTUgLTg4IDIwOXpNMjU5IDQ2MGw2OSAtNzJjLTE4IC0xOCAtMjggLTQxIC0yOCAtNjkKczEwIC01NCAyOCAtNzJsLTY5IC03MmMtMzYgMzYgLTU5IDg5IC01OSAxNDRzMjMgMTA1IDU5IDE0MXpNNTQxIDQ1OWMzNiAtMzYgNTkgLTg1IDU5IC0xNDBzLTIzIC0xMDggLTU5IC0xNDRsLTY5IDcyYzE4IDE4IDI4IDQ0IDI4IDcycy0xMCA1MSAtMjggNjl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE2IiB1bmljb2RlPSImI3hlMDE2OyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0yMDAgODAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDBzOTAgMjAwIDIwMCAyMDB6TTEwMCAzMTljMzEgLTExIDY1IC0xOSAxMDAgLTE5czY4IDggMTAwIDE5di0zMTlsLTEwMCAxMDBsLTEwMCAtMTAwdjMxOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMTciIHVuaWNvZGU9IiYjeGUwMTc7IiAKZD0iTTQwMCA4MDBjMjIwIDAgNDAwIC0xODAgNDAwIC00MDBzLTE4MCAtNDAwIC00MDAgLTQwMHMtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6TTQwMCA3MDBjLTE2NiAwIC0zMDAgLTEzNCAtMzAwIC0zMDBjMCAtNjYgMjEgLTEyNiA1NiAtMTc1bDQxOSA0MTljLTQ5IDM1IC0xMDkgNTYgLTE3NSA1NnpNNjQ0IDU3NWwtNDE5IC00MTljNDkgLTM1IDEwOSAtNTYgMTc1IC01NmMxNjYgMCAzMDAgMTM0IDMwMCAzMDAKYzAgNjYgLTIxIDEyNiAtNTYgMTc1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxOCIgdW5pY29kZT0iJiN4ZTAxODsiIApkPSJNMCA3MDBoMTAwdi02MDBoNzAwdi0xMDBoLTgwMHY3MDB6TTUwMCA3MDBoMjAwdi01MDBoLTIwMHY1MDB6TTIwMCA1MDBoMjAwdi0zMDBoLTIwMHYzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjE5IiB1bmljb2RlPSImI3hlMDE5OyIgCmQ9Ik0zOTcgODAwYzEzIDEgMjMgLTQgMzQgLTEzYzIgLTIgMjE0IC0yNTQgMjQxIC0yODdoMTI4di0xMDBoLTEwMHYtMzY2YzAgLTE4IC0xNiAtMzQgLTM0IC0zNGgtNTMyYy0xOCAwIC0zNCAxNiAtMzQgMzR2MzY2aC0xMDB2MTAwaDEyOGwyMzQgMjgxYzkgMTEgMjIgMTggMzUgMTl6TTQwMCA2NzJsLTE0NCAtMTcyaDI4OHpNMjUwIDMwMGMtMjggMCAtNTAgLTIyIC01MCAtNTB2LTEwMGMwIC0yOCAyMiAtNTAgNTAgLTUwczUwIDIyIDUwIDUwCnYxMDBjMCAyOCAtMjIgNTAgLTUwIDUwek01NTAgMzAwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtMTAwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MTAwYzAgMjggLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWEiIHVuaWNvZGU9IiYjeGUwMWE7IiAKZD0iTTkgNzAwaDY4MmM2IDAgOSAtNCA5IC0xMHYtMTkwaDEwMHYtMjAwaC0xMDB2LTE5MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2NTgyYzAgNiAzIDkgOSA5ek0xMDAgNjAwdi00MDBoNTAwdjQwMGgtNTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxYiIgdW5pY29kZT0iJiN4ZTAxYjsiIApkPSJNOSA3MDBoNjgyYzYgMCA5IC00IDkgLTEwdi0xOTBoMTAwdi0yMDBoLTEwMHYtMTkxYzAgLTYgLTMgLTkgLTkgLTloLTY4MmMtNiAwIC05IDMgLTkgOXY1ODJjMCA2IDMgOSA5IDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjFjIiB1bmljb2RlPSImI3hlMDFjOyIgCmQ9Ik05MiA2NTBjMCAyMyAxOSA1MCA0NSA1MGgzaDVoNWg1MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTB2LTE0MWM5IC0xNyAxMjAgLTIzMSAxNjYgLTMwOWMxNiAtMjYgMzQgLTYxIDM0IC0xMDZjMCAtMzkgLTE1IC03NyAtNDEgLTEwM2gtM2MtMjYgLTI1IC02MiAtNDEgLTEwMCAtNDFoLTUxMmMtMzkgMCAtNzcgMTUgLTEwMyA0MXMtNDEgNjQgLTQxIDEwM2MwIDQ2IDE4IDgwIDM0IDEwNgpjNDYgNzggMTU3IDI5MiAxNjYgMzA5djE0MWgtNTBjLTIgMCAtNiAtMSAtOCAtMWMtMjggMCAtNTAgMjMgLTUwIDUxek01MDAgNjAwaC0yMDB2LTE2MmwtNiAtMTBzLTYzIC0xMjMgLTExOSAtMjI4aDQ1MGMtNTYgMTA1IC0xMTkgMjI4IC0xMTkgMjI4bC02IDEwdjE2MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWQiIHVuaWNvZGU9IiYjeGUwMWQ7IiAKZD0iTTQwMCA4MDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMGMwIC0xMDQgNTIgLTE5OCAxMzQgLTI2NmM0MSAtMzQgNjYgLTgyIDY2IC0xMzRoLTgwMGMwIDUyIDI1IDEwMCA2NiAxMzRjODIgNjggMTM0IDE2MiAxMzQgMjY2YzAgMTEwIDkwIDIwMCAyMDAgMjAwek0zMDAgMTAwaDIwMGMwIC01NSAtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMWUiIHVuaWNvZGU9IiYjeGUwMWU7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTE1MCA4MDBoNTBsMzUwIC0yNTBsLTIyNSAtMTQ3bDIyNSAtMTUzbC0zNTAgLTI1MGgtNTB2MjUwbC03NSAtNzVsLTc1IDc1bDE1MCAxNTBsLTE1MCAxNTBsNzUgNzVsNzUgLTc1djI1MHpNMjUwIDY1MHYtMjAwbDE1MCAxMDB6TTI1MCAzNTB2LTIwMGwxNTAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIxZiIgdW5pY29kZT0iJiN4ZTAxZjsiIApkPSJNMCA4MDBoNTAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBjMCAtNDcgLTE3IC05MSAtNDQgLTEyNWM4NSAtNDAgMTQ0IC0xMjUgMTQ0IC0yMjVjMCAtMTM4IC0xMTIgLTI1MCAtMjUwIC0yNTBoLTU1MHYxMDBjNTUgMCAxMDAgNDUgMTAwIDEwMHY0MDBjMCA1NSAtNDUgMTAwIC0xMDAgMTAwdjEwMHpNMzAwIDcwMHYtMjAwaDEwMGM1NSAwIDEwMCA0NSAxMDAgMTAwcy00NSAxMDAgLTEwMCAxMDBoLTEwMHpNMzAwIDQwMHYtMzAwaDE1MApjODMgMCAxNTAgNjcgMTUwIDE1MHMtNjcgMTUwIC0xNTAgMTUwaC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIwIiB1bmljb2RlPSImI3hlMDIwOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0zMDAgODAwdi0zMDBoMjAwbC0zMDAgLTUwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjEiIHVuaWNvZGU9IiYjeGUwMjE7IiAKZD0iTTEwMCA4MDBoMzAwdi0zMDBsMTAwIDEwMGwxMDAgLTEwMHYzMDBoNTBjMjggMCA1MCAtMjIgNTAgLTUwdi01NTBoLTU1MGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGg1NTB2LTEwMGgtNTUwYy04MyAwIC0xNTAgNjcgLTE1MCAxNTB2NTUwbDMgMTljOCAzOSAzOSA3MCA3OCA3OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjIiIHVuaWNvZGU9IiYjeGUwMjI7IiBob3Jpei1hZHYteD0iNDAwIiAKZD0iTTAgODAwaDQwMHYtODAwbC0yMDAgMjAwbC0yMDAgLTIwMHY4MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjIzIiB1bmljb2RlPSImI3hlMDIzOyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA2MDBoMzAwdi0xMDNoMjAzdjEwM2gyOTd2LTU5MWMwIC02IC0zIC05IC05IC05aC03ODJjLTYgMCAtOSAzIC05IDl2NTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNCIgdW5pY29kZT0iJiN4ZTAyNDsiIApkPSJNMzAwIDgwMGgyMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwdi0xMDBoMTkxYzYgMCA5IC0zIDkgLTl2LTI0MWMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjI0MWMwIDYgMyA5IDkgOWgxOTF2MTAwYzAgNTUgNDUgMTAwIDEwMCAxMDB6TTMwMCA3MDB2LTEwMGgyMDB2MTAwaC0yMDB6TTAgMjA5YzE2IC02IDMyIC05IDUwIC05aDcwMGMxOCAwIDM0IDMgNTAgOXYtMjAwYzAgLTYgLTMgLTkgLTkgLTloLTc4MgpjLTYgMCAtOSAzIC05IDl2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNSIgdW5pY29kZT0iJiN4ZTAyNTsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGM1OCAwIDExMCAtMTYgMTQ3IC01M3M1MyAtODkgNTMgLTE0N2gtMTAwYzAgMzkgLTExIDYxIC0yNSA3NXMtMzYgMjUgLTc1IDI1Yy0zNSAwIC01NSAtMTAgLTcyIC0zMXMtMjggLTU1IC0yOCAtOTRjMCAtNTEgMjAgLTEwNyAyOCAtMTc1aDE3MnYtMTAwaC0xNzhjLTE0IC02MCAtNDkgLTEyNyAtMTEzIC0yMDBoNDkxdi0xMDBoLTYwMHYxMjJsMTYgMTJjNjkgNjkgOTUgMTIxIDEwNiAxNjZoLTEyMnYxMDBoMTI1CmMtOCA1MCAtMjUgMTA2IC0yNSAxNzVjMCA1OCAxNiAxMTQgNTAgMTU2YzM0IDQzIDg4IDY5IDE1MCA2OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjYiIHVuaWNvZGU9IiYjeGUwMjY7IiAKZD0iTTM0IDcwMGg0aDNoNGg1aDcwMGMyOCAwIDUwIC0yMiA1MCAtNTB2LTcwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjcwMHYyYzAgMjAgMTUgNDIgMzQgNDh6TTE1MCA2MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHpNMzUwIDYwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGgzMDBjMjggMCA1MCAyMiA1MCA1MApzLTIyIDUwIC01MCA1MGgtMzAwek0xMDAgNDAwdi00MDBoNjAwdjQwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyNyIgdW5pY29kZT0iJiN4ZTAyNzsiIApkPSJNNzQ0IDc5N2w2IC0zbDQ0IC00NGM0IC00IDMgLTggMCAtMTJsLTI2NiAtMzc1bC0xNSAtMTNsLTI1IC0xMmMtMjMgNzIgLTc4IDEyNyAtMTUwIDE1MGwxMiAyNWwxMyAxNWwzNzUgMjY2ek0yNjYgNDAwYzc0IDAgMTM0IC02MCAxMzQgLTEzNGMwIC0xNDcgLTExOSAtMjY2IC0yNjYgLTI2NmMtNDggMCAtOTUgMTIgLTEzNCAzNGM4MCA0NiAxMzQgMTMzIDEzNCAyMzJjMCA3NCA1OCAxMzQgMTMyIDEzNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMjgiIHVuaWNvZGU9IiYjeGUwMjg7IiAKZD0iTTkgNDUxYzAgMjMgMTkgNTAgNDYgNTBjOCAwIDE5IC0zIDI2IC03bDEzMSAtNjZsMjkgMjJjLTc5IDgxIC0xIDI1MCAxMTggMjUwczE5NyAtMTY3IDExOSAtMjUwbDI4IC0yMmwxMzEgNjZjNiA0IDEyIDcgMjEgN2MyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTcgLTEyIC0zNyAtMjcgLTQ1bC0xMTUgLTU2YzkgLTE2IDE5IC0zMyAyNSAtNTBoNjhjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTAKYzAgLTIzIC0yIC00NSAtNiAtNjZsNzggLTQwYzIxIC01IDM3IC0yOCAzNyAtNDljMCAtMjggLTIyIC01MCAtNTAgLTUwYy0xMCAwIC0yMyA1IC0zMSAxMWwtNjUgMzVjLTI0IC00NiAtNjIgLTg2IC0xMDMgLTExMGMtMzUgMTkgLTYwIDQ1IC02MCA3MnYxMzV2NHY1djZ2NXY1djg3YzAgMjggLTIyIDUwIC01MCA1MGMtMjQgMCAtNDUgLTE3IC01MCAtNDBjMSAtMyAxIC04IDEgLTExczAgLTggLTEgLTExdi04MnYtNHYtNXYtMTQ0CmMwIC0yOCAtMjQgLTUzIC01OSAtNzJjLTQxIDI1IC03OSA2NCAtMTAzIDExMGwtNjYgLTM1Yy04IC02IC0yMSAtMTEgLTMxIC0xMWMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMjEgMTYgNDQgMzcgNDlsNzggNDBjLTQgMjEgLTYgNDMgLTYgNjZoLTUwaC01Yy0yOCAwIC01MCAyMiAtNTAgNTBjMCAyNiAyMiA1MCA1MCA1MGg1aDY5YzYgMTcgMTYgMzQgMjUgNTBsLTExNiA1NmMtMTYgNyAtMjggMjcgLTI4IDQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyOSIgdW5pY29kZT0iJiN4ZTAyOTsiIApkPSJNNjAwIDcwMGg5MWM2IDAgOSAtMyA5IC05di01ODJjMCAtNiAtMyAtOSAtOSAtOWgtOTF2NjAwek0yMTAgNTAzbDI5MCAxNDd2LTUwMGwtMjUwIDEyNXYtM2MtMTUgMCAtMjUgLTggLTI4IC0yMmw3NSAtMTc4YzExIC0yNSAwIC01OCAtMjUgLTY5cy01OCAwIC02OSAyNWwtMTAzIDI3MmgtOTFjLTYgMCAtOSAzIC05IDl2MTgyYzAgNiAzIDkgOSA5aDE4MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMmEiIHVuaWNvZGU9IiYjeGUwMmE7IiAKZD0iTTkgODAwaDY4MmM2IDAgOSAtMyA5IC05di03ODJjMCAtNiAtMyAtOSAtOSAtOWgtNjgyYy02IDAgLTkgMyAtOSA5djc4MmMwIDYgMyA5IDkgOXpNMTAwIDcwMHYtMjAwaDUwMHYyMDBoLTUwMHpNMTAwIDQwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMzAwIDQwMHYtMTAwaDEwMHYxMDBoLTEwMHpNNTAwIDQwMHYtMzAwaDEwMHYzMDBoLTEwMHpNMTAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMzAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMmIiIHVuaWNvZGU9IiYjeGUwMmI7IiAKZD0iTTAgODAwaDcwMHYtMjAwaC03MDB2MjAwek0wIDUwMGg3MDB2LTQ5MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2NDkxek0xMDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek01MDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek0xMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyYyIgdW5pY29kZT0iJiN4ZTAyYzsiIApkPSJNNDA5IDgwMGgxODJjNiAwIDEwIC00IDEyIC05bDk0IC0xODJjMiAtNSA2IC05IDEyIC05aDgyYzYgMCA5IC0zIDkgLTl2LTU4MmMwIC02IC0zIC05IC05IC05aC03ODJjLTYgMCAtOSAzIC05IDl2NDQxYzAgODMgNjcgMTUwIDE1MCAxNTBoMTQxYzYgMCAxMCA0IDEyIDlsOTQgMTgyYzIgNSA2IDkgMTIgOXpNMTUwIDUwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwegpNNTAwIDUwMGMtMTEwIDAgLTIwMCAtOTAgLTIwMCAtMjAwczkwIC0yMDAgMjAwIC0yMDBzMjAwIDkwIDIwMCAyMDBzLTkwIDIwMCAtMjAwIDIwMHpNNTAwIDQwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBzLTQ1IC0xMDAgLTEwMCAtMTAwcy0xMDAgNDUgLTEwMCAxMDBzNDUgMTAwIDEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjJkIiB1bmljb2RlPSImI3hlMDJkOyIgCmQ9Ik0wIDYwMGg4MDBsLTQwMCAtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyZSIgdW5pY29kZT0iJiN4ZTAyZTsiIGhvcml6LWFkdi14PSI0MDAiIApkPSJNNDAwIDgwMHYtODAwbC00MDAgNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIyZiIgdW5pY29kZT0iJiN4ZTAyZjsiIGhvcml6LWFkdi14PSI0MDAiIApkPSJNMCA4MDBsNDAwIC00MDBsLTQwMCAtNDAwdjgwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzAiIHVuaWNvZGU9IiYjeGUwMzA7IiAKZD0iTTQwMCA2MDBsNDAwIC00MDBoLTgwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzEiIHVuaWNvZGU9IiYjeGUwMzE7IiAKZD0iTTAgNTUwYzAgMjMgMjAgNTAgNDYgNTBoM2g1aDRoMjAwYzE3IDAgMzcgLTEzIDQ0IC0yOGwzOCAtNzJoNDQ0YzE0IDAgMTkgLTEyIDE1IC0yNWwtODEgLTI1MGMtNCAtMTMgLTIxIC0yNSAtMzUgLTI1aC0zNTBjLTE0IDAgLTMwIDEyIC0zNCAyNWMtMjcgODMgLTU0IDE2NyAtODEgMjUwbC0xMCAyNWgtMTUwYy0yIDAgLTUgLTEgLTcgLTFjLTI4IDAgLTUxIDIzIC01MSA1MXpNMzU4IDEwMGMyOCAwIDUwIC0yMiA1MCAtNTAKcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek02NTggMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzIiIHVuaWNvZGU9IiYjeGUwMzI7IiAKZD0iTTAgNzAwaDUwMHYtMTAwaC0zMDB2LTMwMGgtMTAwbC0xMDAgLTEwMHY1MDB6TTMwMCA1MDBoNTAwdi01MDBsLTEwMCAxMDBoLTQwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjMzIiB1bmljb2RlPSImI3hlMDMzOyIgCmQ9Ik02NDEgNzAwbDE0MyAtMTQxbC00OTMgLTQ5M2MtNzEgNzYgLTE0NiAxNDggLTIxOSAyMjJsLTcyIDcxbDE0MSAxNDFjNTAgLTUxIDEwMSAtMTAxIDE1MyAtMTUwYzExNiAxMTcgMjM0IDIzMSAzNDcgMzUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzNCIgdW5pY29kZT0iJiN4ZTAzNDsiIApkPSJNMTUwIDYwMGwyNTAgLTI1MGwyNTAgMjUwbDE1MCAtMTUwbC00MDAgLTQwMGwtNDAwIDQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzUiIHVuaWNvZGU9IiYjeGUwMzU7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTQwMCA4MDBsMTUwIC0xNTBsLTI1MCAtMjUwbDI1MCAtMjUwbC0xNTAgLTE1MGwtNDAwIDQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iMzYiIHVuaWNvZGU9IiYjeGUwMzY7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTE1MCA4MDBsNDAwIC00MDBsLTQwMCAtNDAwbC0xNTAgMTUwbDI1MCAyNTBsLTI1MCAyNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM3IiB1bmljb2RlPSImI3hlMDM3OyIgCmQ9Ik00MDAgNjAwbDQwMCAtNDAwbC0xNTAgLTE1MGwtMjUwIDI1MGwtMjUwIC0yNTBsLTE1MCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM4IiB1bmljb2RlPSImI3hlMDM4OyIgCmQ9Ik00MDAgODAwYzIyMSAwIDQwMCAtMTc5IDQwMCAtNDAwcy0xNzkgLTQwMCAtNDAwIC00MDBzLTQwMCAxNzkgLTQwMCA0MDBzMTc5IDQwMCA0MDAgNDAwek02MDAgNjIybC0yNTAgLTI1MGwtMTAwIDEwMGwtNzIgLTcybDE3MiAtMTcybDMyMiAzMjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjM5IiB1bmljb2RlPSImI3hlMDM5OyIgCmQ9Ik00MDAgODAwYzIyMSAwIDQwMCAtMTc5IDQwMCAtNDAwcy0xNzkgLTQwMCAtNDAwIC00MDBzLTQwMCAxNzkgLTQwMCA0MDBzMTc5IDQwMCA0MDAgNDAwek0yNTAgNjIybC03MiAtNzJsMTUwIC0xNTBsLTE1MCAtMTUwbDcyIC03MmwxNTAgMTUwbDE1MCAtMTUwbDcyIDcybC0xNTAgMTUwbDE1MCAxNTBsLTcyIDcybC0xNTAgLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iM2EiIHVuaWNvZGU9IiYjeGUwM2E7IiAKZD0iTTM1MCA4MDBjMjggMCA1MCAtMjIgNTAgLTUwdi01MGg3NWMxNCAwIDI1IC0xMSAyNSAtMjV2LTc1aC0zMDB2NzVjMCAxNCAxMSAyNSAyNSAyNWg3NXY1MGMwIDI4IDIyIDUwIDUwIDUwek0yNSA3MDBoNzV2LTIwMGg1MDB2MjAwaDc1YzE0IDAgMjUgLTExIDI1IC0yNXYtNjUwYzAgLTE0IC0xMSAtMjUgLTI1IC0yNWgtNjUwYy0xNCAwIC0yNSAxMSAtMjUgMjV2NjUwYzAgMTQgMTEgMjUgMjUgMjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjNiIiB1bmljb2RlPSImI3hlMDNiOyIgCmQ9Ik00MDAgODAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwcy0xODAgLTQwMCAtNDAwIC00MDBzLTQwMCAxODAgLTQwMCA0MDBzMTgwIDQwMCA0MDAgNDAwek00MDAgNzAwYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwczMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHpNMzUwIDYwMGgxMDB2LTE4MWMyMyAtMjQgNDcgLTQ3IDcyIC02OWwtNzIgLTcyYy0yNyAzMCAtNTUgNTkgLTg0IDg4bC0xNiAxMgp2MjIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzYyIgdW5pY29kZT0iJiN4ZTAzYzsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtMTggLTMgLTM0IC05IC01MGgtMTkxdjUwYzAgODMgLTY3IDE1MCAtMTUwIDE1MHMtMTUwIC02NyAtMTUwIC0xNTB2LTUwaC0yNzJjLTE3IDMwIC0yOCA2MyAtMjggMTAwYzAgMTEwIDkwIDIwMCAyMDAgMjAwYzIzIDExNCAxMjkgMjAwIDI1MCAyMDB6TTQzNCA0MDBoM2g0YzMgMCA2IDEgOSAxYzI4IDAgNTAgLTIyIDUwIC01MHYtMQp2LTE1MGgxNTBsLTIwMCAtMjAwbC0yMDAgMjAwaDE1MHYxNTB2MmMwIDIwIDE1IDQyIDM0IDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzZCIgdW5pY29kZT0iJiN4ZTAzZDsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtMTggLTMgLTM0IC05IC01MGgtMTQxbC0yMDAgMjAwbC0yMDAgLTIwMGgtMjIyYy0xNyAzMCAtMjggNjMgLTI4IDEwMGMwIDExMCA5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAwek00NTAgMzUwbDI1MCAtMjUwaC0yMDB2LTUwYzAgLTI4IC0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwdjUwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjNlIiB1bmljb2RlPSImI3hlMDNlOyIgCmQ9Ik00NTAgNzAwYzEzOCAwIDI1MCAtMTEyIDI1MCAtMjUwdi01MGM1OCAtMjEgMTAwIC04NSAxMDAgLTE1MGMwIC04MyAtNjcgLTE1MCAtMTUwIC0xNTBoLTQ1MGMtMTEwIDAgLTIwMCA5MCAtMjAwIDIwMHM5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIzZiIgdW5pY29kZT0iJiN4ZTAzZjsiIApkPSJNMjUwIDgwMGM4MiAwIDE1NCAtNDAgMjAwIC0xMDBjLTE0MyAwIC0yNzAgLTg1IC0zMjUgLTIwOWMtMzYgLTEwIC03MCAtMjUgLTEwMCAtNDdjLTE2IDMzIC0yNSA2NyAtMjUgMTA2YzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNNDUwIDYwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwaC00NTBjLTExMCAwIC0yMDAgOTAgLTIwMCAyMDAKczkwIDIwMCAyMDAgMjAwYzIzIDExNCAxMjkgMjAwIDI1MCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQwIiB1bmljb2RlPSImI3hlMDQwOyIgCmQ9Ik01MDAgNzAwaDEwMGwtMzAwIC02MDBoLTEwMHpNMTAwIDYwMGgxMDBsLTEwMCAtMjAwbDEwMCAtMjAwaC0xMDBsLTEwMCAyMDB6TTYwMCA2MDBoMTAwbDEwMCAtMjAwbC0xMDAgLTIwMGgtMTAwbDEwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQxIiB1bmljb2RlPSImI3hlMDQxOyIgCmQ9Ik0zNTAgODAwaDEwMGw1MCAtMTE5bDI4IC0xMmwxMTkgNTBsNzIgLTcybC01MCAtMTE5bDEyIC0yOGwxMTkgLTUwdi0xMDBsLTExOSAtNTBsLTEyIC0yOGw1MCAtMTE5bC03MiAtNzJsLTExOSA1MGwtMjggLTEybC01MCAtMTE5aC0xMDBsLTUwIDExOWwtMjggMTJsLTExOSAtNTBsLTcyIDcybDUwIDExOWwtMTIgMjhsLTExOSA1MHYxMDBsMTE5IDUwbDEyIDI4bC01MCAxMTlsNzIgNzJsMTE5IC01MGwyOCAxMnpNNDAwIDU1MApjLTgzIDAgLTE1MCAtNjcgLTE1MCAtMTUwczY3IC0xNTAgMTUwIC0xNTBzMTUwIDY3IDE1MCAxNTBzLTY3IDE1MCAtMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDIiIHVuaWNvZGU9IiYjeGUwNDI7IiAKZD0iTTAgODAwaDgwMHYtMjAwaC04MDB2MjAwek0yMDAgNTAwaDQwMGwtMjAwIC0yMDB6TTAgMTAwaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0MyIgdW5pY29kZT0iJiN4ZTA0MzsiIApkPSJNMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTYwMCA4MDBoMjAwdi04MDBoLTIwMHY4MDB6TTUwMCA2MDB2LTQwMGwtMjAwIDIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDQiIHVuaWNvZGU9IiYjeGUwNDQ7IiAKZD0iTTAgODAwaDIwMHYtODAwaC0yMDB2ODAwek03MDAgODAwaDEwMHYtODAwaC0xMDB2ODAwek0zMDAgNjAwbDIwMCAtMjAwbC0yMDAgLTIwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjQ1IiB1bmljb2RlPSImI3hlMDQ1OyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNNDAwIDUwMGwyMDAgLTIwMGgtNDAwek0wIDIwMGg4MDB2LTIwMGgtODAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDYiIHVuaWNvZGU9IiYjeGUwNDY7IiAKZD0iTTE1MCA3MDBjODMgMCAxNTAgLTY3IDE1MCAtMTUwdi01MGgxMDB2NTBjMCA4MyA2NyAxNTAgMTUwIDE1MHMxNTAgLTY3IDE1MCAtMTUwcy02NyAtMTUwIC0xNTAgLTE1MGgtNTB2LTEwMGg1MGM4MyAwIDE1MCAtNjcgMTUwIC0xNTBzLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTB2NTBoLTEwMHYtNTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBzNjcgMTUwIDE1MCAxNTBoNTB2MTAwaC01MApjLTgzIDAgLTE1MCA2NyAtMTUwIDE1MHM2NyAxNTAgMTUwIDE1MHpNMTUwIDYwMGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MGg1MHY1MGMwIDI4IC0yMiA1MCAtNTAgNTB6TTU1MCA2MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwdi01MGg1MGMyOCAwIDUwIDIyIDUwIDUwcy0yMiA1MCAtNTAgNTB6TTMwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTE1MCAyMDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTAKczUwIDIyIDUwIDUwdjUwaC01MHpNNTAwIDIwMHYtNTBjMCAtMjggMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwaC01MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNDciIHVuaWNvZGU9IiYjeGUwNDc7IiAKZD0iTTAgNzkxYzAgNSA0IDkgOSA5aDc4MmM2IDAgOSAtNCA5IC0xMHYtNzkwbC0yMDAgMjAwaC01OTFjLTYgMCAtOSAzIC05IDl2NTgyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0OCIgdW5pY29kZT0iJiN4ZTA0ODsiIApkPSJNNDAwIDgwMGMyMjAgMCA0MDAgLTE4MCA0MDAgLTQwMHMtMTgwIC00MDAgLTQwMCAtNDAwcy00MDAgMTgwIC00MDAgNDAwczE4MCA0MDAgNDAwIDQwMHpNNDAwIDcwMGMtMTY2IDAgLTMwMCAtMTM0IC0zMDAgLTMwMHMxMzQgLTMwMCAzMDAgLTMwMHMzMDAgMTM0IDMwMCAzMDBzLTEzNCAzMDAgLTMwMCAzMDB6TTYwMCA2MDBsLTEwMCAtMzAwbC0zMDAgLTEwMGwxMDAgMzAwek00MDAgNDUwYy0yOCAwIC01MCAtMjIgLTUwIC01MApzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0OSIgdW5pY29kZT0iJiN4ZTA0OTsiIApkPSJNNDAwIDgwMGMyMjAgMCA0MDAgLTE4MCA0MDAgLTQwMHMtMTgwIC00MDAgLTQwMCAtNDAwcy00MDAgMTgwIC00MDAgNDAwczE4MCA0MDAgNDAwIDQwMHpNNDAwIDcwMHYtNjAwYzE2NiAwIDMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNGEiIHVuaWNvZGU9IiYjeGUwNGE7IiAKZD0iTTAgODAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDYwMGg1MDB2LTEwMGgtNTAwdjEwMHpNMCAzMDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAwaDYwMHYtMTAwaC02MDB2MTAwek03NTAgMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNGIiIHVuaWNvZGU9IiYjeGUwNGI7IiAKZD0iTTI1IDcwMGg3NTBjMTQgMCAyNSAtMTEgMjUgLTI1di03NWgtODAwdjc1YzAgMTQgMTEgMjUgMjUgMjV6TTAgNTAwaDgwMHYtMzc1YzAgLTE0IC0xMSAtMjUgLTI1IC0yNWgtNzUwYy0xNCAwIC0yNSAxMSAtMjUgMjV2Mzc1ek0xMDAgMzAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgMzAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI0YyIgdW5pY29kZT0iJiN4ZTA0YzsiIApkPSJNMTAwIDgwMGgxMDB2LTEwMGg0NTBsMTAwIDEwMGw1MCAtNTBsLTEwMCAtMTAwdi00NTBoMTAwdi0xMDBoLTEwMHYtMTAwaC0xMDB2MTAwaC01MDB2NTAwaC0xMDB2MTAwaDEwMHYxMDB6TTIwMCA2MDB2LTM1MGwzNTAgMzUwaC0zNTB6TTYwMCA1NTBsLTM1MCAtMzUwaDM1MHYzNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRkIiB1bmljb2RlPSImI3hlMDRkOyIgCmQ9Ik00MDAgODAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwcy0xODAgLTQwMCAtNDAwIC00MDBzLTQwMCAxODAgLTQwMCA0MDBzMTgwIDQwMCA0MDAgNDAwek00MDAgNzAwYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwczMwMCAxMzQgMzAwIDMwMHMtMTM0IDMwMCAtMzAwIDMwMHpNNDAwIDYwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6Ck0yMDAgNDUyYzAgMjAgMTUgNDIgMzQgNDhoM2gzaDhjMTIgMCAyOCAtNyAzNiAtMTZsOTEgLTkwbDI1IDZjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwcy00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwbDYgMjVsLTkwIDkxYy05IDggLTE2IDI0IC0xNiAzNnpNNTUwIDUwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRlIiB1bmljb2RlPSImI3hlMDRlOyIgCmQ9Ik0zMDAgODAwaDIwMHYtMzAwaDIwMGwtMzAwIC0zMDBsLTMwMCAzMDBoMjAwdjMwMHpNMCAxMDBoODAwdi0xMDBoLTgwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjRmIiB1bmljb2RlPSImI3hlMDRmOyIgCmQ9Ik0wIDgwMGg4MDB2LTEwMGgtODAwdjEwMHpNNDAwIDYwMGwzMDAgLTMwMGgtMjAwdi0zMDBoLTIwMHYzMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTAiIHVuaWNvZGU9IiYjeGUwNTA7IiAKZD0iTTIwMCA3MDBoNjAwdi02MDBoLTYwMGwtMjAwIDMwMHpNMzUwIDYyMmwtNzIgLTcybDE1MCAtMTUwbC0xNTAgLTE1MGw3MiAtNzJsMTUwIDE1MGwxNTAgLTE1MGw3MiA3MmwtMTUwIDE1MGwxNTAgMTUwbC03MiA3MmwtMTUwIC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjUxIiB1bmljb2RlPSImI3hlMDUxOyIgCmQ9Ik00MDAgNzAwYzIyMCAwIDQwMCAtMTgwIDQwMCAtNDAwaC0xMDBjMCAxNjYgLTEzNCAzMDAgLTMwMCAzMDBzLTMwMCAtMTM0IC0zMDAgLTMwMGgtMTAwYzAgMjIwIDE4MCA0MDAgNDAwIDQwMHpNMzQxIDQ5MWw1OSAtODhsNTkgODhjODEgLTI1IDE0MSAtMTAxIDE0MSAtMTkxYzAgLTExMCAtOTAgLTIwMCAtMjAwIC0yMDBzLTIwMCA5MCAtMjAwIDIwMGMwIDkwIDYwIDE2NiAxNDEgMTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1MiIgdW5pY29kZT0iJiN4ZTA1MjsiIApkPSJNMCA4MDBoMzAwdi00MDBoNDAwdi00MDBoLTcwMHY4MDB6TTQwMCA4MDBsMzAwIC0zMDBoLTMwMHYzMDB6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCAyMDB2LTEwMGg0MDB2MTAwaC00MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjUzIiB1bmljb2RlPSImI3hlMDUzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0yMDAgNzAwaDEwMHYtMTAwaDc1YzMwIDAgNTggLTYgODEgLTIyczQ0IC00NCA0NCAtNzh2LTEwMGgtMTAwdjk0Yy00IDMgLTEzIDYgLTI1IDZoLTI1MGMtMTQgMCAtMjUgLTExIC0yNSAtMjV2LTUwYzAgLTE1IDIwIC00MCAzNCAtNDRsMjU3IC02NWM2NiAtMTYgMTA5IC03MyAxMDkgLTE0MXYtNTBjMCAtNjggLTU3IC0xMjUgLTEyNSAtMTI1aC03NXYtMTAwaC0xMDB2MTAwaC03NWMtMzAgMCAtNTggNiAtODEgMjJzLTQ0IDQ0IC00NCA3OAp2MTAwaDEwMHYtOTRjNCAtMyAxMyAtNiAyNSAtNmgyNTBjMTQgMCAyNSAxMSAyNSAyNXY1MGMwIDE1IC0yMCA0MCAtMzQgNDRsLTI1NyA2NWMtNjYgMTYgLTEwOSA3MyAtMTA5IDE0MXY1MGMwIDY4IDU3IDEyNSAxMjUgMTI1aDc1djEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTQiIHVuaWNvZGU9IiYjeGUwNTQ7IiAKZD0iTTAgNzAwaDMwMHYtMzAwbC0zMDAgLTMwMHY2MDB6TTUwMCA3MDBoMzAwdi0zMDBsLTMwMCAtMzAwdjYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNTUiIHVuaWNvZGU9IiYjeGUwNTU7IiAKZD0iTTMwMCA3MDB2LTYwMGgtMzAwdjMwMHpNODAwIDcwMHYtNjAwaC0zMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1NiIgdW5pY29kZT0iJiN4ZTA1NjsiIApkPSJNMzAwIDcwMHYtMTAwYy0xMTEgMCAtMjAwIC04OSAtMjAwIC0yMDBoMjAwdi0zMDBoLTMwMHYzMDBjMCAxNjUgMTM1IDMwMCAzMDAgMzAwek04MDAgNzAwdi0xMDBjLTExMSAwIC0yMDAgLTg5IC0yMDAgLTIwMGgyMDB2LTMwMGgtMzAwdjMwMGMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjU3IiB1bmljb2RlPSImI3hlMDU3OyIgCmQ9Ik0wIDcwMGgzMDB2LTMwMGMwIC0xNjUgLTEzNSAtMzAwIC0zMDAgLTMwMHYxMDBjMTExIDAgMjAwIDg5IDIwMCAyMDBoLTIwMHYzMDB6TTUwMCA3MDBoMzAwdi0zMDBjMCAtMTY1IC0xMzUgLTMwMCAtMzAwIC0zMDB2MTAwYzExMSAwIDIwMCA4OSAyMDAgMjAwaC0yMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1OCIgdW5pY29kZT0iJiN4ZTA1ODsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGwzNCAtMzRjMTEgLTExIDI2NiAtMjcwIDI2NiAtNDg4YzAgLTE2NSAtMTM1IC0zMDAgLTMwMCAtMzAwcy0zMDAgMTM1IC0zMDAgMzAwYzAgMjE4IDI1NSA0NzcgMjY2IDQ4OHpNMTUwIDMyOGMtMjggMCAtNTAgLTIyIC01MCAtNTBjMCAtMTEwIDkwIC0yMDAgMjAwIC0yMDBjMjggMCA1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUwYy01NSAwIC0xMDAgNDUgLTEwMCAxMDBjMCAyOCAtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1OSIgdW5pY29kZT0iJiN4ZTA1OTsiIApkPSJNNDAwIDgwMGw0MDAgLTUwMGgtODAwek0wIDIwMGg4MDB2LTIwMGgtODAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNWEiIHVuaWNvZGU9IiYjeGUwNWE7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTMwMCA4MDBsMzAwIC0zMDBoLTYwMHpNMCAzMDBoNjAwbC0zMDAgLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNWIiIHVuaWNvZGU9IiYjeGUwNWI7IiAKZD0iTTAgNTAwaDIwMHYtMjAwaC0yMDB2MjAwek0zMDAgNTAwaDIwMHYtMjAwaC0yMDB2MjAwek02MDAgNTAwaDIwMHYtMjAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1YyIgdW5pY29kZT0iJiN4ZTA1YzsiIApkPSJNMCA3MDBoODAwdi0xMDBsLTQwMCAtMjAwbC00MDAgMjAwdjEwMHpNMCA1MDBsNDAwIC0yMDBsNDAwIDIwMHYtNDAwaC04MDB2NDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI1ZCIgdW5pY29kZT0iJiN4ZTA1ZDsiIApkPSJNNDAwIDgwMGw0MDAgLTIwMHYtNjAwaC04MDB2NjAwek00MDAgNjg4bC0zMDAgLTE1MHYtMTg4bDMwMCAtMTUwbDMwMCAxNTB2MTg4ek0yMDAgNTAwaDQwMHYtMTAwbC0yMDAgLTEwMGwtMjAwIDEwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjVlIiB1bmljb2RlPSImI3hlMDVlOyIgCmQ9Ik02MDAgNzAwYzY5IDAgMTM0IC0xOSAxOTEgLTUwbC0xNiAtMTA2Yy00OSAzNSAtMTA5IDU2IC0xNzUgNTZjLTEzMSAwIC0yNDAgLTg0IC0yODEgLTIwMGgzMzFsLTE2IC0xMDBoLTMzNGMwIC0zNiA4IC02OCAxOSAtMTAwaDI5N2wtMTYgLTEwMGgtMjIyYzU1IC02MSAxMzMgLTEwMCAyMjIgLTEwMGM3OCAwIDE0NyAzMCAyMDAgNzh2LTEyMmMtNTkgLTM1IC0xMjcgLTU2IC0yMDAgLTU2Yy0xNDcgMCAtMjc0IDgyIC0zNDQgMjAwaC0yNTYKbDE5IDEwMGgxOTdjLTggMzIgLTE2IDY2IC0xNiAxMDBoLTIwMGwyNSAxMDBoMTkxYzQ1IDE3MiAxOTggMzAwIDM4NCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjVmIiB1bmljb2RlPSImI3hlMDVmOyIgCmQ9Ik0wIDcwMGg3MDB2LTEwMGgtNzAwdjEwMHpNMCA1MDBoNTAwdi0xMDBoLTUwMHYxMDB6TTAgMzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMjAwIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNDAwIDEwMGgxMDB2LTEwMGgtMTAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjAiIHVuaWNvZGU9IiYjeGUwNjA7IiAKZD0iTTAgODAwaDgwMHYtMTAwaC04MDB2MTAwek0yMDAgNjAwaDQwMGwtMjAwIC0yMDB6TTAgMjAwaDgwMHYtMjAwaC04MDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2MSIgdW5pY29kZT0iJiN4ZTA2MTsiIApkPSJNMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTYwMCA4MDBoMjAwdi04MDBoLTIwMHY4MDB6TTIwMCA2MDBsMjAwIC0yMDBsLTIwMCAtMjAwdjQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjIiIHVuaWNvZGU9IiYjeGUwNjI7IiAKZD0iTTAgODAwaDIwMHYtODAwaC0yMDB2ODAwek03MDAgODAwaDEwMHYtODAwaC0xMDB2ODAwek02MDAgNjAwdi00MDBsLTIwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjYzIiB1bmljb2RlPSImI3hlMDYzOyIgCmQ9Ik0wIDgwMGg4MDB2LTIwMGgtODAwdjIwMHpNNDAwIDQwMGwyMDAgLTIwMGgtNDAwek0wIDEwMGg4MDB2LTEwMGgtODAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjQiIHVuaWNvZGU9IiYjeGUwNjQ7IiAKZD0iTTAgODAwaDIwMHYtMTAwaC0xMDB2LTYwMGg2MDB2MTAwaDEwMHYtMjAwaC04MDB2ODAwek00MDAgODAwaDQwMHYtNDAwbC0xNTAgMTUwbC0yNTAgLTI1MGwtMTAwIDEwMGwyNTAgMjUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2NSIgdW5pY29kZT0iJiN4ZTA2NTsiIApkPSJNNDAzIDcwMGMyNDcgMCAzOTcgLTMwMCAzOTcgLTMwMHMtMTUwIC0zMDAgLTM5NyAtMzAwYy0yNTMgMCAtNDAzIDMwMCAtNDAzIDMwMHMxNTAgMzAwIDQwMyAzMDB6TTQwMCA2MDBjLTExMCAwIC0yMDAgLTkwIC0yMDAgLTIwMHM5MCAtMjAwIDIwMCAtMjAwczIwMCA5MCAyMDAgMjAwcy05MCAyMDAgLTIwMCAyMDB6TTQwMCA1MDBjMTAgMCAxOSAtMyAyOCAtNmMtMTYgLTggLTI4IC0yNCAtMjggLTQ0YzAgLTI4IDIyIC01MCA1MCAtNTAKYzIwIDAgMzYgMTIgNDQgMjhjMyAtOSA2IC0xOCA2IC0yOGMwIC01NSAtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHM0NSAxMDAgMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjYiIHVuaWNvZGU9IiYjeGUwNjY7IiBob3Jpei1hZHYteD0iOTAwIiAKZD0iTTMzMSA3MDBoM2gzYzMgMSA3IDEgMTAgMWMxMiAwIDI5IC04IDM3IC0xN2w5NCAtOTNsNjYgNjVjNTcgNTcgMTU1IDU3IDIxMiAwYzU4IC01OCA1OCAtMTU0IDAgLTIxMmwtNjUgLTY2bDkzIC05NGMxMCAtOCAxOCAtMjUgMTggLTM4YzAgLTI4IC0yMiAtNTAgLTUwIC01MGMtMTMgMCAtMzIgOSAtNDAgMjBsLTYyIDY1bC0zODEgLTM4MWgtMjY5djI3MmwzNzUgMzgxbC02MyA2M2MtOSA4IC0xNiAyNCAtMTYgMzZjMCAyMCAxNiA0MiAzNSA0OHoKTTQ0NyA0ODFsLTMxMyAtMzE1bDEyOCAtMTMybDMxNiAzMTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjY3IiB1bmljb2RlPSImI3hlMDY3OyIgCmQ9Ik0wIDgwMGgzMDB2LTQwMGg0MDB2LTQwMGgtNzAwdjgwMHpNNDAwIDgwMGwzMDAgLTMwMGgtMzAwdjMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjgiIHVuaWNvZGU9IiYjeGUwNjg7IiAKZD0iTTIwMCA4MDBjMCAwIDIwMCAtMTAwIDIwMCAtMzAwcy0yOTggLTMwMiAtMjAwIC01MDBjMCAwIC0yMDAgMTAwIC0yMDAgMzAwczMwMCAzMDAgMjAwIDUwMHpNNTAwIDUwMGMwIDAgMjAwIC0xMDAgMjAwIC0zMDBjMCAtMTUwIC02MCAtMjAwIC0xMDAgLTIwMGgtMzAwYzAgMjAwIDMwMCAzMDAgMjAwIDUwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNjkiIHVuaWNvZGU9IiYjeGUwNjk7IiAKZD0iTTAgODAwaDEwMHYtODAwaC0xMDB2ODAwek0yMDAgODAwaDMwMHYtMTAwaDMwMGwtMjAwIC0yMDNsMjAwIC0xOTdoLTQwMHYxMDBoLTIwMHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjZhIiB1bmljb2RlPSImI3hlMDZhOyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0xNTAgODAwaDE1MGwtMTAwIC0yMDBoMjAwbC0xNTAgLTMwMGgxNTBsLTMwMCAtMzAwbC0xMDAgMzAwaDEzNGw2NiAyMDBoLTIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmIiIHVuaWNvZGU9IiYjeGUwNmI7IiAKZD0iTTAgODAwaDMwMHYtMTAwaDUwMHYtMTAwaC04MDB2MjAwek0wIDUwMGg4MDB2LTQ1MGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjQ1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmMiIHVuaWNvZGU9IiYjeGUwNmM7IiAKZD0iTTE1MCA4MDBjODMgMCAxNTAgLTY3IDE1MCAtMTUwYzAgLTY2IC00MSAtMTIxIC0xMDAgLTE0MXYtMTE4YzE1IDUgMzMgOSA1MCA5aDIwMGMyOCAwIDUwIDIyIDUwIDUwdjU5Yy01OSAyMCAtMTAwIDc1IC0xMDAgMTQxYzAgODMgNjcgMTUwIDE1MCAxNTBzMTUwIC02NyAxNTAgLTE1MGMwIC02NiAtNDEgLTEyMSAtMTAwIC0xNDF2LTU5YzAgLTgyIC02OCAtMTUwIC0xNTAgLTE1MGgtMjAwYy0xNCAwIC0yNSAtNyAtMzQgLTE2CmM1MCAtMjQgODQgLTc0IDg0IC0xMzRjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBjMCA2NiA0MSAxMjEgMTAwIDE0MXYyMThjLTU5IDIwIC0xMDAgNzUgLTEwMCAxNDFjMCA4MyA2NyAxNTAgMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmQiIHVuaWNvZGU9IiYjeGUwNmQ7IiAKZD0iTTAgODAwaDQwMGwtMTUwIC0xNTBsMTUwIC0xNTBsLTEwMCAtMTAwbC0xNTAgMTUwbC0xNTAgLTE1MHY0MDB6TTUwMCA0MDBsMTUwIC0xNTBsMTUwIDE1MHYtNDAwaC00MDBsMTUwIDE1MGwtMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNmUiIHVuaWNvZGU9IiYjeGUwNmU7IiAKZD0iTTEwMCA4MDBsMTUwIC0xNTBsMTUwIDE1MHYtNDAwaC00MDBsMTUwIDE1MGwtMTUwIDE1MHpNNDAwIDQwMGg0MDBsLTE1MCAtMTUwbDE1MCAtMTUwbC0xMDAgLTEwMGwtMTUwIDE1MGwtMTUwIC0xNTB2NDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI2ZiIgdW5pY29kZT0iJiN4ZTA2ZjsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNNDAwIDcwMGMtNTYgMCAtMTA4IC0xNyAtMTUzIC00NGwyMiAtMTljMzMgLTE4IDEzIC00OCAtMTMgLTU5Yy0zMCAtMTMgLTc3IDEwIC02NSAtNDFjMTMgLTU1IC0yNyAtMyAtNDcgLTE1Yy00MiAtMjYgNDkgLTE1MiAzMSAtMTU2bC01OSAzNGMtOCAwIC0xMyAtNSAtMTYgLTEwCmMxIC0zMCAxMCAtNTcgMTkgLTg0YzI4IC0xMSA3NyAtMiAxMDAgLTI1YzQ3IC0yOCA5NyAtMTE1IDc1IC0xNTljMzQgLTEzIDY4IC0yMiAxMDYgLTIyYzEwMSAwIDE5MyA0OCAyNDcgMTI1YzMgMjQgLTggNDQgLTUwIDQ0Yy02OSAwIC0xNTYgMTMgLTE1MyA5N2MyIDQ2IDEwMSAxMDggNjYgMTQzYy0zMCAzMCAxMiAzOSAxMiA2NmMwIDM3IC02NSAzMiAtNjkgNTBzMjAgMzYgNDEgNTZjLTMwIDEwIC02MCAxOSAtOTQgMTl6TTYzMSA1OTEKYy0zOCAtMTEgLTk0IC0zNSAtODcgLTUzYzYgLTE1IDUyIC0xIDY1IC0xM2MxMSAtMTAgMTYgLTU5IDQ0IC0zMWwyMiAyMnYzYy0xMSAyNiAtMjYgNTAgLTQ0IDcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3MCIgdW5pY29kZT0iJiN4ZTA3MDsiIApkPSJNNzAzIDgwMGw5NyAtMTAwbC00MDAgLTQwMGwtMTAwIDEwMGwtMjAwIC0yMDNsLTEwMCAxMDBsMzAwIDMwM2wxMDAgLTEwMHpNMCAxMDBoODAwdi0xMDBoLTgwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjcxIiB1bmljb2RlPSImI3hlMDcxOyIgCmQ9Ik0wIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMjAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNDAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNjAwIDcwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTIwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTQwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTYwMCA1MDBoMTAwdi0xMDBoLTEwMHYxMDB6TTAgMzAwaDEwMHYtMTAwaC0xMDB2MTAwek0yMDAgMzAwaDEwMAp2LTEwMGgtMTAwdjEwMHpNNDAwIDMwMGgxMDB2LTEwMGgtMTAwdjEwMHpNNjAwIDMwMGgxMDB2LTEwMGgtMTAwdjEwMHpNMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTIwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTQwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6TTYwMCAxMDBoMTAwdi0xMDBoLTEwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjcyIiB1bmljb2RlPSImI3hlMDcyOyIgCmQ9Ik0wIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNMzAwIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNNjAwIDgwMGgyMDB2LTIwMGgtMjAwdjIwMHpNMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTMwMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTYwMCA1MDBoMjAwdi0yMDBoLTIwMHYyMDB6TTAgMjAwaDIwMHYtMjAwaC0yMDB2MjAwek0zMDAgMjAwaDIwMHYtMjAwaC0yMDB2MjAwek02MDAgMjAwaDIwMHYtMjAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3MyIgdW5pY29kZT0iJiN4ZTA3MzsiIApkPSJNMCA4MDBoMzAwdi0zMDBoLTMwMHYzMDB6TTUwMCA4MDBoMzAwdi0zMDBoLTMwMHYzMDB6TTAgMzAwaDMwMHYtMzAwaC0zMDB2MzAwek01MDAgMzAwaDMwMHYtMzAwaC0zMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3NCIgdW5pY29kZT0iJiN4ZTA3NDsiIApkPSJNMTkgODAwaDY2MmMxMSAwIDE5IC04IDE5IC0xOXYtMzMxYzAgLTI4IC0yMiAtNTAgLTUwIC01MGgtNjAwYy0yOCAwIC01MCAyMiAtNTAgNTB2MzMxYzAgMTEgOCAxOSAxOSAxOXpNMCAzMDljMTYgLTYgMzIgLTkgNTAgLTloNjAwYzE4IDAgMzQgMyA1MCA5di0yOTBjMCAtMTEgLTggLTE5IC0xOSAtMTloLTY2MmMtMTEgMCAtMTkgOCAtMTkgMTl2Mjkwek01NTAgMjAwYy0yOCAwIC01MCAtMjIgLTUwIC01MHMyMiAtNTAgNTAgLTUwCnM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3NSIgdW5pY29kZT0iJiN4ZTA3NTsiIApkPSJNMCA3MDBoMzAwdi0xMDBoLTUwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtMTUwaDMwMHYxNTBjMCAyOCAtMjIgNTAgLTUwIDUwaC01MHYxMDBoMzAwdi0xMDBoLTUwYy0yOCAwIC01MCAtMjIgLTUwIC01MHYtNDAwYzAgLTI4IDIyIC01MCA1MCAtNTBoNTB2LTEwMGgtMzAwdjEwMGg1MGMyOCAwIDUwIDIyIDUwIDUwdjE1MGgtMzAwdi0xNTBjMCAtMjggMjIgLTUwIDUwIC01MGg1MHYtMTAwaC0zMDB2MTAwaDUwYzI4IDAgNTAgMjIgNTAgNTAKdjQwMGMwIDI4IC0yMiA1MCAtNTAgNTBoLTUwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNzYiIHVuaWNvZGU9IiYjeGUwNzY7IiAKZD0iTTQwMCA3MDBjMTY1IDAgMzAwIC0xMzUgMzAwIC0zMDB2LTEwMGg1MGMyOCAwIDUwIC0yMiA1MCAtNTB2LTIwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTEwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjM1MGMwIDExMSAtODkgMjAwIC0yMDAgMjAwcy0yMDAgLTg5IC0yMDAgLTIwMHYtMzUwYzAgLTI4IC0yMiAtNTAgLTUwIC01MGgtMTAwYy0yOCAwIC01MCAyMiAtNTAgNTB2MjAwYzAgMjggMjIgNTAgNTAgNTBoNTB2MTAwCmMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijc3IiB1bmljb2RlPSImI3hlMDc3OyIgCmQ9Ik0wIDUwMGMwIDEwOSA5MSAyMDAgMjAwIDIwMHMyMDAgLTkxIDIwMCAtMjAwYzAgMTA5IDkxIDIwMCAyMDAgMjAwczIwMCAtOTEgMjAwIC0yMDBjMCAtNTUgLTIzIC0xMDUgLTU5IC0xNDFsLTM0MSAtMzQwbC0zNDEgMzQwYy0zNiAzNiAtNTkgODYgLTU5IDE0MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iNzgiIHVuaWNvZGU9IiYjeGUwNzg7IiAKZD0iTTQwMCA3MDBsNDAwIC0zMDBsLTEwMCAzdi00MDNoLTIwMHYyMDBoLTIwMHYtMjAwaC0yMDB2NDAwaC0xMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijc5IiB1bmljb2RlPSImI3hlMDc5OyIgCmQ9Ik0wIDgwMGg4MDB2LTgwMGgtODAwdjgwMHpNMTAwIDcwMHYtMzAwbDEwMCAxMDBsNDAwIC00MDBoMTAwdjEwMGwtMjAwIDIwMGwxMDAgMTAwbDEwMCAtMTAwdjMwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3YSIgdW5pY29kZT0iJiN4ZTA3YTsiIApkPSJNMTkgODAwaDc2MmMxMSAwIDE5IC04IDE5IC0xOXYtNzYyYzAgLTExIC04IC0xOSAtMTkgLTE5aC03NjJjLTExIDAgLTE5IDggLTE5IDE5djc2MmMwIDExIDggMTkgMTkgMTl6TTEwMCA2MDB2LTMwMGgxMDBsMTAwIC0xMDBoMjAwbDEwMCAxMDBoMTAwdjMwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3YiIgdW5pY29kZT0iJiN4ZTA3YjsiIApkPSJNMjAwIDYwMGM4MCAwIDE0MiAtNTYgMjAwIC0xMjJjNTggNjYgMTE5IDEyMiAyMDAgMTIyYzEzMSAwIDIwMCAtMTAxIDIwMCAtMjAwcy02OSAtMjAwIC0yMDAgLTIwMGMtODEgMCAtMTQyIDU2IC0yMDAgMTIyYy01OCAtNjYgLTEyMSAtMTIyIC0yMDAgLTEyMmMtMTMxIDAgLTIwMCAxMDEgLTIwMCAyMDBzNjkgMjAwIDIwMCAyMDB6TTIwMCA1MDBjLTc0IDAgLTEwMCAtNTQgLTEwMCAtMTAwczI2IC0xMDAgMTAwIC0xMDAKYzQyIDAgODggNDcgMTM0IDEwMGMtNDYgNTMgLTkyIDEwMCAtMTM0IDEwMHpNNjAwIDUwMGMtNDMgMCAtODggLTQ3IC0xMzQgLTEwMGM0NiAtNTMgOTEgLTEwMCAxMzQgLTEwMGM3NCAwIDEwMCA1NCAxMDAgMTAwcy0yNiAxMDAgLTEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjdjIiB1bmljb2RlPSImI3hlMDdjOyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0zMDAgODAwYzU1IDAgMTAwIC00NSAxMDAgLTEwMHMtNDUgLTEwMCAtMTAwIC0xMDBzLTEwMCA0NSAtMTAwIDEwMHM0NSAxMDAgMTAwIDEwMHpNMTUwIDU1MGM4MyAwIDE1MCAtNjkgMTUwIC0xNTBjMCAtNjYgLTEwMCAtMjE0IC0xMDAgLTI1MGMwIC0yOCAyMiAtNTAgNTAgLTUwczUwIDIyIDUwIDUwaDEwMGMwIC04MyAtNjcgLTE1MCAtMTUwIC0xNTBzLTE1MCA2NCAtMTUwIDE1MHMxMDAgMjIyIDEwMCAyNTBzLTIyIDUwIC01MCA1MApzLTUwIC0yMiAtNTAgLTUwaC0xMDBjMCA4MyA2NyAxNTAgMTUwIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iN2QiIHVuaWNvZGU9IiYjeGUwN2Q7IiAKZD0iTTIwMCA4MDBoNTAwdi0xMDBoLTEyMmMtNzcgLTE5NyAtMTU2IC0zOTIgLTIzNCAtNTg4bC02IC0xMmgxNjJ2LTEwMGgtNTAwdjEwMGgxMjJjNzcgMTk3IDE1NiAzOTIgMjM0IDU4OGw3IDEyaC0xNjN2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI3ZSIgdW5pY29kZT0iJiN4ZTA3ZTsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgNTAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDMwMGg4MDB2LTEwMGgtODAwdjEwMHpNMTAwIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iN2YiIHVuaWNvZGU9IiYjeGUwN2Y7IiAKZD0iTTAgNzAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDUwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCAzMDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MCIgdW5pY29kZT0iJiN4ZTA4MDsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgNTAwaDgwMHYtMTAwaC04MDB2MTAwek0wIDMwMGg4MDB2LTEwMGgtODAwdjEwMHpNMjAwIDEwMGg2MDB2LTEwMGgtNjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODEiIHVuaWNvZGU9IiYjeGUwODE7IiAKZD0iTTU1MCA4MDBjMTM4IDAgMjUwIC0xMTIgMjUwIC0yNTBzLTExMiAtMjUwIC0yNTAgLTI1MGMtMTYgMCAtMzIgMCAtNDcgM2wtMyAtM3YtMTAwaC0yMDB2LTIwMGgtMzAwdjIwMGwzMDMgMzAzYy0zIDE1IC0zIDMxIC0zIDQ3YzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNNjAwIDcwMGMtNTUgMCAtMTAwIC00NSAtMTAwIC0xMDBzNDUgLTEwMCAxMDAgLTEwMHMxMDAgNDUgMTAwIDEwMHMtNDUgMTAwIC0xMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MiIgdW5pY29kZT0iJiN4ZTA4MjsiIApkPSJNMTM0IDYwMGgzaDRoNGg1aDUwMGMyOCAwIDUwIC0yMiA1MCAtNTB2LTM1MGgxMDB2LTE1MGMwIC0yOCAtMjIgLTUwIC01MCAtNTBoLTcwMGMtMjggMCAtNTAgMjIgLTUwIDUwdjE1MGgxMDB2MzUwdjJjMCAyMCAxNSA0MiAzNCA0OHpNMjAwIDUwMHYtMzAwaDEwMHYtMTAwaDIwMHYxMDBoMTAwdjMwMGgtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4MyIgdW5pY29kZT0iJiN4ZTA4MzsiIApkPSJNMCA4MDBoNDAwdi00MDBoLTQwMHY0MDB6TTUwMCA2MDBoMTAwdi00MDBoLTQwMHYxMDBoMzAwdjMwMHpNNzAwIDQwMGgxMDB2LTQwMGgtNDAwdjEwMGgzMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4NCIgdW5pY29kZT0iJiN4ZTA4NDsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzM3IDY5NGM2IDQgMTIgNyAyMSA3YzI4IDAgNTAgLTIyIDUwIC01MGMwIC0xNyAtMTIgLTM3IC0yNyAtNDVsLTMwMCAtMTUwYy04IC02IC0yMSAtMTEgLTMxIC0xMWMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMjEgMTYgNDQgMzcgNDl6TTQzNyA1NDRjNiA0IDEyIDcgMjEgN2MyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTcgLTEyIC0zNyAtMjcgLTQ1bC00MDAgLTIwMGMtOCAtNiAtMjEgLTExIC0zMSAtMTFjLTI4IDAgLTUwIDIyIC01MCA1MApjMCAyMSAxNiA0NCAzNyA0OXpNNDM3IDM0NGM2IDQgMTIgNyAyMSA3YzI4IDAgNTAgLTIyIDUwIC01MGMwIC0xNyAtMTIgLTM3IC0yNyAtNDVsLTEwNiAtNTZjMjQgLTQgNDMgLTI2IDQzIC01MGMwIC0yOCAtMjMgLTUxIC01MSAtNTFjLTIgMCAtNiAxIC04IDFoLTIwMGMtMjYgMSAtNDggMjQgLTQ4IDUwYzAgMTYgMTIgMzYgMjYgNDR6TTE1MSAtNTBjMCAyMyAyMCA1MCA0NiA1MGgzaDRoNWgxMDBjMjggMCA1MCAtMjIgNTAgLTUwCnMtMjIgLTUwIC01MCAtNTBoLTEwMGMtMiAwIC02IC0xIC04IC0xYy0yOCAwIC01MCAyMyAtNTAgNTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijg1IiB1bmljb2RlPSImI3hlMDg1OyIgCmQ9Ik0xOTkgODAwaDEwMHYtMjAwaC0yMDB2MTAwaDEwMHYxMDB6TTU4NiA3OTdoMWMxOCAxIDM4IDEgNTYgLTNjMzYgLTggNjkgLTI2IDk3IC01NGM3OCAtNzggNzggLTIwMyAwIC0yODFsLTE1MCAtMTUwYy04IC0xMyAtMjggLTI0IC00MyAtMjRjLTI4IDAgLTUwIDIyIC01MCA1MGMwIDE1IDExIDM1IDI0IDQzbDE1MCAxNTBjNDAgNDAgMzkgMTA1IDAgMTQ0Yy00MSA0MSAtMTEwIDM0IC0xNDQgMGwtNDQgLTQ0CmMtOCAtMTMgLTI3IC0yNCAtNDIgLTI0Yy0yOCAwIC01MCAyMiAtNTAgNTBjMCAxNSAxMSAzNSAyNCA0M2w0MyA0NGMzMiAzMyA3MiA1MyAxMjggNTZ6TTIwOCA0OTBjNCA1IDE0IDE2IDIyIDE2aDNjMiAwIDYgMSA4IDFjMjggMCA1MCAtMjIgNTAgLTUwYzAgLTExIC02IC0yNyAtMTQgLTM1bC0xNTAgLTE1MGMtNDAgLTQwIC0zOSAtMTA1IDAgLTE0NGM0MSAtNDEgMTEwIC0zNCAxNDQgMGw0NCA0NGM4IDEzIDI3IDI0IDQyIDI0CmMyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTUgLTExIC0zNSAtMjQgLTQzbC00MyAtNDRjLTIyIC0yMiAtNDggLTM3IC03NSAtNDdjLTcwIC0yNSAtMTUxIC05IC0yMDcgNDdjLTc4IDc4IC03OCAyMDMgMCAyODF6TTQ5OSAyMDBoMjAwdi0xMDBoLTEwMHYtMTAwaC0xMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4NiIgdW5pY29kZT0iJiN4ZTA4NjsiIApkPSJNNTg2IDc5N2MxOCAxIDM5IDEgNTcgLTNjMzYgLTggNjkgLTI2IDk3IC01NGM3OCAtNzggNzggLTIwMyAwIC0yODFsLTE1MCAtMTUwYy02MiAtNjIgLTEzMiAtODEgLTE4MiAtNzhzLTY5IDE3IC04NCAyNXMtMjYgMjcgLTI2IDQ0YzAgMjggMjIgNTEgNTAgNTFjOCAwIDE5IC0zIDI2IC03YzAgMCAxNSAtMTEgNDEgLTEzczYyIDMgMTA2IDQ3bDE1MCAxNTBjNDAgNDAgMzkgMTA1IDAgMTQ0Yy00MSA0MSAtMTEwIDM0IC0xNDQgMApjLTggLTEzIC0yOCAtMjQgLTQzIC0yNGMtMjggMCAtNTAgMjIgLTUwIDUwYzAgMTUgMTEgMzUgMjQgNDNjMzIgMzMgNzIgNTMgMTI4IDU2ek0zODYgNTY2YzUwIC0yIDY0IC0xNyA4NSAtMjJzMzcgLTI4IDM3IC00OWMwIC0yOCAtMjIgLTUwIC01MCAtNTBjLTEwIDAgLTIzIDUgLTMxIDExYzAgMCAtMTkgOSAtNDcgMTBzLTYzIC00IC0xMDMgLTQ0bC0xNTAgLTE1MGMtNDAgLTQwIC0zOSAtMTA1IDAgLTE0NGM0MSAtNDEgMTEwIC0zNCAxNDQgMApjOCAxMyAyNyAyNCA0MiAyNGMyOCAwIDUwIC0yMiA1MCAtNTBjMCAtMTUgLTEwIC0zNSAtMjMgLTQzYy0yMiAtMjIgLTQ4IC0zNyAtNzUgLTQ3Yy03MCAtMjUgLTE1MSAtOSAtMjA3IDQ3Yy03OCA3OCAtNzggMjAzIDAgMjgxbDE1MCAxNTBjNjAgNjAgMTI4IDc4IDE3OCA3NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODciIHVuaWNvZGU9IiYjeGUwODc7IiAKZD0iTTAgNzAwaDMwMHYtMzAwaC0zMDB2MzAwek00MDAgNzAwaDQwMHYtMTAwaC00MDB2MTAwek00MDAgNTAwaDMwMHYtMTAwaC0zMDB2MTAwek0wIDMwMGgzMDB2LTMwMGgtMzAwdjMwMHpNNDAwIDMwMGg0MDB2LTEwMGgtNDAwdjEwMHpNNDAwIDEwMGgzMDB2LTEwMGgtMzAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iODgiIHVuaWNvZGU9IiYjeGUwODg7IiAKZD0iTTUwIDcwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTIwMCA3MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTUwIDUwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTIwMCA1MDBoNjAwdi0xMDBoLTYwMHYxMDB6TTUwIDMwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTAKczIyIDUwIDUwIDUwek0yMDAgMzAwaDYwMHYtMTAwaC02MDB2MTAwek01MCAxMDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0yMDAgMTAwaDYwMHYtMTAwaC02MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4OSIgdW5pY29kZT0iJiN4ZTA4OTsiIApkPSJNODAwIDgwMGwtNDAwIC04MDBsLTEwMCAzMDBsLTMwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhhIiB1bmljb2RlPSImI3hlMDhhOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0zMDAgNzAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDB2LTEwMGgxMDB2LTQwMGgtNjAwdjQwMGgxMDB2MTAwYzAgMTEwIDkwIDIwMCAyMDAgMjAwek0zMDAgNjAwYy01NiAwIC0xMDAgLTQ0IC0xMDAgLTEwMHYtMTAwaDIwMHYxMDBjMCA1NiAtNDQgMTAwIC0xMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4YiIgdW5pY29kZT0iJiN4ZTA4YjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDgwMGMxMTAgMCAyMDAgLTkwIDIwMCAtMjAwdi0yMDBoMTAwdi00MDBoLTYwMHY0MDBoNDAwdjIwMGMwIDU2IC00NCAxMDAgLTEwMCAxMDBzLTEwMCAtNDQgLTEwMCAtMTAwaC0xMDBjMCAxMTAgOTAgMjAwIDIwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhjIiB1bmljb2RlPSImI3hlMDhjOyIgCmQ9Ik00MDAgNzAwdi0xMDBjLTExMSAwIC0yMDAgLTg5IC0yMDAgLTIwMGgxMDBsLTE1MCAtMjAwbC0xNTAgMjAwaDEwMGMwIDE2NSAxMzUgMzAwIDMwMCAzMDB6TTY1MCA2MDBsMTUwIC0yMDBoLTEwMGMwIC0xNjUgLTEzNSAtMzAwIC0zMDAgLTMwMHYxMDBjMTExIDAgMjAwIDg5IDIwMCAyMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOGQiIHVuaWNvZGU9IiYjeGUwOGQ7IiAKZD0iTTEwMCA4MDBoNjAwdi0zMDBoMTAwbC0xNTAgLTI1MGwtMTUwIDI1MGgxMDB2MjAwaC00MDB2LTEwMGgtMTAwdjIwMHpNMTUwIDU1MGwxNTAgLTI1MGgtMTAwdi0yMDBoNDAwdjEwMGgxMDB2LTIwMGgtNjAwdjMwMGgtMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI4ZSIgdW5pY29kZT0iJiN4ZTA4ZTsiIApkPSJNNjAwIDcwMGwyMDAgLTE1MGwtMjAwIC0xNTB2MTAwaC01MDB2LTEwMGgtMTAwdjEwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwaDUwMHYxMDB6TTIwMCAzMDB2LTEwMGg1MDB2MTAwaDEwMHYtMTAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMGgtNTAwdi0xMDBsLTIwMCAxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjhmIiB1bmljb2RlPSImI3hlMDhmOyIgaG9yaXotYWR2LXg9IjkwMCIgCmQ9Ik0zNTAgODAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgLTYwIC0xNyAtMTE3IC00NCAtMTY2YzUgLTMgMTIgLTggMTYgLTEybDEwMCAtMTAwYzE2IC0xNiAzMCAtNDkgMzAgLTcyYzAgLTU2IC00NiAtMTAyIC0xMDIgLTEwMmMtMjMgMCAtNTYgMTQgLTcyIDMwbC0xMDAgMTAwYy00IDMgLTkgOSAtMTIgMTNjLTQ5IC0yNiAtMTA3IC00MSAtMTY2IC00MWMtMTkzIDAgLTM1MCAxNTcgLTM1MCAzNTBzMTU3IDM1MCAzNTAgMzUwek0zNTAgMjAwCmMxNDIgMCAyNTAgMTA4IDI1MCAyNTBjMCAxMzkgLTExMSAyNTAgLTI1MCAyNTBzLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTAiIHVuaWNvZGU9IiYjeGUwOTA7IiBob3Jpei1hZHYteD0iNjAwIiAKZD0iTTMwMCA4MDBjMTY2IDAgMzAwIC0xMzQgMzAwIC0zMDBjMCAtMjAwIC0zMDAgLTUwMCAtMzAwIC01MDBzLTMwMCAzMDAgLTMwMCA1MDBjMCAxNjYgMTM0IDMwMCAzMDAgMzAwek0zMDAgNzAwYy0xMTAgMCAtMjAwIC05MCAtMjAwIC0yMDBzOTAgLTIwMCAyMDAgLTIwMHMyMDAgOTAgMjAwIDIwMHMtOTAgMjAwIC0yMDAgMjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5MSIgdW5pY29kZT0iJiN4ZTA5MTsiIGhvcml6LWFkdi14PSI5MDAiIApkPSJNMCA4MDBoODAwdi01NDFjMSAtMyAxIC04IDEgLTExczAgLTcgLTEgLTEwdi0yMzhoLTgwMHY4MDB6TTQ5NSAyNTBjMCAyNiAyMiA1MCA1MCA1MGg1aDE1MHY0MDBoLTYwMHYtNjAwaDYwMHYxMDBoLTE1MGgtNWMtMjggMCAtNTAgMjIgLTUwIDUwek0zNTAgNjAwYzgzIDAgMTUwIC02NyAxNTAgLTE1MGMwIC0xMDAgLTE1MCAtMjUwIC0xNTAgLTI1MHMtMTUwIDE1MCAtMTUwIDI1MGMwIDgzIDY3IDE1MCAxNTAgMTUwek0zNTAgNTAwCmMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5MiIgdW5pY29kZT0iJiN4ZTA5MjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMCA3MDBoMjAwdi02MDBoLTIwMHY2MDB6TTQwMCA3MDBoMjAwdi02MDBoLTIwMHY2MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjkzIiB1bmljb2RlPSImI3hlMDkzOyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0wIDcwMGw2MDAgLTMwMGwtNjAwIC0zMDB2NjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5NCIgdW5pY29kZT0iJiN4ZTA5NDsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzAwIDcwMGMxNjYgMCAzMDAgLTEzNCAzMDAgLTMwMHMtMTM0IC0zMDAgLTMwMCAtMzAwcy0zMDAgMTM0IC0zMDAgMzAwczEzNCAzMDAgMzAwIDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTUiIHVuaWNvZGU9IiYjeGUwOTU7IiAKZD0iTTQwMCA3MDB2LTYwMGwtNDAwIDMwMHpNNDAwIDQwMGw0MDAgMzAwdi02MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijk2IiB1bmljb2RlPSImI3hlMDk2OyIgCmQ9Ik0wIDcwMGw0MDAgLTMwMGwtNDAwIC0zMDB2NjAwek00MDAgMTAwdjYwMGw0MDAgLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTciIHVuaWNvZGU9IiYjeGUwOTc7IiAKZD0iTTAgNzAwaDIwMHYtNjAwaC0yMDB2NjAwek0yMDAgNDAwbDUwMCAzMDB2LTYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOTgiIHVuaWNvZGU9IiYjeGUwOTg7IiAKZD0iTTAgNzAwbDUwMCAtMzAwbC01MDAgLTMwMHY2MDB6TTUwMCAxMDB2NjAwaDIwMHYtNjAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ijk5IiB1bmljb2RlPSImI3hlMDk5OyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0wIDcwMGg2MDB2LTYwMGgtNjAwdjYwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iOWEiIHVuaWNvZGU9IiYjeGUwOWE7IiAKZD0iTTIwMCA4MDBoNDAwdi0yMDBoMjAwdi00MDBoLTIwMHYtMjAwaC00MDB2MjAwaC0yMDB2NDAwaDIwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjliIiB1bmljb2RlPSImI3hlMDliOyIgCmQ9Ik0wIDcwMGg4MDB2LTEwMGgtODAwdjEwMHpNMCA0MDNoODAwdi0xMDBoLTgwMHYxMDB6TTAgMTAzaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5YyIgdW5pY29kZT0iJiN4ZTA5YzsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjc4IDcwMGM3IDIgMTMgNCAyMiA0YzU1IDAgMTAwIC00NSAxMDAgLTEwMHYtNHYtMjAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwdjIwMHYyYzAgNDQgMzUgODggNzggOTh6TTM0IDUwMGg0aDNjMyAwIDYgMSA5IDFjMjggMCA1MCAtMjIgNTAgLTUwdi0xdi01MGMwIC0xMTEgODkgLTIwMCAyMDAgLTIwMHMyMDAgODkgMjAwIDIwMHY1MGMwIDI4IDIyIDUwIDUwIDUwczUwIC0yMiA1MCAtNTB2LTUwCmMwIC0xNDggLTEwOSAtMjcwIC0yNTAgLTI5NHYtMTA2aDUwYzU1IDAgMTAwIC00NSAxMDAgLTEwMGgtNDAwYzAgNTUgNDUgMTAwIDEwMCAxMDBoNTB2MTA2Yy0xNDEgMjQgLTI1MCAxNDYgLTI1MCAyOTR2NTB2MmMwIDIwIDE1IDQyIDM0IDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5ZCIgdW5pY29kZT0iJiN4ZTA5ZDsiIApkPSJNMCA1MDBoODAwdi0yMDBoLTgwMHYyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IjllIiB1bmljb2RlPSImI3hlMDllOyIgCmQ9Ik0zNCA3MDBoNGgzaDRoNWg3MDBjMjggMCA1MCAtMjIgNTAgLTUwdi01MDBjMCAtMjggLTIyIC01MCAtNTAgLTUwaC0yNTB2LTEwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaC02MDBjMCA1NSA0NSAxMDAgMTAwIDEwMGgxMDB2MTAwaC0yNTBjLTI4IDAgLTUwIDIyIC01MCA1MHY1MDB2MmMwIDIwIDE1IDQyIDM0IDQ4ek0xMDAgNjAwdi00MDBoNjAwdjQwMGgtNjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSI5ZiIgdW5pY29kZT0iJiN4ZTA5ZjsiIApkPSJNMjcyIDcwMGMtMTQgLTQwIC0yMiAtODMgLTIyIC0xMjhjMCAtMjIxIDE3OSAtNDAwIDQwMCAtNDAwYzQ1IDAgODggOCAxMjggMjJjLTUzIC0xNTggLTIwMiAtMjcyIC0zNzggLTI3MmMtMjIxIDAgLTQwMCAxNzkgLTQwMCA0MDBjMCAxNzYgMTE0IDMyNSAyNzIgMzc4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhMCIgdW5pY29kZT0iJiN4ZTBhMDsiIApkPSJNMzUwIDcwMGwxNTAgLTE1MGgtMTAwdi0xNTBoMTUwdjEwMGwxNTAgLTE1MGwtMTUwIC0xNTB2MTAwaC0xNTB2LTE1MGgxMDBsLTE1MCAtMTUwbC0xNTAgMTUwaDEwMHYxNTBoLTE1MHYtMTAwbC0xNTAgMTUwbDE1MCAxNTB2LTEwMGgxNTB2MTUwaC0xMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImExIiB1bmljb2RlPSImI3hlMGExOyIgCmQ9Ik04MDAgODAwdi01NTBjMCAtODMgLTY3IC0xNTAgLTE1MCAtMTUwcy0xNTAgNjcgLTE1MCAxNTBzNjcgMTUwIDE1MCAxNTBjMTcgMCAzNSAtNCA1MCAtOXYyMDZjLTIwMSAtNiAtMzI3IC0yNyAtNDAwIC01MHYtMzk3YzAgLTgzIC02NyAtMTUwIC0xNTAgLTE1MHMtMTUwIDY3IC0xNTAgMTUwczY3IDE1MCAxNTAgMTUwYzE3IDAgMzUgLTQgNTAgLTl2NDA5czEwMCAxMDAgNjAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYTIiIHVuaWNvZGU9IiYjeGUwYTI7IiBob3Jpei1hZHYteD0iNzAwIiAKZD0iTTQ5OSA3MDBjNTEgMCAxMDIgLTIwIDE0MSAtNTljNzggLTc4IDc4IC0yMDMgMCAtMjgxbC0yNTAgLTI0NGMtNDggLTQ4IC0xMjcgLTQ4IC0xNzUgMHMtNDggMTI3IDAgMTc1bDk2IDk3bDY5IC02OWwtOTAgLTk0bC03IC0zYy0xMCAtMTAgLTEwIC0yOCAwIC0zOHMyOCAtMTAgMzggMGwyNTAgMjQ3YzM3IDQwIDM5IDEwMiAwIDE0MXMtMTA0IDQwIC0xNDQgMGwtMjc4IC0yNzVjLTY2IC02OSAtNjggLTE3OSAwIC0yNDcKYzY5IC02OSAxODEgLTY5IDI1MCAwbDkgMTJsMTE2IDExM2w2OSAtNjlsLTEyNSAtMTI1Yy0xMDcgLTEwNyAtMjgxIC0xMDcgLTM4OCAwcy0xMDcgMjgxIDAgMzg4bDI3OCAyNzJjMzkgMzkgOTAgNTkgMTQxIDU5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhMyIgdW5pY29kZT0iJiN4ZTBhMzsiIApkPSJNNjAwIDgwMGwyMDAgLTIwMGwtMTAwIC0xMDBsLTIwMCAyMDB6TTQwMCA2MDBsMjAwIC0yMDBsLTQwMCAtNDAwaC0yMDB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNCIgdW5pY29kZT0iJiN4ZTBhNDsiIApkPSJNNTUwIDgwMGM4MyAwIDE1MCAtOTAgMTUwIC0yMDBzLTY3IC0yMDAgLTE1MCAtMjAwYy0yMiAwIC00MCA4IC01OSAxOWM2IDI2IDkgNTIgOSA4MWMwIDg0IC0yNyAxNTggLTcyIDIxMmMyNyA1MiA3MSA4OCAxMjIgODh6TTI1MCA3MDBjODMgMCAxNTAgLTkwIDE1MCAtMjAwcy02NyAtMjAwIC0xNTAgLTIwMHMtMTUwIDkwIC0xNTAgMjAwczY3IDIwMCAxNTAgMjAwek03MjUgMzg0YzQ0IC0yMiA3NSAtNjYgNzUgLTExOHYtMTY2aC0yMDB2NjYKYzAgNTAgLTE3IDk2IC00NCAxMzRjNjYgMiAxMjYgMzMgMTY5IDg0ek03NSAyODRjNDUgLTUzIDEwNiAtODQgMTc1IC04NHMxMzAgMzEgMTc1IDg0YzQ0IC0yMiA3NSAtNjYgNzUgLTExOHYtMTY2aC01MDB2MTY2YzAgNTIgMzEgOTYgNzUgMTE4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNSIgdW5pY29kZT0iJiN4ZTBhNTsiIApkPSJNNDAwIDgwMGMxMTAgMCAyMDAgLTExMiAyMDAgLTI1MHMtOTAgLTI1MCAtMjAwIC0yNTBzLTIwMCAxMTIgLTIwMCAyNTBzOTAgMjUwIDIwMCAyNTB6TTE5MSAzMDBjNTQgLTYxIDEyOCAtMTAwIDIwOSAtMTAwczE1NSAzOSAyMDkgMTAwYzEwNiAtNSAxOTEgLTkyIDE5MSAtMjAwdi0xMDBoLTgwMHYxMDBjMCAxMDggODUgMTk1IDE5MSAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImE2IiB1bmljb2RlPSImI3hlMGE2OyIgaG9yaXotYWR2LXg9IjYwMCIgCmQ9Ik0xOSA4MDBoNDYyYzExIDAgMTkgLTggMTkgLTE5di03NjJjMCAtMTEgLTggLTE5IC0xOSAtMTloLTQ2MmMtMTEgMCAtMTkgOCAtMTkgMTl2NzYyYzAgMTEgOCAxOSAxOSAxOXpNMTAwIDcwMHYtNTAwaDMwMHY1MDBoLTMwMHpNMjUwIDE1MGMtMjggMCAtNTAgLTIyIC01MCAtNTBzMjIgLTUwIDUwIC01MHM1MCAyMiA1MCA1MHMtMjIgNTAgLTUwIDUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhNyIgdW5pY29kZT0iJiN4ZTBhNzsiIApkPSJNMzUwIDgwMGMxNyAwIDM0IC0xIDUwIC0zdi0zOTdsLTI5NyAyOTdjNjMgNjQgMTUwIDEwMyAyNDcgMTAzek01MDAgNjk0YzE2OSAtMjUgMzAwIC0xNjggMzAwIC0zNDRjMCAtMTkzIC0xNTcgLTM1MCAtMzUwIC0zNTBjLTg1IDAgLTE2MSAzMSAtMjIyIDgxbDI3MiAyNzJ2MzQxek05MSA1NjJsMjM3IC0yMzRsLTIxMiAtMjEyYy03MCA1NSAtMTE2IDEzOCAtMTE2IDIzNGMwIDg0IDM1IDE1OCA5MSAyMTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImE4IiB1bmljb2RlPSImI3hlMGE4OyIgCmQ9Ik05MiA2NTBjMCAyMyAyMCA1MCA0NiA1MGgzaDRoNWg0MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MGgtNTB2LTIwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaC0zMDB2LTMwMGwtNTYgLTEwMGwtNDQgMTAwdjMwMGgtMzAwYzAgNTUgNDUgMTAwIDEwMCAxMDBoMTAwdjIwMGgtNTBjLTIgMCAtNiAtMSAtOCAtMWMtMjggMCAtNTAgMjMgLTUwIDUxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhOSIgdW5pY29kZT0iJiN4ZTBhOTsiIApkPSJNNDAwIDgwMGMyMjEgMCA0MDAgLTE3OSA0MDAgLTQwMHMtMTc5IC00MDAgLTQwMCAtNDAwcy00MDAgMTc5IC00MDAgNDAwczE3OSA0MDAgNDAwIDQwMHpNMzAwIDYwMHYtNDAwbDMwMCAyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFhIiB1bmljb2RlPSImI3hlMGFhOyIgCmQ9Ik0zMDAgODAwaDIwMHYtMzAwaDMwMHYtMjAwaC0zMDB2LTMwMGgtMjAwdjMwMGgtMzAwdjIwMGgzMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYiIgdW5pY29kZT0iJiN4ZTBhYjsiIApkPSJNMzAwIDgwMGgxMDB2LTQwMGgtMTAwdjQwMHpNMTcyIDY1Nmw2MiAtNzhsLTQwIC0zMWMtNTggLTQ2IC05NCAtMTE3IC05NCAtMTk3YzAgLTEzOSAxMTEgLTI1MCAyNTAgLTI1MHMyNTAgMTExIDI1MCAyNTBjMCA4MCAtMzkgMTUxIC05NyAxOTdsLTM3IDMxbDYyIDc4bDM4IC0zMWM4MiAtNjQgMTM0IC0xNjQgMTM0IC0yNzVjMCAtMTkzIC0xNTcgLTM1MCAtMzUwIC0zNTBzLTM1MCAxNTcgLTM1MCAzNTBjMCAxMTEgNTMgMjExIDEzNCAyNzV6CiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYyIgdW5pY29kZT0iJiN4ZTBhYzsiIApkPSJNMjAwIDgwMGg0MDB2LTIwMGgtNDAwdjIwMHpNOSA1MDBoNzgyYzYgMCA5IC0zIDkgLTl2LTI4MmMwIC02IC0zIC05IC05IC05aC05MXYyMDBoLTYwMHYtMjAwaC05MWMtNiAwIC05IDMgLTkgOXYyODJjMCA2IDMgOSA5IDl6TTIwMCAzMDBoNDAwdi0zMDBoLTQwMHYzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFkIiB1bmljb2RlPSImI3hlMGFkOyIgCmQ9Ik0wIDcwMGgxMDB2LTcwMGgtMTAwdjcwMHpNNzAwIDcwMGgxMDB2LTcwMGgtMTAwdjcwMHpNMjAwIDYwMGgyMDB2LTEwMGgtMjAwdjEwMHpNMzAwIDQwMGgyMDB2LTEwMGgtMjAwdjEwMHpNNDAwIDIwMGgyMDB2LTEwMGgtMjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWUiIHVuaWNvZGU9IiYjeGUwYWU7IiAKZD0iTTMyNSA3MDBjNDIgLTE0MSA4NyAtMjgwIDEzMSAtNDE5YzI5IDc0IDU5IDE0OCA4OCAyMjJjMzAgLTU3IDU4IC0xMTQgODcgLTE3MmgxNjl2LTEwMGgtMjMxbC0xMyAyOGMtMzcgLTkyIC03NCAtMTg0IC0xMTIgLTI3NWMtMzggMTI5IC03OSAyNTcgLTExOSAzODVjLTQyIC0xMzMgLTgzIC0yNjcgLTEyNSAtNDAwYy0yOCA4OCAtNTYgMTc1IC04NCAyNjJoLTExNnYxMDBoMTg4bDkgLTM0bDMgLTZjNDIgMTM3IDgzIDI3MyAxMjUgNDA5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhZiIgdW5pY29kZT0iJiN4ZTBhZjsiIApkPSJNMjAwIDYwMGMwIDU3IDQzIDEwMCAxMDAgMTAwczEwMCAtNDMgMTAwIC0xMDBjMCAtMjggLTE4IC00OCAtMjggLTcyYy0zIC02IC0zIC0xNiAtMyAtMjhoMjMxdi0yMzFjMTIgMCAyMiAwIDI4IDNjMjQgMTAgNDQgMjggNzIgMjhjNTcgMCAxMDAgLTQzIDEwMCAtMTAwcy00MyAtMTAwIC0xMDAgLTEwMGMtMjggMCAtNDggMTggLTcyIDI4Yy02IDMgLTE2IDMgLTI4IDN2LTIzMWgtMjMxYzAgMTIgMCAyMiAzIDI4YzEwIDI0IDI4IDQ0IDI4IDcyCmMwIDU3IC00MyAxMDAgLTEwMCAxMDBzLTEwMCAtNDMgLTEwMCAtMTAwYzAgLTI4IDE4IC00OCAyOCAtNzJjMyAtNiAzIC0xNiAzIC0yOGgtMjMxdjYwMGgyMzFjMCAxMiAwIDIyIC0zIDI4Yy0xMCAyNCAtMjggNDQgLTI4IDcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiMCIgdW5pY29kZT0iJiN4ZTBiMDsiIGhvcml6LWFkdi14PSI1MDAiIApkPSJNMjQ3IDcwMGM4NCAwIDE0OCAtMjAgMTkxIC01OXM1OSAtOTMgNTkgLTE0MWMwIC0xMTcgLTY5IC0xODEgLTExOSAtMjI1cy04MSAtNjcgLTgxIC0xNTB2LTI1aC0xMDB2MjVjMCAxMTcgNjUgMTgxIDExNSAyMjVzODUgNjcgODUgMTUwYzAgMjUgLTggNDggLTI4IDY2cy01NiAzNCAtMTIyIDM0cy05NyAtMTggLTExNiAtMzdzLTI3IC00MyAtMzEgLTY5bC0xMDAgMTJjNSAzOCAxOSA4OCA1OSAxMjhzMTAzIDY2IDE4OCA2NnpNMTk3IDBoMTAwCnYtMTAwaC0xMDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiMSIgdW5pY29kZT0iJiN4ZTBiMTsiIApkPSJNNDUwIDgwMGMxMzggMCAyNTAgLTExMiAyNTAgLTI1MHYtNTBjNTggLTIxIDEwMCAtODUgMTAwIC0xNTBjMCAtNjkgLTQ4IC0xMjcgLTExMiAtMTQ0Yy0yMiA1NSAtNzUgOTQgLTEzOCA5NGMtMjAgMCAtMzkgLTUgLTU2IC0xMmMtMTcgNjQgLTc1IDExMiAtMTQ0IDExMnMtMTI3IC00OCAtMTQ0IC0xMTJjLTE3IDcgLTM2IDEyIC01NiAxMmMtMzcgMCAtNzEgLTEyIC05NyAtMzRjLTMzIDM2IC01MyA4MiAtNTMgMTM0CmMwIDExMCA5MCAyMDAgMjAwIDIwMGMyMyAxMTQgMTI5IDIwMCAyNTAgMjAwek0zMzQgMzAwaDRoM2MzIDAgNiAxIDkgMWMyOCAwIDUwIC0yMiA1MCAtNTB2LTF2LTIwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHYyMDB2MmMwIDIwIDE1IDQyIDM0IDQ4ek0xMzQgMjAwaDRoM2MzIDAgNiAxIDkgMWMyOCAwIDUwIC0yMiA1MCAtNTB2LTF2LTEwMGMwIC0yOCAtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHYxMDB2MgpjMCAyMCAxNSA0MiAzNCA0OHpNNTM0IDIwMGgzaDRjMyAwIDYgMSA5IDFjMjggMCA1MCAtMjIgNTAgLTUwdi0xdi0xMDBjMCAtMjggLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTB2MTAwdjJjMCAyMCAxNSA0MiAzNCA0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjIiIHVuaWNvZGU9IiYjeGUwYjI7IiAKZD0iTTYwMCA4MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNTBsLTE1MyAtMTkxbDE3NSAtMjA2bDYgLTNoMjJ2MTAwbDIwMCAtMTUwbC0yMDAgLTE1MHYxMDBoLTI1Yy0zNSAwIC01NiAxMiAtNzggMzhsLTE2NiAxOTBsLTE1MyAtMTkwYy0yMiAtMjcgLTQzIC0zOCAtNzggLTM4aC0xMDB2MTAwaDEwMGwxNjYgMjA2bC0xNjMgMTkxbC0zIDNoLTEwMHYxMDBoMTAwYzM0IDAgNTYgLTEyIDc4IC0zOGwxNTMgLTE3OGwxNDEgMTc4CmMyMiAyNyA0MyAzOCA3OCAzOGg1MHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImIzIiB1bmljb2RlPSImI3hlMGIzOyIgCmQ9Ik00MDAgODAwYzExMCAwIDIwOSAtNDcgMjgxIC0xMTlsMTE5IDExOXYtMzAwaC0zMDBsMTA5IDEwOWMtNTQgNTUgLTEyNiA5MSAtMjA5IDkxYy0xNjYgMCAtMzAwIC0xMzQgLTMwMCAtMzAwczEzNCAtMzAwIDMwMCAtMzAwYzgzIDAgMTU4IDM0IDIxMiA4OGw3MiAtNzJjLTcyIC03MiAtMTc0IC0xMTYgLTI4NCAtMTE2Yy0yMjAgMCAtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImI0IiB1bmljb2RlPSImI3hlMGI0OyIgCmQ9Ik00MDAgODAwaDQwMHYtNDAwbC0xNjYgMTY2bC00MDAgLTQwMGwxNjYgLTE2NmgtNDAwdjQwMGwxNjYgLTE2Nmw0MDAgNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiNSIgdW5pY29kZT0iJiN4ZTBiNTsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMjUwIDgwMGwyNTAgLTMwMGgtMjAwdi0yMDBoMjAwbC0yNTAgLTMwMGwtMjUwIDMwMGgyMDB2MjAwaC0yMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImI2IiB1bmljb2RlPSImI3hlMGI2OyIgCmQ9Ik0zMDAgNjAwdi0yMDBoMjAwdjIwMGwzMDAgLTI1MGwtMzAwIC0yNTB2MjAwaC0yMDB2LTIwMGwtMzAwIDI1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjciIHVuaWNvZGU9IiYjeGUwYjc7IiAKZD0iTTAgODAwYzQ0MSAwIDgwMCAtMzU5IDgwMCAtODAwaC0yMDBjMCAzMzMgLTI2NyA2MDAgLTYwMCA2MDB2MjAwek0wIDUwMGMyNzUgMCA1MDAgLTIyNSA1MDAgLTUwMGgtMjAwYzAgMTY3IC0xMzMgMzAwIC0zMDAgMzAwdjIwMHpNMCAyMDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMGgtMjAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYjgiIHVuaWNvZGU9IiYjeGUwYjg7IiAKZD0iTTEwMCA4MDBjMzg2IDAgNzAwIC0zMTQgNzAwIC03MDBoLTEwMGMwIDMzMiAtMjY4IDYwMCAtNjAwIDYwMHYxMDB6TTEwMCA2MDBjMjc2IDAgNTAwIC0yMjQgNTAwIC01MDBoLTEwMGMwIDIyMiAtMTc4IDQwMCAtNDAwIDQwMHYxMDB6TTEwMCA0MDBjMTY1IDAgMzAwIC0xMzUgMzAwIC0zMDBoLTEwMGMwIDExMSAtODkgMjAwIC0yMDAgMjAwdjEwMHpNMTAwIDIwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBzLTQ1IC0xMDAgLTEwMCAtMTAwCnMtMTAwIDQ1IC0xMDAgMTAwczQ1IDEwMCAxMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiOSIgdW5pY29kZT0iJiN4ZTBiOTsiIApkPSJNMzAwIDgwMGg0MDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwdi0yMDBoLTQwMHYxNTBjMCAyOCAtMjIgNTAgLTUwIDUwcy01MCAtMjIgLTUwIC01MHYtMjUwaDQwMHYtMzAwYzAgLTU1IC00NSAtMTAwIC0xMDAgLTEwMGgtNTAwYy01NSAwIC0xMDAgNDUgLTEwMCAxMDB2MjAwaDEwMHYtMTUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2NTUwYzAgNTUgNDUgMTAwIDEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJhIiB1bmljb2RlPSImI3hlMGJhOyIgCmQ9Ik03NSA3MDBoMjI1di0xMDBoLTIwMHYtNTAwaDQwMHYxMDBoMTAwdi0xMjVjMCAtNDEgLTM0IC03NSAtNzUgLTc1aC00NTBjLTQxIDAgLTc1IDM0IC03NSA3NXY1NTBjMCA0MSAzNCA3NSA3NSA3NXpNNjAwIDcwMGwyMDAgLTIwMGwtMjAwIC0yMDB2MTAwaC0yMDBjLTk0IDAgLTE3MyAtNjUgLTE5NCAtMTUzYzIzIDE5OSAxODkgMzUzIDM5NCAzNTN2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiYiIgdW5pY29kZT0iJiN4ZTBiYjsiIApkPSJNNTAwIDcwMGwzMDAgLTI4NGwtMzAwIC0zMTZ2MjAwaC0xMDBjLTIwMCAwIC0zNDggLTEwMiAtNDAwIC0zMDBjMCAyOTUgMTAwIDUwMCA1MDAgNTAwdjIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmMiIHVuaWNvZGU9IiYjeGUwYmM7IiAKZD0iTTM4MSA3OTFsMTkgOWwxOSAtOWMxMjcgLTUzIDI1MyAtMTA4IDM4MSAtMTYwdi0zMWMwIC0xNjYgLTY3IC0zMTMgLTE0NyAtNDE5Yy00MCAtNTMgLTgzIC05NyAtMTI1IC0xMjhzLTgyIC01MyAtMTI4IC01M3MtODYgMjIgLTEyOCA1M3MtODUgNzUgLTEyNSAxMjhjLTgwIDEwNyAtMTQ3IDI1MyAtMTQ3IDQxOXYzMWMxMjggNTIgMjU0IDEwNyAzODEgMTYwek00MDAgMTAwdjU5MWwtMjk0IC0xMjJjOCAtMTI2IDU4IC0yNDMgMTIyIC0zMjgKYzM1IC00NiA3MyAtODYgMTA2IC0xMTBzNjIgLTMxIDY2IC0zMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmQiIHVuaWNvZGU9IiYjeGUwYmQ7IiAKZD0iTTYwMCA4MDBoMTAwdi04MDBoLTEwMHY4MDB6TTQwMCA3MDBoMTAwdi03MDBoLTEwMHY3MDB6TTIwMCA1MDBoMTAwdi01MDBoLTEwMHY1MDB6TTAgMzAwaDEwMHYtMzAwaC0xMDB2MzAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiZSIgdW5pY29kZT0iJiN4ZTBiZTsiIApkPSJNMzAwIDgwMGgxMDB2LTIwMGgyMDBsMTAwIC0xMDBsLTEwMCAtMTAwaC0yMDB2LTQwMGgtMTAwdjUwMGgtMjAwbC0xMDAgMTAwbDEwMCAxMDBoMjAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmYiIHVuaWNvZGU9IiYjeGUwYmY7IiAKZD0iTTIwMCA4MDBoMTAwdi02MDBoMjAwbC0yNTAgLTIwMGwtMjUwIDIwMGgyMDB2NjAwek00MDAgODAwaDIwMHYtMTAwaC0yMDB2MTAwek00MDAgNjAwaDMwMHYtMTAwaC0zMDB2MTAwek00MDAgNDAwaDQwMHYtMTAwaC00MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjMCIgdW5pY29kZT0iJiN4ZTBjMDsiIApkPSJNMjAwIDgwMGgxMDB2LTYwMGgyMDBsLTI1MCAtMjAwbC0yNTAgMjAwaDIwMHY2MDB6TTQwMCA4MDBoNDAwdi0xMDBoLTQwMHYxMDB6TTQwMCA2MDBoMzAwdi0xMDBoLTMwMHYxMDB6TTQwMCA0MDBoMjAwdi0xMDBoLTIwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImMxIiB1bmljb2RlPSImI3hlMGMxOyIgCmQ9Ik03NSA3MDBoNjUwYzQxIDAgNzUgLTM0IDc1IC03NXYtNTUwYzAgLTQxIC0zNCAtNzUgLTc1IC03NWgtNjUwYy00MSAwIC03NSAzNCAtNzUgNzV2NTUwYzAgNDEgMzQgNzUgNzUgNzV6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA2MDB2LTEwMGg0MDB2MTAwaC00MDB6TTEwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA0MDB2LTEwMGg0MDB2MTAwaC00MDB6TTEwMCAyMDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCAyMDAKdi0xMDBoNDAwdjEwMGgtNDAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjMiIgdW5pY29kZT0iJiN4ZTBjMjsiIApkPSJNNDAwIDgwMGwxMDAgLTMwMGgzMDBsLTI1MCAtMjAwbDEwMCAtMzAwbC0yNTAgMjAwbC0yNTAgLTIwMGwxMDAgMzAwbC0yNTAgMjAwaDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzMiIHVuaWNvZGU9IiYjeGUwYzM7IiAKZD0iTTQwMCA4MDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0xNTAgNzAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHpNNjUwIDcwMGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTQwMCA2MDBjMTEwIDAgMjAwIC05MCAyMDAgLTIwMApzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDBzOTAgMjAwIDIwMCAyMDB6TTUwIDQ1MGMyOCAwIDUwIC0yMiA1MCAtNTBzLTIyIC01MCAtNTAgLTUwcy01MCAyMiAtNTAgNTBzMjIgNTAgNTAgNTB6TTc1MCA0NTBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek0xNTAgMjAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MApzMjIgNTAgNTAgNTB6TTY1MCAyMDBjMjggMCA1MCAtMjIgNTAgLTUwcy0yMiAtNTAgLTUwIC01MHMtNTAgMjIgLTUwIDUwczIyIDUwIDUwIDUwek00MDAgMTAwYzI4IDAgNTAgLTIyIDUwIC01MHMtMjIgLTUwIC01MCAtNTBzLTUwIDIyIC01MCA1MHMyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzQiIHVuaWNvZGU9IiYjeGUwYzQ7IiAKZD0iTTM0IDgwMGg2MzJjMTggMCAzNCAtMTYgMzQgLTM0di03MzJjMCAtMTggLTE2IC0zNCAtMzQgLTM0aC02MzJjLTE4IDAgLTM0IDE2IC0zNCAzNHY3MzJjMCAxOCAxNiAzNCAzNCAzNHpNMTAwIDcwMHYtNTAwaDUwMHY1MDBoLTUwMHpNMzUwIDE1MGMtMzggMCAtNjMgLTQyIC00NCAtNzVzNjkgLTMzIDg4IDBzLTYgNzUgLTQ0IDc1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjNSIgdW5pY29kZT0iJiN4ZTBjNTsiIApkPSJNMCA4MDBoMzAwbDUwMCAtNTAwbC0zMDAgLTMwMGwtNTAwIDUwMHYzMDB6TTIwMCA3MDBjLTU1IDAgLTEwMCAtNDUgLTEwMCAtMTAwczQ1IC0xMDAgMTAwIC0xMDBzMTAwIDQ1IDEwMCAxMDBzLTQ1IDEwMCAtMTAwIDEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzYiIHVuaWNvZGU9IiYjeGUwYzY7IiAKZD0iTTAgNjAwaDIwMGwzMDAgLTMwMGwtMjAwIC0yMDBsLTMwMCAzMDB2MjAwek0zNDAgNjAwaDE2MGwzMDAgLTMwMGwtMjAwIC0yMDBsLTc4IDc4bDExOSAxMjJ6TTE1MCA1MDBjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzciIHVuaWNvZGU9IiYjeGUwYzc7IiAKZD0iTTQwMCA4MDBjMjIwIDAgNDAwIC0xODAgNDAwIC00MDBzLTE4MCAtNDAwIC00MDAgLTQwMHMtNDAwIDE4MCAtNDAwIDQwMHMxODAgNDAwIDQwMCA0MDB6TTQwMCA3MDBjLTE2NiAwIC0zMDAgLTEzNCAtMzAwIC0zMDBzMTM0IC0zMDAgMzAwIC0zMDBzMzAwIDEzNCAzMDAgMzAwcy0xMzQgMzAwIC0zMDAgMzAwek00MDAgNjAwYzExMCAwIDIwMCAtOTAgMjAwIC0yMDBzLTkwIC0yMDAgLTIwMCAtMjAwcy0yMDAgOTAgLTIwMCAyMDAKczkwIDIwMCAyMDAgMjAwek00MDAgNTAwYy01NiAwIC0xMDAgLTQ0IC0xMDAgLTEwMHM0NCAtMTAwIDEwMCAtMTAwczEwMCA0NCAxMDAgMTAwcy00NCAxMDAgLTEwMCAxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImM4IiB1bmljb2RlPSImI3hlMGM4OyIgCmQ9Ik0wIDcwMGg1NTlsLTEwMCAtMTAwaC0zNTl2LTUwMGg1MDB2MTU5bDEwMCAxMDB2LTM1OWgtNzAwdjcwMHpNNzAwIDcwMGwxMDAgLTEwMGwtNDAwIC00MDBsLTIwMCAyMDBsMTAwIDEwMGwxMDAgLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYzkiIHVuaWNvZGU9IiYjeGUwYzk7IiAKZD0iTTkgODAwaDc4MmM2IDAgOSAtMyA5IC05di03ODJjMCAtNiAtMyAtOSAtOSAtOWgtNzgyYy02IDAgLTkgMyAtOSA5djc4MmMwIDYgMyA5IDkgOXpNMTUwIDcyMmwtNzIgLTcybDEwMCAtMTAwbC0xMDAgLTEwMGw3MiAtNzJsMTcyIDE3MnpNNDAwIDUwMHYtMTAwaDMwMHYxMDBoLTMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2EiIHVuaWNvZGU9IiYjeGUwY2E7IiAKZD0iTTAgODAwaDgwMHYtMjAwaC01MGMwIDU1IC00NSAxMDAgLTEwMCAxMDBoLTE1MHYtNTUwYzAgLTI4IDIyIC01MCA1MCAtNTBoNTB2LTEwMGgtNDAwdjEwMGg1MGMyOCAwIDUwIDIyIDUwIDUwdjU1MGgtMTUwYy01NSAwIC0xMDAgLTQ1IC0xMDAgLTEwMGgtNTB2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYiIgdW5pY29kZT0iJiN4ZTBjYjsiIApkPSJNMCA3MDBoMTAwdi00MDBoLTEwMHY0MDB6TTIwMCA3MDBoMzUwYzIxIDAgMzkgLTEzIDQ3IC0zMWMwIDAgMTAzIC0yOTEgMTAzIC0zMTlzLTIyIC01MCAtNTAgLTUwaC0xNTBjLTI4IDAgLTUwIC0yNSAtNTAgLTUwczM5IC0xNTggNDcgLTE4NHMtNSAtNTUgLTMxIC02M3MtNTIgNSAtNjYgMzFzLTEwOSAyMTkgLTEyOCAyMzhzLTQ0IDI4IC03MiAyOHY0MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNjIiB1bmljb2RlPSImI3hlMGNjOyIgCmQ9Ik00MDAgNjY2YzEwIDE5IDI4IDMyIDQ3IDM0bDE5IC0zYzI2IC04IDM5IC0zNyAzMSAtNjNzLTQ3IC0xNTkgLTQ3IC0xODRzMjIgLTUwIDUwIC01MGgxNTBjMjggMCA1MCAtMjIgNTAgLTUwcy0xMDMgLTMxOSAtMTAzIC0zMTljLTggLTE4IC0yNiAtMzEgLTQ3IC0zMWgtMzUwdjQwMGMyOCAwIDUzIDkgNzIgMjhzMTE0IDIxMiAxMjggMjM4ek0wIDQwMGgxMDB2LTQwMGgtMTAwdjQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2QiIHVuaWNvZGU9IiYjeGUwY2Q7IiAKZD0iTTIwMCA3MDBoMzAwdi0xMDBoLTEwMHYtNmMyNSAtNCA1MCAtOCA3MiAtMTZsLTM0IC05NGMtMjggMTEgLTU4IDE2IC04OCAxNmMtMTM5IDAgLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MHMyNTAgMTExIDI1MCAyNTBjMCAzMSAtNSA2MCAtMTYgODhsOTEgMzdjMTQgLTM4IDI1IC04MSAyNSAtMTI1YzAgLTE5MyAtMTU3IC0zNTAgLTM1MCAtMzUwcy0zNTAgMTU3IC0zNTAgMzUwYzAgMTc2IDEzMCAzMjMgMzAwIDM0N3YzCmgtMTAwdjEwMHpNNzAwIDU4NGMwIDAgLTI5NiAtMzQ4IC0zMTYgLTM2OHMtNDggLTIwIC02OCAwcy0yMCA0OCAwIDY4czM4NCAzMDAgMzg0IDMwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2UiIHVuaWNvZGU9IiYjeGUwY2U7IiAKZD0iTTYwMCA3MDBsMjAwIC0xNTBsLTIwMCAtMTUwdjEwMGgtNjAwdjEwMGg2MDB2MTAwek0yMDAgMzAwdi0xMDBoNjAwdi0xMDBoLTYwMHYtMTAwbC0yMDAgMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjZiIgdW5pY29kZT0iJiN4ZTBjZjsiIApkPSJNMzAwIDgwMGgxMDBjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwaDEwMGM1NSAwIDEwMCAtNDUgMTAwIC0xMDBoLTcwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwaDEwMGMwIDU1IDQ1IDEwMCAxMDAgMTAwek0xMDAgNTAwaDEwMHYtMzUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MzUwaDEwMHYtMzUwYzAgLTI4IDIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTB2MzUwaDEwMHYtNDgxYzAgLTExIC04IC0xOSAtMTkgLTE5aC00NjIKYy0xMSAwIC0xOSA4IC0xOSAxOXY0ODF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQwIiB1bmljb2RlPSImI3hlMGQwOyIgCmQ9Ik0xMDAgODAwaDIwMHYtNDAwYzAgLTU1IDQ1IC0xMDAgMTAwIC0xMDBzMTAwIDQ1IDEwMCAxMDB2NDAwaDEwMHYtNDAwYzAgLTExMCAtOTAgLTIwMCAtMjAwIC0yMDBoLTUwYy0xMzggMCAtMjUwIDkwIC0yNTAgMjAwdjQwMHpNMCAxMDBoNzAwdi0xMDBoLTcwMHYxMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQxIiB1bmljb2RlPSImI3hlMGQxOyIgCmQ9Ik05IDcwMGgxODJjNiAwIDkgLTMgOSAtOXYtNDgyYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXY0ODJjMCA2IDMgOSA5IDl6TTYwOSA3MDBoMTgyYzYgMCA5IC0zIDkgLTl2LTQ4MmMwIC02IC0zIC05IC05IC05aC0xODJjLTYgMCAtOSAzIC05IDl2NDgyYzAgNiAzIDkgOSA5ek0zMDkgNTAwaDE4MmM2IDAgOSAtMyA5IC05di0yODJjMCAtNiAtMyAtOSAtOSAtOWgtMTgyYy02IDAgLTkgMyAtOSA5djI4MgpjMCA2IDMgOSA5IDl6TTAgMTAwaDgwMHYtMTAwaC04MDB2MTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkMiIgdW5pY29kZT0iJiN4ZTBkMjsiIApkPSJNMTAgNzAwaDE4MWM2IDAgOSAtMyA5IC05di0xOTFoLTIwMHYxOTFjMCA2IDQgOSAxMCA5ek02MTAgNzAwaDE4MWM2IDAgOSAtMyA5IC05di0xOTFoLTIwMHYxOTFjMCA2IDUgOSAxMCA5ek0zMTAgNjAwaDE4MWM2IDAgOSAtMyA5IC05di05MWgtMjAwdjkxYzAgNiA0IDkgMTAgOXpNMCA0MDBoODAwdi0xMDBoLTgwMHYxMDB6TTAgMjAwaDIwMHYtMTkxYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXYxOTF6TTMwMCAyMDAKaDIwMHYtOTFjMCAtNiAtMyAtOSAtOSAtOWgtMTgxYy02IDAgLTEwIDMgLTEwIDl2OTF6TTYwMCAyMDBoMjAwdi0xOTFjMCAtNiAtMyAtOSAtOSAtOWgtMTgxYy02IDAgLTEwIDMgLTEwIDl2MTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkMyIgdW5pY29kZT0iJiN4ZTBkMzsiIApkPSJNMCA3MDBoODAwdi0xMDBoLTgwMHYxMDB6TTkgNTAwaDE4MmM2IDAgOSAtMyA5IC05di00ODJjMCAtNiAtMyAtOSAtOSAtOWgtMTgyYy02IDAgLTkgMyAtOSA5djQ4MmMwIDYgMyA5IDkgOXpNMzA5IDUwMGgxODJjNiAwIDkgLTMgOSAtOXYtMjgyYzAgLTYgLTMgLTkgLTkgLTloLTE4MmMtNiAwIC05IDMgLTkgOXYyODJjMCA2IDMgOSA5IDl6TTYwOSA1MDBoMTgyYzYgMCA5IC0zIDkgLTl2LTQ4MmMwIC02IC0zIC05IC05IC05aC0xODIKYy02IDAgLTkgMyAtOSA5djQ4MmMwIDYgMyA5IDkgOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDQiIHVuaWNvZGU9IiYjeGUwZDQ7IiAKZD0iTTUwIDYwMGg1MDBjMjggMCA1MCAtMjIgNTAgLTUwdi0xNTBsMTAwIDEwMGgxMDB2LTMwMGgtMTAwbC0xMDAgMTAwdi0xNTBjMCAtMjggLTIyIC01MCAtNTAgLTUwaC01MDBjLTI4IDAgLTUwIDIyIC01MCA1MHY0MDBjMCAyOCAyMiA1MCA1MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDUiIHVuaWNvZGU9IiYjeGUwZDU7IiAKZD0iTTMzNCA4MDBoNjZ2LTgwMGgtNjZsLTEzNCAyMDBoLTIwMHY0MDBoMjAwek01MDAgNjAwdjEwMGMyNiAwIDUyIC00IDc1IC0xMGMxMzAgLTMzIDIyNSAtMTUwIDIyNSAtMjkwcy05NSAtMjU4IC0yMjUgLTI5MWgtM2MtMjMgLTYgLTQ3IC05IC03MiAtOXYxMDBjMTcgMCAzNCAyIDUwIDZjODYgMjIgMTUwIDEwMCAxNTAgMTk0cy02NCAxNzIgLTE1MCAxOTRjLTE2IDQgLTMzIDYgLTUwIDZ6TTUwMCA1MDBsMjUgLTMKYzQ0IC0xMSA3NSAtNTEgNzUgLTk3cy0zMiAtODYgLTc1IC05N2wtMjUgLTN2MjAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkNiIgdW5pY29kZT0iJiN4ZTBkNjsiIGhvcml6LWFkdi14PSI2MDAiIApkPSJNMzM0IDgwMGg2NnYtODAwaC02NmwtMTM0IDIwMGgtMjAwdjQwMGgyMDB6TTUwMCA1MDBsMjUgLTNjNDQgLTExIDc1IC01MSA3NSAtOTdzLTMyIC04NiAtNzUgLTk3bC0yNSAtM3YyMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImQ3IiB1bmljb2RlPSImI3hlMGQ3OyIgaG9yaXotYWR2LXg9IjQwMCIgCmQ9Ik0zMzQgODAwaDY2di04MDBoLTY2bC0xMzQgMjAwaC0yMDB2NDAwaDIwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDgiIHVuaWNvZGU9IiYjeGUwZDg7IiAKZD0iTTMwOSA4MDBoODJjNiAwIDEwIC00IDEyIC05bDI5NCAtNjgybDMgLTE5di04MWMwIC02IC0zIC05IC05IC05aC02ODJjLTYgMCAtOSAzIC05IDl2ODFsMyAxOWwyOTQgNjgyYzIgNSA2IDkgMTIgOXpNMzAwIDUwMHYtMjAwaDEwMHYyMDBoLTEwMHpNMzAwIDIwMHYtMTAwaDEwMHYxMDBoLTEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZDkiIHVuaWNvZGU9IiYjeGUwZDk7IiAKZD0iTTM3NSA4MDBjMTM4IDAgMjY5IC0zOSAzNzggLTEwOWwtNTMgLTgyYy05MyA2MCAtMjA1IDkxIC0zMjUgOTFjLTExOSAwIC0yMjkgLTMyIC0zMjIgLTkxbC01MyA4MmMxMDkgNzAgMjM3IDEwOSAzNzUgMTA5ek0zNzUgNTAwYzc4IDAgMTU0IC0yMyAyMTYgLTYybC01MyAtODVjLTQ2IDMwIC0xMDQgNDcgLTE2MyA0N2MtNjAgMCAtMTEyIC0xNyAtMTU5IC00N2wtNTQgODVjNjIgNDAgMTM0IDYyIDIxMyA2MnpNMzc1IDIwMApjNTUgMCAxMDAgLTQ1IDEwMCAtMTAwcy00NSAtMTAwIC0xMDAgLTEwMHMtMTAwIDQ1IC0xMDAgMTAwczQ1IDEwMCAxMDAgMTAweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYSIgdW5pY29kZT0iJiN4ZTBkYTsiIGhvcml6LWFkdi14PSI5MDAiIApkPSJNNTUxIDgwMGMxNiAwIDMyIDAgNDcgLTNsLTk3IC05N3YtMjAwaDIwMGw5NyA5N2MzIC0xNSAzIC0zMSAzIC00N2MwIC0xMzggLTExMiAtMjUwIC0yNTAgLTI1MGMtMzIgMCAtNjIgOCAtOTAgMTlsLTI4OCAtMjkxYy0yMCAtMjAgLTQ2IC0yOCAtNzIgLTI4cy01MiA4IC03MiAyOGMtMzkgMzkgLTM5IDEwNSAwIDE0NGwyOTEgMjg3Yy0xMSAyOCAtMTkgNTkgLTE5IDkxYzAgMTM4IDExMiAyNTAgMjUwIDI1MHpNMTAxIDE1MApjLTI4IDAgLTUwIC0yMiAtNTAgLTUwczIyIC01MCA1MCAtNTBzNTAgMjIgNTAgNTBzLTIyIDUwIC01MCA1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGIiIHVuaWNvZGU9IiYjeGUwZGI7IiAKZD0iTTE0MSA3MDBjODQgLTg0IDE2OSAtMTY3IDI1MyAtMjUwYzgyIDgzIDE2NyAxNjUgMjQ3IDI1MGwxNDMgLTE0MWwtMjUzIC0yNTNjODQgLTgyIDE2NyAtMTY2IDI1MyAtMjQ3bC0xNDMgLTE0M2MtODEgODYgLTE2NSAxNjkgLTI0NyAyNTNsLTI1MyAtMjUzbC0xNDEgMTQzYzg1IDgwIDE2NyAxNjQgMjUwIDI0N2MtODMgODQgLTE2NiAxNjkgLTI1MCAyNTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRjIiB1bmljb2RlPSImI3hlMGRjOyIgCmQ9Ik0wIDgwMGgxMDBsMjMxIC0zMDBoMzhsMjMxIDMwMGgxMDBsLTIyNSAtMzAwaDIyNXYtMTAwaC0zMDB2LTEwMGgzMDB2LTEwMGgtMzAwdi0yMDBoLTEwMHYyMDBoLTMwMHYxMDBoMzAwdjEwMGgtMzAwdjEwMGgyMjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRkIiB1bmljb2RlPSImI3hlMGRkOyIgaG9yaXotYWR2LXg9IjkwMCIgCmQ9Ik0zNTAgODAwYzE5MyAwIDM1MCAtMTU3IDM1MCAtMzUwYzAgLTYxIC0xNyAtMTE5IC00NCAtMTY5YzQgLTIgMTAgLTYgMTMgLTlsMTAzIC0xMDBjMTYgLTE2IDMwIC00OSAzMCAtNzJjMCAtNTYgLTQ2IC0xMDIgLTEwMiAtMTAyYy0yMyAwIC01NiAxNCAtNzIgMzBsLTEwMCAxMDNjLTMgMyAtNyA5IC05IDEzYy01MCAtMjggLTEwOCAtNDQgLTE2OSAtNDRjLTE5MyAwIC0zNTAgMTU3IC0zNTAgMzUwczE1NyAzNTAgMzUwIDM1MHpNMzUwIDcwMApjLTEzOSAwIC0yNTAgLTExMSAtMjUwIC0yNTBzMTExIC0yNTAgMjUwIC0yNTBjNjIgMCAxMTkgMjMgMTYzIDYwYzcgMTEgMTkgMjUgMzEgMzFsMyAzYzM0IDQzIDUzIDk3IDUzIDE1NmMwIDEzOSAtMTExIDI1MCAtMjUwIDI1MHpNMzAwIDYwMGgxMDB2LTEwMGgxMDB2LTEwMGgtMTAwdi0xMDBoLTEwMHYxMDBoLTEwMHYxMDBoMTAwdjEwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGUiIHVuaWNvZGU9IiYjeGUwZGU7IiBob3Jpei1hZHYteD0iOTAwIiAKZD0iTTM1MCA4MDBjMTkzIDAgMzUwIC0xNTcgMzUwIC0zNTBjMCAtNjEgLTE3IC0xMTkgLTQ0IC0xNjljNCAtMiAxMCAtNiAxMyAtOWwxMDMgLTEwMGMxNiAtMTYgMzAgLTQ5IDMwIC03MmMwIC01NiAtNDYgLTEwMiAtMTAyIC0xMDJjLTIzIDAgLTU2IDE0IC03MiAzMGwtMTAwIDEwM2MtMyAzIC03IDkgLTkgMTNjLTUwIC0yOCAtMTA4IC00NCAtMTY5IC00NGMtMTkzIDAgLTM1MCAxNTcgLTM1MCAzNTBzMTU3IDM1MCAzNTAgMzUwek0zNTAgNzAwCmMtMTM5IDAgLTI1MCAtMTExIC0yNTAgLTI1MHMxMTEgLTI1MCAyNTAgLTI1MGM2MiAwIDExOSAyMyAxNjMgNjBjNyAxMSAxOSAyNSAzMSAzMWwzIDNjMzQgNDMgNTMgOTcgNTMgMTU2YzAgMTM5IC0xMTEgMjUwIC0yNTAgMjUwek0yMDAgNTAwaDMwMHYtMTAwaC0zMDB2MTAweiIgLz4KICA8L2ZvbnQ+CjwvZGVmcz48L3N2Zz4K"

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.ttf":
/***/ (function(module, exports) {

module.exports = "data:application/x-font-ttf;base64,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AEoALgAgAE8AbgBvAHIAaQAgAHcAaQB0AGgAIABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAKABoAHQAdABwADoALwAvAGYAbwBuAHQAZgBvAHIAZwBlAC4AcwBmAC4AbgBlAHQAKQAAQ3JlYXRlZCBieSBQLkouIE9ub3JpIHdpdGggRm9udEZvcmdlIDIuMCAoaHR0cDovL2ZvbnRmb3JnZS5zZi5uZXQpAABJAGMAbwBuAHMAAEljb25zAABpAGMAbwBuAGkAYwAAaWNvbmljAABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAFUAbgB0AGkAdABsAGUAZAAxACAAOgAgADEALQA3AC0AMgAwADEANAAARm9udEZvcmdlIDIuMCA6IFVudGl0bGVkMSA6IDEtNy0yMDE0AABVAG4AdABpAHQAbABlAGQAMQAAVW50aXRsZWQxAABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAxACAAAFZlcnNpb24gMS4xLjEgAABvAHAAZQBuAC0AaQBjAG8AbgBpAGMAAG9wZW4taWNvbmljAAACAAAAAAAA/4MAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAOIAAAABAAIBAgEDAQQBBQEGAQcBCAEJAQoBCwBEAEUARgBHAEgASQEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakAoAGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHO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UlggPFkusSsBFCstsDwsIyAuRrACJUZQWCA8WS6xKwEUKy2wPSwjIC5GsAIlRlJYIDxZIyAuRrACJUZQWCA8WS6xKwEUKy2wPiywNSsjIC5GsAIlRlJYIDxZLrErARQrLbA/LLA2K4ogIDywBCNCijgjIC5GsAIlRlJYIDxZLrErARQrsARDLrArKy2wQCywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixKwEUKy2wQSyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbErARQrLbBCLLA1Ky6xKwEUKy2wQyywNishIyAgPLAEI0IjOLErARQrsARDLrArKy2wRCywABUgR7AAI0KyAAEBFRQTLrAxKi2wRSywABUgR7AAI0KyAAEBFRQTLrAxKi2wRiyxAAEUE7AyKi2wRyywNCotsEgssAAWRSMgLiBGiiNhOLErARQrLbBJLLAII0KwSCstsEossgAAQSstsEsssgABQSstsEwssgEAQSstsE0ssgEBQSstsE4ssgAAQistsE8ssgABQistsFAssgEAQistsFEssgEBQistsFIssgAAPistsFMssgABPistsFQssgEAPistsFUssgEBPistsFYssgAAQCstsFcssgABQCstsFgssgEAQCstsFkssgEBQCstsFossgAAQystsFsssgABQystsFwssgEAQystsF0ssgEBQystsF4ssgAAPystsF8ssgABPystsGAssgEAPystsGEssgEBPystsGIssDcrLrErARQrLbBjLLA3K7A7Ky2wZCywNyuwPCstsGUssAAWsDcrsD0rLbBmLLA4Ky6xKwEUKy2wZyywOCuwOystsGgssDgrsDwrLbBpLLA4K7A9Ky2waiywOSsusSsBFCstsGsssDkrsDsrLbBsLLA5K7A8Ky2wbSywOSuwPSstsG4ssDorLrErARQrLbBvLLA6K7A7Ky2wcCywOiuwPCstsHEssDorsD0rLbByLLMJBAIDRVghGyMhWUIrsAhlsAMkUHiwARUwLQBLuADIUlixAQGOWbABuQgACABjcLEABUKxAAAqsQAFQrEACCqxAAVCsQAIKrEABUK5AAAACSqxAAVCuQAAAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWbEADCq4Af+FsASNsQIARAA="

/***/ }),

/***/ "../../node_modules/open-iconic/font/fonts/open-iconic.woff":
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,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"

/***/ }),

/***/ "../../node_modules/preact-compat/dist/preact-compat.es.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export version */
/* unused harmony export DOM */
/* unused harmony export Children */
/* unused harmony export render */
/* unused harmony export createClass */
/* unused harmony export createFactory */
/* unused harmony export createElement */
/* unused harmony export cloneElement */
/* unused harmony export isValidElement */
/* unused harmony export findDOMNode */
/* unused harmony export unmountComponentAtNode */
/* unused harmony export Component */
/* unused harmony export PureComponent */
/* unused harmony export unstable_renderSubtreeIntoContainer */
/* unused harmony export __spread */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__("../../node_modules/prop-types/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact__ = __webpack_require__("../../node_modules/preact/dist/preact.esm.js");
/* unused harmony reexport PropTypes */



var version = '15.1.0'; // trick libraries to think we are react

var ELEMENTS = 'a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr circle clipPath defs ellipse g image line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan'.split(' ');

var REACT_ELEMENT_TYPE = (typeof Symbol!=='undefined' && Symbol.for && Symbol.for('react.element')) || 0xeac7;

var COMPONENT_WRAPPER_KEY = typeof Symbol!=='undefined' ? Symbol.for('__preactCompatWrapper') : '__preactCompatWrapper';

// don't autobind these methods since they already have guaranteed context.
var AUTOBIND_BLACKLIST = {
	constructor: 1,
	render: 1,
	shouldComponentUpdate: 1,
	componentWillReceiveProps: 1,
	componentWillUpdate: 1,
	componentDidUpdate: 1,
	componentWillMount: 1,
	componentDidMount: 1,
	componentWillUnmount: 1,
	componentDidUnmount: 1
};


var CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip|color|fill|flood|font|glyph|horiz|marker|overline|paint|stop|strikethrough|stroke|text|underline|unicode|units|v|vector|vert|word|writing|x)[A-Z]/;


var BYPASS_HOOK = {};

/*global process*/
var DEV = typeof process==='undefined' || !process.env || "production"!=='production';

// a component that renders nothing. Used to replace components for unmountComponentAtNode.
function EmptyComponent() { return null; }



// make react think we're react.
var VNode = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])('a', null).constructor;
VNode.prototype.$$typeof = REACT_ELEMENT_TYPE;
VNode.prototype.preactCompatUpgraded = false;
VNode.prototype.preactCompatNormalized = false;

Object.defineProperty(VNode.prototype, 'type', {
	get: function() { return this.nodeName; },
	set: function(v) { this.nodeName = v; },
	configurable:true
});

Object.defineProperty(VNode.prototype, 'props', {
	get: function() { return this.attributes; },
	set: function(v) { this.attributes = v; },
	configurable:true
});



var oldEventHook = __WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].event;
__WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].event = function (e) {
	if (oldEventHook) { e = oldEventHook(e); }
	e.persist = Object;
	e.nativeEvent = e;
	return e;
};


var oldVnodeHook = __WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].vnode;
__WEBPACK_IMPORTED_MODULE_1_preact__["d" /* options */].vnode = function (vnode) {
	if (!vnode.preactCompatUpgraded) {
		vnode.preactCompatUpgraded = true;

		var tag = vnode.nodeName,
			attrs = vnode.attributes = extend({}, vnode.attributes);

		if (typeof tag==='function') {
			if (tag[COMPONENT_WRAPPER_KEY]===true || (tag.prototype && 'isReactComponent' in tag.prototype)) {
				if (vnode.children && String(vnode.children)==='') { vnode.children = undefined; }
				if (vnode.children) { attrs.children = vnode.children; }

				if (!vnode.preactCompatNormalized) {
					normalizeVNode(vnode);
				}
				handleComponentVNode(vnode);
			}
		}
		else {
			if (vnode.children && String(vnode.children)==='') { vnode.children = undefined; }
			if (vnode.children) { attrs.children = vnode.children; }

			if (attrs.defaultValue) {
				if (!attrs.value && attrs.value!==0) {
					attrs.value = attrs.defaultValue;
				}
				delete attrs.defaultValue;
			}

			handleElementVNode(vnode, attrs);
		}
	}

	if (oldVnodeHook) { oldVnodeHook(vnode); }
};

function handleComponentVNode(vnode) {
	var tag = vnode.nodeName,
		a = vnode.attributes;

	vnode.attributes = {};
	if (tag.defaultProps) { extend(vnode.attributes, tag.defaultProps); }
	if (a) { extend(vnode.attributes, a); }
}

function handleElementVNode(vnode, a) {
	var shouldSanitize, attrs, i;
	if (a) {
		for (i in a) { if ((shouldSanitize = CAMEL_PROPS.test(i))) { break; } }
		if (shouldSanitize) {
			attrs = vnode.attributes = {};
			for (i in a) {
				if (a.hasOwnProperty(i)) {
					attrs[ CAMEL_PROPS.test(i) ? i.replace(/([A-Z0-9])/, '-$1').toLowerCase() : i ] = a[i];
				}
			}
		}
	}
}



// proxy render() since React returns a Component reference.
function render$1(vnode, parent, callback) {
	var prev = parent && parent._preactCompatRendered && parent._preactCompatRendered.base;

	// ignore impossible previous renders
	if (prev && prev.parentNode!==parent) { prev = null; }

	// default to first Element child
	if (!prev && parent) { prev = parent.firstElementChild; }

	// remove unaffected siblings
	for (var i=parent.childNodes.length; i--; ) {
		if (parent.childNodes[i]!==prev) {
			parent.removeChild(parent.childNodes[i]);
		}
	}

	var out = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["e" /* render */])(vnode, parent, prev);
	if (parent) { parent._preactCompatRendered = out && (out._component || { base: out }); }
	if (typeof callback==='function') { callback(); }
	return out && out._component || out;
}


var ContextProvider = function () {};

ContextProvider.prototype.getChildContext = function () {
	return this.props.context;
};
ContextProvider.prototype.render = function (props) {
	return props.children[0];
};

function renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {
	var wrap = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(ContextProvider, { context: parentComponent.context }, vnode);
	var renderContainer = render$1(wrap, container);
	var component = renderContainer._component || renderContainer.base;
	if (callback) { callback.call(component, renderContainer); }
	return component;
}


function unmountComponentAtNode(container) {
	var existing = container._preactCompatRendered && container._preactCompatRendered.base;
	if (existing && existing.parentNode===container) {
		Object(__WEBPACK_IMPORTED_MODULE_1_preact__["e" /* render */])(Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(EmptyComponent), container, existing);
		return true;
	}
	return false;
}



var ARR = [];

// This API is completely unnecessary for Preact, so it's basically passthrough.
var Children = {
	map: function(children, fn, ctx) {
		if (children == null) { return null; }
		children = Children.toArray(children);
		if (ctx && ctx!==children) { fn = fn.bind(ctx); }
		return children.map(fn);
	},
	forEach: function(children, fn, ctx) {
		if (children == null) { return null; }
		children = Children.toArray(children);
		if (ctx && ctx!==children) { fn = fn.bind(ctx); }
		children.forEach(fn);
	},
	count: function(children) {
		return children && children.length || 0;
	},
	only: function(children) {
		children = Children.toArray(children);
		if (children.length!==1) { throw new Error('Children.only() expects only one child.'); }
		return children[0];
	},
	toArray: function(children) {
		if (children == null) { return []; }
		return ARR.concat(children);
	}
};


/** Track current render() component for ref assignment */
var currentComponent;


function createFactory(type) {
	return createElement.bind(null, type);
}


var DOM = {};
for (var i=ELEMENTS.length; i--; ) {
	DOM[ELEMENTS[i]] = createFactory(ELEMENTS[i]);
}

function upgradeToVNodes(arr, offset) {
	for (var i=offset || 0; i<arr.length; i++) {
		var obj = arr[i];
		if (Array.isArray(obj)) {
			upgradeToVNodes(obj);
		}
		else if (obj && typeof obj==='object' && !isValidElement(obj) && ((obj.props && obj.type) || (obj.attributes && obj.nodeName) || obj.children)) {
			arr[i] = createElement(obj.type || obj.nodeName, obj.props || obj.attributes, obj.children);
		}
	}
}

function isStatelessComponent(c) {
	return typeof c==='function' && !(c.prototype && c.prototype.render);
}


// wraps stateless functional components in a PropTypes validator
function wrapStatelessComponent(WrappedComponent) {
	return createClass({
		displayName: WrappedComponent.displayName || WrappedComponent.name,
		render: function() {
			return WrappedComponent(this.props, this.context);
		}
	});
}


function statelessComponentHook(Ctor) {
	var Wrapped = Ctor[COMPONENT_WRAPPER_KEY];
	if (Wrapped) { return Wrapped===true ? Ctor : Wrapped; }

	Wrapped = wrapStatelessComponent(Ctor);

	Object.defineProperty(Wrapped, COMPONENT_WRAPPER_KEY, { configurable:true, value:true });
	Wrapped.displayName = Ctor.displayName;
	Wrapped.propTypes = Ctor.propTypes;
	Wrapped.defaultProps = Ctor.defaultProps;

	Object.defineProperty(Ctor, COMPONENT_WRAPPER_KEY, { configurable:true, value:Wrapped });

	return Wrapped;
}


function createElement() {
	var args = [], len = arguments.length;
	while ( len-- ) args[ len ] = arguments[ len ];

	upgradeToVNodes(args, 2);
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */].apply(void 0, args));
}


function normalizeVNode(vnode) {
	vnode.preactCompatNormalized = true;

	applyClassName(vnode);

	if (isStatelessComponent(vnode.nodeName)) {
		vnode.nodeName = statelessComponentHook(vnode.nodeName);
	}

	var ref = vnode.attributes.ref,
		type = ref && typeof ref;
	if (currentComponent && (type==='string' || type==='number')) {
		vnode.attributes.ref = createStringRefProxy(ref, currentComponent);
	}

	applyEventNormalization(vnode);

	return vnode;
}


function cloneElement$1(element, props) {
	var children = [], len = arguments.length - 2;
	while ( len-- > 0 ) children[ len ] = arguments[ len + 2 ];

	if (!isValidElement(element)) { return element; }
	var elementProps = element.attributes || element.props;
	var node = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["c" /* h */])(
		element.nodeName || element.type,
		elementProps,
		element.children || elementProps && elementProps.children
	);
	// Only provide the 3rd argument if needed.
	// Arguments 3+ overwrite element.children in preactCloneElement
	var cloneArgs = [node, props];
	if (children && children.length) {
		cloneArgs.push(children);
	}
	else if (props && props.children) {
		cloneArgs.push(props.children);
	}
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["b" /* cloneElement */].apply(void 0, cloneArgs));
}


function isValidElement(element) {
	return element && ((element instanceof VNode) || element.$$typeof===REACT_ELEMENT_TYPE);
}


function createStringRefProxy(name, component) {
	return component._refProxies[name] || (component._refProxies[name] = function (resolved) {
		if (component && component.refs) {
			component.refs[name] = resolved;
			if (resolved===null) {
				delete component._refProxies[name];
				component = null;
			}
		}
	});
}


function applyEventNormalization(ref) {
	var nodeName = ref.nodeName;
	var attributes = ref.attributes;

	if (!attributes || typeof nodeName!=='string') { return; }
	var props = {};
	for (var i in attributes) {
		props[i.toLowerCase()] = i;
	}
	if (props.ondoubleclick) {
		attributes.ondblclick = attributes[props.ondoubleclick];
		delete attributes[props.ondoubleclick];
	}
	// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:
	if (props.onchange && (nodeName==='textarea' || (nodeName.toLowerCase()==='input' && !/^fil|che|rad/i.test(attributes.type)))) {
		var normalized = props.oninput || 'oninput';
		if (!attributes[normalized]) {
			attributes[normalized] = multihook([attributes[normalized], attributes[props.onchange]]);
			delete attributes[props.onchange];
		}
	}
}


function applyClassName(vnode) {
	var a = vnode.attributes || (vnode.attributes = {});
	classNameDescriptor.enumerable = 'className' in a;
	if (a.className) { a.class = a.className; }
	Object.defineProperty(a, 'className', classNameDescriptor);
}


var classNameDescriptor = {
	configurable: true,
	get: function() { return this.class; },
	set: function(v) { this.class = v; }
};

function extend(base, props) {
	var arguments$1 = arguments;

	for (var i=1, obj = (void 0); i<arguments.length; i++) {
		if ((obj = arguments$1[i])) {
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					base[key] = obj[key];
				}
			}
		}
	}
	return base;
}


function shallowDiffers(a, b) {
	for (var i in a) { if (!(i in b)) { return true; } }
	for (var i$1 in b) { if (a[i$1]!==b[i$1]) { return true; } }
	return false;
}


function findDOMNode(component) {
	return component && component.base || component;
}


function F(){}

function createClass(obj) {
	function cl(props, context) {
		bindAll(this);
		Component$1.call(this, props, context, BYPASS_HOOK);
		newComponentHook.call(this, props, context);
	}

	obj = extend({ constructor: cl }, obj);

	// We need to apply mixins here so that getDefaultProps is correctly mixed
	if (obj.mixins) {
		applyMixins(obj, collateMixins(obj.mixins));
	}
	if (obj.statics) {
		extend(cl, obj.statics);
	}
	if (obj.propTypes) {
		cl.propTypes = obj.propTypes;
	}
	if (obj.defaultProps) {
		cl.defaultProps = obj.defaultProps;
	}
	if (obj.getDefaultProps) {
		cl.defaultProps = obj.getDefaultProps();
	}

	F.prototype = Component$1.prototype;
	cl.prototype = extend(new F(), obj);

	cl.displayName = obj.displayName || 'Component';

	return cl;
}


// Flatten an Array of mixins to a map of method name to mixin implementations
function collateMixins(mixins) {
	var keyed = {};
	for (var i=0; i<mixins.length; i++) {
		var mixin = mixins[i];
		for (var key in mixin) {
			if (mixin.hasOwnProperty(key) && typeof mixin[key]==='function') {
				(keyed[key] || (keyed[key]=[])).push(mixin[key]);
			}
		}
	}
	return keyed;
}


// apply a mapping of Arrays of mixin methods to a component prototype
function applyMixins(proto, mixins) {
	for (var key in mixins) { if (mixins.hasOwnProperty(key)) {
		proto[key] = multihook(
			mixins[key].concat(proto[key] || ARR),
			key==='getDefaultProps' || key==='getInitialState' || key==='getChildContext'
		);
	} }
}


function bindAll(ctx) {
	for (var i in ctx) {
		var v = ctx[i];
		if (typeof v==='function' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {
			(ctx[i] = v.bind(ctx)).__bound = true;
		}
	}
}


function callMethod(ctx, m, args) {
	if (typeof m==='string') {
		m = ctx.constructor.prototype[m];
	}
	if (typeof m==='function') {
		return m.apply(ctx, args);
	}
}

function multihook(hooks, skipDuplicates) {
	return function() {
		var arguments$1 = arguments;
		var this$1 = this;

		var ret;
		for (var i=0; i<hooks.length; i++) {
			var r = callMethod(this$1, hooks[i], arguments$1);

			if (skipDuplicates && r!=null) {
				if (!ret) { ret = {}; }
				for (var key in r) { if (r.hasOwnProperty(key)) {
					ret[key] = r[key];
				} }
			}
			else if (typeof r!=='undefined') { ret = r; }
		}
		return ret;
	};
}


function newComponentHook(props, context) {
	propsHook.call(this, props, context);
	this.componentWillReceiveProps = multihook([propsHook, this.componentWillReceiveProps || 'componentWillReceiveProps']);
	this.render = multihook([propsHook, beforeRender, this.render || 'render', afterRender]);
}


function propsHook(props, context) {
	if (!props) { return; }

	// React annoyingly special-cases single children, and some react components are ridiculously strict about this.
	var c = props.children;
	if (c && Array.isArray(c) && c.length===1 && (typeof c[0]==='string' || typeof c[0]==='function' || c[0] instanceof VNode)) {
		props.children = c[0];

		// but its totally still going to be an Array.
		if (props.children && typeof props.children==='object') {
			props.children.length = 1;
			props.children[0] = props.children;
		}
	}

	// add proptype checking
	if (DEV) {
		var ctor = typeof this==='function' ? this : this.constructor,
			propTypes = this.propTypes || ctor.propTypes;
		var displayName = this.displayName || ctor.name;

		if (propTypes) {
			__WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.checkPropTypes(propTypes, props, 'prop', displayName);
		}
	}
}


function beforeRender(props) {
	currentComponent = this;
}

function afterRender() {
	if (currentComponent===this) {
		currentComponent = null;
	}
}



function Component$1(props, context, opts) {
	__WEBPACK_IMPORTED_MODULE_1_preact__["a" /* Component */].call(this, props, context);
	this.state = this.getInitialState ? this.getInitialState() : {};
	this.refs = {};
	this._refProxies = {};
	if (opts!==BYPASS_HOOK) {
		newComponentHook.call(this, props, context);
	}
}
extend(Component$1.prototype = new __WEBPACK_IMPORTED_MODULE_1_preact__["a" /* Component */](), {
	constructor: Component$1,

	isReactComponent: {},

	replaceState: function(state, callback) {
		var this$1 = this;

		this.setState(state, callback);
		for (var i in this$1.state) {
			if (!(i in state)) {
				delete this$1.state[i];
			}
		}
	},

	getDOMNode: function() {
		return this.base;
	},

	isMounted: function() {
		return !!this.base;
	}
});



function PureComponent(props, context) {
	Component$1.call(this, props, context);
}
F.prototype = Component$1.prototype;
PureComponent.prototype = new F();
PureComponent.prototype.isPureReactComponent = true;
PureComponent.prototype.shouldComponentUpdate = function(props, state) {
	return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);
};

var index = {
	version: version,
	DOM: DOM,
	PropTypes: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a,
	Children: Children,
	render: render$1,
	createClass: createClass,
	createFactory: createFactory,
	createElement: createElement,
	cloneElement: cloneElement$1,
	isValidElement: isValidElement,
	findDOMNode: findDOMNode,
	unmountComponentAtNode: unmountComponentAtNode,
	Component: Component$1,
	PureComponent: PureComponent,
	unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer,
	__spread: extend
};

/* harmony default export */ __webpack_exports__["a"] = (index);
//# sourceMappingURL=preact-compat.es.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/preact/dist/preact.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return h; });
/* unused harmony export createElement */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cloneElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return render; });
/* unused harmony export rerender */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return options; });
/** Virtual DOM Node */
function VNode() {}

/** Global options
 *	@public
 *	@namespace options {Object}
 */
var options = {

	/** If `true`, `prop` changes trigger synchronous component updates.
  *	@name syncComponentUpdates
  *	@type Boolean
  *	@default true
  */
	//syncComponentUpdates: true,

	/** Processes all created VNodes.
  *	@param {VNode} vnode	A newly-created VNode to normalize/process
  */
	//vnode(vnode) { }

	/** Hook invoked after a component is mounted. */
	// afterMount(component) { }

	/** Hook invoked after the DOM is updated with a component's latest render. */
	// afterUpdate(component) { }

	/** Hook invoked immediately before a component is unmounted. */
	// beforeUnmount(component) { }
};

var stack = [];

var EMPTY_CHILDREN = [];

/** JSX/hyperscript reviver
*	Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0
 *	@see http://jasonformat.com/wtf-is-jsx
 *	@public
 */
function h(nodeName, attributes) {
	var children = EMPTY_CHILDREN,
	    lastSimple,
	    child,
	    simple,
	    i;
	for (i = arguments.length; i-- > 2;) {
		stack.push(arguments[i]);
	}
	if (attributes && attributes.children != null) {
		if (!stack.length) stack.push(attributes.children);
		delete attributes.children;
	}
	while (stack.length) {
		if ((child = stack.pop()) && child.pop !== undefined) {
			for (i = child.length; i--;) {
				stack.push(child[i]);
			}
		} else {
			if (typeof child === 'boolean') child = null;

			if (simple = typeof nodeName !== 'function') {
				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
			}

			if (simple && lastSimple) {
				children[children.length - 1] += child;
			} else if (children === EMPTY_CHILDREN) {
				children = [child];
			} else {
				children.push(child);
			}

			lastSimple = simple;
		}
	}

	var p = new VNode();
	p.nodeName = nodeName;
	p.children = children;
	p.attributes = attributes == null ? undefined : attributes;
	p.key = attributes == null ? undefined : attributes.key;

	// if a "vnode hook" is defined, pass every created VNode to it
	if (options.vnode !== undefined) options.vnode(p);

	return p;
}

/** Copy own-properties from `props` onto `obj`.
 *	@returns obj
 *	@private
 */
function extend(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }return obj;
}

/** Call a function asynchronously, as soon as possible.
 *	@param {Function} callback
 */
var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

function cloneElement(vnode, props) {
	return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
}

// DOM properties that should NOT have "px" added when numeric
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

/** Managed queue of dirty components to be re-rendered */

var items = [];

function enqueueRender(component) {
	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
		(options.debounceRendering || defer)(rerender);
	}
}

function rerender() {
	var p,
	    list = items;
	items = [];
	while (p = list.pop()) {
		if (p._dirty) renderComponent(p);
	}
}

/** Check if two nodes are equivalent.
 *	@param {Element} node
 *	@param {VNode} vnode
 *	@private
 */
function isSameNodeType(node, vnode, hydrating) {
	if (typeof vnode === 'string' || typeof vnode === 'number') {
		return node.splitText !== undefined;
	}
	if (typeof vnode.nodeName === 'string') {
		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
	}
	return hydrating || node._componentConstructor === vnode.nodeName;
}

/** Check if an Element has a given normalized name.
*	@param {Element} node
*	@param {String} nodeName
 */
function isNamedNode(node, nodeName) {
	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}

/**
 * Reconstruct Component-style `props` from a VNode.
 * Ensures default/fallback values from `defaultProps`:
 * Own-properties of `defaultProps` not present in `vnode.attributes` are added.
 * @param {VNode} vnode
 * @returns {Object} props
 */
function getNodeProps(vnode) {
	var props = extend({}, vnode.attributes);
	props.children = vnode.children;

	var defaultProps = vnode.nodeName.defaultProps;
	if (defaultProps !== undefined) {
		for (var i in defaultProps) {
			if (props[i] === undefined) {
				props[i] = defaultProps[i];
			}
		}
	}

	return props;
}

/** Create an element with the given nodeName.
 *	@param {String} nodeName
 *	@param {Boolean} [isSvg=false]	If `true`, creates an element within the SVG namespace.
 *	@returns {Element} node
 */
function createNode(nodeName, isSvg) {
	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
	node.normalizedNodeName = nodeName;
	return node;
}

/** Remove a child node from its parent if attached.
 *	@param {Element} node		The node to remove
 */
function removeNode(node) {
	var parentNode = node.parentNode;
	if (parentNode) parentNode.removeChild(node);
}

/** Set a named attribute on the given Node, with special behavior for some names and event handlers.
 *	If `value` is `null`, the attribute/handler will be removed.
 *	@param {Element} node	An element to mutate
 *	@param {string} name	The name/key to set, such as an event or attribute name
 *	@param {any} old	The last value that was set for this name/node pair
 *	@param {any} value	An attribute value, such as a function to be used as an event handler
 *	@param {Boolean} isSvg	Are we currently diffing inside an svg?
 *	@private
 */
function setAccessor(node, name, old, value, isSvg) {
	if (name === 'className') name = 'class';

	if (name === 'key') {
		// ignore
	} else if (name === 'ref') {
		if (old) old(null);
		if (value) value(node);
	} else if (name === 'class' && !isSvg) {
		node.className = value || '';
	} else if (name === 'style') {
		if (!value || typeof value === 'string' || typeof old === 'string') {
			node.style.cssText = value || '';
		}
		if (value && typeof value === 'object') {
			if (typeof old !== 'string') {
				for (var i in old) {
					if (!(i in value)) node.style[i] = '';
				}
			}
			for (var i in value) {
				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
			}
		}
	} else if (name === 'dangerouslySetInnerHTML') {
		if (value) node.innerHTML = value.__html || '';
	} else if (name[0] == 'o' && name[1] == 'n') {
		var useCapture = name !== (name = name.replace(/Capture$/, ''));
		name = name.toLowerCase().substring(2);
		if (value) {
			if (!old) node.addEventListener(name, eventProxy, useCapture);
		} else {
			node.removeEventListener(name, eventProxy, useCapture);
		}
		(node._listeners || (node._listeners = {}))[name] = value;
	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
		setProperty(node, name, value == null ? '' : value);
		if (value == null || value === false) node.removeAttribute(name);
	} else {
		var ns = isSvg && name !== (name = name.replace(/^xlink\:?/, ''));
		if (value == null || value === false) {
			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
		} else if (typeof value !== 'function') {
			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
		}
	}
}

/** Attempt to set a DOM property to the given value.
 *	IE & FF throw for certain property-value combinations.
 */
function setProperty(node, name, value) {
	try {
		node[name] = value;
	} catch (e) {}
}

/** Proxy an event to hooked event handlers
 *	@private
 */
function eventProxy(e) {
	return this._listeners[e.type](options.event && options.event(e) || e);
}

/** Queue of components that have been mounted and are awaiting componentDidMount */
var mounts = [];

/** Diff recursion count, used to track the end of the diff cycle. */
var diffLevel = 0;

/** Global flag indicating if the diff is currently within an SVG */
var isSvgMode = false;

/** Global flag indicating if the diff is performing hydration */
var hydrating = false;

/** Invoke queued componentDidMount lifecycle methods */
function flushMounts() {
	var c;
	while (c = mounts.pop()) {
		if (options.afterMount) options.afterMount(c);
		if (c.componentDidMount) c.componentDidMount();
	}
}

/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.
 *	@param {Element} [dom=null]		A DOM node to mutate into the shape of the `vnode`
 *	@param {VNode} vnode			A VNode (with descendants forming a tree) representing the desired DOM structure
 *	@returns {Element} dom			The created/mutated element
 *	@private
 */
function diff(dom, vnode, context, mountAll, parent, componentRoot) {
	// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)
	if (!diffLevel++) {
		// when first starting the diff, check if we're diffing an SVG or within an SVG
		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

		// hydration is indicated by the existing element to be diffed not having a prop cache
		hydrating = dom != null && !('__preactattr_' in dom);
	}

	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

	// append the element if its a new parent
	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

	// diffLevel being reduced to 0 means we're exiting the diff
	if (! --diffLevel) {
		hydrating = false;
		// invoke queued componentDidMount lifecycle methods
		if (!componentRoot) flushMounts();
	}

	return ret;
}

/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */
function idiff(dom, vnode, context, mountAll, componentRoot) {
	var out = dom,
	    prevSvgMode = isSvgMode;

	// empty values (null, undefined, booleans) render as empty Text nodes
	if (vnode == null || typeof vnode === 'boolean') vnode = '';

	// Fast case: Strings & Numbers create/update Text nodes.
	if (typeof vnode === 'string' || typeof vnode === 'number') {

		// update if it's already a Text node:
		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
			/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */
			if (dom.nodeValue != vnode) {
				dom.nodeValue = vnode;
			}
		} else {
			// it wasn't a Text node: replace it with one and recycle the old Element
			out = document.createTextNode(vnode);
			if (dom) {
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
				recollectNodeTree(dom, true);
			}
		}

		out['__preactattr_'] = true;

		return out;
	}

	// If the VNode represents a Component, perform a component diff:
	var vnodeName = vnode.nodeName;
	if (typeof vnodeName === 'function') {
		return buildComponentFromVNode(dom, vnode, context, mountAll);
	}

	// Tracks entering and exiting SVG namespace when descending through the tree.
	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

	// If there's no existing element or it's the wrong type, create a new one:
	vnodeName = String(vnodeName);
	if (!dom || !isNamedNode(dom, vnodeName)) {
		out = createNode(vnodeName, isSvgMode);

		if (dom) {
			// move children into the replacement node
			while (dom.firstChild) {
				out.appendChild(dom.firstChild);
			} // if the previous Element was mounted into the DOM, replace it inline
			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

			// recycle the old element (skips non-Element node types)
			recollectNodeTree(dom, true);
		}
	}

	var fc = out.firstChild,
	    props = out['__preactattr_'],
	    vchildren = vnode.children;

	if (props == null) {
		props = out['__preactattr_'] = {};
		for (var a = out.attributes, i = a.length; i--;) {
			props[a[i].name] = a[i].value;
		}
	}

	// Optimization: fast-path for elements containing a single TextNode:
	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
		if (fc.nodeValue != vchildren[0]) {
			fc.nodeValue = vchildren[0];
		}
	}
	// otherwise, if there are existing or new children, diff them:
	else if (vchildren && vchildren.length || fc != null) {
			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
		}

	// Apply attributes/props from VNode to the DOM Element:
	diffAttributes(out, vnode.attributes, props);

	// restore previous SVG mode: (in case we're exiting an SVG namespace)
	isSvgMode = prevSvgMode;

	return out;
}

/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.
 *	@param {Element} dom			Element whose children should be compared & mutated
 *	@param {Array} vchildren		Array of VNodes to compare to `dom.childNodes`
 *	@param {Object} context			Implicitly descendant context object (from most recent `getChildContext()`)
 *	@param {Boolean} mountAll
 *	@param {Boolean} isHydrating	If `true`, consumes externally created elements similar to hydration
 */
function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
	var originalChildren = dom.childNodes,
	    children = [],
	    keyed = {},
	    keyedLen = 0,
	    min = 0,
	    len = originalChildren.length,
	    childrenLen = 0,
	    vlen = vchildren ? vchildren.length : 0,
	    j,
	    c,
	    f,
	    vchild,
	    child;

	// Build up a map of keyed children and an Array of unkeyed children:
	if (len !== 0) {
		for (var i = 0; i < len; i++) {
			var _child = originalChildren[i],
			    props = _child['__preactattr_'],
			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
			if (key != null) {
				keyedLen++;
				keyed[key] = _child;
			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
				children[childrenLen++] = _child;
			}
		}
	}

	if (vlen !== 0) {
		for (var i = 0; i < vlen; i++) {
			vchild = vchildren[i];
			child = null;

			// attempt to find a node based on key matching
			var key = vchild.key;
			if (key != null) {
				if (keyedLen && keyed[key] !== undefined) {
					child = keyed[key];
					keyed[key] = undefined;
					keyedLen--;
				}
			}
			// attempt to pluck a node of the same type from the existing children
			else if (!child && min < childrenLen) {
					for (j = min; j < childrenLen; j++) {
						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
							child = c;
							children[j] = undefined;
							if (j === childrenLen - 1) childrenLen--;
							if (j === min) min++;
							break;
						}
					}
				}

			// morph the matched/found/created DOM child to match vchild (deep)
			child = idiff(child, vchild, context, mountAll);

			f = originalChildren[i];
			if (child && child !== dom && child !== f) {
				if (f == null) {
					dom.appendChild(child);
				} else if (child === f.nextSibling) {
					removeNode(f);
				} else {
					dom.insertBefore(child, f);
				}
			}
		}
	}

	// remove unused keyed children:
	if (keyedLen) {
		for (var i in keyed) {
			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
		}
	}

	// remove orphaned unkeyed children:
	while (min <= childrenLen) {
		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
	}
}

/** Recursively recycle (or just unmount) a node and its descendants.
 *	@param {Node} node						DOM node to start unmount/removal from
 *	@param {Boolean} [unmountOnly=false]	If `true`, only triggers unmount lifecycle, skips removal
 */
function recollectNodeTree(node, unmountOnly) {
	var component = node._component;
	if (component) {
		// if node is owned by a Component, unmount that component (ends up recursing back here)
		unmountComponent(component);
	} else {
		// If the node's VNode had a ref function, invoke it with null here.
		// (this is part of the React spec, and smart for unsetting references)
		if (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);

		if (unmountOnly === false || node['__preactattr_'] == null) {
			removeNode(node);
		}

		removeChildren(node);
	}
}

/** Recollect/unmount all children.
 *	- we use .lastChild here because it causes less reflow than .firstChild
 *	- it's also cheaper than accessing the .childNodes Live NodeList
 */
function removeChildren(node) {
	node = node.lastChild;
	while (node) {
		var next = node.previousSibling;
		recollectNodeTree(node, true);
		node = next;
	}
}

/** Apply differences in attributes from a VNode to the given DOM Element.
 *	@param {Element} dom		Element with attributes to diff `attrs` against
 *	@param {Object} attrs		The desired end-state key-value attribute pairs
 *	@param {Object} old			Current/previous attributes (from previous VNode or element's prop cache)
 */
function diffAttributes(dom, attrs, old) {
	var name;

	// remove attributes no longer present on the vnode by setting them to undefined
	for (name in old) {
		if (!(attrs && attrs[name] != null) && old[name] != null) {
			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
		}
	}

	// add new & update changed attributes
	for (name in attrs) {
		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
		}
	}
}

/** Retains a pool of Components for re-use, keyed on component name.
 *	Note: since component names are not unique or even necessarily available, these are primarily a form of sharding.
 *	@private
 */
var components = {};

/** Reclaim a component for later re-use by the recycler. */
function collectComponent(component) {
	var name = component.constructor.name;
	(components[name] || (components[name] = [])).push(component);
}

/** Create a component. Normalizes differences between PFC's and classful Components. */
function createComponent(Ctor, props, context) {
	var list = components[Ctor.name],
	    inst;

	if (Ctor.prototype && Ctor.prototype.render) {
		inst = new Ctor(props, context);
		Component.call(inst, props, context);
	} else {
		inst = new Component(props, context);
		inst.constructor = Ctor;
		inst.render = doRender;
	}

	if (list) {
		for (var i = list.length; i--;) {
			if (list[i].constructor === Ctor) {
				inst.nextBase = list[i].nextBase;
				list.splice(i, 1);
				break;
			}
		}
	}
	return inst;
}

/** The `.render()` method for a PFC backing instance. */
function doRender(props, state, context) {
	return this.constructor(props, context);
}

/** Set a component's `props` (generally derived from JSX attributes).
 *	@param {Object} props
 *	@param {Object} [opts]
 *	@param {boolean} [opts.renderSync=false]	If `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.
 *	@param {boolean} [opts.render=true]			If `false`, no render will be triggered.
 */
function setComponentProps(component, props, opts, context, mountAll) {
	if (component._disable) return;
	component._disable = true;

	if (component.__ref = props.ref) delete props.ref;
	if (component.__key = props.key) delete props.key;

	if (!component.base || mountAll) {
		if (component.componentWillMount) component.componentWillMount();
	} else if (component.componentWillReceiveProps) {
		component.componentWillReceiveProps(props, context);
	}

	if (context && context !== component.context) {
		if (!component.prevContext) component.prevContext = component.context;
		component.context = context;
	}

	if (!component.prevProps) component.prevProps = component.props;
	component.props = props;

	component._disable = false;

	if (opts !== 0) {
		if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
			renderComponent(component, 1, mountAll);
		} else {
			enqueueRender(component);
		}
	}

	if (component.__ref) component.__ref(component);
}

/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.
 *	@param {Component} component
 *	@param {Object} [opts]
 *	@param {boolean} [opts.build=false]		If `true`, component will build and store a DOM node if not already associated with one.
 *	@private
 */
function renderComponent(component, opts, mountAll, isChild) {
	if (component._disable) return;

	var props = component.props,
	    state = component.state,
	    context = component.context,
	    previousProps = component.prevProps || props,
	    previousState = component.prevState || state,
	    previousContext = component.prevContext || context,
	    isUpdate = component.base,
	    nextBase = component.nextBase,
	    initialBase = isUpdate || nextBase,
	    initialChildComponent = component._component,
	    skip = false,
	    rendered,
	    inst,
	    cbase;

	// if updating
	if (isUpdate) {
		component.props = previousProps;
		component.state = previousState;
		component.context = previousContext;
		if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
			skip = true;
		} else if (component.componentWillUpdate) {
			component.componentWillUpdate(props, state, context);
		}
		component.props = props;
		component.state = state;
		component.context = context;
	}

	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
	component._dirty = false;

	if (!skip) {
		rendered = component.render(props, state, context);

		// context to pass to the child, can be updated via (grand-)parent component
		if (component.getChildContext) {
			context = extend(extend({}, context), component.getChildContext());
		}

		var childComponent = rendered && rendered.nodeName,
		    toUnmount,
		    base;

		if (typeof childComponent === 'function') {
			// set up high order component link

			var childProps = getNodeProps(rendered);
			inst = initialChildComponent;

			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
				setComponentProps(inst, childProps, 1, context, false);
			} else {
				toUnmount = inst;

				component._component = inst = createComponent(childComponent, childProps, context);
				inst.nextBase = inst.nextBase || nextBase;
				inst._parentComponent = component;
				setComponentProps(inst, childProps, 0, context, false);
				renderComponent(inst, 1, mountAll, true);
			}

			base = inst.base;
		} else {
			cbase = initialBase;

			// destroy high order component link
			toUnmount = initialChildComponent;
			if (toUnmount) {
				cbase = component._component = null;
			}

			if (initialBase || opts === 1) {
				if (cbase) cbase._component = null;
				base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
			}
		}

		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
			var baseParent = initialBase.parentNode;
			if (baseParent && base !== baseParent) {
				baseParent.replaceChild(base, initialBase);

				if (!toUnmount) {
					initialBase._component = null;
					recollectNodeTree(initialBase, false);
				}
			}
		}

		if (toUnmount) {
			unmountComponent(toUnmount);
		}

		component.base = base;
		if (base && !isChild) {
			var componentRef = component,
			    t = component;
			while (t = t._parentComponent) {
				(componentRef = t).base = base;
			}
			base._component = componentRef;
			base._componentConstructor = componentRef.constructor;
		}
	}

	if (!isUpdate || mountAll) {
		mounts.unshift(component);
	} else if (!skip) {
		// Ensure that pending componentDidMount() hooks of child components
		// are called before the componentDidUpdate() hook in the parent.
		// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750
		// flushMounts();

		if (component.componentDidUpdate) {
			component.componentDidUpdate(previousProps, previousState, previousContext);
		}
		if (options.afterUpdate) options.afterUpdate(component);
	}

	if (component._renderCallbacks != null) {
		while (component._renderCallbacks.length) {
			component._renderCallbacks.pop().call(component);
		}
	}

	if (!diffLevel && !isChild) flushMounts();
}

/** Apply the Component referenced by a VNode to the DOM.
 *	@param {Element} dom	The DOM node to mutate
 *	@param {VNode} vnode	A Component-referencing VNode
 *	@returns {Element} dom	The created/mutated element
 *	@private
 */
function buildComponentFromVNode(dom, vnode, context, mountAll) {
	var c = dom && dom._component,
	    originalComponent = c,
	    oldDom = dom,
	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
	    isOwner = isDirectOwner,
	    props = getNodeProps(vnode);
	while (c && !isOwner && (c = c._parentComponent)) {
		isOwner = c.constructor === vnode.nodeName;
	}

	if (c && isOwner && (!mountAll || c._component)) {
		setComponentProps(c, props, 3, context, mountAll);
		dom = c.base;
	} else {
		if (originalComponent && !isDirectOwner) {
			unmountComponent(originalComponent);
			dom = oldDom = null;
		}

		c = createComponent(vnode.nodeName, props, context);
		if (dom && !c.nextBase) {
			c.nextBase = dom;
			// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:
			oldDom = null;
		}
		setComponentProps(c, props, 1, context, mountAll);
		dom = c.base;

		if (oldDom && dom !== oldDom) {
			oldDom._component = null;
			recollectNodeTree(oldDom, false);
		}
	}

	return dom;
}

/** Remove a component from the DOM and recycle it.
 *	@param {Component} component	The Component instance to unmount
 *	@private
 */
function unmountComponent(component) {
	if (options.beforeUnmount) options.beforeUnmount(component);

	var base = component.base;

	component._disable = true;

	if (component.componentWillUnmount) component.componentWillUnmount();

	component.base = null;

	// recursively tear down & recollect high-order component children:
	var inner = component._component;
	if (inner) {
		unmountComponent(inner);
	} else if (base) {
		if (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);

		component.nextBase = base;

		removeNode(base);
		collectComponent(component);

		removeChildren(base);
	}

	if (component.__ref) component.__ref(null);
}

/** Base Component class.
 *	Provides `setState()` and `forceUpdate()`, which trigger rendering.
 *	@public
 *
 *	@example
 *	class MyFoo extends Component {
 *		render(props, state) {
 *			return <div />;
 *		}
 *	}
 */
function Component(props, context) {
	this._dirty = true;

	/** @public
  *	@type {object}
  */
	this.context = context;

	/** @public
  *	@type {object}
  */
	this.props = props;

	/** @public
  *	@type {object}
  */
	this.state = this.state || {};
}

extend(Component.prototype, {

	/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.
  *	@param {object} nextProps
  *	@param {object} nextState
  *	@param {object} nextContext
  *	@returns {Boolean} should the component re-render
  *	@name shouldComponentUpdate
  *	@function
  */

	/** Update component state by copying properties from `state` to `this.state`.
  *	@param {object} state		A hash of state properties to update with new values
  *	@param {function} callback	A function to be called once component state is updated
  */
	setState: function setState(state, callback) {
		var s = this.state;
		if (!this.prevState) this.prevState = extend({}, s);
		extend(s, typeof state === 'function' ? state(s, this.props) : state);
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		enqueueRender(this);
	},


	/** Immediately perform a synchronous re-render of the component.
  *	@param {function} callback		A function to be called after component is re-rendered.
  *	@private
  */
	forceUpdate: function forceUpdate(callback) {
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		renderComponent(this, 2);
	},


	/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
  *	Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
  *	@param {object} props		Props (eg: JSX attributes) received from parent element/component
  *	@param {object} state		The component's current state
  *	@param {object} context		Context object (if a parent component has provided context)
  *	@returns VNode
  */
	render: function render() {}
});

/** Render JSX into a `parent` Element.
 *	@param {VNode} vnode		A (JSX) VNode to render
 *	@param {Element} parent		DOM element to render into
 *	@param {Element} [merge]	Attempt to re-use an existing DOM tree rooted at `merge`
 *	@public
 *
 *	@example
 *	// render a div into <body>:
 *	render(<div id="hello">hello!</div>, document.body);
 *
 *	@example
 *	// render a "Thing" component into #foo:
 *	const Thing = ({ name }) => <span>{ name }</span>;
 *	render(<Thing name="one" />, document.querySelector('#foo'));
 */
function render(vnode, parent, merge) {
  return diff(merge, vnode, {}, false, parent, false);
}

var preact = {
	h: h,
	createElement: h,
	cloneElement: cloneElement,
	Component: Component,
	render: render,
	rerender: rerender,
	options: options
};

/* unused harmony default export */ var _unused_webpack_default_export = (preact);
//# sourceMappingURL=preact.esm.js.map


/***/ }),

/***/ "../../node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/prop-types/factoryWithThrowingShims.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__("../../node_modules/fbjs/lib/emptyFunction.js");
var invariant = __webpack_require__("../../node_modules/fbjs/lib/invariant.js");
var ReactPropTypesSecret = __webpack_require__("../../node_modules/prop-types/lib/ReactPropTypesSecret.js");

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("../../node_modules/prop-types/factoryWithThrowingShims.js")();
}


/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../../node_modules/react-router/node_modules/isarray/index.js":
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../../node_modules/react-router/node_modules/path-to-regexp/index.js":
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__("../../node_modules/react-router/node_modules/isarray/index.js")

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),

/***/ "../../node_modules/resolve-pathname/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);

/***/ }),

/***/ "../../node_modules/style-loader/lib/addStyles.js":
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__("../../node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "../../node_modules/style-loader/lib/urls.js":
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "../../node_modules/svg-inline-loader/index.js?removeTags=true&removeSVGTagAttrs=true!./images/cube.svg":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 23 27\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"MVP\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"><g id=\"linkStatus2\" transform=\"translate(-899.000000, -638.000000)\" fill=\"#1B2437\"><g id=\"Group-6\" transform=\"translate(655.000000, 631.000000)\"><path d=\"M255.452,6.9992 L244,15.8152 L244,24.4682 L255.452,33.2842 L266.904,24.4682 L266.904,15.8152 L255.452,6.9992 Z M259.874,18.1372 L256.224,15.3282 L256.224,9.7032 L264.761,16.2742 L261.261,18.9702 L258.965,20.7392 L258.963,20.7372 L255.452,23.4412 L252.4,21.0922 L251.031,22.1462 L254.679,24.9562 L254.679,30.5812 L246.142,24.0092 L249.796,21.1962 L251.941,19.5442 L251.941,19.5452 L255.452,16.8422 L258.504,19.1912 L259.874,18.1372 Z M248.562,18.1372 L246.142,16.2742 L254.679,9.7032 L254.679,15.3282 L249.796,19.0872 L248.427,20.1412 L248.381,20.1772 L247.652,20.7382 L245.546,22.3592 L245.546,17.9232 L247.193,19.1902 L248.562,18.1372 Z M256.224,24.9562 L261.108,21.1962 L263.081,19.6762 L265.358,17.9232 L265.358,22.3592 L263.711,21.0922 L262.342,22.1462 L264.761,24.0092 L256.224,30.5812 L256.224,24.9562 Z\" id=\"Page-1\"></path></g></g></g></svg>"

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/adsList.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".adsList__self--1COj9 .adsList__row--2eM5f{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.adsList__self--1COj9 .adsList__button--o-Cn8{margin-left:auto}", "", {"version":3,"sources":["/apps/packages/components/src/adsList.scss"],"names":[],"mappings":"AAAA,2CAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,YAAY,CAAC,8CAAc,gBAAgB,CAAC","file":"adsList.scss","sourcesContent":[".self .row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.self .button{margin-left:auto}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "adsList__self--1COj9",
	"row": "adsList__row--2eM5f",
	"button": "adsList__button--o-Cn8"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/button.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".button__self--1HBVs{border:none;outline:none;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#263fff;letter-spacing:.01em}.button__self--1HBVs.button__primary--2mrKv{font-weight:300;color:#fff;font-size:15px;border-radius:3px;padding:13px 25px!important}.button__self--1HBVs.button__secondary--2Imox{float:right;background-color:#cfd9fa;border-radius:50px;color:#263fff;height:20px;text-align:center;font-size:12px;font-weight:700;-webkit-box-shadow:0 5px 12px rgba(184,188,206,.5);box-shadow:0 5px 12px rgba(184,188,206,.5)}.button__self--1HBVs.button__secondary--2Imox:disabled{background-color:#89939f;opacity:.4;cursor:not-allowed;color:#fff}.button__self--1HBVs.button__secondary--2Imox:not([disabled]):hover{-webkit-transform:translateY(-2px);transform:translateY(-2px)}.button__self--1HBVs:disabled{background-color:#89939f;opacity:.4;cursor:not-allowed;color:#fff}.button__self--1HBVs:not([disabled]):hover{cursor:pointer;color:#fff;background-color:#263fff;-webkit-box-shadow:0 5px 15px rgba(50,93,255,.45);box-shadow:0 5px 15px rgba(50,93,255,.45);-webkit-transform:translateY(-1px);transform:translateY(-1px)}.button__self--1HBVs:active{background-color:#263fff}", "", {"version":3,"sources":["/apps/packages/components/src/button.scss"],"names":[],"mappings":"AAAA,qBAAM,YAAY,aAAa,oBAAsB,mCAAmC,kCAAkC,yBAAyB,oBAAqB,CAAC,4CAAc,gBAAgB,WAAW,eAAe,kBAAkB,2BAA4B,CAAC,8CAAgB,YAAY,yBAAyB,mBAAmB,cAAc,YAAY,kBAAkB,eAAe,gBAAgB,mDAAsD,0CAA6C,CAAC,uDAAyB,yBAAyB,WAAY,mBAAmB,UAAU,CAAC,oEAAsC,mCAAmC,0BAA0B,CAAC,8BAAe,yBAAyB,WAAY,mBAAmB,UAAU,CAAC,2CAA4B,eAAe,WAAW,yBAAyB,kDAAqD,0CAA6C,mCAAmC,0BAA0B,CAAC,4BAAa,wBAAwB,CAAC","file":"button.scss","sourcesContent":[".self{border:none;outline:none;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#263fff;letter-spacing:0.01em}.self.primary{font-weight:300;color:#fff;font-size:15px;border-radius:3px;padding:13px 25px !important}.self.secondary{float:right;background-color:#cfd9fa;border-radius:50px;color:#263fff;height:20px;text-align:center;font-size:12px;font-weight:700;-webkit-box-shadow:0px 5px 12px rgba(184,188,206,0.5);box-shadow:0px 5px 12px rgba(184,188,206,0.5)}.self.secondary:disabled{background-color:#89939f;opacity:0.4;cursor:not-allowed;color:#fff}.self.secondary:not([disabled]):hover{-webkit-transform:translateY(-2px);transform:translateY(-2px)}.self:disabled{background-color:#89939f;opacity:0.4;cursor:not-allowed;color:#fff}.self:not([disabled]):hover{cursor:pointer;color:#fff;background-color:#263fff;-webkit-box-shadow:0px 5px 15px rgba(50,93,255,0.45);box-shadow:0px 5px 15px rgba(50,93,255,0.45);-webkit-transform:translateY(-1px);transform:translateY(-1px)}.self:active{background-color:#263fff}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "button__self--1HBVs",
	"primary": "button__primary--2mrKv",
	"secondary": "button__secondary--2Imox"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/icon.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".icon__self--1htNH{font-size:.8em}", "", {"version":3,"sources":["/apps/packages/components/src/icon.scss"],"names":[],"mappings":"AAAA,mBAAM,cAAe,CAAC","file":"icon.scss","sourcesContent":[".self{font-size:0.8em}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "icon__self--1htNH"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/input.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".input__self--Sta6U{position:relative;margin-bottom:20px;margin-top:20px;width:100%;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-transition:none!important;transition:none!important}.input__self--Sta6U .input__input--1h6KM{font-size:15px;padding:10px;width:calc(100% - 30px);background-color:#f5f7fa;border:1px solid #eef1f2;border-radius:3px;-webkit-box-shadow:none;box-shadow:none}.input__self--Sta6U .input__input--1h6KM:focus{outline:none;border:1px solid #263fff;background-color:#fff}.input__self--Sta6U .input__input--1h6KM:-moz-placeholder{box-shadow:none!important}.input__self--Sta6U.input__invalid--3Vmho{margin-bottom:calc(30px - 1em)}.input__self--Sta6U.input__invalid--3Vmho>.input__input--1h6KM{-webkit-box-shadow:0 0 5px 1px red;box-shadow:0 0 5px 1px red}.input__self--Sta6U .input__placeholder--26K8y{position:absolute;top:10px;left:5px;color:#89939f;font-size:15px;-webkit-transition:.2s;transition:.2s}.input__self--Sta6U .input__input--1h6KM:disabled~.input__placeholder--26K8y,.input__self--Sta6U .input__input--1h6KM:focus~.input__placeholder--26K8y,.input__self--Sta6U .input__input--1h6KM:valid~.input__placeholder--26K8y{color:#1b2437;font-size:11px;top:-16px;left:0}.input__self--Sta6U .input__error--3mUo8{color:red;height:1em;font-size:.8em;font-weight:600}", "", {"version":3,"sources":["/apps/packages/components/src/input.scss"],"names":[],"mappings":"AAAA,oBAAM,kBAAkB,mBAAmB,gBAAgB,WAAW,oBAAsB,mCAAmC,kCAAkC,kCAAmC,yBAA0B,CAAC,yCAAa,eAAe,aAAa,wBAAwB,yBAAyB,yBAAyB,kBAAkB,wBAAwB,eAAe,CAAC,+CAAmB,aAAa,yBAAyB,qBAAqB,CAAC,0DAA8B,yBAA0B,CAAC,0CAAc,8BAA8B,CAAC,+DAAqB,mCAAmC,0BAA0B,CAAC,+CAAmB,kBAAkB,SAAS,SAAS,cAAc,eAAe,uBAAwB,cAAe,CAAC,iOAAyG,cAAc,eAAe,UAAU,MAAQ,CAAC,yCAAa,UAAU,WAAW,eAAgB,eAAe,CAAC","file":"input.scss","sourcesContent":[".self{position:relative;margin-bottom:20px;margin-top:20px;width:100%;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-transition:none !important;transition:none !important}.self .input{font-size:15px;padding:10px;width:calc(100% - 30px);background-color:#f5f7fa;border:1px solid #eef1f2;border-radius:3px;-webkit-box-shadow:none;box-shadow:none}.self .input:focus{outline:none;border:1px solid #263fff;background-color:#fff}.self .input:-moz-placeholder{box-shadow:none !important}.self.invalid{margin-bottom:calc(30px - 1em)}.self.invalid>.input{-webkit-box-shadow:0 0 5px 1px red;box-shadow:0 0 5px 1px red}.self .placeholder{position:absolute;top:10px;left:5px;color:#89939f;font-size:15px;-webkit-transition:0.2s;transition:0.2s}.self .input:focus ~ .placeholder,.self .input:valid ~ .placeholder,.self .input:disabled ~ .placeholder{color:#1b2437;font-size:11px;top:-16px;left:0px}.self .error{color:red;height:1em;font-size:0.8em;font-weight:600}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "input__self--Sta6U",
	"input": "input__input--1h6KM",
	"invalid": "input__invalid--3Vmho",
	"placeholder": "input__placeholder--26K8y",
	"error": "input__error--3mUo8"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/label.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".label__self--33pBu{font-size:15px;text-align:left;font-family:PT Sans;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#89939f}", "", {"version":3,"sources":["/apps/packages/components/src/label.scss"],"names":[],"mappings":"AAAA,oBAAM,eAAe,gBAAgB,oBAAsB,mCAAmC,kCAAkC,aAAa,CAAC","file":"label.scss","sourcesContent":[".self{font-size:15px;text-align:left;font-family:'PT Sans';-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#89939f}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "label__self--33pBu"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/link.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".link__self--2lLaL{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:75%;font-weight:300}.link__self--2lLaL .link__title--3Whqu{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#263fff;font-weight:700;font-size:1.2em;-ms-flex-negative:0;flex-shrink:0}.link__self--2lLaL .link__header--DbUQP{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.link__self--2lLaL .link__summary--3-V2C{color:#545454}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ{overflow:hidden;position:relative;line-height:1.2em;max-height:2.4em;text-align:justify}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ:before{content:\"...\";position:absolute;right:0;bottom:0;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines2--IX2SJ:after{content:\"\";position:absolute;right:0;width:1em;height:1em;margin-top:.2em;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8{overflow:hidden;position:relative;line-height:1.2em;max-height:9.6em;text-align:justify}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8:before{content:\"...\";position:absolute;right:0;bottom:0;background-color:#fff}.link__self--2lLaL .link__summary--3-V2C.link__lines8--3BXj8:after{content:\"\";position:absolute;right:0;width:1em;height:1em;margin-top:.2em;background-color:#fff}.link__self--2lLaL .link__footer--3lI90{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.link__self--2lLaL .link__link--2-AZ1{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#006621;font-size:.8em;-ms-flex-negative:0;flex-shrink:0;outline:none}.link__self--2lLaL .link__link--2-AZ1:link,.link__self--2lLaL .link__link--2-AZ1:visited{text-decoration:none}", "", {"version":3,"sources":["/apps/packages/components/src/link.scss"],"names":[],"mappings":"AAAA,mBAAM,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,cAAc,eAAe,CAAC,uCAAa,mBAAmB,gBAAgB,uBAAuB,cAAc,gBAAgB,gBAAgB,oBAAoB,aAAa,CAAC,wCAAc,yBAAyB,sBAAsB,6BAA6B,CAAC,yCAAe,aAAa,CAAC,6DAAsB,gBAAgB,kBAAkB,kBAAkB,iBAAiB,kBAAkB,CAAC,oEAA6B,cAAc,kBAAkB,QAAQ,SAAS,qBAAqB,CAAC,mEAA4B,WAAW,kBAAkB,QAAQ,UAAU,WAAW,gBAAiB,qBAAqB,CAAC,6DAAsB,gBAAgB,kBAAkB,kBAAkB,iBAAiB,kBAAkB,CAAC,oEAA6B,cAAc,kBAAkB,QAAQ,SAAS,qBAAqB,CAAC,mEAA4B,WAAW,kBAAkB,QAAQ,UAAU,WAAW,gBAAiB,qBAAqB,CAAC,wCAAc,sBAAsB,mBAAmB,qBAAqB,yBAAyB,sBAAsB,6BAA6B,CAAC,sCAAY,cAAc,mBAAmB,gBAAgB,uBAAuB,cAAc,eAAgB,oBAAoB,cAAc,YAAY,CAAC,AAAsC,yFAAoB,oBAAoB,CAAC","file":"link.scss","sourcesContent":[".self{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:75%;font-weight:300}.self .title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#263fff;font-weight:700;font-size:1.2em;-ms-flex-negative:0;flex-shrink:0}.self .header{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.self .summary{color:#545454}.self .summary.lines2{overflow:hidden;position:relative;line-height:1.2em;max-height:2.4em;text-align:justify}.self .summary.lines2:before{content:'...';position:absolute;right:0;bottom:0;background-color:#fff}.self .summary.lines2:after{content:'';position:absolute;right:0;width:1em;height:1em;margin-top:0.2em;background-color:#fff}.self .summary.lines8{overflow:hidden;position:relative;line-height:1.2em;max-height:9.6em;text-align:justify}.self .summary.lines8:before{content:'...';position:absolute;right:0;bottom:0;background-color:#fff}.self .summary.lines8:after{content:'';position:absolute;right:0;width:1em;height:1em;margin-top:0.2em;background-color:#fff}.self .footer{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.self .link{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#006621;font-size:0.8em;-ms-flex-negative:0;flex-shrink:0;outline:none}.self .link:link{text-decoration:none}.self .link:visited{text-decoration:none}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "link__self--2lLaL",
	"title": "link__title--3Whqu",
	"header": "link__header--DbUQP",
	"summary": "link__summary--3-V2C",
	"lines2": "link__lines2--IX2SJ",
	"lines8": "link__lines8--3BXj8",
	"footer": "link__footer--3lI90",
	"link": "link__link--2-AZ1"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/linkList.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".linkList__self--Y8QOq .linkList__row--LxprX{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.linkList__self--Y8QOq .linkList__button--elz1X{margin-left:auto}", "", {"version":3,"sources":["/apps/packages/components/src/linkList.scss"],"names":[],"mappings":"AAAA,6CAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,YAAY,CAAC,gDAAc,gBAAgB,CAAC","file":"linkList.scss","sourcesContent":[".self .row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:10px}.self .button{margin-left:auto}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "linkList__self--Y8QOq",
	"row": "linkList__row--LxprX",
	"button": "linkList__button--elz1X"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/loader.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".loader__self--2U9as{border:1px solid #eef1f2;border-top:1px solid #263fff;border-radius:50%;width:40px;height:40px;-webkit-animation:loader__spin--1Wsm2 2s linear infinite;animation:loader__spin--1Wsm2 2s linear infinite}@-webkit-keyframes loader__spin--1Wsm2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes loader__spin--1Wsm2{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}", "", {"version":3,"sources":["/apps/packages/components/src/loader.scss"],"names":[],"mappings":"AAAA,qBAAM,yBAAyB,6BAA6B,kBAAkB,WAAW,YAAY,yDAA0C,gDAAiC,CAAC,uCAAwB,GAAG,+BAA+B,sBAAsB,CAAC,GAAK,gCAAiC,uBAAwB,CAAC,CAAC,+BAAgB,GAAG,+BAA+B,sBAAsB,CAAC,GAAK,gCAAiC,uBAAwB,CAAC,CAAC","file":"loader.scss","sourcesContent":[".self{border:1px solid #eef1f2;border-top:1px solid #263fff;border-radius:50%;width:40px;height:40px;-webkit-animation:spin 2s linear infinite;animation:spin 2s linear infinite}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "loader__self--2U9as",
	"spin": "loader__spin--1Wsm2"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/paper.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".paper__self--1qtNi{-webkit-box-flex:1;-ms-flex:1;flex:1;background-color:#fff;-webkit-box-shadow:0 5px 20px 0 rgba(19,38,110,.08);box-shadow:0 5px 20px 0 rgba(19,38,110,.08);margin-top:20px;border-radius:3px}", "", {"version":3,"sources":["/apps/packages/components/src/paper.scss"],"names":[],"mappings":"AAAA,oBAAM,mBAAmB,WAAW,OAAO,sBAAsB,oDAAyD,4CAAiD,gBAAgB,iBAAiB,CAAC","file":"paper.scss","sourcesContent":[".self{-webkit-box-flex:1;-ms-flex:1;flex:1;background-color:#fff;-webkit-box-shadow:0px 5px 20px 0px rgba(19,38,110,0.08);box-shadow:0px 5px 20px 0px rgba(19,38,110,0.08);margin-top:20px;border-radius:3px}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "paper__self--1qtNi"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/textWithLabel.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".textWithLabel__self--3SeBK{padding:1em}.textWithLabel__self--3SeBK .textWithLabel__text--2lMFz{margin-top:5px;font-size:15px;color:#1b2437;text-align:left;overflow:hidden;word-wrap:nowrap;text-overflow:ellipsis}", "", {"version":3,"sources":["/apps/packages/components/src/textWithLabel.scss"],"names":[],"mappings":"AAAA,4BAAM,WAAW,CAAC,wDAAY,eAAe,eAAe,cAAc,gBAAgB,gBAAgB,iBAAiB,sBAAsB,CAAC","file":"textWithLabel.scss","sourcesContent":[".self{padding:1em}.self .text{margin-top:5px;font-size:15px;color:#1b2437;text-align:left;overflow:hidden;word-wrap:nowrap;text-overflow:ellipsis}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "textWithLabel__self--3SeBK",
	"text": "textWithLabel__text--2lMFz"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/tooltip.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".tooltip__self--2h8p3{position:relative}.tooltip__self--2h8p3 .tooltip__text--1cz4e{visibility:hidden;width:120px;background-color:#1b2437;color:#fff;text-align:center;padding:5px 0;border-radius:6px;position:absolute;-webkit-transition-delay:0s;transition-delay:0s}.tooltip__self--2h8p3:hover .tooltip__text--1cz4e{visibility:visible;-webkit-transition-delay:.5s;transition-delay:.5s}", "", {"version":3,"sources":["/apps/packages/components/src/tooltip.scss"],"names":[],"mappings":"AAAA,sBAAM,iBAAiB,CAAC,4CAAY,kBAAkB,YAAY,yBAAyB,WAAW,kBAAkB,cAAc,kBAAkB,kBAAkB,4BAA4B,mBAAmB,CAAC,kDAAkB,mBAAmB,6BAA8B,oBAAqB,CAAC","file":"tooltip.scss","sourcesContent":[".self{position:relative}.self .text{visibility:hidden;width:120px;background-color:#1b2437;color:#fff;text-align:center;padding:5px 0;border-radius:6px;position:absolute;-webkit-transition-delay:0s;transition-delay:0s}.self:hover .text{visibility:visible;-webkit-transition-delay:0.5s;transition-delay:0.5s}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "tooltip__self--2h8p3",
	"text": "tooltip__text--1cz4e"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/Status.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".Status__self--2jtwo{width:100vw;height:100vh;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}@media screen and (max-width:1200px){.Status__self--2jtwo{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center}}.Status__self--2jtwo .Status__preview--1IUV0{width:300px;height:250px;margin-right:30px;padding:10px;-webkit-box-flex:1;-ms-flex:auto;flex:auto;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:1200px){.Status__self--2jtwo .Status__preview--1IUV0{width:calc(100vw - 20px);height:unset;margin:0;margin-bottom:20px}}.Status__self--2jtwo .Status__loader--2FksP{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.Status__self--2jtwo .Status__content--1RuY7{text-align:center;max-width:40vw;padding:10px}@media screen and (max-width:1200px){.Status__self--2jtwo .Status__content--1RuY7{max-width:calc(100vw - 20px);margin:0}}.Status__self--2jtwo .Status__label--lGQpY{width:100%;padding:0;margin-top:-1em}.Status__self--2jtwo .Status__link-label--2cc5d{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.Status__self--2jtwo .Status__link--2WauU{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.Status__self--2jtwo .Status__add-bookmark--H6_JK{-webkit-box-flex:1;-ms-flex:auto;flex:auto;-ms-flex-negative:0;flex-shrink:0}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Status/Status.scss"],"names":[],"mappings":"AAAA,qBAAM,YAAY,aAAa,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,wBAAwB,qBAAqB,uBAAuB,wBAAwB,qBAAqB,sBAAsB,CAAC,qCAAsC,qBAAM,4BAA4B,6BAA6B,0BAA0B,sBAAsB,uBAAuB,oBAAoB,2BAA2B,yBAAyB,sBAAsB,kBAAkB,CAAC,CAAC,6CAAe,YAAY,aAAa,kBAAkB,aAAa,mBAAmB,cAAc,UAAU,mBAAmB,oBAAoB,YAAY,oBAAoB,cAAc,oBAAoB,oBAAoB,aAAa,yBAAyB,sBAAsB,kBAAkB,CAAC,qCAAsC,6CAAe,yBAAyB,aAAa,SAAS,kBAAkB,CAAC,CAAC,4CAAc,WAAW,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,6CAAe,kBAAkB,eAAe,YAAY,CAAC,qCAAsC,6CAAe,6BAA6B,QAAQ,CAAC,CAAC,2CAAa,WAAW,UAAU,eAAe,CAAC,gDAAkB,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,kBAAkB,CAAC,0CAAY,gBAAgB,uBAAuB,kBAAkB,CAAC,kDAAoB,mBAAmB,cAAc,UAAU,oBAAoB,aAAa,CAAC","file":"Status.scss","sourcesContent":[".self{width:100vw;height:100vh;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}@media screen and (max-width: 1200px){.self{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center}}.self .preview{width:300px;height:250px;margin-right:30px;padding:10px;-webkit-box-flex:1;-ms-flex:auto;flex:auto;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width: 1200px){.self .preview{width:calc(100vw - 20px);height:unset;margin:0;margin-bottom:20px}}.self .loader{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .content{text-align:center;max-width:40vw;padding:10px}@media screen and (max-width: 1200px){.self .content{max-width:calc(100vw - 20px);margin:0}}.self .label{width:100%;padding:0;margin-top:-1em}.self .link-label{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.self .link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.self .add-bookmark{-webkit-box-flex:1;-ms-flex:auto;flex:auto;-ms-flex-negative:0;flex-shrink:0}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "Status__self--2jtwo",
	"preview": "Status__preview--1IUV0",
	"loader": "Status__loader--2FksP",
	"content": "Status__content--1RuY7",
	"label": "Status__label--lGQpY",
	"link-label": "Status__link-label--2cc5d",
	"linkLabel": "Status__link-label--2cc5d",
	"link": "Status__link--2WauU",
	"add-bookmark": "Status__add-bookmark--H6_JK",
	"addBookmark": "Status__add-bookmark--H6_JK"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/components/steps.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".steps__self--3KyHm{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}@media screen and (max-width:1200px){.steps__self--3KyHm{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}}.steps__self--3KyHm .steps__progress-cotainer--1m2lP{position:relative}.steps__self--3KyHm .steps__progress--32faB{position:absolute;left:0;top:20px;z-index:1;width:100%;height:1em;border-radius:1em;background-color:#eef1f2}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__progress--32faB{width:1em;height:100%;top:0;left:20px}}.steps__self--3KyHm .steps__steps-container--1FxNW{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__steps-container--1FxNW{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}}.steps__self--3KyHm .steps__step--3BEfR{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:2;margin-top:calc(20px + .5em - 1.5em)}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__step--3BEfR{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-top:0;margin-left:calc(20px + .5em - 1.5em)}}.steps__self--3KyHm .steps__step--3BEfR.steps__disabled--gVRIq{opacity:.5;cursor:not-allowed}.steps__self--3KyHm .steps__step--3BEfR.steps__waiting--ZH46m{opacity:.5}.steps__self--3KyHm .steps__step--3BEfR.steps__done--2CvMD .steps__icon--2bo5s,.steps__self--3KyHm .steps__step--3BEfR.steps__done--2CvMD path{color:lime;fill:lime}.steps__self--3KyHm .steps__step--3BEfR .steps__icon--2bo5s{-ms-flex-item-align:center;align-self:center;width:3em;height:3em;background-color:#eef1f2;border-radius:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.steps__self--3KyHm .steps__step--3BEfR .steps__content--1aKlz{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:1200px){.steps__self--3KyHm .steps__step--3BEfR .steps__content--1aKlz{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding-left:20px}}.steps__self--3KyHm .steps__icon--2bo5s{font-size:1em}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Status/components/steps.scss"],"names":[],"mappings":"AAAA,oBAAM,WAAW,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,qBAAqB,CAAC,qCAAsC,oBAAM,8BAA8B,6BAA6B,uBAAuB,kBAAkB,CAAC,CAAC,qDAAyB,iBAAiB,CAAC,4CAAgB,kBAAkB,OAAO,SAAS,UAAU,WAAW,WAAW,kBAAkB,wBAAwB,CAAC,qCAAsC,4CAAgB,UAAU,YAAY,MAAM,SAAS,CAAC,CAAC,mDAAuB,oBAAoB,oBAAoB,aAAa,8BAA8B,6BAA6B,uBAAuB,mBAAmB,yBAAyB,sBAAsB,6BAA6B,CAAC,qCAAsC,mDAAuB,4BAA4B,6BAA6B,0BAA0B,qBAAqB,CAAC,CAAC,wCAAY,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,UAAU,oCAAqC,CAAC,qCAAsC,wCAAY,8BAA8B,6BAA6B,uBAAuB,mBAAmB,aAAa,qCAAsC,CAAC,CAAC,+DAAqB,WAAY,kBAAkB,CAAC,8DAAoB,UAAW,CAAC,+IAA6C,WAAW,SAAS,CAAC,4DAAkB,2BAA2B,kBAAkB,UAAU,WAAW,yBAAyB,kBAAkB,oBAAoB,oBAAoB,aAAa,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,+DAAqB,oBAAoB,oBAAoB,aAAa,4BAA4B,6BAA6B,0BAA0B,sBAAsB,yBAAyB,sBAAsB,kBAAkB,CAAC,qCAAsC,+DAAqB,wBAAwB,qBAAqB,uBAAuB,iBAAiB,CAAC,CAAC,wCAAY,aAAa,CAAC","file":"steps.scss","sourcesContent":[".self{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}@media screen and (max-width: 1200px){.self{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}}.self .progress-cotainer{position:relative}.self .progress{position:absolute;left:0;top:20px;z-index:1;width:100%;height:1em;border-radius:1em;background-color:#eef1f2}@media screen and (max-width: 1200px){.self .progress{width:1em;height:100%;top:0;left:20px}}.self .steps-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}@media screen and (max-width: 1200px){.self .steps-container{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}}.self .step{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:2;margin-top:calc(20px + 0.5em - 1.5em)}@media screen and (max-width: 1200px){.self .step{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-top:0;margin-left:calc(20px + 0.5em - 1.5em)}}.self .step.disabled{opacity:0.5;cursor:not-allowed}.self .step.waiting{opacity:0.5}.self .step.done .icon,.self .step.done path{color:lime;fill:lime}.self .step .icon{-ms-flex-item-align:center;align-self:center;width:3em;height:3em;background-color:#eef1f2;border-radius:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .step .content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width: 1200px){.self .step .content{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding-left:20px}}.self .icon{font-size:1em}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "steps__self--3KyHm",
	"progress-cotainer": "steps__progress-cotainer--1m2lP",
	"progressCotainer": "steps__progress-cotainer--1m2lP",
	"progress": "steps__progress--32faB",
	"steps-container": "steps__steps-container--1FxNW",
	"stepsContainer": "steps__steps-container--1FxNW",
	"step": "steps__step--3BEfR",
	"disabled": "steps__disabled--gVRIq",
	"waiting": "steps__waiting--ZH46m",
	"done": "steps__done--2CvMD",
	"icon": "steps__icon--2bo5s",
	"content": "steps__content--1aKlz"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Whitelist.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, ".Whitelist__self--1BkMz{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:10px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.Whitelist__self--1BkMz .Whitelist__paper--2ZCsu{width:70%;padding:10px}", "", {"version":3,"sources":["/apps/apps/links/src/pages/Whitelist.scss"],"names":[],"mappings":"AAAA,wBAAM,WAAW,YAAY,oBAAoB,oBAAoB,aAAa,gBAAgB,4BAA4B,6BAA6B,0BAA0B,sBAAsB,wBAAwB,qBAAqB,uBAAuB,yBAAyB,sBAAsB,kBAAkB,CAAC,iDAAa,UAAU,YAAY,CAAC","file":"Whitelist.scss","sourcesContent":[".self{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:10px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.self .paper{width:70%;padding:10px}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"self": "Whitelist__self--1BkMz",
	"paper": "Whitelist__paper--2ZCsu"
};

/***/ }),

/***/ "../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./styles/all.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../../node_modules/css-loader/lib/css-base.js")(true);
// imports
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=PT+Sans:400,700);", ""]);

// module
exports.push([module.i, "body{font-family:PT Sans,sans-serif}", "", {"version":3,"sources":["/apps/apps/links/styles/all.scss"],"names":[],"mappings":"AAAuE,KAAK,8BAAiC,CAAC","file":"all.scss","sourcesContent":["@import url(\"https://fonts.googleapis.com/css?family=PT+Sans:400,700\");body{font-family:'PT Sans', sans-serif}\n"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "../../node_modules/utf8/utf8.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return utf8;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/webpack/buildin/module.js")(module), __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/value-equal/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);

/***/ }),

/***/ "../../node_modules/warning/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (false) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "../../node_modules/web3/index.js":
/***/ (function(module, exports, __webpack_require__) {

var Web3 = __webpack_require__("../../node_modules/web3/lib/web3.js");

// dont override global variable
if (typeof window !== 'undefined' && typeof window.Web3 === 'undefined') {
    window.Web3 = Web3;
}

module.exports = Web3;


/***/ }),

/***/ "../../node_modules/web3/lib/contracts/GlobalRegistrar.json":
/***/ (function(module, exports) {

module.exports = [{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"name","outputs":[{"name":"o_name","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"content","outputs":[{"name":"","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"reserve","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"subRegistrar","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_registrar","type":"address"}],"name":"setSubRegistrar","outputs":[],"type":"function"},{"constant":false,"inputs":[],"name":"Registrar","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_a","type":"address"},{"name":"_primary","type":"bool"}],"name":"setAddress","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_content","type":"bytes32"}],"name":"setContent","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"disown","outputs":[],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_name","type":"bytes32"},{"indexed":false,"name":"_winner","type":"address"}],"name":"AuctionEnded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_name","type":"bytes32"},{"indexed":false,"name":"_bidder","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"NewBid","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"}],"name":"Changed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"},{"indexed":true,"name":"addr","type":"address"}],"name":"PrimaryChanged","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/contracts/ICAPRegistrar.json":
/***/ (function(module, exports) {

module.exports = [{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_refund","type":"address"}],"name":"disown","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"_name","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"}],"name":"reserve","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_newOwner","type":"address"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"bytes32"},{"name":"_a","type":"address"}],"name":"setAddr","outputs":[],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"name","type":"bytes32"}],"name":"Changed","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/contracts/SmartExchange.json":
/***/ (function(module, exports) {

module.exports = [{"constant":false,"inputs":[{"name":"from","type":"bytes32"},{"name":"to","type":"address"},{"name":"value","type":"uint256"}],"name":"transfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"from","type":"bytes32"},{"name":"to","type":"address"},{"name":"indirectId","type":"bytes32"},{"name":"value","type":"uint256"}],"name":"icapTransfer","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"to","type":"bytes32"}],"name":"deposit","outputs":[],"payable":true,"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"AnonymousDeposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"bytes32"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"bytes32"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"indirectId","type":"bytes32"},{"indexed":false,"name":"value","type":"uint256"}],"name":"IcapTransfer","type":"event"}]

/***/ }),

/***/ "../../node_modules/web3/lib/solidity/address.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeAddress is a prootype that represents address type
 * It matches:
 * address
 * address[]
 * address[4]
 * address[][]
 * address[3][]
 * address[][6][], ...
 */
var SolidityTypeAddress = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputAddress;
};

SolidityTypeAddress.prototype = new SolidityType({});
SolidityTypeAddress.prototype.constructor = SolidityTypeAddress;

SolidityTypeAddress.prototype.isType = function (name) {
    return !!name.match(/address(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeAddress;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/bool.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeBool is a prootype that represents bool type
 * It matches:
 * bool
 * bool[]
 * bool[4]
 * bool[][]
 * bool[3][]
 * bool[][6][], ...
 */
var SolidityTypeBool = function () {
    this._inputFormatter = f.formatInputBool;
    this._outputFormatter = f.formatOutputBool;
};

SolidityTypeBool.prototype = new SolidityType({});
SolidityTypeBool.prototype.constructor = SolidityTypeBool;

SolidityTypeBool.prototype.isType = function (name) {
    return !!name.match(/^bool(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBool;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/bytes.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeBytes is a prototype that represents the bytes type.
 * It matches:
 * bytes
 * bytes[]
 * bytes[4]
 * bytes[][]
 * bytes[3][]
 * bytes[][6][], ...
 * bytes32
 * bytes8[4]
 * bytes[3][]
 */
var SolidityTypeBytes = function () {
    this._inputFormatter = f.formatInputBytes;
    this._outputFormatter = f.formatOutputBytes;
};

SolidityTypeBytes.prototype = new SolidityType({});
SolidityTypeBytes.prototype.constructor = SolidityTypeBytes;

SolidityTypeBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes([0-9]{1,})(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBytes;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/coder.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file coder.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");

var SolidityTypeAddress = __webpack_require__("../../node_modules/web3/lib/solidity/address.js");
var SolidityTypeBool = __webpack_require__("../../node_modules/web3/lib/solidity/bool.js");
var SolidityTypeInt = __webpack_require__("../../node_modules/web3/lib/solidity/int.js");
var SolidityTypeUInt = __webpack_require__("../../node_modules/web3/lib/solidity/uint.js");
var SolidityTypeDynamicBytes = __webpack_require__("../../node_modules/web3/lib/solidity/dynamicbytes.js");
var SolidityTypeString = __webpack_require__("../../node_modules/web3/lib/solidity/string.js");
var SolidityTypeReal = __webpack_require__("../../node_modules/web3/lib/solidity/real.js");
var SolidityTypeUReal = __webpack_require__("../../node_modules/web3/lib/solidity/ureal.js");
var SolidityTypeBytes = __webpack_require__("../../node_modules/web3/lib/solidity/bytes.js");

var isDynamic = function (solidityType, type) {
   return solidityType.isDynamicType(type) ||
          solidityType.isDynamicArray(type);
};

/**
 * SolidityCoder prototype should be used to encode/decode solidity params of any type
 */
var SolidityCoder = function (types) {
    this._types = types;
};

/**
 * This method should be used to transform type to SolidityType
 *
 * @method _requireType
 * @param {String} type
 * @returns {SolidityType}
 * @throws {Error} throws if no matching type is found
 */
SolidityCoder.prototype._requireType = function (type) {
    var solidityType = this._types.filter(function (t) {
        return t.isType(type);
    })[0];

    if (!solidityType) {
        throw Error('invalid solidity type!: ' + type);
    }

    return solidityType;
};

/**
 * Should be used to encode plain param
 *
 * @method encodeParam
 * @param {String} type
 * @param {Object} plain param
 * @return {String} encoded plain param
 */
SolidityCoder.prototype.encodeParam = function (type, param) {
    return this.encodeParams([type], [param]);
};

/**
 * Should be used to encode list of params
 *
 * @method encodeParams
 * @param {Array} types
 * @param {Array} params
 * @return {String} encoded list of params
 */
SolidityCoder.prototype.encodeParams = function (types, params) {
    var solidityTypes = this.getSolidityTypes(types);

    var encodeds = solidityTypes.map(function (solidityType, index) {
        return solidityType.encode(params[index], types[index]);
    });

    var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {
        var staticPartLength = solidityType.staticPartLength(types[index]);
        var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;

        return acc + (isDynamic(solidityTypes[index], types[index]) ?
            32 :
            roundedStaticPartLength);
    }, 0);

    var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);

    return result;
};

SolidityCoder.prototype.encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {
    var result = "";
    var self = this;

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            result += f.formatInputInt(dynamicOffset).encode();
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
        } else {
            // don't add length to dynamicOffset. it's already counted
            result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
        }

        // TODO: figure out nested arrays
    });

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
            result += e;
        }
    });
    return result;
};

// TODO: refactor whole encoding!
SolidityCoder.prototype.encodeWithOffset = function (type, solidityType, encoded, offset) {
    var self = this;
    if (solidityType.isDynamicArray(type)) {
        return (function () {
            // offset was already set
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = encoded[0];

            (function () {
                var previousLength = 2; // in int
                if (solidityType.isDynamicArray(nestedName)) {
                    for (var i = 1; i < encoded.length; i++) {
                        previousLength += +(encoded[i - 1])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                }
            })();

            // first element is length, skip it
            (function () {
                for (var i = 0; i < encoded.length - 1; i++) {
                    var additionalOffset = result / 2;
                    result += self.encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset +  additionalOffset);
                }
            })();

            return result;
        })();

    } else if (solidityType.isStaticArray(type)) {
        return (function () {
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = "";


            if (solidityType.isDynamicArray(nestedName)) {
                (function () {
                    var previousLength = 0; // in int
                    for (var i = 0; i < encoded.length; i++) {
                        // calculate length of previous item
                        previousLength += +(encoded[i - 1] || [])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                })();
            }

            (function () {
                for (var i = 0; i < encoded.length; i++) {
                    var additionalOffset = result / 2;
                    result += self.encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);
                }
            })();

            return result;
        })();
    }

    return encoded;
};

/**
 * Should be used to decode bytes to plain param
 *
 * @method decodeParam
 * @param {String} type
 * @param {String} bytes
 * @return {Object} plain param
 */
SolidityCoder.prototype.decodeParam = function (type, bytes) {
    return this.decodeParams([type], bytes)[0];
};

/**
 * Should be used to decode list of params
 *
 * @method decodeParam
 * @param {Array} types
 * @param {String} bytes
 * @return {Array} array of plain params
 */
SolidityCoder.prototype.decodeParams = function (types, bytes) {
    var solidityTypes = this.getSolidityTypes(types);
    var offsets = this.getOffsets(types, solidityTypes);

    return solidityTypes.map(function (solidityType, index) {
        return solidityType.decode(bytes, offsets[index],  types[index], index);
    });
};

SolidityCoder.prototype.getOffsets = function (types, solidityTypes) {
    var lengths =  solidityTypes.map(function (solidityType, index) {
        return solidityType.staticPartLength(types[index]);
    });

    for (var i = 1; i < lengths.length; i++) {
         // sum with length of previous element
        lengths[i] += lengths[i - 1];
    }

    return lengths.map(function (length, index) {
        // remove the current length, so the length is sum of previous elements
        var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
        return length - staticPartLength;
    });
};

SolidityCoder.prototype.getSolidityTypes = function (types) {
    var self = this;
    return types.map(function (type) {
        return self._requireType(type);
    });
};

var coder = new SolidityCoder([
    new SolidityTypeAddress(),
    new SolidityTypeBool(),
    new SolidityTypeInt(),
    new SolidityTypeUInt(),
    new SolidityTypeDynamicBytes(),
    new SolidityTypeBytes(),
    new SolidityTypeString(),
    new SolidityTypeReal(),
    new SolidityTypeUReal()
]);

module.exports = coder;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/dynamicbytes.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

var SolidityTypeDynamicBytes = function () {
    this._inputFormatter = f.formatInputDynamicBytes;
    this._outputFormatter = f.formatOutputDynamicBytes;
};

SolidityTypeDynamicBytes.prototype = new SolidityType({});
SolidityTypeDynamicBytes.prototype.constructor = SolidityTypeDynamicBytes;

SolidityTypeDynamicBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes(\[([0-9]*)\])*$/);
};

SolidityTypeDynamicBytes.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeDynamicBytes;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/formatters.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var SolidityParam = __webpack_require__("../../node_modules/web3/lib/solidity/param.js");


/**
 * Formats input value to byte representation of int
 * If value is negative, return it's two's complement
 * If the value is floating point, round it down
 *
 * @method formatInputInt
 * @param {String|Number|BigNumber} value that needs to be formatted
 * @returns {SolidityParam}
 */
var formatInputInt = function (value) {
    BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
    var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatDynamicInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputDynamicBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of string
 *
 * @method formatInputString
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputString = function (value) {
    var result = utils.fromUtf8(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of bool
 *
 * @method formatInputBool
 * @param {Boolean}
 * @returns {SolidityParam}
 */
var formatInputBool = function (value) {
    var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');
    return new SolidityParam(result);
};

/**
 * Formats input value to byte representation of real
 * Values are multiplied by 2^m and encoded as integers
 *
 * @method formatInputReal
 * @param {String|Number|BigNumber}
 * @returns {SolidityParam}
 */
var formatInputReal = function (value) {
    return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));
};

/**
 * Check if input value is negative
 *
 * @method signedIsNegative
 * @param {String} value is hex format
 * @returns {Boolean} true if it is negative, otherwise false
 */
var signedIsNegative = function (value) {
    return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';
};

/**
 * Formats right-aligned output bytes to int
 *
 * @method formatOutputInt
 * @param {SolidityParam} param
 * @returns {BigNumber} right-aligned output bytes formatted to big number
 */
var formatOutputInt = function (param) {
    var value = param.staticPart() || "0";

    // check if it's negative number
    // it it is, return two's complement
    if (signedIsNegative(value)) {
        return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);
    }
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to uint
 *
 * @method formatOutputUInt
 * @param {SolidityParam}
 * @returns {BigNumeber} right-aligned output bytes formatted to uint
 */
var formatOutputUInt = function (param) {
    var value = param.staticPart() || "0";
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to real
 *
 * @method formatOutputReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to real
 */
var formatOutputReal = function (param) {
    return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Formats right-aligned output bytes to ureal
 *
 * @method formatOutputUReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to ureal
 */
var formatOutputUReal = function (param) {
    return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Should be used to format output bool
 *
 * @method formatOutputBool
 * @param {SolidityParam}
 * @returns {Boolean} right-aligned input bytes formatted to bool
 */
var formatOutputBool = function (param) {
    return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @param {String} name type name
 * @returns {String} hex string
 */
var formatOutputBytes = function (param, name) {
    var matches = name.match(/^bytes([0-9]*)/);
    var size = parseInt(matches[1]);
    return '0x' + param.staticPart().slice(0, 2 * size);
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputDynamicBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} hex string
 */
var formatOutputDynamicBytes = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return '0x' + param.dynamicPart().substr(64, length);
};

/**
 * Should be used to format output string
 *
 * @method formatOutputString
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} ascii string
 */
var formatOutputString = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return utils.toUtf8(param.dynamicPart().substr(64, length));
};

/**
 * Should be used to format output address
 *
 * @method formatOutputAddress
 * @param {SolidityParam} right-aligned input bytes
 * @returns {String} address
 */
var formatOutputAddress = function (param) {
    var value = param.staticPart();
    return "0x" + value.slice(value.length - 40, value.length);
};

module.exports = {
    formatInputInt: formatInputInt,
    formatInputBytes: formatInputBytes,
    formatInputDynamicBytes: formatInputDynamicBytes,
    formatInputString: formatInputString,
    formatInputBool: formatInputBool,
    formatInputReal: formatInputReal,
    formatOutputInt: formatOutputInt,
    formatOutputUInt: formatOutputUInt,
    formatOutputReal: formatOutputReal,
    formatOutputUReal: formatOutputUReal,
    formatOutputBool: formatOutputBool,
    formatOutputBytes: formatOutputBytes,
    formatOutputDynamicBytes: formatOutputDynamicBytes,
    formatOutputString: formatOutputString,
    formatOutputAddress: formatOutputAddress
};


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/int.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeInt is a prootype that represents int type
 * It matches:
 * int
 * int[]
 * int[4]
 * int[][]
 * int[3][]
 * int[][6][], ...
 * int32
 * int64[]
 * int8[4]
 * int256[][]
 * int[3][]
 * int64[][6][], ...
 */
var SolidityTypeInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputInt;
};

SolidityTypeInt.prototype = new SolidityType({});
SolidityTypeInt.prototype.constructor = SolidityTypeInt;

SolidityTypeInt.prototype.isType = function (name) {
    return !!name.match(/^int([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeInt;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/param.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file param.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

/**
 * SolidityParam object prototype.
 * Should be used when encoding, decoding solidity bytes
 */
var SolidityParam = function (value, offset) {
    this.value = value || '';
    this.offset = offset; // offset in bytes
};

/**
 * This method should be used to get length of params's dynamic part
 * 
 * @method dynamicPartLength
 * @returns {Number} length of dynamic part (in bytes)
 */
SolidityParam.prototype.dynamicPartLength = function () {
    return this.dynamicPart().length / 2;
};

/**
 * This method should be used to create copy of solidity param with different offset
 *
 * @method withOffset
 * @param {Number} offset length in bytes
 * @returns {SolidityParam} new solidity param with applied offset
 */
SolidityParam.prototype.withOffset = function (offset) {
    return new SolidityParam(this.value, offset);
};

/**
 * This method should be used to combine solidity params together
 * eg. when appending an array
 *
 * @method combine
 * @param {SolidityParam} param with which we should combine
 * @param {SolidityParam} result of combination
 */
SolidityParam.prototype.combine = function (param) {
    return new SolidityParam(this.value + param.value); 
};

/**
 * This method should be called to check if param has dynamic size.
 * If it has, it returns true, otherwise false
 *
 * @method isDynamic
 * @returns {Boolean}
 */
SolidityParam.prototype.isDynamic = function () {
    return this.offset !== undefined;
};

/**
 * This method should be called to transform offset to bytes
 *
 * @method offsetAsBytes
 * @returns {String} bytes representation of offset
 */
SolidityParam.prototype.offsetAsBytes = function () {
    return !this.isDynamic() ? '' : utils.padLeft(utils.toTwosComplement(this.offset).toString(16), 64);
};

/**
 * This method should be called to get static part of param
 *
 * @method staticPart
 * @returns {String} offset if it is a dynamic param, otherwise value
 */
SolidityParam.prototype.staticPart = function () {
    if (!this.isDynamic()) {
        return this.value; 
    } 
    return this.offsetAsBytes();
};

/**
 * This method should be called to get dynamic part of param
 *
 * @method dynamicPart
 * @returns {String} returns a value if it is a dynamic param, otherwise empty string
 */
SolidityParam.prototype.dynamicPart = function () {
    return this.isDynamic() ? this.value : '';
};

/**
 * This method should be called to encode param
 *
 * @method encode
 * @returns {String}
 */
SolidityParam.prototype.encode = function () {
    return this.staticPart() + this.dynamicPart();
};

/**
 * This method should be called to encode array of params
 *
 * @method encodeList
 * @param {Array[SolidityParam]} params
 * @returns {String}
 */
SolidityParam.encodeList = function (params) {
    
    // updating offsets
    var totalOffset = params.length * 32;
    var offsetParams = params.map(function (param) {
        if (!param.isDynamic()) {
            return param;
        }
        var offset = totalOffset;
        totalOffset += param.dynamicPartLength();
        return param.withOffset(offset);
    });

    // encode everything!
    return offsetParams.reduce(function (result, param) {
        return result + param.dynamicPart();
    }, offsetParams.reduce(function (result, param) {
        return result + param.staticPart();
    }, ''));
};



module.exports = SolidityParam;



/***/ }),

/***/ "../../node_modules/web3/lib/solidity/real.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeReal is a prootype that represents real type
 * It matches:
 * real
 * real[]
 * real[4]
 * real[][]
 * real[3][]
 * real[][6][], ...
 * real32
 * real64[]
 * real8[4]
 * real256[][]
 * real[3][]
 * real64[][6][], ...
 */
var SolidityTypeReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputReal;
};

SolidityTypeReal.prototype = new SolidityType({});
SolidityTypeReal.prototype.constructor = SolidityTypeReal;

SolidityTypeReal.prototype.isType = function (name) {
    return !!name.match(/real([0-9]*)?(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeReal;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/string.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

var SolidityTypeString = function () {
    this._inputFormatter = f.formatInputString;
    this._outputFormatter = f.formatOutputString;
};

SolidityTypeString.prototype = new SolidityType({});
SolidityTypeString.prototype.constructor = SolidityTypeString;

SolidityTypeString.prototype.isType = function (name) {
    return !!name.match(/^string(\[([0-9]*)\])*$/);
};

SolidityTypeString.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeString;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/type.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityParam = __webpack_require__("../../node_modules/web3/lib/solidity/param.js");

/**
 * SolidityType prototype is used to encode/decode solidity params of certain type
 */
var SolidityType = function (config) {
    this._inputFormatter = config.inputFormatter;
    this._outputFormatter = config.outputFormatter;
};

/**
 * Should be used to determine if this SolidityType do match given name
 *
 * @method isType
 * @param {String} name
 * @return {Bool} true if type match this SolidityType, otherwise false
 */
SolidityType.prototype.isType = function (name) {
    throw "this method should be overrwritten for type " + name;
};

/**
 * Should be used to determine what is the length of static part in given type
 *
 * @method staticPartLength
 * @param {String} name
 * @return {Number} length of static part in bytes
 */
SolidityType.prototype.staticPartLength = function (name) {
    // If name isn't an array then treat it like a single element array.
    return (this.nestedTypes(name) || ['[1]'])
        .map(function (type) {
            // the length of the nested array
            return parseInt(type.slice(1, -1), 10) || 1;
        })
        .reduce(function (previous, current) {
            return previous * current;
        // all basic types are 32 bytes long
        }, 32);
};

/**
 * Should be used to determine if type is dynamic array
 * eg:
 * "type[]" => true
 * "type[4]" => false
 *
 * @method isDynamicArray
 * @param {String} name
 * @return {Bool} true if the type is dynamic array
 */
SolidityType.prototype.isDynamicArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should be used to determine if type is static array
 * eg:
 * "type[]" => false
 * "type[4]" => true
 *
 * @method isStaticArray
 * @param {String} name
 * @return {Bool} true if the type is static array
 */
SolidityType.prototype.isStaticArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should return length of static array
 * eg.
 * "int[32]" => 32
 * "int256[14]" => 14
 * "int[2][3]" => 3
 * "int" => 1
 * "int[1]" => 1
 * "int[]" => 1
 *
 * @method staticArrayLength
 * @param {String} name
 * @return {Number} static array length
 */
SolidityType.prototype.staticArrayLength = function (name) {
    var nestedTypes = this.nestedTypes(name);
    if (nestedTypes) {
       return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);
    }
    return 1;
};

/**
 * Should return nested type
 * eg.
 * "int[32]" => "int"
 * "int256[14]" => "int256"
 * "int[2][3]" => "int[2]"
 * "int" => "int"
 * "int[]" => "int"
 *
 * @method nestedName
 * @param {String} name
 * @return {String} nested name
 */
SolidityType.prototype.nestedName = function (name) {
    // remove last [] in name
    var nestedTypes = this.nestedTypes(name);
    if (!nestedTypes) {
        return name;
    }

    return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);
};

/**
 * Should return true if type has dynamic size by default
 * such types are "string", "bytes"
 *
 * @method isDynamicType
 * @param {String} name
 * @return {Bool} true if is dynamic, otherwise false
 */
SolidityType.prototype.isDynamicType = function () {
    return false;
};

/**
 * Should return array of nested types
 * eg.
 * "int[2][3][]" => ["[2]", "[3]", "[]"]
 * "int[] => ["[]"]
 * "int" => null
 *
 * @method nestedTypes
 * @param {String} name
 * @return {Array} array of nested types
 */
SolidityType.prototype.nestedTypes = function (name) {
    // return list of strings eg. "[]", "[3]", "[]", "[2]"
    return name.match(/(\[[0-9]*\])/g);
};

/**
 * Should be used to encode the value
 *
 * @method encode
 * @param {Object} value
 * @param {String} name
 * @return {String} encoded value
 */
SolidityType.prototype.encode = function (value, name) {
    var self = this;
    if (this.isDynamicArray(name)) {

        return (function () {
            var length = value.length;                          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            result.push(f.formatInputInt(length).encode());

            value.forEach(function (v) {
                result.push(self.encode(v, nestedName));
            });

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            for (var i = 0; i < length; i++) {
                result.push(self.encode(value[i], nestedName));
            }

            return result;
        })();

    }

    return this._inputFormatter(value, name).encode();
};

/**
 * Should be used to decode value from bytes
 *
 * @method decode
 * @param {String} bytes
 * @param {Number} offset in bytes
 * @param {String} name type name
 * @returns {Object} decoded value
 */
SolidityType.prototype.decode = function (bytes, offset, name) {
    var self = this;

    if (this.isDynamicArray(name)) {

        return (function () {
            var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes
            var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int
            var arrayStart = arrayOffset + 32; // array starts after length; // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);                      // in int
            var arrayStart = offset;                                        // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();
    } else if (this.isDynamicType(name)) {

        return (function () {
            var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes
            var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes
            var roundedLength = Math.floor((length + 31) / 32);                     // in int
            var param = new SolidityParam(bytes.substr(dynamicOffset * 2, ( 1 + roundedLength) * 64), 0);
            return self._outputFormatter(param, name);
        })();
    }

    var length = this.staticPartLength(name);
    var param = new SolidityParam(bytes.substr(offset * 2, length * 2));
    return this._outputFormatter(param, name);
};

module.exports = SolidityType;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/uint.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeUInt is a prootype that represents uint type
 * It matches:
 * uint
 * uint[]
 * uint[4]
 * uint[][]
 * uint[3][]
 * uint[][6][], ...
 * uint32
 * uint64[]
 * uint8[4]
 * uint256[][]
 * uint[3][]
 * uint64[][6][], ...
 */
var SolidityTypeUInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputUInt;
};

SolidityTypeUInt.prototype = new SolidityType({});
SolidityTypeUInt.prototype.constructor = SolidityTypeUInt;

SolidityTypeUInt.prototype.isType = function (name) {
    return !!name.match(/^uint([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUInt;


/***/ }),

/***/ "../../node_modules/web3/lib/solidity/ureal.js":
/***/ (function(module, exports, __webpack_require__) {

var f = __webpack_require__("../../node_modules/web3/lib/solidity/formatters.js");
var SolidityType = __webpack_require__("../../node_modules/web3/lib/solidity/type.js");

/**
 * SolidityTypeUReal is a prootype that represents ureal type
 * It matches:
 * ureal
 * ureal[]
 * ureal[4]
 * ureal[][]
 * ureal[3][]
 * ureal[][6][], ...
 * ureal32
 * ureal64[]
 * ureal8[4]
 * ureal256[][]
 * ureal[3][]
 * ureal64[][6][], ...
 */
var SolidityTypeUReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputUReal;
};

SolidityTypeUReal.prototype = new SolidityType({});
SolidityTypeUReal.prototype.constructor = SolidityTypeUReal;

SolidityTypeUReal.prototype.isType = function (name) {
    return !!name.match(/^ureal([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUReal;


/***/ }),

/***/ "../../node_modules/web3/lib/utils/browser-xhr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// go env doesn't have and need XMLHttpRequest
if (typeof XMLHttpRequest === 'undefined') {
    exports.XMLHttpRequest = {};
} else {
    exports.XMLHttpRequest = XMLHttpRequest; // jshint ignore:line
}



/***/ }),

/***/ "../../node_modules/web3/lib/utils/config.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file config.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 * 
 * @module utils
 */

/**
 * Utility functions
 * 
 * @class [utils] config
 * @constructor
 */


/// required to define ETH_BIGNUMBER_ROUNDING_MODE
var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");

var ETH_UNITS = [
    'wei',
    'kwei',
    'Mwei',
    'Gwei',
    'szabo',
    'finney',
    'femtoether',
    'picoether',
    'nanoether',
    'microether',
    'milliether',
    'nano',
    'micro',
    'milli',
    'ether',
    'grand',
    'Mether',
    'Gether',
    'Tether',
    'Pether',
    'Eether',
    'Zether',
    'Yether',
    'Nether',
    'Dether',
    'Vether',
    'Uether'
];

module.exports = {
    ETH_PADDING: 32,
    ETH_SIGNATURE_LENGTH: 4,
    ETH_UNITS: ETH_UNITS,
    ETH_BIGNUMBER_ROUNDING_MODE: { ROUNDING_MODE: BigNumber.ROUND_DOWN },
    ETH_POLLING_TIMEOUT: 1000/2,
    defaultBlock: 'latest',
    defaultAccount: undefined
};



/***/ }),

/***/ "../../node_modules/web3/lib/utils/sha3.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file sha3.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var CryptoJS = __webpack_require__("../../node_modules/crypto-js/index.js");
var sha3 = __webpack_require__("../../node_modules/crypto-js/sha3.js");

module.exports = function (value, options) {
    if (options && options.encoding === 'hex') {
        if (value.length > 2 && value.substr(0, 2) === '0x') {
            value = value.substr(2);
        }
        value = CryptoJS.enc.Hex.parse(value);
    }

    return sha3(value, {
        outputLength: 256
    }).toString();
};



/***/ }),

/***/ "../../node_modules/web3/lib/utils/utils.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file utils.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 *
 * @module utils
 */

/**
 * Utility functions
 *
 * @class [utils] utils
 * @constructor
 */


var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var utf8 = __webpack_require__("../../node_modules/utf8/utf8.js");

var unitMap = {
    'noether':      '0',
    'wei':          '1',
    'kwei':         '1000',
    'Kwei':         '1000',
    'babbage':      '1000',
    'femtoether':   '1000',
    'mwei':         '1000000',
    'Mwei':         '1000000',
    'lovelace':     '1000000',
    'picoether':    '1000000',
    'gwei':         '1000000000',
    'Gwei':         '1000000000',
    'shannon':      '1000000000',
    'nanoether':    '1000000000',
    'nano':         '1000000000',
    'szabo':        '1000000000000',
    'microether':   '1000000000000',
    'micro':        '1000000000000',
    'finney':       '1000000000000000',
    'milliether':    '1000000000000000',
    'milli':         '1000000000000000',
    'ether':        '1000000000000000000',
    'kether':       '1000000000000000000000',
    'grand':        '1000000000000000000000',
    'mether':       '1000000000000000000000000',
    'gether':       '1000000000000000000000000000',
    'tether':       '1000000000000000000000000000000'
};

/**
 * Should be called to pad string to expected length
 *
 * @method padLeft
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padLeft = function (string, chars, sign) {
    return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
};

/**
 * Should be called to pad string to expected length
 *
 * @method padRight
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padRight = function (string, chars, sign) {
    return string + (new Array(chars - string.length + 1).join(sign ? sign : "0"));
};

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toUtf8 = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        if (code === 0)
            break;
        str += String.fromCharCode(code);
    }

    return utf8.decode(str);
};

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toAscii = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
    }

    return str;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromUtf8 = function(str) {
    str = utf8.encode(str);
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (code === 0)
            break;
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return "0x" + hex;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromAscii = function(str) {
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return "0x" + hex;
};

/**
 * Should be used to create full function/event name from json abi
 *
 * @method transformToFullName
 * @param {Object} json-abi
 * @return {String} full fnction/event name
 */
var transformToFullName = function (json) {
    if (json.name.indexOf('(') !== -1) {
        return json.name;
    }

    var typeName = json.inputs.map(function(i){return i.type; }).join();
    return json.name + '(' + typeName + ')';
};

/**
 * Should be called to get display name of contract function
 *
 * @method extractDisplayName
 * @param {String} name of function/event
 * @returns {String} display name for function/event eg. multiply(uint256) -> multiply
 */
var extractDisplayName = function (name) {
    var length = name.indexOf('(');
    return length !== -1 ? name.substr(0, length) : name;
};

/// @returns overloaded part of function/event name
var extractTypeName = function (name) {
    /// TODO: make it invulnerable
    var length = name.indexOf('(');
    return length !== -1 ? name.substr(length + 1, name.length - 1 - (length + 1)).replace(' ', '') : "";
};

/**
 * Converts value to it's decimal representation in string
 *
 * @method toDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var toDecimal = function (value) {
    return toBigNumber(value).toNumber();
};

/**
 * Converts value to it's hex representation
 *
 * @method fromDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var fromDecimal = function (value) {
    var number = toBigNumber(value);
    var result = number.toString(16);

    return number.lessThan(0) ? '-0x' + result.substr(1) : '0x' + result;
};

/**
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 *
 * @method toHex
 * @param {String|Number|BigNumber|Object}
 * @return {String}
 */
var toHex = function (val) {
    /*jshint maxcomplexity: 8 */

    if (isBoolean(val))
        return fromDecimal(+val);

    if (isBigNumber(val))
        return fromDecimal(val);

    if (typeof val === 'object')
        return fromUtf8(JSON.stringify(val));

    // if its a negative number, pass it through fromDecimal
    if (isString(val)) {
        if (val.indexOf('-0x') === 0)
            return fromDecimal(val);
        else if(val.indexOf('0x') === 0)
            return val;
        else if (!isFinite(val))
            return fromAscii(val);
    }

    return fromDecimal(val);
};

/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
var getValueOfUnit = function (unit) {
    unit = unit ? unit.toLowerCase() : 'ether';
    var unitValue = unitMap[unit];
    if (unitValue === undefined) {
        throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
    }
    return new BigNumber(unitValue, 10);
};

/**
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method fromWei
 * @param {Number|String} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert to, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var fromWei = function(number, unit) {
    var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method toWei
 * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert from, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var toWei = function(number, unit) {
    var returnValue = toBigNumber(number).times(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes an input and transforms it into an bignumber
 *
 * @method toBigNumber
 * @param {Number|String|BigNumber} a number, string, HEX string or BigNumber
 * @return {BigNumber} BigNumber
*/
var toBigNumber = function(number) {
    /*jshint maxcomplexity:5 */
    number = number || 0;
    if (isBigNumber(number))
        return number;

    if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {
        return new BigNumber(number.replace('0x',''), 16);
    }

    return new BigNumber(number.toString(10), 10);
};

/**
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 *
 * @method toTwosComplement
 * @param {Number|String|BigNumber}
 * @return {BigNumber}
 */
var toTwosComplement = function (number) {
    var bigNumber = toBigNumber(number).round();
    if (bigNumber.lessThan(0)) {
        return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
    }
    return bigNumber;
};

/**
 * Checks if the given string is strictly an address
 *
 * @method isStrictAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isStrictAddress = function (address) {
    return /^0x[0-9a-f]{40}$/i.test(address);
};

/**
 * Checks if the given string is an address
 *
 * @method isAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isAddress = function (address) {
    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        // check if it has the basic requirements of an address
        return false;
    } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        // If it's all small caps or all all caps, return true
        return true;
    } else {
        // Otherwise check each case
        return isChecksumAddress(address);
    }
};

/**
 * Checks if the given string is a checksummed address
 *
 * @method isChecksumAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isChecksumAddress = function (address) {
    // Check each case
    address = address.replace('0x','');
    var addressHash = sha3(address.toLowerCase());

    for (var i = 0; i < 40; i++ ) {
        // the nth letter should be uppercase if the nth digit of casemap is 1
        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
            return false;
        }
    }
    return true;
};



/**
 * Makes a checksum address
 *
 * @method toChecksumAddress
 * @param {String} address the given HEX adress
 * @return {String}
*/
var toChecksumAddress = function (address) {
    if (typeof address === 'undefined') return '';

    address = address.toLowerCase().replace('0x','');
    var addressHash = sha3(address);
    var checksumAddress = '0x';

    for (var i = 0; i < address.length; i++ ) {
        // If ith character is 9 to f then make it uppercase
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
};

/**
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 *
 * @method toAddress
 * @param {String} address
 * @return {String} formatted address
 */
var toAddress = function (address) {
    if (isStrictAddress(address)) {
        return address;
    }

    if (/^[0-9a-f]{40}$/.test(address)) {
        return '0x' + address;
    }

    return '0x' + padLeft(toHex(address).substr(2), 40);
};

/**
 * Returns true if object is BigNumber, otherwise false
 *
 * @method isBigNumber
 * @param {Object}
 * @return {Boolean}
 */
var isBigNumber = function (object) {
    return object instanceof BigNumber ||
        (object && object.constructor && object.constructor.name === 'BigNumber');
};

/**
 * Returns true if object is string, otherwise false
 *
 * @method isString
 * @param {Object}
 * @return {Boolean}
 */
var isString = function (object) {
    return typeof object === 'string' ||
        (object && object.constructor && object.constructor.name === 'String');
};

/**
 * Returns true if object is function, otherwise false
 *
 * @method isFunction
 * @param {Object}
 * @return {Boolean}
 */
var isFunction = function (object) {
    return typeof object === 'function';
};

/**
 * Returns true if object is Objet, otherwise false
 *
 * @method isObject
 * @param {Object}
 * @return {Boolean}
 */
var isObject = function (object) {
    return object !== null && !(object instanceof Array) && typeof object === 'object';
};

/**
 * Returns true if object is boolean, otherwise false
 *
 * @method isBoolean
 * @param {Object}
 * @return {Boolean}
 */
var isBoolean = function (object) {
    return typeof object === 'boolean';
};

/**
 * Returns true if object is array, otherwise false
 *
 * @method isArray
 * @param {Object}
 * @return {Boolean}
 */
var isArray = function (object) {
    return object instanceof Array;
};

/**
 * Returns true if given string is valid json object
 *
 * @method isJson
 * @param {String}
 * @return {Boolean}
 */
var isJson = function (str) {
    try {
        return !!JSON.parse(str);
    } catch (e) {
        return false;
    }
};

/**
 * Returns true if given string is a valid Ethereum block header bloom.
 *
 * @method isBloom
 * @param {String} hex encoded bloom filter
 * @return {Boolean}
 */
var isBloom = function (bloom) {
    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
    }
    return false;
};

/**
 * Returns true if given string is a valid log topic.
 *
 * @method isTopic
 * @param {String} hex encoded topic
 * @return {Boolean}
 */
var isTopic = function (topic) {
    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
    }
    return false;
};

module.exports = {
    padLeft: padLeft,
    padRight: padRight,
    toHex: toHex,
    toDecimal: toDecimal,
    fromDecimal: fromDecimal,
    toUtf8: toUtf8,
    toAscii: toAscii,
    fromUtf8: fromUtf8,
    fromAscii: fromAscii,
    transformToFullName: transformToFullName,
    extractDisplayName: extractDisplayName,
    extractTypeName: extractTypeName,
    toWei: toWei,
    fromWei: fromWei,
    toBigNumber: toBigNumber,
    toTwosComplement: toTwosComplement,
    toAddress: toAddress,
    isBigNumber: isBigNumber,
    isStrictAddress: isStrictAddress,
    isAddress: isAddress,
    isChecksumAddress: isChecksumAddress,
    toChecksumAddress: toChecksumAddress,
    isFunction: isFunction,
    isString: isString,
    isObject: isObject,
    isBoolean: isBoolean,
    isArray: isArray,
    isJson: isJson,
    isBloom: isBloom,
    isTopic: isTopic,
};


/***/ }),

/***/ "../../node_modules/web3/lib/version.json":
/***/ (function(module, exports) {

module.exports = {"version":"0.20.1"}

/***/ }),

/***/ "../../node_modules/web3/lib/web3.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file web3.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var RequestManager = __webpack_require__("../../node_modules/web3/lib/web3/requestmanager.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var Eth = __webpack_require__("../../node_modules/web3/lib/web3/methods/eth.js");
var DB = __webpack_require__("../../node_modules/web3/lib/web3/methods/db.js");
var Shh = __webpack_require__("../../node_modules/web3/lib/web3/methods/shh.js");
var Net = __webpack_require__("../../node_modules/web3/lib/web3/methods/net.js");
var Personal = __webpack_require__("../../node_modules/web3/lib/web3/methods/personal.js");
var Swarm = __webpack_require__("../../node_modules/web3/lib/web3/methods/swarm.js");
var Settings = __webpack_require__("../../node_modules/web3/lib/web3/settings.js");
var version = __webpack_require__("../../node_modules/web3/lib/version.json");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var extend = __webpack_require__("../../node_modules/web3/lib/web3/extend.js");
var Batch = __webpack_require__("../../node_modules/web3/lib/web3/batch.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var HttpProvider = __webpack_require__("../../node_modules/web3/lib/web3/httpprovider.js");
var IpcProvider = __webpack_require__("../../node_modules/web3/lib/web3/ipcprovider.js");
var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");



function Web3 (provider) {
    this._requestManager = new RequestManager(provider);
    this.currentProvider = provider;
    this.eth = new Eth(this);
    this.db = new DB(this);
    this.shh = new Shh(this);
    this.net = new Net(this);
    this.personal = new Personal(this);
    this.bzz = new Swarm(this);
    this.settings = new Settings();
    this.version = {
        api: version.version
    };
    this.providers = {
        HttpProvider: HttpProvider,
        IpcProvider: IpcProvider
    };
    this._extend = extend(this);
    this._extend({
        properties: properties()
    });
}

// expose providers on the class
Web3.providers = {
    HttpProvider: HttpProvider,
    IpcProvider: IpcProvider
};

Web3.prototype.setProvider = function (provider) {
    this._requestManager.setProvider(provider);
    this.currentProvider = provider;
};

Web3.prototype.reset = function (keepIsSyncing) {
    this._requestManager.reset(keepIsSyncing);
    this.settings = new Settings();
};

Web3.prototype.BigNumber = BigNumber;
Web3.prototype.toHex = utils.toHex;
Web3.prototype.toAscii = utils.toAscii;
Web3.prototype.toUtf8 = utils.toUtf8;
Web3.prototype.fromAscii = utils.fromAscii;
Web3.prototype.fromUtf8 = utils.fromUtf8;
Web3.prototype.toDecimal = utils.toDecimal;
Web3.prototype.fromDecimal = utils.fromDecimal;
Web3.prototype.toBigNumber = utils.toBigNumber;
Web3.prototype.toWei = utils.toWei;
Web3.prototype.fromWei = utils.fromWei;
Web3.prototype.isAddress = utils.isAddress;
Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
Web3.prototype.isIBAN = utils.isIBAN;
Web3.prototype.padLeft = utils.padLeft;
Web3.prototype.padRight = utils.padRight;


Web3.prototype.sha3 = function(string, options) {
    return '0x' + sha3(string, options);
};

/**
 * Transforms direct icap to address
 */
Web3.prototype.fromICAP = function (icap) {
    var iban = new Iban(icap);
    return iban.address();
};

var properties = function () {
    return [
        new Property({
            name: 'version.node',
            getter: 'web3_clientVersion'
        }),
        new Property({
            name: 'version.network',
            getter: 'net_version',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.ethereum',
            getter: 'eth_protocolVersion',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.whisper',
            getter: 'shh_version',
            inputFormatter: utils.toDecimal
        })
    ];
};

Web3.prototype.isConnected = function(){
    return (this.currentProvider && this.currentProvider.isConnected());
};

Web3.prototype.createBatch = function () {
    return new Batch(this);
};

module.exports = Web3;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/allevents.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file allevents.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var SolidityEvent = __webpack_require__("../../node_modules/web3/lib/web3/event.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

var AllSolidityEvents = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._json = json;
    this._address = address;
};

AllSolidityEvents.prototype.encode = function (options) {
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.address = this._address;

    return result;
};

AllSolidityEvents.prototype.decode = function (data) {
    data.data = data.data || '';
    data.topics = data.topics || [];

    var eventTopic = data.topics[0].slice(2);
    var match = this._json.filter(function (j) {
        return eventTopic === sha3(utils.transformToFullName(j));
    })[0];

    if (!match) { // cannot find matching event?
        console.warn('cannot find event for log');
        return data;
    }

    var event = new SolidityEvent(this._requestManager, match, this._address);
    return event.decode(data);
};

AllSolidityEvents.prototype.execute = function (options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 1)
            options = null;
    }

    var o = this.encode(options);
    var formatter = this.decode.bind(this);
    return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
};

AllSolidityEvents.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    contract.allEvents = execute;
};

module.exports = AllSolidityEvents;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/batch.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file batch.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Jsonrpc = __webpack_require__("../../node_modules/web3/lib/web3/jsonrpc.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

var Batch = function (web3) {
    this.requestManager = web3._requestManager;
    this.requests = [];
};

/**
 * Should be called to add create new request to batch request
 *
 * @method add
 * @param {Object} jsonrpc requet object
 */
Batch.prototype.add = function (request) {
    this.requests.push(request);
};

/**
 * Should be called to execute batch request
 *
 * @method execute
 */
Batch.prototype.execute = function () {
    var requests = this.requests;
    this.requestManager.sendBatch(requests, function (err, results) {
        results = results || [];
        requests.map(function (request, index) {
            return results[index] || {};
        }).forEach(function (result, index) {
            if (requests[index].callback) {

                if (!Jsonrpc.isValidResponse(result)) {
                    return requests[index].callback(errors.InvalidResponse(result));
                }

                requests[index].callback(null, (requests[index].format ? requests[index].format(result.result) : result.result));
            }
        });
    }); 
};

module.exports = Batch;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/contract.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file contract.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var SolidityEvent = __webpack_require__("../../node_modules/web3/lib/web3/event.js");
var SolidityFunction = __webpack_require__("../../node_modules/web3/lib/web3/function.js");
var AllEvents = __webpack_require__("../../node_modules/web3/lib/web3/allevents.js");

/**
 * Should be called to encode constructor params
 *
 * @method encodeConstructorParams
 * @param {Array} abi
 * @param {Array} constructor params
 */
var encodeConstructorParams = function (abi, params) {
    return abi.filter(function (json) {
        return json.type === 'constructor' && json.inputs.length === params.length;
    }).map(function (json) {
        return json.inputs.map(function (input) {
            return input.type;
        });
    }).map(function (types) {
        return coder.encodeParams(types, params);
    })[0] || '';
};

/**
 * Should be called to add functions to contract object
 *
 * @method addFunctionsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addFunctionsToContract = function (contract) {
    contract.abi.filter(function (json) {
        return json.type === 'function';
    }).map(function (json) {
        return new SolidityFunction(contract._eth, json, contract.address);
    }).forEach(function (f) {
        f.attachToContract(contract);
    });
};

/**
 * Should be called to add events to contract object
 *
 * @method addEventsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addEventsToContract = function (contract) {
    var events = contract.abi.filter(function (json) {
        return json.type === 'event';
    });

    var All = new AllEvents(contract._eth._requestManager, events, contract.address);
    All.attachToContract(contract);

    events.map(function (json) {
        return new SolidityEvent(contract._eth._requestManager, json, contract.address);
    }).forEach(function (e) {
        e.attachToContract(contract);
    });
};


/**
 * Should be called to check if the contract gets properly deployed on the blockchain.
 *
 * @method checkForContractAddress
 * @param {Object} contract
 * @param {Function} callback
 * @returns {Undefined}
 */
var checkForContractAddress = function(contract, callback){
    var count = 0,
        callbackFired = false;

    // wait for receipt
    var filter = contract._eth.filter('latest', function(e){
        if (!e && !callbackFired) {
            count++;

            // stop watching after 50 blocks (timeout)
            if (count > 50) {

                filter.stopWatching(function() {});
                callbackFired = true;

                if (callback)
                    callback(new Error('Contract transaction couldn\'t be found after 50 blocks'));
                else
                    throw new Error('Contract transaction couldn\'t be found after 50 blocks');


            } else {

                contract._eth.getTransactionReceipt(contract.transactionHash, function(e, receipt){
                    if(receipt && !callbackFired) {

                        contract._eth.getCode(receipt.contractAddress, function(e, code){
                            /*jshint maxcomplexity: 6 */

                            if(callbackFired || !code)
                                return;

                            filter.stopWatching(function() {});
                            callbackFired = true;

                            if(code.length > 3) {

                                // console.log('Contract code deployed!');

                                contract.address = receipt.contractAddress;

                                // attach events and methods again after we have
                                addFunctionsToContract(contract);
                                addEventsToContract(contract);

                                // call callback for the second time
                                if(callback)
                                    callback(null, contract);

                            } else {
                                if(callback)
                                    callback(new Error('The contract code couldn\'t be stored, please check your gas amount.'));
                                else
                                    throw new Error('The contract code couldn\'t be stored, please check your gas amount.');
                            }
                        });
                    }
                });
            }
        }
    });
};

/**
 * Should be called to create new ContractFactory instance
 *
 * @method ContractFactory
 * @param {Array} abi
 */
var ContractFactory = function (eth, abi) {
    this.eth = eth;
    this.abi = abi;

    /**
     * Should be called to create new contract on a blockchain
     *
     * @method new
     * @param {Any} contract constructor param1 (optional)
     * @param {Any} contract constructor param2 (optional)
     * @param {Object} contract transaction object (required)
     * @param {Function} callback
     * @returns {Contract} returns contract instance
     */
    this.new = function () {
        /*jshint maxcomplexity: 7 */
        
        var contract = new Contract(this.eth, this.abi);

        // parse arguments
        var options = {}; // required!
        var callback;

        var args = Array.prototype.slice.call(arguments);
        if (utils.isFunction(args[args.length - 1])) {
            callback = args.pop();
        }

        var last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
            options = args.pop();
        }

        if (options.value > 0) {
            var constructorAbi = abi.filter(function (json) {
                return json.type === 'constructor' && json.inputs.length === args.length;
            })[0] || {};

            if (!constructorAbi.payable) {
                throw new Error('Cannot send value to non-payable constructor');
            }
        }

        var bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;

        if (callback) {

            // wait for the contract address adn check if the code was deployed
            this.eth.sendTransaction(options, function (err, hash) {
                if (err) {
                    callback(err);
                } else {
                    // add the transaction hash
                    contract.transactionHash = hash;

                    // call callback for the first time
                    callback(null, contract);

                    checkForContractAddress(contract, callback);
                }
            });
        } else {
            var hash = this.eth.sendTransaction(options);
            // add the transaction hash
            contract.transactionHash = hash;
            checkForContractAddress(contract);
        }

        return contract;
    };

    this.new.getData = this.getData.bind(this);
};

/**
 * Should be called to create new ContractFactory
 *
 * @method contract
 * @param {Array} abi
 * @returns {ContractFactory} new contract factory
 */
//var contract = function (abi) {
    //return new ContractFactory(abi);
//};



/**
 * Should be called to get access to existing contract on a blockchain
 *
 * @method at
 * @param {Address} contract address (required)
 * @param {Function} callback {optional)
 * @returns {Contract} returns contract if no callback was passed,
 * otherwise calls callback function (err, contract)
 */
ContractFactory.prototype.at = function (address, callback) {
    var contract = new Contract(this.eth, this.abi, address);

    // this functions are not part of prototype,
    // because we dont want to spoil the interface
    addFunctionsToContract(contract);
    addEventsToContract(contract);

    if (callback) {
        callback(null, contract);
    }
    return contract;
};

/**
 * Gets the data, which is data to deploy plus constructor params
 *
 * @method getData
 */
ContractFactory.prototype.getData = function () {
    var options = {}; // required!
    var args = Array.prototype.slice.call(arguments);

    var last = args[args.length - 1];
    if (utils.isObject(last) && !utils.isArray(last)) {
        options = args.pop();
    }

    var bytes = encodeConstructorParams(this.abi, args);
    options.data += bytes;

    return options.data;
};

/**
 * Should be called to create new contract instance
 *
 * @method Contract
 * @param {Array} abi
 * @param {Address} contract address
 */
var Contract = function (eth, abi, address) {
    this._eth = eth;
    this.transactionHash = null;
    this.address = address;
    this.abi = abi;
};

module.exports = ContractFactory;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/errors.js":
/***/ (function(module, exports) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file errors.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

module.exports = {
    InvalidNumberOfSolidityArgs: function () {
        return new Error('Invalid number of arguments to Solidity function');
    },
    InvalidNumberOfRPCParams: function () {
        return new Error('Invalid number of input parameters to RPC method');
    },
    InvalidConnection: function (host){
        return new Error('CONNECTION ERROR: Couldn\'t connect to node '+ host +'.');
    },
    InvalidProvider: function () {
        return new Error('Provider not set or invalid');
    },
    InvalidResponse: function (result){
        var message = !!result && !!result.error && !!result.error.message ? result.error.message : 'Invalid JSON RPC response: ' + JSON.stringify(result);
        return new Error(message);
    },
    ConnectionTimeout: function (ms){
        return new Error('CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');
    }
};


/***/ }),

/***/ "../../node_modules/web3/lib/web3/event.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file event.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

/**
 * This prototype should be used to create event filters
 */
var SolidityEvent = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._params = json.inputs;
    this._name = utils.transformToFullName(json);
    this._address = address;
    this._anonymous = json.anonymous;
};

/**
 * Should be used to get filtered param types
 *
 * @method types
 * @param {Bool} decide if returned typed should be indexed
 * @return {Array} array of types
 */
SolidityEvent.prototype.types = function (indexed) {
    return this._params.filter(function (i) {
        return i.indexed === indexed;
    }).map(function (i) {
        return i.type;
    });
};

/**
 * Should be used to get event display name
 *
 * @method displayName
 * @return {String} event display name
 */
SolidityEvent.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get event type name
 *
 * @method typeName
 * @return {String} event type name
 */
SolidityEvent.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be used to get event signature
 *
 * @method signature
 * @return {String} event signature
 */
SolidityEvent.prototype.signature = function () {
    return sha3(this._name);
};

/**
 * Should be used to encode indexed params and options to one final object
 *
 * @method encode
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} everything combined together and encoded
 */
SolidityEvent.prototype.encode = function (indexed, options) {
    indexed = indexed || {};
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.topics = [];

    result.address = this._address;
    if (!this._anonymous) {
        result.topics.push('0x' + this.signature());
    }

    var indexedTopics = this._params.filter(function (i) {
        return i.indexed === true;
    }).map(function (i) {
        var value = indexed[i.name];
        if (value === undefined || value === null) {
            return null;
        }

        if (utils.isArray(value)) {
            return value.map(function (v) {
                return '0x' + coder.encodeParam(i.type, v);
            });
        }
        return '0x' + coder.encodeParam(i.type, value);
    });

    result.topics = result.topics.concat(indexedTopics);

    return result;
};

/**
 * Should be used to decode indexed params and options
 *
 * @method decode
 * @param {Object} data
 * @return {Object} result object with decoded indexed && not indexed params
 */
SolidityEvent.prototype.decode = function (data) {

    data.data = data.data || '';
    data.topics = data.topics || [];

    var argTopics = this._anonymous ? data.topics : data.topics.slice(1);
    var indexedData = argTopics.map(function (topics) { return topics.slice(2); }).join("");
    var indexedParams = coder.decodeParams(this.types(true), indexedData);

    var notIndexedData = data.data.slice(2);
    var notIndexedParams = coder.decodeParams(this.types(false), notIndexedData);

    var result = formatters.outputLogFormatter(data);
    result.event = this.displayName();
    result.address = data.address;

    result.args = this._params.reduce(function (acc, current) {
        acc[current.name] = current.indexed ? indexedParams.shift() : notIndexedParams.shift();
        return acc;
    }, {});

    delete result.data;
    delete result.topics;

    return result;
};

/**
 * Should be used to create new filter object from event
 *
 * @method execute
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} filter object
 */
SolidityEvent.prototype.execute = function (indexed, options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 2)
            options = null;
        if(arguments.length === 1) {
            options = null;
            indexed = {};
        }
    }

    var o = this.encode(indexed, options);
    var formatter = this.decode.bind(this);
    return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
};

/**
 * Should be used to attach event to contract object
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityEvent.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = this.execute.bind(this, contract);
};

module.exports = SolidityEvent;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/extend.js":
/***/ (function(module, exports, __webpack_require__) {

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

// TODO: refactor, so the input params are not altered.
// it's necessary to make same 'extension' work with multiple providers
var extend = function (web3) {
    /* jshint maxcomplexity:5 */
    var ex = function (extension) {

        var extendedObject;
        if (extension.property) {
            if (!web3[extension.property]) {
                web3[extension.property] = {};
            }
            extendedObject = web3[extension.property];
        } else {
            extendedObject = web3;
        }

        if (extension.methods) {
            extension.methods.forEach(function (method) {
                method.attachToObject(extendedObject);
                method.setRequestManager(web3._requestManager);
            });
        }

        if (extension.properties) {
            extension.properties.forEach(function (property) {
                property.attachToObject(extendedObject);
                property.setRequestManager(web3._requestManager);
            });
        }
    };

    ex.formatters = formatters; 
    ex.utils = utils;
    ex.Method = Method;
    ex.Property = Property;

    return ex;
};



module.exports = extend;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/filter.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file filter.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

/**
* Converts a given topic to a hex string, but also allows null values.
*
* @param {Mixed} value
* @return {String}
*/
var toTopic = function(value){

    if(value === null || typeof value === 'undefined')
        return null;

    value = String(value);

    if(value.indexOf('0x') === 0)
        return value;
    else
        return utils.fromUtf8(value);
};

/// This method should be called on options object, to verify deprecated properties && lazy load dynamic ones
/// @param should be string or object
/// @returns options string or object
var getOptions = function (options, type) {
    /*jshint maxcomplexity: 6 */

    if (utils.isString(options)) {
        return options;
    }

    options = options || {};


    switch(type) {
        case 'eth':

            // make sure topics, get converted to hex
            options.topics = options.topics || [];
            options.topics = options.topics.map(function(topic){
                return (utils.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);
            });

            return {
                topics: options.topics,
                from: options.from,
                to: options.to,
                address: options.address,
                fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),
                toBlock: formatters.inputBlockNumberFormatter(options.toBlock)
            };
        case 'shh':
            return options;
    }
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method getLogsAtStart
@param {Object} self
@param {function} callback
*/
var getLogsAtStart = function(self, callback){
    // call getFilterLogs for the first watch callback start
    if (!utils.isString(self.options)) {
        self.get(function (err, messages) {
            // don't send all the responses to all the watches again... just to self one
            if (err) {
                callback(err);
            }

            if(utils.isArray(messages)) {
                messages.forEach(function (message) {
                    callback(null, message);
                });
            }
        });
    }
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollFilter
@param {Object} self
*/
var pollFilter = function(self) {

    var onMessage = function (error, messages) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isArray(messages)) {
            messages.forEach(function (message) {
                message = self.formatter ? self.formatter(message) : message;
                self.callbacks.forEach(function (callback) {
                    callback(null, message);
                });
            });
        }
    };

    self.requestManager.startPolling({
        method: self.implementation.poll.call,
        params: [self.filterId],
    }, self.filterId, onMessage, self.stopWatching.bind(self));

};

var Filter = function (options, type, requestManager, methods, formatter, callback, filterCreationErrorCallback) {
    var self = this;
    var implementation = {};
    methods.forEach(function (method) {
        method.setRequestManager(requestManager);
        method.attachToObject(implementation);
    });
    this.requestManager = requestManager;
    this.options = getOptions(options, type);
    this.implementation = implementation;
    this.filterId = null;
    this.callbacks = [];
    this.getLogsCallbacks = [];
    this.pollFilters = [];
    this.formatter = formatter;
    this.implementation.newFilter(this.options, function(error, id){
        if(error) {
            self.callbacks.forEach(function(cb){
                cb(error);
            });
            if (typeof filterCreationErrorCallback === 'function') {
              filterCreationErrorCallback(error);
            }
        } else {
            self.filterId = id;

            // check if there are get pending callbacks as a consequence
            // of calling get() with filterId unassigned.
            self.getLogsCallbacks.forEach(function (cb){
                self.get(cb);
            });
            self.getLogsCallbacks = [];

            // get filter logs for the already existing watch calls
            self.callbacks.forEach(function(cb){
                getLogsAtStart(self, cb);
            });
            if(self.callbacks.length > 0)
                pollFilter(self);

            // start to watch immediately
            if(typeof callback === 'function') {
                return self.watch(callback);
            }
        }
    });

    return this;
};

Filter.prototype.watch = function (callback) {
    this.callbacks.push(callback);

    if(this.filterId) {
        getLogsAtStart(this, callback);
        pollFilter(this);
    }

    return this;
};

Filter.prototype.stopWatching = function (callback) {
    this.requestManager.stopPolling(this.filterId);
    this.callbacks = [];
    // remove filter async
    if (callback) {
        this.implementation.uninstallFilter(this.filterId, callback);
    } else {
        return this.implementation.uninstallFilter(this.filterId);
    }
};

Filter.prototype.get = function (callback) {
    var self = this;
    if (utils.isFunction(callback)) {
        if (this.filterId === null) {
            // If filterId is not set yet, call it back
            // when newFilter() assigns it.
            this.getLogsCallbacks.push(callback);
        } else {
            this.implementation.getLogs(this.filterId, function(err, res){
                if (err) {
                    callback(err);
                } else {
                    callback(null, res.map(function (log) {
                        return self.formatter ? self.formatter(log) : log;
                    }));
                }
            });
        }
    } else {
        if (this.filterId === null) {
            throw new Error('Filter ID Error: filter().get() can\'t be chained synchronous, please provide a callback for the get() method.');
        }
        var logs = this.implementation.getLogs(this.filterId);
        return logs.map(function (log) {
            return self.formatter ? self.formatter(log) : log;
        });
    }

    return this;
};

module.exports = Filter;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/formatters.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var config = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");

/**
 * Should the format output to a big number
 *
 * @method outputBigNumberFormatter
 * @param {String|Number|BigNumber}
 * @returns {BigNumber} object
 */
var outputBigNumberFormatter = function (number) {
    return utils.toBigNumber(number);
};

var isPredefinedBlockNumber = function (blockNumber) {
    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';
};

var inputDefaultBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return config.defaultBlock;
    }
    return inputBlockNumberFormatter(blockNumber);
};

var inputBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return undefined;
    } else if (isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
    }
    return utils.toHex(blockNumber);
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputCallFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputCallFormatter = function (options){

    options.from = options.from || config.defaultAccount;

    if (options.from) {
        options.from = inputAddressFormatter(options.from);
    }

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputTransactionFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputTransactionFormatter = function (options){

    options.from = options.from || config.defaultAccount;
    options.from = inputAddressFormatter(options.from);

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the output of a transaction to its proper values
 *
 * @method outputTransactionFormatter
 * @param {Object} tx
 * @returns {Object}
*/
var outputTransactionFormatter = function (tx){
    if(tx.blockNumber !== null)
        tx.blockNumber = utils.toDecimal(tx.blockNumber);
    if(tx.transactionIndex !== null)
        tx.transactionIndex = utils.toDecimal(tx.transactionIndex);
    tx.nonce = utils.toDecimal(tx.nonce);
    tx.gas = utils.toDecimal(tx.gas);
    tx.gasPrice = utils.toBigNumber(tx.gasPrice);
    tx.value = utils.toBigNumber(tx.value);
    return tx;
};

/**
 * Formats the output of a transaction receipt to its proper values
 *
 * @method outputTransactionReceiptFormatter
 * @param {Object} receipt
 * @returns {Object}
*/
var outputTransactionReceiptFormatter = function (receipt){
    if(receipt.blockNumber !== null)
        receipt.blockNumber = utils.toDecimal(receipt.blockNumber);
    if(receipt.transactionIndex !== null)
        receipt.transactionIndex = utils.toDecimal(receipt.transactionIndex);
    receipt.cumulativeGasUsed = utils.toDecimal(receipt.cumulativeGasUsed);
    receipt.gasUsed = utils.toDecimal(receipt.gasUsed);

    if(utils.isArray(receipt.logs)) {
        receipt.logs = receipt.logs.map(function(log){
            return outputLogFormatter(log);
        });
    }

    return receipt;
};

/**
 * Formats the output of a block to its proper values
 *
 * @method outputBlockFormatter
 * @param {Object} block
 * @returns {Object}
*/
var outputBlockFormatter = function(block) {

    // transform to number
    block.gasLimit = utils.toDecimal(block.gasLimit);
    block.gasUsed = utils.toDecimal(block.gasUsed);
    block.size = utils.toDecimal(block.size);
    block.timestamp = utils.toDecimal(block.timestamp);
    if(block.number !== null)
        block.number = utils.toDecimal(block.number);

    block.difficulty = utils.toBigNumber(block.difficulty);
    block.totalDifficulty = utils.toBigNumber(block.totalDifficulty);

    if (utils.isArray(block.transactions)) {
        block.transactions.forEach(function(item){
            if(!utils.isString(item))
                return outputTransactionFormatter(item);
        });
    }

    return block;
};

/**
 * Formats the output of a log
 *
 * @method outputLogFormatter
 * @param {Object} log object
 * @returns {Object} log
*/
var outputLogFormatter = function(log) {
    if(log.blockNumber)
        log.blockNumber = utils.toDecimal(log.blockNumber);
    if(log.transactionIndex)
        log.transactionIndex = utils.toDecimal(log.transactionIndex);
    if(log.logIndex)
        log.logIndex = utils.toDecimal(log.logIndex);

    return log;
};

/**
 * Formats the input of a whisper post and converts all values to HEX
 *
 * @method inputPostFormatter
 * @param {Object} transaction object
 * @returns {Object}
*/
var inputPostFormatter = function(post) {

    // post.payload = utils.toHex(post.payload);
    post.ttl = utils.fromDecimal(post.ttl);
    post.workToProve = utils.fromDecimal(post.workToProve);
    post.priority = utils.fromDecimal(post.priority);

    // fallback
    if (!utils.isArray(post.topics)) {
        post.topics = post.topics ? [post.topics] : [];
    }

    // format the following options
    post.topics = post.topics.map(function(topic){
        // convert only if not hex
        return (topic.indexOf('0x') === 0) ? topic : utils.fromUtf8(topic);
    });

    return post;
};

/**
 * Formats the output of a received post message
 *
 * @method outputPostFormatter
 * @param {Object}
 * @returns {Object}
 */
var outputPostFormatter = function(post){

    post.expiry = utils.toDecimal(post.expiry);
    post.sent = utils.toDecimal(post.sent);
    post.ttl = utils.toDecimal(post.ttl);
    post.workProved = utils.toDecimal(post.workProved);
    // post.payloadRaw = post.payload;
    // post.payload = utils.toAscii(post.payload);

    // if (utils.isJson(post.payload)) {
    //     post.payload = JSON.parse(post.payload);
    // }

    // format the following options
    if (!post.topics) {
        post.topics = [];
    }
    post.topics = post.topics.map(function(topic){
        return utils.toAscii(topic);
    });

    return post;
};

var inputAddressFormatter = function (address) {
    var iban = new Iban(address);
    if (iban.isValid() && iban.isDirect()) {
        return '0x' + iban.address();
    } else if (utils.isStrictAddress(address)) {
        return address;
    } else if (utils.isAddress(address)) {
        return '0x' + address;
    }
    throw new Error('invalid address');
};


var outputSyncingFormatter = function(result) {
    if (!result) {
        return result;
    }

    result.startingBlock = utils.toDecimal(result.startingBlock);
    result.currentBlock = utils.toDecimal(result.currentBlock);
    result.highestBlock = utils.toDecimal(result.highestBlock);
    if (result.knownStates) {
        result.knownStates = utils.toDecimal(result.knownStates);
        result.pulledStates = utils.toDecimal(result.pulledStates);
    }

    return result;
};

module.exports = {
    inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,
    inputBlockNumberFormatter: inputBlockNumberFormatter,
    inputCallFormatter: inputCallFormatter,
    inputTransactionFormatter: inputTransactionFormatter,
    inputAddressFormatter: inputAddressFormatter,
    inputPostFormatter: inputPostFormatter,
    outputBigNumberFormatter: outputBigNumberFormatter,
    outputTransactionFormatter: outputTransactionFormatter,
    outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,
    outputBlockFormatter: outputBlockFormatter,
    outputLogFormatter: outputLogFormatter,
    outputPostFormatter: outputPostFormatter,
    outputSyncingFormatter: outputSyncingFormatter
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/function.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file function.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var coder = __webpack_require__("../../node_modules/web3/lib/solidity/coder.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var sha3 = __webpack_require__("../../node_modules/web3/lib/utils/sha3.js");

/**
 * This prototype should be used to call/sendTransaction to solidity functions
 */
var SolidityFunction = function (eth, json, address) {
    this._eth = eth;
    this._inputTypes = json.inputs.map(function (i) {
        return i.type;
    });
    this._outputTypes = json.outputs.map(function (i) {
        return i.type;
    });
    this._constant = json.constant;
    this._payable = json.payable;
    this._name = utils.transformToFullName(json);
    this._address = address;
};

SolidityFunction.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

SolidityFunction.prototype.extractDefaultBlock = function (args) {
    if (args.length > this._inputTypes.length && !utils.isObject(args[args.length -1])) {
        return formatters.inputDefaultBlockNumberFormatter(args.pop()); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 *
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
SolidityFunction.prototype.validateArgs = function (args) {
    var inputArgs = args.filter(function (a) {
      // filter the options object but not arguments that are arrays
      return !( (utils.isObject(a) === true) &&
                (utils.isArray(a) === false) &&
                (utils.isBigNumber(a) === false)
              );
    });
    if (inputArgs.length !== this._inputTypes.length) {
        throw errors.InvalidNumberOfSolidityArgs();
    }
};

/**
 * Should be used to create payload from arguments
 *
 * @method toPayload
 * @param {Array} solidity function params
 * @param {Object} optional payload options
 */
SolidityFunction.prototype.toPayload = function (args) {
    var options = {};
    if (args.length > this._inputTypes.length && utils.isObject(args[args.length -1])) {
        options = args[args.length - 1];
    }
    this.validateArgs(args);
    options.to = this._address;
    options.data = '0x' + this.signature() + coder.encodeParams(this._inputTypes, args);
    return options;
};

/**
 * Should be used to get function signature
 *
 * @method signature
 * @return {String} function signature
 */
SolidityFunction.prototype.signature = function () {
    return sha3(this._name).slice(0, 8);
};


SolidityFunction.prototype.unpackOutput = function (output) {
    if (!output) {
        return;
    }

    output = output.length >= 2 ? output.slice(2) : output;
    var result = coder.decodeParams(this._outputTypes, output);
    return result.length === 1 ? result[0] : result;
};

/**
 * Calls a contract function.
 *
 * @method call
 * @param {...Object} Contract function arguments
 * @param {function} If the last argument is a function, the contract function
 *   call will be asynchronous, and the callback will be passed the
 *   error and result.
 * @return {String} output bytes
 */
SolidityFunction.prototype.call = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var defaultBlock = this.extractDefaultBlock(args);
    var payload = this.toPayload(args);


    if (!callback) {
        var output = this._eth.call(payload, defaultBlock);
        return this.unpackOutput(output);
    }

    var self = this;
    this._eth.call(payload, defaultBlock, function (error, output) {
        if (error) return callback(error, null);

        var unpacked = null;
        try {
            unpacked = self.unpackOutput(output);
        }
        catch (e) {
            error = e;
        }

        callback(error, unpacked);
    });
};

/**
 * Should be used to sendTransaction to solidity function
 *
 * @method sendTransaction
 */
SolidityFunction.prototype.sendTransaction = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (payload.value > 0 && !this._payable) {
        throw new Error('Cannot send value to non-payable function');
    }

    if (!callback) {
        return this._eth.sendTransaction(payload);
    }

    this._eth.sendTransaction(payload, callback);
};

/**
 * Should be used to estimateGas of solidity function
 *
 * @method estimateGas
 */
SolidityFunction.prototype.estimateGas = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (!callback) {
        return this._eth.estimateGas(payload);
    }

    this._eth.estimateGas(payload, callback);
};

/**
 * Return the encoded data of the call
 *
 * @method getData
 * @return {String} the encoded data
 */
SolidityFunction.prototype.getData = function () {
    var args = Array.prototype.slice.call(arguments);
    var payload = this.toPayload(args);

    return payload.data;
};

/**
 * Should be used to get function display name
 *
 * @method displayName
 * @return {String} display name of the function
 */
SolidityFunction.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get function type name
 *
 * @method typeName
 * @return {String} type name of the function
 */
SolidityFunction.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be called to get rpc requests from solidity function
 *
 * @method request
 * @returns {Object}
 */
SolidityFunction.prototype.request = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);
    var format = this.unpackOutput.bind(this);

    return {
        method: this._constant ? 'eth_call' : 'eth_sendTransaction',
        callback: callback,
        params: [payload],
        format: format
    };
};

/**
 * Should be called to execute function
 *
 * @method execute
 */
SolidityFunction.prototype.execute = function () {
    var transaction = !this._constant;

    // send transaction
    if (transaction) {
        return this.sendTransaction.apply(this, Array.prototype.slice.call(arguments));
    }

    // call
    return this.call.apply(this, Array.prototype.slice.call(arguments));
};

/**
 * Should be called to attach function to contract
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityFunction.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    execute.request = this.request.bind(this);
    execute.call = this.call.bind(this);
    execute.sendTransaction = this.sendTransaction.bind(this);
    execute.estimateGas = this.estimateGas.bind(this);
    execute.getData = this.getData.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = execute; // circular!!!!
};

module.exports = SolidityFunction;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/httpprovider.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file httpprovider.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

// workaround to use httpprovider in different envs

// browser
if (typeof window !== 'undefined' && window.XMLHttpRequest) {
  XMLHttpRequest = window.XMLHttpRequest; // jshint ignore: line
// node
} else {
  XMLHttpRequest = __webpack_require__("../../node_modules/web3/lib/utils/browser-xhr.js").XMLHttpRequest; // jshint ignore: line
}

var XHR2 = __webpack_require__("../../node_modules/xhr2/lib/browser.js"); // jshint ignore: line

/**
 * HttpProvider should be used to send rpc calls over http
 */
var HttpProvider = function (host, timeout, user, password) {
  this.host = host || 'http://localhost:8545';
  this.timeout = timeout || 0;
  this.user = user;
  this.password = password;
};

/**
 * Should be called to prepare new XMLHttpRequest
 *
 * @method prepareRequest
 * @param {Boolean} true if request should be async
 * @return {XMLHttpRequest} object
 */
HttpProvider.prototype.prepareRequest = function (async) {
  var request;

  if (async) {
    request = new XHR2();
    request.timeout = this.timeout;
  } else {
    request = new XMLHttpRequest();
  }

  request.open('POST', this.host, async);
  if (this.user && this.password) {
    var auth = 'Basic ' + new Buffer(this.user + ':' + this.password).toString('base64');
    request.setRequestHeader('Authorization', auth);
  } request.setRequestHeader('Content-Type', 'application/json');
  return request;
};

/**
 * Should be called to make sync request
 *
 * @method send
 * @param {Object} payload
 * @return {Object} result
 */
HttpProvider.prototype.send = function (payload) {
  var request = this.prepareRequest(false);

  try {
    request.send(JSON.stringify(payload));
  } catch (error) {
    throw errors.InvalidConnection(this.host);
  }

  var result = request.responseText;

  try {
    result = JSON.parse(result);
  } catch (e) {
    throw errors.InvalidResponse(request.responseText);
  }

  return result;
};

/**
 * Should be used to make async request
 *
 * @method sendAsync
 * @param {Object} payload
 * @param {Function} callback triggered on end with (err, result)
 */
HttpProvider.prototype.sendAsync = function (payload, callback) {
  var request = this.prepareRequest(true);

  request.onreadystatechange = function () {
    if (request.readyState === 4 && request.timeout !== 1) {
      var result = request.responseText;
      var error = null;

      try {
        result = JSON.parse(result);
      } catch (e) {
        error = errors.InvalidResponse(request.responseText);
      }

      callback(error, result);
    }
  };

  request.ontimeout = function () {
    callback(errors.ConnectionTimeout(this.timeout));
  };

  try {
    request.send(JSON.stringify(payload));
  } catch (error) {
    callback(errors.InvalidConnection(this.host));
  }
};

/**
 * Synchronously tries to make Http request
 *
 * @method isConnected
 * @return {Boolean} returns true if request haven't failed. Otherwise false
 */
HttpProvider.prototype.isConnected = function () {
  try {
    this.send({
      id: 9999999999,
      jsonrpc: '2.0',
      method: 'net_listening',
      params: []
    });
    return true;
  } catch (e) {
    return false;
  }
};

module.exports = HttpProvider;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("../../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../node_modules/web3/lib/web3/iban.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file iban.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = __webpack_require__("../../node_modules/bignumber.js/bignumber.js");

var padLeft = function (string, bytes) {
    var result = string;
    while (result.length < bytes * 2) {
        result = '0' + result;
    }
    return result;
};

/**
 * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
 * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
 *
 * @method iso13616Prepare
 * @param {String} iban the IBAN
 * @returns {String} the prepared IBAN
 */
var iso13616Prepare = function (iban) {
    var A = 'A'.charCodeAt(0);
    var Z = 'Z'.charCodeAt(0);

    iban = iban.toUpperCase();
    iban = iban.substr(4) + iban.substr(0,4);

    return iban.split('').map(function(n){
        var code = n.charCodeAt(0);
        if (code >= A && code <= Z){
            // A = 10, B = 11, ... Z = 35
            return code - A + 10;
        } else {
            return n;
        }
    }).join('');
};

/**
 * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
 *
 * @method mod9710
 * @param {String} iban
 * @returns {Number}
 */
var mod9710 = function (iban) {
    var remainder = iban,
        block;

    while (remainder.length > 2){
        block = remainder.slice(0, 9);
        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
    }

    return parseInt(remainder, 10) % 97;
};

/**
 * This prototype should be used to create iban object from iban correct string
 *
 * @param {String} iban
 */
var Iban = function (iban) {
    this._iban = iban;
};

/**
 * This method should be used to create iban object from ethereum address
 *
 * @method fromAddress
 * @param {String} address
 * @return {Iban} the IBAN object
 */
Iban.fromAddress = function (address) {
    var asBn = new BigNumber(address, 16);
    var base36 = asBn.toString(36);
    var padded = padLeft(base36, 15);
    return Iban.fromBban(padded.toUpperCase());
};

/**
 * Convert the passed BBAN to an IBAN for this country specification.
 * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
 * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
 *
 * @method fromBban
 * @param {String} bban the BBAN to convert to IBAN
 * @returns {Iban} the IBAN object
 */
Iban.fromBban = function (bban) {
    var countryCode = 'XE';

    var remainder = mod9710(iso13616Prepare(countryCode + '00' + bban));
    var checkDigit = ('0' + (98 - remainder)).slice(-2);

    return new Iban(countryCode + checkDigit + bban);
};

/**
 * Should be used to create IBAN object for given institution and identifier
 *
 * @method createIndirect
 * @param {Object} options, required options are "institution" and "identifier"
 * @return {Iban} the IBAN object
 */
Iban.createIndirect = function (options) {
    return Iban.fromBban('ETH' + options.institution + options.identifier);
};

/**
 * Thos method should be used to check if given string is valid iban object
 *
 * @method isValid
 * @param {String} iban string
 * @return {Boolean} true if it is valid IBAN
 */
Iban.isValid = function (iban) {
    var i = new Iban(iban);
    return i.isValid();
};

/**
 * Should be called to check if iban is correct
 *
 * @method isValid
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isValid = function () {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) &&
        mod9710(iso13616Prepare(this._iban)) === 1;
};

/**
 * Should be called to check if iban number is direct
 *
 * @method isDirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isDirect = function () {
    return this._iban.length === 34 || this._iban.length === 35;
};

/**
 * Should be called to check if iban number if indirect
 *
 * @method isIndirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isIndirect = function () {
    return this._iban.length === 20;
};

/**
 * Should be called to get iban checksum
 * Uses the mod-97-10 checksumming protocol (ISO/IEC 7064:2003)
 *
 * @method checksum
 * @returns {String} checksum
 */
Iban.prototype.checksum = function () {
    return this._iban.substr(2, 2);
};

/**
 * Should be called to get institution identifier
 * eg. XREG
 *
 * @method institution
 * @returns {String} institution identifier
 */
Iban.prototype.institution = function () {
    return this.isIndirect() ? this._iban.substr(7, 4) : '';
};

/**
 * Should be called to get client identifier within institution
 * eg. GAVOFYORK
 *
 * @method client
 * @returns {String} client identifier
 */
Iban.prototype.client = function () {
    return this.isIndirect() ? this._iban.substr(11) : '';
};

/**
 * Should be called to get client direct address
 *
 * @method address
 * @returns {String} client direct address
 */
Iban.prototype.address = function () {
    if (this.isDirect()) {
        var base36 = this._iban.substr(4);
        var asBn = new BigNumber(base36, 36);
        return padLeft(asBn.toString(16), 20);
    } 

    return '';
};

Iban.prototype.toString = function () {
    return this._iban;
};

module.exports = Iban;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/ipcprovider.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file ipcprovider.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");


var IpcProvider = function (path, net) {
    var _this = this;
    this.responseCallbacks = {};
    this.path = path;
    
    this.connection = net.connect({path: this.path});

    this.connection.on('error', function(e){
        console.error('IPC Connection Error', e);
        _this._timeout();
    });

    this.connection.on('end', function(){
        _this._timeout();
    }); 


    // LISTEN FOR CONNECTION RESPONSES
    this.connection.on('data', function(data) {
        /*jshint maxcomplexity: 6 */

        _this._parseResponse(data.toString()).forEach(function(result){

            var id = null;

            // get the id which matches the returned id
            if(utils.isArray(result)) {
                result.forEach(function(load){
                    if(_this.responseCallbacks[load.id])
                        id = load.id;
                });
            } else {
                id = result.id;
            }

            // fire the callback
            if(_this.responseCallbacks[id]) {
                _this.responseCallbacks[id](null, result);
                delete _this.responseCallbacks[id];
            }
        });
    });
};

/**
Will parse the response and make an array out of it.

@method _parseResponse
@param {String} data
*/
IpcProvider.prototype._parseResponse = function(data) {
    var _this = this,
        returnValues = [];
    
    // DE-CHUNKER
    var dechunkedData = data
        .replace(/\}[\n\r]?\{/g,'}|--|{') // }{
        .replace(/\}\][\n\r]?\[\{/g,'}]|--|[{') // }][{
        .replace(/\}[\n\r]?\[\{/g,'}|--|[{') // }[{
        .replace(/\}\][\n\r]?\{/g,'}]|--|{') // }]{
        .split('|--|');

    dechunkedData.forEach(function(data){

        // prepend the last chunk
        if(_this.lastChunk)
            data = _this.lastChunk + data;

        var result = null;

        try {
            result = JSON.parse(data);

        } catch(e) {

            _this.lastChunk = data;

            // start timeout to cancel all requests
            clearTimeout(_this.lastChunkTimeout);
            _this.lastChunkTimeout = setTimeout(function(){
                _this._timeout();
                throw errors.InvalidResponse(data);
            }, 1000 * 15);

            return;
        }

        // cancel timeout and set chunk to null
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;

        if(result)
            returnValues.push(result);
    });

    return returnValues;
};


/**
Get the adds a callback to the responseCallbacks object,
which will be called if a response matching the response Id will arrive.

@method _addResponseCallback
*/
IpcProvider.prototype._addResponseCallback = function(payload, callback) {
    var id = payload.id || payload[0].id;
    var method = payload.method || payload[0].method;

    this.responseCallbacks[id] = callback;
    this.responseCallbacks[id].method = method;
};

/**
Timeout all requests when the end/error event is fired

@method _timeout
*/
IpcProvider.prototype._timeout = function() {
    for(var key in this.responseCallbacks) {
        if(this.responseCallbacks.hasOwnProperty(key)){
            this.responseCallbacks[key](errors.InvalidConnection('on IPC'));
            delete this.responseCallbacks[key];
        }
    }
};


/**
Check if the current connection is still valid.

@method isConnected
*/
IpcProvider.prototype.isConnected = function() {
    var _this = this;

    // try reconnect, when connection is gone
    if(!_this.connection.writable)
        _this.connection.connect({path: _this.path});

    return !!this.connection.writable;
};

IpcProvider.prototype.send = function (payload) {

    if(this.connection.writeSync) {
        var result;

        // try reconnect, when connection is gone
        if(!this.connection.writable)
            this.connection.connect({path: this.path});

        var data = this.connection.writeSync(JSON.stringify(payload));

        try {
            result = JSON.parse(data);
        } catch(e) {
            throw errors.InvalidResponse(data);                
        }

        return result;

    } else {
        throw new Error('You tried to send "'+ payload.method +'" synchronously. Synchronous requests are not supported by the IPC provider.');
    }
};

IpcProvider.prototype.sendAsync = function (payload, callback) {
    // try reconnect, when connection is gone
    if(!this.connection.writable)
        this.connection.connect({path: this.path});


    this.connection.write(JSON.stringify(payload));
    this._addResponseCallback(payload, callback);
};

module.exports = IpcProvider;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/jsonrpc.js":
/***/ (function(module, exports) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file jsonrpc.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Aaron Kumavis <aaron@kumavis.me>
 * @date 2015
 */

// Initialize Jsonrpc as a simple object with utility functions.
var Jsonrpc = {
    messageId: 0
};

/**
 * Should be called to valid json create payload object
 *
 * @method toPayload
 * @param {Function} method of jsonrpc call, required
 * @param {Array} params, an array of method params, optional
 * @returns {Object} valid jsonrpc payload object
 */
Jsonrpc.toPayload = function (method, params) {
    if (!method)
        console.error('jsonrpc method should be specified!');

    // advance message ID
    Jsonrpc.messageId++;

    return {
        jsonrpc: '2.0',
        id: Jsonrpc.messageId,
        method: method,
        params: params || []
    };
};

/**
 * Should be called to check if jsonrpc response is valid
 *
 * @method isValidResponse
 * @param {Object}
 * @returns {Boolean} true if response is valid, otherwise false
 */
Jsonrpc.isValidResponse = function (response) {
    return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);

    function validateSingleMessage(message){
      return !!message &&
        !message.error &&
        message.jsonrpc === '2.0' &&
        typeof message.id === 'number' &&
        message.result !== undefined; // only undefined is not valid json object
    }
};

/**
 * Should be called to create batch payload object
 *
 * @method toBatchPayload
 * @param {Array} messages, an array of objects with method (required) and params (optional) fields
 * @returns {Array} batch payload
 */
Jsonrpc.toBatchPayload = function (messages) {
    return messages.map(function (message) {
        return Jsonrpc.toPayload(message.method, message.params);
    });
};

module.exports = Jsonrpc;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/method.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file method.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

var Method = function (options) {
    this.name = options.name;
    this.call = options.call;
    this.params = options.params || 0;
    this.inputFormatter = options.inputFormatter;
    this.outputFormatter = options.outputFormatter;
    this.requestManager = null;
};

Method.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be used to determine name of the jsonrpc method based on arguments
 *
 * @method getCall
 * @param {Array} arguments
 * @return {String} name of jsonrpc method
 */
Method.prototype.getCall = function (args) {
    return utils.isFunction(this.call) ? this.call(args) : this.call;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Method.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 * 
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
Method.prototype.validateArgs = function (args) {
    if (args.length !== this.params) {
        throw errors.InvalidNumberOfRPCParams();
    }
};

/**
 * Should be called to format input args of method
 * 
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Method.prototype.formatInput = function (args) {
    if (!this.inputFormatter) {
        return args;
    }

    return this.inputFormatter.map(function (formatter, index) {
        return formatter ? formatter(args[index]) : args[index];
    });
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Method.prototype.formatOutput = function (result) {
    return this.outputFormatter && result ? this.outputFormatter(result) : result;
};

/**
 * Should create payload from given input args
 *
 * @method toPayload
 * @param {Array} args
 * @return {Object}
 */
Method.prototype.toPayload = function (args) {
    var call = this.getCall(args);
    var callback = this.extractCallback(args);
    var params = this.formatInput(args);
    this.validateArgs(params);

    return {
        method: call,
        params: params,
        callback: callback
    };
};

Method.prototype.attachToObject = function (obj) {
    var func = this.buildCall();
    func.call = this.call; // TODO!!! that's ugly. filter.js uses it
    var name = this.name.split('.');
    if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
    } else {
        obj[name[0]] = func; 
    }
};

Method.prototype.buildCall = function() {
    var method = this;
    var send = function () {
        var payload = method.toPayload(Array.prototype.slice.call(arguments));
        if (payload.callback) {
            return method.requestManager.sendAsync(payload, function (err, result) {
                payload.callback(err, method.formatOutput(result));
            });
        }
        return method.formatOutput(method.requestManager.send(payload));
    };
    send.request = this.request.bind(this);
    return send;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Method.prototype.request = function () {
    var payload = this.toPayload(Array.prototype.slice.call(arguments));
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Method;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/db.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file db.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");

var DB = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;
    
    methods().forEach(function(method) { 
        method.attachToObject(self);
        method.setRequestManager(web3._requestManager);
    });
};

var methods = function () {
    var putString = new Method({
        name: 'putString',
        call: 'db_putString',
        params: 3
    });

    var getString = new Method({
        name: 'getString',
        call: 'db_getString',
        params: 2
    });

    var putHex = new Method({
        name: 'putHex',
        call: 'db_putHex',
        params: 3
    });

    var getHex = new Method({
        name: 'getHex',
        call: 'db_getHex',
        params: 2
    });

    return [
        putString, getString, putHex, getHex
    ];
};

module.exports = DB;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/eth.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var Contract = __webpack_require__("../../node_modules/web3/lib/web3/contract.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var IsSyncing = __webpack_require__("../../node_modules/web3/lib/web3/syncing.js");
var namereg = __webpack_require__("../../node_modules/web3/lib/web3/namereg.js");
var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var transfer = __webpack_require__("../../node_modules/web3/lib/web3/transfer.js");

var blockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? "eth_getBlockByHash" : "eth_getBlockByNumber";
};

var transactionFromBlockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getTransactionByBlockHashAndIndex' : 'eth_getTransactionByBlockNumberAndIndex';
};

var uncleCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleByBlockHashAndIndex' : 'eth_getUncleByBlockNumberAndIndex';
};

var getBlockTransactionCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getBlockTransactionCountByHash' : 'eth_getBlockTransactionCountByNumber';
};

var uncleCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleCountByBlockHash' : 'eth_getUncleCountByBlockNumber';
};

function Eth(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });


    this.iban = Iban;
    this.sendIBANTransaction = transfer.bind(null, this);
}

Object.defineProperty(Eth.prototype, 'defaultBlock', {
    get: function () {
        return c.defaultBlock;
    },
    set: function (val) {
        c.defaultBlock = val;
        return val;
    }
});

Object.defineProperty(Eth.prototype, 'defaultAccount', {
    get: function () {
        return c.defaultAccount;
    },
    set: function (val) {
        c.defaultAccount = val;
        return val;
    }
});

var methods = function () {
    var getBalance = new Method({
        name: 'getBalance',
        call: 'eth_getBalance',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: formatters.outputBigNumberFormatter
    });

    var getStorageAt = new Method({
        name: 'getStorageAt',
        call: 'eth_getStorageAt',
        params: 3,
        inputFormatter: [null, utils.toHex, formatters.inputDefaultBlockNumberFormatter]
    });

    var getCode = new Method({
        name: 'getCode',
        call: 'eth_getCode',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var getBlock = new Method({
        name: 'getBlock',
        call: blockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, function (val) { return !!val; }],
        outputFormatter: formatters.outputBlockFormatter
    });

    var getUncle = new Method({
        name: 'getUncle',
        call: uncleCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputBlockFormatter,

    });

    var getCompilers = new Method({
        name: 'getCompilers',
        call: 'eth_getCompilers',
        params: 0
    });

    var getBlockTransactionCount = new Method({
        name: 'getBlockTransactionCount',
        call: getBlockTransactionCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getBlockUncleCount = new Method({
        name: 'getBlockUncleCount',
        call: uncleCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getTransaction = new Method({
        name: 'getTransaction',
        call: 'eth_getTransactionByHash',
        params: 1,
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionFromBlock = new Method({
        name: 'getTransactionFromBlock',
        call: transactionFromBlockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionReceipt = new Method({
        name: 'getTransactionReceipt',
        call: 'eth_getTransactionReceipt',
        params: 1,
        outputFormatter: formatters.outputTransactionReceiptFormatter
    });

    var getTransactionCount = new Method({
        name: 'getTransactionCount',
        call: 'eth_getTransactionCount',
        params: 2,
        inputFormatter: [null, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var sendRawTransaction = new Method({
        name: 'sendRawTransaction',
        call: 'eth_sendRawTransaction',
        params: 1,
        inputFormatter: [null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'eth_sendTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var signTransaction = new Method({
        name: 'signTransaction',
        call: 'eth_signTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var sign = new Method({
        name: 'sign',
        call: 'eth_sign',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, null]
    });

    var call = new Method({
        name: 'call',
        call: 'eth_call',
        params: 2,
        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var estimateGas = new Method({
        name: 'estimateGas',
        call: 'eth_estimateGas',
        params: 1,
        inputFormatter: [formatters.inputCallFormatter],
        outputFormatter: utils.toDecimal
    });

    var compileSolidity = new Method({
        name: 'compile.solidity',
        call: 'eth_compileSolidity',
        params: 1
    });

    var compileLLL = new Method({
        name: 'compile.lll',
        call: 'eth_compileLLL',
        params: 1
    });

    var compileSerpent = new Method({
        name: 'compile.serpent',
        call: 'eth_compileSerpent',
        params: 1
    });

    var submitWork = new Method({
        name: 'submitWork',
        call: 'eth_submitWork',
        params: 3
    });

    var getWork = new Method({
        name: 'getWork',
        call: 'eth_getWork',
        params: 0
    });

    return [
        getBalance,
        getStorageAt,
        getCode,
        getBlock,
        getUncle,
        getCompilers,
        getBlockTransactionCount,
        getBlockUncleCount,
        getTransaction,
        getTransactionFromBlock,
        getTransactionReceipt,
        getTransactionCount,
        call,
        estimateGas,
        sendRawTransaction,
        signTransaction,
        sendTransaction,
        sign,
        compileSolidity,
        compileLLL,
        compileSerpent,
        submitWork,
        getWork
    ];
};


var properties = function () {
    return [
        new Property({
            name: 'coinbase',
            getter: 'eth_coinbase'
        }),
        new Property({
            name: 'mining',
            getter: 'eth_mining'
        }),
        new Property({
            name: 'hashrate',
            getter: 'eth_hashrate',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'syncing',
            getter: 'eth_syncing',
            outputFormatter: formatters.outputSyncingFormatter
        }),
        new Property({
            name: 'gasPrice',
            getter: 'eth_gasPrice',
            outputFormatter: formatters.outputBigNumberFormatter
        }),
        new Property({
            name: 'accounts',
            getter: 'eth_accounts'
        }),
        new Property({
            name: 'blockNumber',
            getter: 'eth_blockNumber',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'protocolVersion',
            getter: 'eth_protocolVersion'
        })
    ];
};

Eth.prototype.contract = function (abi) {
    var factory = new Contract(this, abi);
    return factory;
};

Eth.prototype.filter = function (options, callback, filterCreationErrorCallback) {
    return new Filter(options, 'eth', this._requestManager, watches.eth(), formatters.outputLogFormatter, callback, filterCreationErrorCallback);
};

Eth.prototype.namereg = function () {
    return this.contract(namereg.global.abi).at(namereg.global.address);
};

Eth.prototype.icapNamereg = function () {
    return this.contract(namereg.icap.abi).at(namereg.icap.address);
};

Eth.prototype.isSyncing = function (callback) {
    return new IsSyncing(this._requestManager, callback);
};

module.exports = Eth;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/net.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file eth.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

var Net = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    properties().forEach(function(p) { 
        p.attachToObject(self);
        p.setRequestManager(web3._requestManager);
    });
};

/// @returns an array of objects describing web3.eth api properties
var properties = function () {
    return [
        new Property({
            name: 'listening',
            getter: 'net_listening'
        }),
        new Property({
            name: 'peerCount',
            getter: 'net_peerCount',
            outputFormatter: utils.toDecimal
        })
    ];
};

module.exports = Net;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/personal.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */



var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");
var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");

function Personal(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var newAccount = new Method({
        name: 'newAccount',
        call: 'personal_newAccount',
        params: 1,
        inputFormatter: [null]
    });

    var importRawKey = new Method({
        name: 'importRawKey',
		call: 'personal_importRawKey',
		params: 2
    });

    var sign = new Method({
        name: 'sign',
		call: 'personal_sign',
		params: 3,
		inputFormatter: [null, formatters.inputAddressFormatter, null]
    });

    var ecRecover = new Method({
        name: 'ecRecover',
		call: 'personal_ecRecover',
		params: 2
    });

    var unlockAccount = new Method({
        name: 'unlockAccount',
        call: 'personal_unlockAccount',
        params: 3,
        inputFormatter: [formatters.inputAddressFormatter, null, null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'personal_sendTransaction',
        params: 2,
        inputFormatter: [formatters.inputTransactionFormatter, null]
    });

    var lockAccount = new Method({
        name: 'lockAccount',
        call: 'personal_lockAccount',
        params: 1,
        inputFormatter: [formatters.inputAddressFormatter]
    });

    return [
        newAccount,
        importRawKey,
        unlockAccount,
        ecRecover,
        sign,
        sendTransaction,
        lockAccount
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'listAccounts',
            getter: 'personal_listAccounts'
        })
    ];
};


module.exports = Personal;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/shh.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file shh.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethereum.org>
 *   Marek Kotewicz <marek@ethcore.io>
 * @date 2017
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Filter = __webpack_require__("../../node_modules/web3/lib/web3/filter.js");
var watches = __webpack_require__("../../node_modules/web3/lib/web3/methods/watches.js");

var Shh = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });
};

Shh.prototype.newMessageFilter = function (options, callback, filterCreationErrorCallback) {
    return new Filter(options, 'shh', this._requestManager, watches.shh(), null, callback, filterCreationErrorCallback);
};

var methods = function () {

    return [
        new Method({
            name: 'version',
            call: 'shh_version',
            params: 0
        }),
        new Method({
            name: 'info',
            call: 'shh_info',
            params: 0
        }),
        new Method({
            name: 'setMaxMessageSize',
            call: 'shh_setMaxMessageSize',
            params: 1
        }),
        new Method({
            name: 'setMinPoW',
            call: 'shh_setMinPoW',
            params: 1
        }),
        new Method({
            name: 'markTrustedPeer',
            call: 'shh_markTrustedPeer',
            params: 1
        }),
        new Method({
            name: 'newKeyPair',
            call: 'shh_newKeyPair',
            params: 0
        }),
        new Method({
            name: 'addPrivateKey',
            call: 'shh_addPrivateKey',
            params: 1
        }),
        new Method({
            name: 'deleteKeyPair',
            call: 'shh_deleteKeyPair',
            params: 1
        }),
        new Method({
            name: 'hasKeyPair',
            call: 'shh_hasKeyPair',
            params: 1
        }),
        new Method({
            name: 'getPublicKey',
            call: 'shh_getPublicKey',
            params: 1
        }),
        new Method({
            name: 'getPrivateKey',
            call: 'shh_getPrivateKey',
            params: 1
        }),
        new Method({
            name: 'newSymKey',
            call: 'shh_newSymKey',
            params: 0
        }),
        new Method({
            name: 'addSymKey',
            call: 'shh_addSymKey',
            params: 1
        }),
        new Method({
            name: 'generateSymKeyFromPassword',
            call: 'shh_generateSymKeyFromPassword',
            params: 1
        }),
        new Method({
            name: 'hasSymKey',
            call: 'shh_hasSymKey',
            params: 1
        }),
        new Method({
            name: 'getSymKey',
            call: 'shh_getSymKey',
            params: 1
        }),
        new Method({
            name: 'deleteSymKey',
            call: 'shh_deleteSymKey',
            params: 1
        }),

        // subscribe and unsubscribe missing

        new Method({
            name: 'post',
            call: 'shh_post',
            params: 1,
            inputFormatter: [null]
        })
    ];
};

module.exports = Shh;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/swarm.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file bzz.js
 * @author Alex Beregszaszi <alex@rtfs.hu>
 * @date 2016
 *
 * Reference: https://github.com/ethereum/go-ethereum/blob/swarm/internal/web3ext/web3ext.go#L33
 */



var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");
var Property = __webpack_require__("../../node_modules/web3/lib/web3/property.js");

function Swarm(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var blockNetworkRead = new Method({
        name: 'blockNetworkRead',
        call: 'bzz_blockNetworkRead',
        params: 1,
        inputFormatter: [null]
    });

    var syncEnabled = new Method({
        name: 'syncEnabled',
        call: 'bzz_syncEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var swapEnabled = new Method({
        name: 'swapEnabled',
        call: 'bzz_swapEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var download = new Method({
        name: 'download',
        call: 'bzz_download',
        params: 2,
        inputFormatter: [null, null]
    });

    var upload = new Method({
        name: 'upload',
        call: 'bzz_upload',
        params: 2,
        inputFormatter: [null, null]
    });

    var retrieve = new Method({
        name: 'retrieve',
        call: 'bzz_retrieve',
        params: 1,
        inputFormatter: [null]
    });

    var store = new Method({
        name: 'store',
        call: 'bzz_store',
        params: 2,
        inputFormatter: [null, null]
    });

    var get = new Method({
        name: 'get',
        call: 'bzz_get',
        params: 1,
        inputFormatter: [null]
    });

    var put = new Method({
        name: 'put',
        call: 'bzz_put',
        params: 2,
        inputFormatter: [null, null]
    });

    var modify = new Method({
        name: 'modify',
        call: 'bzz_modify',
        params: 4,
        inputFormatter: [null, null, null, null]
    });

    return [
        blockNetworkRead,
        syncEnabled,
        swapEnabled,
        download,
        upload,
        retrieve,
        store,
        get,
        put,
        modify
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'hive',
            getter: 'bzz_hive'
        }),
        new Property({
            name: 'info',
            getter: 'bzz_info'
        })
    ];
};


module.exports = Swarm;


/***/ }),

/***/ "../../node_modules/web3/lib/web3/methods/watches.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file watches.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = __webpack_require__("../../node_modules/web3/lib/web3/method.js");

/// @returns an array of objects describing web3.eth.filter api methods
var eth = function () {
    var newFilterCall = function (args) {
        var type = args[0];

        switch(type) {
            case 'latest':
                args.shift();
                this.params = 0;
                return 'eth_newBlockFilter';
            case 'pending':
                args.shift();
                this.params = 0;
                return 'eth_newPendingTransactionFilter';
            default:
                return 'eth_newFilter';
        }
    };

    var newFilter = new Method({
        name: 'newFilter',
        call: newFilterCall,
        params: 1
    });

    var uninstallFilter = new Method({
        name: 'uninstallFilter',
        call: 'eth_uninstallFilter',
        params: 1
    });

    var getLogs = new Method({
        name: 'getLogs',
        call: 'eth_getFilterLogs',
        params: 1
    });

    var poll = new Method({
        name: 'poll',
        call: 'eth_getFilterChanges',
        params: 1
    });

    return [
        newFilter,
        uninstallFilter,
        getLogs,
        poll
    ];
};

/// @returns an array of objects describing web3.shh.watch api methods
var shh = function () {

    return [
        new Method({
            name: 'newFilter',
            call: 'shh_newMessageFilter',
            params: 1
        }),
        new Method({
            name: 'uninstallFilter',
            call: 'shh_deleteMessageFilter',
            params: 1
        }),
        new Method({
            name: 'getLogs',
            call: 'shh_getFilterMessages',
            params: 1
        }),
        new Method({
            name: 'poll',
            call: 'shh_getFilterMessages',
            params: 1
        })
    ];
};

module.exports = {
    eth: eth,
    shh: shh
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/namereg.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file namereg.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var globalRegistrarAbi = __webpack_require__("../../node_modules/web3/lib/contracts/GlobalRegistrar.json");
var icapRegistrarAbi= __webpack_require__("../../node_modules/web3/lib/contracts/ICAPRegistrar.json");

var globalNameregAddress = '0xc6d9d2cd449a754c494264e1809c50e34d64562b';
var icapNameregAddress = '0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00';

module.exports = {
    global: {
        abi: globalRegistrarAbi,
        address: globalNameregAddress
    },
    icap: {
        abi: icapRegistrarAbi,
        address: icapNameregAddress
    }
};



/***/ }),

/***/ "../../node_modules/web3/lib/web3/property.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file property.js
 * @author Fabian Vogelsteller <fabian@frozeman.de>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

var Property = function (options) {
    this.name = options.name;
    this.getter = options.getter;
    this.setter = options.setter;
    this.outputFormatter = options.outputFormatter;
    this.inputFormatter = options.inputFormatter;
    this.requestManager = null;
};

Property.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be called to format input args of method
 *
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Property.prototype.formatInput = function (arg) {
    return this.inputFormatter ? this.inputFormatter(arg) : arg;
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Property.prototype.formatOutput = function (result) {
    return this.outputFormatter && result !== null && result !== undefined ? this.outputFormatter(result) : result;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Property.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};


/**
 * Should attach function to method
 *
 * @method attachToObject
 * @param {Object}
 * @param {Function}
 */
Property.prototype.attachToObject = function (obj) {
    var proto = {
        get: this.buildGet(),
        enumerable: true
    };

    var names = this.name.split('.');
    var name = names[0];
    if (names.length > 1) {
        obj[names[0]] = obj[names[0]] || {};
        obj = obj[names[0]];
        name = names[1];
    }

    Object.defineProperty(obj, name, proto);
    obj[asyncGetterName(name)] = this.buildAsyncGet();
};

var asyncGetterName = function (name) {
    return 'get' + name.charAt(0).toUpperCase() + name.slice(1);
};

Property.prototype.buildGet = function () {
    var property = this;
    return function get() {
        return property.formatOutput(property.requestManager.send({
            method: property.getter
        }));
    };
};

Property.prototype.buildAsyncGet = function () {
    var property = this;
    var get = function (callback) {
        property.requestManager.sendAsync({
            method: property.getter
        }, function (err, result) {
            callback(err, property.formatOutput(result));
        });
    };
    get.request = this.request.bind(this);
    return get;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Property.prototype.request = function () {
    var payload = {
        method: this.getter,
        params: [],
        callback: this.extractCallback(Array.prototype.slice.call(arguments))
    };
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Property;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/requestmanager.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file requestmanager.js
 * @author Jeffrey Wilcke <jeff@ethdev.com>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Marian Oancea <marian@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @author Gav Wood <g@ethdev.com>
 * @date 2014
 */

var Jsonrpc = __webpack_require__("../../node_modules/web3/lib/web3/jsonrpc.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");
var c = __webpack_require__("../../node_modules/web3/lib/utils/config.js");
var errors = __webpack_require__("../../node_modules/web3/lib/web3/errors.js");

/**
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 * Singleton
 */
var RequestManager = function (provider) {
    this.provider = provider;
    this.polls = {};
    this.timeout = null;
};

/**
 * Should be used to synchronously send request
 *
 * @method send
 * @param {Object} data
 * @return {Object}
 */
RequestManager.prototype.send = function (data) {
    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return null;
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    var result = this.provider.send(payload);

    if (!Jsonrpc.isValidResponse(result)) {
        throw errors.InvalidResponse(result);
    }

    return result.result;
};

/**
 * Should be used to asynchronously send request
 *
 * @method sendAsync
 * @param {Object} data
 * @param {Function} callback
 */
RequestManager.prototype.sendAsync = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    this.provider.sendAsync(payload, function (err, result) {
        if (err) {
            return callback(err);
        }
        
        if (!Jsonrpc.isValidResponse(result)) {
            return callback(errors.InvalidResponse(result));
        }

        callback(null, result.result);
    });
};

/**
 * Should be called to asynchronously send batch request
 *
 * @method sendBatch
 * @param {Array} batch data
 * @param {Function} callback
 */
RequestManager.prototype.sendBatch = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toBatchPayload(data);

    this.provider.sendAsync(payload, function (err, results) {
        if (err) {
            return callback(err);
        }

        if (!utils.isArray(results)) {
            return callback(errors.InvalidResponse(results));
        }

        callback(err, results);
    }); 
};

/**
 * Should be used to set provider of request manager
 *
 * @method setProvider
 * @param {Object}
 */
RequestManager.prototype.setProvider = function (p) {
    this.provider = p;
};

/**
 * Should be used to start polling
 *
 * @method startPolling
 * @param {Object} data
 * @param {Number} pollId
 * @param {Function} callback
 * @param {Function} uninstall
 *
 * @todo cleanup number of params
 */
RequestManager.prototype.startPolling = function (data, pollId, callback, uninstall) {
    this.polls[pollId] = {data: data, id: pollId, callback: callback, uninstall: uninstall};


    // start polling
    if (!this.timeout) {
        this.poll();
    }
};

/**
 * Should be used to stop polling for filter with given id
 *
 * @method stopPolling
 * @param {Number} pollId
 */
RequestManager.prototype.stopPolling = function (pollId) {
    delete this.polls[pollId];

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to reset the polling mechanism of the request manager
 *
 * @method reset
 */
RequestManager.prototype.reset = function (keepIsSyncing) {
    /*jshint maxcomplexity:5 */

    for (var key in this.polls) {
        // remove all polls, except sync polls,
        // they need to be removed manually by calling syncing.stopWatching()
        if(!keepIsSyncing || key.indexOf('syncPoll_') === -1) {
            this.polls[key].uninstall();
            delete this.polls[key];
        }
    }

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to poll for changes on filter with given id
 *
 * @method poll
 */
RequestManager.prototype.poll = function () {
    /*jshint maxcomplexity: 6 */
    this.timeout = setTimeout(this.poll.bind(this), c.ETH_POLLING_TIMEOUT);

    if (Object.keys(this.polls).length === 0) {
        return;
    }

    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return;
    }

    var pollsData = [];
    var pollsIds = [];
    for (var key in this.polls) {
        pollsData.push(this.polls[key].data);
        pollsIds.push(key);
    }

    if (pollsData.length === 0) {
        return;
    }

    var payload = Jsonrpc.toBatchPayload(pollsData);
    
    // map the request id to they poll id
    var pollsIdMap = {};
    payload.forEach(function(load, index){
        pollsIdMap[load.id] = pollsIds[index];
    });


    var self = this;
    this.provider.sendAsync(payload, function (error, results) {


        // TODO: console log?
        if (error) {
            return;
        }

        if (!utils.isArray(results)) {
            throw errors.InvalidResponse(results);
        }
        results.map(function (result) {
            var id = pollsIdMap[result.id];

            // make sure the filter is still installed after arrival of the request
            if (self.polls[id]) {
                result.callback = self.polls[id].callback;
                return result;
            } else
                return false;
        }).filter(function (result) {
            return !!result; 
        }).filter(function (result) {
            var valid = Jsonrpc.isValidResponse(result);
            if (!valid) {
                result.callback(errors.InvalidResponse(result));
            }
            return valid;
        }).forEach(function (result) {
            result.callback(null, result.result);
        });
    });
};

module.exports = RequestManager;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/settings.js":
/***/ (function(module, exports) {



var Settings = function () {
    this.defaultBlock = 'latest';
    this.defaultAccount = undefined;
};

module.exports = Settings;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/syncing.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file syncing.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var formatters = __webpack_require__("../../node_modules/web3/lib/web3/formatters.js");
var utils = __webpack_require__("../../node_modules/web3/lib/utils/utils.js");

var count = 1;

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollSyncing
@param {Object} self
*/
var pollSyncing = function(self) {

    var onMessage = function (error, sync) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isObject(sync) && sync.startingBlock)
            sync = formatters.outputSyncingFormatter(sync);

        self.callbacks.forEach(function (callback) {
            if (self.lastSyncState !== sync) {
                
                // call the callback with true first so the app can stop anything, before receiving the sync data
                if(!self.lastSyncState && utils.isObject(sync))
                    callback(null, true);
                
                // call on the next CPU cycle, so the actions of the sync stop can be processes first
                setTimeout(function() {
                    callback(null, sync);
                }, 0);
                
                self.lastSyncState = sync;
            }
        });
    };

    self.requestManager.startPolling({
        method: 'eth_syncing',
        params: [],
    }, self.pollId, onMessage, self.stopWatching.bind(self));

};

var IsSyncing = function (requestManager, callback) {
    this.requestManager = requestManager;
    this.pollId = 'syncPoll_'+ count++;
    this.callbacks = [];
    this.addCallback(callback);
    this.lastSyncState = false;
    pollSyncing(this);

    return this;
};

IsSyncing.prototype.addCallback = function (callback) {
    if(callback)
        this.callbacks.push(callback);
    return this;
};

IsSyncing.prototype.stopWatching = function () {
    this.requestManager.stopPolling(this.pollId);
    this.callbacks = [];
};

module.exports = IsSyncing;



/***/ }),

/***/ "../../node_modules/web3/lib/web3/transfer.js":
/***/ (function(module, exports, __webpack_require__) {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file transfer.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Iban = __webpack_require__("../../node_modules/web3/lib/web3/iban.js");
var exchangeAbi = __webpack_require__("../../node_modules/web3/lib/contracts/SmartExchange.json");

/**
 * Should be used to make Iban transfer
 *
 * @method transfer
 * @param {String} from
 * @param {String} to iban
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transfer = function (eth, from, to, value, callback) {
    var iban = new Iban(to); 
    if (!iban.isValid()) {
        throw new Error('invalid iban address');
    }

    if (iban.isDirect()) {
        return transferToAddress(eth, from, iban.address(), value, callback);
    }
    
    if (!callback) {
        var address = eth.icapNamereg().addr(iban.institution());
        return deposit(eth, from, address, value, iban.client());
    }

    eth.icapNamereg().addr(iban.institution(), function (err, address) {
        return deposit(eth, from, address, value, iban.client(), callback);
    });
    
};

/**
 * Should be used to transfer funds to certain address
 *
 * @method transferToAddress
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transferToAddress = function (eth, from, to, value, callback) {
    return eth.sendTransaction({
        address: to,
        from: from,
        value: value
    }, callback);
};

/**
 * Should be used to deposit funds to generic Exchange contract (must implement deposit(bytes32) method!)
 *
 * @method deposit
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be transfered
 * @param {String} client unique identifier
 * @param {Function} callback, callback
 */
var deposit = function (eth, from, to, value, client, callback) {
    var abi = exchangeAbi;
    return eth.contract(abi).at(to).deposit(client, {
        from: from,
        value: value
    }, callback);
};

module.exports = transfer;



/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../../node_modules/xhr2/lib/browser.js":
/***/ (function(module, exports) {

module.exports = XMLHttpRequest;


/***/ }),

/***/ "../../packages/components/src/adsList.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/adsList.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./adsList.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./adsList.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/button.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/button.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./button.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./button.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/icon.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/icon.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./icon.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./icon.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/input.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/input.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./input.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./input.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/label.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/label.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./label.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./label.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/link.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/link.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./link.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./link.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/linkList.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/linkList.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./linkList.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./linkList.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/loader.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/loader.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./loader.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./loader.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/paper.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/paper.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./paper.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./paper.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/textWithLabel.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/textWithLabel.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./textWithLabel.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./textWithLabel.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "../../packages/components/src/tooltip.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!../../packages/components/src/tooltip.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./tooltip.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./tooltip.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./images/heart.svg":
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTQxcHgiIGhlaWdodD0iMTMxcHgiIHZpZXdCb3g9IjAgMCAxNDEgMTMxIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0Ni4yICg0NDQ5NikgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+R3JvdXAgMzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxjaXJjbGUgaWQ9InBhdGgtMSIgY3g9IjYwLjc4NjEzMjgiIGN5PSI1OS43ODYxMzI4IiByPSI0NS43ODYxMzI4Ij48L2NpcmNsZT4KICAgICAgICA8ZmlsdGVyIHg9Ii0zNS41JSIgeT0iLTMwLjAlIiB3aWR0aD0iMTcxLjAlIiBoZWlnaHQ9IjE3MS4wJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTIiPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSI1IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxMCIgaW49InNoYWRvd09mZnNldE91dGVyMSIgcmVzdWx0PSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMC4wMzUyOTQxMTc2ICAgMCAwIDAgMCAwLjgzNTI5NDExOCAgIDAgMCAwIDAgMC40ODYyNzQ1MSAgMCAwIDAgMC40NSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iTVZQIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iY3JlYXRlTmV3QWRDb25maXJtYXRpb24iIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03MzYuMDAwMDAwLCAtMzYxLjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzQxLjAwMDAwMCwgMzYyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTMiPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMiIgZmlsbC1vcGFjaXR5PSIwLjIiIGZpbGw9IiMwOUQ1N0MiIGN4PSIxMDMiIGN5PSIzMyIgcj0iMzMiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwtMiIgZmlsbC1vcGFjaXR5PSIwLjIiIGZpbGw9IiMwOUQ1N0MiIGN4PSIzMyIgY3k9IjczIiByPSIzMyI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiMwOUQ1N0MiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJub3VuXzc0NzMwMl9jYyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzYuMDAwMDAwLCA0Mi4wMDAwMDApIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuOTU2MDQ0LDAuMTA5ODkwMTEgQzE2LjcwMzI5NjcsLTMuMDQwNjIzMzFlLTE0IDE5LjA2NTkzNDEsMC45ODkwMTA5ODkgMjAuODI0MTc1OCwyLjg1NzE0Mjg2IEwyNC44OTAxMDk5LDcuMTQyODU3MTQgQzIzLjczNjI2MzcsOC40NjE1Mzg0NiAyMi44NTcxNDI5LDkuMzk1NjA0NCAyMi41Mjc0NzI1LDkuODM1MTY0ODQgQzIxLjkyMzA3NjksOS4xNzU4MjQxOCAyMC40Mzk1NjA0LDcuNDcyNTI3NDcgMTguOTU2MDQ0LDUuODc5MTIwODggQzE3LjU4MjQxNzYsNC4zOTU2MDQ0IDE1LjcxNDI4NTcsMy42ODEzMTg2OCAxMy43MzYyNjM3LDMuNzkxMjA4NzkgQzExLjg2ODEzMTksMy45MDEwOTg5IDEwLjE2NDgzNTIsNC43ODAyMTk3OCA5LjI4NTcxNDI5LDUuOTg5MDEwOTkgQzUuOTg5MDEwOTksMTAuNTQ5NDUwNSA5LjI4NTcxNDI5LDE0LjYxNTM4NDYgOS4yODU3MTQyOSwxNC42NzAzMjk3IEwyNC44MzUxNjQ4LDMyLjYzNzM2MjYgQzIzLjY4MTMxODcsMzMuOTU2MDQ0IDIyLjg1NzE0MjksMzQuOTQ1MDU0OSAyMi40NzI1Mjc1LDM1LjMyOTY3MDMgQzIwLjg3OTEyMDksMzMuMzUxNjQ4NCAxMC4zODQ2MTU0LDIxLjQyODU3MTQgNi4yMDg3OTEyMSwxNi41OTM0MDY2IEM1LjIxOTc4MDIyLDE1LjQ5NDUwNTUgMy4xMzE4NjgxMywxMS41OTM0MDY2IDQuODM1MTY0ODQsNi43NTgyNDE3NiBDNi40ODM1MTY0OCwyLjAzMjk2NzAzIDEwLjc2OTIzMDgsMC4yMTk3ODAyMiAxMy45NTYwNDQsMC4xMDk4OTAxMSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIzLjA3NjkyMzEsMTYuMzE4NjgxMyBDMjQuNDUwNTQ5NSwxNC43MjUyNzQ3IDI4Ljk1NjA0NCw5LjQ1MDU0OTQ1IDMxLjc1ODI0MTgsNi4zNzM2MjYzNyBDMzIuODU3MTQyOSw1LjE2NDgzNTE2IDM0LjI4NTcxNDMsNC40NTA1NDk0NSAzNS45ODkwMTEsNC4zOTU2MDQ0IEMzNy4zMDc2OTIzLDQuMzQwNjU5MzQgMzguNjgxMzE4Nyw0LjcyNTI3NDczIDM5LjcyNTI3NDcsNS40Mzk1NjA0NCBDMzYuNTkzNDA2Niw1LjY1OTM0MDY2IDM1LjA1NDk0NTEsNy41Mjc0NzI1MyAzNSw3LjU4MjQxNzU4IEwyNy42MzczNjI2LDE2LjMxODY4MTMgTDIzLjA3NjkyMzEsMTYuMzE4NjgxMyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMuMDc2OTIzMDgsMTkuNDUwNTQ5NSBDMC45ODkwMTA5ODksMTcuMDMyOTY3IDAuMTY0ODM1MTY1LDEzLjc5MTIwODggMC43MTQyODU3MTQsMTAuMTY0ODM1MiBDMS4xNTM4NDYxNSw3LjAzMjk2NzAzIDMuNzM2MjYzNzQsNC4wNjU5MzQwNyA2LjY0ODM1MTY1LDIuNzQ3MjUyNzUgQzUuNjU5MzQwNjYsMy43OTEyMDg3OSA0LjgzNTE2NDg0LDUuMDU0OTQ1MDUgNC4yODU3MTQyOSw2LjU5MzQwNjU5IEMyLjQ3MjUyNzQ3LDExLjU5MzQwNjYgNC43MjUyNzQ3MywxNS44MjQxNzU4IDUuNzY5MjMwNzcsMTYuOTc4MDIyIEMxMC4yNzQ3MjUzLDIyLjE5NzgwMjIgMjIuMTQyODU3MSwzNS44MjQxNzU4IDIyLjI1Mjc0NzMsMzUuOTM0MDY1OSBMMjIuNTI3NDcyNSwzNi4yNjM3MzYzIEwyMi43NDcyNTI3LDM2LjA0Mzk1NiBDMjIuOTEyMDg3OSwzNS44NzkxMjA5IDM3LjQ3MjUyNzUsMTkuMDY1OTM0MSA0MC43MTQyODU3LDE1LjQzOTU2MDQgQzQzLjQ2MTUzODUsMTIuMzA3NjkyMyA0My4wNzY5MjMxLDcuNjM3MzYyNjQgNDAuODI0MTc1OCw1LjU0OTQ1MDU1IEMzOS42MTUzODQ2LDQuMzk1NjA0NCAzNy44MDIxOTc4LDMuNzM2MjYzNzQgMzYuMDQzOTU2LDMuOTAxMDk4OSBDMzQuMjMwNzY5MiwzLjk1NjA0Mzk2IDMyLjYzNzM2MjYsNC43ODAyMTk3OCAzMS40Mjg1NzE0LDYuMDQzOTU2MDQgQzI4LjUxNjQ4MzUsOS4yMzA3NjkyMyAyMy42MjYzNzM2LDE0Ljg5MDEwOTkgMjIuNTI3NDcyNSwxNi4xNTM4NDYyIEMyMS41Mzg0NjE1LDE0Ljk0NTA1NDkgMTcuMTk3ODAyMiw5LjY3MDMyOTY3IDE0Ljk0NTA1NDksNy4xOTc4MDIyIEMxNC4yMzA3NjkyLDYuNDI4NTcxNDMgMTMuMDIxOTc4LDUuNjA0Mzk1NiAxMC43NjkyMzA4LDUuMzg0NjE1MzggQzExLjU5MzQwNjYsNC43ODAyMTk3OCAxMi42OTIzMDc3LDQuNDUwNTQ5NDUgMTMuNzkxMjA4OCw0LjM0MDY1OTM0IEMxNS4wNTQ5NDUxLDQuMjg1NzE0MjkgMTYuOTIzMDc2OSw0LjUwNTQ5NDUxIDE4LjUxNjQ4MzUsNi4yNjM3MzYyNiBDMjAuMzg0NjE1NCw4LjI0MTc1ODI0IDIyLjI1Mjc0NzMsMTAuNDM5NTYwNCAyMi4yNTI3NDczLDEwLjQzOTU2MDQgTDIyLjQ3MjUyNzUsMTAuNjU5MzQwNyBMMjIuNjkyMzA3NywxMC40Mzk1NjA0IEMyMi42OTIzMDc3LDEwLjQzOTU2MDQgMjUsNy44MDIxOTc4IDI4LjE4NjgxMzIsNC4xNzU4MjQxOCBDMzAuOTM0MDY1OSwxLjA5ODkwMTEgMzQuMjMwNzY5MiwwIDM2LjQ4MzUxNjUsMCBDMzguNzM2MjYzNywwIDQzLjQ2MTUzODUsMS4zNzM2MjYzNyA0NS40OTQ1MDU1LDYuNjQ4MzUxNjUgQzQ2LjcwMzI5NjcsOS44MzUxNjQ4NCA0Ni4xNTM4NDYyLDE0LjA2NTkzNDEgNDQuMTc1ODI0MiwxNi4zMTg2ODEzIEMzOC41NzE0Mjg2LDIyLjg1NzE0MjkgMjQuMTc1ODI0MiwzOS4yODU3MTQzIDIyLjMwNzY5MjMsNDEuNDgzNTE2NSBDMjAuMzg0NjE1NCwzOS4yODU3MTQzIDUuMjc0NzI1MjcsMjEuOTIzMDc2OSAzLjA3NjkyMzA4LDE5LjQ1MDU0OTUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik00Ny45NjcwMzMsMTguNDYxNTM4NSBDNDMuNTcxNDI4NiwyMy40MDY1OTM0IDI5LjE3NTgyNDIsNDAuMzI5NjcwMyAyNy45MTIwODc5LDQxLjc1ODI0MTggTDIzLjAyMTk3OCw0MS43NTgyNDE4IEMyNS41NDk0NTA1LDM4Ljc5MTIwODggMzkuMjg1NzE0MywyMy4xMzE4NjgxIDQ0LjcyNTI3NDcsMTYuODEzMTg2OCBDNDYuODY4MTMxOSwxNC4zOTU2MDQ0IDQ3LjQxNzU4MjQsMTAgNDYuMDk4OTAxMSw2LjU5MzQwNjU5IEM0NS40Mzk1NjA0LDUgNDQuNjE1Mzg0NiwzLjY4MTMxODY4IDQzLjYyNjM3MzYsMi43NDcyNTI3NSBDNDYuMDQzOTU2LDMuNzkxMjA4NzkgNDcuOTEyMDg3OSw1LjQ5NDUwNTQ5IDQ5LjAxMDk4OSw3LjkxMjA4NzkxIEw0OS4wNjU5MzQxLDguMDIxOTc4MDIgQzQ5LjAxMDk4OSw3Ljk2NzAzMjk3IDUxLjgxMzE4NjgsMTQuMDEwOTg5IDQ3Ljk2NzAzMywxOC40NjE1Mzg1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"

/***/ }),

/***/ "./src/index.tsx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: /apps/node_modules/preact/dist/preact.esm.js
var preact_esm = __webpack_require__("../../node_modules/preact/dist/preact.esm.js");

// EXTERNAL MODULE: /apps/node_modules/normalize.css/normalize.css
var normalize = __webpack_require__("../../node_modules/normalize.css/normalize.css");
var normalize_default = /*#__PURE__*/__webpack_require__.n(normalize);

// EXTERNAL MODULE: /apps/node_modules/warning/browser.js
var browser = __webpack_require__("../../node_modules/warning/browser.js");
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);

// EXTERNAL MODULE: /apps/node_modules/preact-compat/dist/preact-compat.es.js
var preact_compat_es = __webpack_require__("../../node_modules/preact-compat/dist/preact-compat.es.js");

// EXTERNAL MODULE: /apps/node_modules/prop-types/index.js
var prop_types = __webpack_require__("../../node_modules/prop-types/index.js");
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: /apps/node_modules/history/createBrowserHistory.js
var history_createBrowserHistory = __webpack_require__("../../node_modules/history/createBrowserHistory.js");
var createBrowserHistory_default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory);

// EXTERNAL MODULE: /apps/node_modules/invariant/browser.js
var invariant_browser = __webpack_require__("../../node_modules/invariant/browser.js");
var invariant_browser_default = /*#__PURE__*/__webpack_require__.n(invariant_browser);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/Router.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for putting history on context.
 */

var Router_Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;


    invariant_browser_default()(children == null || preact_compat_es["a" /* default */].Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    browser_default()(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? preact_compat_es["a" /* default */].Children.only(children) : null;
  };

  return Router;
}(preact_compat_es["a" /* default */].Component);

Router_Router.propTypes = {
  history: prop_types_default.a.object.isRequired,
  children: prop_types_default.a.node
};
Router_Router.contextTypes = {
  router: prop_types_default.a.object
};
Router_Router.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_Router = (Router_Router);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Router.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Router = (es_Router);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/BrowserRouter.js
function BrowserRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BrowserRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function BrowserRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter_BrowserRouter = function (_React$Component) {
  BrowserRouter__inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    BrowserRouter__classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = BrowserRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createBrowserHistory_default()(_this.props), _temp), BrowserRouter__possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');
  };

  BrowserRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(react_router_dom_es_Router, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(preact_compat_es["a" /* default */].Component);

BrowserRouter_BrowserRouter.propTypes = {
  basename: prop_types_default.a.string,
  forceRefresh: prop_types_default.a.bool,
  getUserConfirmation: prop_types_default.a.func,
  keyLength: prop_types_default.a.number,
  children: prop_types_default.a.node
};


/* harmony default export */ var es_BrowserRouter = (BrowserRouter_BrowserRouter);
// EXTERNAL MODULE: /apps/node_modules/history/createHashHistory.js
var history_createHashHistory = __webpack_require__("../../node_modules/history/createHashHistory.js");
var createHashHistory_default = /*#__PURE__*/__webpack_require__.n(history_createHashHistory);

// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/HashRouter.js
function HashRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function HashRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function HashRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter_HashRouter = function (_React$Component) {
  HashRouter__inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    HashRouter__classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = HashRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createHashHistory_default()(_this.props), _temp), HashRouter__possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');
  };

  HashRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(react_router_dom_es_Router, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(preact_compat_es["a" /* default */].Component);

HashRouter_HashRouter.propTypes = {
  basename: prop_types_default.a.string,
  getUserConfirmation: prop_types_default.a.func,
  hashType: prop_types_default.a.oneOf(['hashbang', 'noslash', 'slash']),
  children: prop_types_default.a.node
};


/* harmony default export */ var es_HashRouter = (HashRouter_HashRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Link.js
var Link__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function Link__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Link__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Link__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link_Link = function (_React$Component) {
  Link__inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    Link__classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Link__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), Link__possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars

    invariant_browser_default()(this.context.router, 'You should not use <Link> outside a <Router>');

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return preact_compat_es["a" /* default */].createElement('a', Link__extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(preact_compat_es["a" /* default */].Component);

Link_Link.propTypes = {
  onClick: prop_types_default.a.func,
  target: prop_types_default.a.string,
  replace: prop_types_default.a.bool,
  to: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]).isRequired,
  innerRef: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func])
};
Link_Link.defaultProps = {
  replace: false
};
Link_Link.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      push: prop_types_default.a.func.isRequired,
      replace: prop_types_default.a.func.isRequired,
      createHref: prop_types_default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ var es_Link = (Link_Link);
// EXTERNAL MODULE: /apps/node_modules/history/createMemoryHistory.js
var history_createMemoryHistory = __webpack_require__("../../node_modules/history/createMemoryHistory.js");
var createMemoryHistory_default = /*#__PURE__*/__webpack_require__.n(history_createMemoryHistory);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/MemoryRouter.js
function MemoryRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MemoryRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MemoryRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter_MemoryRouter = function (_React$Component) {
  MemoryRouter__inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    MemoryRouter__classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = MemoryRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createMemoryHistory_default()(_this.props), _temp), MemoryRouter__possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');
  };

  MemoryRouter.prototype.render = function render() {
    return preact_compat_es["a" /* default */].createElement(es_Router, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(preact_compat_es["a" /* default */].Component);

MemoryRouter_MemoryRouter.propTypes = {
  initialEntries: prop_types_default.a.array,
  initialIndex: prop_types_default.a.number,
  getUserConfirmation: prop_types_default.a.func,
  keyLength: prop_types_default.a.number,
  children: prop_types_default.a.node
};


/* harmony default export */ var es_MemoryRouter = (MemoryRouter_MemoryRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/MemoryRouter.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_MemoryRouter = (es_MemoryRouter);
// EXTERNAL MODULE: /apps/node_modules/react-router/node_modules/path-to-regexp/index.js
var path_to_regexp = __webpack_require__("../../node_modules/react-router/node_modules/path-to-regexp/index.js");
var path_to_regexp_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/matchPath.js


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var matchPath_compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = path_to_regexp_default()(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;

  var _compilePath = matchPath_compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

/* harmony default export */ var es_matchPath = (matchPath);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Route.js
var Route__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Route__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Route__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Route__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var Route_isEmptyChildren = function isEmptyChildren(children) {
  return preact_compat_es["a" /* default */].Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route_Route = function (_React$Component) {
  Route__inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    Route__classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Route__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), Route__possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: Route__extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    invariant_browser_default()(router, 'You should not use <Route> or withRouter() outside a <Router>');

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return path ? es_matchPath(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    browser_default()(!(this.props.component && this.props.children && !Route_isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    browser_default()(!(this.props.render && this.props.children && !Route_isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    browser_default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    browser_default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? preact_compat_es["a" /* default */].createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !Route_isEmptyChildren(children) ? preact_compat_es["a" /* default */].Children.only(children) : null : null;
  };

  return Route;
}(preact_compat_es["a" /* default */].Component);

Route_Route.propTypes = {
  computedMatch: prop_types_default.a.object, // private, from <Switch>
  path: prop_types_default.a.string,
  exact: prop_types_default.a.bool,
  strict: prop_types_default.a.bool,
  sensitive: prop_types_default.a.bool,
  component: prop_types_default.a.func,
  render: prop_types_default.a.func,
  children: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.node]),
  location: prop_types_default.a.object
};
Route_Route.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.object.isRequired,
    route: prop_types_default.a.object.isRequired,
    staticContext: prop_types_default.a.object
  })
};
Route_Route.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_Route = (Route_Route);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Route.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Route = (es_Route);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/NavLink.js
var NavLink__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function NavLink__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink_NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref.ariaCurrent,
      rest = NavLink__objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);

  return preact_compat_es["a" /* default */].createElement(react_router_dom_es_Route, {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return preact_compat_es["a" /* default */].createElement(es_Link, NavLink__extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? NavLink__extends({}, style, activeStyle) : style,
        'aria-current': isActive && ariaCurrent
      }, rest));
    }
  });
};

NavLink_NavLink.propTypes = {
  to: es_Link.propTypes.to,
  exact: prop_types_default.a.bool,
  strict: prop_types_default.a.bool,
  location: prop_types_default.a.object,
  activeClassName: prop_types_default.a.string,
  className: prop_types_default.a.string,
  activeStyle: prop_types_default.a.object,
  style: prop_types_default.a.object,
  isActive: prop_types_default.a.func,
  ariaCurrent: prop_types_default.a.oneOf(['page', 'step', 'location', 'true'])
};

NavLink_NavLink.defaultProps = {
  activeClassName: 'active',
  ariaCurrent: 'true'
};

/* harmony default export */ var es_NavLink = (NavLink_NavLink);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Prompt.js
function Prompt__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Prompt__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Prompt__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt_Prompt = function (_React$Component) {
  Prompt__inherits(Prompt, _React$Component);

  function Prompt() {
    Prompt__classCallCheck(this, Prompt);

    return Prompt__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    invariant_browser_default()(this.context.router, 'You should not use <Prompt> outside a <Router>');

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(preact_compat_es["a" /* default */].Component);

Prompt_Prompt.propTypes = {
  when: prop_types_default.a.bool,
  message: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]).isRequired
};
Prompt_Prompt.defaultProps = {
  when: true
};
Prompt_Prompt.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      block: prop_types_default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ var es_Prompt = (Prompt_Prompt);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Prompt.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Prompt = (es_Prompt);
// EXTERNAL MODULE: /apps/node_modules/resolve-pathname/index.js
var resolve_pathname = __webpack_require__("../../node_modules/resolve-pathname/index.js");

// EXTERNAL MODULE: /apps/node_modules/value-equal/index.js
var value_equal = __webpack_require__("../../node_modules/value-equal/index.js");

// CONCATENATED MODULE: /apps/node_modules/history/es/PathUtils.js
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var PathUtils_stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};
// CONCATENATED MODULE: /apps/node_modules/history/es/LocationUtils.js
var LocationUtils__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var LocationUtils_createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = LocationUtils__extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(resolve_pathname["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var LocationUtils_locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal["default"])(a.state, b.state);
};
// CONCATENATED MODULE: /apps/node_modules/history/es/createTransitionManager.js


var createTransitionManager_createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    browser_default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          browser_default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ var es_createTransitionManager = (createTransitionManager_createTransitionManager);
// CONCATENATED MODULE: /apps/node_modules/history/es/DOMUtils.js
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};
// CONCATENATED MODULE: /apps/node_modules/history/es/createBrowserHistory.js
var createBrowserHistory__typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createBrowserHistory__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory_createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant_browser_default()(canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    browser_default()(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = PathUtils_stripBasename(path, basename);

    return LocationUtils_createLocation(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = es_createTransitionManager();

  var setState = function setState(nextState) {
    createBrowserHistory__extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + createPath(location);
  };

  var push = function push(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createBrowserHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        browser_default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createBrowserHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        browser_default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      addEventListener(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      removeEventListener(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ var es_createBrowserHistory = (createBrowserHistory_createBrowserHistory);
// CONCATENATED MODULE: /apps/node_modules/history/es/createHashHistory.js
var createHashHistory__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var createHashHistory_HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory_createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant_browser_default()(canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    browser_default()(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = PathUtils_stripBasename(path, basename);

    return LocationUtils_createLocation(path);
  };

  var transitionManager = es_createTransitionManager();

  var setState = function setState(nextState) {
    createHashHistory__extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && LocationUtils_locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + createPath(location));
  };

  var push = function push(path, state) {
    browser_default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = LocationUtils_createLocation(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        browser_default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    browser_default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = LocationUtils_createLocation(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    browser_default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      addEventListener(window, createHashHistory_HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      removeEventListener(window, createHashHistory_HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ var es_createHashHistory = (createHashHistory_createHashHistory);
// CONCATENATED MODULE: /apps/node_modules/history/es/createMemoryHistory.js
var createMemoryHistory__typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createMemoryHistory__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory_createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = es_createTransitionManager();

  var setState = function setState(nextState) {
    createMemoryHistory__extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? LocationUtils_createLocation(entry, undefined, createKey()) : LocationUtils_createLocation(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = createPath;

  var push = function push(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createMemoryHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    browser_default()(!((typeof path === 'undefined' ? 'undefined' : createMemoryHistory__typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = LocationUtils_createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ var es_createMemoryHistory = (createMemoryHistory_createMemoryHistory);
// CONCATENATED MODULE: /apps/node_modules/history/es/index.js









// CONCATENATED MODULE: /apps/node_modules/react-router/es/Redirect.js
function Redirect__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Redirect__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Redirect__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect_Redirect = function (_React$Component) {
  Redirect__inherits(Redirect, _React$Component);

  function Redirect() {
    Redirect__classCallCheck(this, Redirect);

    return Redirect__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    invariant_browser_default()(this.context.router, 'You should not use <Redirect> outside a <Router>');

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = LocationUtils_createLocation(prevProps.to);
    var nextTo = LocationUtils_createLocation(this.props.to);

    if (LocationUtils_locationsAreEqual(prevTo, nextTo)) {
      browser_default()(false, 'You tried to redirect to the same route you\'re currently on: ' + ('"' + nextTo.pathname + nextTo.search + '"'));
      return;
    }

    this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;


    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(preact_compat_es["a" /* default */].Component);

Redirect_Redirect.propTypes = {
  push: prop_types_default.a.bool,
  from: prop_types_default.a.string,
  to: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]).isRequired
};
Redirect_Redirect.defaultProps = {
  push: false
};
Redirect_Redirect.contextTypes = {
  router: prop_types_default.a.shape({
    history: prop_types_default.a.shape({
      push: prop_types_default.a.func.isRequired,
      replace: prop_types_default.a.func.isRequired
    }).isRequired,
    staticContext: prop_types_default.a.object
  }).isRequired
};


/* harmony default export */ var es_Redirect = (Redirect_Redirect);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Redirect.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Redirect = (es_Redirect);
// EXTERNAL MODULE: /apps/node_modules/history/PathUtils.js
var PathUtils = __webpack_require__("../../node_modules/history/PathUtils.js");
var PathUtils_default = /*#__PURE__*/__webpack_require__.n(PathUtils);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/StaticRouter.js
var StaticRouter__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function StaticRouter__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function StaticRouter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function StaticRouter__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function StaticRouter__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;


  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var StaticRouter_addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return StaticRouter__extends({}, location, {
    pathname: Object(PathUtils["addLeadingSlash"])(basename) + location.pathname
  });
};

var StaticRouter_stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = Object(PathUtils["addLeadingSlash"])(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return StaticRouter__extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var StaticRouter_createLocation = function createLocation(location) {
  return typeof location === 'string' ? Object(PathUtils["parsePath"])(location) : normalizeLocation(location);
};

var StaticRouter_createURL = function createURL(location) {
  return typeof location === 'string' ? location : Object(PathUtils["createPath"])(location);
};

var StaticRouter_staticHandler = function staticHandler(methodName) {
  return function () {
    invariant_browser_default()(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter_StaticRouter = function (_React$Component) {
  StaticRouter__inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    StaticRouter__classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = StaticRouter__possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return Object(PathUtils["addLeadingSlash"])(_this.props.basename + StaticRouter_createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
      context.url = StaticRouter_createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = StaticRouter_addBasename(basename, StaticRouter_createLocation(location));
      context.url = StaticRouter_createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), StaticRouter__possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    browser_default()(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = StaticRouter__objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: StaticRouter_stripBasename(basename, StaticRouter_createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: StaticRouter_staticHandler('go'),
      goBack: StaticRouter_staticHandler('goBack'),
      goForward: StaticRouter_staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return preact_compat_es["a" /* default */].createElement(es_Router, StaticRouter__extends({}, props, { history: history }));
  };

  return StaticRouter;
}(preact_compat_es["a" /* default */].Component);

StaticRouter_StaticRouter.propTypes = {
  basename: prop_types_default.a.string,
  context: prop_types_default.a.object.isRequired,
  location: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object])
};
StaticRouter_StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter_StaticRouter.childContextTypes = {
  router: prop_types_default.a.object.isRequired
};


/* harmony default export */ var es_StaticRouter = (StaticRouter_StaticRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/StaticRouter.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_StaticRouter = (es_StaticRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router/es/Switch.js
function Switch__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Switch__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Switch__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch_Switch = function (_React$Component) {
  Switch__inherits(Switch, _React$Component);

  function Switch() {
    Switch__classCallCheck(this, Switch);

    return Switch__possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    invariant_browser_default()(this.context.router, 'You should not use <Switch> outside a <Router>');
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    browser_default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    browser_default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    preact_compat_es["a" /* default */].Children.forEach(children, function (element) {
      if (!preact_compat_es["a" /* default */].isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          sensitive = _element$props.sensitive,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? es_matchPath(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;
      }
    });

    return match ? preact_compat_es["a" /* default */].cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(preact_compat_es["a" /* default */].Component);

Switch_Switch.contextTypes = {
  router: prop_types_default.a.shape({
    route: prop_types_default.a.object.isRequired
  }).isRequired
};
Switch_Switch.propTypes = {
  children: prop_types_default.a.node,
  location: prop_types_default.a.object
};


/* harmony default export */ var es_Switch = (Switch_Switch);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/Switch.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_Switch = (es_Switch);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/matchPath.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_matchPath = (es_matchPath);
// EXTERNAL MODULE: /apps/node_modules/hoist-non-react-statics/index.js
var hoist_non_react_statics = __webpack_require__("../../node_modules/hoist-non-react-statics/index.js");
var hoist_non_react_statics_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics);

// CONCATENATED MODULE: /apps/node_modules/react-router/es/withRouter.js
var withRouter__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function withRouter__objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A public higher-order component to access the imperative API
 */
var withRouter_withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = withRouter__objectWithoutProperties(props, ['wrappedComponentRef']);

    return preact_compat_es["a" /* default */].createElement(es_Route, { render: function render(routeComponentProps) {
        return preact_compat_es["a" /* default */].createElement(Component, withRouter__extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: prop_types_default.a.func
  };

  return hoist_non_react_statics_default()(C, Component);
};

/* harmony default export */ var es_withRouter = (withRouter_withRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/withRouter.js
// Written in this round about way for babel-transform-imports


/* harmony default export */ var react_router_dom_es_withRouter = (es_withRouter);
// CONCATENATED MODULE: /apps/node_modules/react-router-dom/es/index.js


























// EXTERNAL MODULE: /apps/node_modules/classnames/bind.js
var bind = __webpack_require__("../../node_modules/classnames/bind.js");
var bind_default = /*#__PURE__*/__webpack_require__.n(bind);

// EXTERNAL MODULE: /apps/packages/components/src/button.scss
var src_button = __webpack_require__("../../packages/components/src/button.scss");
var button_default = /*#__PURE__*/__webpack_require__.n(src_button);

// CONCATENATED MODULE: /apps/packages/components/src/Button.tsx
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const cx = bind["bind"](src_button);
const Button = (_a) => {
    var { class: className, secondary = false } = _a, restProps = __rest(_a, ["class", "secondary"]);
    return (Object(preact_esm["c" /* h */])("button", Object.assign({ class: cx(src_button["self"], className, { primary: !secondary, secondary }) }, restProps)));
};
/* harmony default export */ var src_Button = (Button);

// CONCATENATED MODULE: ./src/pages/Home.tsx



const Home = () => (Object(preact_esm["c" /* h */])("div", null,
    Object(preact_esm["c" /* h */])(es_Link, { to: "/whitelist" },
        Object(preact_esm["c" /* h */])(src_Button, null, "Whitelist")),
    Object(preact_esm["c" /* h */])(es_Link, { to: "/status" },
        Object(preact_esm["c" /* h */])(src_Button, null, "Status")),
    Object(preact_esm["c" /* h */])(es_Link, { to: "/linklist" },
        Object(preact_esm["c" /* h */])(src_Button, null, "LinkList"))));
/* harmony default export */ var pages_Home = (Home);

// EXTERNAL MODULE: /apps/node_modules/web3/index.js
var node_modules_web3 = __webpack_require__("../../node_modules/web3/index.js");
var web3_default = /*#__PURE__*/__webpack_require__.n(node_modules_web3);

// CONCATENATED MODULE: /apps/packages/utils/src/web3.ts

let web3_web3;
if (typeof window.web3 !== 'undefined') {
    web3_web3 = new node_modules_web3(window.web3.currentProvider);
}
else {
    web3_web3 = new node_modules_web3();
}
/* harmony default export */ var src_web3 = (web3_web3);

// CONCATENATED MODULE: /apps/packages/utils/src/index.ts


// EXTERNAL MODULE: /apps/packages/components/src/link.scss
var src_link = __webpack_require__("../../packages/components/src/link.scss");
var link_default = /*#__PURE__*/__webpack_require__.n(src_link);

// CONCATENATED MODULE: /apps/packages/components/src/Link.tsx



const Link_cx = bind["bind"](src_link);
const stopPropagation = (e) => e.stopPropagation();
const src_Link_Link = ({ class: className, link, lines = 2, style: externalStyle }) => {
    if (!(lines === 2 || lines === 8)) {
        throw new Error('Only 2 and 8 lines links are available');
    }
    return (Object(preact_esm["c" /* h */])("div", { class: bind(src_link["self"], className), style: externalStyle },
        Object(preact_esm["c" /* h */])("div", { class: src_link["title"] }, link.title),
        Object(preact_esm["c" /* h */])("div", { class: Link_cx('summary', { lines2: lines === 2, lines8: lines === 8 }) }, link.summary),
        Object(preact_esm["c" /* h */])("a", { class: src_link["link"], target: "_blank", href: link.target, onClick: stopPropagation }, link.target)));
};
/* harmony default export */ var src_Link = (src_Link_Link);

// EXTERNAL MODULE: /apps/node_modules/classnames/index.js
var classnames = __webpack_require__("../../node_modules/classnames/index.js");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: /apps/packages/components/src/paper.scss
var paper = __webpack_require__("../../packages/components/src/paper.scss");
var paper_default = /*#__PURE__*/__webpack_require__.n(paper);

// CONCATENATED MODULE: /apps/packages/components/src/Paper.tsx
var Paper___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const Paper = (_a) => {
    var { class: className } = _a, restProps = Paper___rest(_a, ["class"]);
    return (Object(preact_esm["c" /* h */])("div", Object.assign({}, restProps, { class: classnames(className, paper["self"]) })));
};
/* harmony default export */ var src_Paper = (Paper);

// EXTERNAL MODULE: /apps/packages/components/src/loader.scss
var loader = __webpack_require__("../../packages/components/src/loader.scss");
var loader_default = /*#__PURE__*/__webpack_require__.n(loader);

// CONCATENATED MODULE: /apps/packages/components/src/Loader.tsx



const Loader = ({ class: className }) => {
    return Object(preact_esm["c" /* h */])("div", { class: classnames(loader["self"], className) });
};
/* harmony default export */ var src_Loader = (Loader);

// EXTERNAL MODULE: /apps/packages/components/src/textWithLabel.scss
var textWithLabel = __webpack_require__("../../packages/components/src/textWithLabel.scss");
var textWithLabel_default = /*#__PURE__*/__webpack_require__.n(textWithLabel);

// EXTERNAL MODULE: /apps/packages/components/src/label.scss
var src_label = __webpack_require__("../../packages/components/src/label.scss");
var label_default = /*#__PURE__*/__webpack_require__.n(src_label);

// CONCATENATED MODULE: /apps/packages/components/src/Label.tsx


const Label = (props) => {
    if (props && props.children) {
        return Object(preact_esm["c" /* h */])("p", { class: src_label["self"] }, props.children);
    }
    return Object(preact_esm["c" /* h */])("p", { class: src_label["self"] });
};
/* harmony default export */ var src_Label = (Label);

// CONCATENATED MODULE: /apps/packages/components/src/TextWithLabel.tsx




const TextWithLabel = ({ label, text, class: className, children }) => {
    return (Object(preact_esm["c" /* h */])("div", { class: classnames(textWithLabel["self"], className) },
        Object(preact_esm["c" /* h */])(src_Label, null, label),
        Object(preact_esm["c" /* h */])("p", { class: textWithLabel["text"] }, text || children)));
};
/* harmony default export */ var src_TextWithLabel = (TextWithLabel);

// CONCATENATED MODULE: /apps/packages/components/src/Svg.tsx

const getSvgContentRegxp = /<svg[^>]*>(.*)<\/svg>/;
const Svg = ({ svg, size, viewBox, class: className }) => {
    let svgContent;
    const regexpResult = getSvgContentRegxp.exec(svg);
    if (regexpResult) {
        svgContent = regexpResult[1];
    }
    return (Object(preact_esm["c" /* h */])("svg", { class: className, style: { width: size }, alt: name, dangerouslySetInnerHTML: { __html: svgContent }, viewBox: viewBox, xmlns: "http://www.w3.org/2000/svg" }));
};
/* harmony default export */ var src_Svg = (Svg);

// EXTERNAL MODULE: /apps/node_modules/open-iconic/font/css/open-iconic.min.css
var open_iconic_min = __webpack_require__("../../node_modules/open-iconic/font/css/open-iconic.min.css");
var open_iconic_min_default = /*#__PURE__*/__webpack_require__.n(open_iconic_min);

// EXTERNAL MODULE: /apps/packages/components/src/icon.scss
var src_icon = __webpack_require__("../../packages/components/src/icon.scss");
var icon_default = /*#__PURE__*/__webpack_require__.n(src_icon);

// CONCATENATED MODULE: /apps/packages/components/src/Icon.tsx
var Icon___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};




const Icon = (_a) => {
    var { name, class: className } = _a, restProps = Icon___rest(_a, ["name", "class"]);
    return (Object(preact_esm["c" /* h */])("span", Object.assign({ class: classnames(src_icon["self"], className, 'oi'), "data-glyph": name, "aria-hidden": "true" }, restProps)));
};
/* harmony default export */ var src_Icon = (Icon);

// EXTERNAL MODULE: /apps/packages/components/src/tooltip.scss
var tooltip = __webpack_require__("../../packages/components/src/tooltip.scss");
var tooltip_default = /*#__PURE__*/__webpack_require__.n(tooltip);

// CONCATENATED MODULE: /apps/packages/components/src/Tooltip.tsx



const Tooltip = ({ class: className, style: externalStyle, text, children }) => (Object(preact_esm["c" /* h */])("div", { style: externalStyle, class: classnames(tooltip["self"], className) },
    children,
    text && Object(preact_esm["c" /* h */])("div", { class: tooltip["text"] }, text)));
/* harmony default export */ var src_Tooltip = (Tooltip);

// EXTERNAL MODULE: ./src/pages/Status/components/steps.scss
var steps = __webpack_require__("./src/pages/Status/components/steps.scss");
var steps_default = /*#__PURE__*/__webpack_require__.n(steps);

// CONCATENATED MODULE: ./src/pages/Status/components/Steps.tsx






const Steps_cx = bind["bind"](steps);
const cubeSvg = __webpack_require__("../../node_modules/svg-inline-loader/index.js?removeTags=true&removeSVGTagAttrs=true!./images/cube.svg");
const Step = ({ icon, state, children }) => (Object(preact_esm["c" /* h */])("div", { class: Steps_cx(steps["step"], { [state]: true }) },
    Object(preact_esm["c" /* h */])("div", { class: steps["icon"] }, icon),
    Object(preact_esm["c" /* h */])("div", { class: steps["content"] }, children)));
const Steps = ({ context, linkId, link, blockchainState }) => {
    let step0State;
    let step0Reason;
    if (blockchainState.web3Available) {
        if (blockchainState.blockNumber) {
            step0State = 'done';
        }
        else {
            step0State = 'waiting';
            step0Reason = 'Waiting for blockchain';
        }
    }
    else {
        step0State = 'disabled';
        step0Reason = 'Web is unavailable';
    }
    const step1State = link ? 'done' : 'waiting';
    const step2State = link && link.whitelisted ? 'done' : 'waiting';
    const [network] = context.split(':');
    const networkPrefix = network !== 'eth' ? `${network}.` : '';
    const [, tx] = linkId.split(':');
    const etherscanUrl = link ? `https://${networkPrefix}etherscan.io/tx/${tx}` : '';
    return (Object(preact_esm["c" /* h */])("div", { class: steps["self"] },
        Object(preact_esm["c" /* h */])("div", { class: steps["progressCotainer"] },
            Object(preact_esm["c" /* h */])("div", { class: steps["progress"] })),
        Object(preact_esm["c" /* h */])("div", { class: steps["stepsContainer"] },
            Object(preact_esm["c" /* h */])(Step, { state: step0State, icon: Object(preact_esm["c" /* h */])(src_Tooltip, { text: step0Reason },
                    Object(preact_esm["c" /* h */])(src_Icon, { class: steps["icon"], name: "eye" })) },
                Object(preact_esm["c" /* h */])("p", null, "Visible on blockchain"),
                Object(preact_esm["c" /* h */])("a", { href: etherscanUrl, target: "_blank" },
                    "Etherscan ",
                    Object(preact_esm["c" /* h */])(src_Icon, { name: "external-link" }))),
            Object(preact_esm["c" /* h */])(Step, { state: step1State, icon: Object(preact_esm["c" /* h */])(src_Svg, { svg: cubeSvg, size: "1.2em", viewBox: "0 0 23 27" }) },
                Object(preact_esm["c" /* h */])("p", null, "Userfeeds Address"),
                Object(preact_esm["c" /* h */])("span", null, "Visible to publisher")),
            Object(preact_esm["c" /* h */])(Step, { state: step2State, icon: Object(preact_esm["c" /* h */])(src_Icon, { class: steps["icon"], name: "check" }) },
                Object(preact_esm["c" /* h */])("p", null, "Put on whitelist"),
                Object(preact_esm["c" /* h */])("span", null, "All set!")))));
};
/* harmony default export */ var components_Steps = (Steps);

// EXTERNAL MODULE: ./src/pages/Status/Status.scss
var Status_Status = __webpack_require__("./src/pages/Status/Status.scss");
var Status_default = /*#__PURE__*/__webpack_require__.n(Status_Status);

// CONCATENATED MODULE: ./src/pages/Status/index.tsx
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









const heartSvg = __webpack_require__("./images/heart.svg");
const getTransactionReceipt = (tx) => {
    return new Promise((resolve, reject) => {
        src_web3.eth.getTransactionReceipt(tx, (error, result) => {
            if (error) {
                return reject(error);
            }
            resolve(result);
        });
    });
};
const getBlockNumber = () => {
    return new Promise((resolve, reject) => {
        src_web3.eth.getBlockNumber((error, currentBlockNumber) => {
            if (error) {
                return reject(error);
            }
            resolve(currentBlockNumber);
        });
    });
};
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
class pages_Status_Status extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._fetchLinks = (context, algorithm, whitelist) => __awaiter(this, void 0, void 0, function* () {
            const baseURL = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/`)
                    .then((res) => res.json());
                const whitelistedLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/?whitelist=${whitelist}`)
                    .then((res) => res.json());
                const [allLinks, whitelistedLinks] = yield Promise.all([allLinksRequest,
                    whitelistedLinksRequest]);
                const links = allLinks.items.map((link) => {
                    const whitelisted = whitelistedLinks.items.find((a) => link.id === a.id);
                    return Object.assign({}, link, { whitelisted: !!whitelisted });
                });
                return links;
            }
            catch (_) {
                return [];
            }
        });
        this._observeBlockchainState = (linkId) => __awaiter(this, void 0, void 0, function* () {
            if (!src_web3.isConnected()) {
                return this.setState({ blockchain: Object.assign({}, this.state.blockchain, { web3Available: false }) });
            }
            this.setState({ blockchain: Object.assign({}, this.state.blockchain, { web3Available: true }) });
            const [, tx] = linkId.split(':');
            let receipt;
            do {
                receipt = yield getTransactionReceipt(tx);
                yield wait(1000);
            } while (!receipt);
            const currentBlockNumber = yield getBlockNumber();
            this.setState({
                blockchain: Object.assign({}, this.state.blockchain, { blockNumber: receipt.blockNumber, currentBlockNumber }),
            });
            while (true) {
                yield wait(10000);
                const currentBlockNumber = yield getBlockNumber();
                this.setState({ blockchain: Object.assign({}, this.state.blockchain, { currentBlockNumber }) });
            }
        });
        this._findLinkById = (linkId) => (links) => {
            const link = links.find((l) => l.id === linkId);
            this.setState({ link });
            return link;
        };
        const params = new URLSearchParams(props.location.search);
        const context = params.get('context') || '';
        const algorithm = params.get('algorithm') || '';
        const whitelist = params.get('whitelist') || '';
        const linkId = params.get('linkId') || '';
        const publisherNote = params.get('publisherNote') || '';
        const widgetLocation = params.get('widgetLocation') || '';
        this.state = {
            linkId,
            context,
            algorithm,
            whitelist,
            publisherNote,
            widgetLocation,
            blockchain: {
                web3Available: false,
                blockNumber: null,
                currentBlockNumber: null,
            },
        };
        this._observeBlockchainState(linkId);
        this._fetchLinks(context, algorithm, whitelist)
            .then(this._findLinkById(linkId))
            .then((link) => {
            if (!link) {
                const setTimeoutForFetch = () => {
                    setTimeout(() => {
                        this._fetchLinks(context, algorithm, whitelist)
                            .then(this._findLinkById(linkId))
                            .then((link) => !link && setTimeoutForFetch());
                    }, 5000);
                };
                setTimeoutForFetch();
            }
        });
    }
    render() {
        if (!this.state.context) {
            return null;
        }
        const { linkId, context, link, blockchain, widgetLocation } = this.state;
        return (Object(preact_esm["c" /* h */])("div", { class: Status_Status["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Status_Status["preview"] },
                link && Object(preact_esm["c" /* h */])(src_Link, { link: link }),
                !link && Object(preact_esm["c" /* h */])("div", { class: Status_Status["loader"] },
                    Object(preact_esm["c" /* h */])(src_Loader, null))),
            Object(preact_esm["c" /* h */])(src_Paper, { class: Status_Status["content"] },
                Object(preact_esm["c" /* h */])("img", { src: heartSvg }),
                Object(preact_esm["c" /* h */])("h2", null, "Your link has been succesfully submited!"),
                Object(preact_esm["c" /* h */])("p", null, "In order to track its progress please save the link"),
                Object(preact_esm["c" /* h */])(src_TextWithLabel, { class: Status_Status["label"], label: "Link status:" },
                    Object(preact_esm["c" /* h */])("div", { class: Status_Status["linkLabel"] },
                        Object(preact_esm["c" /* h */])("a", { class: Status_Status["link"], href: window.location.href }, window.location.href),
                        Object(preact_esm["c" /* h */])(src_Button, { secondary: true, class: Status_Status["addBookmark"] }, "Add to bookmarks"))),
                Object(preact_esm["c" /* h */])(src_TextWithLabel, { class: Status_Status["label"], label: "Widget location:" },
                    Object(preact_esm["c" /* h */])("a", { href: widgetLocation }, widgetLocation)),
                Object(preact_esm["c" /* h */])(components_Steps, { linkId: linkId, context: context, link: link, blockchainState: blockchain }))));
    }
}

// EXTERNAL MODULE: /apps/node_modules/@userfeeds/core/index.js
var core = __webpack_require__("../../node_modules/@userfeeds/core/index.js");
var core_default = /*#__PURE__*/__webpack_require__.n(core);

// EXTERNAL MODULE: /apps/node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__("../../node_modules/lodash.debounce/index.js");
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);

// EXTERNAL MODULE: /apps/packages/components/src/input.scss
var input = __webpack_require__("../../packages/components/src/input.scss");
var input_default = /*#__PURE__*/__webpack_require__.n(input);

// CONCATENATED MODULE: /apps/packages/components/src/Input.tsx
var Input___rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};



const Input_cx = bind["bind"](input);
class Input_Input extends preact_esm["a" /* Component */] {
    constructor() {
        super(...arguments);
        this._onInputRef = (ref) => this.input = ref;
        this._onPlaceholderClick = () => {
            if (this.input) {
                this.input.focus();
            }
        };
    }
    render(_a) {
        var { class: className, placeholder, errorMessage, value, multiline, disabled = false } = _a, restProps = Input___rest(_a, ["class", "placeholder", "errorMessage", "value", "multiline", "disabled"]);
        return (Object(preact_esm["c" /* h */])("div", { class: Input_cx(input["self"], className, { invalid: !!errorMessage }) },
            !multiline ? (Object(preact_esm["c" /* h */])("input", Object.assign({ ref: this._onInputRef, class: input["input"], value: value, disabled: disabled, required: true }, restProps))) : (Object(preact_esm["c" /* h */])("textarea", Object.assign({ ref: this._onInputRef, class: input["input"], value: value, disabled: disabled, required: true, rows: 3 }, restProps))),
            Object(preact_esm["c" /* h */])("span", { class: input["placeholder"], onClick: this._onPlaceholderClick }, placeholder),
            errorMessage && Object(preact_esm["c" /* h */])("span", { class: input["error"] }, errorMessage)));
    }
}

// EXTERNAL MODULE: /apps/packages/components/src/adsList.scss
var adsList = __webpack_require__("../../packages/components/src/adsList.scss");
var adsList_default = /*#__PURE__*/__webpack_require__.n(adsList);

// CONCATENATED MODULE: /apps/packages/components/src/AdsList.tsx



const AdsList_noop = () => null;
const Ad = ({ ad, onClick }) => (Object(preact_esm["c" /* h */])("div", { class: adsList["row"] },
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])("div", null,
            "URL: ",
            Object(preact_esm["c" /* h */])("a", { href: ad.target }, ad.target)),
        Object(preact_esm["c" /* h */])("div", null,
            "score: ",
            web3.fromWei(ad.score, 'ether')),
        Object(preact_esm["c" /* h */])("div", null, ad.title),
        Object(preact_esm["c" /* h */])("div", null, ad.summary)),
    Object(preact_esm["c" /* h */])("div", { class: adsList["button"] },
        Object(preact_esm["c" /* h */])(src_Button, { onClick: onClick.bind(null, ad), disabled: ad.whitelisted }, "Add to whitelist"))));
const AdsList = ({ ads = [], onItemClick = AdsList_noop }) => (Object(preact_esm["c" /* h */])("div", { class: adsList["self"] }, ads.map((ad) => (Object(preact_esm["c" /* h */])(Ad, { ad: ad, onClick: onItemClick })))));
/* harmony default export */ var src_AdsList = (AdsList);

// EXTERNAL MODULE: ./src/pages/Whitelist.scss
var Whitelist = __webpack_require__("./src/pages/Whitelist.scss");
var Whitelist_default = /*#__PURE__*/__webpack_require__.n(Whitelist);

// CONCATENATED MODULE: ./src/pages/Whitelist.tsx
var Whitelist___awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







class Whitelist_Creator extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._onContextChange = (e) => {
            this.setState({ context: e.target.value });
            this._fetchLinks();
        };
        this._onWhitelistChange = (e) => {
            this.setState({ whitelist: e.target.value });
            this._fetchLinks();
        };
        this._fetchLinks = lodash_debounce_default()(() => Whitelist___awaiter(this, void 0, void 0, function* () {
            const { context, algorithm, whitelist } = this.state;
            this.setState({ fetching: true });
            const baseURL = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/`)
                    .then((res) => res.json());
                const whitelistedLinksRequest = fetch(`${baseURL}/${context}/${algorithm}/?whitelist=${whitelist}`)
                    .then((res) => res.json());
                const [allLinks, whitelistedLinks] = yield Promise.all([
                    allLinksRequest,
                    whitelistedLinksRequest,
                ]);
                const links = allLinks.items.map((link) => {
                    const whitelisted = !!whitelistedLinks.items.find((a) => link.id === a.id);
                    return Object.assign({}, link, { whitelisted });
                });
                this.setState({ links, fetching: false });
            }
            catch (_) {
                this.setState({ fetching: false });
            }
        }), 500);
        this._onLinkClick = (link) => {
            const [_, address] = this.state.whitelist.split(':');
            const claim = {
                claim: { target: link.id },
                credits: [{
                        type: 'interface',
                        value: window.location.href,
                    }],
            };
            core_default.a.ethereum.claims.sendClaim(address, claim);
        };
        const params = new URLSearchParams(props.location.search);
        this.state = {
            links: [],
            fetching: false,
            context: params.get('context') || '',
            algorithm: params.get('algorithm') || 'links',
            whitelist: params.get('whitelist') || '',
            contextFromParams: params.has('context'),
            whitelistFromParams: params.has('whitelist'),
        };
    }
    componentWillMount() {
        if (this.state.contextFromParams) {
            this._fetchLinks();
        }
    }
    render() {
        return (Object(preact_esm["c" /* h */])("div", { class: Whitelist["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Whitelist["paper"] },
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Userfeed ID", value: this.state.context, onInput: this._onContextChange, disabled: this.state.contextFromParams }),
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Whitelist ID", value: this.state.whitelist, onInput: this._onWhitelistChange, disabled: this.state.whitelistFromParams }),
                Object(preact_esm["c" /* h */])(src_AdsList, { ads: this.state.links, onItemClick: this._onLinkClick }))));
    }
}

// EXTERNAL MODULE: /apps/packages/components/src/linkList.scss
var linkList = __webpack_require__("../../packages/components/src/linkList.scss");
var linkList_default = /*#__PURE__*/__webpack_require__.n(linkList);

// CONCATENATED MODULE: /apps/packages/components/src/LinkList.tsx


const LinkList_noop = () => null;
const LinkList_Link = ({ link }) => (Object(preact_esm["c" /* h */])("div", { class: linkList["row"] },
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])("div", null,
            "URL: ",
            Object(preact_esm["c" /* h */])("a", { href: link.target }, link.target)),
        Object(preact_esm["c" /* h */])("div", null, link.summary))));
const LinkList_LinkList = ({ links = [] }) => (Object(preact_esm["c" /* h */])("div", { class: linkList["self"] }, links.map((link) => (Object(preact_esm["c" /* h */])(LinkList_Link, { link: link })))));
/* harmony default export */ var src_LinkList = (LinkList_LinkList);

// CONCATENATED MODULE: ./src/pages/LinkList.tsx
var LinkList___awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






class pages_LinkList_LinkList extends preact_esm["a" /* Component */] {
    constructor(props) {
        super(props);
        this._onContextChange = (e) => {
            this.setState({ context: e.target.value });
            this._fetchLinks();
        };
        this._fetchLinks = lodash_debounce_default()(() => LinkList___awaiter(this, void 0, void 0, function* () {
            const { context } = this.state;
            this.setState({ fetching: true });
            const fetchUrl = 'https://api.userfeeds.io/ranking';
            try {
                const allLinksRequest = fetch(`${fetchUrl}/${context}/authored/?type=link`)
                    .then((res) => res.json());
                const [allLinks] = yield Promise.all([allLinksRequest]);
                this.setState({ links: allLinks.items, fetching: false });
                return allLinks;
            }
            catch (_) {
                this.setState({ fetching: false });
                return null;
            }
        }), 500);
        const params = new URLSearchParams(props.location.search);
        this.state = {
            links: [],
            fetching: false,
            context: params.get('context') || '',
            algorithm: params.get('algorithm') || 'links',
            contextFromParams: params.has('context'),
        };
    }
    componentWillMount() {
        if (this.state.contextFromParams) {
            this._fetchLinks();
        }
    }
    render() {
        return (Object(preact_esm["c" /* h */])("div", { class: Whitelist["self"] },
            Object(preact_esm["c" /* h */])(src_Paper, { class: Whitelist["paper"] },
                Object(preact_esm["c" /* h */])(Input_Input, { placeholder: "Advertiser ID", value: this.state.context, onInput: this._onContextChange, disabled: this.state.contextFromParams }),
                Object(preact_esm["c" /* h */])(src_LinkList, { links: this.state.links }))));
    }
}

// CONCATENATED MODULE: ./src/App.tsx






const App = () => (Object(preact_esm["c" /* h */])(es_HashRouter, null,
    Object(preact_esm["c" /* h */])("div", null,
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { exact: true, path: "/", component: pages_Home }),
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { path: "/status", component: pages_Status_Status }),
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { path: "/whitelist", component: Whitelist_Creator }),
        Object(preact_esm["c" /* h */])(react_router_dom_es_Route, { path: "/linklist", component: pages_LinkList_LinkList }))));
/* harmony default export */ var src_App = (App);

// EXTERNAL MODULE: ./styles/all.scss
var styles_all = __webpack_require__("./styles/all.scss");
var all_default = /*#__PURE__*/__webpack_require__.n(styles_all);

// CONCATENATED MODULE: ./src/index.tsx




const root = document.querySelector('.root');
if (root) {
    Object(preact_esm["e" /* render */])(Object(preact_esm["c" /* h */])(src_App, null), root);
}


/***/ }),

/***/ "./src/pages/Status/Status.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/Status.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Status.scss", function() {
			var newContent = require("!!../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Status.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/pages/Status/components/steps.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true,\"plugins\":[null]}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Status/components/steps.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./steps.scss", function() {
			var newContent = require("!!../../../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./steps.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/pages/Whitelist.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/pages/Whitelist.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Whitelist.scss", function() {
			var newContent = require("!!../../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./Whitelist.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./styles/all.scss":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("../../node_modules/typings-for-css-modules-loader/lib/index.js?{\"namedExport\":true,\"modules\":true,\"importLoaders\":1,\"sourceMap\":true,\"camelCase\":true,\"localIdentName\":\"[name]__[local]--[hash:base64:5]\"}!../../node_modules/postcss-loader/lib/index.js?{\"sourceMap\":true}!../../node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./styles/all.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("../../node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./all.scss", function() {
			var newContent = require("!!../../../node_modules/typings-for-css-modules-loader/lib/index.js??ref--1-1!../../../node_modules/postcss-loader/lib/index.js??ref--1-2!../../../node_modules/sass-loader/lib/loader.js??ref--1-3!./all.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzY0MmI5YTU4NGViNzBmNDYxODQiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL2V0aGVyZXVtQ2xhaW1zLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy91dGlscy9jb250cmFjdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9iaW5kLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy11dGYxNi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jZmIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWVjYi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtYW5zaXg5MjMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzEwMTI2LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtbm9wYWRkaW5nLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC16ZXJvcGFkZGluZy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LWxlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JpcGVtZDE2MC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3RyaXBsZWRlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3M/YWM1YSIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3M/Y2U2ZSIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuZW90Iiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5vdGYiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLnN2ZyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMudHRmIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy53b2ZmIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJlYWN0LWNvbXBhdC9kaXN0L3ByZWFjdC1jb21wYXQuZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QuZXNtLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL2ltYWdlcy9jdWJlLnN2ZyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzPzE4YWQiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2J1dHRvbi5zY3NzPzZkZGMiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2ljb24uc2Nzcz8yODNhIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzP2Y0MmQiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3M/M2MyZSIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzPzc1ZTIiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3M/MTc3NyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3M/OWI5MiIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2Nzcz82YTEwIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90ZXh0V2l0aExhYmVsLnNjc3M/ZmI3ZCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdG9vbHRpcC5zY3NzP2UxNTciLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2Nzcz81NDlmIiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9zdGVwcy5zY3NzP2MxY2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzP2M3ODQiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL2FsbC5zY3NzPzQyN2YiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy91dGY4L3V0ZjguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb24iLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2FkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9ib29sLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9jb2Rlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2R5bmFtaWNieXRlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Zvcm1hdHRlcnMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9pbnQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9wYXJhbS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3JlYWwuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS90eXBlLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdWludC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3VyZWFsLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvYnJvd3Nlci14aHIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9zaGEzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi92ZXJzaW9uLmpzb24iLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9hbGxldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2JhdGNoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9jb250cmFjdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXJyb3JzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9ldmVudC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXh0ZW5kLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Zvcm1hdHRlcnMuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9odHRwcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2liYW4uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2lwY3Byb3ZpZGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9qc29ucnBjLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZGIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZXRoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL25ldC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9wZXJzb25hbC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zaGguanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvc3dhcm0uanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvd2F0Y2hlcy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbmFtZXJlZy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3JlcXVlc3RtYW5hZ2VyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvdHJhbnNmZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMveGhyMi9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2NzcyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rLnNjc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xvYWRlci5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9wYXBlci5zY3NzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90ZXh0V2l0aExhYmVsLnNjc3MiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2NzcyIsIndlYnBhY2s6Ly8vLi9pbWFnZXMvaGVhcnQuc3ZnIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9MaW5rLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTWVtb3J5Um91dGVyLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL05hdkxpbmsuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qcyIsIndlYnBhY2s6Ly8vL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzIiwid2VicGFjazovLy8vYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9CdXR0b24udHN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9Ib21lLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvdXRpbHMvc3JjL3dlYjMudHMiLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL3V0aWxzL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGluay50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1BhcGVyLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTG9hZGVyLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGFiZWwudHN4Iiwid2VicGFjazovLy8vYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9UZXh0V2l0aExhYmVsLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvU3ZnLnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvSWNvbi50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1Rvb2x0aXAudHN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9TdGVwcy50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1N0YXR1cy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0lucHV0LnRzeCIsIndlYnBhY2s6Ly8vL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvQWRzTGlzdC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1doaXRlbGlzdC50c3giLCJ3ZWJwYWNrOi8vLy9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0xpbmtMaXN0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvTGlua0xpc3QudHN4Iiwid2VicGFjazovLy8uL3NyYy9BcHAudHN4Iiwid2VicGFjazovLy8uL3NyYy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL2FsbC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7OztBQ05BLE9BQU8sd0JBQXdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9DQUFvQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0NBQW9DO0FBQ3pDLEtBQUssK0JBQStCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUssa0RBQWtEO0FBQ3ZELEtBQUssb0RBQW9EO0FBQ3pELEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsS0FBSyxrREFBa0Q7QUFDdkQsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDbEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNqSEE7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLHdDQUF3QyxlQUFlO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFD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LE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUIsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixFQUFFOzs7QUFHRixDQUFDLEc7Ozs7Ozs7QUM5SUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDakJELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDM0VELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUMzUUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQzdFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDbkhELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUN6REQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDdkNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQ3JERCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUNoREQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDM0NELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDdkNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7O0FBR0E7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUNsVUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUMsRzs7Ozs7OztBQ2xGRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDbFVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtB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QUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCLEVBQUU7QUFDckU7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbERBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDRkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FB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LHFCQUFxQjs7QUFFMVY7Ozs7Ozs7O3NEQ1BBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsS0FBSztBQUNMLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0SkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdEZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDclRBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCx3QkFBd0IsRUFBRTtBQUNqRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLCtCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7Ozs7Ozs7O0FDOUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEIsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUNuUEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNsVEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLDBFQUEwRSx1QkFBdUIsRUFBRTtBQUNuRztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsdUJBQXVCLEVBQUU7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7Ozs7Ozs7O0FDMVJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsQ0FBQztBQUNELDBHQUE0RDtBQUM1RDs7QUFFQSx5RUFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDNUpBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCLEVBQUUsYUFBYSxHQUFHLFVBQVUsTUFBTTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUNqT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSyxFOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEtBQUssS0FBSztBQUN2QyxvQkFBb0IsYUFBYSxLQUFLLE9BQU8sT0FBTztBQUNwRCxvQkFBb0IsV0FBVyxLQUFLLE1BQU0sT0FBTztBQUNqRCxvQkFBb0IsV0FBVyxLQUFLLE1BQU0sT0FBTztBQUNqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCOztBQUVuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0M7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7OztBQUdqRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQzdNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7Ozs7Ozs7OztBQ25GQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ25LQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDakVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGNBQWMsRUFBRTtBQUMvRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaldBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ25EQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBOzs7Ozs7OztBQ2xIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDOUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTs7Ozs7Ozs7QUNoSkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6R0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3JDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQzlJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssRTtBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7QUFHMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULDRCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBOzs7Ozs7Ozs7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDUEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7Ozs7Ozs7O0FDMUZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBOzs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvYXBwcy9saW5rcy9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LnRzeFwiKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBjNjQyYjlhNTg0ZWI3MGY0NjE4NCIsIlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV0aGVyZXVtOiB7XG4gICAgY2xhaW1zOiByZXF1aXJlKCcuL3NyYy9ldGhlcmV1bUNsYWltcycpLFxuICB9LFxuICB1dGlsczogcmVxdWlyZSgnLi9zcmMvdXRpbHMnKSxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IHsgZ2V0Q3VycmVudE5ldHdvcmtOYW1lIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7XG4gIHBheWFibGVBYmksXG4gIG5vdHBheWFibGVBYmksXG4gIGdldENvbnRyYWN0QWRkcmVzcyxcbn0gPSByZXF1aXJlKCcuL3V0aWxzL2NvbnRyYWN0Jyk7XG5cbmZ1bmN0aW9uIHNlbmRQYXlhYmxlQ2xhaW0oYWRkcmVzcywgY2xhaW0sIHZhbHVlKSB7XG4gIGNvbnN0IGNvbnRyYWN0ID0gd2ViMy5ldGguY29udHJhY3QocGF5YWJsZUFiaSlcbiAgICAuYXQoZ2V0Q29udHJhY3RBZGRyZXNzKGdldEN1cnJlbnROZXR3b3JrTmFtZSgpLCB0cnVlKSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb250cmFjdC5wb3N0KFxuICAgICAgYWRkcmVzcyxcbiAgICAgIEpTT04uc3RyaW5naWZ5KGNsYWltKSxcbiAgICAgIHsgdmFsdWU6IHdlYjMudG9XZWkodmFsdWUsICdldGhlcicpIH0sXG4gICAgICAoZXJycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSxcbiAgICApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VuZE5vdHBheWFibGVDbGFpbShhZGRyZXNzLCBjbGFpbSkge1xuICBjb25zdCBjb250cmFjdCA9IHdlYjMuZXRoLmNvbnRyYWN0KG5vdHBheWFibGVBYmkpXG4gICAgLmF0KGdldENvbnRyYWN0QWRkcmVzcyhnZXRDdXJyZW50TmV0d29ya05hbWUoKSwgZmFsc2UpKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnRyYWN0LnBvc3QoXG4gICAgICBKU09OLnN0cmluZ2lmeShjbGFpbSksXG4gICAgICAoZXJycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSxcbiAgICApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VuZENsYWltKGFkZHJlc3MsIGNsYWltLCB2YWx1ZSkge1xuICBjb25zdCBwYXlhYmxlID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblxuICByZXR1cm4gcGF5YWJsZVxuICAgID8gc2VuZFBheWFibGVDbGFpbShhZGRyZXNzLCBjbGFpbSwgdmFsdWUpXG4gICAgOiBzZW5kTm90cGF5YWJsZUNsYWltKGFkZHJlc3MsIGNsYWltKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNlbmRDbGFpbSxcbiAgc2VuZFBheWFibGVDbGFpbSxcbiAgc2VuZE5vdHBheWFibGVDbGFpbSxcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL2V0aGVyZXVtQ2xhaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy9ldGhlcmV1bUNsYWltcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmNvbnN0IHBheWFibGVDb250cmFjdEFkZHJlc3NNYXBwaW5nID0ge1xuICByb3BzdGVuOiAnMHhhODQ1YzY4NmE2OTZjM2QzMzk4ODkxN2MzODdkOGFiOTM5YzY2MjI2JyxcbiAgcmlua2VieTogJzB4MGE0OGFjODI2M2Q5ZDc5NzY4ZDEwY2Y5ZDdlODJhMTljNDlmMDAwMicsXG59O1xuXG5jb25zdCBub3RwYXlhYmxlQ29udHJhY3RBZGRyZXNzTWFwcGluZyA9IHtcbiAgcm9wc3RlbjogJzB4NWMzZmU2Yjk0YjU3YzFlMjk0MDAwNDAzMzQwZjEyZjA4M2U3MWI4MycsXG4gIHJpbmtlYnk6ICcweDA5ZGNkZjM0ZTBjMjhiMTA2ZmRmZTUxMDA5Y2I3MWFlOTJiZjhiYmMnLFxufTtcblxuZnVuY3Rpb24gZ2V0Q29udHJhY3RBZGRyZXNzKG5ldHdvcmtOYW1lLCBwYXlhYmxlID0gdHJ1ZSkge1xuICBsZXQgY29udHJhY3Q7XG4gIGlmIChwYXlhYmxlKSB7XG4gICAgY29udHJhY3QgPSBwYXlhYmxlQ29udHJhY3RBZGRyZXNzTWFwcGluZ1tuZXR3b3JrTmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY29udHJhY3QgPSBub3RwYXlhYmxlQ29udHJhY3RBZGRyZXNzTWFwcGluZ1tuZXR3b3JrTmFtZV07XG4gIH1cblxuICBpZiAoIWNvbnRyYWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBpcyBub3QgYXZhaWxhYmxlJyk7XG4gIH1cblxuICByZXR1cm4gY29udHJhY3Q7XG59XG5cbmNvbnN0IHBheWFibGVBYmkgPSBbe1xuICBjb25zdGFudDogZmFsc2UsXG4gIGlucHV0czogW1xuICAgIHsgbmFtZTogJ3VzZXJmZWVkJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgeyBuYW1lOiAnZGF0YScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gIF0sXG4gIG5hbWU6ICdwb3N0JyxcbiAgb3V0cHV0czogW10sXG4gIHBheWFibGU6IHRydWUsXG4gIHR5cGU6ICdmdW5jdGlvbicsXG59LCB7XG4gIGFub255bW91czogZmFsc2UsXG4gIGlucHV0czogW1xuICAgIHsgbmFtZTogJ3NlbmRlcicsIHR5cGU6ICdhZGRyZXNzJywgaW5kZXhlZDogZmFsc2UgfSxcbiAgICB7IG5hbWU6ICd1c2VyZmVlZCcsIHR5cGU6ICdhZGRyZXNzJywgaW5kZXhlZDogZmFsc2UgfSxcbiAgICB7IG5hbWU6ICdkYXRhJywgdHlwZTogJ3N0cmluZycsIGluZGV4ZWQ6IGZhbHNlIH0sXG4gIF0sXG4gIG5hbWU6ICdDbGFpbScsXG4gIHR5cGU6ICdldmVudCcsXG59XTtcblxuY29uc3Qgbm90cGF5YWJsZUFiaSA9IFt7XG4gIGNvbnN0YW50OiBmYWxzZSxcbiAgaW5wdXRzOiBbXG4gICAgeyBuYW1lOiAnZGF0YScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gIF0sXG4gIG5hbWU6ICdwb3N0JyxcbiAgb3V0cHV0czogW10sXG4gIHBheWFibGU6IGZhbHNlLFxuICB0eXBlOiAnZnVuY3Rpb24nLFxufSwge1xuICBhbm9ueW1vdXM6IGZhbHNlLFxuICBpbnB1dHM6IFtcbiAgICB7IG5hbWU6ICdzZW5kZXInLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IGZhbHNlIH0sXG4gICAgeyBuYW1lOiAnZGF0YScsIHR5cGU6ICdzdHJpbmcnLCBpbmRleGVkOiBmYWxzZSB9LFxuICBdLFxuICBuYW1lOiAnQ2xhaW0nLFxuICB0eXBlOiAnZXZlbnQnXG59XTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBheWFibGVBYmksXG4gIG5vdHBheWFibGVBYmksXG4gIGdldENvbnRyYWN0QWRkcmVzcyxcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvQHVzZXJmZWVkcy9jb3JlL3NyYy91dGlscy9jb250cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvdXRpbHMvY29udHJhY3QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5jb25zdCBuZXR3b3JrTWFwcGluZyA9IHtcbiAgJzEnOiAnZXRoZXJldW0nLFxuICAnMyc6ICdyb3BzdGVuJyxcbiAgJzQnOiAncmlua2VieScsXG4gICc0Mic6ICdrb3ZhbicsXG59O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50TmV0d29ya05hbWUoKSB7XG4gIGlmICghd2ViMykge1xuICAgIHRocm93IG5ldyBFcnJvcignd2ViMyBub3QgYXZhaWxhYmxlJyk7XG4gIH1cblxuICByZXR1cm4gbmV0d29ya01hcHBpbmdbd2ViMy52ZXJzaW9uLm5ldHdvcmtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q3VycmVudE5ldHdvcmtOYW1lLFxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL0B1c2VyZmVlZHMvY29yZS9zcmMvdXRpbHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9AdXNlcmZlZWRzL2NvcmUvc3JjL3V0aWxzL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIChiNjQubGVuZ3RoICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBiaWdudW1iZXIuanMgdjIuMC43IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qcy9MSUNFTkNFICovXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qXG4gICAgICBiaWdudW1iZXIuanMgdjIuMC43XG4gICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxuICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXG4gICAgICBDb3B5cmlnaHQgKGMpIDIwMTUgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cbiAgICAgIE1JVCBFeHBhdCBMaWNlbmNlXG4gICAgKi9cblxuXG4gICAgdmFyIEJpZ051bWJlciwgY3J5cHRvLCBwYXJzZU51bWVyaWMsXG4gICAgICAgIGlzTnVtZXJpYyA9IC9eLT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxuICAgICAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbm90Qm9vbCA9ICcgbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQnLFxuICAgICAgICByb3VuZGluZ01vZGUgPSAncm91bmRpbmcgbW9kZScsXG4gICAgICAgIHRvb01hbnlEaWdpdHMgPSAnbnVtYmVyIHR5cGUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHMnLFxuICAgICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJyxcbiAgICAgICAgQkFTRSA9IDFlMTQsXG4gICAgICAgIExPR19CQVNFID0gMTQsXG4gICAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXG4gICAgICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXG4gICAgICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXG4gICAgICAgIFNRUlRfQkFTRSA9IDFlNyxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcbiAgICAgICAgICogdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLCBiZXlvbmQgd2hpY2ggYW5cbiAgICAgICAgICogZXhjZXB0aW9uIGlzIHRocm93biAoaWYgRVJST1JTIGlzIHRydWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcblxuXG4gICAgLypcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbm90aGVyKGNvbmZpZ09iaikge1xuICAgICAgICB2YXIgZGl2LFxuXG4gICAgICAgICAgICAvLyBpZCB0cmFja3MgdGhlIGNhbGxlciBmdW5jdGlvbiwgc28gaXRzIG5hbWUgY2FuIGJlIGluY2x1ZGVkIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgICAgaWQgPSAwLFxuICAgICAgICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUsXG4gICAgICAgICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxuXG5cbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRURJVEFCTEUgREVGQVVMVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuY29uZmlnLlxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xuICAgICAgICAgICAgICogdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxuICAgICAgICAgICAgICogVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxuICAgICAgICAgICAgICogRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cbiAgICAgICAgICAgICAqIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cbiAgICAgICAgICAgICAqIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cbiAgICAgICAgICAgICAqIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXG4gICAgICAgICAgICAgKiBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXG4gICAgICAgICAgICAgKiBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXG4gICAgICAgICAgICAgKiBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxuICAgICAgICAgICAgICogSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcblxuICAgICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXG5cbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XG4gICAgICAgICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxuXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogMjFcbiAgICAgICAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcblxuICAgICAgICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cblxuICAgICAgICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXG4gICAgICAgICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcblxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXG4gICAgICAgICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXG4gICAgICAgICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXG5cbiAgICAgICAgICAgIC8vIFdoZXRoZXIgQmlnTnVtYmVyIEVycm9ycyBhcmUgZXZlciB0aHJvd24uXG4gICAgICAgICAgICBFUlJPUlMgPSB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRvIGludFZhbGlkYXRvck5vRXJyb3JzIGlmIEVSUk9SUyBpcyBmYWxzZS5cbiAgICAgICAgICAgIGlzVmFsaWRJbnQgPSBpbnRWYWxpZGF0b3JXaXRoRXJyb3JzLCAgICAgLy8gaW50VmFsaWRhdG9yV2l0aEVycm9ycy9pbnRWYWxpZGF0b3JOb0Vycm9yc1xuXG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXG4gICAgICAgICAgICAgKiBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cbiAgICAgICAgICAgICAqIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXG4gICAgICAgICAgICAgKiBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cbiAgICAgICAgICAgICAqICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cbiAgICAgICAgICAgICAqIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cbiAgICAgICAgICAgICAqIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxuICAgICAgICAgICAgICogICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcbiAgICAgICAgICAgICAqIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXG4gICAgICAgICAgICAgKiBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XG5cbiAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgdG9Qb3dlciBvcGVyYXRpb24uXG4gICAgICAgICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAxMDAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcblxuICAgICAgICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxuICAgICAgICAgICAgRk9STUFUID0ge1xuICAgICAgICAgICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcbiAgICAgICAgICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZTogMyxcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXG4gICAgICAgICAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcbiAgICAgICAgICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMFxuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgICAgICAvLyBDT05TVFJVQ1RPUlxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXG4gICAgICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIG4uIEludGVnZXIsIDIgdG8gNjQgaW5jbHVzaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQmlnTnVtYmVyKCBuLCBiICkge1xuICAgICAgICAgICAgdmFyIGMsIGUsIGksIG51bSwgbGVuLCBzdHIsXG4gICAgICAgICAgICAgICAgeCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciB1c2FnZSB3aXRob3V0IG5ldy5cbiAgICAgICAgICAgIGlmICggISggeCBpbnN0YW5jZW9mIEJpZ051bWJlciApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gJ0JpZ051bWJlcigpIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBuZXc6IHtufSdcbiAgICAgICAgICAgICAgICBpZiAoRVJST1JTKSByYWlzZSggMjYsICdjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgbmV3JywgbiApO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCBuLCBiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgYmFzZSBub3QgYW4gaW50ZWdlcjoge2J9J1xuICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xuICAgICAgICAgICAgaWYgKCBiID09IG51bGwgfHwgIWlzVmFsaWRJbnQoIGIsIDIsIDY0LCBpZCwgJ2Jhc2UnICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEdXBsaWNhdGUuXG4gICAgICAgICAgICAgICAgaWYgKCBuIGluc3RhbmNlb2YgQmlnTnVtYmVyICkge1xuICAgICAgICAgICAgICAgICAgICB4LnMgPSBuLnM7XG4gICAgICAgICAgICAgICAgICAgIHguZSA9IG4uZTtcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gKCBuID0gbi5jICkgPyBuLnNsaWNlKCkgOiBuO1xuICAgICAgICAgICAgICAgICAgICBpZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoICggbnVtID0gdHlwZW9mIG4gPT0gJ251bWJlcicgKSAmJiBuICogMCA9PSAwICkge1xuICAgICAgICAgICAgICAgICAgICB4LnMgPSAxIC8gbiA8IDAgPyAoIG4gPSAtbiwgLTEgKSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuID09PSB+fm4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBlID0gMCwgaSA9IG47IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeC5lID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHguYyA9IFtuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IG4gKyAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpc051bWVyaWMudGVzdCggc3RyID0gbiArICcnICkgKSByZXR1cm4gcGFyc2VOdW1lcmljKCB4LCBzdHIsIG51bSApO1xuICAgICAgICAgICAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiID0gYiB8IDA7XG4gICAgICAgICAgICAgICAgc3RyID0gbiArICcnO1xuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHJldHVybiB2YWx1ZSBpcyByb3VuZGVkIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKCBiID09IDEwICkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlciggbiBpbnN0YW5jZW9mIEJpZ051bWJlciA/IG4gOiBzdHIgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCB4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgLy8gQW55IG51bWJlciBpbiBleHBvbmVudGlhbCBmb3JtIHdpbGwgZmFpbCBkdWUgdG8gdGhlIFtFZV1bKy1dLlxuICAgICAgICAgICAgICAgIGlmICggKCBudW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJyApICYmIG4gKiAwICE9IDAgfHxcbiAgICAgICAgICAgICAgICAgICEoIG5ldyBSZWdFeHAoICdeLT8nICsgKCBjID0gJ1snICsgQUxQSEFCRVQuc2xpY2UoIDAsIGIgKSArICddKycgKSArXG4gICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBjICsgJyk/JCcsYiA8IDM3ID8gJ2knIDogJycgKSApLnRlc3Qoc3RyKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyggeCwgc3RyLCBudW0sIGIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHgucyA9IDEgLyBuIDwgMCA/ICggc3RyID0gc3RyLnNsaWNlKDEpLCAtMSApIDogMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIEVSUk9SUyAmJiBzdHIucmVwbGFjZSggL14wXFwuMCp8XFwuLywgJycgKS5sZW5ndGggPiAxNSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UoIGlkLCB0b29NYW55RGlnaXRzLCBuICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cbiAgICAgICAgICAgICAgICAgICAgbnVtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKCBzdHIgPSBzdHIuc2xpY2UoMSksIC0xICkgOiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKCBzdHIsIDEwLCBiLCB4LnMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgICAgIGlmICggKCBlID0gc3RyLmluZGV4T2YoJy4nKSApID4gLTEgKSBzdHIgPSBzdHIucmVwbGFjZSggJy4nLCAnJyApO1xuXG4gICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xuICAgICAgICAgICAgaWYgKCAoIGkgPSBzdHIuc2VhcmNoKCAvZS9pICkgKSA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgaWYgKCBlIDwgMCApIGUgPSBpO1xuICAgICAgICAgICAgICAgIGUgKz0gK3N0ci5zbGljZSggaSArIDEgKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKCAwLCBpICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBlIDwgMCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEludGVnZXIuXG4gICAgICAgICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxuICAgICAgICAgICAgZm9yICggaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrICk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgICAgIGZvciAoIGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7ICk7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoIGksIGxlbiArIDEgKTtcblxuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBEaXNhbGxvdyBudW1iZXJzIHdpdGggb3ZlciAxNSBzaWduaWZpY2FudCBkaWdpdHMgaWYgbnVtYmVyIHR5cGUuXG4gICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xuICAgICAgICAgICAgICAgIGlmICggbnVtICYmIEVSUk9SUyAmJiBsZW4gPiAxNSApIHJhaXNlKCBpZCwgdG9vTWFueURpZ2l0cywgeC5zICogbiApO1xuXG4gICAgICAgICAgICAgICAgZSA9IGUgLSBpIC0gMTtcblxuICAgICAgICAgICAgICAgICAvLyBPdmVyZmxvdz9cbiAgICAgICAgICAgICAgICBpZiAoIGUgPiBNQVhfRVhQICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZmluaXR5LlxuICAgICAgICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5kZXJmbG93P1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBNSU5fRVhQICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IFsgeC5lID0gMCBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHguYyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgaSA9ICggZSArIDEgKSAlIExPR19CQVNFO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGUgPCAwICkgaSArPSBMT0dfQkFTRTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCBsZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goICtzdHIuc2xpY2UoIDAsIGkgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguYy5wdXNoKCArc3RyLnNsaWNlKCBpLCBpICs9IExPR19CQVNFICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gbGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpLS07IHN0ciArPSAnMCcgKTtcbiAgICAgICAgICAgICAgICAgICAgeC5jLnB1c2goICtzdHIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gWmVyby5cbiAgICAgICAgICAgICAgICB4LmMgPSBbIHguZSA9IDAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWQgPSAwO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXG5cblxuICAgICAgICBCaWdOdW1iZXIuYW5vdGhlciA9IGFub3RoZXI7XG5cbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XG4gICAgICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XG4gICAgICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XG4gICAgICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xuICAgICAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IG9yIGFuIGFyZ3VtZW50IGxpc3QsIHdpdGggb25lIG9yIG1hbnkgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIG9yXG4gICAgICAgICAqIHBhcmFtZXRlcnMgcmVzcGVjdGl2ZWx5OlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICB7bnVtYmVyfSAgSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlXG4gICAgICAgICAqICAgUk9VTkRJTkdfTU9ERSAgIHtudW1iZXJ9ICBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlXG4gICAgICAgICAqICAgRVhQT05FTlRJQUxfQVQgIHtudW1iZXJ8bnVtYmVyW119ICBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsLiwgMCB0byBNQVggaW5jbC5dXG4gICAgICAgICAqICAgUkFOR0UgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbC4sIGludGVnZXIgMSB0byBNQVggaW5jbC5dXG4gICAgICAgICAqICAgRVJST1JTICAgICAgICAgIHtib29sZWFufG51bWJlcn0gICB0cnVlLCBmYWxzZSwgMSBvciAwXG4gICAgICAgICAqICAgQ1JZUFRPICAgICAgICAgIHtib29sZWFufG51bWJlcn0gICB0cnVlLCBmYWxzZSwgMSBvciAwXG4gICAgICAgICAqICAgTU9EVUxPX01PREUgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDkgaW5jbHVzaXZlXG4gICAgICAgICAqICAgUE9XX1BSRUNJU0lPTiAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWCBpbmNsdXNpdmVcbiAgICAgICAgICogICBGT1JNQVQgICAgICAgICAge29iamVjdH0gICAgICAgICAgIFNlZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0XG4gICAgICAgICAqICAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiAgICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XG4gICAgICAgICAqICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxuICAgICAgICAgKiAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XG4gICAgICAgICAqXG4gICAgICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXG4gICAgICAgICAqXG4gICAgICAgICAqIEUuZy5cbiAgICAgICAgICogQmlnTnVtYmVyLmNvbmZpZygyMCwgNCkgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIEJpZ051bWJlci5jb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdiwgcCxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICByID0ge30sXG4gICAgICAgICAgICAgICAgYSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBvID0gYVswXSxcbiAgICAgICAgICAgICAgICBoYXMgPSBvICYmIHR5cGVvZiBvID09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgaWYgKCBvLmhhc093blByb3BlcnR5KHApICkgcmV0dXJuICggdiA9IG9bcF0gKSAhPSBudWxsOyB9XG4gICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgaWYgKCBhLmxlbmd0aCA+IGkgKSByZXR1cm4gKCB2ID0gYVtpKytdICkgIT0gbnVsbDsgfTtcblxuICAgICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIERFQ0lNQUxfUExBQ0VTIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgREVDSU1BTF9QTEFDRVMgb3V0IG9mIHJhbmdlOiB7dn0nXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdERUNJTUFMX1BMQUNFUycgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCBNQVgsIDIsIHAgKSApIHtcbiAgICAgICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHYgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcltwXSA9IERFQ0lNQUxfUExBQ0VTO1xuXG4gICAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUk9VTkRJTkdfTU9ERSBub3QgYW4gaW50ZWdlcjoge3Z9J1xuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJPVU5ESU5HX01PREUgb3V0IG9mIHJhbmdlOiB7dn0nXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdST1VORElOR19NT0RFJyApICYmIGlzVmFsaWRJbnQoIHYsIDAsIDgsIDIsIHAgKSApIHtcbiAgICAgICAgICAgICAgICBST1VORElOR19NT0RFID0gdiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gUk9VTkRJTkdfTU9ERTtcblxuICAgICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cbiAgICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvciBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIEVYUE9ORU5USUFMX0FUIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVhQT05FTlRJQUxfQVQgb3V0IG9mIHJhbmdlOiB7dn0nXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdFWFBPTkVOVElBTF9BVCcgKSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSh2KSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1ZhbGlkSW50KCB2WzBdLCAtTUFYLCAwLCAyLCBwICkgJiYgaXNWYWxpZEludCggdlsxXSwgMCwgTUFYLCAyLCBwICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpc1ZhbGlkSW50KCB2LCAtTUFYLCBNQVgsIDIsIHAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oIFRPX0VYUF9QT1MgPSAoIHYgPCAwID8gLXYgOiB2ICkgfCAwICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcltwXSA9IFsgVE9fRVhQX05FRywgVE9fRVhQX1BPUyBdO1xuXG4gICAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcbiAgICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0Ugbm90IGFuIGludGVnZXI6IHt2fSdcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBSQU5HRSBjYW5ub3QgYmUgemVybzoge3Z9J1xuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJBTkdFIG91dCBvZiByYW5nZToge3Z9J1xuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnUkFOR0UnICkgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzQXJyYXkodikgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNWYWxpZEludCggdlswXSwgLU1BWCwgLTEsIDIsIHAgKSAmJiBpc1ZhbGlkSW50KCB2WzFdLCAxLCBNQVgsIDIsIHAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzVmFsaWRJbnQoIHYsIC1NQVgsIE1BWCwgMiwgcCApICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHYgfCAwICkgTUlOX0VYUCA9IC0oIE1BWF9FWFAgPSAoIHYgPCAwID8gLXYgOiB2ICkgfCAwICk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEVSUk9SUykgcmFpc2UoIDIsIHAgKyAnIGNhbm5vdCBiZSB6ZXJvJywgdiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbcF0gPSBbIE1JTl9FWFAsIE1BWF9FWFAgXTtcblxuICAgICAgICAgICAgLy8gRVJST1JTIHtib29sZWFufG51bWJlcn0gdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cbiAgICAgICAgICAgIC8vICdjb25maWcoKSBFUlJPUlMgbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQ6IHt2fSdcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0VSUk9SUycgKSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggdiA9PT0gISF2IHx8IHYgPT09IDEgfHwgdiA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkSW50ID0gKCBFUlJPUlMgPSAhIXYgKSA/IGludFZhbGlkYXRvcldpdGhFcnJvcnMgOiBpbnRWYWxpZGF0b3JOb0Vycm9ycztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVSUk9SUykge1xuICAgICAgICAgICAgICAgICAgICByYWlzZSggMiwgcCArIG5vdEJvb2wsIHYgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gRVJST1JTO1xuXG4gICAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW58bnVtYmVyfSB0cnVlLCBmYWxzZSwgMSBvciAwLlxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIENSWVBUTyBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3Z9J1xuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIGNyeXB0byB1bmF2YWlsYWJsZToge2NyeXB0b30nXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdDUllQVE8nICkgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHYgPT09ICEhdiB8fCB2ID09PSAxIHx8IHYgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICEhKCB2ICYmIGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvID09ICdvYmplY3QnICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdiAmJiAhQ1JZUFRPICYmIEVSUk9SUyApIHJhaXNlKCAyLCAnY3J5cHRvIHVuYXZhaWxhYmxlJywgY3J5cHRvICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsIHAgKyBub3RCb29sLCB2ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcltwXSA9IENSWVBUTztcblxuICAgICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cbiAgICAgICAgICAgIC8vICdjb25maWcoKSBNT0RVTE9fTU9ERSBub3QgYW4gaW50ZWdlcjoge3Z9J1xuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIE1PRFVMT19NT0RFIG91dCBvZiByYW5nZToge3Z9J1xuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnTU9EVUxPX01PREUnICkgJiYgaXNWYWxpZEludCggdiwgMCwgOSwgMiwgcCApICkge1xuICAgICAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gTU9EVUxPX01PREU7XG5cbiAgICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFBPV19QUkVDSVNJT04gbm90IGFuIGludGVnZXI6IHt2fSdcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBQT1dfUFJFQ0lTSU9OIG91dCBvZiByYW5nZToge3Z9J1xuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnUE9XX1BSRUNJU0lPTicgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCBNQVgsIDIsIHAgKSApIHtcbiAgICAgICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW3BdID0gUE9XX1BSRUNJU0lPTjtcblxuICAgICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0ZPUk1BVCcgKSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHYgPT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgIEZPUk1BVCA9IHY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsIHAgKyAnIG5vdCBhbiBvYmplY3QnLCB2ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcltwXSA9IEZPUk1BVDtcblxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4T3JNaW4oIGFyZ3VtZW50cywgUC5sdCApOyB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heE9yTWluKCBhcmd1bWVudHMsIFAuZ3QgKTsgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXG4gICAgICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xuICAgICAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqICdyYW5kb20oKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcbiAgICAgICAgICogJ3JhbmRvbSgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcbiAgICAgICAgICogJ3JhbmRvbSgpIGNyeXB0byB1bmF2YWlsYWJsZToge2NyeXB0b30nXG4gICAgICAgICAqL1xuICAgICAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cbiAgICAgICAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxuICAgICAgICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cbiAgICAgICAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vciggTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMgKTsgfVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXG4gICAgICAgICAgICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcblxuICAgICAgICAgICAgICAgIGRwID0gZHAgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMTQgKSA/IERFQ0lNQUxfUExBQ0VTIDogZHAgfCAwO1xuICAgICAgICAgICAgICAgIGsgPSBtYXRoY2VpbCggZHAgLyBMT0dfQkFTRSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKENSWVBUTykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoIG5ldyBVaW50MzJBcnJheSggayAqPSAyICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgazsgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA+PSA5ZTE1ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyggbmV3IFVpbnQzMkFycmF5KDIpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKCB2ICUgMWUxNCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGsgLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyggayAqPSA3ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGs7ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9ICggKCBhW2ldICYgMzEgKSAqIDB4MTAwMDAwMDAwMDAwMCApICsgKCBhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDAgKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhW2kgKyAyXSAqIDB4MTAwMDAwMDAwICkgKyAoIGFbaSArIDNdICogMHgxMDAwMDAwICkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggYVtpICsgNF0gPDwgMTYgKSArICggYVtpICsgNV0gPDwgOCApICsgYVtpICsgNl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHYgPj0gOWUxNSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoIGEsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnB1c2goIHYgJSAxZTE0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gayAvIDc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSggMTQsICdjcnlwdG8gdW5hdmFpbGFibGUnLCBjcnlwdG8gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbTogQ1JZUFRPIGlzIGZhbHNlIG9yIGNyeXB0byBpcyB1bmF2YWlsYWJsZSBhbmQgRVJST1JTIGlzIGZhbHNlLlxuICAgICAgICAgICAgICAgIGlmICghaSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGs7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHYgPCA5ZTE1ICkgY1tpKytdID0gdiAlIDFlMTQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrID0gY1stLWldO1xuICAgICAgICAgICAgICAgIGRwICU9IExPR19CQVNFO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxuICAgICAgICAgICAgICAgIGlmICggayAmJiBkcCApIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xuICAgICAgICAgICAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKCBrIC8gdiApICogdjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXG4gICAgICAgICAgICAgICAgZm9yICggOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0gKTtcblxuICAgICAgICAgICAgICAgIC8vIFplcm8/XG4gICAgICAgICAgICAgICAgaWYgKCBpIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IFsgZSA9IDAgXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc2hpZnQoKSwgZSAtPSBMT0dfQkFTRSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IExPR19CQVNFICkgZSAtPSBMT0dfQkFTRSAtIGk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmFuZC5lID0gZTtcbiAgICAgICAgICAgICAgICByYW5kLmMgPSBjO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5kO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcblxuXG4gICAgICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXG5cblxuICAgICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cbiAgICAgICAgZnVuY3Rpb24gY29udmVydEJhc2UoIHN0ciwgYmFzZU91dCwgYmFzZUluLCBzaWduICkge1xuICAgICAgICAgICAgdmFyIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxuICAgICAgICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZiggJy4nICksXG4gICAgICAgICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcbiAgICAgICAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XG5cbiAgICAgICAgICAgIGlmICggYmFzZUluIDwgMzcgKSBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gTm9uLWludGVnZXIuXG4gICAgICAgICAgICBpZiAoIGkgPj0gMCApIHtcbiAgICAgICAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcblxuICAgICAgICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXG4gICAgICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoICcuJywgJycgKTtcbiAgICAgICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xuICAgICAgICAgICAgICAgIHggPSB5LnBvdyggc3RyLmxlbmd0aCAtIGkgKTtcbiAgICAgICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXG4gICAgICAgICAgICAgICAgeS5jID0gdG9CYXNlT3V0KCB0b0ZpeGVkUG9pbnQoIGNvZWZmVG9TdHJpbmcoIHguYyApLCB4LmUgKSwgMTAsIGJhc2VPdXQgKTtcbiAgICAgICAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cbiAgICAgICAgICAgIHhjID0gdG9CYXNlT3V0KCBzdHIsIGJhc2VJbiwgYmFzZU91dCApO1xuICAgICAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgICAgIGZvciAoIDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSApO1xuICAgICAgICAgICAgaWYgKCAheGNbMF0gKSByZXR1cm4gJzAnO1xuXG4gICAgICAgICAgICBpZiAoIGkgPCAwICkge1xuICAgICAgICAgICAgICAgIC0tZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeC5jID0geGM7XG4gICAgICAgICAgICAgICAgeC5lID0gZTtcblxuICAgICAgICAgICAgICAgIC8vIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxuICAgICAgICAgICAgICAgIHgucyA9IHNpZ247XG4gICAgICAgICAgICAgICAgeCA9IGRpdiggeCwgeSwgZHAsIHJtLCBiYXNlT3V0ICk7XG4gICAgICAgICAgICAgICAgeGMgPSB4LmM7XG4gICAgICAgICAgICAgICAgciA9IHgucjtcbiAgICAgICAgICAgICAgICBlID0geC5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkID0gZSArIGRwICsgMTtcblxuICAgICAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXG4gICAgICAgICAgICBpID0geGNbZF07XG4gICAgICAgICAgICBrID0gYmFzZU91dCAvIDI7XG4gICAgICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcblxuICAgICAgICAgICAgciA9IHJtIDwgNCA/ICggaSAhPSBudWxsIHx8IHIgKSAmJiAoIHJtID09IDAgfHwgcm0gPT0gKCB4LnMgPCAwID8gMyA6IDIgKSApXG4gICAgICAgICAgICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKCBybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgcm0gPT0gKCB4LnMgPCAwID8gOCA6IDcgKSApO1xuXG4gICAgICAgICAgICBpZiAoIGQgPCAxIHx8ICF4Y1swXSApIHtcblxuICAgICAgICAgICAgICAgIC8vIDFeLWRwIG9yIDAuXG4gICAgICAgICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludCggJzEnLCAtZHAgKSA6ICcwJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gZDtcblxuICAgICAgICAgICAgICAgIGlmIChyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0OyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjW2RdID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGMudW5zaGlmdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgICAgICAgICBmb3IgKCBrID0geGMubGVuZ3RoOyAheGNbLS1rXTsgKTtcblxuICAgICAgICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoIHhjW2krK10gKSApO1xuICAgICAgICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludCggc3RyLCBlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXG4gICAgICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxuICAgICAgICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoIHgsIGssIGJhc2UgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxuICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcbiAgICAgICAgICAgICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB4ID0geC5zbGljZSgpOyBpLS07ICkge1xuICAgICAgICAgICAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xuICAgICAgICAgICAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICggKCBtICUgU1FSVF9CQVNFICkgKiBTUVJUX0JBU0UgKSArIGNhcnJ5O1xuICAgICAgICAgICAgICAgICAgICBjYXJyeSA9ICggdGVtcCAvIGJhc2UgfCAwICkgKyAoIG0gLyBTUVJUX0JBU0UgfCAwICkgKyBraGkgKiB4aGk7XG4gICAgICAgICAgICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FycnkpIHgudW5zaGlmdChjYXJyeSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGFyZSggYSwgYiwgYUwsIGJMICkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBjbXA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGFMICE9IGJMICkge1xuICAgICAgICAgICAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFbaV0gIT0gYltpXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWJ0cmFjdCggYSwgYiwgYUwsIGJhc2UgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXG4gICAgICAgICAgICAgICAgZm9yICggOyBhTC0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgYVthTF0gLT0gaTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXG4gICAgICAgICAgICAgICAgZm9yICggOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc2hpZnQoKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHgsIHksIGRwLCBybSwgYmFzZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXG4gICAgICAgICAgICAgICAgICAgIHlMLCB5eixcbiAgICAgICAgICAgICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXG4gICAgICAgICAgICAgICAgICAgIHhjID0geC5jLFxuICAgICAgICAgICAgICAgICAgICB5YyA9IHkuYztcblxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cbiAgICAgICAgICAgICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKCB4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljICkgPyBOYU4gOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXG4gICAgICAgICAgICAgICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcbiAgICAgICAgICAgICAgICBxYyA9IHEuYyA9IFtdO1xuICAgICAgICAgICAgICAgIGUgPSB4LmUgLSB5LmU7XG4gICAgICAgICAgICAgICAgcyA9IGRwICsgZSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFiYXNlICkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gQkFTRTtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGJpdEZsb29yKCB4LmUgLyBMT0dfQkFTRSApIC0gYml0Rmxvb3IoIHkuZSAvIExPR19CQVNFICk7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgeWNbaV0gPT0gKCB4Y1tpXSB8fCAwICk7IGkrKyApO1xuICAgICAgICAgICAgICAgIGlmICggeWNbaV0gPiAoIHhjW2ldIHx8IDAgKSApIGUtLTtcblxuICAgICAgICAgICAgICAgIGlmICggcyA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHFjLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gMjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXG5cbiAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggYmFzZSAvICggeWNbMF0gKyAxICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoIGJhc2UgLyAyICkgLSAxLlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbiA+IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5YyA9IG11bHRpcGx5KCB5YywgbiwgYmFzZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGMgPSBtdWx0aXBseSggeGMsIG4sIGJhc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4aSA9IHlMO1xuICAgICAgICAgICAgICAgICAgICByZW0gPSB4Yy5zbGljZSggMCwgeUwgKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCApO1xuICAgICAgICAgICAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHl6LnVuc2hpZnQoMCk7XG4gICAgICAgICAgICAgICAgICAgIHljMCA9IHljWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHljWzFdID49IGJhc2UgLyAyICkgeWMwKys7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZiAoIGJhc2UgPT0gMyAmJiB5YzAgPT0gMSApIHljMCA9IDEgKyAxZS0xNTtcblxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKCB5YywgcmVtLCB5TCwgcmVtTCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjbXAgPCAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHlMICE9IHJlbUwgKSByZW0wID0gcmVtMCAqIGJhc2UgKyAoIHJlbVsxXSB8fCAwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggcmVtMCAvIHljMCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMS4gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdCAobilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMi4gaWYgcHJvZHVjdCA+IHJlbWFpbmRlcjogcHJvZHVjdCAtPSBkaXZpc29yLCBuLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMy4gcmVtYWluZGVyIC09IHByb2R1Y3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgNC4gaWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIgYXQgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICA1LiBjb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICA2LiBJZiByZW1haW5kZXIgPiBkaXZpc29yOiByZW1haW5kZXIgLT0gZGl2aXNvciwgbisrXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPiAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KCB5YywgbiwgYmFzZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGNvbXBhcmUoIHByb2QsIHJlbSwgcHJvZEwsIHJlbUwgKSA9PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KCBwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuID09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHByb2RMIDwgcmVtTCApIHByb2QudW5zaGlmdCgwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QoIHJlbSwgcHJvZCwgcmVtTCwgYmFzZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY21wID09IC0xICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY29tcGFyZSggeWMsIHJlbSwgeUwsIHJlbUwgKSA8IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNtcCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcWNbaSsrXSA9IG47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZW1bMF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gWyB4Y1t4aV0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoICggeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsICkgJiYgcy0tICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcWNbMF0gKSBxYy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggYmFzZSA9PSBCQVNFICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrICk7XG4gICAgICAgICAgICAgICAgICAgIHJvdW5kKCBxLCBkcCArICggcS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEgKSArIDEsIHJtLCBtb3JlICk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcS5lID0gZTtcbiAgICAgICAgICAgICAgICAgICAgcS5yID0gK21vcmU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcbiAgICAgICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogbiBpcyBhIEJpZ051bWJlci5cbiAgICAgICAgICogaSBpcyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxuICAgICAgICAgKiBybSBpcyB0aGUgcm91bmRpbmcgbW9kZS5cbiAgICAgICAgICogY2FsbGVyIGlzIGNhbGxlciBpZDogdG9FeHBvbmVudGlhbCAxOSwgdG9GaXhlZCAyMCwgdG9Gb3JtYXQgMjEsIHRvUHJlY2lzaW9uIDI0LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0KCBuLCBpLCBybSwgY2FsbGVyICkge1xuICAgICAgICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XG5cbiAgICAgICAgICAgIHJtID0gcm0gIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBybSwgMCwgOCwgY2FsbGVyLCByb3VuZGluZ01vZGUgKVxuICAgICAgICAgICAgICA/IHJtIHwgMCA6IFJPVU5ESU5HX01PREU7XG5cbiAgICAgICAgICAgIGlmICggIW4uYyApIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjMCA9IG4uY1swXTtcbiAgICAgICAgICAgIG5lID0gbi5lO1xuXG4gICAgICAgICAgICBpZiAoIGkgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKCBuLmMgKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBjYWxsZXIgPT0gMTkgfHwgY2FsbGVyID09IDI0ICYmIG5lIDw9IFRPX0VYUF9ORUdcbiAgICAgICAgICAgICAgICAgID8gdG9FeHBvbmVudGlhbCggc3RyLCBuZSApXG4gICAgICAgICAgICAgICAgICA6IHRvRml4ZWRQb2ludCggc3RyLCBuZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gcm91bmQoIG5ldyBCaWdOdW1iZXIobiksIGksIHJtICk7XG5cbiAgICAgICAgICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXG4gICAgICAgICAgICAgICAgZSA9IG4uZTtcblxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xuICAgICAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXG5cbiAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoIGNhbGxlciA9PSAxOSB8fCBjYWxsZXIgPT0gMjQgJiYgKCBpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrICk7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoIHN0ciwgZSApO1xuXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSBuZTtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XG4gICAgICAgICAgICAgICAgICAgIGlmICggZSArIDEgPiBsZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIC0taSA+IDAgKSBmb3IgKCBzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlICsgMSA9PSBsZW4gKSBzdHIgKz0gJy4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaS0tOyBzdHIgKz0gJzAnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cbiAgICAgICAgZnVuY3Rpb24gbWF4T3JNaW4oIGFyZ3MsIG1ldGhvZCApIHtcbiAgICAgICAgICAgIHZhciBtLCBuLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIGlzQXJyYXkoIGFyZ3NbMF0gKSApIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoIGFyZ3NbMF0gKTtcblxuICAgICAgICAgICAgZm9yICggOyArK2kgPCBhcmdzLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoIGFyZ3NbaV0gKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxuICAgICAgICAgICAgICAgIGlmICggIW4ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IG47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1ldGhvZC5jYWxsKCBtLCBuICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIG4gaXMgYW4gaW50ZWdlciBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxuICAgICAgICAgKiBVc2UgZm9yIGFyZ3VtZW50IHZhbGlkYXRpb24gd2hlbiBFUlJPUlMgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGludFZhbGlkYXRvcldpdGhFcnJvcnMoIG4sIG1pbiwgbWF4LCBjYWxsZXIsIG5hbWUgKSB7XG4gICAgICAgICAgICBpZiAoIG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9IHRydW5jYXRlKG4pICkge1xuICAgICAgICAgICAgICAgIHJhaXNlKCBjYWxsZXIsICggbmFtZSB8fCAnZGVjaW1hbCBwbGFjZXMnICkgK1xuICAgICAgICAgICAgICAgICAgKCBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZScgOiAnIG5vdCBhbiBpbnRlZ2VyJyApLCBuICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cbiAgICAgICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGlzZSggbiwgYywgZSApIHtcbiAgICAgICAgICAgIHZhciBpID0gMSxcbiAgICAgICAgICAgICAgICBqID0gYy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXG4gICAgICAgICAgICBmb3IgKCA7ICFjWy0tal07IGMucG9wKCkgKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cbiAgICAgICAgICAgIGZvciAoIGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKysgKTtcblxuICAgICAgICAgICAgLy8gT3ZlcmZsb3c/XG4gICAgICAgICAgICBpZiAoICggZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxICkgPiBNQVhfRVhQICkge1xuXG4gICAgICAgICAgICAgICAgLy8gSW5maW5pdHkuXG4gICAgICAgICAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gVW5kZXJmbG93P1xuICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IE1JTl9FWFAgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBaZXJvLlxuICAgICAgICAgICAgICAgIG4uYyA9IFsgbi5lID0gMCBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuLmUgPSBlO1xuICAgICAgICAgICAgICAgIG4uYyA9IGM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXG4gICAgICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pL2ksXG4gICAgICAgICAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcbiAgICAgICAgICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcbiAgICAgICAgICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrfF5cXHMrfFxccyskL2c7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHgsIHN0ciwgbnVtLCBiICkge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlLFxuICAgICAgICAgICAgICAgICAgICBzID0gbnVtID8gc3RyIDogc3RyLnJlcGxhY2UoIHdoaXRlc3BhY2VPclBsdXMsICcnICk7XG5cbiAgICAgICAgICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXG4gICAgICAgICAgICAgICAgaWYgKCBpc0luZmluaXR5T3JOYU4udGVzdChzKSApIHtcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbnVtICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSggYmFzZVByZWZpeCwgZnVuY3Rpb24gKCBtLCBwMSwgcDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9ICggcDIgPSBwMi50b0xvd2VyQ2FzZSgpICkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSggZG90QWZ0ZXIsICckMScgKS5yZXBsYWNlKCBkb3RCZWZvcmUsICcwLiQxJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0ciAhPSBzICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIHMsIGJhc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbm90IGEgbnVtYmVyOiB7bn0nXG4gICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXG4gICAgICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCBpZCwgJ25vdCBhJyArICggYiA/ICcgYmFzZSAnICsgYiA6ICcnICkgKyAnIG51bWJlcicsIHN0ciApO1xuICAgICAgICAgICAgICAgICAgICB4LnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG5cbiAgICAgICAgLy8gVGhyb3cgYSBCaWdOdW1iZXIgRXJyb3IuXG4gICAgICAgIGZ1bmN0aW9uIHJhaXNlKCBjYWxsZXIsIG1zZywgdmFsICkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCBbXG4gICAgICAgICAgICAgICAgJ25ldyBCaWdOdW1iZXInLCAgICAgLy8gMFxuICAgICAgICAgICAgICAgICdjbXAnLCAgICAgICAgICAgICAgIC8vIDFcbiAgICAgICAgICAgICAgICAnY29uZmlnJywgICAgICAgICAgICAvLyAyXG4gICAgICAgICAgICAgICAgJ2RpdicsICAgICAgICAgICAgICAgLy8gM1xuICAgICAgICAgICAgICAgICdkaXZUb0ludCcsICAgICAgICAgIC8vIDRcbiAgICAgICAgICAgICAgICAnZXEnLCAgICAgICAgICAgICAgICAvLyA1XG4gICAgICAgICAgICAgICAgJ2d0JywgICAgICAgICAgICAgICAgLy8gNlxuICAgICAgICAgICAgICAgICdndGUnLCAgICAgICAgICAgICAgIC8vIDdcbiAgICAgICAgICAgICAgICAnbHQnLCAgICAgICAgICAgICAgICAvLyA4XG4gICAgICAgICAgICAgICAgJ2x0ZScsICAgICAgICAgICAgICAgLy8gOVxuICAgICAgICAgICAgICAgICdtaW51cycsICAgICAgICAgICAgIC8vIDEwXG4gICAgICAgICAgICAgICAgJ21vZCcsICAgICAgICAgICAgICAgLy8gMTFcbiAgICAgICAgICAgICAgICAncGx1cycsICAgICAgICAgICAgICAvLyAxMlxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nLCAgICAgICAgIC8vIDEzXG4gICAgICAgICAgICAgICAgJ3JhbmRvbScsICAgICAgICAgICAgLy8gMTRcbiAgICAgICAgICAgICAgICAncm91bmQnLCAgICAgICAgICAgICAvLyAxNVxuICAgICAgICAgICAgICAgICdzaGlmdCcsICAgICAgICAgICAgIC8vIDE2XG4gICAgICAgICAgICAgICAgJ3RpbWVzJywgICAgICAgICAgICAgLy8gMTdcbiAgICAgICAgICAgICAgICAndG9EaWdpdHMnLCAgICAgICAgICAvLyAxOFxuICAgICAgICAgICAgICAgICd0b0V4cG9uZW50aWFsJywgICAgIC8vIDE5XG4gICAgICAgICAgICAgICAgJ3RvRml4ZWQnLCAgICAgICAgICAgLy8gMjBcbiAgICAgICAgICAgICAgICAndG9Gb3JtYXQnLCAgICAgICAgICAvLyAyMVxuICAgICAgICAgICAgICAgICd0b0ZyYWN0aW9uJywgICAgICAgIC8vIDIyXG4gICAgICAgICAgICAgICAgJ3BvdycsICAgICAgICAgICAgICAgLy8gMjNcbiAgICAgICAgICAgICAgICAndG9QcmVjaXNpb24nLCAgICAgICAvLyAyNFxuICAgICAgICAgICAgICAgICd0b1N0cmluZycsICAgICAgICAgIC8vIDI1XG4gICAgICAgICAgICAgICAgJ0JpZ051bWJlcicgICAgICAgICAgLy8gMjZcbiAgICAgICAgICAgIF1bY2FsbGVyXSArICcoKSAnICsgbXNnICsgJzogJyArIHZhbCApO1xuXG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ0JpZ051bWJlciBFcnJvcic7XG4gICAgICAgICAgICBpZCA9IDA7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cbiAgICAgICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJvdW5kKCB4LCBzZCwgcm0sIHIgKSB7XG4gICAgICAgICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxuICAgICAgICAgICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xuXG4gICAgICAgICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cbiAgICAgICAgICAgIGlmICh4Yykge1xuXG4gICAgICAgICAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cbiAgICAgICAgICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxuICAgICAgICAgICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXG4gICAgICAgICAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxuICAgICAgICAgICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxuICAgICAgICAgICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXG4gICAgICAgICAgICAgICAgb3V0OiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKysgKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHNkIC0gZDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gc2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0geGNbIG5pID0gMCBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFsgZCAtIGogLSAxIF0gJSAxMCB8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuaSA9IG1hdGhjZWlsKCAoIGkgKyAxICkgLyBMT0dfQkFTRSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5pID49IHhjLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKysgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFsgZCAtIGogLSAxIF0gJSAxMCB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwWyBkIC0gaiAtIDEgXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cbiAgICAgICAgICAgICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKCBqIDwgMCA/IG4gOiBuICUgcG93czEwWyBkIC0gaiAtIDEgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHIgPSBybSA8IDRcbiAgICAgICAgICAgICAgICAgICAgICA/ICggcmQgfHwgciApICYmICggcm0gPT0gMCB8fCBybSA9PSAoIHgucyA8IDAgPyAzIDogMiApIClcbiAgICAgICAgICAgICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmICggcm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICggKCBpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFsgZCAtIGogXSA6IDAgOiB4Y1tuaSAtIDFdICkgJSAxMCApICYgMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBybSA9PSAoIHgucyA8IDAgPyA4IDogNyApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZCA8IDEgfHwgIXhjWzBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbIHNkICUgTE9HX0JBU0UgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaZXJvLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpID09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmktLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBwb3dzMTBbIExPR19CQVNFIC0gaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKCBuIC8gcG93czEwWyBkIC0gaiBdICUgcG93czEwW2pdICkgKiBrIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwP1xuICAgICAgICAgICAgICAgICAgICBpZiAocikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IDsgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmkgPT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9IGsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGNbMF0gPT0gQkFTRSApIHhjWzBdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHhjW25pXSAhPSBCQVNFICkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cbiAgICAgICAgICAgICAgICBpZiAoIHguZSA+IE1BWF9FWFAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeC5lIDwgTUlOX0VYUCApIHtcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XG4gICAgICAgICAgICBpZiAoIHgucyA8IDAgKSB4LnMgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgd2hvbGVcbiAgICAgICAgICogbnVtYmVyIGluIHRoZSBkaXJlY3Rpb24gb2YgSW5maW5pdHkuXG4gICAgICAgICAqL1xuICAgICAgICBQLmNlaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIG5ldyBCaWdOdW1iZXIodGhpcyksIHRoaXMuZSArIDEsIDIgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVyblxuICAgICAgICAgKiAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcbiAgICAgICAgICogLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxuICAgICAgICAgKiAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcbiAgICAgICAgICogb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cbiAgICAgICAgICovXG4gICAgICAgIFAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgICAgICAgICAgaWQgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZVxuICAgICAgICAgKiBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cbiAgICAgICAgICovXG4gICAgICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbiwgdixcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5jO1xuXG4gICAgICAgICAgICBpZiAoICFjICkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBuID0gKCAoIHYgPSBjLmxlbmd0aCAtIDEgKSAtIGJpdEZsb29yKCB0aGlzLmUgLyBMT0dfQkFTRSApICkgKiBMT0dfQkFTRTtcblxuICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXG4gICAgICAgICAgICBpZiAoIHYgPSBjW3ZdICkgZm9yICggOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tICk7XG4gICAgICAgICAgICBpZiAoIG4gPCAwICkgbiA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogIG4gLyAwID0gSVxuICAgICAgICAgKiAgbiAvIE4gPSBOXG4gICAgICAgICAqICBuIC8gSSA9IDBcbiAgICAgICAgICogIDAgLyBuID0gMFxuICAgICAgICAgKiAgMCAvIDAgPSBOXG4gICAgICAgICAqICAwIC8gTiA9IE5cbiAgICAgICAgICogIDAgLyBJID0gMFxuICAgICAgICAgKiAgTiAvIG4gPSBOXG4gICAgICAgICAqICBOIC8gMCA9IE5cbiAgICAgICAgICogIE4gLyBOID0gTlxuICAgICAgICAgKiAgTiAvIEkgPSBOXG4gICAgICAgICAqICBJIC8gbiA9IElcbiAgICAgICAgICogIEkgLyAwID0gSVxuICAgICAgICAgKiAgSSAvIE4gPSBOXG4gICAgICAgICAqICBJIC8gSSA9IE5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cbiAgICAgICAgICovXG4gICAgICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICBpZCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gZGl2KCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcbiAgICAgICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXG4gICAgICAgICAqL1xuICAgICAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuZGl2VG9JbnQgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICBpZCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gZGl2KCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICksIDAsIDEgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxuICAgICAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIFAuZXF1YWxzID0gUC5lcSA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIGlkID0gNTtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA9PT0gMDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSB3aG9sZVxuICAgICAgICAgKiBudW1iZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiAtSW5maW5pdHkuXG4gICAgICAgICAqL1xuICAgICAgICBQLmZsb29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCBuZXcgQmlnTnVtYmVyKHRoaXMpLCB0aGlzLmUgKyAxLCAzICk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXG4gICAgICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICBpZCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgPiAwO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIFAuZ3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIGlkID0gNztcbiAgICAgICAgICAgIHJldHVybiAoIGIgPSBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSApID09PSAxIHx8IGIgPT09IDA7XG5cbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuYztcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKCB0aGlzLmUgLyBMT0dfQkFTRSApID4gdGhpcy5jLmxlbmd0aCAtIDI7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMucztcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBQLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcbiAgICAgICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBQLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIGlkID0gODtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA8IDA7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5sZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgICAgICAgICAgaWQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuICggYiA9IGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApICkgPT09IC0xIHx8IGIgPT09IDA7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiAgbiAtIDAgPSBuXG4gICAgICAgICAqICBuIC0gTiA9IE5cbiAgICAgICAgICogIG4gLSBJID0gLUlcbiAgICAgICAgICogIDAgLSBuID0gLW5cbiAgICAgICAgICogIDAgLSAwID0gMFxuICAgICAgICAgKiAgMCAtIE4gPSBOXG4gICAgICAgICAqICAwIC0gSSA9IC1JXG4gICAgICAgICAqICBOIC0gbiA9IE5cbiAgICAgICAgICogIE4gLSAwID0gTlxuICAgICAgICAgKiAgTiAtIE4gPSBOXG4gICAgICAgICAqICBOIC0gSSA9IE5cbiAgICAgICAgICogIEkgLSBuID0gSVxuICAgICAgICAgKiAgSSAtIDAgPSBJXG4gICAgICAgICAqICBJIC0gTiA9IE5cbiAgICAgICAgICogIEkgLSBJID0gTlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24gKCB5LCBiICkge1xuICAgICAgICAgICAgdmFyIGksIGosIHQsIHhMVHksXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYSA9IHgucztcblxuICAgICAgICAgICAgaWQgPSAxMDtcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XG4gICAgICAgICAgICBiID0geS5zO1xuXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xuICAgICAgICAgICAgaWYgKCAhYSB8fCAhYiApIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XG5cbiAgICAgICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cbiAgICAgICAgICAgIGlmICggYSAhPSBiICkge1xuICAgICAgICAgICAgICAgIHkucyA9IC1iO1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnBsdXMoeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxuICAgICAgICAgICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXG4gICAgICAgICAgICAgICAgeWMgPSB5LmM7XG5cbiAgICAgICAgICAgIGlmICggIXhlIHx8ICF5ZSApIHtcblxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cbiAgICAgICAgICAgICAgICBpZiAoICF4YyB8fCAheWMgKSByZXR1cm4geGMgPyAoIHkucyA9IC1iLCB5ICkgOiBuZXcgQmlnTnVtYmVyKCB5YyA/IHggOiBOYU4gKTtcblxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICAgICAgICAgIGlmICggIXhjWzBdIHx8ICF5Y1swXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHljWzBdID8gKCB5LnMgPSAtYiwgeSApIDogbmV3IEJpZ051bWJlciggeGNbMF0gPyB4IDpcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcbiAgICAgICAgICAgICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xuICAgICAgICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XG4gICAgICAgICAgICB4YyA9IHhjLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cbiAgICAgICAgICAgIGlmICggYSA9IHhlIC0geWUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHhMVHkgPSBhIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgICAgICB0ID0geGM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWUgPSB4ZTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHljO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXG4gICAgICAgICAgICAgICAgZm9yICggYiA9IGE7IGItLTsgdC5wdXNoKDApICk7XG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cbiAgICAgICAgICAgICAgICBqID0gKCB4TFR5ID0gKCBhID0geGMubGVuZ3RoICkgPCAoIGIgPSB5Yy5sZW5ndGggKSApID8gYSA6IGI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBhID0gYiA9IDA7IGIgPCBqOyBiKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1tiXSAhPSB5Y1tiXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXG4gICAgICAgICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XG5cbiAgICAgICAgICAgIGIgPSAoIGogPSB5Yy5sZW5ndGggKSAtICggaSA9IHhjLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXG4gICAgICAgICAgICBpZiAoIGIgPiAwICkgZm9yICggOyBiLS07IHhjW2krK10gPSAwICk7XG4gICAgICAgICAgICBiID0gQkFTRSAtIDE7XG5cbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXG4gICAgICAgICAgICBmb3IgKCA7IGogPiBhOyApIHtcblxuICAgICAgICAgICAgICAgIGlmICggeGNbLS1qXSA8IHljW2pdICkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiICk7XG4gICAgICAgICAgICAgICAgICAgIC0teGNbaV07XG4gICAgICAgICAgICAgICAgICAgIHhjW2pdICs9IEJBU0U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeGNbal0gLT0geWNbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICBmb3IgKCA7IHhjWzBdID09IDA7IHhjLnNoaWZ0KCksIC0teWUgKTtcblxuICAgICAgICAgICAgLy8gWmVybz9cbiAgICAgICAgICAgIGlmICggIXhjWzBdICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXG4gICAgICAgICAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxuICAgICAgICAgICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB5LmMgPSBbIHkuZSA9IDAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XG4gICAgICAgICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB4YywgeWUgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqICAgbiAlIDAgPSAgTlxuICAgICAgICAgKiAgIG4gJSBOID0gIE5cbiAgICAgICAgICogICBuICUgSSA9ICBuXG4gICAgICAgICAqICAgMCAlIG4gPSAgMFxuICAgICAgICAgKiAgLTAgJSBuID0gLTBcbiAgICAgICAgICogICAwICUgMCA9ICBOXG4gICAgICAgICAqICAgMCAlIE4gPSAgTlxuICAgICAgICAgKiAgIDAgJSBJID0gIDBcbiAgICAgICAgICogICBOICUgbiA9ICBOXG4gICAgICAgICAqICAgTiAlIDAgPSAgTlxuICAgICAgICAgKiAgIE4gJSBOID0gIE5cbiAgICAgICAgICogICBOICUgSSA9ICBOXG4gICAgICAgICAqICAgSSAlIG4gPSAgTlxuICAgICAgICAgKiAgIEkgJSAwID0gIE5cbiAgICAgICAgICogICBJICUgTiA9ICBOXG4gICAgICAgICAqICAgSSAlIEkgPSAgTlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cbiAgICAgICAgICovXG4gICAgICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICB2YXIgcSwgcyxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcztcblxuICAgICAgICAgICAgaWQgPSAxMTtcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXG4gICAgICAgICAgICBpZiAoICF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICF5LmMgfHwgeC5jICYmICF4LmNbMF0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggTU9EVUxPX01PREUgPT0gOSApIHtcblxuICAgICAgICAgICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxuICAgICAgICAgICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxuICAgICAgICAgICAgICAgIHMgPSB5LnM7XG4gICAgICAgICAgICAgICAgeS5zID0gMTtcbiAgICAgICAgICAgICAgICBxID0gZGl2KCB4LCB5LCAwLCAzICk7XG4gICAgICAgICAgICAgICAgeS5zID0gcztcbiAgICAgICAgICAgICAgICBxLnMgKj0gcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcSA9IGRpdiggeCwgeSwgMCwgTU9EVUxPX01PREUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHgubWludXMoIHEudGltZXMoeSkgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXG4gICAgICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cbiAgICAgICAgICovXG4gICAgICAgIFAubmVnYXRlZCA9IFAubmVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xuICAgICAgICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiAgbiArIDAgPSBuXG4gICAgICAgICAqICBuICsgTiA9IE5cbiAgICAgICAgICogIG4gKyBJID0gSVxuICAgICAgICAgKiAgMCArIG4gPSBuXG4gICAgICAgICAqICAwICsgMCA9IDBcbiAgICAgICAgICogIDAgKyBOID0gTlxuICAgICAgICAgKiAgMCArIEkgPSBJXG4gICAgICAgICAqICBOICsgbiA9IE5cbiAgICAgICAgICogIE4gKyAwID0gTlxuICAgICAgICAgKiAgTiArIE4gPSBOXG4gICAgICAgICAqICBOICsgSSA9IE5cbiAgICAgICAgICogIEkgKyBuID0gSVxuICAgICAgICAgKiAgSSArIDAgPSBJXG4gICAgICAgICAqICBJICsgTiA9IE5cbiAgICAgICAgICogIEkgKyBJID0gSVxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXG4gICAgICAgICAqL1xuICAgICAgICBQLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uICggeSwgYiApIHtcbiAgICAgICAgICAgIHZhciB0LFxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxuICAgICAgICAgICAgICAgIGEgPSB4LnM7XG5cbiAgICAgICAgICAgIGlkID0gMTI7XG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlciggeSwgYiApO1xuICAgICAgICAgICAgYiA9IHkucztcblxuICAgICAgICAgICAgLy8gRWl0aGVyIE5hTj9cbiAgICAgICAgICAgIGlmICggIWEgfHwgIWIgKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xuXG4gICAgICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgICAgICAgaWYgKCBhICE9IGIgKSB7XG4gICAgICAgICAgICAgICAgeS5zID0gLWI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxuICAgICAgICAgICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXG4gICAgICAgICAgICAgICAgeWMgPSB5LmM7XG5cbiAgICAgICAgICAgIGlmICggIXhlIHx8ICF5ZSApIHtcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxuICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiBuZXcgQmlnTnVtYmVyKCBhIC8gMCApO1xuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHplcm8/XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXG4gICAgICAgICAgICAgICAgaWYgKCAheGNbMF0gfHwgIXljWzBdICkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoIHhjWzBdID8geCA6IGEgKiAwICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xuICAgICAgICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XG4gICAgICAgICAgICB4YyA9IHhjLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cbiAgICAgICAgICAgIGlmICggYSA9IHhlIC0geWUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBhID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgeWUgPSB4ZTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHljO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHhjO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgYS0tOyB0LnB1c2goMCkgKTtcbiAgICAgICAgICAgICAgICB0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYSA9IHhjLmxlbmd0aDtcbiAgICAgICAgICAgIGIgPSB5Yy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cbiAgICAgICAgICAgIGlmICggYSAtIGIgPCAwICkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xuXG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cbiAgICAgICAgICAgIGZvciAoIGEgPSAwOyBiOyApIHtcbiAgICAgICAgICAgICAgICBhID0gKCB4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEgKSAvIEJBU0UgfCAwO1xuICAgICAgICAgICAgICAgIHhjW2JdICU9IEJBU0U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgeGMudW5zaGlmdChhKTtcbiAgICAgICAgICAgICAgICArK3llO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXG4gICAgICAgICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB4YywgeWUgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFt6XSB7Ym9vbGVhbnxudW1iZXJ9IFdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlLCBmYWxzZSwgMSBvciAwLlxuICAgICAgICAgKi9cbiAgICAgICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHopIHtcbiAgICAgICAgICAgIHZhciBuLCB2LFxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxuICAgICAgICAgICAgICAgIGMgPSB4LmM7XG5cbiAgICAgICAgICAgIC8vICdwcmVjaXNpb24oKSBhcmd1bWVudCBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3p9J1xuICAgICAgICAgICAgaWYgKCB6ICE9IG51bGwgJiYgeiAhPT0gISF6ICYmIHogIT09IDEgJiYgeiAhPT0gMCApIHtcbiAgICAgICAgICAgICAgICBpZiAoRVJST1JTKSByYWlzZSggMTMsICdhcmd1bWVudCcgKyBub3RCb29sLCB6ICk7XG4gICAgICAgICAgICAgICAgaWYgKCB6ICE9ICEheiApIHogPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICFjICkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2ID0gYy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XG5cbiAgICAgICAgICAgIGlmICggdiA9IGNbdl0gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgZm9yICggOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgZm9yICggdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHogJiYgeC5lICsgMSA+IG4gKSBuID0geC5lICsgMTtcblxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZlxuICAgICAgICAgKiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciB0byAwIGFuZCBST1VORElOR19NT0RFIHJlc3BlY3RpdmVseSBpZlxuICAgICAgICAgKiBvbWl0dGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogJ3JvdW5kKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xuICAgICAgICAgKiAncm91bmQoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcbiAgICAgICAgICogJ3JvdW5kKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcbiAgICAgICAgICogJ3JvdW5kKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXG4gICAgICAgICAqL1xuICAgICAgICBQLnJvdW5kID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICggZHAgPT0gbnVsbCB8fCBpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAxNSApICkge1xuICAgICAgICAgICAgICAgIHJvdW5kKCBuLCB+fmRwICsgdGhpcy5lICsgMSwgcm0gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgIWlzVmFsaWRJbnQoIHJtLCAwLCA4LCAxNSwgcm91bmRpbmdNb2RlICkgPyBST1VORElOR19NT0RFIDogcm0gfCAwICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xuICAgICAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGsgaXMgb3V0IG9mIHJhbmdlIGFuZCBFUlJPUlMgaXMgZmFsc2UsIHRoZSByZXN1bHQgd2lsbCBiZSDCsTAgaWYgayA8IDAsIG9yIMKxSW5maW5pdHlcbiAgICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAnc2hpZnQoKSBhcmd1bWVudCBub3QgYW4gaW50ZWdlcjoge2t9J1xuICAgICAgICAgKiAnc2hpZnQoKSBhcmd1bWVudCBvdXQgb2YgcmFuZ2U6IHtrfSdcbiAgICAgICAgICovXG4gICAgICAgIFAuc2hpZnQgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRJbnQoIGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSLCAxNiwgJ2FyZ3VtZW50JyApXG5cbiAgICAgICAgICAgICAgLy8gayA8IDFlKzIxLCBvciB0cnVuY2F0ZShrKSB3aWxsIHByb2R1Y2UgZXhwb25lbnRpYWwgbm90YXRpb24uXG4gICAgICAgICAgICAgID8gbi50aW1lcyggJzFlJyArIHRydW5jYXRlKGspIClcbiAgICAgICAgICAgICAgOiBuZXcgQmlnTnVtYmVyKCBuLmMgJiYgbi5jWzBdICYmICggayA8IC1NQVhfU0FGRV9JTlRFR0VSIHx8IGsgPiBNQVhfU0FGRV9JTlRFR0VSIClcbiAgICAgICAgICAgICAgICA/IG4ucyAqICggayA8IDAgPyAwIDogMSAvIDAgKVxuICAgICAgICAgICAgICAgIDogbiApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogIHNxcnQoLW4pID0gIE5cbiAgICAgICAgICogIHNxcnQoIE4pID0gIE5cbiAgICAgICAgICogIHNxcnQoLUkpID0gIE5cbiAgICAgICAgICogIHNxcnQoIEkpID0gIElcbiAgICAgICAgICogIHNxcnQoIDApID0gIDBcbiAgICAgICAgICogIHNxcnQoLTApID0gLTBcbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxuICAgICAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cbiAgICAgICAgICovXG4gICAgICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYyA9IHguYyxcbiAgICAgICAgICAgICAgICBzID0geC5zLFxuICAgICAgICAgICAgICAgIGUgPSB4LmUsXG4gICAgICAgICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXG4gICAgICAgICAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xuXG4gICAgICAgICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cbiAgICAgICAgICAgIGlmICggcyAhPT0gMSB8fCAhYyB8fCAhY1swXSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggIXMgfHwgcyA8IDAgJiYgKCAhYyB8fCBjWzBdICkgPyBOYU4gOiBjID8geCA6IDEgLyAwICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXG4gICAgICAgICAgICBzID0gTWF0aC5zcXJ0KCAreCApO1xuXG4gICAgICAgICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xuICAgICAgICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmICggcyA9PSAwIHx8IHMgPT0gMSAvIDAgKSB7XG4gICAgICAgICAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XG4gICAgICAgICAgICAgICAgaWYgKCAoIG4ubGVuZ3RoICsgZSApICUgMiA9PSAwICkgbiArPSAnMCc7XG4gICAgICAgICAgICAgICAgcyA9IE1hdGguc3FydChuKTtcbiAgICAgICAgICAgICAgICBlID0gYml0Rmxvb3IoICggZSArIDEgKSAvIDIgKSAtICggZSA8IDAgfHwgZSAlIDIgKTtcblxuICAgICAgICAgICAgICAgIGlmICggcyA9PSAxIC8gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9ICcxZScgKyBlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IG4uc2xpY2UoIDAsIG4uaW5kZXhPZignZScpICsgMSApICsgZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIoIHMgKyAnJyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgemVyby5cbiAgICAgICAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXG4gICAgICAgICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxuICAgICAgICAgICAgaWYgKCByLmNbMF0gKSB7XG4gICAgICAgICAgICAgICAgZSA9IHIuZTtcbiAgICAgICAgICAgICAgICBzID0gZSArIGRwO1xuICAgICAgICAgICAgICAgIGlmICggcyA8IDMgKSBzID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSByO1xuICAgICAgICAgICAgICAgICAgICByID0gaGFsZi50aW1lcyggdC5wbHVzKCBkaXYoIHgsIHQsIGRwLCAxICkgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29lZmZUb1N0cmluZyggdC5jICAgKS5zbGljZSggMCwgcyApID09PSAoIG4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmVG9TdHJpbmcoIHIuYyApICkuc2xpY2UoIDAsIHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggci5lIDwgZSApIC0tcztcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuLnNsaWNlKCBzIC0gMywgcyArIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZCggdCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0LnRpbWVzKHQpLmVxKHgpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRwICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZCggciwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCByLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0gKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqICBuICogMCA9IDBcbiAgICAgICAgICogIG4gKiBOID0gTlxuICAgICAgICAgKiAgbiAqIEkgPSBJXG4gICAgICAgICAqICAwICogbiA9IDBcbiAgICAgICAgICogIDAgKiAwID0gMFxuICAgICAgICAgKiAgMCAqIE4gPSBOXG4gICAgICAgICAqICAwICogSSA9IE5cbiAgICAgICAgICogIE4gKiBuID0gTlxuICAgICAgICAgKiAgTiAqIDAgPSBOXG4gICAgICAgICAqICBOICogTiA9IE5cbiAgICAgICAgICogIE4gKiBJID0gTlxuICAgICAgICAgKiAgSSAqIG4gPSBJXG4gICAgICAgICAqICBJICogMCA9IE5cbiAgICAgICAgICogIEkgKiBOID0gTlxuICAgICAgICAgKiAgSSAqIEkgPSBJXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHRpbWVzIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXG4gICAgICAgICAqL1xuICAgICAgICBQLnRpbWVzID0gUC5tdWwgPSBmdW5jdGlvbiAoIHksIGIgKSB7XG4gICAgICAgICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXG4gICAgICAgICAgICAgICAgYmFzZSwgc3FydEJhc2UsXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXG4gICAgICAgICAgICAgICAgeWMgPSAoIGlkID0gMTcsIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKS5jO1xuXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cbiAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdICkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxuICAgICAgICAgICAgICAgIGlmICggIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4YyApIHtcbiAgICAgICAgICAgICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5LnMgKj0geC5zO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoICF4YyB8fCAheWMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuYyA9IFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZSA9IGJpdEZsb29yKCB4LmUgLyBMT0dfQkFTRSApICsgYml0Rmxvb3IoIHkuZSAvIExPR19CQVNFICk7XG4gICAgICAgICAgICB5LnMgKj0geC5zO1xuICAgICAgICAgICAgeGNMID0geGMubGVuZ3RoO1xuICAgICAgICAgICAgeWNMID0geWMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXG4gICAgICAgICAgICBpZiAoIHhjTCA8IHljTCApIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXG4gICAgICAgICAgICBmb3IgKCBpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkgKTtcblxuICAgICAgICAgICAgYmFzZSA9IEJBU0U7XG4gICAgICAgICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcblxuICAgICAgICAgICAgZm9yICggaSA9IHljTDsgLS1pID49IDA7ICkge1xuICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XG4gICAgICAgICAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBrID0geGNMLCBqID0gaSArIGs7IGogPiBpOyApIHtcbiAgICAgICAgICAgICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xuICAgICAgICAgICAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcbiAgICAgICAgICAgICAgICAgICAgeGxvID0geWxvICogeGxvICsgKCAoIG0gJSBzcXJ0QmFzZSApICogc3FydEJhc2UgKSArIHpjW2pdICsgYztcbiAgICAgICAgICAgICAgICAgICAgYyA9ICggeGxvIC8gYmFzZSB8IDAgKSArICggbSAvIHNxcnRCYXNlIHwgMCApICsgeWhpICogeGhpO1xuICAgICAgICAgICAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB6Y1tqXSA9IGM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgKytlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB6Yy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB6YywgZSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2ZcbiAgICAgICAgICogc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAndG9EaWdpdHMoKSBwcmVjaXNpb24gb3V0IG9mIHJhbmdlOiB7c2R9J1xuICAgICAgICAgKiAndG9EaWdpdHMoKSBwcmVjaXNpb24gbm90IGFuIGludGVnZXI6IHtzZH0nXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xuICAgICAgICAgKi9cbiAgICAgICAgUC50b0RpZ2l0cyA9IGZ1bmN0aW9uICggc2QsIHJtICkge1xuICAgICAgICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xuICAgICAgICAgICAgc2QgPSBzZCA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBzZCwgMSwgTUFYLCAxOCwgJ3ByZWNpc2lvbicgKSA/IG51bGwgOiBzZCB8IDA7XG4gICAgICAgICAgICBybSA9IHJtID09IG51bGwgfHwgIWlzVmFsaWRJbnQoIHJtLCAwLCA4LCAxOCwgcm91bmRpbmdNb2RlICkgPyBST1VORElOR19NT0RFIDogcm0gfCAwO1xuICAgICAgICAgICAgcmV0dXJuIHNkID8gcm91bmQoIG4sIHNkLCBybSApIDogbjtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxuICAgICAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcbiAgICAgICAgICogJ3RvRXhwb25lbnRpYWwoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xuICAgICAgICAgKi9cbiAgICAgICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KCB0aGlzLFxuICAgICAgICAgICAgICBkcCAhPSBudWxsICYmIGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDE5ICkgPyB+fmRwICsgMSA6IG51bGwsIHJtLCAxOSApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcbiAgICAgICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcbiAgICAgICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXG4gICAgICAgICAqXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAndG9GaXhlZCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xuICAgICAgICAgKiAndG9GaXhlZCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcbiAgICAgICAgICogJ3RvRml4ZWQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xuICAgICAgICAgKiAndG9GaXhlZCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xuICAgICAgICAgKi9cbiAgICAgICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KCB0aGlzLCBkcCAhPSBudWxsICYmIGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDIwIClcbiAgICAgICAgICAgICAgPyB+fmRwICsgdGhpcy5lICsgMSA6IG51bGwsIHJtLCAyMCApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxuICAgICAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xuICAgICAgICAgKiBvZiB0aGUgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5jb25maWcpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGT1JNQVQgPSB7XG4gICAgICAgICAqICAgICAgZGVjaW1hbFNlcGFyYXRvciA6ICcuJyxcbiAgICAgICAgICogICAgICBncm91cFNlcGFyYXRvciA6ICcsJyxcbiAgICAgICAgICogICAgICBncm91cFNpemUgOiAzLFxuICAgICAgICAgKiAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZSA6IDAsXG4gICAgICAgICAqICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciA6ICdcXHhBMCcsICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxuICAgICAgICAgKiAgICAgIGZyYWN0aW9uR3JvdXBTaXplIDogMFxuICAgICAgICAgKiB9O1xuICAgICAgICAgKlxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXG4gICAgICAgICAqL1xuICAgICAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gZm9ybWF0KCB0aGlzLCBkcCAhPSBudWxsICYmIGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDIxIClcbiAgICAgICAgICAgICAgPyB+fmRwICsgdGhpcy5lICsgMSA6IG51bGwsIHJtLCAyMSApO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuYyApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgICAgIGcxID0gK0ZPUk1BVC5ncm91cFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGcyID0gK0ZPUk1BVC5zZWNvbmRhcnlHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gRk9STUFULmdyb3VwU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXG4gICAgICAgICAgICAgICAgICAgIGlzTmVnID0gdGhpcy5zIDwgMCxcbiAgICAgICAgICAgICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBnMSA+IDAgJiYgbGVuID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xuICAgICAgICAgICAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0ciggMCwgaSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSArPSBnMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKCBpLCBnMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBnMiA+IDAgKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxuICAgICAgICAgICAgICAgICAgPyBpbnRQYXJ0ICsgRk9STUFULmRlY2ltYWxTZXBhcmF0b3IgKyAoICggZzIgPSArRk9STUFULmZyYWN0aW9uR3JvdXBTaXplIClcbiAgICAgICAgICAgICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZSggbmV3IFJlZ0V4cCggJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycgKSxcbiAgICAgICAgICAgICAgICAgICAgICAnJCYnICsgRk9STUFULmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgKVxuICAgICAgICAgICAgICAgICAgICA6IGZyYWN0aW9uUGFydCApXG4gICAgICAgICAgICAgICAgICA6IGludFBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZSBmcmFjdGlvbiB3aXRoXG4gICAgICAgICAqIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlXG4gICAgICAgICAqIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bVxuICAgICAgICAgKiBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZSB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0b1xuICAgICAgICAgKiByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxIGFuZCA8IEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogJ3RvRnJhY3Rpb24oKSBtYXggZGVub21pbmF0b3Igbm90IGFuIGludGVnZXI6IHttZH0nXG4gICAgICAgICAqICd0b0ZyYWN0aW9uKCkgbWF4IGRlbm9taW5hdG9yIG91dCBvZiByYW5nZToge21kfSdcbiAgICAgICAgICovXG4gICAgICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xuICAgICAgICAgICAgdmFyIGFyciwgZDAsIGQyLCBlLCBleHAsIG4sIG4wLCBxLCBzLFxuICAgICAgICAgICAgICAgIGsgPSBFUlJPUlMsXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXG4gICAgICAgICAgICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKSxcbiAgICAgICAgICAgICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpLFxuICAgICAgICAgICAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XG5cbiAgICAgICAgICAgIGlmICggbWQgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBFUlJPUlMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XG4gICAgICAgICAgICAgICAgRVJST1JTID0gaztcblxuICAgICAgICAgICAgICAgIGlmICggISggayA9IG4uaXNJbnQoKSApIHx8IG4ubHQoT05FKSApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoRVJST1JTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSggMjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdtYXggZGVub21pbmF0b3IgJyArICggayA/ICdvdXQgb2YgcmFuZ2UnIDogJ25vdCBhbiBpbnRlZ2VyJyApLCBtZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRVJST1JTIGlzIGZhbHNlOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBtZCBpcyBhIGZpbml0ZSBub24taW50ZWdlciA+PSAxLCByb3VuZCBpdCB0byBhbiBpbnRlZ2VyIGFuZCB1c2UgaXQuXG4gICAgICAgICAgICAgICAgICAgIG1kID0gIWsgJiYgbi5jICYmIHJvdW5kKCBuLCBuLmUgKyAxLCAxICkuZ3RlKE9ORSkgPyBuIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggIXhjICkgcmV0dXJuIHgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXG4gICAgICAgICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cbiAgICAgICAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XG4gICAgICAgICAgICBkLmNbMF0gPSBQT1dTX1RFTlsgKCBleHAgPSBlICUgTE9HX0JBU0UgKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cCBdO1xuICAgICAgICAgICAgbWQgPSAhbWQgfHwgbi5jbXAoZCkgPiAwID8gKCBlID4gMCA/IGQgOiBuMSApIDogbjtcblxuICAgICAgICAgICAgZXhwID0gTUFYX0VYUDtcbiAgICAgICAgICAgIE1BWF9FWFAgPSAxIC8gMDtcbiAgICAgICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xuXG4gICAgICAgICAgICAvLyBuMCA9IGQxID0gMFxuICAgICAgICAgICAgbjAuY1swXSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIDsgOyApICB7XG4gICAgICAgICAgICAgICAgcSA9IGRpdiggbiwgZCwgMCwgMSApO1xuICAgICAgICAgICAgICAgIGQyID0gZDAucGx1cyggcS50aW1lcyhkMSkgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGQyLmNtcChtZCkgPT0gMSApIGJyZWFrO1xuICAgICAgICAgICAgICAgIGQwID0gZDE7XG4gICAgICAgICAgICAgICAgZDEgPSBkMjtcbiAgICAgICAgICAgICAgICBuMSA9IG4wLnBsdXMoIHEudGltZXMoIGQyID0gbjEgKSApO1xuICAgICAgICAgICAgICAgIG4wID0gZDI7XG4gICAgICAgICAgICAgICAgZCA9IG4ubWludXMoIHEudGltZXMoIGQyID0gZCApICk7XG4gICAgICAgICAgICAgICAgbiA9IGQyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkMiA9IGRpdiggbWQubWludXMoZDApLCBkMSwgMCwgMSApO1xuICAgICAgICAgICAgbjAgPSBuMC5wbHVzKCBkMi50aW1lcyhuMSkgKTtcbiAgICAgICAgICAgIGQwID0gZDAucGx1cyggZDIudGltZXMoZDEpICk7XG4gICAgICAgICAgICBuMC5zID0gbjEucyA9IHgucztcbiAgICAgICAgICAgIGUgKj0gMjtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxuICAgICAgICAgICAgYXJyID0gZGl2KCBuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUgKS5taW51cyh4KS5hYnMoKS5jbXAoXG4gICAgICAgICAgICAgICAgICBkaXYoIG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSApLm1pbnVzKHgpLmFicygpICkgPCAxXG4gICAgICAgICAgICAgICAgICAgID8gWyBuMS50b1N0cmluZygpLCBkMS50b1N0cmluZygpIF1cbiAgICAgICAgICAgICAgICAgICAgOiBbIG4wLnRvU3RyaW5nKCksIGQwLnRvU3RyaW5nKCkgXTtcblxuICAgICAgICAgICAgTUFYX0VYUCA9IGV4cDtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgemVybyBoYXMgY29ycmVjdCBzaWduLlxuICAgICAgICAgICAgcmV0dXJuICt4IHx8ICggeC5zID8geC5zICogMCA6IE5hTiApO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByYWlzZWQgdG8gdGhlIHBvd2VyIG4uXG4gICAgICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxuICAgICAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vdCAwLCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXG4gICAgICAgICAqXG4gICAgICAgICAqIG4ge251bWJlcn0gSW50ZWdlciwgLTkwMDcxOTkyNTQ3NDA5OTIgdG8gOTAwNzE5OTI1NDc0MDk5MiBpbmNsdXNpdmUuXG4gICAgICAgICAqIChQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5Mi4pXG4gICAgICAgICAqXG4gICAgICAgICAqICdwb3coKSBleHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xuICAgICAgICAgKiAncG93KCkgZXhwb25lbnQgb3V0IG9mIHJhbmdlOiB7bn0nXG4gICAgICAgICAqL1xuICAgICAgICBQLnRvUG93ZXIgPSBQLnBvdyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgaywgeSxcbiAgICAgICAgICAgICAgICBpID0gbWF0aGZsb29yKCBuIDwgMCA/IC1uIDogK24gKSxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gUGFzcyDCsUluZmluaXR5IHRvIE1hdGgucG93IGlmIGV4cG9uZW50IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgICAgIGlmICggIWlzVmFsaWRJbnQoIG4sIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSLCAyMywgJ2V4cG9uZW50JyApICYmXG4gICAgICAgICAgICAgICggIWlzRmluaXRlKG4pIHx8IGkgPiBNQVhfU0FGRV9JTlRFR0VSICYmICggbiAvPSAwICkgfHxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KG4pICE9IG4gJiYgISggbiA9IE5hTiApICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIE1hdGgucG93KCAreCwgbiApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb24gZXF1YXRlc1xuICAgICAgICAgICAgLy8gdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLCBpLmUuIHRoZXJlIHdpbGwgYmUgYVxuICAgICAgICAgICAgLy8gbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuIChVc2luZyArIDEuNSB3b3VsZCBnaXZlIFs5LCAyMV0gZ3VhcmQgZGlnaXRzLilcbiAgICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OID8gbWF0aGNlaWwoIFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIgKSA6IDA7XG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xuXG4gICAgICAgICAgICBmb3IgKCA7IDsgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGkgJSAyICkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAheS5jICkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICggayAmJiB5LmMubGVuZ3RoID4gayApIHkuYy5sZW5ndGggPSBrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBtYXRoZmxvb3IoIGkgLyAyICk7XG4gICAgICAgICAgICAgICAgaWYgKCAhaSApIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgeCA9IHgudGltZXMoeCk7XG4gICAgICAgICAgICAgICAgaWYgKCBrICYmIHguYyAmJiB4LmMubGVuZ3RoID4gayApIHguYy5sZW5ndGggPSBrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG4gPCAwICkgeSA9IE9ORS5kaXYoeSk7XG4gICAgICAgICAgICByZXR1cm4gayA/IHJvdW5kKCB5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFICkgOiB5O1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcbiAgICAgICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcbiAgICAgICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcbiAgICAgICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogJ3RvUHJlY2lzaW9uKCkgcHJlY2lzaW9uIG5vdCBhbiBpbnRlZ2VyOiB7c2R9J1xuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSBwcmVjaXNpb24gb3V0IG9mIHJhbmdlOiB7c2R9J1xuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcbiAgICAgICAgICovXG4gICAgICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoIHNkLCBybSApIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsIHNkICE9IG51bGwgJiYgaXNWYWxpZEludCggc2QsIDEsIE1BWCwgMjQsICdwcmVjaXNpb24nIClcbiAgICAgICAgICAgICAgPyBzZCB8IDAgOiBudWxsLCBybSwgMjQgKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXG4gICAgICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXG4gICAgICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcbiAgICAgICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cbiAgICAgICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byA2NCBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqICd0b1N0cmluZygpIGJhc2Ugbm90IGFuIGludGVnZXI6IHtifSdcbiAgICAgICAgICogJ3RvU3RyaW5nKCkgYmFzZSBvdXQgb2YgcmFuZ2U6IHtifSdcbiAgICAgICAgICovXG4gICAgICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIHN0cixcbiAgICAgICAgICAgICAgICBuID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzID0gbi5zLFxuICAgICAgICAgICAgICAgIGUgPSBuLmU7XG5cbiAgICAgICAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cbiAgICAgICAgICAgIGlmICggZSA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcyA8IDAgKSBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJ05hTic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKCBuLmMgKTtcblxuICAgICAgICAgICAgICAgIGlmICggYiA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBiLCAyLCA2NCwgMjUsICdiYXNlJyApICkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXG4gICAgICAgICAgICAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKCBzdHIsIGUgKVxuICAgICAgICAgICAgICAgICAgICAgIDogdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSggdG9GaXhlZFBvaW50KCBzdHIsIGUgKSwgYiB8IDAsIDEwLCBzICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBzIDwgMCAmJiBuLmNbMF0gKSBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciB0cnVuY2F0ZWQgdG8gYSB3aG9sZVxuICAgICAgICAgKiBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBQLnRydW5jYXRlZCA9IFAudHJ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIG5ldyBCaWdOdW1iZXIodGhpcyksIHRoaXMuZSArIDEsIDEgKTtcbiAgICAgICAgfTtcblxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvLyBBbGlhc2VzIGZvciBCaWdEZWNpbWFsIG1ldGhvZHMuXG4gICAgICAgIC8vUC5hZGQgPSBQLnBsdXM7ICAgICAgICAgLy8gUC5hZGQgaW5jbHVkZWQgYWJvdmVcbiAgICAgICAgLy9QLnN1YnRyYWN0ID0gUC5taW51czsgICAvLyBQLnN1YiBpbmNsdWRlZCBhYm92ZVxuICAgICAgICAvL1AubXVsdGlwbHkgPSBQLnRpbWVzOyAgIC8vIFAubXVsIGluY2x1ZGVkIGFib3ZlXG4gICAgICAgIC8vUC5kaXZpZGUgPSBQLmRpdjtcbiAgICAgICAgLy9QLnJlbWFpbmRlciA9IFAubW9kO1xuICAgICAgICAvL1AuY29tcGFyZVRvID0gUC5jbXA7XG4gICAgICAgIC8vUC5uZWdhdGUgPSBQLm5lZztcblxuXG4gICAgICAgIGlmICggY29uZmlnT2JqICE9IG51bGwgKSBCaWdOdW1iZXIuY29uZmlnKGNvbmZpZ09iaik7XG5cbiAgICAgICAgcmV0dXJuIEJpZ051bWJlcjtcbiAgICB9XG5cblxuICAgIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xuXG5cbiAgICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XG4gICAgICAgIHZhciBpID0gbiB8IDA7XG4gICAgICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xuICAgIH1cblxuXG4gICAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXG4gICAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XG4gICAgICAgIHZhciBzLCB6LFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBqID0gYS5sZW5ndGgsXG4gICAgICAgICAgICByID0gYVswXSArICcnO1xuXG4gICAgICAgIGZvciAoIDsgaSA8IGo7ICkge1xuICAgICAgICAgICAgcyA9IGFbaSsrXSArICcnO1xuICAgICAgICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCA7IHotLTsgcyA9ICcwJyArIHMgKTtcbiAgICAgICAgICAgIHIgKz0gcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cbiAgICAgICAgZm9yICggaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7ICk7XG4gICAgICAgIHJldHVybiByLnNsaWNlKCAwLCBqICsgMSB8fCAxICk7XG4gICAgfVxuXG5cbiAgICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXG4gICAgZnVuY3Rpb24gY29tcGFyZSggeCwgeSApIHtcbiAgICAgICAgdmFyIGEsIGIsXG4gICAgICAgICAgICB4YyA9IHguYyxcbiAgICAgICAgICAgIHljID0geS5jLFxuICAgICAgICAgICAgaSA9IHgucyxcbiAgICAgICAgICAgIGogPSB5LnMsXG4gICAgICAgICAgICBrID0geC5lLFxuICAgICAgICAgICAgbCA9IHkuZTtcblxuICAgICAgICAvLyBFaXRoZXIgTmFOP1xuICAgICAgICBpZiAoICFpIHx8ICFqICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgYSA9IHhjICYmICF4Y1swXTtcbiAgICAgICAgYiA9IHljICYmICF5Y1swXTtcblxuICAgICAgICAvLyBFaXRoZXIgemVybz9cbiAgICAgICAgaWYgKCBhIHx8IGIgKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xuXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cbiAgICAgICAgaWYgKCBpICE9IGogKSByZXR1cm4gaTtcblxuICAgICAgICBhID0gaSA8IDA7XG4gICAgICAgIGIgPSBrID09IGw7XG5cbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xuICAgICAgICBpZiAoICF4YyB8fCAheWMgKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxuICAgICAgICBpZiAoICFiICkgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcblxuICAgICAgICBqID0gKCBrID0geGMubGVuZ3RoICkgPCAoIGwgPSB5Yy5sZW5ndGggKSA/IGsgOiBsO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgajsgaSsrICkgaWYgKCB4Y1tpXSAhPSB5Y1tpXSApIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcblxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHMuXG4gICAgICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBuIGlzIGEgdmFsaWQgbnVtYmVyIGluIHJhbmdlLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogVXNlIGZvciBhcmd1bWVudCB2YWxpZGF0aW9uIHdoZW4gRVJST1JTIGlzIGZhbHNlLlxuICAgICAqIE5vdGU6IHBhcnNlSW50KCcxZSsxJykgPT0gMSBidXQgcGFyc2VGbG9hdCgnMWUrMScpID09IDEwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludFZhbGlkYXRvck5vRXJyb3JzKCBuLCBtaW4sIG1heCApIHtcbiAgICAgICAgcmV0dXJuICggbiA9IHRydW5jYXRlKG4pICkgPj0gbWluICYmIG4gPD0gbWF4O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXG4gICAgICogRWcuIGNvbnZlcnRCYXNlKCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXG4gICAgICogRWcuIGNvbnZlcnRCYXNlKCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9CYXNlT3V0KCBzdHIsIGJhc2VJbiwgYmFzZU91dCApIHtcbiAgICAgICAgdmFyIGosXG4gICAgICAgICAgICBhcnIgPSBbMF0sXG4gICAgICAgICAgICBhcnJMLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIDsgaSA8IGxlbjsgKSB7XG4gICAgICAgICAgICBmb3IgKCBhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluICk7XG4gICAgICAgICAgICBhcnJbIGogPSAwIF0gKz0gQUxQSEFCRVQuaW5kZXhPZiggc3RyLmNoYXJBdCggaSsrICkgKTtcblxuICAgICAgICAgICAgZm9yICggOyBqIDwgYXJyLmxlbmd0aDsgaisrICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBhcnJbal0gPiBiYXNlT3V0IC0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJbaiArIDFdID09IG51bGwgKSBhcnJbaiArIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcbiAgICAgICAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKCBzdHIsIGUgKSB7XG4gICAgICAgIHJldHVybiAoIHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0ciApICtcbiAgICAgICAgICAoIGUgPCAwID8gJ2UnIDogJ2UrJyApICsgZTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRvRml4ZWRQb2ludCggc3RyLCBlICkge1xuICAgICAgICB2YXIgbGVuLCB6O1xuXG4gICAgICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xuICAgICAgICBpZiAoIGUgPCAwICkge1xuXG4gICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zLlxuICAgICAgICAgICAgZm9yICggeiA9ICcwLic7ICsrZTsgeiArPSAnMCcgKTtcbiAgICAgICAgICAgIHN0ciA9IHogKyBzdHI7XG5cbiAgICAgICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cbiAgICAgICAgICAgIGlmICggKytlID4gbGVuICkge1xuICAgICAgICAgICAgICAgIGZvciAoIHogPSAnMCcsIGUgLT0gbGVuOyAtLWU7IHogKz0gJzAnICk7XG4gICAgICAgICAgICAgICAgc3RyICs9IHo7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBlIDwgbGVuICkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggMCwgZSApICsgJy4nICsgc3RyLnNsaWNlKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRydW5jYXRlKG4pIHtcbiAgICAgICAgbiA9IHBhcnNlRmxvYXQobik7XG4gICAgICAgIHJldHVybiBuIDwgMCA/IG1hdGhjZWlsKG4pIDogbWF0aGZsb29yKG4pO1xuICAgIH1cblxuXG4gICAgLy8gRVhQT1JUXG5cblxuICAgIEJpZ051bWJlciA9IGFub3RoZXIoKTtcblxuICAgIC8vIEFNRC5cbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSApO1xuXG4gICAgLy8gTm9kZSBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcbiAgICAgICAgaWYgKCAhY3J5cHRvICkgdHJ5IHsgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7IH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBCcm93c2VyLlxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XG4gICAgfVxufSkodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2godGhpcyAmJiB0aGlzW2FyZ10gfHwgYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KHRoaXMsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKHRoaXMgJiYgdGhpc1trZXldIHx8IGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2JpbmQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2JpbmQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xuXHQgICAgdmFyIFNCT1ggPSBbXTtcblx0ICAgIHZhciBJTlZfU0JPWCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcblx0ICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgdmFyIHhpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxuXHQgICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuXHQgICAgICAgICAgICBTQk9YW3hdID0gc3g7XG5cdCAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcblx0ICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xuXHQgICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG5cdCAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5cdCAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2Vcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX25Sb3VuZHMgJiYgdGhpcy5fa2V5UHJpb3JSZXNldCA9PT0gdGhpcy5fa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblxuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG5cdCAgICAgICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XG5cdCAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcblx0ICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuXHQgICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG5cdCAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgczAgPSB0MDtcblx0ICAgICAgICAgICAgICAgIHMxID0gdDE7XG5cdCAgICAgICAgICAgICAgICBzMiA9IHQyO1xuXHQgICAgICAgICAgICAgICAgczMgPSB0Mztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDJdID0gdDI7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0Mztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkFFUztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0Q3J5cHRvSlMubGliLkNpcGhlciB8fCAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVFbmNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XG5cdCAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcblx0ICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3Ncblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXG5cblx0ICAgICAgICBfREVDX1hGT1JNX01PREU6IDIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0oKSlcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2Ugc3RyZWFtIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDFcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1vZGUgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19tb2RlID0gQy5tb2RlID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcblx0ICAgICAgICAgICAgdGhpcy5faXYgPSBpdjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBlbmNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkVuY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBkZWNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaXY7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBDQkM7XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhZGRpbmcgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNCkgfCAoblBhZGRpbmdCeXRlcyA8PCAxNikgfCAoblBhZGRpbmdCeXRlcyA8PCA4KSB8IG5QYWRkaW5nQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBtb2RlOiBDQkMsXG5cdCAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBjaXBoZXJcblx0ICAgICAgICAgICAgQ2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gY2ZnLml2O1xuXHQgICAgICAgICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGJsb2NrIG1vZGVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcblxuXHQgICAgICAgICAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcblxuXHQgICAgICAgICAgICAvLyBGaW5hbGl6ZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuXHQgICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuXHQgICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuXHQgICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcblx0ICAgICAgICAgICAgaWYgKHNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XG5cdCAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG5cdCAgICAgICAgICAgICAgICB2YXIgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxuXHQgICAgICAgICAgICAgICAga2V5OiBrZXksXG5cdCAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG5cdCAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxuXHQgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG5cdCAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWwgb2YgT2JqZWN0LmNyZWF0ZVxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fTtcblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuXG5cdCAgICAgICAgICAgIHN1YnR5cGUgPSBuZXcgRigpO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gbnVsbDtcblxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICB9O1xuXHQgICAgfSgpKVxuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIHZhciByID0gKGZ1bmN0aW9uIChtX3cpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtX3cgPSBtX3c7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV96ID0gMHgzYWRlNjhiMTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXNrID0gMHhmZmZmZmZmZjtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtX3ogPSAoMHg5MDY5ICogKG1feiAmIDB4RkZGRikgKyAobV96ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgbV93ID0gKDB4NDY1MCAqIChtX3cgJiAweEZGRkYpICsgKG1fdyA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoKG1feiA8PCAweDEwKSArIG1fdykgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gMC41O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKiAoTWF0aC5yYW5kb20oKSA+IC41ID8gMSA6IC0xKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHJjYWNoZTsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cblx0ICAgICAgICAgICAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaCgoX3IoKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblx0ICAgICAgICAgICAgdmFyIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwO1xuXG5cdCAgICAgICAgICAgIGlmICghcmV2ZXJzZU1hcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcFttYXAuY2hhckNvZGVBdChqKV0gPSBqO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElnbm9yZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCk7XG5cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21hcDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XG5cdCAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICB2YXIgbkJ5dGVzID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGkgJSA0KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMxID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpIC0gMSldIDw8ICgoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gKGJpdHMxIHwgYml0czIpIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgIG5CeXRlcysrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjQ7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgQkUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGYxNkJFID0gQ19lbmMuVXRmMTYgPSBDX2VuYy5VdGYxNkJFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmY7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBCRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNi5wYXJzZSh1dGYxNlN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgQ19lbmMuVXRmMTZMRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBzd2FwRW5kaWFuKCh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZik7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnBhcnNlKHV0ZjE2U3RyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHN3YXBFbmRpYW4odXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHN3YXBFbmRpYW4od29yZCkge1xuXHQgICAgICAgIHJldHVybiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmMTY7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy11dGYxNi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtdXRmMTYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTFcIiksIHJlcXVpcmUoXCIuL2htYWNcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMVwiLCBcIi4vaG1hY1wiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cblx0ICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG5cdCAgICAgKi9cblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxuXHQgICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG5cdCAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZXZwa2RmLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcztcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleDtcblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0O1xuXG5cdCAgICB2YXIgSGV4Rm9ybWF0dGVyID0gQ19mb3JtYXQuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoZSBjaXBoZXJ0ZXh0IG9mIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0LnRvU3RyaW5nKEhleCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIGNpcGhlcnRleHQgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gSGV4LnBhcnNlKGlucHV0KTtcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZm9ybWF0LkhleDtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9mb3JtYXQtaGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2htYWMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIiksIHJlcXVpcmUoXCIuL2xpYi10eXBlZGFycmF5c1wiKSwgcmVxdWlyZShcIi4vZW5jLXV0ZjE2XCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL3NoYTFcIiksIHJlcXVpcmUoXCIuL3NoYTI1NlwiKSwgcmVxdWlyZShcIi4vc2hhMjI0XCIpLCByZXF1aXJlKFwiLi9zaGE1MTJcIiksIHJlcXVpcmUoXCIuL3NoYTM4NFwiKSwgcmVxdWlyZShcIi4vc2hhM1wiKSwgcmVxdWlyZShcIi4vcmlwZW1kMTYwXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpLCByZXF1aXJlKFwiLi9wYmtkZjJcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIiksIHJlcXVpcmUoXCIuL21vZGUtY2ZiXCIpLCByZXF1aXJlKFwiLi9tb2RlLWN0clwiKSwgcmVxdWlyZShcIi4vbW9kZS1jdHItZ2xhZG1hblwiKSwgcmVxdWlyZShcIi4vbW9kZS1vZmJcIiksIHJlcXVpcmUoXCIuL21vZGUtZWNiXCIpLCByZXF1aXJlKFwiLi9wYWQtYW5zaXg5MjNcIiksIHJlcXVpcmUoXCIuL3BhZC1pc28xMDEyNlwiKSwgcmVxdWlyZShcIi4vcGFkLWlzbzk3OTcxXCIpLCByZXF1aXJlKFwiLi9wYWQtemVyb3BhZGRpbmdcIiksIHJlcXVpcmUoXCIuL3BhZC1ub3BhZGRpbmdcIiksIHJlcXVpcmUoXCIuL2Zvcm1hdC1oZXhcIiksIHJlcXVpcmUoXCIuL2Flc1wiKSwgcmVxdWlyZShcIi4vdHJpcGxlZGVzXCIpLCByZXF1aXJlKFwiLi9yYzRcIiksIHJlcXVpcmUoXCIuL3JhYmJpdFwiKSwgcmVxdWlyZShcIi4vcmFiYml0LWxlZ2FjeVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiLCBcIi4vbGliLXR5cGVkYXJyYXlzXCIsIFwiLi9lbmMtdXRmMTZcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vc2hhMVwiLCBcIi4vc2hhMjU2XCIsIFwiLi9zaGEyMjRcIiwgXCIuL3NoYTUxMlwiLCBcIi4vc2hhMzg0XCIsIFwiLi9zaGEzXCIsIFwiLi9yaXBlbWQxNjBcIiwgXCIuL2htYWNcIiwgXCIuL3Bia2RmMlwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiLCBcIi4vbW9kZS1jZmJcIiwgXCIuL21vZGUtY3RyXCIsIFwiLi9tb2RlLWN0ci1nbGFkbWFuXCIsIFwiLi9tb2RlLW9mYlwiLCBcIi4vbW9kZS1lY2JcIiwgXCIuL3BhZC1hbnNpeDkyM1wiLCBcIi4vcGFkLWlzbzEwMTI2XCIsIFwiLi9wYWQtaXNvOTc5NzFcIiwgXCIuL3BhZC16ZXJvcGFkZGluZ1wiLCBcIi4vcGFkLW5vcGFkZGluZ1wiLCBcIi4vZm9ybWF0LWhleFwiLCBcIi4vYWVzXCIsIFwiLi90cmlwbGVkZXNcIiwgXCIuL3JjNFwiLCBcIi4vcmFiYml0XCIsIFwiLi9yYWJiaXQtbGVnYWN5XCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0cm9vdC5DcnlwdG9KUyA9IGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBDaGVjayBpZiB0eXBlZCBhcnJheXMgYXJlIHN1cHBvcnRlZFxuXHQgICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cblx0ICAgIC8vIFJlZmVyZW5jZSBvcmlnaW5hbCBpbml0XG5cdCAgICB2YXIgc3VwZXJJbml0ID0gV29yZEFycmF5LmluaXQ7XG5cblx0ICAgIC8vIEF1Z21lbnQgV29yZEFycmF5LmluaXQgdG8gaGFuZGxlIHR5cGVkIGFycmF5c1xuXHQgICAgdmFyIHN1YkluaXQgPSBXb3JkQXJyYXkuaW5pdCA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdCAgICAgICAgLy8gQ29udmVydCBidWZmZXJzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29udmVydCBvdGhlciBhcnJheSB2aWV3cyB0byB1aW50OFxuXHQgICAgICAgIGlmIChcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuXHQgICAgICAgICAgICAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcblx0ICAgICAgICApIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gSGFuZGxlIFVpbnQ4QXJyYXlcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXlCeXRlTGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIEV4dHJhY3QgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWRBcnJheUJ5dGVMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gdHlwZWRBcnJheVtpXSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoaXMgd29yZCBhcnJheVxuXHQgICAgICAgICAgICBzdXBlckluaXQuY2FsbCh0aGlzLCB3b3JkcywgdHlwZWRBcnJheUJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIEVsc2UgY2FsbCBub3JtYWwgaW5pdFxuXHQgICAgICAgICAgICBzdXBlckluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBzdWJJbml0LnByb3RvdHlwZSA9IFdvcmRBcnJheTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9saWItdHlwZWRhcnJheXMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbGliLXR5cGVkYXJyYXlzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXG5cdCAgICB2YXIgVCA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgVFtpXSA9IChNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG5cdCAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG5cdCAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzAgID0gTVtvZmZzZXQgKyAwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEgID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzMgID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzQgID0gTVtvZmZzZXQgKyA0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzYgID0gTVtvZmZzZXQgKyA2XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzcgID0gTVtvZmZzZXQgKyA3XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzkgID0gTVtvZmZzZXQgKyA5XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEwID0gTVtvZmZzZXQgKyAxMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTIgPSBNW29mZnNldCArIDEyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEzID0gTVtvZmZzZXQgKyAxM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTUgPSBNW29mZnNldCArIDE1XTtcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhbGJlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA3LCAgVFswXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsICAyMiwgVFszXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNywgVFs2XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzksICAxMiwgVFs5XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsICBUWzEyXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG5cblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgIDksICBUWzE3XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDUsICBUWzIwXSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgIFRbMjFdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgIDIwLCBUWzIzXSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNSwgIFRbMjRdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE0LCBUWzI2XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAgMjAsIFRbMjddKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgIDksICBUWzI5XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTQsIFRbMzBdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNCwgIFRbMzJdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsICAxMSwgVFszM10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA0LCAgVFszNl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgIDExLCBUWzM3XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTYsIFRbMzhdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEwLCAyMywgVFszOV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsICBUWzQwXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8wLCAgMTEsIFRbNDFdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNiwgVFs0Ml0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgIDIzLCBUWzQzXSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNCwgIFRbNDRdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEyLCAxMSwgVFs0NV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAgMjMsIFRbNDddKTtcblxuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDYsICBUWzQ4XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgIDIxLCBUWzUxXSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDYsICBUWzYwXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgIDIxLCBUWzYzXSk7XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEwgPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDI0KSB8IChuQml0c1RvdGFsSCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgMjQpIHwgKG5CaXRzVG90YWxMID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xuXG5cdCAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgZCkgfCAoYyAmIH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY01ENShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuTUQ1O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBGZWVkYmFjayBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5DRkIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIENGQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIENGQi5FbmNyeXB0b3IgPSBDRkIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7XG5cblx0ICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgQ0ZCLkRlY3J5cHRvciA9IENGQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKTtcblxuXHQgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cdCAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0KHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gQ0ZCO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuQ0ZCO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKiBAcHJlc2VydmVcblx0ICogQ291bnRlciBibG9jayBtb2RlIGNvbXBhdGlibGUgd2l0aCAgRHIgQnJpYW4gR2xhZG1hbiBmaWxlZW5jLmNcblx0ICogZGVyaXZlZCBmcm9tIENyeXB0b0pTLm1vZGUuQ1RSXG5cdCAqIEphbiBIcnVieSBqaHJ1Ynkud2ViQGdtYWlsLmNvbVxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5DVFJHbGFkbWFuID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBDVFJHbGFkbWFuID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHRcdGZ1bmN0aW9uIGluY1dvcmQod29yZClcblx0XHR7XG5cdFx0XHRpZiAoKCh3b3JkID4+IDI0KSAmIDB4ZmYpID09PSAweGZmKSB7IC8vb3ZlcmZsb3dcblx0XHRcdHZhciBiMSA9ICh3b3JkID4+IDE2KSYweGZmO1xuXHRcdFx0dmFyIGIyID0gKHdvcmQgPj4gOCkmMHhmZjtcblx0XHRcdHZhciBiMyA9IHdvcmQgJiAweGZmO1xuXG5cdFx0XHRpZiAoYjEgPT09IDB4ZmYpIC8vIG92ZXJmbG93IGIxXG5cdFx0XHR7XG5cdFx0XHRiMSA9IDA7XG5cdFx0XHRpZiAoYjIgPT09IDB4ZmYpXG5cdFx0XHR7XG5cdFx0XHRcdGIyID0gMDtcblx0XHRcdFx0aWYgKGIzID09PSAweGZmKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YjMgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdCsrYjM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0KytiMjtcblx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdCsrYjE7XG5cdFx0XHR9XG5cblx0XHRcdHdvcmQgPSAwO1xuXHRcdFx0d29yZCArPSAoYjEgPDwgMTYpO1xuXHRcdFx0d29yZCArPSAoYjIgPDwgOCk7XG5cdFx0XHR3b3JkICs9IGIzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0d29yZCArPSAoMHgwMSA8PCAyNCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gd29yZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmNDb3VudGVyKGNvdW50ZXIpXG5cdFx0e1xuXHRcdFx0aWYgKChjb3VudGVyWzBdID0gaW5jV29yZChjb3VudGVyWzBdKSkgPT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGVuY3JfZGF0YSBpbiBmaWxlZW5jLmMgZnJvbSAgRHIgQnJpYW4gR2xhZG1hbidzIGNvdW50cyBvbmx5IHdpdGggRFdPUkQgaiA8IDhcblx0XHRcdFx0Y291bnRlclsxXSA9IGluY1dvcmQoY291bnRlclsxXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY291bnRlcjtcblx0XHR9XG5cblx0ICAgIHZhciBFbmNyeXB0b3IgPSBDVFJHbGFkbWFuLkVuY3J5cHRvciA9IENUUkdsYWRtYW4uZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyXG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblx0ICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cblx0XHRcdFx0aW5jQ291bnRlcihjb3VudGVyKTtcblxuXHRcdFx0XHR2YXIga2V5c3RyZWFtID0gY291bnRlci5zbGljZSgwKTtcblx0ICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIENUUkdsYWRtYW4uRGVjcnlwdG9yID0gRW5jcnlwdG9yO1xuXG5cdCAgICByZXR1cm4gQ1RSR2xhZG1hbjtcblx0fSgpKTtcblxuXG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DVFJHbGFkbWFuO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWN0ci1nbGFkbWFuLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY3RyLWdsYWRtYW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ291bnRlciBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5DVFIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIENUUiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIHZhciBFbmNyeXB0b3IgPSBDVFIuRW5jcnlwdG9yID0gQ1RSLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlclxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cdCAgICAgICAgICAgIHZhciBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlciA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gY291bnRlci5zbGljZSgwKTtcblx0ICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyXG5cdCAgICAgICAgICAgIGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gPSAoY291bnRlcltibG9ja1NpemUgLSAxXSArIDEpIHwgMFxuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIENUUi5EZWNyeXB0b3IgPSBFbmNyeXB0b3I7XG5cblx0ICAgIHJldHVybiBDVFI7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DVFI7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY3RyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtY3RyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIEVsZWN0cm9uaWMgQ29kZWJvb2sgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuRUNCID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBFQ0IgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICBFQ0IuRW5jcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBFQ0IuRGVjcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gRUNCO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuRUNCO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWVjYi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWVjYi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBPdXRwdXQgRmVlZGJhY2sgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuT0ZCID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBPRkIgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICB2YXIgRW5jcnlwdG9yID0gT0ZCLkVuY3J5cHRvciA9IE9GQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gdGhpcy5fa2V5c3RyZWFtO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGtleXN0cmVhbSA9IHRoaXMuX2tleXN0cmVhbSA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgT0ZCLkRlY3J5cHRvciA9IEVuY3J5cHRvcjtcblxuXHQgICAgcmV0dXJuIE9GQjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLk9GQjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1vZmIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1vZmIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQU5TSSBYLjkyMyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLkFuc2lYOTIzID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YVNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAvLyBDb21wdXRlIGxhc3QgYnl0ZSBwb3NpdGlvblxuXHQgICAgICAgIHZhciBsYXN0Qnl0ZVBvcyA9IGRhdGFTaWdCeXRlcyArIG5QYWRkaW5nQnl0ZXMgLSAxO1xuXG5cdCAgICAgICAgLy8gUGFkXG5cdCAgICAgICAgZGF0YS5jbGFtcCgpO1xuXHQgICAgICAgIGRhdGEud29yZHNbbGFzdEJ5dGVQb3MgPj4+IDJdIHw9IG5QYWRkaW5nQnl0ZXMgPDwgKDI0IC0gKGxhc3RCeXRlUG9zICUgNCkgKiA4KTtcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzICs9IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLkFuc2l4OTIzO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtYW5zaXg5MjMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWFuc2l4OTIzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIElTTyAxMDEyNiBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLklzbzEwMTI2ID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAvLyBQYWRcblx0ICAgICAgICBkYXRhLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbShuUGFkZGluZ0J5dGVzIC0gMSkpLlxuXHQgICAgICAgICAgICAgY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtuUGFkZGluZ0J5dGVzIDw8IDI0XSwgMSkpO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5Jc28xMDEyNjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWlzbzEwMTI2LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc28xMDEyNi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBJU08vSUVDIDk3OTctMSBQYWRkaW5nIE1ldGhvZCAyLlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLklzbzk3OTcxID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gQWRkIDB4ODAgYnl0ZVxuXHQgICAgICAgIGRhdGEuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDgwMDAwMDAwXSwgMSkpO1xuXG5cdCAgICAgICAgLy8gWmVybyBwYWQgdGhlIHJlc3Rcblx0ICAgICAgICBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcucGFkKGRhdGEsIGJsb2NrU2l6ZSk7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBSZW1vdmUgemVybyBwYWRkaW5nXG5cdCAgICAgICAgQ3J5cHRvSlMucGFkLlplcm9QYWRkaW5nLnVucGFkKGRhdGEpO1xuXG5cdCAgICAgICAgLy8gUmVtb3ZlIG9uZSBtb3JlIGJ5dGUgLS0gdGhlIDB4ODAgYnl0ZVxuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMtLTtcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuSXNvOTc5NzE7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvOTc5NzEuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQSBub29wIHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuTm9QYWRkaW5nID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKCkge1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5Ob1BhZGRpbmc7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1ub3BhZGRpbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLW5vcGFkZGluZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBaZXJvIHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAvLyBQYWRcblx0ICAgICAgICBkYXRhLmNsYW1wKCk7XG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyArPSBibG9ja1NpemVCeXRlcyAtICgoZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzKSB8fCBibG9ja1NpemVCeXRlcyk7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgLy8gVW5wYWRcblx0ICAgICAgICB2YXIgaSA9IGRhdGEuc2lnQnl0ZXMgLSAxO1xuXHQgICAgICAgIHdoaWxlICghKChkYXRhV29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmKSkge1xuXHQgICAgICAgICAgICBpLS07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBpICsgMTtcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmc7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC16ZXJvcGFkZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtemVyb3BhZGRpbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTFcIiksIHJlcXVpcmUoXCIuL2htYWNcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMVwiLCBcIi4vaG1hY1wiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExO1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBCS0RGMiA9IENfYWxnby5QQktERjIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlLiBEZWZhdWx0OiBTSEExXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IFNIQTEsXG5cdCAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblxuXHQgICAgICAgICAgICAvLyBJbml0IEhNQUNcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBITUFDLmNyZWF0ZShjZmcuaGFzaGVyLCBwYXNzd29yZCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgIHZhciBibG9ja0luZGV4ID0gV29yZEFycmF5LmNyZWF0ZShbMHgwMDAwMDAwMV0pO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrSW5kZXhXb3JkcyA9IGJsb2NrSW5kZXgud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaG1hYy51cGRhdGUoc2FsdCkuZmluYWxpemUoYmxvY2tJbmRleCk7XG5cdCAgICAgICAgICAgICAgICBobWFjLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrV29yZHMgPSBibG9jay53b3Jkcztcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1dvcmRzTGVuZ3RoID0gYmxvY2tXb3Jkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGUgPSBibG9jaztcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gaG1hYy5maW5hbGl6ZShpbnRlcm1lZGlhdGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGhtYWMucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGludGVybWVkaWF0ZVdvcmRzID0gaW50ZXJtZWRpYXRlLndvcmRzO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gWE9SIGludGVybWVkaWF0ZSB3aXRoIGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBibG9ja1dvcmRzTGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tXb3Jkc1tqXSBePSBpbnRlcm1lZGlhdGVXb3Jkc1tqXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIGJsb2NrSW5kZXhXb3Jkc1swXSsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb21wdXRlcyB0aGUgUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMi5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgKi9cblx0ICAgIEMuUEJLREYyID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcblx0ICAgICAgICByZXR1cm4gUEJLREYyLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5QQktERjI7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3Bia2RmMi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzXG5cdCAgICB2YXIgUyAgPSBbXTtcblx0ICAgIHZhciBDXyA9IFtdO1xuXHQgICAgdmFyIEcgID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmFiYml0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICpcblx0ICAgICAqIFRoaXMgaXMgYSBsZWdhY3kgdmVyc2lvbiB0aGF0IG5lZ2xlY3RlZCB0byBjb252ZXJ0IHRoZSBrZXkgdG8gbGl0dGxlLWVuZGlhbi5cblx0ICAgICAqIFRoaXMgZXJyb3IgZG9lc24ndCBhZmZlY3QgdGhlIGNpcGhlcidzIHNlY3VyaXR5LFxuXHQgICAgICogYnV0IGl0IGRvZXMgYWZmZWN0IGl0cyBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zLlxuXHQgICAgICovXG5cdCAgICB2YXIgUmFiYml0TGVnYWN5ID0gQ19hbGdvLlJhYmJpdExlZ2FjeSA9IFN0cmVhbUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSyA9IHRoaXMuX2tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5jZmcuaXY7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YID0gW1xuXHQgICAgICAgICAgICAgICAgS1swXSwgKEtbM10gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMV0sIChLWzBdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzJdLCAoS1sxXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1szXSwgKEtbMl0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIEMgPSB0aGlzLl9DID0gW1xuXHQgICAgICAgICAgICAgICAgKEtbMl0gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSwgKEtbMF0gJiAweGZmZmYwMDAwKSB8IChLWzFdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1szXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLCAoS1sxXSAmIDB4ZmZmZjAwMDApIHwgKEtbMl0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzBdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksIChLWzJdICYgMHhmZmZmMDAwMCkgfCAoS1szXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMV0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KSwgKEtbM10gJiAweGZmZmYwMDAwKSB8IChLWzBdICYgMHgwMDAwZmZmZilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBDYXJyeSBiaXRcblx0ICAgICAgICAgICAgdGhpcy5fYiA9IDA7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBjb3VudGVyc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgQ1tpXSBePSBYWyhpICsgNCkgJiA3XTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElWIHNldHVwXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgSVYgPSBpdi53b3Jkcztcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8wID0gSVZbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMSA9IElWWzFdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIHN1YnZlY3RvcnNcblx0ICAgICAgICAgICAgICAgIHZhciBpMCA9ICgoKElWXzAgPDwgOCkgfCAoSVZfMCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMCA8PCAyNCkgfCAoSVZfMCA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTIgPSAoKChJVl8xIDw8IDgpIHwgKElWXzEgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzEgPDwgMjQpIHwgKElWXzEgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkxID0gKGkwID4+PiAxNikgfCAoaTIgJiAweGZmZmYwMDAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMyA9IChpMiA8PCAxNikgIHwgKGkwICYgMHgwMDAwZmZmZik7XG5cblx0ICAgICAgICAgICAgICAgIC8vIE1vZGlmeSBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgQ1swXSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbMV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzJdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1szXSBePSBpMztcblx0ICAgICAgICAgICAgICAgIENbNF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzVdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1s2XSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbN10gXj0gaTM7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtXG5cdCAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIga2V5c3RyZWFtIHdvcmRzXG5cdCAgICAgICAgICAgIFNbMF0gPSBYWzBdIF4gKFhbNV0gPj4+IDE2KSBeIChYWzNdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1sxXSA9IFhbMl0gXiAoWFs3XSA+Pj4gMTYpIF4gKFhbNV0gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzJdID0gWFs0XSBeIChYWzFdID4+PiAxNikgXiAoWFs3XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbM10gPSBYWzZdIF4gKFhbM10gPj4+IDE2KSBeIChYWzFdIDw8IDE2KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIFNbaV0gPSAoKChTW2ldIDw8IDgpICB8IChTW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKFNbaV0gPDwgMjQpIHwgKFNbaV0gPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXQgKyBpXSBePSBTW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cdCAgICAgICAgdmFyIEMgPSB0aGlzLl9DO1xuXG5cdCAgICAgICAgLy8gU2F2ZSBvbGQgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICBDX1tpXSA9IENbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIENbMF0gPSAoQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iKSB8IDA7XG5cdCAgICAgICAgQ1sxXSA9IChDWzFdICsgMHhkMzRkMzRkMyArICgoQ1swXSA+Pj4gMCkgPCAoQ19bMF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1syXSA9IChDWzJdICsgMHgzNGQzNGQzNCArICgoQ1sxXSA+Pj4gMCkgPCAoQ19bMV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1szXSA9IChDWzNdICsgMHg0ZDM0ZDM0ZCArICgoQ1syXSA+Pj4gMCkgPCAoQ19bMl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s0XSA9IChDWzRdICsgMHhkMzRkMzRkMyArICgoQ1szXSA+Pj4gMCkgPCAoQ19bM10gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s1XSA9IChDWzVdICsgMHgzNGQzNGQzNCArICgoQ1s0XSA+Pj4gMCkgPCAoQ19bNF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s2XSA9IChDWzZdICsgMHg0ZDM0ZDM0ZCArICgoQ1s1XSA+Pj4gMCkgPCAoQ19bNV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s3XSA9IChDWzddICsgMHhkMzRkMzRkMyArICgoQ1s2XSA+Pj4gMCkgPCAoQ19bNl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgdGhpcy5fYiA9IChDWzddID4+PiAwKSA8IChDX1s3XSA+Pj4gMCkgPyAxIDogMDtcblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZy12YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZ3ggPSBYW2ldICsgQ1tpXTtcblxuXHQgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgaGlnaCBhbmQgbG93IGFyZ3VtZW50IGZvciBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2EgPSBneCAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgdmFyIGdiID0gZ3ggPj4+IDE2O1xuXG5cdCAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBoaWdoIGFuZCBsb3cgcmVzdWx0IG9mIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnaCA9ICgoKChnYSAqIGdhKSA+Pj4gMTcpICsgZ2EgKiBnYikgPj4+IDE1KSArIGdiICogZ2I7XG5cdCAgICAgICAgICAgIHZhciBnbCA9ICgoKGd4ICYgMHhmZmZmMDAwMCkgKiBneCkgfCAwKSArICgoKGd4ICYgMHgwMDAwZmZmZikgKiBneCkgfCAwKTtcblxuXHQgICAgICAgICAgICAvLyBIaWdoIFhPUiBsb3dcblx0ICAgICAgICAgICAgR1tpXSA9IGdoIF4gZ2w7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICBYWzBdID0gKEdbMF0gKyAoKEdbN10gPDwgMTYpIHwgKEdbN10gPj4+IDE2KSkgKyAoKEdbNl0gPDwgMTYpIHwgKEdbNl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzFdID0gKEdbMV0gKyAoKEdbMF0gPDwgOCkgIHwgKEdbMF0gPj4+IDI0KSkgKyBHWzddKSB8IDA7XG5cdCAgICAgICAgWFsyXSA9IChHWzJdICsgKChHWzFdIDw8IDE2KSB8IChHWzFdID4+PiAxNikpICsgKChHWzBdIDw8IDE2KSB8IChHWzBdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFszXSA9IChHWzNdICsgKChHWzJdIDw8IDgpICB8IChHWzJdID4+PiAyNCkpICsgR1sxXSkgfCAwO1xuXHQgICAgICAgIFhbNF0gPSAoR1s0XSArICgoR1szXSA8PCAxNikgfCAoR1szXSA+Pj4gMTYpKSArICgoR1syXSA8PCAxNikgfCAoR1syXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbNV0gPSAoR1s1XSArICgoR1s0XSA8PCA4KSAgfCAoR1s0XSA+Pj4gMjQpKSArIEdbM10pIHwgMDtcblx0ICAgICAgICBYWzZdID0gKEdbNl0gKyAoKEdbNV0gPDwgMTYpIHwgKEdbNV0gPj4+IDE2KSkgKyAoKEdbNF0gPDwgMTYpIHwgKEdbNF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzddID0gKEdbN10gKyAoKEdbNl0gPDwgOCkgIHwgKEdbNl0gPj4+IDI0KSkgKyBHWzVdKSB8IDA7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJhYmJpdExlZ2FjeSA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdExlZ2FjeSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUmFiYml0TGVnYWN5O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQtbGVnYWN5LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC1sZWdhY3kuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzXG5cdCAgICB2YXIgUyAgPSBbXTtcblx0ICAgIHZhciBDXyA9IFtdO1xuXHQgICAgdmFyIEcgID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmFiYml0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtXG5cdCAgICAgKi9cblx0ICAgIHZhciBSYWJiaXQgPSBDX2FsZ28uUmFiYml0ID0gU3RyZWFtQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBLID0gdGhpcy5fa2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLmNmZy5pdjtcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgS1tpXSA9ICgoKEtbaV0gPDwgOCkgIHwgKEtbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoS1tpXSA8PCAyNCkgfCAoS1tpXSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YID0gW1xuXHQgICAgICAgICAgICAgICAgS1swXSwgKEtbM10gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMV0sIChLWzBdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzJdLCAoS1sxXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1szXSwgKEtbMl0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIEMgPSB0aGlzLl9DID0gW1xuXHQgICAgICAgICAgICAgICAgKEtbMl0gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSwgKEtbMF0gJiAweGZmZmYwMDAwKSB8IChLWzFdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1szXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLCAoS1sxXSAmIDB4ZmZmZjAwMDApIHwgKEtbMl0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzBdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksIChLWzJdICYgMHhmZmZmMDAwMCkgfCAoS1szXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMV0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KSwgKEtbM10gJiAweGZmZmYwMDAwKSB8IChLWzBdICYgMHgwMDAwZmZmZilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBDYXJyeSBiaXRcblx0ICAgICAgICAgICAgdGhpcy5fYiA9IDA7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBjb3VudGVyc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgQ1tpXSBePSBYWyhpICsgNCkgJiA3XTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElWIHNldHVwXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgSVYgPSBpdi53b3Jkcztcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8wID0gSVZbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMSA9IElWWzFdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIHN1YnZlY3RvcnNcblx0ICAgICAgICAgICAgICAgIHZhciBpMCA9ICgoKElWXzAgPDwgOCkgfCAoSVZfMCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMCA8PCAyNCkgfCAoSVZfMCA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTIgPSAoKChJVl8xIDw8IDgpIHwgKElWXzEgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzEgPDwgMjQpIHwgKElWXzEgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkxID0gKGkwID4+PiAxNikgfCAoaTIgJiAweGZmZmYwMDAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMyA9IChpMiA8PCAxNikgIHwgKGkwICYgMHgwMDAwZmZmZik7XG5cblx0ICAgICAgICAgICAgICAgIC8vIE1vZGlmeSBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgQ1swXSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbMV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzJdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1szXSBePSBpMztcblx0ICAgICAgICAgICAgICAgIENbNF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzVdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1s2XSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbN10gXj0gaTM7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtXG5cdCAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIga2V5c3RyZWFtIHdvcmRzXG5cdCAgICAgICAgICAgIFNbMF0gPSBYWzBdIF4gKFhbNV0gPj4+IDE2KSBeIChYWzNdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1sxXSA9IFhbMl0gXiAoWFs3XSA+Pj4gMTYpIF4gKFhbNV0gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzJdID0gWFs0XSBeIChYWzFdID4+PiAxNikgXiAoWFs3XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbM10gPSBYWzZdIF4gKFhbM10gPj4+IDE2KSBeIChYWzFdIDw8IDE2KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIFNbaV0gPSAoKChTW2ldIDw8IDgpICB8IChTW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKFNbaV0gPDwgMjQpIHwgKFNbaV0gPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXQgKyBpXSBePSBTW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cdCAgICAgICAgdmFyIEMgPSB0aGlzLl9DO1xuXG5cdCAgICAgICAgLy8gU2F2ZSBvbGQgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICBDX1tpXSA9IENbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIENbMF0gPSAoQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iKSB8IDA7XG5cdCAgICAgICAgQ1sxXSA9IChDWzFdICsgMHhkMzRkMzRkMyArICgoQ1swXSA+Pj4gMCkgPCAoQ19bMF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1syXSA9IChDWzJdICsgMHgzNGQzNGQzNCArICgoQ1sxXSA+Pj4gMCkgPCAoQ19bMV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1szXSA9IChDWzNdICsgMHg0ZDM0ZDM0ZCArICgoQ1syXSA+Pj4gMCkgPCAoQ19bMl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s0XSA9IChDWzRdICsgMHhkMzRkMzRkMyArICgoQ1szXSA+Pj4gMCkgPCAoQ19bM10gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s1XSA9IChDWzVdICsgMHgzNGQzNGQzNCArICgoQ1s0XSA+Pj4gMCkgPCAoQ19bNF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s2XSA9IChDWzZdICsgMHg0ZDM0ZDM0ZCArICgoQ1s1XSA+Pj4gMCkgPCAoQ19bNV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s3XSA9IChDWzddICsgMHhkMzRkMzRkMyArICgoQ1s2XSA+Pj4gMCkgPCAoQ19bNl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgdGhpcy5fYiA9IChDWzddID4+PiAwKSA8IChDX1s3XSA+Pj4gMCkgPyAxIDogMDtcblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZy12YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZ3ggPSBYW2ldICsgQ1tpXTtcblxuXHQgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgaGlnaCBhbmQgbG93IGFyZ3VtZW50IGZvciBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2EgPSBneCAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgdmFyIGdiID0gZ3ggPj4+IDE2O1xuXG5cdCAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBoaWdoIGFuZCBsb3cgcmVzdWx0IG9mIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnaCA9ICgoKChnYSAqIGdhKSA+Pj4gMTcpICsgZ2EgKiBnYikgPj4+IDE1KSArIGdiICogZ2I7XG5cdCAgICAgICAgICAgIHZhciBnbCA9ICgoKGd4ICYgMHhmZmZmMDAwMCkgKiBneCkgfCAwKSArICgoKGd4ICYgMHgwMDAwZmZmZikgKiBneCkgfCAwKTtcblxuXHQgICAgICAgICAgICAvLyBIaWdoIFhPUiBsb3dcblx0ICAgICAgICAgICAgR1tpXSA9IGdoIF4gZ2w7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICBYWzBdID0gKEdbMF0gKyAoKEdbN10gPDwgMTYpIHwgKEdbN10gPj4+IDE2KSkgKyAoKEdbNl0gPDwgMTYpIHwgKEdbNl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzFdID0gKEdbMV0gKyAoKEdbMF0gPDwgOCkgIHwgKEdbMF0gPj4+IDI0KSkgKyBHWzddKSB8IDA7XG5cdCAgICAgICAgWFsyXSA9IChHWzJdICsgKChHWzFdIDw8IDE2KSB8IChHWzFdID4+PiAxNikpICsgKChHWzBdIDw8IDE2KSB8IChHWzBdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFszXSA9IChHWzNdICsgKChHWzJdIDw8IDgpICB8IChHWzJdID4+PiAyNCkpICsgR1sxXSkgfCAwO1xuXHQgICAgICAgIFhbNF0gPSAoR1s0XSArICgoR1szXSA8PCAxNikgfCAoR1szXSA+Pj4gMTYpKSArICgoR1syXSA8PCAxNikgfCAoR1syXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbNV0gPSAoR1s1XSArICgoR1s0XSA8PCA4KSAgfCAoR1s0XSA+Pj4gMjQpKSArIEdbM10pIHwgMDtcblx0ICAgICAgICBYWzZdID0gKEdbNl0gKyAoKEdbNV0gPDwgMTYpIHwgKEdbNV0gPj4+IDE2KSkgKyAoKEdbNF0gPDwgMTYpIHwgKEdbNF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzddID0gKEdbN10gKyAoKEdbNl0gPDwgOCkgIHwgKEdbNl0gPj4+IDI0KSkgKyBHWzVdKSB8IDA7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUmFiYml0LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUmFiYml0LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJhYmJpdCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUmFiYml0O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yYWJiaXQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmFiYml0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBSQzQgPSBDX2FsZ28uUkM0ID0gU3RyZWFtQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpZ0J5dGVzID0ga2V5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgc2JveFxuXHQgICAgICAgICAgICB2YXIgUyA9IHRoaXMuX1MgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgU1tpXSA9IGk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBLZXkgc2V0dXBcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlCeXRlSW5kZXggPSBpICUga2V5U2lnQnl0ZXM7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5Qnl0ZSA9IChrZXlXb3Jkc1trZXlCeXRlSW5kZXggPj4+IDJdID4+PiAoMjQgLSAoa2V5Qnl0ZUluZGV4ICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICBqID0gKGogKyBTW2ldICsga2V5Qnl0ZSkgJSAyNTY7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gU1tpXTtcblx0ICAgICAgICAgICAgICAgIFNbaV0gPSBTW2pdO1xuXHQgICAgICAgICAgICAgICAgU1tqXSA9IHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudGVyc1xuXHQgICAgICAgICAgICB0aGlzLl9pID0gdGhpcy5faiA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICBNW29mZnNldF0gXj0gZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkLmNhbGwodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtV29yZCgpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgUyA9IHRoaXMuX1M7XG5cdCAgICAgICAgdmFyIGkgPSB0aGlzLl9pO1xuXHQgICAgICAgIHZhciBqID0gdGhpcy5fajtcblxuXHQgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbSB3b3JkXG5cdCAgICAgICAgdmFyIGtleXN0cmVhbVdvcmQgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNDsgbisrKSB7XG5cdCAgICAgICAgICAgIGkgPSAoaSArIDEpICUgMjU2O1xuXHQgICAgICAgICAgICBqID0gKGogKyBTW2ldKSAlIDI1NjtcblxuXHQgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgIHZhciB0ID0gU1tpXTtcblx0ICAgICAgICAgICAgU1tpXSA9IFNbal07XG5cdCAgICAgICAgICAgIFNbal0gPSB0O1xuXG5cdCAgICAgICAgICAgIGtleXN0cmVhbVdvcmQgfD0gU1soU1tpXSArIFNbal0pICUgMjU2XSA8PCAoMjQgLSBuICogOCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVXBkYXRlIGNvdW50ZXJzXG5cdCAgICAgICAgdGhpcy5faSA9IGk7XG5cdCAgICAgICAgdGhpcy5faiA9IGo7XG5cblx0ICAgICAgICByZXR1cm4ga2V5c3RyZWFtV29yZDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SQzQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SQzQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUkM0ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RpZmllZCBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBSQzREcm9wID0gQ19hbGdvLlJDNERyb3AgPSBSQzQuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJvcCBUaGUgbnVtYmVyIG9mIGtleXN0cmVhbSB3b3JkcyB0byBkcm9wLiBEZWZhdWx0IDE5MlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogUkM0LmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBkcm9wOiAxOTJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIFJDNC5fZG9SZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIERyb3Bcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2ZnLmRyb3A7IGkgPiAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0RHJvcC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJDNERyb3AuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUkM0RHJvcCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJDNERyb3ApO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJDNDtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JjNC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKiBAcHJlc2VydmVcblx0KGMpIDIwMTIgYnkgQ8OpZHJpYyBNZXNuaWwuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblx0UmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG5cdCAgICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblx0ICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5cdFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblx0Ki9cblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBfemwgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuXHQgICAgICAgIDcsICA0LCAxMywgIDEsIDEwLCAgNiwgMTUsICAzLCAxMiwgIDAsICA5LCAgNSwgIDIsIDE0LCAxMSwgIDgsXG5cdCAgICAgICAgMywgMTAsIDE0LCAgNCwgIDksIDE1LCAgOCwgIDEsICAyLCAgNywgIDAsICA2LCAxMywgMTEsICA1LCAxMixcblx0ICAgICAgICAxLCAgOSwgMTEsIDEwLCAgMCwgIDgsIDEyLCAgNCwgMTMsICAzLCAgNywgMTUsIDE0LCAgNSwgIDYsICAyLFxuXHQgICAgICAgIDQsICAwLCAgNSwgIDksICA3LCAxMiwgIDIsIDEwLCAxNCwgIDEsICAzLCAgOCwgMTEsICA2LCAxNSwgMTNdKTtcblx0ICAgIHZhciBfenIgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICA1LCAxNCwgIDcsICAwLCAgOSwgIDIsIDExLCAgNCwgMTMsICA2LCAxNSwgIDgsICAxLCAxMCwgIDMsIDEyLFxuXHQgICAgICAgIDYsIDExLCAgMywgIDcsICAwLCAxMywgIDUsIDEwLCAxNCwgMTUsICA4LCAxMiwgIDQsICA5LCAgMSwgIDIsXG5cdCAgICAgICAgMTUsICA1LCAgMSwgIDMsICA3LCAxNCwgIDYsICA5LCAxMSwgIDgsIDEyLCAgMiwgMTAsICAwLCAgNCwgMTMsXG5cdCAgICAgICAgOCwgIDYsICA0LCAgMSwgIDMsIDExLCAxNSwgIDAsICA1LCAxMiwgIDIsIDEzLCAgOSwgIDcsIDEwLCAxNCxcblx0ICAgICAgICAxMiwgMTUsIDEwLCAgNCwgIDEsICA1LCAgOCwgIDcsICA2LCAgMiwgMTMsIDE0LCAgMCwgIDMsICA5LCAxMV0pO1xuXHQgICAgdmFyIF9zbCA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgICAxMSwgMTQsIDE1LCAxMiwgIDUsICA4LCAgNywgIDksIDExLCAxMywgMTQsIDE1LCAgNiwgIDcsICA5LCAgOCxcblx0ICAgICAgICA3LCA2LCAgIDgsIDEzLCAxMSwgIDksICA3LCAxNSwgIDcsIDEyLCAxNSwgIDksIDExLCAgNywgMTMsIDEyLFxuXHQgICAgICAgIDExLCAxMywgIDYsICA3LCAxNCwgIDksIDEzLCAxNSwgMTQsICA4LCAxMywgIDYsICA1LCAxMiwgIDcsICA1LFxuXHQgICAgICAgICAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgIDksICA4LCAgOSwgMTQsICA1LCAgNiwgIDgsICA2LCAgNSwgMTIsXG5cdCAgICAgICAgOSwgMTUsICA1LCAxMSwgIDYsICA4LCAxMywgMTIsICA1LCAxMiwgMTMsIDE0LCAxMSwgIDgsICA1LCAgNiBdKTtcblx0ICAgIHZhciBfc3IgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICA4LCAgOSwgIDksIDExLCAxMywgMTUsIDE1LCAgNSwgIDcsICA3LCAgOCwgMTEsIDE0LCAxNCwgMTIsICA2LFxuXHQgICAgICAgIDksIDEzLCAxNSwgIDcsIDEyLCAgOCwgIDksIDExLCAgNywgIDcsIDEyLCAgNywgIDYsIDE1LCAxMywgMTEsXG5cdCAgICAgICAgOSwgIDcsIDE1LCAxMSwgIDgsICA2LCAgNiwgMTQsIDEyLCAxMywgIDUsIDE0LCAxMywgMTMsICA3LCAgNSxcblx0ICAgICAgICAxNSwgIDUsICA4LCAxMSwgMTQsIDE0LCAgNiwgMTQsICA2LCAgOSwgMTIsICA5LCAxMiwgIDUsIDE1LCAgOCxcblx0ICAgICAgICA4LCAgNSwgMTIsICA5LCAxMiwgIDUsIDE0LCAgNiwgIDgsIDEzLCAgNiwgIDUsIDE1LCAxMywgMTEsIDExIF0pO1xuXG5cdCAgICB2YXIgX2hsID0gIFdvcmRBcnJheS5jcmVhdGUoWyAweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXSk7XG5cdCAgICB2YXIgX2hyID0gIFdvcmRBcnJheS5jcmVhdGUoWyAweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUklQRU1EMTYwIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUklQRU1EMTYwID0gQ19hbGdvLlJJUEVNRDE2MCA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggID0gV29yZEFycmF5LmNyZWF0ZShbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3NiwgMHhDM0QyRTFGMF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIICA9IHRoaXMuX2hhc2gud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBobCA9IF9obC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGhyID0gX2hyLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgemwgPSBfemwud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB6ciA9IF96ci53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNsID0gX3NsLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc3IgPSBfc3Iud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGFsLCBibCwgY2wsIGRsLCBlbDtcblx0ICAgICAgICAgICAgdmFyIGFyLCBiciwgY3IsIGRyLCBlcjtcblxuXHQgICAgICAgICAgICBhciA9IGFsID0gSFswXTtcblx0ICAgICAgICAgICAgYnIgPSBibCA9IEhbMV07XG5cdCAgICAgICAgICAgIGNyID0gY2wgPSBIWzJdO1xuXHQgICAgICAgICAgICBkciA9IGRsID0gSFszXTtcblx0ICAgICAgICAgICAgZXIgPSBlbCA9IEhbNF07XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIHZhciB0O1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgIHQgPSAoYWwgKyAgTVtvZmZzZXQremxbaV1dKXwwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGk8MTYpe1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYxKGJsLGNsLGRsKSArIGhsWzBdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDMyKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjIoYmwsY2wsZGwpICsgaGxbMV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NDgpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMyhibCxjbCxkbCkgKyBobFsyXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw2NCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY0KGJsLGNsLGRsKSArIGhsWzNdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY1KGJsLGNsLGRsKSArIGhsWzRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdCA9IHR8MDtcblx0ICAgICAgICAgICAgICAgIHQgPSAgcm90bCh0LHNsW2ldKTtcblx0ICAgICAgICAgICAgICAgIHQgPSAodCtlbCl8MDtcblx0ICAgICAgICAgICAgICAgIGFsID0gZWw7XG5cdCAgICAgICAgICAgICAgICBlbCA9IGRsO1xuXHQgICAgICAgICAgICAgICAgZGwgPSByb3RsKGNsLCAxMCk7XG5cdCAgICAgICAgICAgICAgICBjbCA9IGJsO1xuXHQgICAgICAgICAgICAgICAgYmwgPSB0O1xuXG5cdCAgICAgICAgICAgICAgICB0ID0gKGFyICsgTVtvZmZzZXQrenJbaV1dKXwwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGk8MTYpe1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY1KGJyLGNyLGRyKSArIGhyWzBdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDMyKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjQoYnIsY3IsZHIpICsgaHJbMV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NDgpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMyhicixjcixkcikgKyBoclsyXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw2NCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYyKGJyLGNyLGRyKSArIGhyWzNdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYxKGJyLGNyLGRyKSArIGhyWzRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdCA9IHR8MDtcblx0ICAgICAgICAgICAgICAgIHQgPSAgcm90bCh0LHNyW2ldKSA7XG5cdCAgICAgICAgICAgICAgICB0ID0gKHQrZXIpfDA7XG5cdCAgICAgICAgICAgICAgICBhciA9IGVyO1xuXHQgICAgICAgICAgICAgICAgZXIgPSBkcjtcblx0ICAgICAgICAgICAgICAgIGRyID0gcm90bChjciwgMTApO1xuXHQgICAgICAgICAgICAgICAgY3IgPSBicjtcblx0ICAgICAgICAgICAgICAgIGJyID0gdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICB0ICAgID0gKEhbMV0gKyBjbCArIGRyKXwwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKXwwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbM10gKyBlbCArIGFyKXwwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbNF0gKyBhbCArIGJyKXwwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbMF0gKyBibCArIGNyKXwwO1xuXHQgICAgICAgICAgICBIWzBdID0gIHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsIDw8IDgpICB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbCA8PCAyNCkgfCAobkJpdHNUb3RhbCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblxuXHQgICAgZnVuY3Rpb24gZjEoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKHgpIF4gKHkpIF4gKHopKTtcblxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmMih4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoKHgpJih5KSkgfCAoKH54KSYoeikpKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjMoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKCh4KSB8ICh+KHkpKSkgXiAoeikpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmNCh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoKHgpICYgKHopKSB8ICgoeSkmKH4oeikpKSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGY1KHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCh4KSBeICgoeSkgfCh+KHopKSkpO1xuXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHJvdGwoeCxuKSB7XG5cdCAgICAgICAgcmV0dXJuICh4PDxuKSB8ICh4Pj4+KDMyLW4pKTtcblx0ICAgIH1cblxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuUklQRU1EMTYwKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5SSVBFTUQxNjAod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5SSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihSSVBFTUQxNjApO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1JJUEVNRDE2MChtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNSSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoUklQRU1EMTYwKTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUklQRU1EMTYwO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yaXBlbWQxNjAuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmlwZW1kMTYwLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTEgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTEgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LFxuXHQgICAgICAgICAgICAgICAgMHhjM2QyZTFmMFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIDB4NWE4Mjc5OTk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgKyAweDZlZDllYmExO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoaSA8IDgwKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGUgPSBkO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEExKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEExO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTI1NlwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9zaGEyNTZcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTIyNCBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTIyNCA9IENfYWxnby5TSEEyMjQgPSBTSEEyNTYuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG5cdCAgICAgICAgICAgICAgICAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0XG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IFNIQTI1Ni5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIGhhc2guc2lnQnl0ZXMgLT0gNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjI0KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMjI0ID0gU0hBMjU2Ll9jcmVhdGVIZWxwZXIoU0hBMjI0KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyMjQobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMjI0ID0gU0hBMjU2Ll9jcmVhdGVIbWFjSGVscGVyKFNIQTIyNCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjI0O1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyMjQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjI0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTI1Ni5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ194NjQgPSBDLng2NDtcblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBSSE9fT0ZGU0VUUyA9IFtdO1xuXHQgICAgdmFyIFBJX0lOREVYRVMgID0gW107XG5cdCAgICB2YXIgUk9VTkRfQ09OU1RBTlRTID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgQ29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgcmhvIG9mZnNldCBjb25zdGFudHNcblx0ICAgICAgICB2YXIgeCA9IDEsIHkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuXHQgICAgICAgICAgICBSSE9fT0ZGU0VUU1t4ICsgNSAqIHldID0gKCh0ICsgMSkgKiAodCArIDIpIC8gMikgJSA2NDtcblxuXHQgICAgICAgICAgICB2YXIgbmV3WCA9IHkgJSA1O1xuXHQgICAgICAgICAgICB2YXIgbmV3WSA9ICgyICogeCArIDMgKiB5KSAlIDU7XG5cdCAgICAgICAgICAgIHggPSBuZXdYO1xuXHQgICAgICAgICAgICB5ID0gbmV3WTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb21wdXRlIHBpIGluZGV4IGNvbnN0YW50c1xuXHQgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICBQSV9JTkRFWEVTW3ggKyA1ICogeV0gPSB5ICsgKCgyICogeCArIDMgKiB5KSAlIDUpICogNTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbXB1dGUgcm91bmQgY29uc3RhbnRzXG5cdCAgICAgICAgdmFyIExGU1IgPSAweDAxO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgcm91bmRDb25zdGFudE1zdyA9IDA7XG5cdCAgICAgICAgICAgIHZhciByb3VuZENvbnN0YW50THN3ID0gMDtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDc7IGorKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKExGU1IgJiAweDAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJpdFBvc2l0aW9uID0gKDEgPDwgaikgLSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3NpdGlvbiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kQ29uc3RhbnRMc3cgXj0gMSA8PCBiaXRQb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKGJpdFBvc2l0aW9uID49IDMyKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kQ29uc3RhbnRNc3cgXj0gMSA8PCAoYml0UG9zaXRpb24gLSAzMik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgTEZTUlxuXHQgICAgICAgICAgICAgICAgaWYgKExGU1IgJiAweDgwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIHBvbHlub21pYWwgb3ZlciBHRigyKTogeF44ICsgeF42ICsgeF41ICsgeF40ICsgMVxuXHQgICAgICAgICAgICAgICAgICAgIExGU1IgPSAoTEZTUiA8PCAxKSBeIDB4NzE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIExGU1IgPDw9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBST1VORF9DT05TVEFOVFNbaV0gPSBYNjRXb3JkLmNyZWF0ZShyb3VuZENvbnN0YW50TXN3LCByb3VuZENvbnN0YW50THN3KTtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzIGZvciB0ZW1wb3JhcnkgdmFsdWVzXG5cdCAgICB2YXIgVCA9IFtdO1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcblx0ICAgICAgICAgICAgVFtpXSA9IFg2NFdvcmQuY3JlYXRlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMyBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTMgPSBDX2FsZ28uU0hBMyA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvdXRwdXRMZW5ndGhcblx0ICAgICAgICAgKiAgIFRoZSBkZXNpcmVkIG51bWJlciBvZiBiaXRzIGluIHRoZSBvdXRwdXQgaGFzaC5cblx0ICAgICAgICAgKiAgIE9ubHkgdmFsdWVzIHBlcm1pdHRlZCBhcmU6IDIyNCwgMjU2LCAzODQsIDUxMi5cblx0ICAgICAgICAgKiAgIERlZmF1bHQ6IDUxMlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogSGFzaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBvdXRwdXRMZW5ndGg6IDUxMlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGUgPSBbXVxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlW2ldID0gbmV3IFg2NFdvcmQuaW5pdCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5ibG9ja1NpemUgPSAoMTYwMCAtIDIgKiB0aGlzLmNmZy5vdXRwdXRMZW5ndGgpIC8gMzI7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tTaXplTGFuZXMgPSB0aGlzLmJsb2NrU2l6ZSAvIDI7XG5cblx0ICAgICAgICAgICAgLy8gQWJzb3JiXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJsb2NrU2l6ZUxhbmVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIE0yaSAgPSBNW29mZnNldCArIDIgKiBpXTtcblx0ICAgICAgICAgICAgICAgIHZhciBNMmkxID0gTVtvZmZzZXQgKyAyICogaSArIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgTTJpID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaSA8PCA4KSAgfCAoTTJpID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaSA8PCAyNCkgfCAoTTJpID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICBNMmkxID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaTEgPDwgOCkgIHwgKE0yaTEgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpMSA8PCAyNCkgfCAoTTJpMSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBYnNvcmIgbWVzc2FnZSBpbnRvIHN0YXRlXG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2ldO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5oaWdoIF49IE0yaTE7XG5cdCAgICAgICAgICAgICAgICBsYW5lLmxvdyAgXj0gTTJpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhldGFcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTWl4IGNvbHVtbiBsYW5lc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gMCwgdExzdyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVt4ICsgNSAqIHldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0TXN3IF49IGxhbmUuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdExzdyBePSBsYW5lLmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgdmFsdWVzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4ID0gVFt4XTtcblx0ICAgICAgICAgICAgICAgICAgICBUeC5oaWdoID0gdE1zdztcblx0ICAgICAgICAgICAgICAgICAgICBUeC5sb3cgID0gdExzdztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4NCA9IFRbKHggKyA0KSAlIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDEgPSBUWyh4ICsgMSkgJSA1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHgxTXN3ID0gVHgxLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4MUxzdyA9IFR4MS5sb3c7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBNaXggc3Vycm91bmRpbmcgY29sdW1uc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gVHg0LmhpZ2ggXiAoKFR4MU1zdyA8PCAxKSB8IChUeDFMc3cgPj4+IDMxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRMc3cgPSBUeDQubG93ICBeICgoVHgxTHN3IDw8IDEpIHwgKFR4MU1zdyA+Pj4gMzEpKTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW3ggKyA1ICogeV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUuaGlnaCBePSB0TXN3O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmxvdyAgXj0gdExzdztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJobyBQaVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgbGFuZUluZGV4ID0gMTsgbGFuZUluZGV4IDwgMjU7IGxhbmVJbmRleCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtsYW5lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lTXN3ID0gbGFuZS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lTHN3ID0gbGFuZS5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJob09mZnNldCA9IFJIT19PRkZTRVRTW2xhbmVJbmRleF07XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBSb3RhdGUgbGFuZXNcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmhvT2Zmc2V0IDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSAobGFuZU1zdyA8PCByaG9PZmZzZXQpIHwgKGxhbmVMc3cgPj4+ICgzMiAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdExzdyA9IChsYW5lTHN3IDw8IHJob09mZnNldCkgfCAobGFuZU1zdyA+Pj4gKDMyIC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChyaG9PZmZzZXQgPj0gMzIpICovIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSAobGFuZUxzdyA8PCAocmhvT2Zmc2V0IC0gMzIpKSB8IChsYW5lTXN3ID4+PiAoNjQgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRMc3cgPSAobGFuZU1zdyA8PCAocmhvT2Zmc2V0IC0gMzIpKSB8IChsYW5lTHN3ID4+PiAoNjQgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc3Bvc2UgbGFuZXNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVFBpTGFuZSA9IFRbUElfSU5ERVhFU1tsYW5lSW5kZXhdXTtcblx0ICAgICAgICAgICAgICAgICAgICBUUGlMYW5lLmhpZ2ggPSB0TXN3O1xuXHQgICAgICAgICAgICAgICAgICAgIFRQaUxhbmUubG93ICA9IHRMc3c7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJobyBwaSBhdCB4ID0geSA9IDBcblx0ICAgICAgICAgICAgICAgIHZhciBUMCA9IFRbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhdGUwID0gc3RhdGVbMF07XG5cdCAgICAgICAgICAgICAgICBUMC5oaWdoID0gc3RhdGUwLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICBUMC5sb3cgID0gc3RhdGUwLmxvdztcblxuXHQgICAgICAgICAgICAgICAgLy8gQ2hpXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZUluZGV4ID0geCArIDUgKiB5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUTGFuZSA9IFRbbGFuZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFR4MUxhbmUgPSBUWygoeCArIDEpICUgNSkgKyA1ICogeV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUeDJMYW5lID0gVFsoKHggKyAyKSAlIDUpICsgNSAqIHldO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCByb3dzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUuaGlnaCA9IFRMYW5lLmhpZ2ggXiAoflR4MUxhbmUuaGlnaCAmIFR4MkxhbmUuaGlnaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUubG93ICA9IFRMYW5lLmxvdyAgXiAoflR4MUxhbmUubG93ICAmIFR4MkxhbmUubG93KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElvdGFcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgcm91bmRDb25zdGFudCA9IFJPVU5EX0NPTlNUQU5UU1tyb3VuZF07XG5cdCAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggXj0gcm91bmRDb25zdGFudC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5sb3cgIF49IHJvdW5kQ29uc3RhbnQubG93Oztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQml0cyA9IHRoaXMuYmxvY2tTaXplICogMzI7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHgxIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoTWF0aC5jZWlsKChuQml0c0xlZnQgKyAxKSAvIGJsb2NrU2l6ZUJpdHMpICogYmxvY2tTaXplQml0cykgPj4+IDUpIC0gMV0gfD0gMHg4MDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgIHZhciBvdXRwdXRMZW5ndGhCeXRlcyA9IHRoaXMuY2ZnLm91dHB1dExlbmd0aCAvIDg7XG5cdCAgICAgICAgICAgIHZhciBvdXRwdXRMZW5ndGhMYW5lcyA9IG91dHB1dExlbmd0aEJ5dGVzIC8gODtcblxuXHQgICAgICAgICAgICAvLyBTcXVlZXplXG5cdCAgICAgICAgICAgIHZhciBoYXNoV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGhMYW5lczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZU1zdyA9IGxhbmUuaGlnaDtcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lTHN3ID0gbGFuZS5sb3c7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBsYW5lTXN3ID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVNc3cgPDwgOCkgIHwgKGxhbmVNc3cgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZU1zdyA8PCAyNCkgfCAobGFuZU1zdyA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgbGFuZUxzdyA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTHN3IDw8IDgpICB8IChsYW5lTHN3ID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVMc3cgPDwgMjQpIHwgKGxhbmVMc3cgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3F1ZWV6ZSBzdGF0ZSB0byByZXRyaWV2ZSBoYXNoXG5cdCAgICAgICAgICAgICAgICBoYXNoV29yZHMucHVzaChsYW5lTHN3KTtcblx0ICAgICAgICAgICAgICAgIGhhc2hXb3Jkcy5wdXNoKGxhbmVNc3cpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChoYXNoV29yZHMsIG91dHB1dExlbmd0aEJ5dGVzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gY2xvbmUuX3N0YXRlID0gdGhpcy5fc3RhdGUuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgc3RhdGVbaV0gPSBzdGF0ZVtpXS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMygnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMyh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTMgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEzKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTMgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMyk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTM7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTUxMlwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiLCBcIi4vc2hhNTEyXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQ7XG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQ7XG5cdCAgICB2YXIgWDY0V29yZEFycmF5ID0gQ194NjQuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBTSEE1MTIgPSBDX2FsZ28uU0hBNTEyO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0zODQgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEzODQgPSBDX2FsZ28uU0hBMzg0ID0gU0hBNTEyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBYNjRXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgpLCBuZXcgWDY0V29yZC5pbml0KDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDkxNTkwMTVhLCAweDMwNzBkZDE3KSwgbmV3IFg2NFdvcmQuaW5pdCgweDE1MmZlY2Q4LCAweGY3MGU1OTM5KSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg2NzMzMjY2NywgMHhmZmMwMGIzMSksIG5ldyBYNjRXb3JkLmluaXQoMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcpLCBuZXcgWDY0V29yZC5pbml0KDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQpXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IFNIQTUxMi5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIGhhc2guc2lnQnl0ZXMgLT0gMTY7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTM4NCh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTM4NCA9IFNIQTUxMi5fY3JlYXRlSGVscGVyKFNIQTM4NCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMzg0KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTM4NCA9IFNIQTUxMi5fY3JlYXRlSG1hY0hlbHBlcihTSEEzODQpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTM4NDtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMzg0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTM4NC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ194NjQgPSBDLng2NDtcblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcblx0ICAgIHZhciBYNjRXb3JkQXJyYXkgPSBDX3g2NC5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICBmdW5jdGlvbiBYNjRXb3JkX2NyZWF0ZSgpIHtcblx0ICAgICAgICByZXR1cm4gWDY0V29yZC5jcmVhdGUuYXBwbHkoWDY0V29yZCwgYXJndW1lbnRzKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29uc3RhbnRzXG5cdCAgICB2YXIgSyA9IFtcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDQyOGEyZjk4LCAweGQ3MjhhZTIyKSwgWDY0V29yZF9jcmVhdGUoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiksIFg2NFdvcmRfY3JlYXRlKDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgpLCBYNjRXb3JkX2NyZWF0ZSgweDU5ZjExMWYxLCAweGI2MDVkMDE5KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDkyM2Y4MmE0LCAweGFmMTk0ZjliKSwgWDY0V29yZF9jcmVhdGUoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhkODA3YWE5OCwgMHhhMzAzMDI0MiksIFg2NFdvcmRfY3JlYXRlKDB4MTI4MzViMDEsIDB4NDU3MDZmYmUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMpLCBYNjRXb3JkX2NyZWF0ZSgweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDcyYmU1ZDc0LCAweGYyN2I4OTZmKSwgWDY0V29yZF9jcmVhdGUoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5YmRjMDZhNywgMHgyNWM3MTIzNSksIFg2NFdvcmRfY3JlYXRlKDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIpLCBYNjRXb3JkX2NyZWF0ZSgweGVmYmU0Nzg2LCAweDM4NGYyNWUzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDBmYzE5ZGM2LCAweDhiOGNkNWI1KSwgWDY0V29yZF9jcmVhdGUoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSksIFg2NFdvcmRfY3JlYXRlKDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQpLCBYNjRXb3JkX2NyZWF0ZSgweDc2Zjk4OGRhLCAweDgzMTE1M2I1KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDk4M2U1MTUyLCAweGVlNjZkZmFiKSwgWDY0V29yZF9jcmVhdGUoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiksIFg2NFdvcmRfY3JlYXRlKDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YzZlMDBiZjMsIDB4M2RhODhmYzIpLCBYNjRXb3JkX2NyZWF0ZSgweGQ1YTc5MTQ3LCAweDkzMGFhNzI1KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDA2Y2E2MzUxLCAweGUwMDM4MjZmKSwgWDY0V29yZF9jcmVhdGUoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyN2I3MGE4NSwgMHg0NmQyMmZmYyksIFg2NFdvcmRfY3JlYXRlKDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQpLCBYNjRXb3JkX2NyZWF0ZSgweDUzMzgwZDEzLCAweDlkOTViM2RmKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDY1MGE3MzU0LCAweDhiYWY2M2RlKSwgWDY0V29yZF9jcmVhdGUoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiksIFg2NFdvcmRfY3JlYXRlKDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQpLCBYNjRXb3JkX2NyZWF0ZSgweGE4MWE2NjRiLCAweGJjNDIzMDAxKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGMyNGI4YjcwLCAweGQwZjg5NzkxKSwgWDY0V29yZF9jcmVhdGUoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCksIFg2NFdvcmRfY3JlYXRlKDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEpLCBYNjRXb3JkX2NyZWF0ZSgweDEwNmFhMDcwLCAweDMyYmJkMWI4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDE5YTRjMTE2LCAweGI4ZDJkMGM4KSwgWDY0V29yZF9jcmVhdGUoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSksIFg2NFdvcmRfY3JlYXRlKDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMpLCBYNjRXb3JkX2NyZWF0ZSgweDRlZDhhYTRhLCAweGUzNDE4YWNiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDViOWNjYTRmLCAweDc3NjNlMzczKSwgWDY0V29yZF9jcmVhdGUoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg3NDhmODJlZSwgMHg1ZGVmYjJmYyksIFg2NFdvcmRfY3JlYXRlKDB4NzhhNTYzNmYsIDB4NDMxNzJmNjApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ODRjODc4MTQsIDB4YTFmMGFiNzIpLCBYNjRXb3JkX2NyZWF0ZSgweDhjYzcwMjA4LCAweDFhNjQzOWVjKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDkwYmVmZmZhLCAweDIzNjMxZTI4KSwgWDY0V29yZF9jcmVhdGUoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhiZWY5YTNmNywgMHhiMmM2NzkxNSksIFg2NFdvcmRfY3JlYXRlKDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMpLCBYNjRXb3JkX2NyZWF0ZSgweGQxODZiOGM3LCAweDIxYzBjMjA3KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGVhZGE3ZGQ2LCAweGNkZTBlYjFlKSwgWDY0V29yZF9jcmVhdGUoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSksIFg2NFdvcmRfY3JlYXRlKDB4MGE2MzdkYzUsIDB4YTJjODk4YTYpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUpLCBYNjRXb3JkX2NyZWF0ZSgweDFiNzEwYjM1LCAweDEzMWM0NzFiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0KSwgWDY0V29yZF9jcmVhdGUoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgzYzllYmUwYSwgMHgxNWM5YmViYyksIFg2NFdvcmRfY3JlYXRlKDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYpLCBYNjRXb3JkX2NyZWF0ZSgweDU5N2YyOTljLCAweGZjNjU3ZTJhKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDVmY2I2ZmFiLCAweDNhZDZmYWVjKSwgWDY0V29yZF9jcmVhdGUoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNylcblx0ICAgIF07XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHNcblx0ICAgIHZhciBXID0gW107XG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICBXW2ldID0gWDY0V29yZF9jcmVhdGUoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS01MTIgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEE1MTIgPSBDX2FsZ28uU0hBNTEyID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBYNjRXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgpLCBuZXcgWDY0V29yZC5pbml0KDB4YmI2N2FlODUsIDB4ODRjYWE3M2IpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDNjNmVmMzcyLCAweGZlOTRmODJiKSwgbmV3IFg2NFdvcmQuaW5pdCgweGE1NGZmNTNhLCAweDVmMWQzNmYxKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSksIG5ldyBYNjRXb3JkLmluaXQoMHg5YjA1Njg4YywgMHgyYjNlNmMxZiksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIpLCBuZXcgWDY0V29yZC5pbml0KDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkpXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgSDAgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgSDEgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgSDIgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgSDMgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgSDQgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgSDUgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgSDYgPSBIWzZdO1xuXHQgICAgICAgICAgICB2YXIgSDcgPSBIWzddO1xuXG5cdCAgICAgICAgICAgIHZhciBIMGggPSBIMC5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDBsID0gSDAubG93O1xuXHQgICAgICAgICAgICB2YXIgSDFoID0gSDEuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgxbCA9IEgxLmxvdztcblx0ICAgICAgICAgICAgdmFyIEgyaCA9IEgyLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIMmwgPSBIMi5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIM2ggPSBIMy5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDNsID0gSDMubG93O1xuXHQgICAgICAgICAgICB2YXIgSDRoID0gSDQuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg0bCA9IEg0Lmxvdztcblx0ICAgICAgICAgICAgdmFyIEg1aCA9IEg1LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBINWwgPSBINS5sb3c7XG5cdCAgICAgICAgICAgIHZhciBINmggPSBINi5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDZsID0gSDYubG93O1xuXHQgICAgICAgICAgICB2YXIgSDdoID0gSDcuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg3bCA9IEg3LmxvdztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYWggPSBIMGg7XG5cdCAgICAgICAgICAgIHZhciBhbCA9IEgwbDtcblx0ICAgICAgICAgICAgdmFyIGJoID0gSDFoO1xuXHQgICAgICAgICAgICB2YXIgYmwgPSBIMWw7XG5cdCAgICAgICAgICAgIHZhciBjaCA9IEgyaDtcblx0ICAgICAgICAgICAgdmFyIGNsID0gSDJsO1xuXHQgICAgICAgICAgICB2YXIgZGggPSBIM2g7XG5cdCAgICAgICAgICAgIHZhciBkbCA9IEgzbDtcblx0ICAgICAgICAgICAgdmFyIGVoID0gSDRoO1xuXHQgICAgICAgICAgICB2YXIgZWwgPSBINGw7XG5cdCAgICAgICAgICAgIHZhciBmaCA9IEg1aDtcblx0ICAgICAgICAgICAgdmFyIGZsID0gSDVsO1xuXHQgICAgICAgICAgICB2YXIgZ2ggPSBINmg7XG5cdCAgICAgICAgICAgIHZhciBnbCA9IEg2bDtcblx0ICAgICAgICAgICAgdmFyIGhoID0gSDdoO1xuXHQgICAgICAgICAgICB2YXIgaGwgPSBIN2w7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBXaSA9IFdbaV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBtZXNzYWdlXG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IFdpLmhpZ2ggPSBNW29mZnNldCArIGkgKiAyXSAgICAgfCAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBXaS5sb3cgID0gTVtvZmZzZXQgKyBpICogMiArIDFdIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gR2FtbWEwXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4aCA9IGdhbW1hMHguaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweGwgPSBnYW1tYTB4Lmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwaCAgPSAoKGdhbW1hMHhoID4+PiAxKSB8IChnYW1tYTB4bCA8PCAzMSkpIF4gKChnYW1tYTB4aCA+Pj4gOCkgfCAoZ2FtbWEweGwgPDwgMjQpKSBeIChnYW1tYTB4aCA+Pj4gNyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMGwgID0gKChnYW1tYTB4bCA+Pj4gMSkgfCAoZ2FtbWEweGggPDwgMzEpKSBeICgoZ2FtbWEweGwgPj4+IDgpIHwgKGdhbW1hMHhoIDw8IDI0KSkgXiAoKGdhbW1hMHhsID4+PiA3KSB8IChnYW1tYTB4aCA8PCAyNSkpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gR2FtbWExXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggID0gV1tpIC0gMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXhoID0gZ2FtbWExeC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4bCA9IGdhbW1hMXgubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTFoICA9ICgoZ2FtbWExeGggPj4+IDE5KSB8IChnYW1tYTF4bCA8PCAxMykpIF4gKChnYW1tYTF4aCA8PCAzKSB8IChnYW1tYTF4bCA+Pj4gMjkpKSBeIChnYW1tYTF4aCA+Pj4gNik7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMWwgID0gKChnYW1tYTF4bCA+Pj4gMTkpIHwgKGdhbW1hMXhoIDw8IDEzKSkgXiAoKGdhbW1hMXhsIDw8IDMpIHwgKGdhbW1hMXhoID4+PiAyOSkpIF4gKChnYW1tYTF4bCA+Pj4gNikgfCAoZ2FtbWExeGggPDwgMjYpKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTcgID0gV1tpIC0gN107XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpN2ggPSBXaTcuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2k3bCA9IFdpNy5sb3c7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2kxNiAgPSBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpMTZoID0gV2kxNi5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTE2bCA9IFdpMTYubG93O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IGdhbW1hMGwgKyBXaTdsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBnYW1tYTBoICsgV2k3aCArICgoV2lsID4+PiAwKSA8IChnYW1tYTBsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gV2lsICsgZ2FtbWExbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gV2loICsgZ2FtbWExaCArICgoV2lsID4+PiAwKSA8IChnYW1tYTFsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gV2lsICsgV2kxNmw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IFdpaCArIFdpMTZoICsgKChXaWwgPj4+IDApIDwgKFdpMTZsID4+PiAwKSA/IDEgOiAwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdpLmhpZ2ggPSBXaWg7XG5cdCAgICAgICAgICAgICAgICAgICAgV2kubG93ICA9IFdpbDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoaCAgPSAoZWggJiBmaCkgXiAofmVoICYgZ2gpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNobCAgPSAoZWwgJiBmbCkgXiAofmVsICYgZ2wpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hamggPSAoYWggJiBiaCkgXiAoYWggJiBjaCkgXiAoYmggJiBjaCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqbCA9IChhbCAmIGJsKSBeIChhbCAmIGNsKSBeIChibCAmIGNsKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMGggPSAoKGFoID4+PiAyOCkgfCAoYWwgPDwgNCkpICBeICgoYWggPDwgMzApICB8IChhbCA+Pj4gMikpIF4gKChhaCA8PCAyNSkgfCAoYWwgPj4+IDcpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTBsID0gKChhbCA+Pj4gMjgpIHwgKGFoIDw8IDQpKSAgXiAoKGFsIDw8IDMwKSAgfCAoYWggPj4+IDIpKSBeICgoYWwgPDwgMjUpIHwgKGFoID4+PiA3KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExaCA9ICgoZWggPj4+IDE0KSB8IChlbCA8PCAxOCkpIF4gKChlaCA+Pj4gMTgpIHwgKGVsIDw8IDE0KSkgXiAoKGVoIDw8IDIzKSB8IChlbCA+Pj4gOSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMWwgPSAoKGVsID4+PiAxNCkgfCAoZWggPDwgMTgpKSBeICgoZWwgPj4+IDE4KSB8IChlaCA8PCAxNCkpIF4gKChlbCA8PCAyMykgfCAoZWggPj4+IDkpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxuXHQgICAgICAgICAgICAgICAgdmFyIEtpICA9IEtbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgS2loID0gS2kuaGlnaDtcblx0ICAgICAgICAgICAgICAgIHZhciBLaWwgPSBLaS5sb3c7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSBobCArIHNpZ21hMWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gaGggKyBzaWdtYTFoICsgKCh0MWwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSB0MWwgKyBjaGw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gdDFoICsgY2hoICsgKCh0MWwgPj4+IDApIDwgKGNobCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gdDFsICsgS2lsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IHQxaCArIEtpaCArICgodDFsID4+PiAwKSA8IChLaWwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IHQxbCArIFdpbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSB0MWggKyBXaWggKyAoKHQxbCA+Pj4gMCkgPCAoV2lsID4+PiAwKSA/IDEgOiAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcblx0ICAgICAgICAgICAgICAgIHZhciB0MmwgPSBzaWdtYTBsICsgbWFqbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MmggPSBzaWdtYTBoICsgbWFqaCArICgodDJsID4+PiAwKSA8IChzaWdtYTBsID4+PiAwKSA/IDEgOiAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgICAgICBoaCA9IGdoO1xuXHQgICAgICAgICAgICAgICAgaGwgPSBnbDtcblx0ICAgICAgICAgICAgICAgIGdoID0gZmg7XG5cdCAgICAgICAgICAgICAgICBnbCA9IGZsO1xuXHQgICAgICAgICAgICAgICAgZmggPSBlaDtcblx0ICAgICAgICAgICAgICAgIGZsID0gZWw7XG5cdCAgICAgICAgICAgICAgICBlbCA9IChkbCArIHQxbCkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZWggPSAoZGggKyB0MWggKyAoKGVsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGRoID0gY2g7XG5cdCAgICAgICAgICAgICAgICBkbCA9IGNsO1xuXHQgICAgICAgICAgICAgICAgY2ggPSBiaDtcblx0ICAgICAgICAgICAgICAgIGNsID0gYmw7XG5cdCAgICAgICAgICAgICAgICBiaCA9IGFoO1xuXHQgICAgICAgICAgICAgICAgYmwgPSBhbDtcblx0ICAgICAgICAgICAgICAgIGFsID0gKHQxbCArIHQybCkgfCAwO1xuXHQgICAgICAgICAgICAgICAgYWggPSAodDFoICsgdDJoICsgKChhbCA+Pj4gMCkgPCAodDFsID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSDBsID0gSDAubG93ICA9IChIMGwgKyBhbCk7XG5cdCAgICAgICAgICAgIEgwLmhpZ2ggPSAoSDBoICsgYWggKyAoKEgwbCA+Pj4gMCkgPCAoYWwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDFsID0gSDEubG93ICA9IChIMWwgKyBibCk7XG5cdCAgICAgICAgICAgIEgxLmhpZ2ggPSAoSDFoICsgYmggKyAoKEgxbCA+Pj4gMCkgPCAoYmwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDJsID0gSDIubG93ICA9IChIMmwgKyBjbCk7XG5cdCAgICAgICAgICAgIEgyLmhpZ2ggPSAoSDJoICsgY2ggKyAoKEgybCA+Pj4gMCkgPCAoY2wgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDNsID0gSDMubG93ICA9IChIM2wgKyBkbCk7XG5cdCAgICAgICAgICAgIEgzLmhpZ2ggPSAoSDNoICsgZGggKyAoKEgzbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDRsID0gSDQubG93ICA9IChINGwgKyBlbCk7XG5cdCAgICAgICAgICAgIEg0LmhpZ2ggPSAoSDRoICsgZWggKyAoKEg0bCA+Pj4gMCkgPCAoZWwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDVsID0gSDUubG93ICA9IChINWwgKyBmbCk7XG5cdCAgICAgICAgICAgIEg1LmhpZ2ggPSAoSDVoICsgZmggKyAoKEg1bCA+Pj4gMCkgPCAoZmwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDZsID0gSDYubG93ICA9IChINmwgKyBnbCk7XG5cdCAgICAgICAgICAgIEg2LmhpZ2ggPSAoSDZoICsgZ2ggKyAoKEg2bCA+Pj4gMCkgPCAoZ2wgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDdsID0gSDcubG93ICA9IChIN2wgKyBobCk7XG5cdCAgICAgICAgICAgIEg3LmhpZ2ggPSAoSDdoICsgaGggKyAoKEg3bCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgMTI4KSA+Pj4gMTApIDw8IDUpICsgMzBdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgMTI4KSA+Pj4gMTApIDw8IDUpICsgMzFdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IGhhc2ggdG8gMzItYml0IHdvcmQgYXJyYXkgYmVmb3JlIHJldHVybmluZ1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2gudG9YMzIoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMDI0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTUxMignbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBNTEyID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBNTEyKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEE1MTIobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBNTEyID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTUxMik7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBNTEyO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGE1MTIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhNTEyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBQZXJtdXRlZCBDaG9pY2UgMSBjb25zdGFudHNcblx0ICAgIHZhciBQQzEgPSBbXG5cdCAgICAgICAgNTcsIDQ5LCA0MSwgMzMsIDI1LCAxNywgOSwgIDEsXG5cdCAgICAgICAgNTgsIDUwLCA0MiwgMzQsIDI2LCAxOCwgMTAsIDIsXG5cdCAgICAgICAgNTksIDUxLCA0MywgMzUsIDI3LCAxOSwgMTEsIDMsXG5cdCAgICAgICAgNjAsIDUyLCA0NCwgMzYsIDYzLCA1NSwgNDcsIDM5LFxuXHQgICAgICAgIDMxLCAyMywgMTUsIDcsICA2MiwgNTQsIDQ2LCAzOCxcblx0ICAgICAgICAzMCwgMjIsIDE0LCA2LCAgNjEsIDUzLCA0NSwgMzcsXG5cdCAgICAgICAgMjksIDIxLCAxMywgNSwgIDI4LCAyMCwgMTIsIDRcblx0ICAgIF07XG5cblx0ICAgIC8vIFBlcm11dGVkIENob2ljZSAyIGNvbnN0YW50c1xuXHQgICAgdmFyIFBDMiA9IFtcblx0ICAgICAgICAxNCwgMTcsIDExLCAyNCwgMSwgIDUsXG5cdCAgICAgICAgMywgIDI4LCAxNSwgNiwgIDIxLCAxMCxcblx0ICAgICAgICAyMywgMTksIDEyLCA0LCAgMjYsIDgsXG5cdCAgICAgICAgMTYsIDcsICAyNywgMjAsIDEzLCAyLFxuXHQgICAgICAgIDQxLCA1MiwgMzEsIDM3LCA0NywgNTUsXG5cdCAgICAgICAgMzAsIDQwLCA1MSwgNDUsIDMzLCA0OCxcblx0ICAgICAgICA0NCwgNDksIDM5LCA1NiwgMzQsIDUzLFxuXHQgICAgICAgIDQ2LCA0MiwgNTAsIDM2LCAyOSwgMzJcblx0ICAgIF07XG5cblx0ICAgIC8vIEN1bXVsYXRpdmUgYml0IHNoaWZ0IGNvbnN0YW50c1xuXHQgICAgdmFyIEJJVF9TSElGVFMgPSBbMSwgIDIsICA0LCAgNiwgIDgsICAxMCwgMTIsIDE0LCAxNSwgMTcsIDE5LCAyMSwgMjMsIDI1LCAyNywgMjhdO1xuXG5cdCAgICAvLyBTQk9YZXMgYW5kIHJvdW5kIHBlcm11dGF0aW9uIGNvbnN0YW50c1xuXHQgICAgdmFyIFNCT1hfUCA9IFtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDA6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHgyMDAwMDAwMDogMHg4MDgwMDIsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwMDA6IDB4Mixcblx0ICAgICAgICAgICAgMHg0MDAwMDAwMDogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwMDA6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDYwMDAwMDAwOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHg3MDAwMDAwMDogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDA6IDB4MjAyLFxuXHQgICAgICAgICAgICAweDkwMDAwMDAwOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDAwMDogMHg4MjAwLFxuXHQgICAgICAgICAgICAweGIwMDAwMDAwOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHhjMDAwMDAwMDogMHg4MDAyLFxuXHQgICAgICAgICAgICAweGQwMDAwMDAwOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHhlMDAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGYwMDAwMDAwOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDAwOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHgyODAwMDAwMDogMHg4MjAyLFxuXHQgICAgICAgICAgICAweDM4MDAwMDAwOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwMDA6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweDU4MDAwMDAwOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg2ODAwMDAwMDogMHg4MDgwMDIsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwMDA6IDB4Mixcblx0ICAgICAgICAgICAgMHg4ODAwMDAwMDogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwMDA6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHhhODAwMDAwMDogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwMDA6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweGM4MDAwMDAwOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHhkODAwMDAwMDogMHg4MDAyLFxuXHQgICAgICAgICAgICAweGU4MDAwMDAwOiAweDIwMixcblx0ICAgICAgICAgICAgMHhmODAwMDAwMDogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDAxOiAweDIsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwMDE6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweDMwMDAwMDAxOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHg0MDAwMDAwMTogMHg4MDgwMDIsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwMDE6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHg2MDAwMDAwMTogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwMDE6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAxOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHg5MDAwMDAwMTogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwMDE6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweGIwMDAwMDAxOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwMDE6IDB4MjAyLFxuXHQgICAgICAgICAgICAweGQwMDAwMDAxOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHhlMDAwMDAwMTogMHg4MDAyLFxuXHQgICAgICAgICAgICAweGYwMDAwMDAxOiAweDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDE6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweDI4MDAwMDAxOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHgzODAwMDAwMTogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwMDE6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDAwMTogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwMDE6IDB4Mixcblx0ICAgICAgICAgICAgMHg3ODAwMDAwMTogMHg4MjAyLFxuXHQgICAgICAgICAgICAweDg4MDAwMDAxOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwMDE6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweGE4MDAwMDAxOiAweDIwMixcblx0ICAgICAgICAgICAgMHhiODAwMDAwMTogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwMDE6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDAxOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwMDE6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHhmODAwMDAwMTogMHg4MDgwMDJcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHgyMDAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDMwMDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHg1MDAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweDYwMDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwOiAweDg0MDAwLFxuXHQgICAgICAgICAgICAweDkwMDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHhiMDAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweGMwMDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGUwMDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHhmMDAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweDI4MDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDAwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDU4MDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHg3ODAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDg4MDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGE4MDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweGM4MDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwMDogMHg4NDAwMCxcblx0ICAgICAgICAgICAgMHhlODAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweGY4MDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDExMDAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDEyMDAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweDEzMDAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweDE0MDAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweDE1MDAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDE2MDAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweDE3MDAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHgxOTAwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHgxYjAwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHgxYzAwMDAwMDogMHg4NDAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHgxZTAwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZjAwMDAwMDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMDgwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMTgwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHgxMjgwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHgxMzgwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweDE0ODAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDE1ODAwMDAwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDE2ODAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDE3ODAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE4ODAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweDE5ODAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweDFhODAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweDFiODAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweDFjODAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWQ4MDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHgxZjgwMDAwMDogMHg4NDAwMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDEwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDIwMDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDMwMDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHg0MDAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwOiAweDEwMTAwLFxuXHQgICAgICAgICAgICAweGIwMDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweGMwMDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweGQwMDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHhlMDAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHhmMDAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweDgwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweDY4MDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHg3ODAwMDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDg4MDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweDk4MDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweGM4MDAwMDogMHgxMDEwMCxcblx0ICAgICAgICAgICAgMHhkODAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHhlODAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHhmODAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHgxMjAwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweDEzMDAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHgxNDAwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHgxNTAwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4MTYwMDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDE3MDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4MTkwMDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHgxYjAwMDAwOiAweDEwMTAwLFxuXHQgICAgICAgICAgICAweDFjMDAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwMDAwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHgxZTAwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweDFmMDAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHgxMDgwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTE4MDAwMDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4MTI4MDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweDEzODAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxNDgwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDE1ODAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHgxNjgwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHgxNzgwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTg4MDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHgxOTgwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4MWE4MDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHgxYjgwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4MWM4MDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweDFkODAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4MWY4MDAwMDogMHgxMDEwMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDA6IDB4NDAxMDQwLFxuXHQgICAgICAgICAgICAweDMwMDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDQwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4NTAwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDYwMDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDcwMDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4YzAwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4ZDAwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHhlMDAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweGYwMDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDgwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4MjgwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MzgwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDU4MDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDY4MDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4NzgwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODgwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHg5ODAwMDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHhhODAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHhjODAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHhkODAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDA6IDB4NDAxMDQwLFxuXHQgICAgICAgICAgICAweGY4MDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxMjAwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTMwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTQwMDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweDE2MDAwMDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxNzAwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDE5MDAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWIwMDAwOiAweDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgxYzAwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZTAwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTA4MDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDExODAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgxMjgwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxMzgwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDE0ODAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE2ODAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgxNzgwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDE5ODAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweDFhODAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHgxYjgwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MWM4MDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4MWQ4MDAwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweDFlODAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWY4MDAwOiAweDQwMTA0MFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MTAwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDIwMDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg0MDAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDUwMDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHg2MDAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDcwMDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4ODAwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDkwMDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDogMHgyMDAwMDA4MCxcblx0ICAgICAgICAgICAgMHhiMDAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweGMwMDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGUwMDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHhmMDAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE4MDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MjgwMDogMHg4MCxcblx0ICAgICAgICAgICAgMHgzODAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHg1ODAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDY4MDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4NzgwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4ODAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweDk4MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhhODAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweGI4MDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHhjODAwOiAweDIwMDAwMDgwLFxuXHQgICAgICAgICAgICAweGQ4MDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweGY4MDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4MTAwMDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MTIwMDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTMwMDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MTQwMDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxNTAwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxNjAwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxNzAwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE4MDAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE5MDAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWIwMDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4MWQwMDA6IDB4MjAwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MWUwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZjAwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDEwODAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDExODAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxMzgwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxNDgwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNTgwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE2ODAwOiAweDgwLFxuXHQgICAgICAgICAgICAweDE3ODAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDE4ODAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDE5ODAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDFhODAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWI4MDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWM4MDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxZDgwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxZjgwMDogMHgyMDAwMDA4MFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTAwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDMwMDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHg0MDA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4NTAwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHg2MDA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDcwMDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHg5MDA6IDB4MTAwMDIwMDgsXG5cdCAgICAgICAgICAgIDB4YTAwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHhiMDA6IDB4OCxcblx0ICAgICAgICAgICAgMHhjMDA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4ZDAwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHhlMDA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHhmMDA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4ODA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDI4MDogMHg4LFxuXHQgICAgICAgICAgICAweDM4MDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHg1ODA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4NjgwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDc4MDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweDg4MDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4OTgwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4YTgwOiAweDEwMDAyMDA4LFxuXHQgICAgICAgICAgICAweGI4MDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHhjODA6IDB4MCxcblx0ICAgICAgICAgICAgMHhkODA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4ZTgwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHhmODA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHgxMTAwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweDEyMDA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTMwMDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweDE0MDA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDE1MDA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTYwMDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHgxNzAwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxODAwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxOTAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDogMHg4LFxuXHQgICAgICAgICAgICAweDFiMDA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweDFkMDA6IDB4MTAwMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MWUwMDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxZjAwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxMDgwOiAweDgsXG5cdCAgICAgICAgICAgIDB4MTE4MDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHgxNDgwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDE1ODA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHgxNjgwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDE3ODA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxOTgwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweDFhODA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHgxYjgwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxYzgwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxZDgwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZjgwOiAweDEwMDAyMDA4XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTA6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgyMDogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4MzA6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDQwOiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4NTA6IDB4MCxcblx0ICAgICAgICAgICAgMHg2MDogMHgxLFxuXHQgICAgICAgICAgICAweDcwOiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4ODA6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHg5MDogMHgxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4YTA6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHhiMDogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweGMwOiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZDA6IDB4NDAxLFxuXHQgICAgICAgICAgICAweGUwOiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHhmMDogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDg6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxODogMHgwLFxuXHQgICAgICAgICAgICAweDI4OiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4Mzg6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHg0ODogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NTg6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHg2ODogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDc4OiAweDQwMSxcblx0ICAgICAgICAgICAgMHg4ODogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4OTg6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHhhODogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweGI4OiAweDEwMDAwMSxcblx0ICAgICAgICAgICAgMHhjODogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4ZDg6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHhlODogMHgxLFxuXHQgICAgICAgICAgICAweGY4OiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxMDA6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMTA6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDEyMDogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDEzMDogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDE0MDogMHgxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTUwOiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTYwOiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTcwOiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxODA6IDB4NDAxLFxuXHQgICAgICAgICAgICAweDE5MDogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweDFhMDogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MWIwOiAweDEsXG5cdCAgICAgICAgICAgIDB4MWMwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWQwOiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWUwOiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MWYwOiAweDQwMCxcblx0ICAgICAgICAgICAgMHgxMDg6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweDExODogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDEyODogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDEzODogMHgxLFxuXHQgICAgICAgICAgICAweDE0ODogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE1ODogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTY4OiAweDQwMSxcblx0ICAgICAgICAgICAgMHgxNzg6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxODg6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHgxOTg6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTg6IDB4MCxcblx0ICAgICAgICAgICAgMHgxYjg6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxYzg6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDFkODogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4MWU4OiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MWY4OiAweDEwMDAwMVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHgxOiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDI6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHgzOiAweDIwLFxuXHQgICAgICAgICAgICAweDQ6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4NTogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDY6IDB4ODAyMDgwMCxcblx0ICAgICAgICAgICAgMHg3OiAweDgwMCxcblx0ICAgICAgICAgICAgMHg4OiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4OTogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweGE6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4YjogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweGM6IDB4ODIwLFxuXHQgICAgICAgICAgICAweGQ6IDB4MCxcblx0ICAgICAgICAgICAgMHhlOiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4ZjogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMDogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDE6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMjogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAzOiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDQ6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNTogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNjogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNzogMHgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwODogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA5OiAweDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwYTogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwYjogMHg4MDIwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBjOiAweDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGQ6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwZTogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBmOiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDEwOiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDExOiAweDgwMjA4MDAsXG5cdCAgICAgICAgICAgIDB4MTI6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4MTM6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDE0OiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4MTU6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHgxNjogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweDE3OiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDE4OiAweDAsXG5cdCAgICAgICAgICAgIDB4MTk6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4MWE6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHgxYjogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDFjOiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4MWQ6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4MWU6IDB4ODIwLFxuXHQgICAgICAgICAgICAweDFmOiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTA6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTE6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDEyOiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTM6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTQ6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTU6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNjogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE3OiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTg6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxOTogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFhOiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWI6IDB4MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxYzogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxZDogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWU6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWY6IDB4ODAyMDgwMFxuXHQgICAgICAgIH1cblx0ICAgIF07XG5cblx0ICAgIC8vIE1hc2tzIHRoYXQgc2VsZWN0IHRoZSBTQk9YIGlucHV0XG5cdCAgICB2YXIgU0JPWF9NQVNLID0gW1xuXHQgICAgICAgIDB4ZjgwMDAwMDEsIDB4MWY4MDAwMDAsIDB4MDFmODAwMDAsIDB4MDAxZjgwMDAsXG5cdCAgICAgICAgMHgwMDAxZjgwMCwgMHgwMDAwMWY4MCwgMHgwMDAwMDFmOCwgMHg4MDAwMDAxZlxuXHQgICAgXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBERVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIERFUyA9IENfYWxnby5ERVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2VsZWN0IDU2IGJpdHMgYWNjb3JkaW5nIHRvIFBDMVxuXHQgICAgICAgICAgICB2YXIga2V5Qml0cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlCaXRQb3MgPSBQQzFbaV0gLSAxO1xuXHQgICAgICAgICAgICAgICAga2V5Qml0c1tpXSA9IChrZXlXb3Jkc1trZXlCaXRQb3MgPj4+IDVdID4+PiAoMzEgLSBrZXlCaXRQb3MgJSAzMikpICYgMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFzc2VtYmxlIDE2IHN1YmtleXNcblx0ICAgICAgICAgICAgdmFyIHN1YktleXMgPSB0aGlzLl9zdWJLZXlzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIG5TdWJLZXkgPSAwOyBuU3ViS2V5IDwgMTY7IG5TdWJLZXkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHN1YmtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YktleSA9IHN1YktleXNbblN1YktleV0gPSBbXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRTaGlmdCA9IEJJVF9TSElGVFNbblN1YktleV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNlbGVjdCA0OCBiaXRzIGFjY29yZGluZyB0byBQQzJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBmcm9tIHRoZSBsZWZ0IDI4IGtleSBiaXRzXG5cdCAgICAgICAgICAgICAgICAgICAgc3ViS2V5WyhpIC8gNikgfCAwXSB8PSBrZXlCaXRzWygoUEMyW2ldIC0gMSkgKyBiaXRTaGlmdCkgJSAyOF0gPDwgKDMxIC0gaSAlIDYpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZyb20gdGhlIHJpZ2h0IDI4IGtleSBiaXRzXG5cdCAgICAgICAgICAgICAgICAgICAgc3ViS2V5WzQgKyAoKGkgLyA2KSB8IDApXSB8PSBrZXlCaXRzWzI4ICsgKCgoUEMyW2kgKyAyNF0gLSAxKSArIGJpdFNoaWZ0KSAlIDI4KV0gPDwgKDMxIC0gaSAlIDYpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBTaW5jZSBlYWNoIHN1YmtleSBpcyBhcHBsaWVkIHRvIGFuIGV4cGFuZGVkIDMyLWJpdCBpbnB1dCxcblx0ICAgICAgICAgICAgICAgIC8vIHRoZSBzdWJrZXkgY2FuIGJlIGJyb2tlbiBpbnRvIDggdmFsdWVzIHNjYWxlZCB0byAzMi1iaXRzLFxuXHQgICAgICAgICAgICAgICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBrZXkgdG8gYmUgdXNlZCB3aXRob3V0IGV4cGFuc2lvblxuXHQgICAgICAgICAgICAgICAgc3ViS2V5WzBdID0gKHN1YktleVswXSA8PCAxKSB8IChzdWJLZXlbMF0gPj4+IDMxKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNzsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViS2V5W2ldID0gc3ViS2V5W2ldID4+PiAoKGkgLSAxKSAqIDQgKyAzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHN1YktleVs3XSA9IChzdWJLZXlbN10gPDwgNSkgfCAoc3ViS2V5WzddID4+PiAyNyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludmVyc2Ugc3Via2V5c1xuXHQgICAgICAgICAgICB2YXIgaW52U3ViS2V5cyA9IHRoaXMuX2ludlN1YktleXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpbnZTdWJLZXlzW2ldID0gc3ViS2V5c1sxNSAtIGldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9zdWJLZXlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludlN1YktleXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBzdWJLZXlzKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dFxuXHQgICAgICAgICAgICB0aGlzLl9sQmxvY2sgPSBNW29mZnNldF07XG5cdCAgICAgICAgICAgIHRoaXMuX3JCbG9jayA9IE1bb2Zmc2V0ICsgMV07XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCBwZXJtdXRhdGlvblxuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgIDB4MGYwZjBmMGYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMTYsIDB4MDAwMGZmZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgIDB4MzMzMzMzMzMpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgOCwgIDB4MDBmZjAwZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMSwgIDB4NTU1NTU1NTUpO1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgMTY7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1YktleSA9IHN1YktleXNbcm91bmRdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxCbG9jayA9IHRoaXMuX2xCbG9jaztcblx0ICAgICAgICAgICAgICAgIHZhciByQmxvY2sgPSB0aGlzLl9yQmxvY2s7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEZlaXN0ZWwgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgIHZhciBmID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZiB8PSBTQk9YX1BbaV1bKChyQmxvY2sgXiBzdWJLZXlbaV0pICYgU0JPWF9NQVNLW2ldKSA+Pj4gMF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sQmxvY2sgPSByQmxvY2s7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yQmxvY2sgPSBsQmxvY2sgXiBmO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVW5kbyBzd2FwIGZyb20gbGFzdCByb3VuZFxuXHQgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xCbG9jaztcblx0ICAgICAgICAgICAgdGhpcy5fbEJsb2NrID0gdGhpcy5fckJsb2NrO1xuXHQgICAgICAgICAgICB0aGlzLl9yQmxvY2sgPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsIHBlcm11dGF0aW9uXG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAgMHg1NTU1NTU1NSk7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCA4LCAgMHgwMGZmMDBmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCAyLCAgMHgzMzMzMzMzMyk7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxNiwgMHgwMDAwZmZmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCA0LCAgMHgwZjBmMGYwZik7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gPSB0aGlzLl9sQmxvY2s7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0aGlzLl9yQmxvY2s7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDY0LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMixcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvLyBTd2FwIGJpdHMgYWNyb3NzIHRoZSBsZWZ0IGFuZCByaWdodCB3b3Jkc1xuXHQgICAgZnVuY3Rpb24gZXhjaGFuZ2VMUihvZmZzZXQsIG1hc2spIHtcblx0ICAgICAgICB2YXIgdCA9ICgodGhpcy5fbEJsb2NrID4+PiBvZmZzZXQpIF4gdGhpcy5fckJsb2NrKSAmIG1hc2s7XG5cdCAgICAgICAgdGhpcy5fckJsb2NrIF49IHQ7XG5cdCAgICAgICAgdGhpcy5fbEJsb2NrIF49IHQgPDwgb2Zmc2V0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBleGNoYW5nZVJMKG9mZnNldCwgbWFzaykge1xuXHQgICAgICAgIHZhciB0ID0gKCh0aGlzLl9yQmxvY2sgPj4+IG9mZnNldCkgXiB0aGlzLl9sQmxvY2spICYgbWFzaztcblx0ICAgICAgICB0aGlzLl9sQmxvY2sgXj0gdDtcblx0ICAgICAgICB0aGlzLl9yQmxvY2sgXj0gdCA8PCBvZmZzZXQ7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkRFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoREVTKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUcmlwbGUtREVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBUcmlwbGVERVMgPSBDX2FsZ28uVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBERVMgaW5zdGFuY2VzXG5cdCAgICAgICAgICAgIHRoaXMuX2RlczEgPSBERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoMCwgMikpKTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMiA9IERFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgyLCA0KSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMzID0gREVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDQsIDYpKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMxLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMyLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMzLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMy5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMi5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMS5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMTkyLzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMixcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlRyaXBsZURFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlRyaXBsZURFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5UcmlwbGVERVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKFRyaXBsZURFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuVHJpcGxlREVTO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2NyeXB0by1qcy90cmlwbGVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvdHJpcGxlZGVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFgzMldvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiB4NjQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ194NjQgPSBDLng2NCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgNjQtYml0IHdvcmQuXG5cdCAgICAgKi9cblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZCA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgNjQtYml0IHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAzMiBiaXRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAzMiBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgeDY0V29yZCA9IENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGlnaCwgbG93KSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XG5cdCAgICAgICAgICAgIHRoaXMubG93ID0gbG93O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgTk9UcyB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgbmVnYXRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBuZWdhdGVkID0geDY0V29yZC5ub3QoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBub3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB+dGhpcy5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gfnRoaXMubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIEFORHMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBBTkQgd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgQU5EaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYW5kZWQgPSB4NjRXb3JkLmFuZChhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gYW5kOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCAmIHdvcmQuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93ICYgd29yZC5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgT1JzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gT1Igd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgT1JpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBvcmVkID0geDY0V29yZC5vcihhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gb3I6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoIHwgd29yZC5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgfCB3b3JkLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBYT1JzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gWE9SIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIFhPUmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHhvcmVkID0geDY0V29yZC54b3IoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHhvcjogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggXiB3b3JkLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyBeIHdvcmQubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTaGlmdHMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgbGVmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byBzaGlmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBzaGlmdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHNoaWZ0ZWQgPSB4NjRXb3JkLnNoaWZ0TCgyNSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gc2hpZnRMOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyBpZiAobiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9ICh0aGlzLmhpZ2ggPDwgbikgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG4pKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyA8PCBuO1xuXHQgICAgICAgICAgICAvLyB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmxvdyA8PCAobiAtIDMyKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSAwO1xuXHQgICAgICAgICAgICAvLyB9XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNoaWZ0cyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSByaWdodC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byBzaGlmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBzaGlmdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHNoaWZ0ZWQgPSB4NjRXb3JkLnNoaWZ0Uig3KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBzaGlmdFI6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIGlmIChuIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSAodGhpcy5sb3cgPj4+IG4pIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBuKSk7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCA+Pj4gbjtcblx0ICAgICAgICAgICAgLy8gfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmhpZ2ggPj4+IChuIC0gMzIpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSAwO1xuXHQgICAgICAgICAgICAvLyB9XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJvdGF0ZXMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgbGVmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byByb3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgcm90YXRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciByb3RhdGVkID0geDY0V29yZC5yb3RMKDI1KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyByb3RMOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5zaGlmdEwobikub3IodGhpcy5zaGlmdFIoNjQgLSBuKSk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJvdGF0ZXMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHJvdGF0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcm90YXRlZCA9IHg2NFdvcmQucm90Uig3KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyByb3RSOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5zaGlmdFIobikub3IodGhpcy5zaGlmdEwoNjQgLSBuKSk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBhZGQgd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgYWRkaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYWRkZWQgPSB4NjRXb3JkLmFkZChhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gYWRkOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gKHRoaXMubG93ICsgd29yZC5sb3cpIHwgMDtcblx0ICAgICAgICAgICAgLy8gdmFyIGNhcnJ5ID0gKGxvdyA+Pj4gMCkgPCAodGhpcy5sb3cgPj4+IDApID8gMSA6IDA7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gKHRoaXMuaGlnaCArIHdvcmQuaGlnaCArIGNhcnJ5KSB8IDA7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgNjQtYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiBDcnlwdG9KUy54NjQuV29yZCBvYmplY3RzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgWDY0V29yZEFycmF5ID0gQ194NjQuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiBDcnlwdG9KUy54NjQuV29yZCBvYmplY3RzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpLFxuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MTgxOTFhMWIsIDB4MWMxZDFlMWYpXG5cdCAgICAgICAgICogICAgIF0pO1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyksXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgxODE5MWExYiwgMHgxYzFkMWUxZilcblx0ICAgICAgICAgKiAgICAgXSwgMTApO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyA2NC1iaXQgd29yZCBhcnJheSB0byBhIDMyLWJpdCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q3J5cHRvSlMubGliLldvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5J3MgZGF0YSBhcyBhIDMyLWJpdCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgeDMyV29yZEFycmF5ID0geDY0V29yZEFycmF5LnRvWDMyKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9YMzI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB4NjRXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB4NjRXb3Jkc0xlbmd0aCA9IHg2NFdvcmRzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB4MzJXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHg2NFdvcmRzTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB4NjRXb3JkID0geDY0V29yZHNbaV07XG5cdCAgICAgICAgICAgICAgICB4MzJXb3Jkcy5wdXNoKHg2NFdvcmQuaGlnaCk7XG5cdCAgICAgICAgICAgICAgICB4MzJXb3Jkcy5wdXNoKHg2NFdvcmQubG93KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBYMzJXb3JkQXJyYXkuY3JlYXRlKHgzMldvcmRzLCB0aGlzLnNpZ0J5dGVzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHg2NFdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBcIndvcmRzXCIgYXJyYXlcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGVhY2ggWDY0V29yZCBvYmplY3Rcblx0ICAgICAgICAgICAgdmFyIHdvcmRzTGVuZ3RoID0gd29yZHMubGVuZ3RoO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2ldID0gd29yZHNbaV0uY2xvbmUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jcnlwdG8tanMveDY0LWNvcmUuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMveDY0LWNvcmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiEgbm9ybWFsaXplLmNzcyB2Ny4wLjAgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovaHRtbHtsaW5lLWhlaWdodDoxLjE1Oy1tcy10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCV9Ym9keXttYXJnaW46MH1hcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsbmF2LHNlY3Rpb257ZGlzcGxheTpibG9ja31oMXtmb250LXNpemU6MmVtO21hcmdpbjouNjdlbSAwfWZpZ2NhcHRpb24sZmlndXJlLG1haW57ZGlzcGxheTpibG9ja31maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhye2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjA7b3ZlcmZsb3c6dmlzaWJsZX1wcmV7Zm9udC1mYW1pbHk6bW9ub3NwYWNlLG1vbm9zcGFjZTtmb250LXNpemU6MWVtfWF7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDstd2Via2l0LXRleHQtZGVjb3JhdGlvbi1za2lwOm9iamVjdHN9YWJiclt0aXRsZV17Ym9yZGVyLWJvdHRvbTpub25lO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZSBkb3R0ZWR9YixzdHJvbmd7Zm9udC13ZWlnaHQ6aW5oZXJpdDtmb250LXdlaWdodDpib2xkZXJ9Y29kZSxrYmQsc2FtcHtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19ZGZue2ZvbnQtc3R5bGU6aXRhbGljfW1hcmt7YmFja2dyb3VuZC1jb2xvcjojZmYwO2NvbG9yOiMwMDB9c21hbGx7Zm9udC1zaXplOjgwJX1zdWIsc3Vwe2ZvbnQtc2l6ZTo3NSU7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX1zdWJ7Ym90dG9tOi0uMjVlbX1zdXB7dG9wOi0uNWVtfWF1ZGlvLHZpZGVve2Rpc3BsYXk6aW5saW5lLWJsb2NrfWF1ZGlvOm5vdChbY29udHJvbHNdKXtkaXNwbGF5Om5vbmU7aGVpZ2h0OjB9aW1ne2JvcmRlci1zdHlsZTpub25lfXN2Zzpub3QoOnJvb3Qpe292ZXJmbG93OmhpZGRlbn1idXR0b24saW5wdXQsb3B0Z3JvdXAsc2VsZWN0LHRleHRhcmVhe2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7Zm9udC1zaXplOjEwMCU7bGluZS1oZWlnaHQ6MS4xNTttYXJnaW46MH1idXR0b24saW5wdXR7b3ZlcmZsb3c6dmlzaWJsZX1idXR0b24sc2VsZWN0e3RleHQtdHJhbnNmb3JtOm5vbmV9W3R5cGU9cmVzZXRdLFt0eXBlPXN1Ym1pdF0sYnV0dG9uLGh0bWwgW3R5cGU9YnV0dG9uXXstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9ufVt0eXBlPWJ1dHRvbl06Oi1tb3otZm9jdXMtaW5uZXIsW3R5cGU9cmVzZXRdOjotbW96LWZvY3VzLWlubmVyLFt0eXBlPXN1Ym1pdF06Oi1tb3otZm9jdXMtaW5uZXIsYnV0dG9uOjotbW96LWZvY3VzLWlubmVye2JvcmRlci1zdHlsZTpub25lO3BhZGRpbmc6MH1bdHlwZT1idXR0b25dOi1tb3otZm9jdXNyaW5nLFt0eXBlPXJlc2V0XTotbW96LWZvY3VzcmluZyxbdHlwZT1zdWJtaXRdOi1tb3otZm9jdXNyaW5nLGJ1dHRvbjotbW96LWZvY3VzcmluZ3tvdXRsaW5lOjFweCBkb3R0ZWQgQnV0dG9uVGV4dH1maWVsZHNldHtwYWRkaW5nOi4zNWVtIC43NWVtIC42MjVlbX1sZWdlbmR7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yOmluaGVyaXQ7ZGlzcGxheTp0YWJsZTttYXgtd2lkdGg6MTAwJTtwYWRkaW5nOjA7d2hpdGUtc3BhY2U6bm9ybWFsfXByb2dyZXNze2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXRleHRhcmVhe292ZXJmbG93OmF1dG99W3R5cGU9Y2hlY2tib3hdLFt0eXBlPXJhZGlvXXtib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzowfVt0eXBlPW51bWJlcl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sW3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbntoZWlnaHQ6YXV0b31bdHlwZT1zZWFyY2hdey13ZWJraXQtYXBwZWFyYW5jZTp0ZXh0ZmllbGQ7b3V0bGluZS1vZmZzZXQ6LTJweH1bdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1jYW5jZWwtYnV0dG9uLFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmV9Ojotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2ZvbnQ6aW5oZXJpdH1kZXRhaWxzLG1lbnV7ZGlzcGxheTpibG9ja31zdW1tYXJ5e2Rpc3BsYXk6bGlzdC1pdGVtfWNhbnZhc3tkaXNwbGF5OmlubGluZS1ibG9ja31baGlkZGVuXSx0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhL2FwcHMvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBmb250LWZhY2V7Zm9udC1mYW1pbHk6SWNvbnM7c3JjOnVybChcIiArIHJlcXVpcmUoXCIuLi9mb250cy9vcGVuLWljb25pYy5lb3RcIikgKyBcIik7c3JjOnVybChcIiArIHJlcXVpcmUoXCIuLi9mb250cy9vcGVuLWljb25pYy5lb3RcIikgKyBcIj8jaWNvbmljLXNtKSBmb3JtYXQoXFxcImVtYmVkZGVkLW9wZW50eXBlXFxcIiksdXJsKFwiICsgcmVxdWlyZShcIi4uL2ZvbnRzL29wZW4taWNvbmljLndvZmZcIikgKyBcIikgZm9ybWF0KFxcXCJ3b2ZmXFxcIiksdXJsKFwiICsgcmVxdWlyZShcIi4uL2ZvbnRzL29wZW4taWNvbmljLnR0ZlwiKSArIFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIiksdXJsKFwiICsgcmVxdWlyZShcIi4uL2ZvbnRzL29wZW4taWNvbmljLm90ZlwiKSArIFwiKSBmb3JtYXQoXFxcIm9wZW50eXBlXFxcIiksdXJsKFwiICsgcmVxdWlyZShcIi4uL2ZvbnRzL29wZW4taWNvbmljLnN2Z1wiKSArIFwiI2ljb25pYy1zbSkgZm9ybWF0KFxcXCJzdmdcXFwiKTtmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9Lm9pW2RhdGEtZ2x5cGhdLm9pLXRleHQtcmVwbGFjZXtmb250LXNpemU6MDtsaW5lLWhlaWdodDowfS5vaVtkYXRhLWdseXBoXS5vaS10ZXh0LXJlcGxhY2U6YmVmb3Jle3dpZHRoOjFlbTt0ZXh0LWFsaWduOmNlbnRlcn0ub2lbZGF0YS1nbHlwaF06YmVmb3Jle2ZvbnQtZmFtaWx5Okljb25zO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3NwZWFrOm5vbmU7bGluZS1oZWlnaHQ6MTt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZTtmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWw7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGV9Lm9pW2RhdGEtZ2x5cGhdOmVtcHR5OmJlZm9yZXt3aWR0aDoxZW07dGV4dC1hbGlnbjpjZW50ZXI7Ym94LXNpemluZzpjb250ZW50LWJveH0ub2lbZGF0YS1nbHlwaF0ub2ktYWxpZ24tbGVmdDpiZWZvcmV7dGV4dC1hbGlnbjpsZWZ0fS5vaVtkYXRhLWdseXBoXS5vaS1hbGlnbi1yaWdodDpiZWZvcmV7dGV4dC1hbGlnbjpyaWdodH0ub2lbZGF0YS1nbHlwaF0ub2ktYWxpZ24tY2VudGVyOmJlZm9yZXt0ZXh0LWFsaWduOmNlbnRlcn0ub2lbZGF0YS1nbHlwaF0ub2ktZmxpcC1ob3Jpem9udGFsOmJlZm9yZXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoLTEpOy1tcy10cmFuc2Zvcm06c2NhbGVYKC0xKTt0cmFuc2Zvcm06c2NhbGVYKC0xKX0ub2lbZGF0YS1nbHlwaF0ub2ktZmxpcC12ZXJ0aWNhbDpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVZKC0xKTstbXMtdHJhbnNmb3JtOnNjYWxlWCgtMSk7dHJhbnNmb3JtOnNjYWxlWSgtMSl9Lm9pW2RhdGEtZ2x5cGhdLm9pLWZsaXAtaG9yaXpvbnRhbC12ZXJ0aWNhbDpiZWZvcmV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLTEpOy1tcy10cmFuc2Zvcm06c2NhbGVYKC0xKTt0cmFuc2Zvcm06c2NhbGUoLTEpfS5vaVtkYXRhLWdseXBoPWFjY291bnQtbG9naW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YWNjb3VudC1sb2dvdXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwMVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YWN0aW9uLXJlZG9dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YWN0aW9uLXVuZG9dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YWxpZ24tY2VudGVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDRcXFwifS5vaVtkYXRhLWdseXBoPWFsaWduLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwNVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YWxpZ24tcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwNlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXBlcnR1cmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctYm90dG9tXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMDhcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LWNpcmNsZS1ib3R0b21dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctY2lyY2xlLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctY2lyY2xlLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMEJcXFwifS5vaVtkYXRhLWdseXBoPWFycm93LWNpcmNsZS10b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDBEXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDBFXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy10aGljay1ib3R0b21dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAwRlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctdGhpY2stbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDEwXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy10aGljay1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDExXFxcIn0ub2lbZGF0YS1nbHlwaD1hcnJvdy10aGljay10b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YXJyb3ctdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTNcXFwifS5vaVtkYXRhLWdseXBoPWF1ZGlvLXNwZWN0cnVtXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTRcXFwifS5vaVtkYXRhLWdseXBoPWF1ZGlvXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTVcXFwifS5vaVtkYXRhLWdseXBoPWJhZGdlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTZcXFwifS5vaVtkYXRhLWdseXBoPWJhbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDE3XFxcIn0ub2lbZGF0YS1nbHlwaD1iYXItY2hhcnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmFza2V0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMTlcXFwifS5vaVtkYXRhLWdseXBoPWJhdHRlcnktZW1wdHldOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAxQVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YmF0dGVyeS1mdWxsXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMUJcXFwifS5vaVtkYXRhLWdseXBoPWJlYWtlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDFDXFxcIn0ub2lbZGF0YS1nbHlwaD1iZWxsXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMURcXFwifS5vaVtkYXRhLWdseXBoPWJsdWV0b290aF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDFFXFxcIn0ub2lbZGF0YS1nbHlwaD1ib2xkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMUZcXFwifS5vaVtkYXRhLWdseXBoPWJvbHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyMFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Ym9va106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDIxXFxcIn0ub2lbZGF0YS1nbHlwaD1ib29rbWFya106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDIyXFxcIn0ub2lbZGF0YS1nbHlwaD1ib3hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9YnJpZWZjYXNlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMjRcXFwifS5vaVtkYXRhLWdseXBoPWJyaXRpc2gtcG91bmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyNVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YnJvd3Nlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDI2XFxcIn0ub2lbZGF0YS1nbHlwaD1icnVzaF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDI3XFxcIn0ub2lbZGF0YS1nbHlwaD1idWddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9YnVsbGhvcm5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAyOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2FsY3VsYXRvcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDJBXFxcIn0ub2lbZGF0YS1nbHlwaD1jYWxlbmRhcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDJCXFxcIn0ub2lbZGF0YS1nbHlwaD1jYW1lcmEtc2xyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMkNcXFwifS5vaVtkYXRhLWdseXBoPWNhcmV0LWJvdHRvbV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDJEXFxcIn0ub2lbZGF0YS1nbHlwaD1jYXJldC1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMkVcXFwifS5vaVtkYXRhLWdseXBoPWNhcmV0LXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMkZcXFwifS5vaVtkYXRhLWdseXBoPWNhcmV0LXRvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDMwXFxcIn0ub2lbZGF0YS1nbHlwaD1jYXJ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzFcXFwifS5vaVtkYXRhLWdseXBoPWNoYXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2hlY2tdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2hldnJvbi1ib3R0b21dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzNFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2hldnJvbi1sZWZ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzVcXFwifS5vaVtkYXRhLWdseXBoPWNoZXZyb24tcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzNlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2hldnJvbi10b3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2lyY2xlLWNoZWNrXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzhcXFwifS5vaVtkYXRhLWdseXBoPWNpcmNsZS14XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwMzlcXFwifS5vaVtkYXRhLWdseXBoPWNsaXBib2FyZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDNBXFxcIn0ub2lbZGF0YS1nbHlwaD1jbG9ja106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDNCXFxcIn0ub2lbZGF0YS1nbHlwaD1jbG91ZC1kb3dubG9hZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDNDXFxcIn0ub2lbZGF0YS1nbHlwaD1jbG91ZC11cGxvYWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzRFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2xvdWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTAzRVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y2xvdWR5XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwM0ZcXFwifS5vaVtkYXRhLWdseXBoPWNvZGVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0MFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29nXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDFcXFwifS5vaVtkYXRhLWdseXBoPWNvbGxhcHNlLWRvd25dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0MlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29sbGFwc2UtbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQzXFxcIn0ub2lbZGF0YS1nbHlwaD1jb2xsYXBzZS1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQ0XFxcIn0ub2lbZGF0YS1nbHlwaD1jb2xsYXBzZS11cF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDQ1XFxcIn0ub2lbZGF0YS1nbHlwaD1jb21tYW5kXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDZcXFwifS5vaVtkYXRhLWdseXBoPWNvbW1lbnQtc3F1YXJlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNDdcXFwifS5vaVtkYXRhLWdseXBoPWNvbXBhc3NdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0OFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29udHJhc3RdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0OVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y29weXdyaXRpbmddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0QVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y3JlZGl0LWNhcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0QlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9Y3JvcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDRDXFxcIn0ub2lbZGF0YS1nbHlwaD1kYXNoYm9hcmRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA0RFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZGF0YS10cmFuc2Zlci1kb3dubG9hZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDRFXFxcIn0ub2lbZGF0YS1nbHlwaD1kYXRhLXRyYW5zZmVyLXVwbG9hZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDRGXFxcIn0ub2lbZGF0YS1nbHlwaD1kZWxldGVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1MFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZGlhbF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDUxXFxcIn0ub2lbZGF0YS1nbHlwaD1kb2N1bWVudF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDUyXFxcIn0ub2lbZGF0YS1nbHlwaD1kb2xsYXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1M1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZG91YmxlLXF1b3RlLXNhbnMtbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDU0XFxcIn0ub2lbZGF0YS1nbHlwaD1kb3VibGUtcXVvdGUtc2Fucy1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDU1XFxcIn0ub2lbZGF0YS1nbHlwaD1kb3VibGUtcXVvdGUtc2VyaWYtbGVmdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDU2XFxcIn0ub2lbZGF0YS1nbHlwaD1kb3VibGUtcXVvdGUtc2VyaWYtcmlnaHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1N1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZHJvcGxldF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDU4XFxcIn0ub2lbZGF0YS1nbHlwaD1lamVjdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDU5XFxcIn0ub2lbZGF0YS1nbHlwaD1lbGV2YXRvcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDVBXFxcIn0ub2lbZGF0YS1nbHlwaD1lbGxpcHNlc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDVCXFxcIn0ub2lbZGF0YS1nbHlwaD1lbnZlbG9wZS1jbG9zZWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1Q1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZW52ZWxvcGUtb3Blbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDVEXFxcIn0ub2lbZGF0YS1nbHlwaD1ldXJvXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNUVcXFwifS5vaVtkYXRhLWdseXBoPWV4Y2VycHRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA1RlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXhwYW5kLWRvd25dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2MFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXhwYW5kLWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2MVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZXhwYW5kLXJpZ2h0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjJcXFwifS5vaVtkYXRhLWdseXBoPWV4cGFuZC11cF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDYzXFxcIn0ub2lbZGF0YS1nbHlwaD1leHRlcm5hbC1saW5rXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjRcXFwifS5vaVtkYXRhLWdseXBoPWV5ZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDY1XFxcIn0ub2lbZGF0YS1nbHlwaD1leWVkcm9wcGVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjZcXFwifS5vaVtkYXRhLWdseXBoPWZpbGVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2N1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZmlyZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDY4XFxcIn0ub2lbZGF0YS1nbHlwaD1mbGFnXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNjlcXFwifS5vaVtkYXRhLWdseXBoPWZsYXNoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNkFcXFwifS5vaVtkYXRhLWdseXBoPWZvbGRlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDZCXFxcIn0ub2lbZGF0YS1nbHlwaD1mb3JrXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNkNcXFwifS5vaVtkYXRhLWdseXBoPWZ1bGxzY3JlZW4tZW50ZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA2RFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9ZnVsbHNjcmVlbi1leGl0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNkVcXFwifS5vaVtkYXRhLWdseXBoPWdsb2JlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNkZcXFwifS5vaVtkYXRhLWdseXBoPWdyYXBoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzBcXFwifS5vaVtkYXRhLWdseXBoPWdyaWQtZm91ci11cF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDcxXFxcIn0ub2lbZGF0YS1nbHlwaD1ncmlkLXRocmVlLXVwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzJcXFwifS5vaVtkYXRhLWdseXBoPWdyaWQtdHdvLXVwXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzNcXFwifS5vaVtkYXRhLWdseXBoPWhhcmQtZHJpdmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3NFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9aGVhZGVyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwNzVcXFwifS5vaVtkYXRhLWdseXBoPWhlYWRwaG9uZXNdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3NlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9aGVhcnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3N1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9aG9tZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDc4XFxcIn0ub2lbZGF0YS1nbHlwaD1pbWFnZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDc5XFxcIn0ub2lbZGF0YS1nbHlwaD1pbmJveF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDdBXFxcIn0ub2lbZGF0YS1nbHlwaD1pbmZpbml0eV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDdCXFxcIn0ub2lbZGF0YS1nbHlwaD1pbmZvXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwN0NcXFwifS5vaVtkYXRhLWdseXBoPWl0YWxpY106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDdEXFxcIn0ub2lbZGF0YS1nbHlwaD1qdXN0aWZ5LWNlbnRlcl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDdFXFxcIn0ub2lbZGF0YS1nbHlwaD1qdXN0aWZ5LWxlZnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA3RlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9anVzdGlmeS1yaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDgwXFxcIn0ub2lbZGF0YS1nbHlwaD1rZXldOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4MVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bGFwdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODJcXFwifS5vaVtkYXRhLWdseXBoPWxheWVyc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDgzXFxcIn0ub2lbZGF0YS1nbHlwaD1saWdodGJ1bGJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4NFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bGluay1icm9rZW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4NVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bGluay1pbnRhY3RdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4NlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bGlzdC1yaWNoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwODdcXFwifS5vaVtkYXRhLWdseXBoPWxpc3RdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4OFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bG9jYXRpb25dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4OVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bG9jay1sb2NrZWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4QVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bG9jay11bmxvY2tlZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDhCXFxcIn0ub2lbZGF0YS1nbHlwaD1sb29wLWNpcmN1bGFyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOENcXFwifS5vaVtkYXRhLWdseXBoPWxvb3Atc3F1YXJlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOERcXFwifS5vaVtkYXRhLWdseXBoPWxvb3BdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA4RVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWFnbmlmeWluZy1nbGFzc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDhGXFxcIn0ub2lbZGF0YS1nbHlwaD1tYXAtbWFya2VyXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTBcXFwifS5vaVtkYXRhLWdseXBoPW1hcF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDkxXFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1wYXVzZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDkyXFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1wbGF5XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTNcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXJlY29yZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDk0XFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1za2lwLWJhY2t3YXJkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTVcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXNraXAtZm9yd2FyZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDk2XFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1zdGVwLWJhY2t3YXJkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTdcXFwifS5vaVtkYXRhLWdseXBoPW1lZGlhLXN0ZXAtZm9yd2FyZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDk4XFxcIn0ub2lbZGF0YS1nbHlwaD1tZWRpYS1zdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOTlcXFwifS5vaVtkYXRhLWdseXBoPW1lZGljYWwtY3Jvc3NdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5QVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bWVudV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDlCXFxcIn0ub2lbZGF0YS1nbHlwaD1taWNyb3Bob25lXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOUNcXFwifS5vaVtkYXRhLWdseXBoPW1pbnVzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwOURcXFwifS5vaVtkYXRhLWdseXBoPW1vbml0b3JdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTA5RVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9bW9vbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMDlGXFxcIn0ub2lbZGF0YS1nbHlwaD1tb3ZlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTBcXFwifS5vaVtkYXRhLWdseXBoPW11c2ljYWwtbm90ZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEExXFxcIn0ub2lbZGF0YS1nbHlwaD1wYXBlcmNsaXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGVuY2lsXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTNcXFwifS5vaVtkYXRhLWdseXBoPXBlb3BsZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEE0XFxcIn0ub2lbZGF0YS1nbHlwaD1wZXJzb25dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBNVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGhvbmVdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBNlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cGllLWNoYXJ0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQTdcXFwifS5vaVtkYXRhLWdseXBoPXBpbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEE4XFxcIn0ub2lbZGF0YS1nbHlwaD1wbGF5LWNpcmNsZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEE5XFxcIn0ub2lbZGF0YS1nbHlwaD1wbHVzXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQUFcXFwifS5vaVtkYXRhLWdseXBoPXBvd2VyLXN0YW5kYnldOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cHJpbnRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9cHJvamVjdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEFEXFxcIn0ub2lbZGF0YS1nbHlwaD1wdWxzZV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEFFXFxcIn0ub2lbZGF0YS1nbHlwaD1wdXp6bGUtcGllY2VdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBBRlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cXVlc3Rpb24tbWFya106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEIwXFxcIn0ub2lbZGF0YS1nbHlwaD1yYWluXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjFcXFwifS5vaVtkYXRhLWdseXBoPXJhbmRvbV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEIyXFxcIn0ub2lbZGF0YS1nbHlwaD1yZWxvYWRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCM1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9cmVzaXplLWJvdGhdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCNFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cmVzaXplLWhlaWdodF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEI1XFxcIn0ub2lbZGF0YS1nbHlwaD1yZXNpemUtd2lkdGhdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCNlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9cnNzLWFsdF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEI3XFxcIn0ub2lbZGF0YS1nbHlwaD1yc3NdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCOFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c2NyaXB0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQjlcXFwifS5vaVtkYXRhLWdseXBoPXNoYXJlLWJveGVkXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQkFcXFwifS5vaVtkYXRhLWdseXBoPXNoYXJlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQkJcXFwifS5vaVtkYXRhLWdseXBoPXNoaWVsZF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEJDXFxcIn0ub2lbZGF0YS1nbHlwaD1zaWduYWxdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCRFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c2lnbnBvc3RdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCRVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c29ydC1hc2NlbmRpbmddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBCRlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c29ydC1kZXNjZW5kaW5nXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzBcXFwifS5vaVtkYXRhLWdseXBoPXNwcmVhZHNoZWV0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzFcXFwifS5vaVtkYXRhLWdseXBoPXN0YXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9c3VuXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQzNcXFwifS5vaVtkYXRhLWdseXBoPXRhYmxldF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEM0XFxcIn0ub2lbZGF0YS1nbHlwaD10YWddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDNVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGFnc106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEM2XFxcIn0ub2lbZGF0YS1nbHlwaD10YXJnZXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDN1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGFza106YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEM4XFxcIn0ub2lbZGF0YS1nbHlwaD10ZXJtaW5hbF06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEM5XFxcIn0ub2lbZGF0YS1nbHlwaD10ZXh0XTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwQ0FcXFwifS5vaVtkYXRhLWdseXBoPXRodW1iLWRvd25dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGh1bWItdXBdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDQ1xcXCJ9Lm9pW2RhdGEtZ2x5cGg9dGltZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDRFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dHJhbnNmZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDRVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dHJhc2hdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBDRlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dW5kZXJsaW5lXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDBcXFwifS5vaVtkYXRhLWdseXBoPXZlcnRpY2FsLWFsaWduLWJvdHRvbV06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQxXFxcIn0ub2lbZGF0YS1nbHlwaD12ZXJ0aWNhbC1hbGlnbi1jZW50ZXJdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEMlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dmVydGljYWwtYWxpZ24tdG9wXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDNcXFwifS5vaVtkYXRhLWdseXBoPXZpZGVvXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDRcXFwifS5vaVtkYXRhLWdseXBoPXZvbHVtZS1oaWdoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDVcXFwifS5vaVtkYXRhLWdseXBoPXZvbHVtZS1sb3ddOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBENlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9dm9sdW1lLW9mZl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxFMEQ3XFxcIn0ub2lbZGF0YS1nbHlwaD13YXJuaW5nXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRDhcXFwifS5vaVtkYXRhLWdseXBoPXdpZmldOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEOVxcXCJ9Lm9pW2RhdGEtZ2x5cGg9d3JlbmNoXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwREFcXFwifS5vaVtkYXRhLWdseXBoPXhdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBEQlxcXCJ9Lm9pW2RhdGEtZ2x5cGg9eWVuXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEUwRENcXFwifS5vaVtkYXRhLWdseXBoPXpvb20taW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBERFxcXCJ9Lm9pW2RhdGEtZ2x5cGg9em9vbS1vdXRdOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRTBERVxcXCJ9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2Nzcy9vcGVuLWljb25pYy5taW4uY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgZ2V0Q29uZmlybWF0aW9uID0gZXhwb3J0cy5nZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IGV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cbnZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZXhwb3J0cy5zdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xudmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xudmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBleHBvcnRzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUgPSByZXF1aXJlKCdyZXNvbHZlLXBhdGhuYW1lJyk7XG5cbnZhciBfcmVzb2x2ZVBhdGhuYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc29sdmVQYXRobmFtZSk7XG5cbnZhciBfdmFsdWVFcXVhbCA9IHJlcXVpcmUoJ3ZhbHVlLWVxdWFsJyk7XG5cbnZhciBfdmFsdWVFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWx1ZUVxdWFsKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlTG9jYXRpb24gPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gKDAsIF9yZXNvbHZlUGF0aG5hbWUyLmRlZmF1bHQpKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG52YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmICgwLCBfdmFsdWVFcXVhbDIuZGVmYXVsdCkoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L0xvY2F0aW9uVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0xvY2F0aW9uVXRpbHMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGFkZExlYWRpbmdTbGFzaCA9IGV4cG9ydHMuYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbnZhciBzdHJpcExlYWRpbmdTbGFzaCA9IGV4cG9ydHMuc3RyaXBMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufTtcblxudmFyIGhhc0Jhc2VuYW1lID0gZXhwb3J0cy5oYXNCYXNlbmFtZSA9IGZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXggKyAnKFxcXFwvfFxcXFw/fCN8JCknLCAnaScpLnRlc3QocGF0aCk7XG59O1xuXG52YXIgc3RyaXBCYXNlbmFtZSA9IGV4cG9ydHMuc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpID8gcGF0aC5zdWJzdHIocHJlZml4Lmxlbmd0aCkgOiBwYXRoO1xufTtcblxudmFyIHN0cmlwVHJhaWxpbmdTbGFzaCA9IGV4cG9ydHMuc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn07XG5cbnZhciBwYXJzZVBhdGggPSBleHBvcnRzLnBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxudmFyIGNyZWF0ZVBhdGggPSBleHBvcnRzLmNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcblxuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L1BhdGhVdGlscy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoX0RPTVV0aWxzLmNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkpKCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UpKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gX0RPTVV0aWxzLmdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/ICgwLCBfUGF0aFV0aWxzLnN0cmlwVHJhaWxpbmdTbGFzaCkoKDAsIF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoKShwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCFiYXNlbmFtZSB8fCAoMCwgX1BhdGhVdGlscy5oYXNCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBrZXkpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb3BTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cbiAgICBpZiAoKDAsIF9ET01VdGlscy5pc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KShldmVudCkpIHJldHVybjtcblxuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIGtleXMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsS2V5cy5pbmRleE9mKHRvTG9jYXRpb24ua2V5KTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGZyb21Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpO1xuICB2YXIgYWxsS2V5cyA9IFtpbml0aWFsTG9jYXRpb24ua2V5XTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICB2YXIgbmV4dEtleXMgPSBhbGxLZXlzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgICBuZXh0S2V5cy5wdXNoKGxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgYWxsS2V5cyA9IG5leHRLZXlzO1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgSGFzaFBhdGhDb2RlcnMgPSB7XG4gIGhhc2hiYW5nOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGggOiAnIS8nICsgKDAsIF9QYXRoVXRpbHMuc3RyaXBMZWFkaW5nU2xhc2gpKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBfUGF0aFV0aWxzLnN0cmlwTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxudmFyIGdldEhhc2hQYXRoID0gZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG59O1xuXG52YXIgcHVzaEhhc2hQYXRoID0gZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn07XG5cbnZhciByZXBsYWNlSGFzaFBhdGggPSBmdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB2YXIgaGFzaEluZGV4ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xuXG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGhhc2hJbmRleCA+PSAwID8gaGFzaEluZGV4IDogMCkgKyAnIycgKyBwYXRoKTtcbn07XG5cbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfRE9NVXRpbHMuY2FuVXNlRE9NLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2gpKCk7XG5cbiAgdmFyIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBfRE9NVXRpbHMuZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/ICgwLCBfUGF0aFV0aWxzLnN0cmlwVHJhaWxpbmdTbGFzaCkoKDAsIF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoKShwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcblxuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIWJhc2VuYW1lIHx8ICgwLCBfUGF0aFV0aWxzLmhhc0Jhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmICgwLCBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbCkocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKSh0b0xvY2F0aW9uKSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGZyb21Mb2NhdGlvbikpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gWygwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSk7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUFVTSCwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcHVzaEhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG5cbiAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpO1xuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBfUGF0aFV0aWxzLmNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuXG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcblxuICAgICAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAoIWJsYWNrbGlzdCB8fCAhYmxhY2tsaXN0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7IC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL25vcm1hbGl6ZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbm9ybWFsaXplLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbm9ybWFsaXplLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vb3Blbi1pY29uaWMubWluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9vcGVuLWljb25pYy5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9vcGVuLWljb25pYy5taW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9jc3Mvb3Blbi1pY29uaWMubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvY3NzL29wZW4taWNvbmljLm1pbi5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3Q7YmFzZTY0LEpHNEFBSHh0QUFBQkFBSUFBQUFBQUFJQUJRTUFBQUFBQUFBQkFKQUJBQUFBQUV4UUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFFQUFBQUFBQUFBR1l3TEt3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBb0FTUUJqQUc4QWJnQnpBQUFBREFCcEFHTUFid0J1QUdrQVl3QUFBQndBVmdCbEFISUFjd0JwQUc4QWJnQWdBREVBTGdBeEFDNEFNUUFnQUFBQUVnQlZBRzRBZEFCcEFIUUFiQUJsQUdRQU1RQUFBQUFBQUFFQUFBQVBBSUFBQXdCd1JrWlVUV3Z3QWFRQUFBRDhBQUFBSEU5VEx6STBCbEZpQUFBQkdBQUFBR0JqYldGd0FBL2tpUUFBQVhnQUFBRkNZM1owSUFBQUFBQUFBR0dJQUFBQUNtWndaMjIrYitZNUFBQmhsQUFBQzJ4bllYTndBQUFBRUFBQVlZQUFBQUFJWjJ4NVpramw3cTRBQUFLOEFBQlNHR2hsWVdRQjg3dEZBQUJVMUFBQUFEWm9hR1ZoQm93RUFRQUFWUXdBQUFBa2FHMTBlSnFlQUJvQUFGVXdBQUFEaG14dlkyR2p1bzlFQUFCWXVBQUFBY1p0WVhod0Fad0wxZ0FBV29BQUFBQWdibUZ0Wlk3MkVNVUFBRnFnQUFBQ2ZIQnZjM1R0RURQK0FBQmRIQUFBQkdOd2NtVnczV3NEaFFBQWJRQUFBQUI3QUFBQUFRQUFBQURNUGFMUEFBQUFBTS9aTDJvQUFBQUF6OWt2YWdBRUF2NEJrQUFGQUFBQ0NBSXdBQUFBY0FJSUFqQUFBQUdBQUNjQXp3QUFBZ0FGQXdBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQlFaa1ZrQU1EZ0FPRGVBeUFBQUFCSUF5QUFaUUFBQUFFQUFBQUFBQUFBQUFBQUFDQUFBUUFBQUFNQUFBQURBQUFBSEFBQkFBQUFBQUE4QUFNQUFRQUFBQndBQkFBZ0FBQUFCQUFFQUFFQUFPRGUvLzhBQU9BQS8vOGdBd0FCQUFBQUFBQUFBUVlBQUFFQUFBQUFBQUFBQVFJQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUJvQUFBRHNBaFVBQXdBSEFBaTFCZ1FCQUFJdEt6TVJNeEVuTXhFakd0SzRucDRDRmYzckdnSGhBQUlBQUFBQUF5QUN2QUFIQUE0QUNMVUtDQUlBQWkwckFTRVJJVFVoRVNFZkFRYzFJVFVoQVN3QjlQNE1BWkQrY0dUSXlQNXdBWkFDdlAxRVpBSDBaSmFXWkdRQUFnQUFBQUFESUFLOEFBY0FEZ0FJdFEwSUFnQUNMU3NCSVJFaE5TRVJJUWNWSVJVaEZTY0JMQUgwL2d3QmtQNXdaQUdRL25ESUFyejlSR1FCOUdSa1pHU1dBQUFCQUFBQVpBTWdBcndBRHdBR3N3WUFBUzByRWlBV0hRRXpCeWN6TlRRbUlnWVZOTTBCSXMxa3lNaGtrdENTQXJ6TmtUTEl5REpva3BKb2tRQUJBQUFBWkFNZ0Fyd0FEd0FHc3dzQUFTMHJBQ0FXRlRRbUlnWWRBVE1ISnpNMU5BRXhBU0xOa3RDU1pNaklaQUs4elpGb2twSm9Nc2pJTXBFQUFBQUFCQUFBQUFBRElBSzhBQU1BQndBTEFBOEFEVUFLRGd3S0NBWUVBZ0FFTFNzUklSVWhGeUVWSVFjaEZTRVhJUlVoQXlEODRHUUNXUDJvWkFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUFBQUVBQUFBQUFNZ0Fyd0FBd0FIQUFzQUR3QU5RQW9PREFvSUJnUUNBQVF0S3hFaEZTRVZJUlVoRlNFVklSVWhGU0VESVB6Z0FsajlxQU1nL09BQ1dQMm9BcnhrWkdSa1pHUmtBQUFBQkFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRFVBS0Rnd0tDQVlFQWdBRUxTc1JJUlVoRnlFVklRY2hGU0VYSVJVaEF5RDg0TWdDV1Ayb3lBTWcvT0RJQWxqOXFBSzhaR1JrWkdSa1pBQUFBQUFGQUFEL253TWdBcndBQlFBTEFCRUFGZ0FiQUE5QURCc1hFeElRREFnR0F3QUZMU3NCTWhjSEpUWUhGd1VtTlRRbEZoVVVCeU1sRXk0Qkp3VWhEZ0VIQVpCc1lrdit2bHl3di83S0JnS3djQkRhL3FKd1hwY3FBVXNCZERHallnSzhPK0hxTW5DSzNpUWtxR3QxbmlSQU5mNmxFWGRXSEZOcENRQUFBUUFBQUFBQjlBTWdBQVlBQnJNRUFBRXRLeE16RVRNTEFUUElaTWozL2NnRElQNE0vdFFCTEFBQUFBQUNBQUFBQUFNZ0F5QUFCd0FPQUFpMUN3Z0VBQUl0S3hJZ0ZoQUdJQ1lRSlJFakNRRWpFZW9CVE9ycS9yVHFBU3pJQVN3QkxNZ0RJT3IrdE9ycUFVeUcvdFQrMUFFc0FTd0FBQUFBQWdBQUFBQURJQU1nQUFjQURnQUl0UW9JQkFBQ0xTc1NJQllRQmlBbUVDVUpBVFVoTlNIcUFVenE2djYwNmdHUS90UUJMQUVzL3RRRElPcit0T3JxQVV5Ry90VCsxTWpJQUFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTkNBUUFBaTByRWlBV0VBWWdKaEFsRlNFVklSVUI2Z0ZNNnVyK3RPb0JrUDdVQVN3QkxBTWc2djYwNnVvQlRJYkl5TWdCTEFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTENBUUFBaTByRWlBV0VBWWdKaEFsQVRNUk14RXo2Z0ZNNnVyK3RPb0JrUDdVeU1qSUF5RHEvclRxNmdGTWh2N1UvdFFCTEFBQUFBRUFBQUJrQXlBQ1dBQUdBQWF6QlFBQkxTc0JGU0VWSVJVbEFTd0I5UDRNL3RRQ1dNaGt5UGNBQUFBQUFRQUFBR1FESUFKWUFBWUFCck1DQUFFdEt3RU5BVFVoTlNFQjlBRXMvdFQrREFIMEFsajMvY2hrQUFBQkFBQUFBQUpZQXlBQUJnQUdzd1FBQVMwckV6TVJNd2tCTThqSXlQN1gvdEhJQXlEK0RQN1VBU3dBQUFFQUFBQmtBeUFDdkFBR0FBYXpCUUFCTFNzQkZTRVZJUlVCQVN3QjlQNE0vdFFDdk1qSXlBRXBBQUFBQVFBQUFHUURJQUs4QUFZQUJyTUNBQUV0S3drQ05TRTFJUUgwQVN6KzFQNE1BZlFDdlA3WC90SEl5QUFCQUFBQUFBSllBeUFBQmdBR3N3TUFBUzByQ1FFakVTTVJJd0VwQVMvSXlNZ0RJUDdVL2d3QjlBQUFBQUVBQUFBQUFmUURJQUFHQUFhekF3QUJMU3NiQVNNUkl4RWo5LzNJWk1nRElQN1UvZ3dCOUFBRUFBQUFBQUs4QXlBQUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLd0V6RVNNRE14RWpBVE1SSXdFekZTTUJrR1JreUdSa0FaQmtaUDJvWkdRRElQemdBcno5cUFIMC9uQUJMTWdBQUFRQUFBQWlBeUFDV0FBS0FCVUFId0FwQUExQUNpUWdIQllRQ3dZQUJDMHJFeGNHRlJRWEJ5NEJOVFFsRmhVVUJnY25OalUwSndVWEJoVVVGd2NtTlRRbEZoVVVCeWMyTlRRbmRFaFlXRWczUFFLc2REMDNTRmhZL3A5RkhCeEZPd0ZWT3p0RkhCd0NXRWhZZVgxWVNEZVVVcVYwZEtWU2xEZElXSDE1V0VSSUhDa3NIRWc3VlZJNk8xRlZPMGdjTENrY0FBQUNBQUFBQUFHUUF5QUFCd0FQQUFpMURRZ0VBQUl0S3hJeUZoUUdJaVkwRXhZek1qY1JKd2QycEhaMnBIWmtOaTR0TjJSa0F5QjJwSFoycFA2VkV4UCt3V1JrQUFNQUFBQUFBeUFESUFBSEFBOEFGd0FLdHhJUURRZ0VBQU10S3hJZ0ZoQUdJQ1lRSlNJR0ZSUVhBU1lYQVJZek1qWTFOT3NCU3V2ci9yYnJBWkI4c0RnQm8wNlQvbDFPWVh5d0F5RHIvcmJyNndGS2g3QjhZVTRCb3poOS9sMDRzSHhoQUFBREFBQUFBQU1nQXJ3QUJRQUpBQTBBQ3JjTUNnZ0dCQUFETFNzUk14RWhGU0VCTXhFakFUTVJJMlFDdlB6Z0FmVEl5UDdVeU1nQ3ZQMm9aQUs4L2d3QkxQN1VBQVFBQUFBQUF5QURJQUFYQUJvQUpnQXlBQTFBQ2kwbklSc1pHQXdCQkMwckFUWVhIZ0lYTXhVakVSUUdJeUVpSmpVUkl6VXpFellYQnlFRUlnWWRBUlFXTWpZOUFUUWtJZ1lkQVJRV01qWTlBVFFCalJFUkFXeDRESUJrRkE3OTdBNFVaSURxRGhpUUFTRCs3eW9kSFNvZEFROHFIUjBxSFFNZ0FRNEJnWTRQWlA2U0RoUVVEZ0Z1WkFFWkVYNnN5QjBWWkJVZEhSVmtGUjBkRldRVkhSMFZaQlVBQWdBQUFHUURJQUs4QUE4QUV3QUl0UkVRQ1FBQ0xTc1RJVElkQVRNVkl4VVVJeUVpTlJFMEZ4RWhFUWtDcWdsa1pBbjlWZ2xrQWZRQ3ZBcSt5TDhKQ1FKR0NXVCtjQUdRQUFBQUFBRUFBQUJrQXlBQ3ZBQVBBQWF6Q1FBQkxTc1RJVElkQVRNVkl4VVVJeUVpTlJFMENRS3FDV1JrQ2YxV0NRSzhDcjdJdndrSkFrWUpBQUFBQUFJQUFQK2NBeUFDdkFBbUFDOEFDTFVzSnhZQ0FpMHJFelEyT3dNaE1oWVVCaXNCRlJJWEZoVVVCeU1HSXlFaUpqVTBOellUTlNNaUJpTWlKZ1VqRlFjR0J5RXZBVndhRXdNRkJRSDBGUjBkRlRLT0dDSXBBeXM1L2dBK1VpSVlqaklCQmdFVkhRR1l5QVkvT0FIQ2R3WUNpaElnSFNvZGpmN3pLRGN6UGlrcFVqNHpOeWdCRFkwQkhoMmlDbnRwNUFvQUFBQUNBQUFBQUFNZ0F5QUFEUUFUQUFpMUVRNEhBQUl0S3dBeUZoVVVGeFlWSVRRM05qVTBFek1VQmlJbUFUNmtkb1pDL09CQ2htVElPMUk3QXlCMlVwdHZOMDlQTjIrYlV2MjZLVHM3QUFBQUFBTUFBQUFBQWlZRElBQU5BQkFBRXdBS3R4SVJEdzRGQUFNdEt4TXpCUWNYQlNNMUJ5YzNKemNYTnhVM0J4VTNsaklCWHVIaC9xSXlTMHVXbGt0TFpKYVdsZ01nK3BPWit2cExTNWFXUzB0a3lHVEl5R1FBQUFBREFBQUFBQU1nQXlBQUZRQWRBQ1VBQ3JjZkhoY1dDd0FETFNzUklUSVdGUlFISGdFVkZBWWpJVFV5TmpVUk5DWWpJUlV6TWpZMEppTURFVE15TmpRbUl3SDBVbllzUVUrU2FQM2FLVHM3S1FFc1pDazdPeWxrbGo1WVdENERJSFpTUmpjZmVFcG9rbVE3S1FHUUtUdklPMUk3L3RUKzFGaDhXQUFBQVFBQUFBQUI5QU1nQUFVQUJyTURBQUV0S3dFUk13RVJJd0VzeVA3VXlBTWcvdFQrREFFc0FBRUFBQUFBQXJ3RElBQWJBQWF6RWdBQkxTc1RJUkUzRnhFek1oWVZFU0VpQmhRV015RVZJU0ltTlJFM1BnRTNaQUVzWkdReUZSMzkyaFVkSFJVQ0p2M2FQbGdEQmlzZEF5RCsxR1JrQVN3ZEZmM2FIU29kWkZnK0FpWVRIU3NHQUFFQUFBQUFBWkFESUFBRUFBYXpBZ0FCTFNzUklSRW5Cd0dReU1nRElQemd5TWdBQUFJQUFBQUFBeUFESUFBREFBOEFDTFVMQkFJQUFpMHJFU0VWSVJVaEZUTTFJUkVVSXlFaU5RTWcvT0FCTE1zQktRbjg4Z2tESUdSa1oyZjlzUWtKQUFBREFBQUFBQU1nQXlBQUZ3QWJBQ2NBQ3JjakhCa1lDd0FETFNzQk16SVdIUUV6TWgwQkZBWWpJU0ltUFFFME93RTFORFlYRlRNMUFSWXpJVEkzRlJRaklTSTFBU3pJS1R1L0NSMFYvVVFWSFFtL095bkkvZ3dZR2dLOEdoZ0ovUElKQXlBN0tXUUo4UlVkSFJYeENXUXBPMlJrWlA0VkNRbklDUWtBQVFBQUFBQUNXQU1nQUNRQUJyTVZBQUV0S3dFeUZoVWpOQ1lqSWdjR0ZSUVdGek1WSXdZSElSVWhOVGMyTnlNMU15NENOVFEzTmdFc1htcGtNakl2R1J3WkE2eXlGMW9CNi8yb0VGY1RlbjBDRHdneU53TWdhbDR5TWg4ak94eDNIR1JoWjJSNkRGZFBaQTFIUEI5ZVBrVUFBQUFFQUFEL25BTWdBcndBRkFBY0FDZ0FMQUFOUUFvcUtTRWRHUlVMQUFRdEt4TTdBeUV5RmhVUkZBWWpJU0ltTlJFMU5EWVdJZ1lVRmpJMk5EY2lCaFFXTXlFeU5qUW1Jd1VSSVJFaUJBTUVCUUs4RlIwZEZmMUVGUjBVbHlvZEhTb2RsaFVkSFJVQkxCVWRIUlg5MmdKWUFyd2RGZjFFRlIwZEZRSzhBZzhkWUIwcUhSMHFIUjBxSFIwcUhjaitjQUdRQUFBQUFnQUFBQUFER2dNZEFBMEFHd0FJdFJNT0J3QUNMU3NCSHdFV0J3RVBBUzRCSno4QkNRRXlGaFVVQmlNaUp6NEJOVFEyQXVnR0xBVUYvdllQR1JGUE5nd05BWGYrS0RoT25HNUtQRDFKVFFNZEF5d0ZCLzZKRFF3MlR4RVpEd0VLL25aT09HNmNJaU44U1RoT0FBQUFBQUVBQVArN0FzNEN2QUJuQUFhek1nc0JMU3NUTkRZek1oOEJOeTRCUGdFeUhnRUdCeGMzTmpNeUZoVVVCZzhCRmhjek1oWVVCaXNCRkFjWEhnRVZGQVlqSWk4QkJnY21QUWMwSmlNaUJnY1dGQWNkQXhRSEppY0hCaU1pSmpVME5qOEJKalVyQVNJbU5UUTJPd0kyTnljdUFRa2JFdzRNZ3gwY0JpUkpWa2trQlJ3Y2d3c0tGUjBRQzNNVUJVUVZIUjBWTWdaT0R4WWRGUkFQUVNWQ1BCMFZFaHdFQVFFN1F5UkNEeEFWSFJZUFRnWXlCUlVkSFJVRlJRVVVkQXdRQWNNU0lBZENGaDFZVFRnM1RWZ2VGa0lISFJVTkdnWTRJdzhkS2gwaUlDZ0VIUkFWSFFzalNDWWhKNGNFQlFZRkJWY1ZIUmNSQXhBRFVnUUZrQ2dnS1VVakN4MFZFQjBFS0NBaUhSVVVIZzhqT0FVYUFBSUFBQUFDQXJ3Q3ZBQUhBQndBQ0xVU0NRVUFBaTByQVRNeUZSRVVLd0VCSlJFbkZTSUhGeFlPQVNZbkF5TWlQUUUwT3dFQ1dGc0pDVnYrZWdFaStoY0ZTd2dPSmlvSVoxc0pDYllDdkFuOXVna0JrNVArREgwREZySVRLaEFPRXdFUUNiWUpBQUFBQndBQUFBQUN2QU1nQUFzQUR3QVRBQmNBR3dBZkFDTUFFMEFRSVNBZEhCa1lGUlFSRUEwTUJRQUhMU3NUSVRJVkVSUWpJU0kxRVRRWEZTRTFBUlV6TlRNVk16VXpFVE1SQlJVek5UTVZNelVKQXFvSkNmMVdDV1FCOVA0TVpHUmtaR1QrREdSa1pBTWdDZnp5Q1FrRERnbGt5TWorMUdSa1pHVCsxQUVzeUdSa1pHUUFCd0FBQUFBQ3ZBTWdBQU1BQ3dBUEFCTUFGd0FiQUI4QUUwQVFIUndaR0JVVUVSQU5EQWNFQWdBSExTc1JJUlVoRlNFUkZDTWhJalVURlRNMU14VXpOVE1WTXpVRkZUTTFNeFV6TlFLOC9VUUN2QW45Vmdsa1pHUmtaR1QrREdSa1pBTWd5R1QrRlFrSkFZZGtaR1JrWkdUSVpHUmtaQUFBQkFBQUFBQURJQU1nQUJnQUlBQW9BREFBRFVBS0xTa2xJUjBaQ3dBRUxTc0JNeklmQVJZN0FUSVZFUlFqSVNJMUVUUTJPd0V5UHdFMkFpSUdGQll5TmpRa0lnWVVGakkyTkNZeUZoUUdJaVkwQVptMkNBUmVCQWhTQ1FuODhnbFlQbzBJQkY0RTVpb2RIU29kQVg2a2RuYWtkdkZTT3p0U093TWdDYllKQ2YyNkNRa0J1VDVZQ2JZSi90UWRLaDBkS2gxMnBIWjJwQkk3VWpzN1VnQUFBQUVBQUFESUF5QUNXQUFDQUFhekFnQUJMU3NSSVFFRElQNXdBbGorY0FBQUFRQUFBQUFCa0FNZ0FBSUFCck1CQUFFdEt3RVJBUUdRL25BRElQemdBWkFBQUFBQUFRQUFBQUFCa0FNZ0FBSUFCck1DQUFFdEt4RUpBUUdRL25BRElQNXcvbkFBQUFBQUFRQUFBTWdESUFKWUFBSUFCck1CQUFFdEt3a0JJUUdRQVpEODRBSlkvbkFBQUFBQUF3QUFBQUFESHdKWUFDRUFLUUF4QUFxM0xpb21JaElDQXkwckVUUTJPd1F5Rmg4QklUSVdEd0VPQVNNaElpWW5MZ0V2QVNNaUJpTWlKZ0F5RmhRR0lpWTBKRElXRkFZaUpqUWJFd01GQk1nTkdnVW1BYndLQ0FOUkF4VUwvcUlLRlFNT05nMEtsZ0VGQVJVZUFWRXFIUjBxSFFGSktoMGRLaDBDSmhJZ0VRdElEd3I2Q2c4UENpbW9LUmtCSHY1VEhTb2RIU29kSFNvZEhTb0FBZ0FBQUFBRElBSzhBQVlBQ3dBSXRRa0hCZ0FDTFNzUklSVWhFU01IQVNFUkp5RUI5UDdVWkdRQkxBSDBaUDV3QXJ4ay90UmtBU3orREdRQUFRQUFBRUlERUFLOEFBMEFCck1DQUFFdEt3RVhBUzRDTHdFM0ZoYytBZ0tCai80VElFbGFHRWlOUzA0bmpuUUN2STMrRXlKS1dSbEhqVXhLSjQ1MEFBRUFBQUF5QXlBQ1dBQUZBQWF6QkFBQkxTc1RGemNYQ1FHVyt2cVcvbkQrY0FKWSt2cVcvbkFCa0FBQUFRQUFBQUFDSmdNZ0FBVUFCck1FQUFFdEt3RVhCeGNIQVFHUWx2cjZsdjV3QXlDVyt2cVdBWkFBQUFBQkFBQUFBQUltQXlBQUJRQUdzd0lBQVMwckV3a0JKemNubGdHUS9uQ1crdm9ESVA1dy9uQ1crdm9BQUFFQUFBQXlBeUFDV0FBRkFBYXpBZ0FCTFNzSkFRY25CeWNCa0FHUWx2cjZsZ0pZL25DVyt2cVdBQUFBQWdBQUFBQURJQU1nQUFjQURRQUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVDVUhKd2NYQWVvQlRPcnEvclRxQWxqNlpFaXNBVUlESU9yK3RPcnFBVXc0K21SSXJBRkNBQUFBQWdBQUFBQURJQU1nQUFjQUV3QUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVEY0hGd2NYTnhjM0p6Y25CK29CVE9ycS9yVHEra2lXbGtpV2xraVdsa2lXQXlEcS9yVHE2Z0ZNT0VpV2xraVdsa2lXbGtpV0FBQUFBQUlBQUFBQUFyd0RJQUFSQUNVQUNMVWRFZ2tBQWkwckFESVdIUUV6TWhZZEFTRTFORFk3QVRVMEJUTVZJVFV6TWhZVkVSUUdJeUVpSmpVUk5EWUJTU29kU3dzTy90UU9DMHYrN1VzQjlFc0xEZzRML1hZTERnNERJQjBWTWc0TFMwc0xEaklWUjhqSURndjlkZ3NPRGdzQ2lnc09BQUFBQUFNQUFBQUFBeUFESUFBSEFBOEFHQUFLdHhVUURBZ0VBQU10S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFsTXhVV0Z3Y21Md0hyQVVycjYvNjI2d0lNK0xDdytMRCtvbVFpSmtna01CQURJT3YrdHV2ckFVcUhzUGl3c1BoTXRTUWhTQ2d3REFBQ0FBQUFBQU1nQXlBQUdRQXNBQWkxSmg0SkFBSXRLd0V5RmgwQkhnRVZGQWNqTlRRbUlnWWRBU0VtTlRRMk16NEJFenNCTWpZek1oWWRBak1ISnpNOUFUUTJBY0pva2lzNUNiOVlmRmorOEJ4MlVoR1BTZ01FQVFZQ0ZSMld5TWlXRkFNZ2ttZ3lFRlV4R2hneVBsaFlQakl4TTFKMlZuTCtjQUVkRlFHV3lNaVdBZzhkQUFBQUFnQUFBQUFESUFNZ0FCUUFId0FJdFJvVkNRQUNMU3NCTWhZZEFSNEJGUlFISXljSEl5WTFORFl6UGdFVEZ5TVZGQVlpSmowQkl3SENhSklyT1FtTnlNamVISFpTRVk5YStzZ2RLaDNJQXlDU2FESVFWVEVhR01qSU1UTlNkbFp5L2o3Nk1oVWRIUlV5QUFBQUFRQUFBR1FESUFLOEFCSUFCck1KQUFFdEt3RXlGaDBCSGdFVkZBWWpJU0ltTkRZelBnRUJ3bWlTS3psWVB2NCtVbloyVWhHUEFyeVNhRElRVlRFK1dIYWtkbFp5QUFBQUFnQUFBQUFESUFNZ0FBc0FIZ0FJdFJVTUJ3QUNMU3NUTWhjaUJnY0dCeVkxTkRZRk1oWWRBUjRCRlJRR0l5RWlKalEyTXo0QitudE5hckVxT2lvWmtnRXdhSklyT1ZnKy9qNVNkblpTRVk4RElHUnpYaEFmTkRab2tzaVNhRElRVlRFK1dIYWtkbFp5QUFBQUF3QUFBR1FESUFLOEFBTUFDUUFQQUFxM0RRb0hCQUlBQXkwckFUTUJJd016Qnhjakp5VXpGd2NqTndIMFpQN1VaR1JrWkdSa1pBSllaR1JrWkdRQ3ZQMm9BZlRJeU1qSXlNaklBQUlBQUFBQUF5QURJQUFmQUNjQUNMVWtJQkFBQWkwckFUTWZBVGNYQng4QkZROEJGd2NuRHdFakx3RUhKemN2QVRVL0FTYzNGemNXSWdZVUZqSTJOQUZlWkRJY2QwZ3lESGQzRERKSWR4d3laREljZDBneURIZDNEREpJZHh5aWZGaFlmRmdESUhjTU1raDNIREprTWh4M1NESU1kM2NNTWtoM0hESmtNaHgzU0RJTWcxaDhXRmg4QUFBQUF3QUFBQUFESUFNZ0FBTUFCZ0FLQUFxM0NRY0dCQUlBQXkwckVTRVZJUmNoQndVaEZTRURJUHpneUFHUXlQNXdBeUQ4NEFNZ3lHVEl5R1FBQXdBQUFBQURJQU1nQUFNQUJ3QUtBQXEzQ1FnR0JBSUFBeTByRVRNUkl3RXpFU01ERVNka1pBSll5TWhreUFNZy9PQURJUHpnQWxqK2NNZ0FBd0FBQUFBRElBTWdBQU1BQndBS0FBcTNDZ2dHQkFJQUF5MHJFVE1SSXdFekVTTUJGd2ZJeUFLOFpHVCtjTWpJQXlEODRBTWcvT0FDV01qSUFBQUFBQU1BQUFBQUF5QURJQUFEQUFZQUNnQUt0d2tIQlFRQ0FBTXRLeEVoRlNFRkZ5RUhJUlVoQXlEODRBR1F5UDV3eUFNZy9PQURJR1RJeUdUSUFBWUFBQUFBQXJ3Q3ZBQW5BREFBT1FBOUFFWUFUd0FSUUE1S1IwSStPem8xTVN3b0ZBQUdMU3NTTWhZZEFUTTFORFl5RmhRR0t3RVZNeklXRkFZaUpqMEJJeFVVQmlJbU5EWTdBVFVqSWlZMEZpSUdGQlk3QVRVMEpDSUdIUUV6TWpZMEJSVXpOUWNpQmhRV01qWTlBU0VWRkJZeU5qUW1JMWg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHhZV0Q0eU1qNVlxeW9kSFJVeUFYTXFIVElWSGY3VVpQb1ZIUjBxSFFFc0hTb2RIUlVDdkZnK01qSStXRmg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHdNSFNvZE1oVWRIUlV5SFNxclpHVElIU29kSFJVeU1oVWRIU29kQUFBQkFBQUFBQU1nQXlBQUNnQUdzd1lCQVMwckVUUXpJVElWRVNjaElqVUpBdzRKeVAyeENRTVhDUXI4NnNnSkFBQUVBQUFBQUFNZ0F5QUFCd0FQQUJNQUd3QU5RQW9ZRkJJUURBZ0VBQVF0S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFuQXdVVEZpSUdGQll5TmpUckFVcnI2LzYyNndJTStMQ3crTEJrWlA3VVpIa3FIUjBxSFFNZzYvNjI2K3NCU29ldytMQ3crRXorMUdRQkxESWRLaDBkS2dBQUFBSUFBQUFBQXlBRElBQUhBQTBBQ0xVSkNBUUFBaTByRWlBV0VBWWdKaEFsRVRJMk5DYnJBVXJyNi82MjZ3R1FmTEN3QXlEci9yYnI2d0ZLaC8yb3NQaXdBQUFBQlFBQUFBQURJQU1nQUFNQUJ3QUxBQThBRndBUFFBd1VFQTRNQ2dnR0JBSUFCUzByRVNFVklSVWhGU0VWSVJVaEZTRVZJU1F5RmhRR0lpWTBBeUQ4NEFIMC9nd0RJUHpnQWxqOXFBTFpLaDBkS2gwRElHUmtaTWhrWkdSa0hTb2RIU29BQUFRQUFBQmtBeUFDdkFBSkFCTUFGd0FiQUExQUNoa1lGUlFPQ2dVQUJDMHJFeUV5RmgwQklUVTBOZ2NoRVJRR0l5RWlKalUzRlRNMU14VXpOUmtDN2dzTy9PQU9EZ01nRGd2OUVnc09aR1JrWkFLOERndExTd3NPeVA2SkN3NE9DNjlrWkdSa0FBQUFBd0FBQUFBRElBTWdBQklBRlFBWUFBcTNGeFlVRXdzQUF5MHJFek1WSVRjWEJ4RXpGU01WSXpVaEVTTTFNeGNSQVJjQklXUmtBY0prTW1Sa1pHVCtER1JrWkFGZU12NmlBVjRESUdSa01tVCtQbVJrWkFIMFpHVCtvZ0ZlTXY2aUFBQUFBQVVBQUFBQUF5QURJQUFIQUE4QUZ3QXNBRFFBRDBBTU1TMG1HeFFRREFnRUFBVXRLeElnRmhBR0lDWVFKQ0lHRkJZeU5qUWtNaFlVQmlJbU5BYzBOamM3QWpJZkFUY3lGaFFHSWlZMU55Y21KRElXRkFZaUpqVHJBVXJyNi82MjZ3SU0rTEN3K0xEK3Z5b2RIU29kbGhRT0F3TUlGZzViR1NrN08xSTdCbG9RQVVrcUhSMHFIUU1nNi82MjYrc0JTb2V3K0xDdytFd2RLaDBkS25jUEhRUVFXZ1k3VWpzN0tSbGJEa1lkS2gwZEtnQUFBQUlBQUFBQUF5QURJQUFHQUFvQUNMVUpCd1FBQWkwckFUTVJNd2tCTXdFaEZTRUJMTWpJL3RUKzFNaisxQU1nL09BRElQN1UvdFFCTFA1d1pBQUFBQUFDQUFBQUFBTWdBeUFBQXdBS0FBaTFCd1FDQUFJdEt4RWhGU0VGQVNNUkl4RWpBeUQ4NEFHUUFTekl5TWdESUdSay90VCsxQUVzQUFJQUFBQmtBeUFDdkFBRUFCQUFDTFVKQlFJQUFpMHJFeUVSSVFNbEJ4Y0hGemNYTnljM0p3ZklBbGo5cU1nQlhraVdsa2lXbGtpV2xraVdBcno5cUFFczNraVdsa2lXbGtpV2xraVdBQUFBQWdBQUFHUURJQUs4QUFzQUdBQUl0Uk1NQXdBQ0xTc1NJQllWSXpRbUlnWVZJelFsRnpjZUFSVVVCaUltTlRRMjZ3Rks2MlN3K0xCa0FWVTdPejVQZHFSMlR3Szg2NlY4c0xCOHBScFlXQk5wUTFKMmRsSkRhUUFBQUFBRkFBQUFBQUs4QXlBQUJRQUlBQXdBRUFBVUFBOUFEQklSRGcwS0NRY0dCQUFGTFNzUklSRWhFU0VKQVNFbEZUTTFCeFV6TlFjVklUVUJMQUdRL1VRQmtBRXMvdFQrMUdSa1pHUUJrQU1nL25EK2NBTWcvdFJrWkdUSVpHVElaR1FBQUFBQUFRQUEvNXdCOUFLOEFEc0FCck1lQUFFdEt4TXpGVE15RnhZZEFTTTFKaXNCSWdZZEFSUVdGd1VlQVIwQkZBWXJBUlVqTlNNaUp5WTlBVE1WRmpzQk1qWTlBVFFtSnlVdUFUMEJORFk3QWNoa1N6RWdMR1FJRWZvTERoY0xBUUV4UEVvelMyUkxNU0FzWkFnUitnc09Gd3YrL3pFOFNqTkxBcnhrRmg4dlpGNEdEZ3N5Q3g0RFFReE9Nekl6U21Sa0ZoOHZaRjRHRGdzeUN4NERRUXhPTXpJelNnQUNBQUFBWkFNZ0Fyd0FBd0FIQUFpMUJ3UURBQUl0S3hFaEVRa0JJUkVCQVN6KzFBSDBBU3orMUFLOC90VCsxQUpZL3RUKzFBQUFBQUlBQUFCa0F5QUN2QUFEQUFjQUNMVUZCQUVBQWkwckFSRWhFUUVSSVJFQkxQN1VBeUQrMUFLOC9hZ0JMQUVzL2FnQkxBQUNBQUFBWkFNZ0Fyd0FDZ0FWQUFpMUVRc0dBQUl0S3dFVklnWVZNeEVoRVRRMklSVWlCaFV6RVNFUk5EWUJMRk4xeVA3VXNBSndVM1hJL3RTd0FyeGtkVlArMUFFc2ZMQmtkVlArMUFFc2ZMQUFBQUFDQUFBQVpBTWdBcndBQ2dBVkFBaTFEd3NFQUFJdEt4RWhFUlFHSXpVeU5qVWpBU0VSRkFZak5USTJOU01CTExCOFUzWElBZlFCTExCOFUzWElBcnorMUh5d1pIVlRBU3orMUh5d1pIVlRBQUlBQVAvcUFsZ0RJQUFTQUNJQUNMVVlFd2tBQWkwckFSY2VCQlVVQmlJbU5UUStBemNDSWdZVkZCWXpNalkwSmlNaUpqVTBBU3dpRFNoWlJUZXcrTEEzUlZrb0RWOHFIWFpTRlIwZEZTazdBeUFpRFN0eWI1STlmTEN3ZkQyU2IzSXJEZjVLSFJWU2RoMHFIVHNwRlFBQ0FBQUFBQU1nQXlBQUFnQUdBQWkxQlFNQkFBSXRLd2tCSVJVaEZTRUJrQUdRL09BRElQemdBeUQrREdUSUFBQUNBQUFBQUFKWUF5QUFBZ0FGQUFpMUJRTUJBQUl0S3drQklSVWhBUUVzQVN6OXFBSlkvdFFESVA3VXlQN1VBQUFEQUFBQkxBTWdBZlFBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSUFmVEl5TWpJeUFBQUFBQUNBQUFBWkFNZ0Fyd0FCQUFKQUFpMUNBVURBQUl0S3hFaEZRVWxGUVVsRVNFRElQNXcvbkFCa0FHUS9PQUN2R1RJeUdUSXlQNXdBQU1BQUFBQUF5QURJQUFFQUFvQUR3QUt0dzRMQ0FVQ0FBTXRLd0VGRVNFUkpRVVZCU1UxQlNFVkJ5Y0JrQUdRL09BQmtQN1VBU3dCTFA0TUFaREl5QU1neVAyb0FsaFlscnlXbHJ3bVpHUmtBQUFBQUFFQUFQK2NBeUFDdkFBakFBYXpGUUFCTFNzQk1oY0hKaUlHQnlFSElSUVhJUWNqRmpNeU54VUdJeUltSnlFM015WTFJemN6UGdFQ1dHTmNFRTdDbVI4QlN4RCtzaE1CS1JEZVdvUnlWbDVxYkxZMi93QVR4UkRJR2I4aTFBSzhNbW80YjFsa0xUZGtaRTU2T0cxYlpFQWtaSU9wQUFBQUFBWUFBQUFBQXlBQ3ZBQURBQWNBQ3dBUEFCTUFGd0FSUUE0V0ZCSVFEZ3dLQ0FZRUFnQUdMU3NSSVJVaEZTRVZJUlVoRlNFVk14VWpOek1WSXpjekZTTUN2UDFFQWZUK0RBTWcvT0JrWk1oa1pNaGtaQUs4WkdSa1pHUmtaR1JrWkdRQUFBQURBQUFBQUFNZ0F5QUFBd0FHQUFvQUNyY0pCd1lFQWdBRExTc1JJUlVoRnlFSEJTRVZJUU1nL09ESUFaREkvbkFESVB6Z0F5QmtaTWpJeUFBREFBQUFBQU1nQXlBQUF3QUhBQW9BQ3JjS0NBWUVBZ0FETFNzUk14RWpBVE1SSXdFWEIyUmtBbGpJeVA1d3lNZ0RJUHpnQXlEODRBSll5TWdBQUFBQUF3QUFBQUFESUFNZ0FBTUFCd0FLQUFxM0NRZ0dCQUlBQXkwckVUTVJJd0V6RVNNREVTZkl5QUs4WkdSa3lBTWcvT0FESVB6Z0FsaitjTWdBQXdBQUFBQURJQU1nQUFNQUJnQUtBQXEzQ1FjRkJBSUFBeTByRVNFVklRVVhJUWNoRlNFRElQemdBWkRJL25ESUF5RDg0QU1neU1qSVpHUUFBZ0FBQUFBRElBTWdBQWtBRUFBSXRRNEtDQUFDTFNzUk14VWpFU0UxTXhVaEFTRVJKd2NuTjhoa0FsaGsvT0FCa0FHUWx2cGsrZ01nWlAyb1pNZ0RJUDV3bHZwaytnQUFBd0FBQUdRRElBSzhBQnNBSXdBMUFBcTNNU1FnSEEwQUF5MHJBVEllQkI4QkRnUWpJaTRDTHdFK0JoWWlCaFFXTWpZMEp6SVhCaFVVRmpNeU54WVZGQVlpSmpRMkFaTXlZMHhGTVNRSkNRWVhUMWFHUlVlSFhFY1JFUU1NS1M1SVRXU0RwSFoycEhiSUNoSWNIUlVlRGdZN1VqczdBcndoTlVCQU5SRVFEQ2xuVDBFK1dGZ2ZId1lXUGpsRk1pSmtkcVIyZHFRU0JnNGVGUjBjRWdvcE96dFNPd0FDQUFEL25BTWlBcjBBSVFBbEFBaTFKQ0laQXdJdEt3RTdBVFl6TWg4Qk56WXlGeFlVRHdFWEZoVVVCaU1pTHdFQklSRUJKeVkxTkRZWEFSY0JBVXNEQXdNSEZnOWVRaXQrS3l3c1FWMFNIUlVaRHo3K2cvN3pBWGMvRUJXQy9zZUFBVHdDdkFFUlhVRXJLeXg4TEVKZURoZ1ZIUlJCL29NQkVBRjlQdzRXRHgzWC9zV0VBVHdBQWdBQUFBQUN2QU1nQUFVQUNBQUl0UWNHQkFBQ0xTc1JJUkVoRVNFSkFTRUJMQUdRL1VRQmtBRXMvdFFESVA1dy9uQURJUDdVQUFBQ0FBQUFBQUs4QXlBQUdnQXNBQWkxSXhzTkFBSXRLeE1lQkJVVURnUVhMZ1ExTkQ0RU5BRWVCQlVVQmlNaE5ENEVOTWdJRzBVMUt5czlRUzBMR1FnYlJUVXJJVEU1TVNBQkdBZ2JSVFVyUHlYKzFDRXhPVEVnQXlBRUVEaEFhRGd1WFVkU1Jsd3VCQkE0UUdnNEtGQkFRa0ZDVHY3OUJCQTRRR2c0Wm1Jb1VFQkNRVUpPQUFBQUFnQUFBQUFESUFNZ0FBTUFEQUFJdFFrRUFnQUNMU3NSTXhFakV5RVZJUWNYSVRValpHVElBU3dCTE1qSS9uRElBeUQ4NEFNZ1pNdkZaQUFBQVFBQUFBQUJrQU1nQUFvQUJyTUdBQUV0S3hNekJ6TURNd0VETXpjamxwWmt5SmFXL3RSa2hrTElBeURJL3RUKzFBRXN5QUFBQUFBQ0FBQUFBQU1nQXlBQUJRQVBBQWkxQ2dZRUFBSXRLeEVoRlNFVklSVWhFUlFHSXlFaUpqVUJMQUgwL09BRElCMFYvVVFWSFFNZ1pHUmsvajRWSFIwVkFBQUFBQUVBQUFBQUFyd0RJQUF3QUFhekpRQUJMU3NTTWhZVkZBWUhGVFk3QVRJMlBRRXVBVFUwTmpJV0ZSUUdCeFVVQmlzQklnY2VBUlVVQmlJbU5UUTJOelV1QVRVMFdIeFlOeTBiRjhnVkhTMDNXSHhZTnkxWVBzZ1NFQ1l1V0h4WU55MHROd01nV0Q0eFRROTJDUjBWT3c5Tk1UNVlXRDR4VFE4N1BsZ1FFa2dzUGxoWVBqRk5EOW9QVFRFK0FBQUFBQUlBQUFBQUF5QURJQUFHQUEwQUNMVUtCd1FBQWkwckVTRUhGd2NuQnlFWE54RWhOeWNCa0phV1pKYVdBZlNXbHY1d2xwWURJSmFXWkphV2xwYitjSmFXQUFBQUFnQUFBQUFESUFNZ0FBWUFEUUFJdFFzSEF3QUNMU3NURnpjUklUY25BU0VIRndjbkIyU1dsdjV3bHBZQmtBR1FscFprbHBZRElKYVcvbkNXbHY3VWxwWmtscFlBQUFBQUF3QUFBQUFESUFNZ0FBY0FSZ0JWQUFxM1VVY25DQVFBQXkwckVpQVdFQVlnSmhBbElnY1hGZ1lIQmlJR0Z4WUdMZ0VIQmg0QkJ5Y2lCeFlYSGdFWEhnRUhGak15TmpjMkppTWlMZ0kzUGdNbkpqNEJOVFFtSnlZK0F6Y21GdzRCRnhZMkZ4NERQd0UxSnVvQlRPcnEvclRxQVpCUVNSWVdEUllLS3hFRkJnb09Gd1lUR1NBSE93b0dBUklKVGcwbE5oQTZNRXVES1FJWEhSNHdNUnNCQVI4ZUVRME5CUlJFQVFFREN3WVRBem5DSXprRkF6WUlBd2tIRUFrV0VBTWc2djYwNnVvQlRJWXNFdzhqQ1FRT0Z4UUlDUWdFRWtOR0FTSUtIallEQ1EwV2FTQVdRem9VR0FjVEtSNFBMQ0VvQ3hJTkdRb1ZGd1lGQ3cwSEVnSVRiUW9mREFnQkJnTVVEUVlMRmdNbUFBQUNBQUFBQUFNZ0F5QUFCd0FMQUFpMUNnZ0VBQUl0S3dFWEFTY0hKd0VYQVNFVklRSy9ZZjV3Wk1oa0FTeGsvbkFESVB6Z0F5QmsvbkJreTJRQkwyVCtjR1FBQUJBQUFBQUFBcndDdkFBREFBY0FDd0FQQUJNQUZ3QWJBQjhBSXdBbkFDc0FMd0F6QURjQU93QS9BQ1ZBSWo0OE9qZzJOREl3TGl3cUtDWWtJaUFlSEJvWUZoUVNFQTRNQ2dnR0JBSUFFQzByRVRNVkl6Y3pGU00zTXhVak56TVZJd1V6RlNNM014VWpOek1WSXpjekZTTUZNeFVqTnpNVkl6Y3pGU00zTXhVakJUTVZJemN6RlNNM014VWpOek1WSTJSa3lHUmt5R1JreUdSay9haGtaTWhrWk1oa1pNaGtaUDJvWkdUSVpHVElaR1RJWkdUOXFHUmt5R1JreUdSa3lHUmtBcnhrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa0FBa0FBQUFBQXlBRElBQURBQWNBQ3dBUEFCTUFGd0FiQUI4QUl3QVhRQlFpSUI0Y0doZ1dGQklRRGd3S0NBWUVBZ0FKTFNzUk14VWpKVE1WSXlVekZTTUZNeFVqSlRNVkl5VXpGU01GTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSS9hakl5QUVzeU1nQkxNakkvYWpJeUFFc3lNZ0JMTWpJQXlESXlNakl5R1RJeU1qSXlHVEl5TWpJeUFBQUFBUUFBQUFBQXlBRElBQURBQWNBQ3dBUEFBMUFDZzRNQ2dnR0JBSUFCQzByRVNFUklRRWhFU0VGSVJFaEFTRVJJUUVzL3RRQjlBRXMvdFQrREFFcy90UUI5QUVzL3RRRElQN1VBU3orMU1qKzFBRXMvdFFBQUFBREFBQUFBQUs4QXlBQURRQVpBQ0VBQ3JjZUdoVU9CZ0FETFNzVElUSVZFUlFHSXlFaUpqVVJOQkVXTXlFeU54RVVJeUVpTlNRaUJoUVdNalkwRXdLV0V4MFYvYWdWSFJnYUFsZ2FHQlA5YWhNQ095b2RIU29kQXlBVC9yVVZIUjBWQVVzVC9oVUpDZjdlRXhPMUhTb2RIU29BQUFFQUFBQUFBcndDdkFBekFBYXpHZ0FCTFNzUklSVWpJZ1lkQVNFMU5DWXJBVFVoRlNNaUJoVVJGQlk3QVJVaE5UTXlOajBCSVJVVUZqc0JGU0UxTXpJMk5SRTBKaXNCQVN3eUZSMEJMQjBWTWdFc01oVWRIUlV5L3RReUZSMysxQjBWTXY3VU1oVWRIUlV5QXJ4a0hSV1dsaFVkWkdRZEZmNXdGUjFrWkIwVmxwWVZIV1JrSFJVQmtCVWRBQUFBQUFFQUFBQUFBeUFDdkFBbEFBYXpDd0FCTFNzQU1oWWRBVE15RmgwQkZBWXJBU0ltTlJFMEppSUdGUkVVQmlzQklpWTlBVFEyT3dFMU5BRVUrTEF5RlIwZEZXUVZIWFdtZFIwVlpCVWRIUlV5QXJ5d2ZHUWRGY2dWSFIwVkFWNVRkWFZUL3FJVkhSMFZ5QlVkWkh3QUFBQUJBQUFBRXdNZ0Fyd0FEUUFHc3d3Q0FTMHJFRFEyTWhZVk5EWXlGaFFIQ1FGMnBIWjJwSFk3L3F2K3F3R2lwSFoyVWxKMmRxUTcvcXdCVkFBQkFBQUFBQU1nQXJ3QUNnQUdzd01BQVMwckNRRW5FU00xSXhVakVTTUJrQUdRWk1qSXlHUUN2UDdVQS81dHlNZ0JrQUFBQWdBQUFBQURJQU1nQUFNQURRQUl0UWNFQWdBQ0xTc1JJUkVoRXhFM0FUTTFKemNYRVFNZy9PQmtaQUdRWk1oa1pBTWcvT0FDdlA3VVpQNXdaTWhrWkFFc0FBQUNBQUFBQUFNZ0F5QUFDd0FUQUFpMUR3d0ZBQUl0S3hNaE1oVVJGQ01oSWpVUk5CY1JNeGN6TnpNUkV3TDZFeFA5QmhOa1pHVElaR1FESUJQOUJoTVRBdm9UeVA3VVpHUUJMQUFBQXdBQUFNZ0RJQUpZQUJVQUlBQXJBQXEzSmlFYUZnb0FBeTByRXpJV0Z6NEJNeklXRkFZaklpWW5EZ0VqSWlZME5oY2lCaFFXTXpJMk55NEJJU0lHQng0Qk16STJOQ2JJTjE0ek0xNDNYV3RyWFRkZU16TmZObDFyYTEwek1URXpIVDhxS2o4QmN4MC9LaW8vSFRNeE1RSllRRG82UUhpZ2VFQTZPa0I0b0hoa1BGQThOREF3TkRRd01EUThVRHdBQWdBQUFBQUJrQU1nQUFjQUpRQUl0UllJQkFBQ0xTc0FNaFlVQmlJbU5BWXlGaFVVQmhVVUZqSTJOVE1VQmlNaUpqVTBQZ0UxTkNZaUJoVWpOQUVEVWpzN1VqdHdmRmhrSFNvZFpGZytQMWN5TWgwcUhXUURJRHRTT3p0U3YxazlKY2NPRlIwZEZUNVlWa0FsY1ZvS0ZSMGRGVDRBQUFBQUFRQUFBQUFDdkFNZ0FCQUFCck1IQUFFdEt4TWhGU01EQnpNVklUVXpQZ0kvQVNQSUFmUjY2Z2FpL2d4NklrNWdHZ2VqQXlCay9iUU1aR1JZeE85QkRBQUFBQUFFQUFBQUFBTWdBcndBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt4RWhGU0VWSVJVaEZTRVZJUmNoRlNFRElQemdBeUQ4NEFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUJBQUFBQUFESUFLOEFBTUFCd0FMQUE4QURVQUtEZ3dLQ0FZRUFnQUVMU3NSSVJVaEZTRVZJUlVoRlNFVklSVWhBeUQ4NEFNZy9PQURJUHpnQWxqOXFBSzhaR1JrWkdSa1pBQUFBQVFBQUFBQUF5QUN2QUFEQUFjQUN3QVBBQTFBQ2c0TUNnZ0dCQUlBQkMwckVTRVZJUlVoRlNFVklSVWhGeUVWSVFNZy9PQURJUHpnQXlEODRNZ0NXUDJvQXJ4a1pHUmtaR1JrQUFBQ0FBQUFBQU1nQXlBQUVRQVpBQWkxRmhJTEFBSXRLd0F5RmhRR0l5SW5CeFVqRlNFMUFTWTFOQ1FpQmhRV01qWTBBYjdRa3BKb0lBOER5UDdVQVM4REFWVlNPenRTT3dNZ2t0Q1NBd05reU1nQkx3OGdhQzQ3VWpzN1VnQUFBQUFDQUFBQUFBTWdBbGdBR0FBZ0FBaTFIQmtOQUFJdEt4TTdBeUV5RmhVUk14VVVCaU1oSWlZOUFUTVJOVFEyRnhFekZUTTFNeEdHQXdRRUJRSDBGUjFrSFJYOVJCVWRaQlJRWk1oa0FsZ2RGZjZpbGhVZEhSV1dBVjRDRHgxZy90UmtaQUVzQUFBQUFBTUFBQUFBQXlBRElBQURBQWtBRHdBS3R3d0tCZ1FDQUFNdEt4RWhFU0VsTXhFaE5TRTNNeEVoTlNFQmtQNXdBZlJrL25BQkxNaGsvbkFCTEFNZy9uREkvbkJrWlA1d1pBQUFBQUFFQUFEL213SDhBcjBBRVFBakFEMEFVQUFOUUFwTlFESWxIQk1LQVFRdEt3RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0R3RWVBUlVVQmlNaUppc0JMZ0UxTkRZM0Z6UTJPd1F5RmhRR0t3RWlCaU1pSmdGUkNnc1ZIUkFML3RRUEVCVWRGZzhCa0FzS0ZSMFFDLzV3RHhBVkhSWVBBWkFMQ2hVZEVBdHFFaGtlRlFFR0FjZ1RIUThMRGhzVEF3UUZaQlVkSFJWa0FRWUJGUjBDdGdjZEZRMGFCcFlMSFJVUUhRUUhIUlVOR2diSUN4MFZFQjBFQngwVkRSb0dPQU1kRWhVZUFRRWRGQXdhQnZRU0lCMHFIUUVlQUFRQUFBQUFBeDRESUFBRkFDY0FTZ0JRQUExQUNrOUxSUzBRQ0FJQUJDMHJFek1WSXpVekpUTTJGeFlYRmhRUEFRWWpJaVkxTkQ4Qk5pWW5KZ1lQQVFZaklpWTFORDhCTmdFMk93RXlOak15RmhRUEFRWVdGeFkyUHdFMk16SVdGUlFQQVFZSEJpWW5KalEzQlRNVkl4VWp4MlRJWkFHREFTSVdOeW82T3BZUEhCVWRHSlllQVIwZ1ZSc3NEeHNWSFJnck12N1VEUWtEQVFZQkZSME9saDRCSFNCVkd5d1BHeFVkR0NzZkxEUnlLVG82QWJuSVpHUURJTWhrWVFJRkRDbzZwRHVXR0IwVkhBK1dIbFVkSGdNYkxCZ2RGUndQTERUKzBSQUJIU29PbGg1VkhSNERHeXdZSFJVY0R5d2ZFQk1aS1R1a09veGtaQUFBQUFJQUFBQUZBeDRESFFBckFGUUFDTFZVVFFrQkFpMHJBVFlYRmhjV0ZBOEJCaWN1QlNNbU5UUTJNeklYRmhjV1B3RTJKaWNtQmdjR0l5SW1OVFEzTmdjZUFoY2VBUlVVQmlNaUp5WW5KZzhCQmhZWEZqWTNOak15RmhVVUJ3WUhCaVluSmpRL0FUWUNTaU1XTnlvNk9wWlVZZ3dXRFJFRkRnRWFIUlVPREE4YU56T1dIZ0VkSUZVYkR4d1ZIUmd5ZWhZZ0dBY1BGaDBWRUE4VEhEa3VsaDRCSFNCVkd3OGJGUjBYSHl3MGNpazZPcFpRQXgwQ0JRd3FPcVE3bGxRR0FRTURCd01JRGg0VkhnY0xBZ1F6bGg1VkhSNERHeGdkRlJ3UE5PTUJDQXNDQkIwUUZSMExDUUVDTHBZZVZSMGVBeHNZSFJVZERoOFFFeGtwTzZRNmxsQUFBQUFBQmdBQUFBQURJQUs4QUFNQUJ3QUxBQThBRXdBWEFCRkFEaFlVRWhBT0RBb0lCZ1FDQUFZdEt4RWhFU0VCSVJVaEZTRVZJUVVoRVNFQklSVWhGU0VWSVFFcy90UUJrQUdRL25BQkxQN1UvbkFCTFA3VUFaQUJrUDV3QVN6KzFBSzgvdFFCTEdSa1pHVCsxQUVzWkdSa0FBZ0FBQUFBQXlBQ3ZBQUhBQXNBRXdBWEFCOEFJd0FyQUM4QUZVQVNMaXdvSkNJZ0hCZ1dGQkFNQ2dnRUFBZ3RLeEl5RmhRR0lpWTBOeUVWSVFZeUZoUUdJaVkwTnlFVklRWXlGaFFHSWlZME55RVZJUVl5RmhRR0lpWTBOeUVWSVIwcUhSMHFIY2dDV1Ayb3F5b2RIU29keUFKWS9haXJLaDBkS2gzSUFsajlxS3NxSFIwcUhjZ0NXUDJvQXJ3ZEtoMGRLaDFrWkIwcUhSMHFIV1JrSFNvZEhTb2RaR1FkS2gwZEtoMWtBQUFBQVFBQUFBQURJQU1nQUFNQUJyTUJBQUV0S3drQkF5VURJUDV3WlA3VUF5RDg0QUVzWkFBQUFBSUFBQUFBQWxnQ3ZBQUxBQk1BQ0xVUURBWUFBaTByRWpJV0hRRXpFU0VSTXpVME5pSUdIUUV6TlRUYXBIWmsvYWhrOGxRNnlBSzhkbEprL25BQmtHUlNFam9xWkdRcUFBRUFBQUFBQWxnRElBQVJBQWF6QmdBQkxTc1NNaFlkQVRNUklSRWhOVFFtSWdZVkl6VGFwSFprL2FnQmtEcFVPbVFESUhaU3lQNXdBWkRJS2pvNktsSUFBQUFBQWdBQUFHUURJQUs4QUFvQUZRQUl0UThMQmdBQ0xTc0JGU0lHRlRNSEp6TTBOZ1VYSXhRR0l6VXlOalVqQVpCVGRXU1dsbVN3QVhhV1pMQjhVM1ZrQXJ4a2RWUEl5SHl3Wk1oOHNHUjFVd0FDQUFBQUFBTWdBeUFBQ2dBVkFBaTFFZ3NFQUFJdEt4TWhFVE1ISnpNMUlSVWpId0VqRlNFMU14VWhFU05rQWxoa2xwWmsvbkJrTXBaa0FaQmsvYWhrQXlEKzFQcjZ5R1F5K3Noa3lBRXNBQUlBQUFBQUF5QUN2QUFMQUJjQUNMVVdEQUlBQWkwckFSY0hOU0VWSXpVME5qTWhBUlVoTlRNVkZBWWpJUlVuQWxqSXlQNE1aRHNwQWZUK2NBSDBaRHNwL2d6SUFyeVdsbVJrWkNrNy90UmtaR1FwTzJTV0FBQUNBQUQvL2dNaUF5QUFHUUFqQUFpMUh4b05BQUl0S3hJZ0ZoVVVCeFlmQVI0QkZSUUdJeUltTHdFbUp3WWpJaVlRQVRJMk5UUW1JZ1lVRnMwQklzMHNDZ1prREJJOEtoRXJER1FGQjAxWmtjMEJYbXFRa3RDU2tnTWd6WkZXVUFZR1pBd3JFU284RWd4a0JBa3B6UUVpL25XUWFtaVNrdENTQUFBQUFnQUFBQUFDV0FNZ0FCQUFHQUFJdFJVUkNRQUNMU3NTTWhZVkZBNENEd0V1QkRVMEpDSUdGQll5TmpTdytMQStXRmdmSHd3cFowOUJBWDZrZG5ha2RnTWdzSHc0a0g1dUlDQU1LMzExa3poOFRIYWtkbmFrQUFRQUFBQUFBeUVESUFBSUFCY0FKZ0F1QUExQUNpc25IeGdSRHdjQUJDMHJFU0VSRmhVVUJ4VWhKVFEyT3dJUklSRWhOU3NCSWlZQ01oWVZGQVlQQVM0RU5UUVdJZ1lVRmpJMk5BTWdBUUg4NEFIdkhSVUZsdjJvQWxpV0JSVWR6M3hZU3lVbUJoUTBLQ0NyS2gwZEtoMERJUDNqQXdnSEErNzZGQjRCa1Ayb1pCMEJjMWcrTEgwcEtBWVdQanBLSEQ0TUhTb2RIU29BQWdBQUFHUUNXQUs4QUFNQUJ3QUl0UVlFQWdBQ0xTc1JNeEVqQVRNUkk4aklBWkRJeUFLOC9hZ0NXUDJvQUFBQUFRQUFBR1FDV0FLOEFBSUFCck1DQUFFdEt4RUpBUUpZL2FnQ3ZQN1UvdFFBQUFBQUFRQUFBR1FDV0FLOEFBY0FCck1FQUFFdEt4SXlGaFFHSWlZMHNQaXdzUGl3QXJ5dytMQ3crQUFBQUFBQ0FBQUFaQU1nQXJ3QUFnQUZBQWkxQlFRQkFBSXRLd0VSQVNFQkVRR1EvbkFCa0FHUUFyejlxQUVzQVN6OXFBQUNBQUFBWkFNZ0Fyd0FBZ0FGQUFpMUJBTUNBQUl0S3hFSkFTRVJBUUdRL25BQmtBR1FBcnorMVA3VUFsaisxQUFDQUFBQVpBSzhBcndBQXdBR0FBaTFCZ1VDQUFJdEt4RXpFU01UQVJISXlNZ0I5QUs4L2FnQkxBRXMvYWdBQUFBQ0FBQUFaQUs4QXJ3QUFnQUdBQWkxQkFNQ0FBSXRLeEVKQVNFUk14RUI5UDRNQWZUSUFyeisxUDdVQWxqOXFBQUJBQUFBWkFKWUFyd0FBd0FHc3dJQUFTMHJFU0VSSVFKWS9hZ0N2UDJvQUFFQUFBQUFBeUFESUFBTEFBYXpCZ0FCTFNzVElSVXpFU01WSVRVakVUUElBWkRJeVA1d3lNZ0RJTWorY01qSUFaQUFBQUFEQUFBQUF3TWdBcndBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSSVJVaEZTRVZJUlVoRlNFRElQemdBeUQ4NEFNZy9PQUN2R1RGWk1oa0FBQUNBQUQvbkFKWUFzQUFFQUE4QUFpMUx4VUpBUUl0S3dFMk16SVdIUUlVQmlJbVBRSTBOZ2M3QVRJMk16SVdIUUlVRmpJMlBRRTBOaklXSFFFVUJnY1ZNeklXRlNFME5qc0JOUzRCUFFJME5nRVdEZ2dwT3p0U095N1VCQU1CQmdJVkhYV21kUjBxSFk5ck1pazcvbkE3S1RKcmp4UUN2QVE3S1FUSUtUczdLY2dDSVRyQkFSMFZBVEpUZFhWVE1oVWRIUlV5YnFZU2Fqc3BLVHRxRXFadU1nSVBIUUFBQUFBQkFBQUJMQU1nQWZRQUF3QUdzd0lBQVMwckVTRVZJUU1nL09BQjlNZ0FBQUlBQVArY0F5QUN2QUFnQUNRQUNMVWlJUklBQWkwckV6c0RJVElXRlJFVUJpc0JGVE15RmhVaE5EWTdBVFVqSWlZMUVUVTBOaGNSSVJFaUJBTUVCUUs4RlIwZEZmcGtLVHY5cURzcFpQb1ZIUlJRQWxnQ3ZCMFYvZ3dWSFdRN0tTazdaQjBWQWZRQ0R4MWcvbkFCa0FBQkFBRC9zZ01LQXJ3QUR3QUdzd2tBQVMwckFRWVZGQll6TWpjT0FTTWlKalUwTmdFUUZ1cW1RVDhvMElLbTZwZ0N2RDlCcHVvV2VKanFwb0xRQUFBQUFRQUFBQUFDdkFLOEFCY0FCck1NQUFFdEt3RVhJeFV6TlJjSE5TTVZNd2NuTXpVakZTYzNGVE0xSXdGZWxtU1dscGFXWkphV1pKYVdscFprQXJ5V2xtU1dsbVNXbHBhV1pKYVdaSllBQUFBQkFBQUFBQU1nQXlBQUhRQUdzeEFBQVMwckFSRVVCaUltTkRZek1oYzFCQWNSRkFZaUpqUTJNeklYRVQ0RUF5QllmRmhZUGhjYi92V0ZXSHhZV0Q0WEd3UVVXSGprQXlEOTJqNVlXSHhZQ2M0SUt2NXpQbGhZZkZnSkFaa0VEaUlhRmdBQUFRQUEvNTBDdWdLOEFDd0FCck1uQUFFdEt3QXlGeFlVRHdFR0lpWTBQd0VYRHdFR0ZCWXlQd0UrQVNjdUFRY0JEZ0VYRmpJL0FoY0hCaUltTkRjQkFhR2tPem82K2lSblNDUmdSVm9IQnc0WUIvb2NBUjBkVlI3KzZqSUJNelNTTkFsMFJYMVE1S0JRQVJZQ3ZEczdwRHIwSkVobkpHRkZYZ01JRmhBSTl4NVJIaDBCSHY3dE5KQXpORFFNY1VWOVVLRGtVQUVRQUFBQ0FBQUFBQU1nQXlBQUF3QUlBQWkxQmdRQ0FBSXRLd0VYQnljSEZ3RWpOUUpZeUdUSVpNaitjTWdESU1oa3lHVEkvbkRJQUFBQUFBUUFBQUFBQXlBRElBQU1BQlFBSGdBcUFBMUFDaVlmR1JVUkRRUUFCQzByQVRJV0ZBWWpJaWMyTlRRbk5nUXlGaFFHSWlZMEJSNEJIUUVqTlRRbk5nVVdNamNlQVIwQklUVTBOZ0ltUGxoWVBob2hDVWd1L3VKOFdGaDhXQUp4SWluSUxHWDl1a2ZRUnlJcC9nd3BBeUIxcG5VVEp5cCtWbGhrZGFaMWRhYkhFVDhtcGtKSVBnTVRWRlFSUHlhbXBpWS9BQUFDQUFBQUFBTWdBeUFBQndBVEFBaTFEd2dFQUFJdEt3QXlGaFFHSWlZMEF4WXlOeDRCSFFFaE5UUTJBVDJtZFhXbWRRbFo4RmxRYi96Z2J3TWdrODZUazg3K24yUmtCSE5SWkdSUmN3QUFBQU1BQUFBQUFmUURJQUFMQUE4QUZ3QUt0eFFRRFF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjUklSRUNJZ1lVRmpJMk5CTUJ6aE1UL2pJVFpBRXNnU29kSFNvZEF5QVQvUVlURXdMNkUyVCtEQUgwL2RvZEtoMGRLZ0FBQXdBQUFBQURJQU1nQUFVQUR3QVdBQXEzRWhBTEJnTUFBeTByQVRJWEVRRTJCUjRCRlJRR0l5SW5BU1VYQnk0Qk5UUUJYaG9ZL3RkbEFTaUFyTTJSZTJNQkVQNW43ZFEyUGdNZ0EvNXpBU2xuYWhQQ2c1SE5VUUVRMGVyVUtucEdmQUFBQUFFQUFQK2NBcndDdkFBakFBYXpGUUlCTFNzVE5EWTdBeUV5RmhRR0t3RVZNeklXRlNFUkJ5Y1JJVFEyT3dFMUl5SUdJeUltWEJzVEF3UUZBWkFWSFIwVk1tUXBPLzdVT0N6KzFEc3BaRElCQmdFVkhRS0tFaUFkS2gzSU95bisxR1JrQVN3cE84Z0JIZ0FBQUFJQUFBQUFBeUFESUFBSEFBb0FDTFVKQ0FRQUFpMHJFaUFXRUFZZ0poQWxFU1hxQVV6cTZ2NjA2Z0VzQVN3RElPcit0T3JxQVV3aS9uRElBQUVBQUFBQUF5QURJQUFMQUFhekJnQUJMU3NCTXhFaEZTRVJJeEVoTlNFQkxNZ0JMUDdVeVA3VUFTd0RJUDdVeVA3VUFTeklBQUFBQWdBQUFBQUN2QU1nQUFNQUhnQUl0UmdFQWdBQ0xTc0JNeEVqQXhjSEJoVVVGakkyTlRRbUx3RTNGeDRCRlJRR0lDWTFORFkzQVN4a1pJQStLRjZTMEpJMExTVStKajVJemY3ZXpVZytBeUQrY0FFQVRoOUxlbWlTa21nN1p5TWZUaDh4a0ZLUnpjMlJVcEF4QUFBQUFBTUFBQUFBQXlBRElBQURBQk1BRndBS3R4WVVDUVFDQUFNdEt4TWhGU0VISVRJVkVSUXJBVFVoRlNNaU5SRTBGeUVSSWNnQmtQNXd2d01PQ1FsYi9haGJDY2dCa1A1d0F5RElaQW4rNWduSXlBa0JHZ25JL3RRQUFBQUFCUUFBQUFBRElBSzhBQU1BQndBTEFBOEFFd0FQUUF3U0VBNE1DZ2dHQkFJQUJTMHJFVE1SSXdFekVTTUJNeFVqRnpNVkl4Y3pGU05rWkFLOFpHVCtETWpJWk1qSVpNaklBcno5UkFLOC9VUUNXR1JrWkdSa0FBRUFBUC9oQXlBQ3ZBQWJBQWF6RWdBQkxTc0JGaE0rQVRjV0Z6TVZJeWNHQnlZREJnSUhKaWNqTlRNZkFUWVNBVVVhYVE4NkR4UkRxZWNOU2lZV1lSVlRGUnc0ZEx3SkF3OVdBcnhYL3JRbGxDVW1obVFjdUZ0SkFUaEQvdlpEV0s1a0lnWXhBUnNBQVFBQS81d0RJQUs4QURrQUJyTWZBZ0V0S3hNME5qSVdGUlFPQVFjR0ZUTVZNamMrQWpNeUZoUUdJeUl1QVNjbUl4VWpORGMrQWpVMEppSUdGUlFlQVJjV0ZTTVJNelFuTGdMSU9WWTVDUkFEQStjV0JnY2RGdzByT1RrckRSY2RCd1lXNXdNREVBazVWamtKRUFNRDUrY0RBeEFKQWxnck9Ua3JEUmNkQndZVzV3TURFQWs1VmprSkVBTUQ1eFlHQngwWERTczVPU3NORngwSEJoWUNXQllHQngwWEFBQUFBZ0FBLzV3QjhRSzhBQ3NBTHdBSXRTNHNEd0FDTFNzVE1oY1dGUlFPQVFjT0JCMEJJelUwUGdFM1BnZzFOQ2NtSXlJSEJnY25OamMyRXpNVkkvZCtRVHNyS2lJWEN4NElDV1FvS2lFQ0d3UVZCQThEQndJY0psUlBKUmdIWkFveFFraGtaQUs4T3paWE5sOHVIaFFMSVJZb0dCa1pObDR3SFFJWEJSUUlFdzRXRnc0cEdTSWxHQzBNVHpGQy9VUmtBQUFBQUFRQUFBQUFBeUFESUFBZkFETUFSd0JiQUExQUNsUk1RRGdzSkFvQUJDMHJBVElXSFFFZUFSVVVCZ2N1QVNNaUJ5NEJJZ1lISmlNaUJ5WTFORFl6UGdFRE93RXlOak15RmgwQ0ZBWWlKajBDTkRZSE93RXlOak15RmgwQ0ZBWWlKajBDTkRZbE93RXlOak15RmgwQ0ZBWWlKajBDTkRZQndtaVNLemsvTVJGTExoc2REVkJtVUEwZEd6a29OWFpTRVk4YUJBTUJCZ0lWSFIwcUhSUzZCQU1CQmdJVkhSMHFIUlFCbmdNRUFRWUNGUjBkS2gwVUF5Q1NhRElRVlRFelVBMHFOQXd4UHo4eERDSTZURkoyVm5MK0RBRWRGUUhJRlIwZEZjZ0NEeDFnQVIwVkFXUVZIUjBWWkFJUEhRUUJIUlVCWkJVZEhSVmtBZzhkQUFFQUFBQUFBeUFESUFBakFBYXpDd0FCTFNzQkZ3YzFJd2NmQVRNMUZ3YzFJeUl2QVFjR0t3RTFNemN2QVNNMU16SWZBVGMyT3dFQ1dNaklNcG12QmhiSXlCa3VJS2FaSHk5a1pLYWpBMlJrTGlDWmpSOHZNZ01nbHBaa3Y4NERaSmFXWkNhK3ZpWmt6cjhEWkNheXNpWUFBQUFBQVFBQUFBQURJQU1nQUJVQUJyTVFBQUV0S3dFeUZ6Y1JJVGNtSXlJR0ZCWXlOeGNHSXlJbUVEWUJrS0ozZC83VWJWbDRmTEN3K0ZoSWRLaWw2K3NESUhkMy90UnRXN0Q0c0ZoSWRPc0JTdXNBQUFBQUFRQUFBQUFESUFNZ0FBa0FCck1GQUFFdEt3RWhFU2NCRnlFUkZ3RUJrQUdRcHY1d3B2NXdwZ0dRQXlEK2NLYitjS1lCa0tZQmtBQUJBQUFBQUFIMEF5QUFDUUFHc3dVQUFTMHJHd0VqRlRNTEFUTTFJL3I2eU1qNitzaklBeUQrMU1qKzFBRXN5QUFCQUFBQVpBTWdBbGdBQ1FBR3N3VUFBUzByQVJVek5RMEJOU01WSlFFc3lBRXMvdFRJL3RRQ1dNakkrdnJJeVBvQUFBQUFBd0FBQUFBRElBTWdBQW9BRWdBWEFBcTNGaE1PQ3dVQUF5MHJFVElFRmhJVkl6UUNKQ01WTWdBVkl6UW1JeFV5RmhVam9nRXAxbi9Jb1A3c3BNNEJKc2l2ZlZKMnlBTWdmOWIrMTZLa0FSU2daUDdhem4ydlpIWlNBQUFFQUFBQUFBTWdBeUFBQ2dBVEFCc0FJd0FOUUFvZ0hCY1VEd3NFQUFRdEt4TXlCQklWSXpRdUFpTVZNaDRCRlNNMEppTVZNaFlWSXpRbUl3WXlGaFFHSWlZMFpMNEJRcnhrWDZEZmVvam1obVRxcG55d1pIVlRLVkk3TzFJN0F5QzgvcjYrZXQrZ1gyU0c1b2ltNm1Td2ZGTjFaRHRTT3p0U0FBQUFBUUFBQUFBRElBTWdBQ0VBQnJNUkFBRXRLd0VoTWhZZEFTRTFOQ1lpQmgwQklSRVVCaU1oSWlZOUFUTVZGQll5TmpVUk5EWUJMQUdRS1R2K2NCMHFIUUdRT3luK0RDazdaQjBxSFRzRElEc3B5SllWSFIwVit2N1VLVHM3S2NpV0ZSMGRGUUltS1RzQUFBQUFBZ0FBQUFBRElBSzhBQklBSFFBSXRSb1RDZ0FDTFNzVE14VWpFU0UxTXhVVUJpTWhJaVkxRVRRMklSY0hOU01pQmdjK0FUTkw0Y2dCa0dRc0gvNCtIeXdzQWl6SXlNaEdiQkFSNEprQ3ZHVCtER1I5SHl3c0h3SW1IeXpJeUdSV1E1YkxBQUVBQUFBQUF5QUN2QUFNQUFhekJ3QUJMU3NKQWpVaklnWUhORDRDTXdIMEFTeisxR1NZMGlZdGJjaVNBcnorNVA3RXlKcVNkcXlMUndBQUFBSUFBQUFBQXlBRElBQVVBQndBQ0xVV0ZRc0JBaTByQVRjWEZnUVhGUlFIQmdjR0lpY21KeVk5QVRZa0V4RUZGaGNXRnhZQmZSTVRKUUVPU3BNOVFFaHdTRUE5azBvQkRqaisyZ3h1T0RJckF4Y0pDUTl6SGgvZ3cxRXZOVFV2VWNYZUh4NXovVndDVDNxMWswb2tId0FFQUFBQUFBSzhBeUFBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt3RXpFU01ETXhFakF6TVJJd016RVNNQ1dHUmt5R1JreUdSa3lHUmtBeUQ4NEFLOC9VUUI5UDRNQVN6KzFBQUFBQUVBQUFBQUFyd0RJQUFOQUFhekJ3QUJMU3NCTXhVekZ3Y2pFU01SSXljM013RXNaTWhrWk1oa3lHUmt5QU1neUdSay9uQUI5R1JrQUFBQUFBUUFBQUFBQXlBRElBQUdBQW9BRGdBU0FBMUFDaEVQRFFzSkJ3UUFCQzByRXpNUk13Y25NeE16RlNNVklSVWhGU0VWSWNoa3lQcjZ5TWpJeUFFcy90UUJrUDV3QXlEOXFNaklBbGhrWkdSa1pBQUFBQVFBQUFBQUF5QURJQUFHQUFvQURnQVNBQTFBQ2hFUERRc0pCd1FBQkMwckV6TVJNd2NuTXhNaEZTRVZJUlVoRlRNVkk4aGt5UHI2eU1nQmtQNXdBU3orMU1qSUF5RDlxTWpJQWxoa1pHUmtaQUFBQUFjQUFBQUFBeUFDdkFBUEFCTUFGd0FiQUI4QUl3QW5BQk5BRUNVa0lTQWRIQmtZRlJRUkVBY0FCeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNWTXpVekZTRTFCUlV6TlRNVklUVUZGVE0xTXhVaE5Vc0NpaDhzTEIvOWRoOHNMRGhrWkFHUS9haGtaQUdRL2Foa1pBR1FBcndzSC8zYUh5d3NId0ltSHl4a1pHUmtaTWhrWkdSa3lHUmtaR1FBQUFFQUFBQUFBeUFESUFBSkFBYXpCQUFCTFNzQkV5RUhFeWNIRXljaEFaQmtBU3o2WlByNlpQb0JMQU1nL3RUSS90VEl5QUVzeUFBQUNRQUFBQUFESUFNZ0FBY0FEd0FYQUI4QUp3QXZBRGNBUHdCSEFCZEFGRVJBUERnME1Dd29KQ0FjR0JRUURBZ0VBQWt0S3dBeUZoUUdJaVkwQmpJV0ZBWWlKalFrTWhZVUJpSW1OQVF5RmhRR0lpWTBCaklXRkFZaUpqUWtNaFlVQmlJbU5BUXlGaFFHSWlZMEpESVdGQVlpSmpRR01oWVVCaUltTkFGN0toMGRLaDNkS2gwZEtoMENFU29kSFNvZC91YWtkbmFrZHFzcUhSMHFIUUxaS2gwZEtoMzl4U29kSFNvZEFoRXFIUjBxSGQwcUhSMHFIUU1nSFNvZEhTcEhIU29kSFNvZEhTb2RIU3BIZHFSMmRxUWdIU29kSFNvZEhTb2RIU3JkSFNvZEhTb2RIU29kSFNwSEhTb2RIU29BQXdBQUFBQUN2QU1nQUE4QUV3QVpBQXEzRnhRUkVBY0FBeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNSSVJFQ0lnWVdNallpQW5nT0ZCUU8vWWdPRkJSUUFmVGRPaDBjUEJ3RElCUU8vU1FPRkJRT0F0d09GR1QrREFIMC9kb3lNaklBQUFJQUFBQUFBeUFESUFBRUFBd0FDTFVKQlFNQUFpMHJFU0VKQWpZaUJoUVdNalkwQVN3QjlQN1UvZ3p4VWpzN1Vqc0RJUDRNL3RRQjlNZzdVanM3VWdBREFBQUFaQU1nQWxnQUJBQUtBQklBQ3JjUEN3Z0ZBd0FETFNzUk13RUhBU1V6QVFjbk55UWlCaFFXTWpZMHlBRXN5UDdVQVZTZ0FTeklUbmYrS2lvZEhTb2RBbGorMU1nQkxNaisxTWhPZXNnZEtoMGRLZ0FBQkFBQUFBQURJQU1nQUFjQUR3QVhBQjhBRFVBS0hCZ1VFQXdJQkFBRUxTc1NJQllRQmlBbUVDUWlCaFFXTWpZMEpESVdGQVlpSmpRMklnWVVGakkyTk9zQlN1dnIvcmJyQWd6NHNMRDRzUDZDcEhaMnBIYnlWRG82VkRvRElPdit0dXZyQVVxSHNQaXdzUGhNZHFSMmRxUVNPbFE2T2xRQUFnQUFBQUFESUFLOEFBa0FEd0FJdFF3S0NBQUNMU3NSSVFjaEVTRTFOeEVoQVJjQkp6Y1hBaTlrL3BrQjlHVDlSQUs4WlA1d3lHUmtBcnhrL2d5ZlpQNlpBcnhrL25ESVpHUUFBQU1BQUFBQUF5QURJQUFMQUJFQUZRQUt0eE1TRUF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjSEZ3Y1hOeGNWSVRVSkF3NEpDZnp5Q1paSVpHUklyRTRCTEFNZ0NmenlDUWtERGdsT1NHUmtTS3d5WkdRQUFBQUJBQUFBQUFNZ0F5QUFHUUFHc3cwQUFTMHJFU0VWSXpRbUt3RVJGQlk3QVJVaE5UTXlOalVSSXlJR0ZTTURJREk3S1pZZEZUTCtjRElWSFpZcE96SURJTWdwTy8zYUZSMWtaQjBWQWlZN0tRQUFBQUFDQUFBQUF3SzhBcndBQXdBZEFBaTFGUVFDQUFJdEt4RXpFU01USVRJWEVoVVVCaXNCSWdZVkZCY1dEZ0VtSnk0Q0p5WWpaR1RJQVY0aERtY2RGWllVSGk4R0VpWWtDd0krT0FnY0xBSzgvbkFCa0IvKzNSd1ZIUjhUSDVrVUpRd1JGQU43YUFnY0FBSUFBQUFBQXJ3Q3ZBQWNBQ0FBQ0xVZkhSUUNBaTByQVRZM0Z4NEJCd1lWRkJZN0FUSVdGUlFHRHdFR0l5RVJNamMrQWdFekVTTUJrQkFmRXhNU0JpOGVGSllWSFRRYUdRNGgvcUlzSEFnNFB2NXlaR1FDbWg4REF3WWxGSmtmRXg4ZEZReWdTa2tmQVpBY0NHaDcvdm4rY0FBQUFnQUEvNXdDdkFLOEFCOEFLZ0FJdFNNZ0Z3QUNMU3NUSVJVakZSWVhCeVlqSWdZVUZqSTJOVFFuTnhZVkZBWWdKalUwTmpjMUl3VUFCd1lpSmpRM1BnRTN5QUVzWkRJV0lpa3ZhSktTMEpJUVd4bk4vdDdOcklCa0FmVCsyQlFQSmg0UENjQmJBcnhrQmdnSVhoQ1MwSktTYUM4cEpVUTVrYzNOa1lQR0VnTVEvcVFVRHg0bUR3bVdSd0FDQUFBQUFBTWdBcndBQmdBTkFBaTFEQWNDQUFJdEt3RVhCelVoTlNFQkZTRVZJUlVuQWxqSXlQMm9BbGorY0FKWS9haklBcnlXbG1Say90UmtaR1NXQUFBQUFBSUFBQUFBQXJ3RElBQVBBQ2NBQ0xVakVBZ0FBaTByQVRNeUZoVXpNaFlWSVRRMk93RTBOZ016RVJRV01qWTFFVE1SRkJZeU5qVVJNeEVVSXlFaU5RRXNaQ2s3WkNrNy9VUTdLV1E3bjJRZEtoMWtIU29kWkJQK01oTURJRHNwT3lrcE95azcvdFQrb2hVZEhSVUJYdjZpRlIwZEZRRmUvaDhURXdBQ0FBQUFBQUs4QXlBQUVRQVZBQWkxRkJJTUFBSXRLeE16RVJRV01qWTFFVE1SRkFZckFTSW1OUU1oRlNGa3lEdFNPMlIyVWpKbmsyUUN2UDFFQXlEK2NDazdPeWtCa1A1d1VuWjFVLzdVWkFBQUFBQUVBQUFBQUFNZ0Fyd0FDd0FYQUNNQUp3QU5RQW9tSkIwWUVRd0ZBQVF0S3hNek1oVVJGQ3NCSWpVUk5DRXpNaFVSRkNzQklqVVJOQVV6TWhVUkZDc0JJalVSTkFFaEZTRUp0Z2tKdGdrQ1liWUpDYllKL3QyMkNRbTJDZjdVQXlEODRBSzhDZjRlQ1FrQjRna0ovaDRKQ1FIaUNjZ0ovdVlKQ1FFYUNmNXdaQUFBQUFBSEFBQUFBQU1nQXJ3QUJ3QVBBQmNBR3dBakFDc0FNd0FUUUJBdkxDY2tIeHdhR0JRUURBZ0VBQWN0S3hNek1oMEJJelUwSVRNeUhRRWpOVFFGTXpJZEFTTTFOQVVoRlNFVk14VVVLd0VpTlNVekZSUXJBU0kxSlRNVkZDc0JJalVLdFFuSUFtSzFDY2orM3JVSnlQN1VBeUQ4NE1nSnRna0JMTWdKdFFvQkxNZ0p0UW9DdkFtL3Z3a0p2NzhKWkFsYld3bklaR1MvQ1FtL1d3a0pXNzhKQ1FBQUFBUUFBQUFBQXlBQ3ZBQURBQThBR3dBbkFBMUFDaUVjRlJBSkJBSUFCQzByRVNFVklSY3pNaFVSRkNzQklqVVJOQ0V6TWhVUkZDc0JJalVSTkNFek1oVVJGQ3NCSWpVUk5BTWcvT0FKdGdrSnRna0JOYllKQ2JZSkFUVzJDUW0yQ1FLOFpHUUovaDRKQ1FIaUNRbis1Z2tKQVJvSkNmNGVDUWtCNGdrQUFBQUFBUUFBQUdRRElBSllBQlVBQnJNTkFBRXRLeE1oTWhZZEFUY3pFU01uRlJRR0l5RWlKalVSTkRZeUFmUVZIV1JrWkdRZEZmNE1GUjBkQWxnZEZaWmsvdFJrbGhVZEhSVUJrQlVkQUFNQUFBQUFBeUFESUFBSEFCd0FKQUFLdHlRZEVna0NBQU10S3dFekVTTW5JeEV6SVRVeUZ4NEJGQVlISXdZak5USTNQZ0UwSmljbUJ4Y2VBUlFHRHdFQlRrSkNoc2pJQVN3bEptSi9mMklESWlZYUdFRlZWVUVZR2hraEtpc2dHUU1nL09ESUFaQmtDaG1oMEtJWkNXUUdFV3VNYXhFR1pBTUlOMFEzQ0FNQUFnQUFBQUFDV0FNZ0FBY0FEd0FJdFE4SUFnQUNMU3NCTXhFakp5TVJNd1VYSGdFVUJnOEJBVTVDUW9iSXlBRXNHU0VxS3lBWkF5RDg0TWdCa0dRRENEZEVOd2dEQUFBQUFRQUFBQUFCa0FNZ0FBY0FCck1DQUFFdEt3RXpFU01uSXhFekFVNUNRb2JJeUFNZy9PRElBWkFBQUFBREFBQUFBQUs4QXlBQUR3QVRBQmNBQ3JjVkZCRVFCd0FETFNzQk16SVhBUmNWRkNNaElqMEJOd0UyQXhVek5RTVZNelVCTlZJSUJBRW1Bd245VmdrREFTWUVBV1JrWkFNZ0NmMVdFMUVKQ1ZFVEFxb0ovdFRJeVA3VVpHUUFBQUFEQUFBQUFBTHhBeUFBQ1FBU0FCb0FDcmNYRXcwS0F3QURMU3NCTWhjSEppTWlCeWMyRWpJWEJ5WWpJZ2NuRmpJV0ZBWWlKalFCZDlDcU5ZMjRzNDgxcWxqcVl6VklXMVZLTnF4U096dFNPd01nYlZKYlcxSnQvdFErVlM4dlZlNDdVanM3VWdBQUFBSUFBQUFBQXlFRElBQVpBQ0VBQ0xVZUdnOEFBaTByQVRJWEJ4VXpOeFlWRkFZaklpY0JCaUluSmpRM0FTWTFORFlBSWdZVUZqSTJOQUluSUE5aHlHRURrMmNxTVA3Z0hGZ2NIUjBCSXhPVC9yb3FIUjBxSFFNZ0EySElZUThnYUpJVC90MGNIQjFXSFFFZk1DdG9rdjEySFNvZEhTb0FBQUVBQVArc0F4QUN2QUFYQUFhekRRQUJMU3NURmhjK0FqY1hCeDRDRndjdUFpY0hKelkzSmllTkFmd2JabElrai8wY1psVW1qeVJUWlJ2OWpUUEgrUUVDdkFINUhHVlRKbzM5RzJWVEpJOG1WV1ljL1k4d3gvd0JBQUFBQVFBQUFBQUN2QU1nQUJjQUJyTU9BQUV0S3hFekV6TVRNd016RlNFVklSVWhGU00xSVRVaE5TRTFNMlRuSnVkazRlSCsxQUVzL3RSay90UUJMUDdVNFFNZy90UUJMUDdVWkdSa3lNaGtaR1FBQUFBQUF3QUEvLzRESWdNZ0FCa0FKd0F6QUFxM0xpZ2VHZzBBQXkwckVpQVdGUlFIRmg4QkhnRVZGQVlqSWlZdkFTWW5CaU1pSmhBa0lnWVVGak15TnpZL0FUWTFOQ1V6RlRNVkl4VWpOU00xTTgwQklzMHNDQVZuREJJOEtoRXJER1FGQkU5YWtjMEJ4dENTa21oY1J3NFJBelgrMUdSa1pHUmtaQU1nelpGWVVRUUZaQXdyRVNvOEVneG5CUWdzelFFaWFaTFFrandYQ0FORFdXZ3VaR1JrWkdRQUFBQURBQUQvL2dNaUF5QUFHUUFuQUNzQUNyY3FLQjRhRFFBRExTc1NJQllWRkFjV0h3RWVBUlVVQmlNaUppOEJKaWNHSXlJbUVDUWlCaFFXTXpJM05qOEJOalUwQlNFVkljMEJJczBzQ0FWbkRCSThLaEVyREdRRkJFOWFrYzBCeHRDU2ttaGNSdzRSQXpYK2NBRXMvdFFESU0yUldGRUVCV1FNS3hFcVBCSU1ad1VJTE0wQkltbVMwSkk4RndnRFExbG9ObVFBQVFBQUFBRVptU3NMakJsZkR6ejFBQXNESUFBQUFBRFAyUzlxQUFBQUFNL1pMMm9BQVArYkF5SURJQUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUCtiQUVnRGhBQUFBQUFESWdBQkFBQUFBQUFBQUFBQUFBQUFBQUFBNFFFZ0FCb0FBQUFBQVFvQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBSllBQUFDV0FBQUF5QUFBQU1nQUFBQmtBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBbGdBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUFaQUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU9FQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQTRRQUFBSllBQUFEaEFBQUFsZ0FBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSzhBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBZlFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQVpBQUFBTWdBQUFESUFBQUE0UUFBQU1nQUFBRElBQUFBNFFBQUFBQUFBQUFBQUFXQUJZQUZnQTRBRm9BZUFDWUFNQUE1Z0VPQVV3QllnR0lBYTRCMGdIMkFnd0NJZ0k0QWs0Q1pBSjZBbzRDdGdNQUF5SURWQU4yQThnRDdnUU1CRllFZmdTcUJPZ0UvQVVzQlQ0RlhnV2NCZFlHSUFaWUJ1SUhGZ2RZQjVRSDVBZjBDQVlJR0FncUNIZ0lsZ2kyQ013STRnajRDUTRKTWdsZUNab0p6QW9RQ2tZS2FncWdDc1lMREFzcUMwZ0xhQXVHQy9vTUVneE1ERzRNb0F6VURRWU5ZQTJBRFp3TnhBM3lEaVFPZGc2U0Rxd08xZzcrRHpZUFRnOW1ENFFQb0EvS0VBWVFPQkJXRUhZUWxCQ3lFTllSS0JGc0VZZ1J6QkhxRWdZU0tCSndFcElTdGhNK0UyQVQwaFFhRkVZVWdCVElGUUFWSGhVNEZWb1ZnQlhJRmdRV0poWk1GbklXbUJiSUZ2d1hJaGVZR0JZWW1CalFHU2daUEJsZ0dZSVpxaG5TR2Y0YVBCcG9HclFhekJyZUd2UWJEQnNrR3p3YlZCdGtHMzRibkJ2d0hBQWNPQnhZSElBY3NoeitIUm9kWkIyTUhib2Q3QjRpSGtBZVhCNlVIc0llN2g4aUgzWWZ3Q0ErSUhnZ29pQytJTllnOENFZUlWd2hraUhFSWVJaUdpSkNJbUFpaWlLMEl2d2pHQ09RSThJajRpUU9KRW9rY0NTY0pNWWsraVUwSlhvbG5DWGFKZ1FtUmlhWUp0Z20vaWMrSjJJbmVDZW9KOXdvR0NoR0tIQW93aWtNQUFBQUFRQUFBT0lBYUFBUUFBQUFBQUFDQUFBQUFBQnpBQUFBTmd0c0FBQUFBQUFBQUE0QXJnQUJBQUFBQUFBQUFFSUFoZ0FCQUFBQUFBQUJBQVVBMVFBQkFBQUFBQUFDQUFZQTZRQUJBQUFBQUFBREFDUUJPZ0FCQUFBQUFBQUVBQWtCY3dBQkFBQUFBQUFGQUE0Qm13QUJBQUFBQUFBR0FBc0J3Z0FEQUFFRUNRQUFBSVFBQUFBREFBRUVDUUFCQUFvQXlRQURBQUVFQ1FBQ0FBd0Eyd0FEQUFFRUNRQURBRWdBOEFBREFBRUVDUUFFQUJJQlh3QURBQUVFQ1FBRkFCd0JmUUFEQUFFRUNRQUdBQllCcWdCREFISUFaUUJoQUhRQVpRQmtBQ0FBWWdCNUFDQUFVQUF1QUVvQUxnQWdBRThBYmdCdkFISUFhUUFnQUhjQWFRQjBBR2dBSUFCR0FHOEFiZ0IwQUVZQWJ3QnlBR2NBWlFBZ0FESUFMZ0F3QUNBQUtBQm9BSFFBZEFCd0FEb0FMd0F2QUdZQWJ3QnVBSFFBWmdCdkFISUFad0JsQUM0QWN3Qm1BQzRBYmdCbEFIUUFLUUFBUTNKbFlYUmxaQ0JpZVNCUUxrb3VJRTl1YjNKcElIZHBkR2dnUm05dWRFWnZjbWRsSURJdU1DQW9hSFIwY0RvdkwyWnZiblJtYjNKblpTNXpaaTV1WlhRcEFBQkpBR01BYndCdUFITUFBRWxqYjI1ekFBQnBBR01BYndCdUFHa0FZd0FBYVdOdmJtbGpBQUJHQUc4QWJnQjBBRVlBYndCeUFHY0FaUUFnQURJQUxnQXdBQ0FBT2dBZ0FGVUFiZ0IwQUdrQWRBQnNBR1VBWkFBeEFDQUFPZ0FnQURFQUxRQTNBQzBBTWdBd0FERUFOQUFBUm05dWRFWnZjbWRsSURJdU1DQTZJRlZ1ZEdsMGJHVmtNU0E2SURFdE55MHlNREUwQUFCVkFHNEFkQUJwQUhRQWJBQmxBR1FBTVFBQVZXNTBhWFJzWldReEFBQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREVBTGdBeEFDQUFBRlpsY25OcGIyNGdNUzR4TGpFZ0FBQnZBSEFBWlFCdUFDMEFhUUJqQUc4QWJnQnBBR01BQUc5d1pXNHRhV052Ym1sakFBQUNBQUFBQUFBQS80TUFNZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9JQUFBQUJBQUlCQWdFREFRUUJCUUVHQVFjQkNBRUpBUW9CQ3dCRUFFVUFSZ0JIQUVnQVNRRU1BUTBCRGdFUEFSQUJFUUVTQVJNQkZBRVZBUllCRndFWUFSa0JHZ0ViQVJ3QkhRRWVBUjhCSUFFaEFTSUJJd0VrQVNVQkpnRW5BU2dCS1FFcUFTc0JMQUV0QVM0Qkx3RXdBVEVCTWdFekFUUUJOUUUyQVRjQk9BRTVBVG9CT3dFOEFUMEJQZ0UvQVVBQlFRRkNBVU1CUkFGRkFVWUJSd0ZJQVVrQlNnRkxBVXdCVFFGT0FVOEJVQUZSQVZJQlV3RlVBVlVCVmdGWEFWZ0JXUUZhQVZzQlhBRmRBVjRCWHdGZ0FXRUJZZ0ZqQVdRQlpRRm1BV2NCYUFGcEFXb0Jhd0ZzQVcwQmJnRnZBWEFCY1FGeUFYTUJkQUYxQVhZQmR3RjRBWGtCZWdGN0FYd0JmUUYrQVg4QmdBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0FvQUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0FjTUJ4QUhGQWNZQnh3SElBY2tCeWdITEFjd0J6UUhPQWM4QjBBSFJBZElCMHdIVUFkVUIxZ0hYQWRnQjJRQUJNUUV5QVRNQk5BRTFBVFlCTndFNEFUa0NNVEFDTVRFQ01USUNNVE1DTVRRQ01UVUNNVFlDTVRjQ01UZ0NNVGtDTVdFQ01XSUNNV01DTVdRQ01XVUNNV1lDTWpBQ01qRUNNaklDTWpNQ01qUUNNalVDTWpZQ01qY0NNamdDTWprQ01tRUNNbUlDTW1NQ01tUUNNbVVDTW1ZQ016QUNNekVDTXpJQ016TUNNelFDTXpVQ016WUNNemNDTXpnQ016a0NNMkVDTTJJQ00yTUNNMlFDTTJVQ00yWUNOREFDTkRFQ05ESUNORE1DTkRRQ05EVUNORFlDTkRjQ05EZ0NORGtDTkdFQ05HSUNOR01DTkdRQ05HVUNOR1lDTlRBQ05URUNOVElDTlRNQ05UUUNOVFVDTlRZQ05UY0NOVGdDTlRrQ05XRUNOV0lDTldNQ05XUUNOV1VDTldZQ05qQUNOakVDTmpJQ05qTUNOalFDTmpVQ05qWUNOamNDTmpnQ05qa0NObUVDTm1JQ05tTUNObVFDTm1VQ05tWUNOekFDTnpFQ056SUNOek1DTnpRQ056VUNOellDTnpjQ056Z0NOemtDTjJFQ04ySUNOMk1DTjJRQ04yVUNOMllDT0RBQ09ERUNPRElDT0RNQ09EUUNPRFVDT0RZQ09EY0NPRGdDT0RrQ09HRUNPR0lDT0dNQ09HUUNPR1VDT0dZQ09UQUNPVEVDT1RJQ09UTUNPVFFDT1RVQ09UWUNPVGNDT1RnQ09Ua0NPV0VDT1dJQ09XTUNPV1FDT1dVQ09XWUNZVEFDWVRFQ1lUSUNZVE1DWVRRQ1lUVUNZVFlDWVRjQ1lUZ0NZVGtDWVdFQ1lXSUNZV01DWVdRQ1lXWUNZakFDWWpFQ1lqSUNZak1DWWpRQ1lqVUNZallDWWpjQ1lqZ0NZamtDWW1FQ1ltSUNZbU1DWW1RQ1ltVUNZbVlDWXpBQ1l6RUNZeklDWXpNQ1l6UUNZelVDWXpZQ1l6Y0NZemdDWXprQ1kyRUNZMklDWTJNQ1kyUUNZMlVDWTJZQ1pEQUNaREVDWkRJQ1pETUNaRFFDWkRVQ1pEWUNaRGNDWkRnQ1pEa0NaR0VDWkdJQ1pHTUNaR1FDWkdVQUFBRUFBZi8vQUE4QUFBQUFBQUFBQUFBQUFBQ3dBQ3dnc0FCVldFVlpJQ0JMdUFBT1VVdXdCbE5hV0xBMEc3QW9XV0JtSUlwVldMQUNKV0c1Q0FBSUFHTmpJMkliSVNHd0FGbXdBRU1qUkxJQUFRQkRZRUl0c0FFc3NDQmdaaTJ3QWl3Z1pDQ3d3RkN3QkNaYXNpZ0JDa05GWTBWU1cxZ2hJeUViaWxnZ3NGQlFXQ0d3UUZrYklMQTRVRmdoc0RoWldTQ3hBUXBEUldORllXU3dLRkJZSWJFQkNrTkZZMFVnc0RCUVdDR3dNRmtiSUxEQVVGZ2daaUNLaW1FZ3NBcFFXR0FiSUxBZ1VGZ2hzQXBnR3lDd05sQllJYkEyWUJ0Z1dWbFpHN0FCSzFsWkk3QUFVRmhsV1ZrdHNBTXNJRVVnc0FRbFlXUWdzQVZEVUZpd0JTTkNzQVlqUWhzaElWbXdBV0F0c0FRc0l5RWpJU0Jrc1FWaVFpQ3dCaU5Dc1FFS1EwVmpzQXBEc0FCZ1JiQURLaUVnc0FaRElJb2dpckFCSzdFd0JTV0tVVmhnVUJ0aFVsbFlJMWtoSUxCQVUxaXdBU3NiSWJCQVdTT3dBRkJZWlZrdHNBVXNzQWRESzdJQUFnQkRZRUl0c0FZc3NBY2pRaU1nc0FBalFtR3dBbUptc0FGanNBRmdzQVVxTGJBSExDQWdSU0N3QzBOanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ1JMQUJZQzJ3Q0N5eUJ3c0FRMFZDS2lHeUFBRUFRMkJDTGJBSkxMQUFReU5Fc2dBQkFFTmdRaTJ3Q2l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtJTEFnVUZnaHNBQWJzREJRV0xBZ0c3QkFXVmtqc0FCUVdHVlpzQU1sSTJGRVJMQUJZQzJ3Q3l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtzQ1JRV0xBQUc3QkFXU093QUZCWVpWbXdBeVVqWVVSRXNBRmdMYkFNTENDd0FDTkNzZ3NLQTBWWUlSc2pJVmtxSVMyd0RTeXhBZ0pGc0dSaFJDMndEaXl3QVdBZ0lMQU1RMHF3QUZCWUlMQU1JMEpac0ExRFNyQUFVbGdnc0EwalFsa3RzQThzSUxBUVltYXdBV01ndUFRQVk0b2pZYkFPUTJBZ2ltQWdzQTRqUWlNdHNCQXNTMVJZc1FSa1JGa2tzQTFsSTNndHNCRXNTMUZZUzFOWXNRUmtSRmtiSVZra3NCTmxJM2d0c0JJc3NRQVBRMVZZc1E4UFE3QUJZVUt3RHl0WnNBQkRzQUlsUXJFTUFpVkNzUTBDSlVLd0FSWWpJTEFESlZCWXNRRUFRMkN3QkNWQ2lvb2dpaU5oc0E0cUlTT3dBV0VnaWlOaHNBNHFJUnV4QVFCRFlMQUNKVUt3QWlWaHNBNHFJVm13REVOSHNBMURSMkN3QW1JZ3NBQlFXTEJBWUZsbXNBRmpJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDeEFBQVRJMFN3QVVPd0FENnlBUUVCUTJCQ0xiQVRMQUN4QUFKRlZGaXdEeU5DSUVXd0N5TkNzQW9qc0FCZ1FpQmdzQUZodFJBUUFRQU9BRUpDaW1DeEVnWXJzSElyR3lKWkxiQVVMTEVBRXlzdHNCVXNzUUVUS3kyd0ZpeXhBaE1yTGJBWExMRURFeXN0c0Jnc3NRUVRLeTJ3R1N5eEJSTXJMYkFhTExFR0V5c3RzQnNzc1FjVEt5MndIQ3l4Q0JNckxiQWRMTEVKRXlzdHNCNHNBTEFOSzdFQUFrVlVXTEFQSTBJZ1JiQUxJMEt3Q2lPd0FHQkNJR0N3QVdHMUVCQUJBQTRBUWtLS1lMRVNCaXV3Y2lzYklsa3RzQjhzc1FBZUt5MndJQ3l4QVI0ckxiQWhMTEVDSGlzdHNDSXNzUU1lS3kyd0l5eXhCQjRyTGJBa0xMRUZIaXN0c0NVc3NRWWVLeTJ3Sml5eEJ4NHJMYkFuTExFSUhpc3RzQ2dzc1FrZUt5MndLU3dnUExBQllDMndLaXdnWUxBUVlDQkRJN0FCWUVPd0FpVmhzQUZnc0NrcUlTMndLeXl3S2l1d0tpb3RzQ3dzSUNCSElDQ3dDME5qdUFRQVlpQ3dBRkJZc0VCZ1dXYXdBV05nSTJFNEl5Q0tWVmdnUnlBZ3NBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZQ05oT0JzaFdTMndMU3dBc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0xpd0FzQTByc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0x5d2dOYkFCWUMyd01Dd0FzQUZGWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqc0FFcnNBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpzQUVyc0FBV3RBQUFBQUFBUkQ0ak9MRXZBUlVxTGJBeExDQThJRWNnc0F0RFk3Z0VBR0lnc0FCUVdMQkFZRmxtc0FGallMQUFRMkU0TGJBeUxDNFhQQzJ3TXl3Z1BDQkhJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDd0FFTmhzQUZEWXpndHNEUXNzUUlBRmlVZ0xpQkhzQUFqUXJBQ0pVbUtpa2NqUnlOaElGaGlHeUZac0FFalFySXpBUUVWRkNvdHNEVXNzQUFXc0FRbHNBUWxSeU5ISTJHd0NVTXJaWW91SXlBZ1BJbzRMYkEyTExBQUZyQUVKYkFFSlNBdVJ5TkhJMkVnc0FRalFyQUpReXNnc0dCUVdDQ3dRRkZZc3dJZ0F5QWJzd0ltQXhwWlFrSWpJTEFJUXlDS0kwY2pSeU5oSTBaZ3NBUkRzQUppSUxBQVVGaXdRR0JaWnJBQlkyQWdzQUVySUlxS1lTQ3dBa05nWkNPd0EwTmhaRkJZc0FKRFlSdXdBME5nV2JBREpiQUNZaUN3QUZCWXNFQmdXV2F3QVdOaEl5QWdzQVFtSTBaaE9Cc2pzQWhEUnJBQ0piQUlRMGNqUnlOaFlDQ3dCRU93QW1JZ3NBQlFXTEJBWUZsbXNBRmpZQ01nc0FFckk3QUVRMkN3QVN1d0JTVmhzQVVsc0FKaUlMQUFVRml3UUdCWlpyQUJZN0FFSm1FZ3NBUWxZR1Fqc0FNbFlHUlFXQ0ViSXlGWkl5QWdzQVFtSTBaaE9Ga3RzRGNzc0FBV0lDQWdzQVVtSUM1SEkwY2pZU004T0Myd09DeXdBQllnc0FnalFpQWdJRVlqUjdBQkt5TmhPQzJ3T1N5d0FCYXdBeVd3QWlWSEkwY2pZYkFBVkZndUlEd2pJUnV3QWlXd0FpVkhJMGNqWVNDd0JTV3dCQ1ZISTBjalliQUdKYkFGSlVtd0FpVmh1UWdBQ0FCall5TWdXR0liSVZsanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ0l5NGpJQ0E4aWpnaklWa3RzRG9zc0FBV0lMQUlReUF1UnlOSEkyRWdZTEFnWUdhd0FtSWdzQUJRV0xCQVlGbG1zQUZqSXlBZ1BJbzRMYkE3TENNZ0xrYXdBaVZHVWxnZ1BGa3VzU3NCRkNzdHNEd3NJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UFN3aklDNUdzQUlsUmxKWUlEeFpJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UGl5d05Tc2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJMYkEvTExBMks0b2dJRHl3QkNOQ2lqZ2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJzQVJETHJBckt5MndRQ3l3QUJhd0JDV3dCQ1lnTGtjalJ5TmhzQWxES3lNZ1BDQXVJeml4S3dFVUt5MndRU3l4Q0FRbFFyQUFGckFFSmJBRUpTQXVSeU5ISTJFZ3NBUWpRckFKUXlzZ3NHQlFXQ0N3UUZGWXN3SWdBeUFic3dJbUF4cFpRa0lqSUVld0JFT3dBbUlnc0FCUVdMQkFZRmxtc0FGallDQ3dBU3NnaW9waElMQUNRMkJrSTdBRFEyRmtVRml3QWtOaEc3QURRMkJac0FNbHNBSmlJTEFBVUZpd1FHQlpackFCWTJHd0FpVkdZVGdqSUR3ak9Cc2hJQ0JHSTBld0FTc2pZVGdoV2JFckFSUXJMYkJDTExBMUt5NnhLd0VVS3kyd1F5eXdOaXNoSXlBZ1BMQUVJMElqT0xFckFSUXJzQVJETHJBckt5MndSQ3l3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckF4S2kyd1JTeXdBQlVnUjdBQUkwS3lBQUVCRlJRVExyQXhLaTJ3Uml5eEFBRVVFN0F5S2kyd1J5eXdOQ290c0Vnc3NBQVdSU01nTGlCR2lpTmhPTEVyQVJRckxiQkpMTEFJSTBLd1NDc3RzRW9zc2dBQVFTc3RzRXNzc2dBQlFTc3RzRXdzc2dFQVFTc3RzRTBzc2dFQlFTc3RzRTRzc2dBQVFpc3RzRThzc2dBQlFpc3RzRkFzc2dFQVFpc3RzRkVzc2dFQlFpc3RzRklzc2dBQVBpc3RzRk1zc2dBQlBpc3RzRlFzc2dFQVBpc3RzRlVzc2dFQlBpc3RzRllzc2dBQVFDc3RzRmNzc2dBQlFDc3RzRmdzc2dFQVFDc3RzRmtzc2dFQlFDc3RzRm9zc2dBQVF5c3RzRnNzc2dBQlF5c3RzRndzc2dFQVF5c3RzRjBzc2dFQlF5c3RzRjRzc2dBQVB5c3RzRjhzc2dBQlB5c3RzR0Fzc2dFQVB5c3RzR0Vzc2dFQlB5c3RzR0lzc0RjckxyRXJBUlFyTGJCakxMQTNLN0E3S3kyd1pDeXdOeXV3UENzdHNHVXNzQUFXc0RjcnNEMHJMYkJtTExBNEt5NnhLd0VVS3kyd1p5eXdPQ3V3T3lzdHNHZ3NzRGdyc0R3ckxiQnBMTEE0SzdBOUt5MndhaXl3T1NzdXNTc0JGQ3N0c0dzc3NEa3JzRHNyTGJCc0xMQTVLN0E4S3kyd2JTeXdPU3V3UFNzdHNHNHNzRG9yTHJFckFSUXJMYkJ2TExBNks3QTdLeTJ3Y0N5d09pdXdQQ3N0c0hFc3NEb3JzRDByTGJCeUxMTUpCQUlEUlZnaEd5TWhXVUlyc0FobHNBTWtVSGl3QVJVd0xRQkx1QURJVWxpeEFRR09XYkFCdVFnQUNBQmpjTEVBQlVLeEFBQXFzUUFGUXJFQUNDcXhBQVZDc1FBSUtyRUFCVUs1QUFBQUNTcXhBQVZDdVFBQUFBa3FzUU1BUkxFa0FZaFJXTEJBaUZpeEEyUkVzU1lCaUZGWXVnaUFBQUVFUUloalZGaXhBd0JFV1ZsWldiRUFEQ3E0QWYrRnNBU05zUUlBUkFBPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuZW90XG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5lb3Rcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsVDFSVVR3QUtBSUFBQXdBZ1EwWkdJRjNOUW9vQUFBVlFBQUJKRmtaR1ZFMXI4QUdrQUFCUjZBQUFBQnhQVXk4eU5BWlJnZ0FBQVJBQUFBQmdZMjFoY0FBTjQ0UUFBQVBzQUFBQlFtaGxZV1FCODd0RkFBQUFyQUFBQURab2FHVmhCb3dEL3dBQUFPUUFBQUFrYUcxMGVKb0VBQUFBQUU1b0FBQURmbTFoZUhBQTRGQUFBQUFCQ0FBQUFBWnVZVzFsanZZUXhRQUFBWEFBQUFKOGNHOXpkUCtHQURJQUFBVXdBQUFBSUFBQkFBQUFBUm1aUVRCak5sOFBQUFVBQ3dNZ0FBQUFBTS9aTDJvQUFBQUF6OWt2YWdBQS81c0RJZ01nQUFBQUNBQUNBQUFBQUFBQUFBRUFBQU1nLzVzQVNBT0VBQUFBQUFNaUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFEZkFBQlFBQURnQUFBQUJBTCtBWkFBQlFBQUFnZ0NNQUFBQUhBQ0NBSXdBQUFCZ0FBbkFNOEFBQUlBQlFNQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFVR1pGWkFEQTRBRGczZ01nQUFBQVNBTWdBR1VBQUFBQkFBQUFBQUFBQUFBQUlBQWdBQUVBQUFBT0FLNEFBUUFBQUFBQUFBQkNBSVlBQVFBQUFBQUFBUUFGQU5VQUFRQUFBQUFBQWdBR0FPa0FBUUFBQUFBQUF3QWtBVG9BQVFBQUFBQUFCQUFKQVhNQUFRQUFBQUFBQlFBT0Fac0FBUUFBQUFBQUJnQUxBY0lBQXdBQkJBa0FBQUNFQUFBQUF3QUJCQWtBQVFBS0FNa0FBd0FCQkFrQUFnQU1BTnNBQXdBQkJBa0FBd0JJQVBBQUF3QUJCQWtBQkFBU0FWOEFBd0FCQkFrQUJRQWNBWDBBQXdBQkJBa0FCZ0FXQWFvQVF3QnlBR1VBWVFCMEFHVUFaQUFnQUdJQWVRQWdBRkFBTGdCS0FDNEFJQUJQQUc0QWJ3QnlBR2tBSUFCM0FHa0FkQUJvQUNBQVJnQnZBRzRBZEFCR0FHOEFjZ0JuQUdVQUlBQXlBQzRBTUFBZ0FDZ0FhQUIwQUhRQWNBQTZBQzhBTHdCbUFHOEFiZ0IwQUdZQWJ3QnlBR2NBWlFBdUFITUFaZ0F1QUc0QVpRQjBBQ2tBQUVOeVpXRjBaV1FnWW5rZ1VDNUtMaUJQYm05eWFTQjNhWFJvSUVadmJuUkdiM0puWlNBeUxqQWdLR2gwZEhBNkx5OW1iMjUwWm05eVoyVXVjMll1Ym1WMEtRQUFTUUJqQUc4QWJnQnpBQUJKWTI5dWN3QUFhUUJqQUc4QWJnQnBBR01BQUdsamIyNXBZd0FBUmdCdkFHNEFkQUJHQUc4QWNnQm5BR1VBSUFBeUFDNEFNQUFnQURvQUlBQlZBRzRBZEFCcEFIUUFiQUJsQUdRQU1RQWdBRG9BSUFBeEFDMEFOd0F0QURJQU1BQXhBRFFBQUVadmJuUkdiM0puWlNBeUxqQWdPaUJWYm5ScGRHeGxaREVnT2lBeExUY3RNakF4TkFBQVZRQnVBSFFBYVFCMEFHd0FaUUJrQURFQUFGVnVkR2wwYkdWa01RQUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F4QUM0QU1RQWdBQUJXWlhKemFXOXVJREV1TVM0eElBQUFid0J3QUdVQWJnQXRBR2tBWXdCdkFHNEFhUUJqQUFCdmNHVnVMV2xqYjI1cFl3QUFBQUFEQUFBQUF3QUFBQndBQVFBQUFBQUFQQUFEQUFFQUFBQWNBQVFBSUFBQUFBUUFCQUFCQUFEZzN2Ly9BQURnQVAvL0lBRUFBUUFBQUFBQUFBRUdBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd0FBQUFBQUFQK0RBRElBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUJBUUFBUUVCREc5d1pXNHRhV052Ym1sakFBRUNBQUVBT3ZqekFQajBBZmoxQXZqMkEvZ1ZCQjRLQUJKZmk0c2VDZ0FTWDR1TERBZUtKdm0yK2JVRkhBUU5EeHdBQUJBY0Jjd1JIQUF1SEVWV0VnRGNBZ0FCQUFFQUFnQURBQVFBQlFBR0FBY0FDQUFKQUFvQURBQU9BQkFBRWdBVUFCWUFHQUFhQUJ3QUhnQWdBQ0lBSkFBbUFDZ0FLZ0FzQUM0QU1BQXlBRFFBTmdBNEFEb0FQQUErQUVBQVFnQkVBRVlBU0FCS0FFd0FUZ0JRQUZJQVZBQldBRmdBV2dCY0FGNEFZQUJpQUdRQVpnQm9BR29BYkFCdUFIQUFjZ0IwQUhZQWVBQjZBSHdBZmdDQUFJSUFoQUNHQUlnQWlnQ01BSTRBa0FDU0FKUUFsZ0NZQUpvQW5BQ2VBS0FBb2dDa0FLWUFxQUNxQUt3QXJnQ3dBTElBdEFDMkFMZ0F1Z0M4QUw0QXdBRENBTVFBeGdESUFNb0F6QURPQU5BQTBnRFVBTllBMkFEYUFOd0EzZ0RnQU9JQTVBRG1BT2dBNmdEc0FPNEE4QUR5QVBRQTlnRDRBUG9BL0FEK0FRQUJBZ0VFQVFZQkNBRUtBUXdCRGdFUUFSSUJGQUVXQVJnQkdnRWNBUjRCSUFFaUFTUUJKZ0VvQVNvQkxBRXVBVEFCTWdFMEFUWUJPQUU2QVR3QlBnRkFBVUlCUkFGR0FVZ0JTZ0ZNQVU0QlVBRlNBVlFCVmdGWUFWb0JYQUZlQVdBQllnRmtBV1lCYUFGcUFXd0JiZ0Z3QVhJQmRBRjJBWGdCZWdGOEFYNEJnQUdDQVlRQmhnR0lBWW9CakFHT0FaQUJrZ0dVQVpZQm1BR2FBWndCbmdHZ0FhSUJwQUdtQWFzQjdRSDJBZnN4TWpNME5UWTNPRGt4TURFeE1USXhNekUwTVRVeE5qRTNNVGd4T1RGaE1XSXhZekZrTVdVeFpqSXdNakV5TWpJek1qUXlOVEkyTWpjeU9ESTVNbUV5WWpKak1tUXlaVEptTXpBek1UTXlNek16TkRNMU16WXpOek00TXprellUTmlNMk16WkRObE0yWTBNRFF4TkRJME16UTBORFUwTmpRM05EZzBPVFJoTkdJMFl6UmtOR1UwWmpVd05URTFNalV6TlRRMU5UVTJOVGMxT0RVNU5XRTFZalZqTldRMVpUVm1OakEyTVRZeU5qTTJORFkxTmpZMk56WTROamsyWVRaaU5tTTJaRFpsTm1ZM01EY3hOekkzTXpjME56VTNOamMzTnpnM09UZGhOMkkzWXpka04yVTNaamd3T0RFNE1qZ3pPRFE0TlRnMk9EYzRPRGc1T0dFNFlqaGpPR1E0WlRobU9UQTVNVGt5T1RNNU5EazFPVFk1TnprNE9UazVZVGxpT1dNNVpEbGxPV1poTUdFeFlUSmhNMkUwWVRWaE5tRTNZVGhoT1dGaFlXSmhZMkZrWVdaaU1HSXhZakppTTJJMFlqVmlObUkzWWpoaU9XSmhZbUppWTJKa1ltVmlabU13WXpGak1tTXpZelJqTldNMll6ZGpPR001WTJGalltTmpZMlJqWldObVpEQmtNV1F5WkROa05HUTFaRFprTjJRNFpEbGtZV1JpWkdOa1pHUmxNUzR4TGpGRGNtVmhkR1ZrSUdKNUlGQXVTaTRnVDI1dmNta2dkMmwwYUNCR2IyNTBSbTl5WjJVZ01pNHdJQ2hvZEhSd09pOHZabTl1ZEdadmNtZGxMbk5tTG01bGRDbFZiblJwZEd4bFpERkpZMjl1Y3dBQUFBR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBRUlBUXdCRUFFVUFSZ0JIQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBYmdCdVFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQWNjQnlBSEpBY29CeXdITUFjMEJ6Z0hQQWRBQjBRSFNBZE1CMUFIVkFkWUIxd0hZQWRrQjJnSGJBZHdCM1FIZUFkOEI0QUhoQWVJQjR3SGtBZVVCNWdIbkFlZ0I2UUhxQWVzQjdBSHRBZTRCN3dId0FmRUI4Z0h6QWZRQjlRSDJBZmNCK0FINUFmb0Ird0g4QWYwQi9nSC9BZ0FDQVFJQ0FnTUNCQUlGQWdZQ0J3SUlBZ2tDQ2dJTEFnd0NEUUlPQWc4Q0VBSVJBaElDRXdJVUFoVUNGZ0lYQWhnQ0dRSWFBaHNDSEFJZEFoNENId0lnQWlFQ0lnSWpBaVFDSlFJbUFpY0NLQUlwQWlvQ0t3SXNBaTBDTGdDUUFpOENNQUl4QWpJQ013STBBalVDTmdJM0FqZ0NPUUk2QWpzQ1BBSTlBajRDUHdKQUFrRUNRZ0pEQWtRQ1JRSkdBa2NDU0FKSkFrb0NTd0pNQWswQ1RnSlBBbEFDVVFKU0FsTUNWQUpWQWxZQ1Z3SllBbGtDV2dKYkFsd0NYUUplQU9BQ0FBRUFJd0JNQUhzQXZBRDhBU0FCUkFGb0FkOENBUUl0QWxNQ2ZRS21Bc1FDM1FNQUF5QURPd05lQTM4RHJRUklCSGdFeHdUM0JWMEZwd1hUQm5FR3RRY0FCM0FIakFmVUIrOElGd2lQQ1JjSmhRbmNDdkVMVEF1ekRCRU10QXpCRE5RTTVBenlEV3NObmczS0RlVU9CQTRqRGo0T1hnNTFEdFFQRGcrV0Qvc1FCeEE5RUhNUTd4RVJFVFFSVmhGMkVpa1NXQktFRXF3UzNSTXBFMjRVQWhRckZGVVVjQlRORlJBVnFCVzdGZElXRkJaSkZxSVd1aGJhRnZrWEd4ZGRGK2dZS1JoTEdHMFlrQml3R09nWlNobTlHZHNhTGhwU0duNGF0UnRIRzFZYlp4d1dIRDBjdWh6OEhTTWRnUjN0SG1JZWxoN0ZIdmdmUFIreElEUWdheUNQSUxNZzF5RXhJWVloclNLWkk0a2tmU1M1SlBVbENTVkhKWUlsenlZWkptQW01U2NiSjVJbnBpZXpKK01uL1NnVktDb29SU2haS0lJb255bFJLVndwdVNuOEtsRXFvQ3NzSzFBcjl5eE1MSmdzOVMxTkxXb3RreTM3TGs4dWpDN3RMNGt2K0RENE1XNHh6ekg2TWljeVVUS2pNd2N6YlRPK00razBVelNITk1rMCtqVXJOWWcxc1RZY05tODJrVGJJTnY4M096ZUdOOGs0SHppQ09SYzVTam01T2ZvNkpqck5Pdlk3S3p1Sk82RTdzVHY0UEdFODBqMGNQV3c5blQzR0xvdXorRm16QWJPejk0U3pBN01XOTlUNHFmdlVCclA4Z1JYNFdmZUUvRmtIRG92djkxenY5MXp2QWZsUTd3TVU0UGZBK1ZBVklBcjhKUHRjRlNmOEpDZjRKQ2NIOTF6M0tnVU9pKy8zWE8vM1hPOEIrVkR2QXhUZzk4RDVVQlVnQ3Z6cysxd1YrMXo3S3ZkYyt5cUw3L2draTR2di9DU0xCUTc0N084QitJajNYQVAzOHZsUUZmdFYrekg3TWZ0Vjl4NzNCUGNFOXg3M0h2Y0Urd1Q3SGg5Wkp3ZjNYUHRjOTF6M1hDZUxpNzBGOTFYN01mY3grMVVlRHZqczd3SHY5MXdEK0ZiNVVCWDdWZnN4K3pIN1ZSOVpKd2YzWFB0YzkxejNYQ2VMaTcwRjl4NzNCUGNFOXg3M0h2Y0Urd1Q3SHZkVit6SDNNZnRWSGc2TDcrL3Y3Ky92N3dINVVBUWhDdjFRKzF3VklncjlVUHRjRlNFSy9WRDdYQlVpQ2c2TDcrL3Y3Ky92N3dINVVBUWhDdjIwKzF3Vklncjg3UHRjRlNFSy9iVDdYQlVpQ2c2TDcrL3Y3Ky92N3dINVVBUWhDdnpzKzF3Vklncjl0UHRjRlNFSy9PejdYQlVpQ2c2TCtiUUQrQ1Q1VUJWR2kwcDRVbXdJOTliN2Z0YjNkUVZQcjBTaVFJc0krNmY3QkJVL1Fsb21pL3NHaTNLTmRJOXpDUGZLOTNJRitBajNFUlg3RHZ3TDkyNkxCWk9yazZ5THJvdjJZT3RHMHdqOGJQdldGZnREK3hFRnd2c0Y4elgzRkhRSXQvZFdGY243V1FYM0daZjNCZGZMOXdFSUR2YWdkZ0gzWE84RDkxejV0Qlg4aVB0Y0IvZVIrOEQzaS9mQSsxeUxpL2lJQlE2Z2R2bFE3d0dMOThEM1hQZkFBL2drK2JRVkl3b25KeFgzWFB2QTkxd0crOEQ3d1B2QTk4RDNYSXNGRG92M3dQZGM5OEFCK1ZEdkEvZ2srYlFWSXdvbkJQdGM5OEQ3WFB2QSsxd0grOEQzd0FVT2kvZkE5MXozd0FHTDd3UDRKUG0wRlNNS0p3VDN3UHZBKzhEN3dJdjNYUHZBaTR2M1hQZkFpd1VPaSs4QmkvZkE5MXozd0FQNEpQbTBGU01LSndUM3dQdkErMXlMaS92QSsxeUxpL2ZBKzF5TEJRNzN3TzhCOThENDdCWDd3UHVSOThEN2k0djNYUGlJaTR2di9JaUxCUTczd084QitJajQ3Qlg3WFB5SUovaUkrMXdIOThEM2tRVU85cUIyQWZkYzkxd0Q5MXo1dEJYOGlQdGNCL2ZEKzhEM3ZmZkErMXlMaS9pSUJRNzN3UGRjQWZmQStWQVYrOEQ3dy9mQSs3Mkw5MXo0aUl1TDkxejhpSXNGRHZmQTkxd0IrSWo1VUJYN1hQeUkrMXo0aVB0Y0IvZkE5OE1GRHZhZ2RnSDNYUGRjQS9lOStiUVYrNzM3d1BkY2k0djhpUGRjaTR2NGlQZGNpd1VPOXFCMkFmZGM3d1AzaS9tMEZmdUwrOEQzWEl1TC9JanZpNHY0aVBkY2l3VU9vSFlCaSsvdjcrL3Y3KzhEK0NUNXRCVWtDdnZBSnhYODdPLzQ3QWYzd0NjVkpRcjlVQ2NWKzF6djkxd0hEb3Z2NysvM1hPL3Y3d1AzQ1Bqc0ZVTkRYeWlMK3dLTCt3SzNKTk5EQ05QVEJWWEJhZGVMM292ZXJkUEJ3UWo0aE5NVlEwTUZ3Vld0UTRzNGl6aHBQMVZWQ05OREJkUFR0L0tMOXdLTDl3SmY3a1BUQ1B3OSt5QVZaMmQwV1l0VWkxU2lWcTluQ05EVEJYbWRnYVdMcDR1bmxhS2RuUWozYWRJVlJrUUZuWG1WZEl0dmkyK0JjWGw1Q05CREJhK3Zvc0NMd292Q2RMeG5yd2dPTHFCMitDVDRKQUdMK0NRRDkxejV0QlVtQ2lmOGRSV0wrOVB2Nys4bmkvZlRCV3VBYW9Ob2kyaUxhWk5zbGdnT2krLzQ3TzhCaSsvNDdPOEQrQ1Q1dEJVbkNpY0V6WXZIZHJ4b0NQdzMvRGNGYUx4Mng0dk5pL2M2OXhyM0d2YzZpd2ozaVBzUkZhNWFvRStMU1l2N092c2EreHI3T290SmkwK2dXcTRJRG92dkFZdnY3L2RjNy9kY0EvbFFCUDFRK2JUdi9WRDQ3QWY0SkJiOGlQZGMrSWdIL0lqN1hCWDd3UGRjOThBSERvdnY5OER2QWUvdjcvZGM3KzhERkRqNElmbTBGWDZLZm9TQ2dBajdmdnV0K3hTTGl5ZnZpNHY4QWdWNW0zdWRIdmlvQnAyYm01MGYrQUx2Ny9zVUIzQ3MrMmoza0ltTmdKU0JrSDZLQ0k3N0ZCWDNKUHRBKzdTTEJZWDdYQlVvQ3ZmQUZpZ0tEdS92K0NUdkVvdnYrSWozWFB0Yzd4UG9sUGxRRllXSWlJVWYvTm9IaFk2SWtSNzVQZ2FSam82UkgvZFRCeFB3Ny9kY0JoUG9KL2RTQnBHSWo0VWUvT01uRmZpSS9DVDhpQVlPNy9qc0FaVDVVQldGaUlpRkgvemFCNFdPaUpFZStUNEdrWTZPa1IvM1UrLzNYQ2YzVWdlUmlJK0ZIZzRuOThENEpPOEI5MXp2OTF6dkErZjVIaFZ2b1hTbkhvMkxqNHlOaXdpOSt5RUdnbnI3QS90cVhUMTdjWGxwaTEyTFpKcGxwWEdsY2JGOHNvc0krSlFHc1l1dm02V2tDSTRHcGFXYXNZdXlpN2g1cm51bFhkbjdBL2RxZ3B3STl5RzlCNmVob2FlbmRhRnZIL3lJaTRhTGhvdUlpd1Z4ZUhCMEgvZ3NXUldMK3phUmdRV0xpOHI3RDhNaUNQeFdCc1AweXZjUGk0c0lrWldMOXpZRkRvdnY3L2pzQWZnaytiUVYrd0l4TWZzQ0g0c2pWeTA1UjJKcGNsdUxWd2o1dEFhTHYzSzdZcTA1ejFmcGkvTUk5d0l4NWZzQ0hpZjlVQlZVdUY3Q3dyaTR3aDRPOXFCMkFmY3E3d1AzS3ZtMEZZdjdqa0RXUUVEM0t2c3EreXI3S3RaQTF0YUwrNDY5aS9meTk0NzdkZmN0OTNYM0ovdnk5NDRGdmZzcUZmY3FKL3NxSndVbkJQY3FKL3NxSndVT2krLzN3Ty8zWE84UzcvZGM5MXozWENmM1hCUDArYlFFSndmQ3VGNVVIL3drQjFSZVhsUWVKL2k2Qi9jZTl3VDNCUGNlSDR2dlVPQTJzd2dUK0thdG5MZUx1Z2ozQWpIbCt3SWUrMXduRmU4R3dyaGVWRlJlWGxRZkp3WW5CUGNxQmhQMDNzNUlPRGhJU0RnZit5b0dEdmFnZGdIM3dQbTBGZnZBL0lqM1hJdUwrOEQzd1BpSSsxeUxCUTZMN3dHTDcvaUk3d1B2K2JRVmVJZ0ZaSU5zYklOa0NJaDRpL3k2QlRqT1NONGUrTHJ2L0xvR2IzV2hwNmVob2FjZitMcjR1Z2FuZGFGdkhsbjd3QVluN3ljbmkvZkFCUTR1b0hZQmkvZ2tBL20wQkl2OXRQZGM5MXozWFB0Y2kvbTBCUTc1VU84QitiUUVJUXI5dFB0Y0ZmempCNFdPaUpFZSthSUdrWTZPa1IvNDQvdTlKUHRmOGdjT2kvZGM3L2ZBNys4QjkxenY5MXp2QS9mQStiUVZWRjVlVkI4bisxTUhoWWlJaFIvN2hRZHZvWFduSHZsUUJxZWhvYWNmOTRVSGtZaU9oUjc3VSs4R3dsNjRWQjc3WENjVjkxd24rMXdHKzhEOEd4WDdYQWVGam9pUkh2bWlCcEdPanBFZjkxd0hlNFY3aUhtTENQMVFCbm1MZTQ1N2tRZ085b3Z2OTF6djk4RHZFdS92UGUvM1J1OFQ5UGZBK2JRVlRZdFZjV2xnYVdGN1U0dFJpMGFjVTVOWkNQc1JKd1lUN1BjT0JvQmVjVmRHUmdoN2Y0djdEdmpzaTR2di9IK0xCY3ZVcnM2Wnh3ajNSdS83UUFZVDlJUFBkOE9Mdm91eWxxMmNvSnlnbjVXdWk3S0xvWUNaZlpsOWxuV0xaQWp2Qm92RmU3OW1zQWhtc0ZlYlVZc0lEaWZ2K0NUdjcrOEJpKy92Ny9nazd3T3QrVkFWZUlWOGRZdDNDSXVKaS8xUUJXK2hkYWNlK1ZBR3A2R2hweC81VUFlbmRhRnZIdjFRaTRhTGg0dUlpd1gzQkNjVktRcjNYQmIzd0Fhbm9YVnZiM1YxYngvN3dBWnZkYUducDZHaHB4LzdqdnRjRmZqcy9DVDg3QVlPb0hZQjl4cjNuZ1A1ZlBteEZZV0kvQXY3bm41OGYzSUYwM1RDVktKRENLU1htcGozbnZnTEJZNlBqSStIandoZnR3WDhlUHdlRlVGUlQwRWZpeWhWTkR0ZHNuVzZmN3VMQ1Bjbjl3djNDL2NuMVUvSFFSOE9odTcxN3dINExmZkFBNVQ0VnhXTGVaZDNtNFFJOXdoVEJZSjdnWHFGZWdoR2k0YUxCVzkxYzNGdm9YV25INUNMdllzRmkzU05kWTkyQ0QxakJYYUdlM1NMZG90dm9YV25pNVdMbUpDVGtRak5yZ1dqWGJGa3RIS3VucU9raTZjSWkvY2tpNUNMajR2ZEJZeU9pNUNMam91T2k1Q0tqcENpb0p5aml3aW5vWFZ2SDRzMGk0YUxob3VGaTRhTGg0djdHd1dMY0tSeHJuaTBvN0d6bzdrSXpHZ0ZrNFdZaHBXTHA0dWhvWXVuaTZCN29uYVFDRDJ6QlkrZ2phR0xvZ2k5QnFlaG9hZW5kYUZ2SDBjR2haeUJuSUtiQ1BjSHd3V2FrNWVmaTV5THAzV2hiNHVDaTRXSWhZY0kreGRKYjZFRjJkNDk5enY3QzR2N0M0czkrejNhT2dodWRmc1h6UVdFajRDT2c0dHdpM2h3aTNRSUR2anM3d1A0N1BsUUZmenM1Z2VSam82UkgvamFCNUdJam9VZS9IWDdXUlY0aVB0S2l3V0ZpSWlGSC90S0I0V09pSkVlNW92eSs2UUZsbktzZ0tTV3BKYVdySUNrQ0VEM1JnV09tWldUbW9zSWk0NzNqdnNSaS9pSUJRNkw3Ky92NysvM1hPOEJpKy92NysvdjcrOERsUG0wRllXSWlJVWYvYUlIaFk2SWtSNzVQZ2FSam82UkgvbWlCNUdJam9VZS9PTW5GZmlJKzF6OGlBWW5CTzhuSndiM1hPOFY3eWNuQnZkYzd4WHYrOEFuQnZ3azd4WHZKeWNHOTF6dkZlOG5Kd1lPaSsvdjcrL3Y3L2RjQVl2djcrL3Y3Ky92QS9tMEJQdGMrVkQzWEFmOVVQdkFGZngvQjRXT2lKRWUrVDRHa1k2T2tSLzRmd2Y4N0NjVjd5Y25CdmRjN3hYdkp5Y0c5MXp2RmU4bkp3YjhKQ2NWN3ljbkJ2ZGM3eFh2SnljR0RvdnY3L2RjNy9mQSs4RHZFb3Z2NysvdjkxenY3eFB2K0MzNXRCV0ZpNGVIaVlZSUxmdEtCUlBmaVlhSGg0V0xDUHNoQmpoSVNEZ2YvRTBIaFk2SWtSNzVvZ2FSam82UkgvamFCNUdJam9VZU9RYUZpNGVQaVpBSUxmZEtCUlB2aVpDSGo0V0xDQlBmL0UzN3dCV25vWFZ2YjNWMWIyOTFvYWNmcDZHaHB4NFQ3L2Z5RnZjQzVUSDdBdnNDTVRIN0F2c0NNZVgzQWgvM0F1WGw5d0llSndRcUNnNzQ3QVQ0SlB3aytDVDRKQVVPTHFCMkFmZ2srYlFWL0NUOEpQZ2svQ1FGRGk2Z2RnSDV0QVNML2JUNEpQZ2tCUTc0SlBqc0Zmd2svQ1Q1dElzRkRvdnY3L2ZBaSs4Uzk4anY5MXp2RTdqNHVnUnZvblNuSG8yTGpveU5pd2ozS291VmNnV21PS1kzcGpnSUU5aVBmcHQvbVlzSTkvSUdtWXVjbDQrWUNOejNqZ1VUdUkrWWhwZDlpd2dUMlB4UWkyWFRCUk80aEpwM21IcUxDUHRjaTRlTGhvdUlpd1Z4ZDNCMEgvZjYvRllWS3dyM3dCWXJDZzZnZHUvNEpPL3ZBWXYzWE8vNGlBUDVVQVNML0lqdjcrK0xpL2ZBOThDTGkrOEYrMXo3WEJYOEpQZ2tCKzhuaS9pSUJRNzVGZmxRRmZzRit3djdDdnNHK3dqN0NWZThXTDFadmdqN0lmc2gwMFFGMUVIV1E5SS9DUGlCK0lFRkR2Y3ErT3dWK3lyN0t2Z2svQ1Q0SlBnayt5cjNLdnVPKzQ0RkR2YWdkZ0g0SlBtMEZmd2svQ1Q0SlB3azl5cjNLdnVPOTQ3M2p2ZU9CUTcyb0hZQjl5cjV0Qlg3S3ZzcTk0NzdqdnVPKzQ3M0t2c3ErQ1Q0SkFVTytDVDQ3Qlg4SlB3azl5cjdLdmVPOTQ3M2p2dU85eXIzS2dVT2kvbTBBZmdrK2JRVkl3cjNYUHRHRmRORCs5YjcxdnRBOTBEVDArOG5CUTZMK2JRQmkvbTBBL2drK2JRVkl3cjdLdnRHRlN3S0RvdjRpTy92QVl2djkxenY5MXp2QXhRNDkvTDV0QlZ2ZFhWdkgxbEFCMzJBZ0gwZlFQZkExZ2VaZ0paOUhrQzlCcWQxb1c4ZSs5a25GWDJBZ0gwZi9SNEhmWmFBbVI3NUhnYVpscGFaSC9rZUI1bUFsbjBlUVB0Yy9JajNYQVlPaSsvNDdPOEJpKy8zanUvM2p1OERGRGo0SlBtMEZTY0tKd1F0Q2xrbkZZdjdjcHQvQmFodXAyNm1iUWpUMHdWeW9YT2lkS01JOTBrSERxQjIrSWozd0FHTDk4RHY3Ky8zWEFQNFZ2bTBGZnNOaXlFMWRQc0crd0tMTVRHTCt3S0xacFpxbkcwSTk2UzlCdDdPenQ3ZXprZzRIbG4zVXdlUm00NmJpNTJMekdITFVhQUl2UWYzSHZzRTl3VDdIaDU3L0NRVmVJVjhkWXQzQ0l1Smkvc3EreXFMOTF6N1hQZGM5MXo3S291TDl5cUxqQVduZGFGdkhvaUxpSXFJaXdpSEJnNmdkZ0g0Sk84RCtGYjV0Qlg3RFlzaE5YVDdCdnNDaXpFeGkvc0NpMmFXYXB4dENQZHlpL2RjOTF6M1hQdGM5eUdMQlpHYmpwdUxuWXZNWWN0Um9BaTlCL2NlK3dUM0JQc2VIdnhXQlB1Tys0NzNYSXVMV1FWdm9YV25wNkdocHg2OTkxd0hEdS80N0FINFZ2bFFGUzRLRG92NDdBSDNqdm0wRmZzZSt3VDdCUHNlSDR0a2xHbWJhcW1oclpxdmxjTDNFUGNUNFBjamkxM0hRN001aXdqM1hQdGNGUzRLRHZpSStWQVYrOEQ4N08rTDk4RDQ3QVg4aUNjVkovdGM3L3RjNzRzbjkxenY5MXdGK0NRVzcvdGNKL3RjNzR2djkxd245MXdGRG92M2p2ZkE5NDRCaS9lTzk4RDNqZ1AzOHZtMEZWbjdDMjkvK3d1OVEwTzkrd3QvYi9zTFdZc245d3RabDI5Wit3dlRRL2NMdmFkL3Zmc0xCZStMdmZjTHA1ZjNDMW5UMDFuM0M1ZW45d3U5aSsvN0M3MS9wNzMzQzBQVCt3dFpiNWNGV2ZjTEJWbjdqaFhlemtnNE9FaElPRGhJenQ3ZXpzN2VIdzZMNy9pSTkxd0IrYlFFTHdyODdQdkFGZmRjKzF6M1hQZGNCZnpzL0NRVklRb09vSFlCaSsvNGlQZGNBL20wQkNRSytJZ1dNQXI3d1B0Y0ZmdGMrMXozWFB0Y0JRNmdkZ0dMOTF6NGlPOEQrYlFFTUFyNGlCWWtDdnlJKzF3Vmkvd2s5MXozWEFVT2kvZGMrSWp2QWZtMEJDRUsvQ1Q3d0JYN1hQdGMrQ1NMQmZ6c0p4VXZDZzZMNysvdjcrL3Y3d0dMNysvdjcrL3Y3d1AzS3ZsUUZUaElTRGc0emtqZUg3MG5XUVk0U0VnNE9NNUkzdDdPenQ0ZnZlOVpCempPU043ZXpzN2Uza2pPT0I1Wjc3MEczczdPM3Q1SXpqZzRTRWc0SDFrbnZRZmVTTTQ0SGljRXA2RjFieDlaV1FkdmRhR25wNkdocHgvNEpCYW5vWFZ2YjNWMWJ4OVp2UWFub2FHbkh2dU8rMXdWN3ljbkJ2c3FKeFc5V1FadmRYVnZiM1docDZlaG9hY2U5L0lXdlFhbm9YVnZiM1YxYjI5MW9hY2ZEcUIyOTF6NDdBR0wrYlFEK2FzRS9Ob0hoWTZJa1I3NDQ0djNYUHRjaS9tcUJaR0lqNFVlL2FJR2hvZUhoaDhPaSsvNDdPOEJpKy80N084RCtDVDV0QlVuQ2ljRUxRcjNYQ2NWKzhBbkovdkE5OER2QlNmM0toVXBDZzZMNy9qczd3R0wrQ1Qzd084RCtDVDV0QlVuQ2ljRTl6cjNHdnNhK3pyN092c2EreHI3T2g4T2krL3Y3L2RjNysvdkFmbFE3d1A1dEFRaEN2MjArMXdWSi9pSTd3ZjhpUHZBRlNFSy9iVDdYQlVpQ3ZjcUZpc0tEdS92Ny9kYzcrOEJpKy92N3dNVTRLVDVVQlY5Z0lCOUgwRDV0TllIbVlDV2ZSNzltL3RjRmZ3TEIzMldnSmtlK1lJR21aYVdtUi80Q3dmOVVQdGNGZThuSndiM1hPOFY3eWNuQmc2Z2R1L3YrQ1R2QWUvditDVHZBKy81dEJVbkp5ZnYvSWo0aUNmdjcrL3ZKL2hXQisvdldiMG5KL3hXaTR2dkJmdGNCUGZ5aS92eSsvSUYrQ1Qzd0JYNzh2dnlCdzZMNysvM1hJdnZpKy92N3hLTDcvZGM5MXo3S3UrOTcrL3ZFNnhBK0NUNXRCWDdjUHRJKzBqN2NQdHc5MGo3U1BkdzkzRDNTUGRJOTNBZjkzRDdTUGRJKzNBZUp3UXRDaE9kUUNjRU1RcjdYUHNvRll0L2tudVVnd2psTUFVVDNrQ0ZjZ1ZVdUY3Q3dyaTR3c0pldUZRZWNvVXc1UVdEbEh1U2Y0c0lnNHVJaTRpTEJYaUZmSFdMZHdnVHJNRDM4cnNWTVFvT2krOEI5OEQzWEFQM3dQbTBGZnZBKzF3SDk4RDd3UGZBOThEN1hJdUw5OEFGL0lqOVVCVWhDZzZnZHZsUTd3SDN3UGRjQS9tMEJDRUsvQ1Q3WEJYN3dQdkE5MXlMaS92QTkxeUxpL2ZBOTF5TEJRNzNYUGxRRmZ0Yys4RDNYUHZBK095TGkvanNCZnhXUFJVc0NnNzQ3TzhCaSsvditDVHY3d01VY1BnaytWQVYrM0Q3U1B0SSszQWY3d2IzT3ZjYTl4cjNPdmM2OXhyN0d2czZIdThHOTNEN1NQZEkrM0FlVVB0bEZUcHlUeitMTVFqN0F1VXg5d0wzQXVYbDl3SWVpK1ZQMXpxa0NGQXpCUTZMNysvM1hQdGM3Ky92RW92djcrOFRuUG0wQlAyMCtWRDRKQWNUelB3aytDUUc3eFlUblB2QTk4QUgvT3p2RmU4bkp3WW5CTzhHRTd3bkp3Y25CQlBNTWdvTzlvdnYrQ1R2QVl2djcrL3Y3d01VT1BkYytWQVZKMEFIUjFKU1J4OVpCNHRIdGxMTmV3ajNsVW9GbVllZmNvdDhDRmtIZllDQWZSNzdqZ1ovaTRLT2g0NEk2U2NuQjR0cG9HK2llNko3cDRXcGl3aldKKy92MWdiUHhNVFBINzBIaTg5Z3hFbWJDUHVWekFWOWozZWtpNW9JdlFlWmxwYVpIdmVPQnBlTGxJaVBpQWd0Nys4SGk2MTJwM1NiZEp0dmtXMkxDRUR2Qmc2TDk4RDNYUGZBQS9sUUJETUs5MXdXTXdvT2kvZkE5MXozd0FQM3dQbFFGVFFLK0lqNDdCVTBDZzd2OThEM1hPOFNpL2ZBKzhEditDVDN3UHZBN3hQZzk4RDVVQlUxQ2hQUSsxd0dFK0QzQStUazl3TWVFOGo0aU84Vk5Rb1R4UHRjQmhQSTl3UGs1UGNESGc3djcvZGM5OEFTaS9mQUorLzNYUGZBSis4VDRQbFFCUHZBQnhQUTkxd0dFK0EyQ2hQSTkxd1crOEFIRThUM1hBWVR5RFlLRHZaMTd3R0w3L2VPOTQ0RDk4RDV0QlZwYVFXQWdQdVQrNWVMKzI0SSt6bjNHL3NiOXpuM09mY2I5eHYzT1I2TDkyNzdrL2VYZ0pZSSswejhTaFdub1hWdlZMaGV3cWVoZFc5dmRYVnYrd0l4NWZjQ3A2R2hweDhPaS9kY0FmZ2srYlFWL0NUOGlQbTBpd1g5dENjVkx3b085cUIyQWZmQStiUVYrOEQ3d1Bqc2l3WDg3UHRjRmZmQSs4RDN3UGZBQlE3M3dQZGNBWXYzWE8vM1hPLzNYQU1VY1BpSUJEY0s3eFkzQ3U4V053b08rVkFFaXlmNEpQdGMrQ1QzWEl2dkJmMjArMXdWL0NUNXRQZ2tCL3drKzF3RkRxQjJBWXZ2K096dkEvZ2srYlFWL0NUN1hJdjg3UG0waTR2NDdBWDhKT01WOThEN0tvdjdVUHZBK3lyN3dQY3FpL2RRQmU5bEZZc245MXduOTF6dmkrOEZEaWZ2NysvdjcvZGM3d0gzWE84RCtPejVVQlg3VG92N0xmc1VYdnRBQ1B0VGkzSW45MXlMQll0cGsybVRhd2o3V1l0NEovZVVpd1hSK3dyM0V6bjNKNHZVaTgrZ3hxNEk5dzRIVmx0R2JUMkxNb3M5c2xUSUNQZHlpNXZ2KzcyTEJZQ3JnNnVMcndqMzRvdWI3L3ZmaXdXMDl3ajNBZC8zRjR2Tmk4ZDJ2R2dJbS9VRlVxcEtua2FMQ0E2TDcrL3Y3Ky92N3dHTDcrL3Y3KzhERkE3NVVBUW4rVkR2Qi8xUSsxd1ZKL2lJN3dmOGlQdGNGU0VLL2JUN1hCVW43KzhIN3hZbjcrOEg3eFluNys4SERvdjNYUGlJN3dINXRBUWhDdnpzKzF3VjkxejdYUGRjOTF3Ri9PejhKQlV2Q2c2Z2RnR0w3L2lJOTF3RCtiUUVKQXI0aUJZd0N2enMrMXdWaS93azkxejNYQVVPb0hZQmkvZGMrSWp2QS9tMEJEQUsrSWdXSkFyN1hQdGNGZnRjKzF6M1hQdGNCUTZMNy9pSTkxd0IrYlFFTHdyOEpQd2tGZnRjKzF6NEpJc0YvT3duRlNFS0RvdnYrT3p2QVl2ditPenZBL20wQlAyMCtiVDNYQ2NuL096NDdPL3ZCL2RjRnZjcSt5cjdqdnVPN3lmM2p2ZU85eXI3S292NEpBVU83Ky92Ny9kYzd3SDN3TzhEK0NmNVVCWDdrZnNxKzhDTGkvY3ErOEQza2ZlTDl5cjN3SXVMK3lyM3dQdUxINGduRlRnS0p3UlVYbDVVVkxoZXdzSzR1TUlmaTVXSWxJaVVnM3Q3ZjNlTGI0dDFvWXVuaTUrWG01dVRnbzZDam9HTENBNzRLL2ZmK1ZBVmVJVjdkWXQzaTMrU2U1U0RDTXBNL0F2OEVZdjdwUGVoaS9nUitCSEpTZ1dUZ0o2Q21JdW5pNkdoaTZlTG1JT2NnWk1JTHVuTXpRWEZ4WXZyVWNWU3hDbUxVbElJU1VvdDZBV0RsSHFUZjR1SWk0ZUxpSW9JaUFiM0JmdHZGZmNYK3hmNzBQdlEreFQzR0FVT2kvZ2tBWXYzd0FQNXRBVDl0UGxRK0NUOEpQZ2tCKzhXKzhEM3dBY09vSFlTaS9na0ovZ2tFOEQzWFBtMEZlLzdYUHZBSjR2N1hJdjdYUGRjSjR1TEtmZGE5Nzd4aS9kY0NQZGMrMXp2aXg3M3dQdkFGUk9nNy90Yys4QW5pL3RjQ1BmQUJyUEh2ZmNxOTF6N1hPK0xIdzZnZGdHTDd3UDV0QVFrQ3U4Vy9DVDNYQ2Y0SkFmN1hQZFo5MXozWC92QWk0dnZCUTR1b0hZQjl5cjV0Qlg3S3Z2QTkxeUxTZnRjK3hxTDcvdkE5OEQzd1BzcWkvY3E5OEQ3WEl2djkxd0ZEb3Y0aU8vM1hQdGM3eElUd1BtMEJQdGNCeE9nK2JUdi9JZ0dFOER2Qi92QSs4QVYvRllIYjZGMXB4NzVVQWFub2FHbkgvaFdCdzZnZHZmQTd4S0w5OEQ3WE8vM1hQZkErMXp2RStEM0t2bTBGVGhJU0RnZkU5Q0xTYlJVeG5jSSsyNEhFK1JRZDJKVWkwa0lPTTVJM3Q3T3p0NGVpOGRwdlZtamxKU1drcG1MQ1BkY0J0M1B6OTBmeGdjVHlNYWZ0TUtMelFqZVNNNDRPRWhJT0I0VDFJdEp0RlRHZHdoUUIyOTFkVzhlKzF3R2VvdDVoM3lHQ1BjS0J4UGd4cCswd292TkNONUl6amdlRHFCMkFmbTBCRGtLNy93a0ZUb0tEcUIyQWUvNXRCVTZDdmNxKzQ0Vk9Rb09pKy80N084QmkrOEQrQ1Q1dEJVakNpY0VyWXVwZ3FtQmRuZHplWTk1ajNuTWtJdG1pM0JoZ3FsdHJtZ29UWWxkaURmaWZ0Q0xDTFdMbG5lSWMxVStMMXNtaTJXTGFaUnBtS0czV2VKY3AzU2lXb0p2bG9LbWdxYUtxUWlPa0pDUWs0c0l4bWtGblk4dzl4SzFwWitYczFkK3duKyt1blNwbUtXV242bHFuUWgxbmdXNHByK2N3NHNJOTN2N0FSV2RkWnB6bG5FSWk0aDFkUVZ2YjRhOGdKVitsMTE5aFpxRW5jT2pzWllJRG92dkFmbFQrYlFWKzhQN3dDZnYrOEQ3dys4bjkxejNYKzhuK0NUNEpBWDl0UHpzRlNFS0RvdnY3Ky92NysvdkFZdnY3Ky92NysvdkEvbFFCQ2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3dmOVVQdGNGU2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3dmOVVQdGNGU2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3dmOVVQdGNGU2Z2N3dmdkZpZnY3d2Z2Rmlmdjd3ZnZGaWZ2N3djT2kvZGM3L2RjNy9kY0FZdjNYTy8zWE8vM1hBTVUvUG0wQkRjSzd4WTNDdThXTndyOXRQdkFGVGNLN3hZM0N1OFdOd3I5dFB2QUZUY0s3eFkzQ3U4V053b09pL2ZBOTF6M3dBR0w5OEQzWFBmQUEvbTBCRHNLOTF3V093cjl0UHlJRlRzSzkxd1dPd29PaSsvdjcrLzRKQUg0N084RG52bTBGWUNEZzRBZis5OEhiNkYxcHg3NDdBYW5vYUduSC9mZkI1YURrNEFlL1QzOGZ4WDd0Z2VBazRPV0h2a3FCcGFUazVZZjk3WUhlNFY3aUhtTENQenNCbm1MZTQ1N2tRajR1dnNCRlNrS0RvdnY5MXp2OTF6dkFlL3Y5OER2QXhUZytWQUVKNzBIcDZGMWJ4LzhKQWR2ZFhWdkhsa245OER2V1FadmRhR25IL2NxOThEN0tnZHZkWFZ2SGxrbjk4RHZXUVp2ZGFHbkgvZ2tCNmVob2FjZXZlLzd3Q2U5QnFlaGRXOGYreXI3d1BjcUI2ZWhvYWNldmU4R0RxQjIrT3p2RW92M1hDZnYrQ1QzWFB0Yzd4UFErQ1Q1VUJYN09mc2IreHY3T1I4bldRY1Q0RzkxZFc4Zisxd0hiNkYxcHg3dkJxZWhvYWNmRTlUMzhnZjNBK1RrOXdQM0ErUXkrd01lRThqNzhnZHZvWFduSHU4R3A2R2hweC8zWEFlbmRhRnZIaFBVV2U4Rzl6bjdHL2NiK3prZUR2aUlCSXRVb2xtdlp3ajM2ZnZvOStuMzZBV3ZyNks5aThJSTl3RXc1dnNCK3dFd01Qc0I5d0V3NXZzQit3RXdNUHNCSGc2Z2RnSHY5MXozWFBkY0EvZ2srVkFWL0NUN3dPK0xpL3drOTF5TGkvZGM5MXlMaS90YzkxeUxpL2duNzRnRkRvdnYrT3p2QVl2ditPenZBL20wQlAyMCtiVDV0QWY5VUNjVitPejd3QVluN3ljbjkxejdYSXNuSjR2OEpQZ2tKeWNGRG92M1hQZ2s5MXdCaSsvNDdPOERudm0wRllDRGc0QWYvWTRIZ0pPRGxoNzVqZ2FXazVPV0gvbU9CNWFEazRBZS9UMzdYQlg0N1B2QUp3WW5KL3RjaXlmdko0c0ZEdmRjNy9kYzd3R0w3L2pzN3dQM1hQanNGZnNYUmlZb0tOQW05eGNmMm92S3c4WE54VW5JVTl5TENQY1gwUER1N2tidyt4Y2ZPb3RPVTFGSlVjMU53enVMQ0NjRXRZdTVYTGxXWFZaZFhHR0xDRUZ4d2JtNXBjSFZIL2drRnRXbFZWMWRjVlZCSDJDTFhycGR3TG5BdUxxMml3Z09Mb3Z2OS9MdnZmZGNFdS92aS9kYysxenZFK1Qzd1BtMEZSUG9WRjVlVkI4VDVGUzRYc0llRStqQ3VMakNIOEpldUZRZSt5cjdqaFU0U0VnNEh4UHc3d2Fub2FHbkhoUGtwNkYxYng4VDhJdHZKL3NjaXpVSU5jNUwzaDRUNk43T3p0NGZFK1FuQm05MWRXOGVFL0J2ZGFHbkh4UGtpNi92OXlpTHpRamNTTkE0SGc2TDcvanM3d0gzWFBtMEZTZjNOd2VFZndVOSsxZzgrMWMrKzFrSSt3NG4rSWp2K3pZR2taY0YyZmRZMnZkWDJQZFpDUGNPN3dZT2krL3Y3Ky92Nys4QitWQUVJUXI5dFB0Y0ZTRUsvYlQ3WEJVaEN2MVErMXdWSWdvT2krL3Y3Ky92Nys4QitWQUVJUXI5dFB0Y0ZTRUsvYlQ3WEJVaEN2MjArMXdWSWdvT2krL3Y3Ky92Nys4QitWQUVJUXI5dFB0Y0ZTRUsvYlQ3WEJVaEN2enMrMXdWSWdvT29IYjN3UGRjOTF6dkFmZkE5MXozWE84RCtMcjV0Qlg3SHZzRSt3VDdIaCtMZTR0N2pud0krOFA3dzR2N1hQZkFpNHYzWFBkY2k0dnZqbzRGbW9pYmk1dUxDUGNlOXdUM0JQY2U5eDc3QlBjRSt4NGZ2U2NWUEFvT2kvZGM5OER2QWUvditDVHZBL2NhK093VmVJVjhkWXQzQ0l1SmkvdnlKNHVMK3lvRmI2RjFweDc1VUFhbm9hR25IL2NxSi9meUI2ZDFvVzhlL0lpTGhvdUhpNGVMQmNvbkZmZ2srOEFuSi90Yzd5Y0dEb3Z2NysvditDUUJpL2drNysvdjd3UDV0QVQ4SlBnaytDUUg3L3RjRlQwSzcvdGNGVDBLRHZZbjd4TDNBL2ZIKzUvM1pCT0E5K1g1U2hYN3dQc3FCWGFHZTNTTGRvdHZvWFduaTVXTG1KQ1RrUWozd1BjcUJacVRsNStMbkl1bmRhRnZpd2lDaTRXSWhZY0k3L3NxRmZ3aysxd0Zkb1o3ZEl0MmkyK2hkYWVMbFl1WWtKT1JDUGdrOTF3Rm1wT1huNHVjaTZkMW9XK0xnb3VGaUlXSENQdGNCUHZBK3lvRkU4QjlnMzkzaTN1TGNhRjBwWW9JRTZEM1hBYU5pNCtLallzSUU4Q25vcUtuSDR1amVLRnpqd2oxd3dXYWs1ZWZpNXlMcDNXaGI0dUNpNFdJaFljSUU2RDdzdndlRlcraGRLY2VqWXVQakkyTENPOEdwNkdocDZkMW9XOGZKNHVHaTRlTGlJc0ZjWGR3ZEI4T29IYnY3L2drN3dIM1crLzNYTzhEOTF2NXRCVW5KeWYzWFBkY0IvZXppQlZUaUdOM2Eyb0lZRjhGZm9PQWQ0dDhpMitoZGFlTG1vdWVscE9ZQ0xlM0JhMnQwSkswWXJKa2pFcGpZd2o3S3ZzcUJYNkRnSGVMZkl0dm9YV25pNXFMbjVhVG1BajNLdmNxQmRuWmkvY1JQZGx2cDJxZFo1TjVqM2VMZVlvSS9BLzd4eFg3S3ZzcUJUMDlpL3NSMlQzRFU5eDcwYVNtbGFXYW9hRUl0cmNGbUpPV240dWFpNmQxb1crTGZJdDRnSU4rQ0Y5ZkJXbHBSb1JpdEdTeWlzeXpzd2ozS3ZjcUJaT1RrWnVMbG91bmRhRnZpNG1MaDRxSml3aUlCb09MZ1lDSGhnajN0L3UyRmZ0YzcrL3Y3d2NPOTVUcTZlNDk3eElUZ1BqZStiRVZVNGhqZDJ0cWZvT0FkNHQ4aTIraGRhZUxtb3VmbHBPWXJhM1FrclJpc21TTVNtTmpDUHNxK3lvRlgxOW5obkdOY1kxOGxvdUxoSStBam9PTGI0dDFkSXR2aTNxV2VKcURtb09lZmIySUNMMkkwWjdKeVFqM0t2Y3FCZG5aaS9jUlBkbHZwMnFkWjVNSWVZOTJpM21LQ0JPZysxejdleFZaalVkNVQwOEkreXI3S2dVOVBZdjdFZGs5dzFQY2U5R2twcFdsbXFHaG1KT1ZuNHVhaTZkMW9XK0xmSXQ0Z0lOK0NHbHBSb1JpdEdTeWlzeXpzd2ozS3ZjcUJiT3pycENuaXFlS25vS0xpd2dUd0pPRm1JYVZpNmVMb2FHTHA0dWdlNkoya0FoMmtIMmFXWTBJRG92djcrL3Y3Ky92QVl2M3dBUDVVQVE3Q3U4V0ovZ2s3d2Y4SlB0Y0ZTZjN3TzhIL1ZEN1hCVTdDdThXSi9nazd3ZjhKUHRjRlNmM3dPOEhEb3Z2NysvdjcrL3ZBWXZ2QTczNVVCVXJDdmNxRmlJSy9ZTDdYQlVyQ3ZjcUZpSUsvWUw3WEJVckN2Y3FGaUlLL1lMN1hCVXJDdmNxRmlJS0RxQjJBZm0wK2JRVi9iVDhKUGZBSisvN3dBVU85b3Y0SlBkYzd3SHY3L2RjN3dQM3dQbFFGZnNDTVRIN0FoOG5KL3drK096NEpDZnZCL2NDTWVYN0FoNG5CTU8zWDFNZkovdGM3d2ZEdDdmREhnNzJpL2drOThEdkFlL3Y5MXp2QS9mQStiUVYrd0l4TWZzQ0grOEd3N2UzdzhPM1gxTWUrMXo4SlB3aytPejRKQ2YzWEFmM0FqSGwrd0llRHUvditDVHZBZS92K0NUdkEvZ2srVkFWK3puN0cvc2IremtmSjR2M0t2dGM5eXIzWENlTEJmY0Q1T1QzQXg3M2poYjdLdnRjNzRzRit3TXlNdnNESGljSDl6bjNHL2NiOXprZjd3WU9pKy80N084QjcrLzRKTzhENy9tMEZmdGM3Ky80SlB0Y0p3ZjNLdnVPOXlyM2ppZUxpL2ZBQmZ5Nis0NFYreXI3anUrTGkvdkErT3lMaS9kY0o0dUxKL3draTR2M1hPK0xCUTZnZHUvdjk4RHZBWXZ2K096dkEvanMrVkFWSi95SUIxUmVYbFFmSisvditJZ25CL2RjOXlvRi9PejdqaFg3WFBzcTkxejdLb3Z2K0lpTEJjSzR1TUlmN3ljbi9JZ0hEdmdyNysvNGlPOEJpKy80aU84RDkvTDV0Qlg3VmZzeCt6SDdWZnRWOXpIN01mZFZIOGFMeFpxOHBZNkhrSVdQaUFqdkp3V2JlNng5b292RGk3bTVpOE9Mb24yc2U1c0lKKzhGaDQrRWtJYU9wcnljeEl2SENQZFYrekgzTWZ0Vkh2enNCUHNmK3dQM0EvY2Y5eC8zQS9jRDl4LzNIL2NEK3dQN0gvc2krd0Q3QVBzaUh3NzJvSGI1VU84QmkrLzRKTzhEOThENXRCWDdPdnNhK3hyN092dGM5OEQ3d0l1TDk4RDN3UGRjOXpyN0d2Y2Erem9mSndRNENnNzRLNHZ2NysvM1hPL3Y3d0dMNysvdjcrLzNYTzhEK2JRRS9iVDV0UGVDQjR5T2k0K0xqb3VPaTVDS2pnajRzUWY3eGZ5NkZXK2hkYWNla0l2M0tvdUxKL3pzaTR2NDdQanNpNHY4SlBzcWk0YUxCVzkxYzNFZit5WDM4aFU0U0VnNEovY3EreXFMaS9jcTl5cnYza2pPT0I4bkJDa0tEdmFMOTF6M1hQZGNBL2xRQkQ0Szkxd1dQZ29POXZsUUJJdjg3UGpzOThBRkR2YnYrT3dCaS9qc0EvZkErVkFWK3pyN0d2c2ErenI3T3ZjYSt4cjNPdmM2OXhyM0d2YzY5enI3R3ZjYSt6b2ZEdmdrK1ZBVi9DVDd3UGdrKzhBRjk4QUUrQ1Q3d0l2NDdBVU8rVkFFaS96cytDVDN3QVg3d0FUNEpQZkEvQ1Qzd0FVT2kvZGNBL2xRQkQ0Sys4QUUrSWo3d0l2NDdBVU8rSWozWEFQNVVBU0wvT3o0aVBmQUJmdkFCUGRjK096N1hBWU85dS80N0FHTCtPd0QrVkFFL096NDdQanNCdzZnZHZkYytDUUI5MXo0SkFQM1hQbTBGZnRjKzF6OEpQZGMrMXo0SlBkYzkxejRKUHRjOTF3SERvN3Y5MXp2OTFudkFmbFFCQ0VLL2JUN3ZSVWhDdjIwKzhBVklRb085aWZ2OWVuditDZ1NpKy92OTF6N0t1LzNLdThUK3ZlcStWQVZZSUZvWDR0ZkNJdUppL3RjQlZTNFhzTEN1TGpDSG92M1hJdVBCY0pldUZRZWdvdUZpWVNKQ1B1SSsxd1ZlSVY4ZFl0M0NJdUppMWtGRS9hTCt5ajNBZnNPOXlGekNDRUhFL3BaQmxSZVhsUWYrQ1FHd2w2NFZCNFQ5bG4xQnZjaG8vY0I5dzZMOXlnSXZRZW5kYUZ2YjNWMWJ4NVpCL3NETWpMN0Evc0RNdVQzQXg2THZZdU1CYWQxb1c4ZWlJdUlpb2lMQ0lnR0R2ZkE5MXdCK0lnRUx3b09KKy92Ny9nazd3R0w3L2pzN3dPdCtWQVZlSVY4ZFl0M0NJdUppL3lJQlcraGRhY2U5NDRuSndaVVhsNVVIL2pzQnNKZXVGUWVKKy8zamdhbm9hR25IL2lJQjZkMW9XOGUvVkNMaG91SGk0aUxCY2tuRmZqcy9DVDg3QVlPUGZlT0FZdjNqZ1AzcFBsUUZmc3lWdnNHK3ltTCswU0wrM0gzUi90SDkzR0w5MFNMOXluM0JzRDNNbU45WUlOZWkvdHhpL3RIOTBlTDkzR0x1Sk8ybWJNSURxQjI5OER2QWZmQTd3UDM4dmxRRmZzcSt5cnZpNHY3S3ZzcWk0dnYreXI3S3ZjcSt5cUw3L2NxaTR2N0tpZUw5eXI3S3ZjcTl5b25pNHYzS2dYM0tpY0c5eXIzS3ZzcTl5cUxKL3NxaTR2M0t1K0xCUTZMOThEN1hQZkE5MW4zWHhLTDk4QW43L2RjOThBbjd4T3ErYlQ1dEJYOGlDY25peC84TFFkOGtIbVBlb3NJRTdBL0NoTnErQ0VIMUtMM0VxRDNYWkVJKzJJSGZKQjVqM3FMQ0JOa1B3b085MlA0aC9sUUZWaUxXSGRrWkFqN3F2dWtCU0FnaS90QzlpRDJJUGRDaS9iMkNQY1I5eEZHMFBzSSt3V0Nmd1ZHUnZzRWkwYlFSOCtOOXdMTjBBajNxdmVuQmJPenpJcXlaTEpraVUxbVl3ajdqdnVMQllHQmVZdUJsWUdWaTUyVmxRaVNqdVhwUnRBcktnVmJXNHM4dTF1N1c5cUx1N3NJOTQ3M2lBWFoyWXYzRVQzWlpMSlluMWlMQ0E2Z2RnSDQ3UG0wRlNjbjkxejdYTy92QmZ3a0Z2d2svQ1NMKzF6M1hJdjRKUGdrQlE2TDkxenYrQ1Q3d1Bna0V1LzN3Ty8zWENmM1hCTzQrTHI1dEJWWWkxOW5jRmU0VmFaQml6ZUxib2h4aFhHZWdKMkRvWXNJM3M3bDl3SWY5d0pJNVRnZUU5RDd3Q2NWT0VneCt3TDdBczR4M3Q3TzVmY0NIL2NDU09VNEh2aHYrOUFWWUZoUGJFbUpDQlBVcG1XY1hZdFpDRW4zWFBjNkI0dS9iTGRmb1FqOUhpY1ZYM1ZzWDR0WENQczZCeE9ZK0lqM09nYUx2MnkzWDZGZVZrNXNSb3RHaTA2cVhzQUlEb3YzWE8vNGlBSDNYUGdrQS9naytiUVYrd0l4K3dUN0h2c2U1ZnNFOXdMM0F1WDNCUGNlOXg0eDl3VDdBaC83WmZ5SUZTR0dOalNMK3dBSUovbTA3d2VMOXdBMjRpR1FWVTVCWkRxTE9vdEJzbFhJQ0E3Mmk3M3Z2ZmlJN3hLTDkxejdYTy8zWFBkY0orOFQ2cDc1dEJXQWc0T0FILzJPQjRDVGc1WWUrR0lHbHBPVGxoLzVqZ2VXZzVPQUh2d1JKeFgzd1B5SSs4QUc5eXBaRlJQMEtRb09vSFlCOS9MNXRCVXFpelJrVEVzSTk3Mzd2WXY0SVFWN2pYcU1lb3NJOXlvaEZZdjc2ZnVrKzZRRnlGblhiT0NMOTFXTDl6SDNNWXYzVll2M1JQc1g5eVA3UGFRSS9DMzdHQlZUVldoQml6ZUxLN2s0MFZRSTkyajNhQVVPOThEdjkxenZBZmZBN3dQbitSNFZiNkYwcHg2Tmk0K01qWXNJdmZ0Y0p3WlVYbDVVSC9mQSs4QUd0eWZENzR2M3dQZkFpd1hDWHJoVUhpZjNYTDBHcDZHaHA2ZDFvVzhmL0NTTGhvdUhpNGlMQlhGM2NIUWZEb3Y1dEFHTDk4QUQrQ1Q1dEJVakNpZjdYQlgzd1B0Yys4RDdYQVVPb0hiM3dQZGNBZmZBOTF3RDk4RDV0Qlg3d1B2QSsxejN3UHZBOTF6M3dQZkE5MXo3d1BmQUJ3Nkw3d0dMNy9kYzcvZGM3d01VY1BmQStiUVZKUXI3ZVBza0ZXVnNCVHBMVmllTCt3TUkrMVgzTWZzeDkxWDNWZmN4OXpIM1ZSNkw5d05YN3puTENHV3FUVDJ3YkFYRlhiSkVpenNJK3gvN0Evc0QreC83SC9zRDl3UDNIeDZMMjYvU3hia0lzNm9GRG92M3dPL3Y3L2RjQVl2djcvZ2s3KzhERkJ6M1hQbTBGZnRjK0NUM1hBZjg0L3ZBRllXSWlJVWYrNjRIaFk2SWtSN205MXo0N1B0YzVnYVJqbzZSSC9ldUI1R0lqb1VlL09QN1hCWDd3UGdrOThBSERxQjI3Ky92NysvdkFZdnYrT3p2QS9sUUJQMVE3L2xRQi9qc0Z2MVE3L2xRQi96c0p4VW45MXp2QnlmN1hCVW45MXp2QnlmN1hCVW45MXp2Qnc3M2UrOEI5OW41VUJWaCt4eGkreHhoK3gwSWlKR0NyZnRRaTRzbjl3aUxCYWMwcHpTbk03WDNHYlQzR3JYM0diUDdGTFQ3RkxIN0ZiSG1zT2V3NXdpWWIvZDdpNHZ2K3oyTEJXN0ZiOFJ0eEc1QmJVRnVRVi8zSDE3M0gySDNJUWdPNy9qcy9PejNYQktMOTF5TDkxeUw5MXdUa1BkYytPd1ZpMitkZDVWempvV0xnWXQvQ0JPbyszdjg3UGQ3Qm91WGk1V0lrWUdqZVorTHB3akV0cmJFeExaZ1VoNkxiM2wzZ1hPSWhZdUJpMzhJOTN2M2V3YVhpNVdMa1lnSUUwaWpnWjk1cDRzSXhMYTJ4TVJndGxJZmI0dDNlWE9CaFlpQmkzK0xDUGQ3KzNzSGk1ZUxsWTZSQ0JPUWxhT2RuNHVuQ01SZ3RsSWVVbUJnVWg4T2tpZnYrT3p2QWZkWjcrL3ZBL2VMK1ZBVk5vdE1jV05qWTJOOVdZWmxDTzkvQlkrbGs2T2VucDZlcXAzTmk4MkxyM3VmZVo5NWszU0xjb3M0YUhSWlgxbGZTa3VMK3drSWN1K2tCNHZlcXFLOXQ3MjMwTXVMOXdtTHUzdkJZTEpnc2t1Zk40c0lXZjFRRlNmdjd3Y09pL2RjNy9mQSsxejRKQkx2NysvdjcrOFVIQk84K0ZiNXRCVVQzUHNOaXlFMWRQc0dDQk84K3dJeE1mc0NINHRYbjEyc1p3Z1QzS1doclpld2k1K0xub2FjaEFnVHZKekx4YnZRaTlDTHhWdWNTd2dUM0p5U25wQ2ZpOHFMd0dTaFZNdWN1OFdMMEl2TVljdFJvQWk5Qi9jZSt3VDNCUHNlSHZzSS9JZ1ZlSVY4ZFl0M0NJdUppL3RjQlcraGRhZW5vYUduSG92M1hJdU1CYWQxb1c4ZWlJdUlpb2lMQ0lnRysyQW5GWGlGZkhXTGR3aUxpWXNuQlcraGRhZW5vYUduSG92dmk0d0ZwM1doYng2SWk0aUtpSXNJaUFiNElCWjRoWHgxaTNjSWk0bUxKd1Z2b1hXbnA2R2hweDZMNzR1TUJhZDFvVzhlaUl1SWlvaUxDSWNHRHFCMjcrLzRKTzhCK096NXRCVW5XUWRvaTNhQWRYQUkreUg3UnZzdDkwWUZkYVYxbDJtTENDY243d2FPaVBjMysxUDdPdnRpSjR1TEorK0xCYTZMb0phaHBnajNMZmRTOXpyN1VnV2hjYUIvcm9zSXBDY0c5MXozS3Z0Yzl5cUxKM1dMaFk3N1EvZGk5eTMzVTcyTGl5ZjNYUGNxQlE2TDcvanM3d0dMN3dQNEpQbTBGZnR3KzBqN1NQdHcrM0QzU1B0STkzQWY5d0tMOGJmVDB3aEQwd1ZWVlVCcE9Jc0krenI3R3ZjYTl6cjNPdmNhOXhyM09oL2VpOU5ud1ZRSSt3SDdBZmZBaTR2M3dQc0wrd3NGUTlNb3V2c0Npd2dPb0hZQitDVDV0QlgzT3ZzNi9DVDhKUHM2OXpxTC9DVDRKSXY3T3ZjNitDVDRKUGM2K3pxTCtDUUZEdmFnZGdIM1hPOEQ5NDc1dEJYN2p2dkE5MXlMaS90YysxeUw5NDc3d1BlTzk4RDdYSXVMOTF6M1hJc0ZEdmZBN3dIM3dQanNGZnZBKzQ3M3dQdU9pL2RjOTF5TGkvdGM5OEQzanZ2QTk0NkwrMXo3WElzRkRxQjIrT3ozWEFINDdQZGNBL20wQlB0Y0IvZmg5NS83bi92aEgvZGNCdmhOKy92MysveE5IdnZBQlB0Y0IvYzc5eG43R2ZzN0gvZGNCdmVuKzNYM2RmdW5IdnZBQlB0Yzkxd0g5d0l4NWZzQ0hnNkw5MXp2NysvdjcrOEJpL2RjNysvdjcrL3ZBKy81dEJVbkIvZmc5NkQ3b1B2Z0grOEcrQmI3enZmTy9CWWUrMXdFSndmM2N2ZEcrMGI3Y2gvdkJ2ZW8rM1QzZFB1b0h2dGNCQ2NIOXdQa012c0RIKzhHOXpuN0cvY2IremtlKzF3RUtnb09pL2drL0NUditDVDN3Q2Z2RW92djcrOFRYUGZBK2JRVlZGNWVWQi84dWdkdmRYVnZiM1docHg3M0tpZjdYQWRVdUY3Q0hoT00rSWdHRTB6Q3VMakNIeE9jOThEOEpQZU9CNmVob2Flbm9YVnZIaE1zK3lyNEpBY1RIUGRjQnhNc3dsNjRWQjRPaSsvNGlPOEJpKy80Sk84RDF2bFFGV0pwYVdJZi9Mb0hZcTFwdEI3NFZnYTByYTIwSC9jUkp5ZjhKUGlJOTF6dkIvZkFGaWNIKzJHTCt6cjdMblQ3VzZEajJzenBpd2ozWENjRzkxejNYQVVPb0hiM3dQZGNBZmlJK1ZBVisxd0gvQ1FuKzJIN3V4Ky85MXIzS1BIM1hJc0k3L3RjQnZmQTk5QUZEb3Z2QWZnUithc1YreE5XK3hKVSt4UlhDR3dIaS9zNnp2c20yeUN6VnJaZnRXeTFiTE4xdVl1NWk3T2h0YXExcXJhM3M4RGI5YzczSjR2M09naXFCL3NVdi9zU3d2c1R3QWg0bEFYOVVBU0hpMjZTYXFOcW8yV3phTGxMNEZuM0NZUDNFZ2ozdXZjT0JRNmdkZ0dMNysvdjcrL3Y3d1A0N1BtMEZTUUsrOEFuRmYxUTcvbFFCL3ZBKzF3Vi9JanYrSWdIKzhEN1hCWDd3Ty8zd0FjT29IYjRKUGRjSi9kY0V2ZkE3eE93OThENXRCVW4rMXdIRTlBbkp3VVRzTzhuOTF5TGkveUk3NHNGRTlENEpQZGNCeE93Nys4RkU5QW43L3RjaTR2M1hBVU9vSGIzd08vdjcrL3ZBZmRjN3dQM1hQbTBGVUFLN3hZbjkxenZCL3RjKzF3VkovZkE3d2Y3d1B0Y0ZTZjRKTzhIRHFCMjk4RHY3Ky92N3dIM1hPOEQ5MXo1dEJWQUN1OFdKL2drN3dmOEpQdGNGU2Yzd084SCs4RDdYQlVuOTF6dkJ3Nkw3Ky92Nysvdjd3R0w3Ky92K0NUdkE5YjVVQlZpYVdsaUgveTZCMkt0YWJRZStSNEd0SzJ0dEIvNHVnZTBhYTFpSHYwRkp4WHZKeWNHOTF6dkZUSUsrMXduRmU4bkp3YjNYTzhWTWdyN1hDY1Y3eWNuQnZkYzd4VXlDZzZnZGdINEpQbTBGU2Y3d1B2QWkvZU8rMXduKzhEM2p2ZGM5NDc3WENmM3dQZU85MXo3d0lzRkRvdnZpKy8zS3UvM0t1K0w3eEtMNzR2djl5cnY5eXJ2aSs4VEtRRDRKUG0wRlRFS0V6TUErNDRuRlRFSytJZ1dFekdBS3dyN2ppY1ZFM09BSmdyNzh2c3FGUk1sQUNzSytWQVdFeUZBS3dvVFl3RDg3UHVPRlRFSytJZ1dFMkdBS3dvVG9RRDdqaWNWTVFvT29IYjNLcjM0aU84QmkrLzRpTzhEcmZtMEZYbDdlM2tmL1hBSGVadDduUjc1REFhZG01dWRIL2x3QjUxN20za2UvTW9uRmZpSS9JajhpQWIzamxrVnNZdWtZWGhxZUdwWmkzaXNlS3lrdGJHTENBNmdkdmxRN3dHTDd3UDV0QVNMKzhENGlQeUk5OEQzd1B5SStJZ0ZKeWNWUEFvTytJanZBWXZ2QS9qc0JJdjdYUGZBKzhEM1hQZGMrOEQzd0FYM0lCYjN3ZnZBK3d2N0R0azk5MXozWFB2QTk4QUYrL0luRlNrS0RvdnY3Ky8zWE8vdjd3R0w3Ky92OTF6djcrOEQrQ1Q1dEJVbkNpY0VMUW9uQkNZS0p3VER0MTlUVTE5ZlUxTmZ0OFBEdDdmREh3Nkw3L2lJN3dHTDcvaUk3d1A1VUFUOVVQbFE5L3NISnllTCt6UDhpSXVMK0lqMys0dnY3d1gzSVJiN3dQdkFKKzhuSi9kYysxejRKUGdrQlE2TCtDVHY5OEFCK1ZEdkE1VDV0QldGaUlpRkgvMmlCNFdPaUpFZSthSUdrWTZPa1IvNW9nZVJpSTZGSHYwVlBSWDNRUHRBKzBEN1FFUFQ3KzhuN3dYMzF2c3FGZmZBSi92QUJnNkw3L2pzN3dHTHZmZU85MXozanIwREZEajV0QVQ3WEwwSHdyaTR3aDczS3Z5NkJtOTFkVzhlV1NmNEpPOVpCbTkxb2FjZitMcjNLZ2ZDdUY1VUg3MzNYQVlPaSsvditJajd3T3dUZ1BsUUJDVUtFOER2RnZ3a0I2ZUxwSUtlZUFnVG9KNTQ2dnRWbVhHWmNhVitwWk9sazVpb2c2V0RwV1QzR1l1a0NLU2hwS2NlOXlvR0U4Q25vYUducHlUM3Q0c2ZnNTE1bUhhTENBNmdkaEtMNysvNGlQdkE3QlBRK0NUNUxoVjljU3o3VlhoNENCUGdlSGh5Z20rTENQd2s5L0lIb0l1ZG1KT2RDSXZ5OTdlbnAzV2hieC83S2dadmRhU2tIeFBRaTZTeTl4bVRwWk9sZnFoeGt3aDRqZ1Y0aVhsK2dYZ0kvQ1Q3bmhVbENnNG43L2lJN0k3dkFZdnYrSWp2QS9kYytWQVZKKytJQi9zK2Mvc1creWVMKzBRSSsxWDNNZnN4OTFYM1ZmY3g5ekgzVlI2THQ0QzJmYkVJTUdZRmxtK1Fib3RzQ1BzZit3UDdBL3NmK3gvN0EvY0Q5eC8zSC9jRDl3UDNIeDZwaTZtR3A0QUlyZWtGZFpOeWozS1BDSkh2N3dmM1hQc0lGWXVML0FEN3JIZDNkM2VMYjU5M24zZW5pNStmbjUvM3ZQZndpNHNJRHFCMjcrLzN3TzhCK096NVVCVW4vT3duK093bkIvZGM5eW9GL096N2poWDdYUHNxOTF6N0tvdnYrT3lMaSsvODdJc0ZEb3Z2K0lqM1hQdGM3eEx2NysvdjcrOFVIQlBjOThENXRCVVR2RlJlWGxRZkp3WlVYbDVVSC9sUUJzSmV1RlFlSndZVDNNSmV1RlFlKzhEN3dCWDhkUWVBazRPV0h2aGlCcGFUazVZZitIVW4rL0lIYjNWMWIyOTFvYWNlOS9JbisvSUhiM1YxYjI5MW9hY2U5L0lIRG92djcrOEI3L2RjOTF6dkErLzV0Qlg4SkFmN0F2Y0VNZmNlSHIwRzl3TGw1ZmNDSC9na0ovd2tCMVJlWGxSVVhyakNIdmdrQi92QS9WQVZKL2xRN3djT2krL3YrSWdCaS9kYzcvZGM3L2RjQXhRNGxQbFFGVUVLK0RZV1FRcjhkdnRjRlVJSy9ILzhKQlVoQ2c2TDkxd243Ky92Ny9kYysxenZFb3YzWE8vM1hPLzNYQlFIRXplVitWQVZoWWVJaFIvN1UvZGM5MU1Ia1lpT2hSNzROeGFHaG9pRkgvdFQ5MXozVXdlUmlJNkZIaE12L0hVbkZZV0hpSVVmTVBkYzVnZVJpSTZGSHZ4Lysxd1ZJUW9UcC8yMCsxd1YrMU1IaFk2SWtSNzNTZ2FSam82UkgvZFRCeE5uN3hZd0I0V1BpSkVlOTBrR2tZNk9rUi9tQnhPbjd4YjdVd2VGajRpUkh2ZEpCcEdPanBFZjkxTUhEb3Y0aU8vdkFZdjNYTy8zWE8vM1hBTVVPUGxRQkNFSy9hdjdYQlZCQ3ZjS0ZrSUs5d29XUVFvTzcvaUlBYjM0N0JWdmRYVnZIL3drQjIraGRhY2UrSWdHcDZHaHB4K0w5eXJ2SisrTGkvZkFKNHNuSjR2M0tnV25kYUZ2SGc2Z2R1L3YrQ1R2QVl2NEpPL3Y3KzhEOStMNXRCVkRDdS83WEJXY2k1eUptNGZoZGNzOWl5MkxMVXM5TlhWN2gzcUplb3NJSndla2k2T09vcEVJamdiM0ZxenE5d3FMOXlDTDl5QXM5d243RnF4MGtYR1BjWXNJKzF3RVJBb085cUIyQVl2NEpPL3ZBL2ZpK2JRVlF3cnYrOEFWUkFvT0xxQjJBWXY0SkFQMzR2bTBGVU1LRG92djcrOEI5OG41dEJXRmk0ZUhpWVlJKzdyOVBvaDRpem9GaFk2SWtSNzVQZ2FSam82Ukg0dmNpSjc3dXZrK0JZbVFoNCtGaXdndys4QVY3L3RjSndZbkJPOG5Kd1lPaS9kYzkxenY5MXp2QWZlbjkxd0QrQXY1dEJYN0hvdjdGR1Q3QVVVSXdEa0Y2TWIzQXF2M0M0djNESXYzQkd6b1R3akEzUVg3QWRIN0Y3TDdIb3NJKzhBRVBJdERkVTFqQ01FMkJicXB2NXpIaThhTHhYcTViUWpBNEFWTnNqK2lQWXNJKzhBRUtnb08rQ3VMdmZlTzkxd0I5OEgzWEFQNHUvbTBGZnNlK3dUN0JQc2VINHRyazJ5V2J3ajd0L3V6QldSa2kwbXlaSjkzcFlPbGk2V0xwWk9mbndqM3RQZTNCYWVBcVlPcmkvY2VpL2NFOXdTTDl4NkxtNHViaUpvSUtpcjdYSXVMOTF6czdBVjhqbnVMZTRzSS9GYjlIaFVwQ2c3M0lmbFFGZnNoK3lFRjN6ZmVOdDQzT0RnNU56WTdDUGNoK3lQM2tmZVJCZDAzM3pqY05RajNJL2NqQlRYY09OODMzUWoza2ZlUit5UDNJUVU3TmpZNU9UZzMzamJlTjk4SURxQjI5MXp2Nys4Qjk4RHZBL20wQlBkMSs4RDdkWXVMSi9mQWk0c24rOENMaXlmM3dJdUwrMXp2aTR2M1hQZkFpNHZ2KzhDTGkrOEY5OER2KzNVRzkzWDN3Q2VMKzN2N3dHV0wrM3Yzd0FVTytDdnY3L2RjNy9kYzd3R0w3L2RjNy9kYzd3TVUvUGZ5K2JRVlJRb25CRVlLV1NjVkp5Y243eWZ2NysvdkorOEhEdmdyNysvM1hPLzNYTzhCaSsvNGlPOERGT0QzOHZtMEZVVUtKd1JHQ3ZzcSsxd1ZKL2ZBN3djTytiUVUrSUVWbmd3Szd3cTl0NUh2dmIzdmordnY5MXdNRE84THZiM3ZrN1diclpMbzcrLzNYQXdOSEFBdUV3QW5BZ0FCQUE4QUZRQWJBRDBBUkFCTEFHVUFod0NmQUxFQXd3RFZBUDBCSHdGUUFWZ0JZQUZ6QVhvQmhnR1NBYU1CdVFIQkFkc0I4Z0lJQWhBQ0lnSXRBalVDUXdKWUFuWUNsQUtzQXNBRERnTkFKL2drL0lqOEpDZjRpUGxRQndzbitiVHZCd3NuK096dkJ3djdjZnRIKzBmN2NmdHg5MGY3Ui9keDkzSDNSL2RIOTNIM2NmdEg5MGY3Y1I4TC9iVHYrYlFIQy93azcvZ2tCd3Y3QWpFeCt3TDdBdVV4OXdMM0F1WGw5d0wzQWpIbCt3SWZDL3R3KzBqN1NQdHcrM0QzU1B0STkzRDNjUGRJOTBqM2NQZHcrMGozU1B0d0h3dW5vWFZ2SHljSGIzVjFiMjkxb2FjZTd3ZW5vYUduSGd1bm9YVnZiM1YxYjI5MW9hZW5vYUduSHd0VVhsNVVWTGhld3NLNHVNTENYcmhVSHd0dmRYVnZiNkYxcDZlaG9hZW5kYUZ2SHd2M0t2c3E5eXIzS3RORCt5cjdLdmNxK3lwRFEvc3E5eXI3S3ZzcVE5UDNLdmNxK3lyM0tnVUw5enIzR3ZzYSt6cjdPdnNhK3hyN092czYreHIzR3ZjNjl6cjNHdmNhOXpvZkMvc05peUUxZFBzR0NQc0NNVEg3QXZzQzVUSDNBaC80VmdiZXpzN2VINHZNWWN0Um9BaTlCL2NlK3dUM0JQc2VIZ3Y3WFBtMDkxd0hDLzIwOTF6NXRBY0xiM1YxYjIraGRhZW5vYUduSDZkMW9XOGVDL2drSi93a0JndUwvT3ozd1BmQWkvZkFCUXY3d1B2QWkvdkE5OENMQlF2N09mc2IreHY3T1IvN3dQZkE5OEFIQy9zRE1qTDdBeDRuQi9jNTl4djNHL2M1SC9mQUJ3djdYUGRjOTF3SEMvY0M1VEg3QXZzQ01USDdBdnNDTWVYM0F2Y0M1ZVgzQWg4TGkvd2s5eXIzS3ZjcSt5cnY3L3NxOXlyM0t2Y3FCUXNuSi9jcSt5cjdLdnNxK0NTTGkvZ2sreXI3S2dVTCs4RDN3UGZBQnd2Q3VGNVVWRjVlVkZSZXVNTEN1TGpDSHd2N3dQdkFKL2drK0NRSEMvenM5MXo0N0FjTE9FaElPRGpPU043ZXpzN2VId3Y4N1B0Y0IvZU8rMXozanZkYysxeUxpL2pzQlF1RmlJaUZIL3gyQjRXT2lKRWU5MG9Ha1k2T2tSLzRkZ2VSaUk2RkhndUZpSWlGSC91dUI0V09pSkVlOTBvR2tZNk9rUi8zcmdlUmlJNkZIZ3Y3R3Z0YysxeUxpL3drOTF5TDl4cjdYTTJMaS9tMEJRdUwrMXlramdXMmxxdXppN21MdVd5elg1WUlDL3RWK3pIN01mdFYrMVgzTWZzeDkxVWZ5SXZGbTcybmpZZVBoWTZJQ084a0JadDdySDJpaThPTHVibUx3NHVpZmF4N213Z2s3d1dJam9XUGg0Mm12WnpGaThnSTkxWDdNZmN4KzFVZUMvY2Y5d1A3QS9zZkg0dFFlRlZwWUFpSWlBVi9oWDk5aElCZlpsSjBUWXNJK3gvN0EvY0Q5eC8zSC9jRDl3UDNIeDhMQUFBQmtBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBbGdBQUFKWUFBQURJQUFBQXlBQUFBR1FBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFDV0FBQUF5QUFBQUdRQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFHUUFBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBbGdBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQTRRQUFBTWdBQUFESUFBQUF5QUFBQUdRQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUdRQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRGhBQUFBbGdBQUFPRUFBQUNXQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBbGdBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBcndBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCOUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBQmtBQUFBeUFBQUFNZ0FBQURoQUFBQXlBQUFBTWdBQUFEaEFBQUFBQUFBQUFBQUFFQUFBQUF6RDJpendBQUFBRFAyUzlxQUFBQUFNL1pMMm89XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5vdGZcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLm90ZlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QZ284SVVSUFExUlpVRVVnYzNabklGQlZRa3hKUXlBaUxTOHZWek5ETHk5RVZFUWdVMVpISURFdU1TOHZSVTRpSUNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk5SGNtRndhR2xqY3k5VFZrY3ZNUzR4TDBSVVJDOXpkbWN4TVM1a2RHUWlJRDRLUENFdExRb3lNREUwTFRjdE1Ub2dRM0psWVhSbFpDNEtMUzArQ2p4emRtY2dlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQRzFsZEdGa1lYUmhQZ3BEY21WaGRHVmtJR0o1SUVadmJuUkdiM0puWlNBeU1ERXlNRGN6TVNCaGRDQlVkV1VnU25Wc0lDQXhJREl3T2pNNU9qSXlJREl3TVRRS0lFSjVJRkF1U2k0Z1QyNXZjbWtLUTNKbFlYUmxaQ0JpZVNCUUxrb3VJRTl1YjNKcElIZHBkR2dnUm05dWRFWnZjbWRsSURJdU1DQW9hSFIwY0RvdkwyWnZiblJtYjNKblpTNXpaaTV1WlhRcENqd3ZiV1YwWVdSaGRHRStDanhrWldaelBnbzhabTl1ZENCcFpEMGliM0JsYmkxcFkyOXVhV01pSUdodmNtbDZMV0ZrZGkxNFBTSTRNREFpSUQ0S0lDQThabTl1ZEMxbVlXTmxJQW9nSUNBZ1ptOXVkQzFtWVcxcGJIazlJa2xqYjI1eklnb2dJQ0FnWm05dWRDMTNaV2xuYUhROUlqUXdNQ0lLSUNBZ0lHWnZiblF0YzNSeVpYUmphRDBpYm05eWJXRnNJZ29nSUNBZ2RXNXBkSE10Y0dWeUxXVnRQU0k0TURBaUNpQWdJQ0J3WVc1dmMyVXRNVDBpTWlBd0lEVWdNeUF3SURBZ01DQXdJREFnTUNJS0lDQWdJR0Z6WTJWdWREMGlPREF3SWdvZ0lDQWdaR1Z6WTJWdWREMGlNQ0lLSUNBZ0lHSmliM2c5SWkwd0xqVWdMVEV3TVNBNE1ESWdPREF3TGpFeU5pSUtJQ0FnSUhWdVpHVnliR2x1WlMxMGFHbGphMjVsYzNNOUlqVXdJZ29nSUNBZ2RXNWtaWEpzYVc1bExYQnZjMmwwYVc5dVBTSXRNVEF3SWdvZ0lDQWdkVzVwWTI5a1pTMXlZVzVuWlQwaVZTdEZNREF3TFVVd1JFVWlDaUFnTHo0S0lDQWdJRHh0YVhOemFXNW5MV2RzZVhCb0lDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaUlpQjFibWxqYjJSbFBTSW1JM2hsTURBd095SWdDbVE5SWswek1EQWdOekF3YURVd01IWXROekF3YUMwMU1EQjJNVEF3YURRd01IWTFNREJvTFRRd01IWXhNREI2VFRRd01DQTFNREJzTWpBd0lDMHhOVEJzTFRJd01DQXRNVFV3ZGpFd01HZ3ROREF3ZGpFd01HZzBNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhJaUIxYm1samIyUmxQU0ltSTNobE1EQXhPeUlnQ21ROUlrMHpNREFnTnpBd2FEVXdNSFl0TnpBd2FDMDFNREIyTVRBd2FEUXdNSFkxTURCb0xUUXdNSFl4TURCNlRUSXdNQ0ExTURCMkxURXdNR2cwTURCMkxURXdNR2d0TkRBd2RpMHhNREJzTFRJd01DQXhOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpJaUlIVnVhV052WkdVOUlpWWplR1V3TURJN0lpQUtaRDBpVFRNMU1DQTNNREJqTVRreklEQWdNelV3SUMweE5UY2dNelV3SUMwek5UQjJMVFV3YURFd01Hd3RNakF3SUMweU1EQnNMVEl3TUNBeU1EQm9NVEF3ZGpVd1l6QWdNVE00SUMweE1USWdNalV3SUMweU5UQWdNalV3Y3kweU5UQWdMVEV4TWlBdE1qVXdJQzB5TlRCak1DQXhPVE1nTVRVM0lETTFNQ0F6TlRBZ016VXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6SWlCMWJtbGpiMlJsUFNJbUkzaGxNREF6T3lJZ0NtUTlJazAwTlRBZ056QXdZekU1TXlBd0lETTFNQ0F0TVRVM0lETTFNQ0F0TXpVd1l6QWdNVE00SUMweE1USWdNalV3SUMweU5UQWdNalV3Y3kweU5UQWdMVEV4TWlBdE1qVXdJQzB5TlRCMkxUVXdhREV3TUd3dE1qQXdJQzB5TURCc0xUSXdNQ0F5TURCb01UQXdkalV3WXpBZ01Ua3pJREUxTnlBek5UQWdNelV3SURNMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXdORHNpSUFwa1BTSk5NQ0EzTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRURXdNQ0ExTURCb05qQXdkaTB4TURCb0xUWXdNSFl4TURCNlRUQWdNekF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWsweE1EQWdNVEF3YURZd01IWXRNVEF3YUMwMk1EQjJNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMUlpQjFibWxqYjJSbFBTSW1JM2hsTURBMU95SWdDbVE5SWswd0lEY3dNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTUNBMU1EQm9OakF3ZGkweE1EQm9MVFl3TUhZeE1EQjZUVEFnTXpBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJREV3TUdnMk1EQjJMVEV3TUdndE5qQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5pSWdkVzVwWTI5a1pUMGlKaU40WlRBd05qc2lJQXBrUFNKTk1DQTNNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRJd01DQTFNREJvTmpBd2RpMHhNREJvTFRZd01IWXhNREI2VFRBZ016QXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB5TURBZ01UQXdhRFl3TUhZdE1UQXdhQzAyTURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzSWlCMWJtbGpiMlJsUFNJbUkzaGxNREEzT3lJZ0NtUTlJazAwTURBZ056QXdZemMxSURBZ01UUTJJQzB5TXlBeU1EWWdMVFU1YkMwM05TQXRNakkxYkMwek1qSWdNak0wWXpVM0lETXhJREV5TWlBMU1DQXhPVEVnTlRCNlRURXlOU0ExT0Roc01Ua3hJQzB4TXpoc0xUTXhNQ0F0TWpJeVl5MDBJREkwSUMwMklEUTNJQzAySURjeVl6QWdNVEUwSURRNUlESXhOU0F4TWpVZ01qZzRlazAyT0RnZ05UYzFZelk1SUMwM01pQXhNVElnTFRFMk9DQXhNVElnTFRJM05XTXdJQzB6TlNBdE9DQXROamdnTFRFMklDMHhNREJvTFRJeE9IcE5NakUySURJMU0yd3hNVElnTFRNME4yTXRNVEk0SURJeklDMHlNeklnTVRBNUlDMHlPRGNnTWpJeWVrMHpOeklnTVRBd0NtZ3pOekpqTFRZMElDMHhNRGtnTFRFM055QXRNVGcxSUMwek1UQWdMVEU1TjNvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9DSWdkVzVwWTI5a1pUMGlKaU40WlRBd09Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk1qQXdJRGd3TUdneE1EQjJMVFV3TUdneU1EQnNMVEkwTnlBdE16QXdiQzB5TlRNZ016QXdhREl3TUhZMU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamtpSUhWdWFXTnZaR1U5SWlZamVHVXdNRGs3SWlBS1pEMGlUVFF3TUNBNE1EQmpNakl4SURBZ05EQXdJQzB4TnprZ05EQXdJQzAwTURCekxURTNPU0F0TkRBd0lDMDBNREFnTFRRd01ITXROREF3SURFM09TQXROREF3SURRd01ITXhOemtnTkRBd0lEUXdNQ0EwTURCNlRUTXdNQ0EzTURCMkxUTXdNR2d0TWpBd2JETXdNQ0F0TXpBd2JETXdNQ0F6TURCb0xUSXdNSFl6TURCb0xUSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWVNJZ2RXNXBZMjlrWlQwaUppTjRaVEF3WVRzaUlBcGtQU0pOTkRBd0lEZ3dNR015TWpFZ01DQTBNREFnTFRFM09TQTBNREFnTFRRd01ITXRNVGM1SUMwME1EQWdMVFF3TUNBdE5EQXdjeTAwTURBZ01UYzVJQzAwTURBZ05EQXdjekUzT1NBME1EQWdOREF3SURRd01IcE5OREF3SURjd01Hd3RNekF3SUMwek1EQnNNekF3SUMwek1EQjJNakF3YURNd01IWXlNREJvTFRNd01IWXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1JaUlIVnVhV052WkdVOUlpWWplR1V3TUdJN0lpQUtaRDBpVFRRd01DQTRNREJqTWpJeElEQWdOREF3SUMweE56a2dOREF3SUMwME1EQnpMVEUzT1NBdE5EQXdJQzAwTURBZ0xUUXdNSE10TkRBd0lERTNPU0F0TkRBd0lEUXdNSE14TnprZ05EQXdJRFF3TUNBME1EQjZUVFF3TUNBM01EQjJMVEl3TUdndE16QXdkaTB5TURCb016QXdkaTB5TURCc016QXdJRE13TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVl5SWdkVzVwWTI5a1pUMGlKaU40WlRBd1l6c2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qRWdNQ0EwTURBZ0xURTNPU0EwTURBZ0xUUXdNSE10TVRjNUlDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGM1SUMwME1EQWdOREF3Y3pFM09TQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNR3d0TXpBd0lDMHpNREJvTWpBd2RpMHpNREJvTWpBd2RqTXdNR2d5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01HUTdJaUFLWkQwaVRUTXdNQ0EyTURCMkxUSXdNR2cxTURCMkxURXdNR2d0TlRBd2RpMHlNREJzTFRNd01DQXlORGQ2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1VaUlIVnVhV052WkdVOUlpWWplR1V3TUdVN0lpQUtaRDBpVFRVd01DQTJNREJzTXpBd0lDMHlORGRzTFRNd01DQXRNalV6ZGpJd01HZ3ROVEF3ZGpFd01HZzFNREIyTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSm1JaUIxYm1samIyUmxQU0ltSTNobE1EQm1PeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHlNREFnT0RBd2FESXdNSFl0TlRBd2FESXdNR3d0TWprM0lDMHpNREJzTFRNd015QXpNREJvTWpBd2RqVXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTVRBaUlIVnVhV052WkdVOUlpWWplR1V3TVRBN0lpQUtaRDBpVFRNd01DQTNNREIyTFRJd01HZzFNREIyTFRJd01HZ3ROVEF3ZGkweU1EQnNMVE13TUNBeU9UZDZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakV4SWlCMWJtbGpiMlJsUFNJbUkzaGxNREV4T3lJZ0NtUTlJazAxTURBZ056QXdiRE13TUNBdE1qazNiQzB6TURBZ0xUTXdNM1l5TURCb0xUVXdNSFl5TURCb05UQXdkakl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1USWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01USTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU5qQXdJaUFLWkQwaVRUSTVOeUE0TURCc016QXpJQzB6TURCb0xUSXdNSFl0TlRBd2FDMHlNREIyTlRBd2FDMHlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpFeklpQjFibWxqYjJSbFBTSW1JM2hsTURFek95SWdhRzl5YVhvdFlXUjJMWGc5SWpZd01DSWdDbVE5SWsweU5EY2dPREF3YkRJMU15QXRNekF3YUMweU1EQjJMVFV3TUdndE1UQXdkalV3TUdndE1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l4TkNJZ2RXNXBZMjlrWlQwaUppTjRaVEF4TkRzaUlBcGtQU0pOTkRBd0lEZ3dNR2d4TURCMkxUZ3dNR2d0TVRBd2RqZ3dNSHBOTWpBd0lEY3dNR2d4TURCMkxUWXdNR2d0TVRBd2RqWXdNSHBOTmpBd0lEWXdNR2d4TURCMkxUUXdNR2d0TVRBd2RqUXdNSHBOTUNBMU1EQm9NVEF3ZGkweU1EQm9MVEV3TUhZeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakUxSWlCMWJtbGpiMlJsUFNJbUkzaGxNREUxT3lJZ0NtUTlJazB4TVRZZ05qQXdiRGN5SUMwM01tTXROVFFnTFRVMElDMDRPQ0F0TVRJMklDMDRPQ0F0TWpBNWN6TTBJQzB4TlRrZ09EZ2dMVEl4TTJ3dE56SWdMVGN5WXkwM01pQTNNaUF0TVRFMklERTNOU0F0TVRFMklESTROWE0wTkNBeU1Ea2dNVEUySURJNE1YcE5OamcwSURZd01HTTNNaUF0TnpJZ01URTJJQzB4TnpFZ01URTJJQzB5T0RGekxUUTBJQzB5TVRNZ0xURXhOaUF0TWpnMWJDMDNNaUEzTW1NMU5DQTFOQ0E0T0NBeE16QWdPRGdnTWpFemN5MHpOQ0F4TlRVZ0xUZzRJREl3T1hwTk1qVTVJRFEyTUd3Mk9TQXROekpqTFRFNElDMHhPQ0F0TWpnZ0xUUXhJQzB5T0NBdE5qa0tjekV3SUMwMU5DQXlPQ0F0TnpKc0xUWTVJQzAzTW1NdE16WWdNellnTFRVNUlEZzVJQzAxT1NBeE5EUnpNak1nTVRBMUlEVTVJREUwTVhwTk5UUXhJRFExT1dNek5pQXRNellnTlRrZ0xUZzFJRFU1SUMweE5EQnpMVEl6SUMweE1EZ2dMVFU1SUMweE5EUnNMVFk1SURjeVl6RTRJREU0SURJNElEUTBJREk0SURjeWN5MHhNQ0ExTVNBdE1qZ2dOamw2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpFMklpQjFibWxqYjJSbFBTSW1JM2hsTURFMk95SWdhRzl5YVhvdFlXUjJMWGc5SWpRd01DSWdDbVE5SWsweU1EQWdPREF3WXpFeE1DQXdJREl3TUNBdE9UQWdNakF3SUMweU1EQnpMVGt3SUMweU1EQWdMVEl3TUNBdE1qQXdjeTB5TURBZ09UQWdMVEl3TUNBeU1EQnpPVEFnTWpBd0lESXdNQ0F5TURCNlRURXdNQ0F6TVRsak16RWdMVEV4SURZMUlDMHhPU0F4TURBZ0xURTVjelk0SURnZ01UQXdJREU1ZGkwek1UbHNMVEV3TUNBeE1EQnNMVEV3TUNBdE1UQXdkak14T1hvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1UY2lJSFZ1YVdOdlpHVTlJaVlqZUdVd01UYzdJaUFLWkQwaVRUUXdNQ0E0TURCak1qSXdJREFnTkRBd0lDMHhPREFnTkRBd0lDMDBNREJ6TFRFNE1DQXROREF3SUMwME1EQWdMVFF3TUhNdE5EQXdJREU0TUNBdE5EQXdJRFF3TUhNeE9EQWdOREF3SURRd01DQTBNREI2VFRRd01DQTNNREJqTFRFMk5pQXdJQzB6TURBZ0xURXpOQ0F0TXpBd0lDMHpNREJqTUNBdE5qWWdNakVnTFRFeU5pQTFOaUF0TVRjMWJEUXhPU0EwTVRsakxUUTVJRE0xSUMweE1Ea2dOVFlnTFRFM05TQTFObnBOTmpRMElEVTNOV3d0TkRFNUlDMDBNVGxqTkRrZ0xUTTFJREV3T1NBdE5UWWdNVGMxSUMwMU5tTXhOallnTUNBek1EQWdNVE0wSURNd01DQXpNREFLWXpBZ05qWWdMVEl4SURFeU5pQXROVFlnTVRjMWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhPQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXhPRHNpSUFwa1BTSk5NQ0EzTURCb01UQXdkaTAyTURCb056QXdkaTB4TURCb0xUZ3dNSFkzTURCNlRUVXdNQ0EzTURCb01qQXdkaTAxTURCb0xUSXdNSFkxTURCNlRUSXdNQ0ExTURCb01qQXdkaTB6TURCb0xUSXdNSFl6TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqRTVJaUIxYm1samIyUmxQU0ltSTNobE1ERTVPeUlnQ21ROUlrMHpPVGNnT0RBd1l6RXpJREVnTWpNZ0xUUWdNelFnTFRFell6SWdMVElnTWpFMElDMHlOVFFnTWpReElDMHlPRGRvTVRJNGRpMHhNREJvTFRFd01IWXRNelkyWXpBZ0xURTRJQzB4TmlBdE16UWdMVE0wSUMwek5HZ3ROVE15WXkweE9DQXdJQzB6TkNBeE5pQXRNelFnTXpSMk16WTJhQzB4TURCMk1UQXdhREV5T0d3eU16UWdNamd4WXprZ01URWdNaklnTVRnZ016VWdNVGw2VFRRd01DQTJOekpzTFRFME5DQXRNVGN5YURJNE9IcE5NalV3SURNd01HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEIyTFRFd01HTXdJQzB5T0NBeU1pQXROVEFnTlRBZ0xUVXdjelV3SURJeUlEVXdJRFV3Q25ZeE1EQmpNQ0F5T0NBdE1qSWdOVEFnTFRVd0lEVXdlazAxTlRBZ016QXdZeTB5T0NBd0lDMDFNQ0F0TWpJZ0xUVXdJQzAxTUhZdE1UQXdZekFnTFRJNElESXlJQzAxTUNBMU1DQXROVEJ6TlRBZ01qSWdOVEFnTlRCMk1UQXdZekFnTWpnZ0xUSXlJRFV3SUMwMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTVdFaUlIVnVhV052WkdVOUlpWWplR1V3TVdFN0lpQUtaRDBpVFRrZ056QXdhRFk0TW1NMklEQWdPU0F0TkNBNUlDMHhNSFl0TVRrd2FERXdNSFl0TWpBd2FDMHhNREIyTFRFNU1XTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDJPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJOVGd5WXpBZ05pQXpJRGtnT1NBNWVrMHhNREFnTmpBd2RpMDBNREJvTlRBd2RqUXdNR2d0TlRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhZaUlnZFc1cFkyOWtaVDBpSmlONFpUQXhZanNpSUFwa1BTSk5PU0EzTURCb05qZ3lZellnTUNBNUlDMDBJRGtnTFRFd2RpMHhPVEJvTVRBd2RpMHlNREJvTFRFd01IWXRNVGt4WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRZNE1tTXROaUF3SUMwNUlETWdMVGtnT1hZMU9ESmpNQ0EySURNZ09TQTVJRGw2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpGaklpQjFibWxqYjJSbFBTSW1JM2hsTURGak95SWdDbVE5SWswNU1pQTJOVEJqTUNBeU15QXhPU0ExTUNBME5TQTFNR2d6YURWb05XZzFNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNR2d0TlRCMkxURTBNV001SUMweE55QXhNakFnTFRJek1TQXhOallnTFRNd09XTXhOaUF0TWpZZ016UWdMVFl4SURNMElDMHhNRFpqTUNBdE16a2dMVEUxSUMwM055QXROREVnTFRFd00yZ3RNMk10TWpZZ0xUSTFJQzAyTWlBdE5ERWdMVEV3TUNBdE5ERm9MVFV4TW1NdE16a2dNQ0F0TnpjZ01UVWdMVEV3TXlBME1YTXROREVnTmpRZ0xUUXhJREV3TTJNd0lEUTJJREU0SURnd0lETTBJREV3Tmdwak5EWWdOemdnTVRVM0lESTVNaUF4TmpZZ016QTVkakUwTVdndE5UQmpMVElnTUNBdE5pQXRNU0F0T0NBdE1XTXRNamdnTUNBdE5UQWdNak1nTFRVd0lEVXhlazAxTURBZ05qQXdhQzB5TURCMkxURTJNbXd0TmlBdE1UQnpMVFl6SUMweE1qTWdMVEV4T1NBdE1qSTRhRFExTUdNdE5UWWdNVEExSUMweE1Ua2dNakk0SUMweE1Ua2dNakk0YkMwMklERXdkakUyTW5vaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1XUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd01XUTdJaUFLWkQwaVRUUXdNQ0E0TURCak1URXdJREFnTWpBd0lDMDVNQ0F5TURBZ0xUSXdNR013SUMweE1EUWdOVElnTFRFNU9DQXhNelFnTFRJMk5tTTBNU0F0TXpRZ05qWWdMVGd5SURZMklDMHhNelJvTFRnd01HTXdJRFV5SURJMUlERXdNQ0EyTmlBeE16UmpPRElnTmpnZ01UTTBJREUyTWlBeE16UWdNalkyWXpBZ01URXdJRGt3SURJd01DQXlNREFnTWpBd2VrMHpNREFnTVRBd2FESXdNR013SUMwMU5TQXRORFVnTFRFd01DQXRNVEF3SUMweE1EQnpMVEV3TUNBME5TQXRNVEF3SURFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNV1VpSUhWdWFXTnZaR1U5SWlZamVHVXdNV1U3SWlCb2IzSnBlaTFoWkhZdGVEMGlOakF3SWlBS1pEMGlUVEUxTUNBNE1EQm9OVEJzTXpVd0lDMHlOVEJzTFRJeU5TQXRNVFEzYkRJeU5TQXRNVFV6YkMwek5UQWdMVEkxTUdndE5UQjJNalV3YkMwM05TQXROelZzTFRjMUlEYzFiREUxTUNBeE5UQnNMVEUxTUNBeE5UQnNOelVnTnpWc056VWdMVGMxZGpJMU1IcE5NalV3SURZMU1IWXRNakF3YkRFMU1DQXhNREI2VFRJMU1DQXpOVEIyTFRJd01Hd3hOVEFnTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXhaaUlnZFc1cFkyOWtaVDBpSmlONFpUQXhaanNpSUFwa1BTSk5NQ0E0TURCb05UQXdZekV4TUNBd0lESXdNQ0F0T1RBZ01qQXdJQzB5TURCak1DQXRORGNnTFRFM0lDMDVNU0F0TkRRZ0xURXlOV000TlNBdE5EQWdNVFEwSUMweE1qVWdNVFEwSUMweU1qVmpNQ0F0TVRNNElDMHhNVElnTFRJMU1DQXRNalV3SUMweU5UQm9MVFUxTUhZeE1EQmpOVFVnTUNBeE1EQWdORFVnTVRBd0lERXdNSFkwTURCak1DQTFOU0F0TkRVZ01UQXdJQzB4TURBZ01UQXdkakV3TUhwTk16QXdJRGN3TUhZdE1qQXdhREV3TUdNMU5TQXdJREV3TUNBME5TQXhNREFnTVRBd2N5MDBOU0F4TURBZ0xURXdNQ0F4TURCb0xURXdNSHBOTXpBd0lEUXdNSFl0TXpBd2FERTFNQXBqT0RNZ01DQXhOVEFnTmpjZ01UVXdJREUxTUhNdE5qY2dNVFV3SUMweE5UQWdNVFV3YUMweE5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJakl3SWlCMWJtbGpiMlJsUFNJbUkzaGxNREl3T3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB6TURBZ09EQXdkaTB6TURCb01qQXdiQzB6TURBZ0xUVXdNSFl6TURCb0xUSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTWpFaUlIVnVhV052WkdVOUlpWWplR1V3TWpFN0lpQUtaRDBpVFRFd01DQTRNREJvTXpBd2RpMHpNREJzTVRBd0lERXdNR3d4TURBZ0xURXdNSFl6TURCb05UQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTAxTlRCb0xUVTFNR010TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCek1qSWdMVFV3SURVd0lDMDFNR2cxTlRCMkxURXdNR2d0TlRVd1l5MDRNeUF3SUMweE5UQWdOamNnTFRFMU1DQXhOVEIyTlRVd2JETWdNVGxqT0NBek9TQXpPU0EzTUNBM09DQTNPSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTWpJaUlIVnVhV052WkdVOUlpWWplR1V3TWpJN0lpQm9iM0pwZWkxaFpIWXRlRDBpTkRBd0lpQUtaRDBpVFRBZ09EQXdhRFF3TUhZdE9EQXdiQzB5TURBZ01qQXdiQzB5TURBZ0xUSXdNSFk0TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqSXpJaUIxYm1samIyUmxQU0ltSTNobE1ESXpPeUlnQ21ROUlrMHdJRGd3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1DQTJNREJvTXpBd2RpMHhNRE5vTWpBemRqRXdNMmd5T1RkMkxUVTVNV013SUMwMklDMHpJQzA1SUMwNUlDMDVhQzAzT0RKakxUWWdNQ0F0T1NBeklDMDVJRGwyTlRreGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXlOQ0lnZFc1cFkyOWtaVDBpSmlONFpUQXlORHNpSUFwa1BTSk5NekF3SURnd01HZ3lNREJqTlRVZ01DQXhNREFnTFRRMUlERXdNQ0F0TVRBd2RpMHhNREJvTVRreFl6WWdNQ0E1SUMweklEa2dMVGwyTFRJME1XTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRjd01HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdkakkwTVdNd0lEWWdNeUE1SURrZ09XZ3hPVEYyTVRBd1l6QWdOVFVnTkRVZ01UQXdJREV3TUNBeE1EQjZUVE13TUNBM01EQjJMVEV3TUdneU1EQjJNVEF3YUMweU1EQjZUVEFnTWpBNVl6RTJJQzAySURNeUlDMDVJRFV3SUMwNWFEY3dNR014T0NBd0lETTBJRE1nTlRBZ09YWXRNakF3WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRjNE1ncGpMVFlnTUNBdE9TQXpJQzA1SURsMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l5TlNJZ2RXNXBZMjlrWlQwaUppTjRaVEF5TlRzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTXpBd0lEZ3dNR00xT0NBd0lERXhNQ0F0TVRZZ01UUTNJQzAxTTNNMU15QXRPRGtnTlRNZ0xURTBOMmd0TVRBd1l6QWdNemtnTFRFeElEWXhJQzB5TlNBM05YTXRNellnTWpVZ0xUYzFJREkxWXkwek5TQXdJQzAxTlNBdE1UQWdMVGN5SUMwek1YTXRNamdnTFRVMUlDMHlPQ0F0T1RSak1DQXROVEVnTWpBZ0xURXdOeUF5T0NBdE1UYzFhREUzTW5ZdE1UQXdhQzB4TnpoakxURTBJQzAyTUNBdE5Ea2dMVEV5TnlBdE1URXpJQzB5TURCb05Ea3hkaTB4TURCb0xUWXdNSFl4TWpKc01UWWdNVEpqTmprZ05qa2dPVFVnTVRJeElERXdOaUF4Tmpab0xURXlNbll4TURCb01USTFDbU10T0NBMU1DQXRNalVnTVRBMklDMHlOU0F4TnpWak1DQTFPQ0F4TmlBeE1UUWdOVEFnTVRVMll6TTBJRFF6SURnNElEWTVJREUxTUNBMk9Yb2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNallpSUhWdWFXTnZaR1U5SWlZamVHVXdNalk3SWlBS1pEMGlUVE0wSURjd01HZzBhRE5vTkdnMWFEY3dNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEIyTFRjd01HTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRjd01HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdkamN3TUhZeVl6QWdNakFnTVRVZ05ESWdNelFnTkRoNlRURTFNQ0EyTURCakxUSTRJREFnTFRVd0lDMHlNaUF0TlRBZ0xUVXdjekl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQnpMVEl5SURVd0lDMDFNQ0ExTUhwTk16VXdJRFl3TUdNdE1qZ2dNQ0F0TlRBZ0xUSXlJQzAxTUNBdE5UQnpNaklnTFRVd0lEVXdJQzAxTUdnek1EQmpNamdnTUNBMU1DQXlNaUExTUNBMU1BcHpMVEl5SURVd0lDMDFNQ0ExTUdndE16QXdlazB4TURBZ05EQXdkaTAwTURCb05qQXdkalF3TUdndE5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l5TnlJZ2RXNXBZMjlrWlQwaUppTjRaVEF5TnpzaUlBcGtQU0pOTnpRMElEYzVOMncySUMwemJEUTBJQzAwTkdNMElDMDBJRE1nTFRnZ01DQXRNVEpzTFRJMk5pQXRNemMxYkMweE5TQXRNVE5zTFRJMUlDMHhNbU10TWpNZ056SWdMVGM0SURFeU55QXRNVFV3SURFMU1Hd3hNaUF5Tld3eE15QXhOV3d6TnpVZ01qWTJlazB5TmpZZ05EQXdZemMwSURBZ01UTTBJQzAyTUNBeE16UWdMVEV6TkdNd0lDMHhORGNnTFRFeE9TQXRNalkySUMweU5qWWdMVEkyTm1NdE5EZ2dNQ0F0T1RVZ01USWdMVEV6TkNBek5HTTRNQ0EwTmlBeE16UWdNVE16SURFek5DQXlNekpqTUNBM05DQTFPQ0F4TXpRZ01UTXlJREV6TkhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU1qZ2lJSFZ1YVdOdlpHVTlJaVlqZUdVd01qZzdJaUFLWkQwaVRUa2dORFV4WXpBZ01qTWdNVGtnTlRBZ05EWWdOVEJqT0NBd0lERTVJQzB6SURJMklDMDNiREV6TVNBdE5qWnNNamtnTWpKakxUYzVJRGd4SUMweElESTFNQ0F4TVRnZ01qVXdjekU1TnlBdE1UWTNJREV4T1NBdE1qVXdiREk0SUMweU1td3hNekVnTmpaak5pQTBJREV5SURjZ01qRWdOMk15T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJqTUNBdE1UY2dMVEV5SUMwek55QXRNamNnTFRRMWJDMHhNVFVnTFRVMll6a2dMVEUySURFNUlDMHpNeUF5TlNBdE5UQm9OamhqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNR2d0TlRBS1l6QWdMVEl6SUMweUlDMDBOU0F0TmlBdE5qWnNOemdnTFRRd1l6SXhJQzAxSURNM0lDMHlPQ0F6TnlBdE5EbGpNQ0F0TWpnZ0xUSXlJQzAxTUNBdE5UQWdMVFV3WXkweE1DQXdJQzB5TXlBMUlDMHpNU0F4TVd3dE5qVWdNelZqTFRJMElDMDBOaUF0TmpJZ0xUZzJJQzB4TURNZ0xURXhNR010TXpVZ01Ua2dMVFl3SURRMUlDMDJNQ0EzTW5ZeE16VjJOSFkxZGpaMk5YWTFkamczWXpBZ01qZ2dMVEl5SURVd0lDMDFNQ0ExTUdNdE1qUWdNQ0F0TkRVZ0xURTNJQzAxTUNBdE5EQmpNU0F0TXlBeElDMDRJREVnTFRFeGN6QWdMVGdnTFRFZ0xURXhkaTA0TW5ZdE5IWXROWFl0TVRRMENtTXdJQzB5T0NBdE1qUWdMVFV6SUMwMU9TQXROekpqTFRReElESTFJQzAzT1NBMk5DQXRNVEF6SURFeE1Hd3ROallnTFRNMVl5MDRJQzAySUMweU1TQXRNVEVnTFRNeElDMHhNV010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3WXpBZ01qRWdNVFlnTkRRZ016Y2dORGxzTnpnZ05EQmpMVFFnTWpFZ0xUWWdORE1nTFRZZ05qWm9MVFV3YUMwMVl5MHlPQ0F3SUMwMU1DQXlNaUF0TlRBZ05UQmpNQ0F5TmlBeU1pQTFNQ0ExTUNBMU1HZzFhRFk1WXpZZ01UY2dNVFlnTXpRZ01qVWdOVEJzTFRFeE5pQTFObU10TVRZZ055QXRNamdnTWpjZ0xUSTRJRFExZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeU9TSWdkVzVwWTI5a1pUMGlKaU40WlRBeU9Uc2lJQXBrUFNKTk5qQXdJRGN3TUdnNU1XTTJJREFnT1NBdE15QTVJQzA1ZGkwMU9ESmpNQ0F0TmlBdE15QXRPU0F0T1NBdE9XZ3RPVEYyTmpBd2VrMHlNVEFnTlRBemJESTVNQ0F4TkRkMkxUVXdNR3d0TWpVd0lERXlOWFl0TTJNdE1UVWdNQ0F0TWpVZ0xUZ2dMVEk0SUMweU1tdzNOU0F0TVRjNFl6RXhJQzB5TlNBd0lDMDFPQ0F0TWpVZ0xUWTVjeTAxT0NBd0lDMDJPU0F5Tld3dE1UQXpJREkzTW1ndE9URmpMVFlnTUNBdE9TQXpJQzA1SURsMk1UZ3lZekFnTmlBeklEa2dPU0E1YURFNE1ub2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNbUVpSUhWdWFXTnZaR1U5SWlZamVHVXdNbUU3SWlBS1pEMGlUVGtnT0RBd2FEWTRNbU0ySURBZ09TQXRNeUE1SUMwNWRpMDNPREpqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0TmpneVl5MDJJREFnTFRrZ015QXRPU0E1ZGpjNE1tTXdJRFlnTXlBNUlEa2dPWHBOTVRBd0lEY3dNSFl0TWpBd2FEVXdNSFl5TURCb0xUVXdNSHBOTVRBd0lEUXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSHBOTXpBd0lEUXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSHBOTlRBd0lEUXdNSFl0TXpBd2FERXdNSFl6TURCb0xURXdNSHBOTVRBd0lESXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSHBOTXpBd0lESXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTW1JaUlIVnVhV052WkdVOUlpWWplR1V3TW1JN0lpQUtaRDBpVFRBZ09EQXdhRGN3TUhZdE1qQXdhQzAzTURCMk1qQXdlazB3SURVd01HZzNNREIyTFRRNU1XTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDJPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJORGt4ZWsweE1EQWdOREF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWswek1EQWdOREF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWswMU1EQWdOREF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWsweE1EQWdNakF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWswek1EQWdNakF3ZGkweE1EQm9NVEF3ZGpFd01HZ3RNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeVl5SWdkVzVwWTI5a1pUMGlKaU40WlRBeVl6c2lJQXBrUFNKTk5EQTVJRGd3TUdneE9ESmpOaUF3SURFd0lDMDBJREV5SUMwNWJEazBJQzB4T0RKak1pQXROU0EySUMwNUlERXlJQzA1YURneVl6WWdNQ0E1SUMweklEa2dMVGwyTFRVNE1tTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDNPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJORFF4WXpBZ09ETWdOamNnTVRVd0lERTFNQ0F4TlRCb01UUXhZellnTUNBeE1DQTBJREV5SURsc09UUWdNVGd5WXpJZ05TQTJJRGtnTVRJZ09YcE5NVFV3SURVd01HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJ6TWpJZ0xUVXdJRFV3SUMwMU1ITTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2VncE5OVEF3SURVd01HTXRNVEV3SURBZ0xUSXdNQ0F0T1RBZ0xUSXdNQ0F0TWpBd2N6a3dJQzB5TURBZ01qQXdJQzB5TURCek1qQXdJRGt3SURJd01DQXlNREJ6TFRrd0lESXdNQ0F0TWpBd0lESXdNSHBOTlRBd0lEUXdNR00xTlNBd0lERXdNQ0F0TkRVZ01UQXdJQzB4TURCekxUUTFJQzB4TURBZ0xURXdNQ0F0TVRBd2N5MHhNREFnTkRVZ0xURXdNQ0F4TURCek5EVWdNVEF3SURFd01DQXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpKa0lpQjFibWxqYjJSbFBTSW1JM2hsTURKa095SWdDbVE5SWswd0lEWXdNR2c0TURCc0xUUXdNQ0F0TkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSXlaU0lnZFc1cFkyOWtaVDBpSmlONFpUQXlaVHNpSUdodmNtbDZMV0ZrZGkxNFBTSTBNREFpSUFwa1BTSk5OREF3SURnd01IWXRPREF3YkMwME1EQWdOREF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJeVppSWdkVzVwWTI5a1pUMGlKaU40WlRBeVpqc2lJR2h2Y21sNkxXRmtkaTE0UFNJME1EQWlJQXBrUFNKTk1DQTRNREJzTkRBd0lDMDBNREJzTFRRd01DQXROREF3ZGpnd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNekFpSUhWdWFXTnZaR1U5SWlZamVHVXdNekE3SWlBS1pEMGlUVFF3TUNBMk1EQnNOREF3SUMwME1EQm9MVGd3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU16RWlJSFZ1YVdOdlpHVTlJaVlqZUdVd016RTdJaUFLWkQwaVRUQWdOVFV3WXpBZ01qTWdNakFnTlRBZ05EWWdOVEJvTTJnMWFEUm9NakF3WXpFM0lEQWdNemNnTFRFeklEUTBJQzB5T0d3ek9DQXROekpvTkRRMFl6RTBJREFnTVRrZ0xURXlJREUxSUMweU5Xd3RPREVnTFRJMU1HTXROQ0F0TVRNZ0xUSXhJQzB5TlNBdE16VWdMVEkxYUMwek5UQmpMVEUwSURBZ0xUTXdJREV5SUMwek5DQXlOV010TWpjZ09ETWdMVFUwSURFMk55QXRPREVnTWpVd2JDMHhNQ0F5TldndE1UVXdZeTB5SURBZ0xUVWdMVEVnTFRjZ0xURmpMVEk0SURBZ0xUVXhJREl6SUMwMU1TQTFNWHBOTXpVNElERXdNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEFLY3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazAyTlRnZ01UQXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlNeklpSUhWdWFXTnZaR1U5SWlZamVHVXdNekk3SWlBS1pEMGlUVEFnTnpBd2FEVXdNSFl0TVRBd2FDMHpNREIyTFRNd01HZ3RNVEF3YkMweE1EQWdMVEV3TUhZMU1EQjZUVE13TUNBMU1EQm9OVEF3ZGkwMU1EQnNMVEV3TUNBeE1EQm9MVFF3TUhZME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak16SWlCMWJtbGpiMlJsUFNJbUkzaGxNRE16T3lJZ0NtUTlJazAyTkRFZ056QXdiREUwTXlBdE1UUXhiQzAwT1RNZ0xUUTVNMk10TnpFZ056WWdMVEUwTmlBeE5EZ2dMVEl4T1NBeU1qSnNMVGN5SURjeGJERTBNU0F4TkRGak5UQWdMVFV4SURFd01TQXRNVEF4SURFMU15QXRNVFV3WXpFeE5pQXhNVGNnTWpNMElESXpNU0F6TkRjZ016VXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6TkNJZ2RXNXBZMjlrWlQwaUppTjRaVEF6TkRzaUlBcGtQU0pOTVRVd0lEWXdNR3d5TlRBZ0xUSTFNR3d5TlRBZ01qVXdiREUxTUNBdE1UVXdiQzAwTURBZ0xUUXdNR3d0TkRBd0lEUXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTXpVaUlIVnVhV052WkdVOUlpWWplR1V3TXpVN0lpQm9iM0pwZWkxaFpIWXRlRDBpTmpBd0lpQUtaRDBpVFRRd01DQTRNREJzTVRVd0lDMHhOVEJzTFRJMU1DQXRNalV3YkRJMU1DQXRNalV3YkMweE5UQWdMVEUxTUd3dE5EQXdJRFF3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU16WWlJSFZ1YVdOdlpHVTlJaVlqZUdVd016WTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU5qQXdJaUFLWkQwaVRURTFNQ0E0TURCc05EQXdJQzAwTURCc0xUUXdNQ0F0TkRBd2JDMHhOVEFnTVRVd2JESTFNQ0F5TlRCc0xUSTFNQ0F5TlRCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqTTNJaUIxYm1samIyUmxQU0ltSTNobE1ETTNPeUlnQ21ROUlrMDBNREFnTmpBd2JEUXdNQ0F0TkRBd2JDMHhOVEFnTFRFMU1Hd3RNalV3SURJMU1Hd3RNalV3SUMweU5UQnNMVEUxTUNBeE5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak00SWlCMWJtbGpiMlJsUFNJbUkzaGxNRE00T3lJZ0NtUTlJazAwTURBZ09EQXdZekl5TVNBd0lEUXdNQ0F0TVRjNUlEUXdNQ0F0TkRBd2N5MHhOemtnTFRRd01DQXROREF3SUMwME1EQnpMVFF3TUNBeE56a2dMVFF3TUNBME1EQnpNVGM1SURRd01DQTBNREFnTkRBd2VrMDJNREFnTmpJeWJDMHlOVEFnTFRJMU1Hd3RNVEF3SURFd01Hd3ROeklnTFRjeWJERTNNaUF0TVRjeWJETXlNaUF6TWpKNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqTTVJaUIxYm1samIyUmxQU0ltSTNobE1ETTVPeUlnQ21ROUlrMDBNREFnT0RBd1l6SXlNU0F3SURRd01DQXRNVGM1SURRd01DQXROREF3Y3kweE56a2dMVFF3TUNBdE5EQXdJQzAwTURCekxUUXdNQ0F4TnprZ0xUUXdNQ0EwTURCek1UYzVJRFF3TUNBME1EQWdOREF3ZWsweU5UQWdOakl5YkMwM01pQXROekpzTVRVd0lDMHhOVEJzTFRFMU1DQXRNVFV3YkRjeUlDMDNNbXd4TlRBZ01UVXdiREUxTUNBdE1UVXdiRGN5SURjeWJDMHhOVEFnTVRVd2JERTFNQ0F4TlRCc0xUY3lJRGN5YkMweE5UQWdMVEUxTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU0yRWlJSFZ1YVdOdlpHVTlJaVlqZUdVd00yRTdJaUFLWkQwaVRUTTFNQ0E0TURCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2RpMDFNR2czTldNeE5DQXdJREkxSUMweE1TQXlOU0F0TWpWMkxUYzFhQzB6TURCMk56VmpNQ0F4TkNBeE1TQXlOU0F5TlNBeU5XZzNOWFkxTUdNd0lESTRJREl5SURVd0lEVXdJRFV3ZWsweU5TQTNNREJvTnpWMkxUSXdNR2cxTURCMk1qQXdhRGMxWXpFMElEQWdNalVnTFRFeElESTFJQzB5TlhZdE5qVXdZekFnTFRFMElDMHhNU0F0TWpVZ0xUSTFJQzB5TldndE5qVXdZeTB4TkNBd0lDMHlOU0F4TVNBdE1qVWdNalYyTmpVd1l6QWdNVFFnTVRFZ01qVWdNalVnTWpWNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqTmlJaUIxYm1samIyUmxQU0ltSTNobE1ETmlPeUlnQ21ROUlrMDBNREFnT0RBd1l6SXlNQ0F3SURRd01DQXRNVGd3SURRd01DQXROREF3Y3kweE9EQWdMVFF3TUNBdE5EQXdJQzAwTURCekxUUXdNQ0F4T0RBZ0xUUXdNQ0EwTURCek1UZ3dJRFF3TUNBME1EQWdOREF3ZWswME1EQWdOekF3WXkweE5qWWdNQ0F0TXpBd0lDMHhNelFnTFRNd01DQXRNekF3Y3pFek5DQXRNekF3SURNd01DQXRNekF3Y3pNd01DQXhNelFnTXpBd0lETXdNSE10TVRNMElETXdNQ0F0TXpBd0lETXdNSHBOTXpVd0lEWXdNR2d4TURCMkxURTRNV015TXlBdE1qUWdORGNnTFRRM0lEY3lJQzAyT1d3dE56SWdMVGN5WXkweU55QXpNQ0F0TlRVZ05Ua2dMVGcwSURnNGJDMHhOaUF4TWdwMk1qSXllaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6WXlJZ2RXNXBZMjlrWlQwaUppTjRaVEF6WXpzaUlBcGtQU0pOTkRVd0lEZ3dNR014TXpnZ01DQXlOVEFnTFRFeE1pQXlOVEFnTFRJMU1IWXROVEJqTlRnZ0xUSXhJREV3TUNBdE9EVWdNVEF3SUMweE5UQmpNQ0F0TVRnZ0xUTWdMVE0wSUMwNUlDMDFNR2d0TVRreGRqVXdZekFnT0RNZ0xUWTNJREUxTUNBdE1UVXdJREUxTUhNdE1UVXdJQzAyTnlBdE1UVXdJQzB4TlRCMkxUVXdhQzB5TnpKakxURTNJRE13SUMweU9DQTJNeUF0TWpnZ01UQXdZekFnTVRFd0lEa3dJREl3TUNBeU1EQWdNakF3WXpJeklERXhOQ0F4TWprZ01qQXdJREkxTUNBeU1EQjZUVFF6TkNBME1EQm9NMmcwWXpNZ01DQTJJREVnT1NBeFl6STRJREFnTlRBZ0xUSXlJRFV3SUMwMU1IWXRNUXAyTFRFMU1HZ3hOVEJzTFRJd01DQXRNakF3YkMweU1EQWdNakF3YURFMU1IWXhOVEIyTW1Nd0lESXdJREUxSURReUlETTBJRFE0ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJelpDSWdkVzVwWTI5a1pUMGlKaU40WlRBelpEc2lJQXBrUFNKTk5EVXdJRGd3TUdNeE16Z2dNQ0F5TlRBZ0xURXhNaUF5TlRBZ0xUSTFNSFl0TlRCak5UZ2dMVEl4SURFd01DQXRPRFVnTVRBd0lDMHhOVEJqTUNBdE1UZ2dMVE1nTFRNMElDMDVJQzAxTUdndE1UUXhiQzB5TURBZ01qQXdiQzB5TURBZ0xUSXdNR2d0TWpJeVl5MHhOeUF6TUNBdE1qZ2dOak1nTFRJNElERXdNR013SURFeE1DQTVNQ0F5TURBZ01qQXdJREl3TUdNeU15QXhNVFFnTVRJNUlESXdNQ0F5TlRBZ01qQXdlazAwTlRBZ016VXdiREkxTUNBdE1qVXdhQzB5TURCMkxUVXdZekFnTFRJNElDMHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdkalV3YUMweU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJak5sSWlCMWJtbGpiMlJsUFNJbUkzaGxNRE5sT3lJZ0NtUTlJazAwTlRBZ056QXdZekV6T0NBd0lESTFNQ0F0TVRFeUlESTFNQ0F0TWpVd2RpMDFNR00xT0NBdE1qRWdNVEF3SUMwNE5TQXhNREFnTFRFMU1HTXdJQzA0TXlBdE5qY2dMVEUxTUNBdE1UVXdJQzB4TlRCb0xUUTFNR010TVRFd0lEQWdMVEl3TUNBNU1DQXRNakF3SURJd01ITTVNQ0F5TURBZ01qQXdJREl3TUdNeU15QXhNVFFnTVRJNUlESXdNQ0F5TlRBZ01qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0l6WmlJZ2RXNXBZMjlrWlQwaUppTjRaVEF6WmpzaUlBcGtQU0pOTWpVd0lEZ3dNR000TWlBd0lERTFOQ0F0TkRBZ01qQXdJQzB4TURCakxURTBNeUF3SUMweU56QWdMVGcxSUMwek1qVWdMVEl3T1dNdE16WWdMVEV3SUMwM01DQXRNalVnTFRFd01DQXRORGRqTFRFMklETXpJQzB5TlNBMk55QXRNalVnTVRBMll6QWdNVE00SURFeE1pQXlOVEFnTWpVd0lESTFNSHBOTkRVd0lEWXdNR014TXpnZ01DQXlOVEFnTFRFeE1pQXlOVEFnTFRJMU1IWXROVEJqTlRnZ0xUSXhJREV3TUNBdE9EVWdNVEF3SUMweE5UQmpNQ0F0T0RNZ0xUWTNJQzB4TlRBZ0xURTFNQ0F0TVRVd2FDMDBOVEJqTFRFeE1DQXdJQzB5TURBZ09UQWdMVEl3TUNBeU1EQUtjemt3SURJd01DQXlNREFnTWpBd1l6SXpJREV4TkNBeE1qa2dNakF3SURJMU1DQXlNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpRd0lpQjFibWxqYjJSbFBTSW1JM2hsTURRd095SWdDbVE5SWswMU1EQWdOekF3YURFd01Hd3RNekF3SUMwMk1EQm9MVEV3TUhwTk1UQXdJRFl3TUdneE1EQnNMVEV3TUNBdE1qQXdiREV3TUNBdE1qQXdhQzB4TURCc0xURXdNQ0F5TURCNlRUWXdNQ0EyTURCb01UQXdiREV3TUNBdE1qQXdiQzB4TURBZ0xUSXdNR2d0TVRBd2JERXdNQ0F5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqUXhJaUIxYm1samIyUmxQU0ltSTNobE1EUXhPeUlnQ21ROUlrMHpOVEFnT0RBd2FERXdNR3cxTUNBdE1URTViREk0SUMweE1td3hNVGtnTlRCc056SWdMVGN5YkMwMU1DQXRNVEU1YkRFeUlDMHlPR3d4TVRrZ0xUVXdkaTB4TURCc0xURXhPU0F0TlRCc0xURXlJQzB5T0d3MU1DQXRNVEU1YkMwM01pQXROekpzTFRFeE9TQTFNR3d0TWpnZ0xURXliQzAxTUNBdE1URTVhQzB4TURCc0xUVXdJREV4T1d3dE1qZ2dNVEpzTFRFeE9TQXROVEJzTFRjeUlEY3liRFV3SURFeE9Xd3RNVElnTWpoc0xURXhPU0ExTUhZeE1EQnNNVEU1SURVd2JERXlJREk0YkMwMU1DQXhNVGxzTnpJZ056SnNNVEU1SUMwMU1Hd3lPQ0F4TW5wTk5EQXdJRFUxTUFwakxUZ3pJREFnTFRFMU1DQXROamNnTFRFMU1DQXRNVFV3Y3pZM0lDMHhOVEFnTVRVd0lDMHhOVEJ6TVRVd0lEWTNJREUxTUNBeE5UQnpMVFkzSURFMU1DQXRNVFV3SURFMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlORElpSUhWdWFXTnZaR1U5SWlZamVHVXdOREk3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TWpBd2FDMDRNREIyTWpBd2VrMHlNREFnTlRBd2FEUXdNR3d0TWpBd0lDMHlNREI2VFRBZ01UQXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kwTXlJZ2RXNXBZMjlrWlQwaUppTjRaVEEwTXpzaUlBcGtQU0pOTUNBNE1EQm9NVEF3ZGkwNE1EQm9MVEV3TUhZNE1EQjZUVFl3TUNBNE1EQm9NakF3ZGkwNE1EQm9MVEl3TUhZNE1EQjZUVFV3TUNBMk1EQjJMVFF3TUd3dE1qQXdJREl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5EUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05EUTdJaUFLWkQwaVRUQWdPREF3YURJd01IWXRPREF3YUMweU1EQjJPREF3ZWswM01EQWdPREF3YURFd01IWXRPREF3YUMweE1EQjJPREF3ZWswek1EQWdOakF3YkRJd01DQXRNakF3YkMweU1EQWdMVEl3TUhZME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalExSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFExT3lJZ0NtUTlJazB3SURnd01HZzRNREIyTFRFd01HZ3RPREF3ZGpFd01IcE5OREF3SURVd01Hd3lNREFnTFRJd01HZ3ROREF3ZWswd0lESXdNR2c0TURCMkxUSXdNR2d0T0RBd2RqSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTkRZaUlIVnVhV052WkdVOUlpWWplR1V3TkRZN0lpQUtaRDBpVFRFMU1DQTNNREJqT0RNZ01DQXhOVEFnTFRZM0lERTFNQ0F0TVRVd2RpMDFNR2d4TURCMk5UQmpNQ0E0TXlBMk55QXhOVEFnTVRVd0lERTFNSE14TlRBZ0xUWTNJREUxTUNBdE1UVXdjeTAyTnlBdE1UVXdJQzB4TlRBZ0xURTFNR2d0TlRCMkxURXdNR2cxTUdNNE15QXdJREUxTUNBdE5qY2dNVFV3SUMweE5UQnpMVFkzSUMweE5UQWdMVEUxTUNBdE1UVXdjeTB4TlRBZ05qY2dMVEUxTUNBeE5UQjJOVEJvTFRFd01IWXROVEJqTUNBdE9ETWdMVFkzSUMweE5UQWdMVEUxTUNBdE1UVXdjeTB4TlRBZ05qY2dMVEUxTUNBeE5UQnpOamNnTVRVd0lERTFNQ0F4TlRCb05UQjJNVEF3YUMwMU1BcGpMVGd6SURBZ0xURTFNQ0EyTnlBdE1UVXdJREUxTUhNMk55QXhOVEFnTVRVd0lERTFNSHBOTVRVd0lEWXdNR010TWpnZ01DQXROVEFnTFRJeUlDMDFNQ0F0TlRCek1qSWdMVFV3SURVd0lDMDFNR2cxTUhZMU1HTXdJREk0SUMweU1pQTFNQ0F0TlRBZ05UQjZUVFUxTUNBMk1EQmpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3ZGkwMU1HZzFNR015T0NBd0lEVXdJREl5SURVd0lEVXdjeTB5TWlBMU1DQXROVEFnTlRCNlRUTXdNQ0EwTURCMkxURXdNR2d4TURCMk1UQXdhQzB4TURCNlRURTFNQ0F5TURCakxUSTRJREFnTFRVd0lDMHlNaUF0TlRBZ0xUVXdjekl5SUMwMU1DQTFNQ0F0TlRBS2N6VXdJREl5SURVd0lEVXdkalV3YUMwMU1IcE5OVEF3SURJd01IWXROVEJqTUNBdE1qZ2dNaklnTFRVd0lEVXdJQzAxTUhNMU1DQXlNaUExTUNBMU1ITXRNaklnTlRBZ0xUVXdJRFV3YUMwMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlORGNpSUhWdWFXTnZaR1U5SWlZamVHVXdORGM3SWlBS1pEMGlUVEFnTnpreFl6QWdOU0EwSURrZ09TQTVhRGM0TW1NMklEQWdPU0F0TkNBNUlDMHhNSFl0Tnprd2JDMHlNREFnTWpBd2FDMDFPVEZqTFRZZ01DQXRPU0F6SUMwNUlEbDJOVGd5ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJME9DSWdkVzVwWTI5a1pUMGlKaU40WlRBME9Ec2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qQWdNQ0EwTURBZ0xURTRNQ0EwTURBZ0xUUXdNSE10TVRnd0lDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGd3SUMwME1EQWdOREF3Y3pFNE1DQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNR010TVRZMklEQWdMVE13TUNBdE1UTTBJQzB6TURBZ0xUTXdNSE14TXpRZ0xUTXdNQ0F6TURBZ0xUTXdNSE16TURBZ01UTTBJRE13TUNBek1EQnpMVEV6TkNBek1EQWdMVE13TUNBek1EQjZUVFl3TUNBMk1EQnNMVEV3TUNBdE16QXdiQzB6TURBZ0xURXdNR3d4TURBZ016QXdlazAwTURBZ05EVXdZeTB5T0NBd0lDMDFNQ0F0TWpJZ0xUVXdJQzAxTUFwek1qSWdMVFV3SURVd0lDMDFNSE0xTUNBeU1pQTFNQ0ExTUhNdE1qSWdOVEFnTFRVd0lEVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kwT1NJZ2RXNXBZMjlrWlQwaUppTjRaVEEwT1RzaUlBcGtQU0pOTkRBd0lEZ3dNR015TWpBZ01DQTBNREFnTFRFNE1DQTBNREFnTFRRd01ITXRNVGd3SUMwME1EQWdMVFF3TUNBdE5EQXdjeTAwTURBZ01UZ3dJQzAwTURBZ05EQXdjekU0TUNBME1EQWdOREF3SURRd01IcE5OREF3SURjd01IWXROakF3WXpFMk5pQXdJRE13TUNBeE16UWdNekF3SURNd01ITXRNVE0wSURNd01DQXRNekF3SURNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOR0VpSUhWdWFXTnZaR1U5SWlZamVHVXdOR0U3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJRFl3TUdnMU1EQjJMVEV3TUdndE5UQXdkakV3TUhwTk1DQXpNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRBZ01UQXdhRFl3TUhZdE1UQXdhQzAyTURCMk1UQXdlazAzTlRBZ01UQXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOR0lpSUhWdWFXTnZaR1U5SWlZamVHVXdOR0k3SWlBS1pEMGlUVEkxSURjd01HZzNOVEJqTVRRZ01DQXlOU0F0TVRFZ01qVWdMVEkxZGkwM05XZ3RPREF3ZGpjMVl6QWdNVFFnTVRFZ01qVWdNalVnTWpWNlRUQWdOVEF3YURnd01IWXRNemMxWXpBZ0xURTBJQzB4TVNBdE1qVWdMVEkxSUMweU5XZ3ROelV3WXkweE5DQXdJQzB5TlNBeE1TQXRNalVnTWpWMk16YzFlazB4TURBZ016QXdkaTB4TURCb01UQXdkakV3TUdndE1UQXdlazB6TURBZ016QXdkaTB4TURCb01UQXdkakV3TUdndE1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kwWXlJZ2RXNXBZMjlrWlQwaUppTjRaVEEwWXpzaUlBcGtQU0pOTVRBd0lEZ3dNR2d4TURCMkxURXdNR2cwTlRCc01UQXdJREV3TUd3MU1DQXROVEJzTFRFd01DQXRNVEF3ZGkwME5UQm9NVEF3ZGkweE1EQm9MVEV3TUhZdE1UQXdhQzB4TURCMk1UQXdhQzAxTURCMk5UQXdhQzB4TURCMk1UQXdhREV3TUhZeE1EQjZUVEl3TUNBMk1EQjJMVE0xTUd3ek5UQWdNelV3YUMwek5UQjZUVFl3TUNBMU5UQnNMVE0xTUNBdE16VXdhRE0xTUhZek5UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalJrSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFJrT3lJZ0NtUTlJazAwTURBZ09EQXdZekl5TUNBd0lEUXdNQ0F0TVRnd0lEUXdNQ0F0TkRBd2N5MHhPREFnTFRRd01DQXROREF3SUMwME1EQnpMVFF3TUNBeE9EQWdMVFF3TUNBME1EQnpNVGd3SURRd01DQTBNREFnTkRBd2VrMDBNREFnTnpBd1l5MHhOallnTUNBdE16QXdJQzB4TXpRZ0xUTXdNQ0F0TXpBd2N6RXpOQ0F0TXpBd0lETXdNQ0F0TXpBd2N6TXdNQ0F4TXpRZ016QXdJRE13TUhNdE1UTTBJRE13TUNBdE16QXdJRE13TUhwTk5EQXdJRFl3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCekxUSXlJQzAxTUNBdE5UQWdMVFV3Y3kwMU1DQXlNaUF0TlRBZ05UQnpNaklnTlRBZ05UQWdOVEI2Q2sweU1EQWdORFV5WXpBZ01qQWdNVFVnTkRJZ016UWdORGhvTTJnemFEaGpNVElnTUNBeU9DQXROeUF6TmlBdE1UWnNPVEVnTFRrd2JESTFJRFpqTlRVZ01DQXhNREFnTFRRMUlERXdNQ0F0TVRBd2N5MDBOU0F0TVRBd0lDMHhNREFnTFRFd01ITXRNVEF3SURRMUlDMHhNREFnTVRBd2JEWWdNalZzTFRrd0lEa3hZeTA1SURnZ0xURTJJREkwSUMweE5pQXpObnBOTlRVd0lEVXdNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJ6TFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCek1qSWdOVEFnTlRBZ05UQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalJsSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFJsT3lJZ0NtUTlJazB6TURBZ09EQXdhREl3TUhZdE16QXdhREl3TUd3dE16QXdJQzB6TURCc0xUTXdNQ0F6TURCb01qQXdkak13TUhwTk1DQXhNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpSbUlpQjFibWxqYjJSbFBTSW1JM2hsTURSbU95SWdDbVE5SWswd0lEZ3dNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTkRBd0lEWXdNR3d6TURBZ0xUTXdNR2d0TWpBd2RpMHpNREJvTFRJd01IWXpNREJvTFRJd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOVEFpSUhWdWFXTnZaR1U5SWlZamVHVXdOVEE3SWlBS1pEMGlUVEl3TUNBM01EQm9OakF3ZGkwMk1EQm9MVFl3TUd3dE1qQXdJRE13TUhwTk16VXdJRFl5TW13dE56SWdMVGN5YkRFMU1DQXRNVFV3YkMweE5UQWdMVEUxTUd3M01pQXROekpzTVRVd0lERTFNR3d4TlRBZ0xURTFNR3czTWlBM01td3RNVFV3SURFMU1Hd3hOVEFnTVRVd2JDMDNNaUEzTW13dE1UVXdJQzB4TlRCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqVXhJaUIxYm1samIyUmxQU0ltSTNobE1EVXhPeUlnQ21ROUlrMDBNREFnTnpBd1l6SXlNQ0F3SURRd01DQXRNVGd3SURRd01DQXROREF3YUMweE1EQmpNQ0F4TmpZZ0xURXpOQ0F6TURBZ0xUTXdNQ0F6TURCekxUTXdNQ0F0TVRNMElDMHpNREFnTFRNd01HZ3RNVEF3WXpBZ01qSXdJREU0TUNBME1EQWdOREF3SURRd01IcE5NelF4SURRNU1XdzFPU0F0T0Roc05Ua2dPRGhqT0RFZ0xUSTFJREUwTVNBdE1UQXhJREUwTVNBdE1Ua3hZekFnTFRFeE1DQXRPVEFnTFRJd01DQXRNakF3SUMweU1EQnpMVEl3TUNBNU1DQXRNakF3SURJd01HTXdJRGt3SURZd0lERTJOaUF4TkRFZ01Ua3hlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxTWlJZ2RXNXBZMjlrWlQwaUppTjRaVEExTWpzaUlBcGtQU0pOTUNBNE1EQm9NekF3ZGkwME1EQm9OREF3ZGkwME1EQm9MVGN3TUhZNE1EQjZUVFF3TUNBNE1EQnNNekF3SUMwek1EQm9MVE13TUhZek1EQjZUVEV3TUNBMk1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVEV3TUNBME1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVEV3TUNBeU1EQjJMVEV3TUdnME1EQjJNVEF3YUMwME1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalV6SWlCMWJtbGpiMlJsUFNJbUkzaGxNRFV6T3lJZ2FHOXlhWG90WVdSMkxYZzlJall3TUNJZ0NtUTlJazB5TURBZ056QXdhREV3TUhZdE1UQXdhRGMxWXpNd0lEQWdOVGdnTFRZZ09ERWdMVEl5Y3pRMElDMDBOQ0EwTkNBdE56aDJMVEV3TUdndE1UQXdkamswWXkwMElETWdMVEV6SURZZ0xUSTFJRFpvTFRJMU1HTXRNVFFnTUNBdE1qVWdMVEV4SUMweU5TQXRNalYyTFRVd1l6QWdMVEUxSURJd0lDMDBNQ0F6TkNBdE5EUnNNalUzSUMwMk5XTTJOaUF0TVRZZ01UQTVJQzAzTXlBeE1Ea2dMVEUwTVhZdE5UQmpNQ0F0TmpnZ0xUVTNJQzB4TWpVZ0xURXlOU0F0TVRJMWFDMDNOWFl0TVRBd2FDMHhNREIyTVRBd2FDMDNOV010TXpBZ01DQXROVGdnTmlBdE9ERWdNakp6TFRRMElEUTBJQzAwTkNBM09BcDJNVEF3YURFd01IWXRPVFJqTkNBdE15QXhNeUF0TmlBeU5TQXRObWd5TlRCak1UUWdNQ0F5TlNBeE1TQXlOU0F5TlhZMU1HTXdJREUxSUMweU1DQTBNQ0F0TXpRZ05EUnNMVEkxTnlBMk5XTXROallnTVRZZ0xURXdPU0EzTXlBdE1UQTVJREUwTVhZMU1HTXdJRFk0SURVM0lERXlOU0F4TWpVZ01USTFhRGMxZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOVFFpSUhWdWFXTnZaR1U5SWlZamVHVXdOVFE3SWlBS1pEMGlUVEFnTnpBd2FETXdNSFl0TXpBd2JDMHpNREFnTFRNd01IWTJNREI2VFRVd01DQTNNREJvTXpBd2RpMHpNREJzTFRNd01DQXRNekF3ZGpZd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOVFVpSUhWdWFXTnZaR1U5SWlZamVHVXdOVFU3SWlBS1pEMGlUVE13TUNBM01EQjJMVFl3TUdndE16QXdkak13TUhwTk9EQXdJRGN3TUhZdE5qQXdhQzB6TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxTmlJZ2RXNXBZMjlrWlQwaUppTjRaVEExTmpzaUlBcGtQU0pOTXpBd0lEY3dNSFl0TVRBd1l5MHhNVEVnTUNBdE1qQXdJQzA0T1NBdE1qQXdJQzB5TURCb01qQXdkaTB6TURCb0xUTXdNSFl6TURCak1DQXhOalVnTVRNMUlETXdNQ0F6TURBZ016QXdlazA0TURBZ056QXdkaTB4TURCakxURXhNU0F3SUMweU1EQWdMVGc1SUMweU1EQWdMVEl3TUdneU1EQjJMVE13TUdndE16QXdkak13TUdNd0lERTJOU0F4TXpVZ016QXdJRE13TUNBek1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalUzSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFUzT3lJZ0NtUTlJazB3SURjd01HZ3pNREIyTFRNd01HTXdJQzB4TmpVZ0xURXpOU0F0TXpBd0lDMHpNREFnTFRNd01IWXhNREJqTVRFeElEQWdNakF3SURnNUlESXdNQ0F5TURCb0xUSXdNSFl6TURCNlRUVXdNQ0EzTURCb016QXdkaTB6TURCak1DQXRNVFkxSUMweE16VWdMVE13TUNBdE16QXdJQzB6TURCMk1UQXdZekV4TVNBd0lESXdNQ0E0T1NBeU1EQWdNakF3YUMweU1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMU9DSWdkVzVwWTI5a1pUMGlKaU40WlRBMU9Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16QXdJRGd3TUd3ek5DQXRNelJqTVRFZ0xURXhJREkyTmlBdE1qY3dJREkyTmlBdE5EZzRZekFnTFRFMk5TQXRNVE0xSUMwek1EQWdMVE13TUNBdE16QXdjeTB6TURBZ01UTTFJQzB6TURBZ016QXdZekFnTWpFNElESTFOU0EwTnpjZ01qWTJJRFE0T0hwTk1UVXdJRE15T0dNdE1qZ2dNQ0F0TlRBZ0xUSXlJQzAxTUNBdE5UQmpNQ0F0TVRFd0lEa3dJQzB5TURBZ01qQXdJQzB5TURCak1qZ2dNQ0ExTUNBeU1pQTFNQ0ExTUhNdE1qSWdOVEFnTFRVd0lEVXdZeTAxTlNBd0lDMHhNREFnTkRVZ0xURXdNQ0F4TURCak1DQXlPQ0F0TWpJZ05UQWdMVFV3SURVd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTFPU0lnZFc1cFkyOWtaVDBpSmlONFpUQTFPVHNpSUFwa1BTSk5OREF3SURnd01HdzBNREFnTFRVd01HZ3RPREF3ZWswd0lESXdNR2c0TURCMkxUSXdNR2d0T0RBd2RqSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTldFaUlIVnVhV052WkdVOUlpWWplR1V3TldFN0lpQm9iM0pwZWkxaFpIWXRlRDBpTmpBd0lpQUtaRDBpVFRNd01DQTRNREJzTXpBd0lDMHpNREJvTFRZd01IcE5NQ0F6TURCb05qQXdiQzB6TURBZ0xUTXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTldJaUlIVnVhV052WkdVOUlpWWplR1V3TldJN0lpQUtaRDBpVFRBZ05UQXdhREl3TUhZdE1qQXdhQzB5TURCMk1qQXdlazB6TURBZ05UQXdhREl3TUhZdE1qQXdhQzB5TURCMk1qQXdlazAyTURBZ05UQXdhREl3TUhZdE1qQXdhQzB5TURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kxWXlJZ2RXNXBZMjlrWlQwaUppTjRaVEExWXpzaUlBcGtQU0pOTUNBM01EQm9PREF3ZGkweE1EQnNMVFF3TUNBdE1qQXdiQzAwTURBZ01qQXdkakV3TUhwTk1DQTFNREJzTkRBd0lDMHlNREJzTkRBd0lESXdNSFl0TkRBd2FDMDRNREIyTkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTFaQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTFaRHNpSUFwa1BTSk5OREF3SURnd01HdzBNREFnTFRJd01IWXROakF3YUMwNE1EQjJOakF3ZWswME1EQWdOamc0YkMwek1EQWdMVEUxTUhZdE1UZzRiRE13TUNBdE1UVXdiRE13TUNBeE5UQjJNVGc0ZWsweU1EQWdOVEF3YURRd01IWXRNVEF3YkMweU1EQWdMVEV3TUd3dE1qQXdJREV3TUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalZsSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFZsT3lJZ0NtUTlJazAyTURBZ056QXdZelk1SURBZ01UTTBJQzB4T1NBeE9URWdMVFV3YkMweE5pQXRNVEEyWXkwME9TQXpOU0F0TVRBNUlEVTJJQzB4TnpVZ05UWmpMVEV6TVNBd0lDMHlOREFnTFRnMElDMHlPREVnTFRJd01HZ3pNekZzTFRFMklDMHhNREJvTFRNek5HTXdJQzB6TmlBNElDMDJPQ0F4T1NBdE1UQXdhREk1TjJ3dE1UWWdMVEV3TUdndE1qSXlZelUxSUMwMk1TQXhNek1nTFRFd01DQXlNaklnTFRFd01HTTNPQ0F3SURFME55QXpNQ0F5TURBZ056aDJMVEV5TW1NdE5Ua2dMVE0xSUMweE1qY2dMVFUySUMweU1EQWdMVFUyWXkweE5EY2dNQ0F0TWpjMElEZ3lJQzB6TkRRZ01qQXdhQzB5TlRZS2JERTVJREV3TUdneE9UZGpMVGdnTXpJZ0xURTJJRFkySUMweE5pQXhNREJvTFRJd01Hd3lOU0F4TURCb01Ua3hZelExSURFM01pQXhPVGdnTXpBd0lETTROQ0F6TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqVm1JaUIxYm1samIyUmxQU0ltSTNobE1EVm1PeUlnQ21ROUlrMHdJRGN3TUdnM01EQjJMVEV3TUdndE56QXdkakV3TUhwTk1DQTFNREJvTlRBd2RpMHhNREJvTFRVd01IWXhNREI2VFRBZ016QXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlazB3SURFd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5NakF3SURFd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01IcE5OREF3SURFd01HZ3hNREIyTFRFd01HZ3RNVEF3ZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOakFpSUhWdWFXTnZaR1U5SWlZamVHVXdOakE3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHlNREFnTmpBd2FEUXdNR3d0TWpBd0lDMHlNREI2VFRBZ01qQXdhRGd3TUhZdE1qQXdhQzA0TURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kyTVNJZ2RXNXBZMjlrWlQwaUppTjRaVEEyTVRzaUlBcGtQU0pOTUNBNE1EQm9NVEF3ZGkwNE1EQm9MVEV3TUhZNE1EQjZUVFl3TUNBNE1EQm9NakF3ZGkwNE1EQm9MVEl3TUhZNE1EQjZUVEl3TUNBMk1EQnNNakF3SUMweU1EQnNMVEl3TUNBdE1qQXdkalF3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5qSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05qSTdJaUFLWkQwaVRUQWdPREF3YURJd01IWXRPREF3YUMweU1EQjJPREF3ZWswM01EQWdPREF3YURFd01IWXRPREF3YUMweE1EQjJPREF3ZWswMk1EQWdOakF3ZGkwME1EQnNMVEl3TUNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJall6SWlCMWJtbGpiMlJsUFNJbUkzaGxNRFl6T3lJZ0NtUTlJazB3SURnd01HZzRNREIyTFRJd01HZ3RPREF3ZGpJd01IcE5OREF3SURRd01Hd3lNREFnTFRJd01HZ3ROREF3ZWswd0lERXdNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTmpRaUlIVnVhV052WkdVOUlpWWplR1V3TmpRN0lpQUtaRDBpVFRBZ09EQXdhREl3TUhZdE1UQXdhQzB4TURCMkxUWXdNR2cyTURCMk1UQXdhREV3TUhZdE1qQXdhQzA0TURCMk9EQXdlazAwTURBZ09EQXdhRFF3TUhZdE5EQXdiQzB4TlRBZ01UVXdiQzB5TlRBZ0xUSTFNR3d0TVRBd0lERXdNR3d5TlRBZ01qVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kyTlNJZ2RXNXBZMjlrWlQwaUppTjRaVEEyTlRzaUlBcGtQU0pOTkRBeklEY3dNR015TkRjZ01DQXpPVGNnTFRNd01DQXpPVGNnTFRNd01ITXRNVFV3SUMwek1EQWdMVE01TnlBdE16QXdZeTB5TlRNZ01DQXROREF6SURNd01DQXROREF6SURNd01ITXhOVEFnTXpBd0lEUXdNeUF6TURCNlRUUXdNQ0EyTURCakxURXhNQ0F3SUMweU1EQWdMVGt3SUMweU1EQWdMVEl3TUhNNU1DQXRNakF3SURJd01DQXRNakF3Y3pJd01DQTVNQ0F5TURBZ01qQXdjeTA1TUNBeU1EQWdMVEl3TUNBeU1EQjZUVFF3TUNBMU1EQmpNVEFnTUNBeE9TQXRNeUF5T0NBdE5tTXRNVFlnTFRnZ0xUSTRJQzB5TkNBdE1qZ2dMVFEwWXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRBS1l6SXdJREFnTXpZZ01USWdORFFnTWpoak15QXRPU0EySUMweE9DQTJJQzB5T0dNd0lDMDFOU0F0TkRVZ0xURXdNQ0F0TVRBd0lDMHhNREJ6TFRFd01DQTBOU0F0TVRBd0lERXdNSE0wTlNBeE1EQWdNVEF3SURFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOallpSUhWdWFXTnZaR1U5SWlZamVHVXdOalk3SWlCb2IzSnBlaTFoWkhZdGVEMGlPVEF3SWlBS1pEMGlUVE16TVNBM01EQm9NMmd6WXpNZ01TQTNJREVnTVRBZ01XTXhNaUF3SURJNUlDMDRJRE0zSUMweE4ydzVOQ0F0T1ROc05qWWdOalZqTlRjZ05UY2dNVFUxSURVM0lESXhNaUF3WXpVNElDMDFPQ0ExT0NBdE1UVTBJREFnTFRJeE1td3ROalVnTFRZMmJEa3pJQzA1TkdNeE1DQXRPQ0F4T0NBdE1qVWdNVGdnTFRNNFl6QWdMVEk0SUMweU1pQXROVEFnTFRVd0lDMDFNR010TVRNZ01DQXRNeklnT1NBdE5EQWdNakJzTFRZeUlEWTFiQzB6T0RFZ0xUTTRNV2d0TWpZNWRqSTNNbXd6TnpVZ016Z3hiQzAyTXlBMk0yTXRPU0E0SUMweE5pQXlOQ0F0TVRZZ016WmpNQ0F5TUNBeE5pQTBNaUF6TlNBME9Ib0tUVFEwTnlBME9ERnNMVE14TXlBdE16RTFiREV5T0NBdE1UTXliRE14TmlBek1UWjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJalkzSWlCMWJtbGpiMlJsUFNJbUkzaGxNRFkzT3lJZ0NtUTlJazB3SURnd01HZ3pNREIyTFRRd01HZzBNREIyTFRRd01HZ3ROekF3ZGpnd01IcE5OREF3SURnd01Hd3pNREFnTFRNd01HZ3RNekF3ZGpNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOamdpSUhWdWFXTnZaR1U5SWlZamVHVXdOamc3SWlBS1pEMGlUVEl3TUNBNE1EQmpNQ0F3SURJd01DQXRNVEF3SURJd01DQXRNekF3Y3kweU9UZ2dMVE13TWlBdE1qQXdJQzAxTURCak1DQXdJQzB5TURBZ01UQXdJQzB5TURBZ016QXdjek13TUNBek1EQWdNakF3SURVd01IcE5OVEF3SURVd01HTXdJREFnTWpBd0lDMHhNREFnTWpBd0lDMHpNREJqTUNBdE1UVXdJQzAyTUNBdE1qQXdJQzB4TURBZ0xUSXdNR2d0TXpBd1l6QWdNakF3SURNd01DQXpNREFnTWpBd0lEVXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTmpraUlIVnVhV052WkdVOUlpWWplR1V3TmprN0lpQUtaRDBpVFRBZ09EQXdhREV3TUhZdE9EQXdhQzB4TURCMk9EQXdlazB5TURBZ09EQXdhRE13TUhZdE1UQXdhRE13TUd3dE1qQXdJQzB5TUROc01qQXdJQzB4T1Rkb0xUUXdNSFl4TURCb0xUSXdNSFkwTURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqWmhJaUIxYm1samIyUmxQU0ltSTNobE1EWmhPeUlnYUc5eWFYb3RZV1IyTFhnOUlqUXdNQ0lnQ21ROUlrMHhOVEFnT0RBd2FERTFNR3d0TVRBd0lDMHlNREJvTWpBd2JDMHhOVEFnTFRNd01HZ3hOVEJzTFRNd01DQXRNekF3YkMweE1EQWdNekF3YURFek5HdzJOaUF5TURCb0xUSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTm1JaUlIVnVhV052WkdVOUlpWWplR1V3Tm1JN0lpQUtaRDBpVFRBZ09EQXdhRE13TUhZdE1UQXdhRFV3TUhZdE1UQXdhQzA0TURCMk1qQXdlazB3SURVd01HZzRNREIyTFRRMU1HTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRjd01HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdkalExTUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU5tTWlJSFZ1YVdOdlpHVTlJaVlqZUdVd05tTTdJaUFLWkQwaVRURTFNQ0E0TURCak9ETWdNQ0F4TlRBZ0xUWTNJREUxTUNBdE1UVXdZekFnTFRZMklDMDBNU0F0TVRJeElDMHhNREFnTFRFME1YWXRNVEU0WXpFMUlEVWdNek1nT1NBMU1DQTVhREl3TUdNeU9DQXdJRFV3SURJeUlEVXdJRFV3ZGpVNVl5MDFPU0F5TUNBdE1UQXdJRGMxSUMweE1EQWdNVFF4WXpBZ09ETWdOamNnTVRVd0lERTFNQ0F4TlRCek1UVXdJQzAyTnlBeE5UQWdMVEUxTUdNd0lDMDJOaUF0TkRFZ0xURXlNU0F0TVRBd0lDMHhOREYyTFRVNVl6QWdMVGd5SUMwMk9DQXRNVFV3SUMweE5UQWdMVEUxTUdndE1qQXdZeTB4TkNBd0lDMHlOU0F0TnlBdE16UWdMVEUyQ21NMU1DQXRNalFnT0RRZ0xUYzBJRGcwSUMweE16UmpNQ0F0T0RNZ0xUWTNJQzB4TlRBZ0xURTFNQ0F0TVRVd2N5MHhOVEFnTmpjZ0xURTFNQ0F4TlRCak1DQTJOaUEwTVNBeE1qRWdNVEF3SURFME1YWXlNVGhqTFRVNUlESXdJQzB4TURBZ056VWdMVEV3TUNBeE5ERmpNQ0E0TXlBMk55QXhOVEFnTVRVd0lERTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTm1RaUlIVnVhV052WkdVOUlpWWplR1V3Tm1RN0lpQUtaRDBpVFRBZ09EQXdhRFF3TUd3dE1UVXdJQzB4TlRCc01UVXdJQzB4TlRCc0xURXdNQ0F0TVRBd2JDMHhOVEFnTVRVd2JDMHhOVEFnTFRFMU1IWTBNREI2VFRVd01DQTBNREJzTVRVd0lDMHhOVEJzTVRVd0lERTFNSFl0TkRBd2FDMDBNREJzTVRVd0lERTFNR3d0TVRVd0lERTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpTm1VaUlIVnVhV052WkdVOUlpWWplR1V3Tm1VN0lpQUtaRDBpVFRFd01DQTRNREJzTVRVd0lDMHhOVEJzTVRVd0lERTFNSFl0TkRBd2FDMDBNREJzTVRVd0lERTFNR3d0TVRVd0lERTFNSHBOTkRBd0lEUXdNR2cwTURCc0xURTFNQ0F0TVRVd2JERTFNQ0F0TVRVd2JDMHhNREFnTFRFd01Hd3RNVFV3SURFMU1Hd3RNVFV3SUMweE5UQjJOREF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJMlppSWdkVzVwWTI5a1pUMGlKaU40WlRBMlpqc2lJQXBrUFNKTk5EQXdJRGd3TUdNeU1qRWdNQ0EwTURBZ0xURTNPU0EwTURBZ0xUUXdNSE10TVRjNUlDMDBNREFnTFRRd01DQXROREF3Y3kwME1EQWdNVGM1SUMwME1EQWdOREF3Y3pFM09TQTBNREFnTkRBd0lEUXdNSHBOTkRBd0lEY3dNR010TlRZZ01DQXRNVEE0SUMweE55QXRNVFV6SUMwME5Hd3lNaUF0TVRsak16TWdMVEU0SURFeklDMDBPQ0F0TVRNZ0xUVTVZeTB6TUNBdE1UTWdMVGMzSURFd0lDMDJOU0F0TkRGak1UTWdMVFUxSUMweU55QXRNeUF0TkRjZ0xURTFZeTAwTWlBdE1qWWdORGtnTFRFMU1pQXpNU0F0TVRVMmJDMDFPU0F6TkdNdE9DQXdJQzB4TXlBdE5TQXRNVFlnTFRFd0NtTXhJQzB6TUNBeE1DQXROVGNnTVRrZ0xUZzBZekk0SUMweE1TQTNOeUF0TWlBeE1EQWdMVEkxWXpRM0lDMHlPQ0E1TnlBdE1URTFJRGMxSUMweE5UbGpNelFnTFRFeklEWTRJQzB5TWlBeE1EWWdMVEl5WXpFd01TQXdJREU1TXlBME9DQXlORGNnTVRJMVl6TWdNalFnTFRnZ05EUWdMVFV3SURRMFl5MDJPU0F3SUMweE5UWWdNVE1nTFRFMU15QTVOMk15SURRMklERXdNU0F4TURnZ05qWWdNVFF6WXkwek1DQXpNQ0F4TWlBek9TQXhNaUEyTm1Nd0lETTNJQzAyTlNBek1pQXROamtnTlRCek1qQWdNellnTkRFZ05UWmpMVE13SURFd0lDMDJNQ0F4T1NBdE9UUWdNVGw2VFRZek1TQTFPVEVLWXkwek9DQXRNVEVnTFRrMElDMHpOU0F0T0RjZ0xUVXpZellnTFRFMUlEVXlJQzB4SURZMUlDMHhNMk14TVNBdE1UQWdNVFlnTFRVNUlEUTBJQzB6TVd3eU1pQXlNbll6WXkweE1TQXlOaUF0TWpZZ05UQWdMVFEwSURjeWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNNQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTNNRHNpSUFwa1BTSk5OekF6SURnd01HdzVOeUF0TVRBd2JDMDBNREFnTFRRd01Hd3RNVEF3SURFd01Hd3RNakF3SUMweU1ETnNMVEV3TUNBeE1EQnNNekF3SURNd00yd3hNREFnTFRFd01IcE5NQ0F4TURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqY3hJaUIxYm1samIyUmxQU0ltSTNobE1EY3hPeUlnQ21ROUlrMHdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk1qQXdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk5EQXdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk5qQXdJRGN3TUdneE1EQjJMVEV3TUdndE1UQXdkakV3TUhwTk1DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRJd01DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRRd01DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRZd01DQTFNREJvTVRBd2RpMHhNREJvTFRFd01IWXhNREI2VFRBZ016QXdhREV3TUhZdE1UQXdhQzB4TURCMk1UQXdlazB5TURBZ016QXdhREV3TUFwMkxURXdNR2d0TVRBd2RqRXdNSHBOTkRBd0lETXdNR2d4TURCMkxURXdNR2d0TVRBd2RqRXdNSHBOTmpBd0lETXdNR2d4TURCMkxURXdNR2d0TVRBd2RqRXdNSHBOTUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZUVEl3TUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZUVFF3TUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZUVFl3TUNBeE1EQm9NVEF3ZGkweE1EQm9MVEV3TUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamN5SWlCMWJtbGpiMlJsUFNJbUkzaGxNRGN5T3lJZ0NtUTlJazB3SURnd01HZ3lNREIyTFRJd01HZ3RNakF3ZGpJd01IcE5NekF3SURnd01HZ3lNREIyTFRJd01HZ3RNakF3ZGpJd01IcE5OakF3SURnd01HZ3lNREIyTFRJd01HZ3RNakF3ZGpJd01IcE5NQ0ExTURCb01qQXdkaTB5TURCb0xUSXdNSFl5TURCNlRUTXdNQ0ExTURCb01qQXdkaTB5TURCb0xUSXdNSFl5TURCNlRUWXdNQ0ExTURCb01qQXdkaTB5TURCb0xUSXdNSFl5TURCNlRUQWdNakF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWswek1EQWdNakF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWswMk1EQWdNakF3YURJd01IWXRNakF3YUMweU1EQjJNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJM015SWdkVzVwWTI5a1pUMGlKaU40WlRBM016c2lJQXBrUFNKTk1DQTRNREJvTXpBd2RpMHpNREJvTFRNd01IWXpNREI2VFRVd01DQTRNREJvTXpBd2RpMHpNREJvTFRNd01IWXpNREI2VFRBZ016QXdhRE13TUhZdE16QXdhQzB6TURCMk16QXdlazAxTURBZ016QXdhRE13TUhZdE16QXdhQzB6TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzTkNJZ2RXNXBZMjlrWlQwaUppTjRaVEEzTkRzaUlBcGtQU0pOTVRrZ09EQXdhRFkyTW1NeE1TQXdJREU1SUMwNElERTVJQzB4T1hZdE16TXhZekFnTFRJNElDMHlNaUF0TlRBZ0xUVXdJQzAxTUdndE5qQXdZeTB5T0NBd0lDMDFNQ0F5TWlBdE5UQWdOVEIyTXpNeFl6QWdNVEVnT0NBeE9TQXhPU0F4T1hwTk1DQXpNRGxqTVRZZ0xUWWdNeklnTFRrZ05UQWdMVGxvTmpBd1l6RTRJREFnTXpRZ015QTFNQ0E1ZGkweU9UQmpNQ0F0TVRFZ0xUZ2dMVEU1SUMweE9TQXRNVGxvTFRZMk1tTXRNVEVnTUNBdE1Ua2dPQ0F0TVRrZ01UbDJNamt3ZWswMU5UQWdNakF3WXkweU9DQXdJQzAxTUNBdE1qSWdMVFV3SUMwMU1ITXlNaUF0TlRBZ05UQWdMVFV3Q25NMU1DQXlNaUExTUNBMU1ITXRNaklnTlRBZ0xUVXdJRFV3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJM05TSWdkVzVwWTI5a1pUMGlKaU40WlRBM05Uc2lJQXBrUFNKTk1DQTNNREJvTXpBd2RpMHhNREJvTFRVd1l5MHlPQ0F3SUMwMU1DQXRNaklnTFRVd0lDMDFNSFl0TVRVd2FETXdNSFl4TlRCak1DQXlPQ0F0TWpJZ05UQWdMVFV3SURVd2FDMDFNSFl4TURCb016QXdkaTB4TURCb0xUVXdZeTB5T0NBd0lDMDFNQ0F0TWpJZ0xUVXdJQzAxTUhZdE5EQXdZekFnTFRJNElESXlJQzAxTUNBMU1DQXROVEJvTlRCMkxURXdNR2d0TXpBd2RqRXdNR2cxTUdNeU9DQXdJRFV3SURJeUlEVXdJRFV3ZGpFMU1HZ3RNekF3ZGkweE5UQmpNQ0F0TWpnZ01qSWdMVFV3SURVd0lDMDFNR2cxTUhZdE1UQXdhQzB6TURCMk1UQXdhRFV3WXpJNElEQWdOVEFnTWpJZ05UQWdOVEFLZGpRd01HTXdJREk0SUMweU1pQTFNQ0F0TlRBZ05UQm9MVFV3ZGpFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOellpSUhWdWFXTnZaR1U5SWlZamVHVXdOelk3SWlBS1pEMGlUVFF3TUNBM01EQmpNVFkxSURBZ016QXdJQzB4TXpVZ016QXdJQzB6TURCMkxURXdNR2cxTUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCMkxUSXdNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xURXdNR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZGpNMU1HTXdJREV4TVNBdE9Ea2dNakF3SUMweU1EQWdNakF3Y3kweU1EQWdMVGc1SUMweU1EQWdMVEl3TUhZdE16VXdZekFnTFRJNElDMHlNaUF0TlRBZ0xUVXdJQzAxTUdndE1UQXdZeTB5T0NBd0lDMDFNQ0F5TWlBdE5UQWdOVEIyTWpBd1l6QWdNamdnTWpJZ05UQWdOVEFnTlRCb05UQjJNVEF3Q21Nd0lERTJOU0F4TXpVZ016QXdJRE13TUNBek1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamMzSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGMzT3lJZ0NtUTlJazB3SURVd01HTXdJREV3T1NBNU1TQXlNREFnTWpBd0lESXdNSE15TURBZ0xUa3hJREl3TUNBdE1qQXdZekFnTVRBNUlEa3hJREl3TUNBeU1EQWdNakF3Y3pJd01DQXRPVEVnTWpBd0lDMHlNREJqTUNBdE5UVWdMVEl6SUMweE1EVWdMVFU1SUMweE5ERnNMVE0wTVNBdE16UXdiQzB6TkRFZ016UXdZeTB6TmlBek5pQXROVGtnT0RZZ0xUVTVJREUwTVhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU56Z2lJSFZ1YVdOdlpHVTlJaVlqZUdVd056ZzdJaUFLWkQwaVRUUXdNQ0EzTURCc05EQXdJQzB6TURCc0xURXdNQ0F6ZGkwME1ETm9MVEl3TUhZeU1EQm9MVEl3TUhZdE1qQXdhQzB5TURCMk5EQXdhQzB4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqYzVJaUIxYm1samIyUmxQU0ltSTNobE1EYzVPeUlnQ21ROUlrMHdJRGd3TUdnNE1EQjJMVGd3TUdndE9EQXdkamd3TUhwTk1UQXdJRGN3TUhZdE16QXdiREV3TUNBeE1EQnNOREF3SUMwME1EQm9NVEF3ZGpFd01Hd3RNakF3SURJd01Hd3hNREFnTVRBd2JERXdNQ0F0TVRBd2RqTXdNR2d0TmpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNZU0lnZFc1cFkyOWtaVDBpSmlONFpUQTNZVHNpSUFwa1BTSk5NVGtnT0RBd2FEYzJNbU14TVNBd0lERTVJQzA0SURFNUlDMHhPWFl0TnpZeVl6QWdMVEV4SUMwNElDMHhPU0F0TVRrZ0xURTVhQzAzTmpKakxURXhJREFnTFRFNUlEZ2dMVEU1SURFNWRqYzJNbU13SURFeElEZ2dNVGtnTVRrZ01UbDZUVEV3TUNBMk1EQjJMVE13TUdneE1EQnNNVEF3SUMweE1EQm9NakF3YkRFd01DQXhNREJvTVRBd2RqTXdNR2d0TmpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTNZaUlnZFc1cFkyOWtaVDBpSmlONFpUQTNZanNpSUFwa1BTSk5NakF3SURZd01HTTRNQ0F3SURFME1pQXROVFlnTWpBd0lDMHhNakpqTlRnZ05qWWdNVEU1SURFeU1pQXlNREFnTVRJeVl6RXpNU0F3SURJd01DQXRNVEF4SURJd01DQXRNakF3Y3kwMk9TQXRNakF3SUMweU1EQWdMVEl3TUdNdE9ERWdNQ0F0TVRReUlEVTJJQzB5TURBZ01USXlZeTAxT0NBdE5qWWdMVEV5TVNBdE1USXlJQzB5TURBZ0xURXlNbU10TVRNeElEQWdMVEl3TUNBeE1ERWdMVEl3TUNBeU1EQnpOamtnTWpBd0lESXdNQ0F5TURCNlRUSXdNQ0ExTURCakxUYzBJREFnTFRFd01DQXROVFFnTFRFd01DQXRNVEF3Y3pJMklDMHhNREFnTVRBd0lDMHhNREFLWXpReUlEQWdPRGdnTkRjZ01UTTBJREV3TUdNdE5EWWdOVE1nTFRreUlERXdNQ0F0TVRNMElERXdNSHBOTmpBd0lEVXdNR010TkRNZ01DQXRPRGdnTFRRM0lDMHhNelFnTFRFd01HTTBOaUF0TlRNZ09URWdMVEV3TUNBeE16UWdMVEV3TUdNM05DQXdJREV3TUNBMU5DQXhNREFnTVRBd2N5MHlOaUF4TURBZ0xURXdNQ0F4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqZGpJaUIxYm1samIyUmxQU0ltSTNobE1EZGpPeUlnYUc5eWFYb3RZV1IyTFhnOUlqUXdNQ0lnQ21ROUlrMHpNREFnT0RBd1l6VTFJREFnTVRBd0lDMDBOU0F4TURBZ0xURXdNSE10TkRVZ0xURXdNQ0F0TVRBd0lDMHhNREJ6TFRFd01DQTBOU0F0TVRBd0lERXdNSE0wTlNBeE1EQWdNVEF3SURFd01IcE5NVFV3SURVMU1HTTRNeUF3SURFMU1DQXROamtnTVRVd0lDMHhOVEJqTUNBdE5qWWdMVEV3TUNBdE1qRTBJQzB4TURBZ0xUSTFNR013SUMweU9DQXlNaUF0TlRBZ05UQWdMVFV3Y3pVd0lESXlJRFV3SURVd2FERXdNR013SUMwNE15QXROamNnTFRFMU1DQXRNVFV3SUMweE5UQnpMVEUxTUNBMk5DQXRNVFV3SURFMU1ITXhNREFnTWpJeUlERXdNQ0F5TlRCekxUSXlJRFV3SUMwMU1DQTFNQXB6TFRVd0lDMHlNaUF0TlRBZ0xUVXdhQzB4TURCak1DQTRNeUEyTnlBeE5UQWdNVFV3SURFMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlOMlFpSUhWdWFXTnZaR1U5SWlZamVHVXdOMlE3SWlBS1pEMGlUVEl3TUNBNE1EQm9OVEF3ZGkweE1EQm9MVEV5TW1NdE56Y2dMVEU1TnlBdE1UVTJJQzB6T1RJZ0xUSXpOQ0F0TlRnNGJDMDJJQzB4TW1neE5qSjJMVEV3TUdndE5UQXdkakV3TUdneE1qSmpOemNnTVRrM0lERTFOaUF6T1RJZ01qTTBJRFU0T0d3M0lERXlhQzB4TmpOMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0kzWlNJZ2RXNXBZMjlrWlQwaUppTjRaVEEzWlRzaUlBcGtQU0pOTUNBM01EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZUVEFnTlRBd2FEZ3dNSFl0TVRBd2FDMDRNREIyTVRBd2VrMHdJRE13TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1UQXdJREV3TUdnMk1EQjJMVEV3TUdndE5qQXdkakV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU4yWWlJSFZ1YVdOdlpHVTlJaVlqZUdVd04yWTdJaUFLWkQwaVRUQWdOekF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWswd0lEVXdNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTUNBek1EQm9PREF3ZGkweE1EQm9MVGd3TUhZeE1EQjZUVEFnTVRBd2FEWXdNSFl0TVRBd2FDMDJNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTRNQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTRNRHNpSUFwa1BTSk5NQ0EzTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUQWdOVEF3YURnd01IWXRNVEF3YUMwNE1EQjJNVEF3ZWswd0lETXdNR2c0TURCMkxURXdNR2d0T0RBd2RqRXdNSHBOTWpBd0lERXdNR2cyTURCMkxURXdNR2d0TmpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT0RFaUlIVnVhV052WkdVOUlpWWplR1V3T0RFN0lpQUtaRDBpVFRVMU1DQTRNREJqTVRNNElEQWdNalV3SUMweE1USWdNalV3SUMweU5UQnpMVEV4TWlBdE1qVXdJQzB5TlRBZ0xUSTFNR010TVRZZ01DQXRNeklnTUNBdE5EY2dNMnd0TXlBdE0zWXRNVEF3YUMweU1EQjJMVEl3TUdndE16QXdkakl3TUd3ek1ETWdNekF6WXkweklERTFJQzB6SURNeElDMHpJRFEzWXpBZ01UTTRJREV4TWlBeU5UQWdNalV3SURJMU1IcE5OakF3SURjd01HTXROVFVnTUNBdE1UQXdJQzAwTlNBdE1UQXdJQzB4TURCek5EVWdMVEV3TUNBeE1EQWdMVEV3TUhNeE1EQWdORFVnTVRBd0lERXdNSE10TkRVZ01UQXdJQzB4TURBZ01UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0TWlJZ2RXNXBZMjlrWlQwaUppTjRaVEE0TWpzaUlBcGtQU0pOTVRNMElEWXdNR2d6YURSb05HZzFhRFV3TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCMkxUTTFNR2d4TURCMkxURTFNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCb0xUY3dNR010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3ZGpFMU1HZ3hNREIyTXpVd2RqSmpNQ0F5TUNBeE5TQTBNaUF6TkNBME9IcE5NakF3SURVd01IWXRNekF3YURFd01IWXRNVEF3YURJd01IWXhNREJvTVRBd2RqTXdNR2d0TkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTRNeUlnZFc1cFkyOWtaVDBpSmlONFpUQTRNenNpSUFwa1BTSk5NQ0E0TURCb05EQXdkaTAwTURCb0xUUXdNSFkwTURCNlRUVXdNQ0EyTURCb01UQXdkaTAwTURCb0xUUXdNSFl4TURCb016QXdkak13TUhwTk56QXdJRFF3TUdneE1EQjJMVFF3TUdndE5EQXdkakV3TUdnek1EQjJNekF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNE5DSWdkVzVwWTI5a1pUMGlKaU40WlRBNE5Ec2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16TTNJRFk1TkdNMklEUWdNVElnTnlBeU1TQTNZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNR013SUMweE55QXRNVElnTFRNM0lDMHlOeUF0TkRWc0xUTXdNQ0F0TVRVd1l5MDRJQzAySUMweU1TQXRNVEVnTFRNeElDMHhNV010TWpnZ01DQXROVEFnTWpJZ0xUVXdJRFV3WXpBZ01qRWdNVFlnTkRRZ016Y2dORGw2VFRRek55QTFORFJqTmlBMElERXlJRGNnTWpFZ04yTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQmpNQ0F0TVRjZ0xURXlJQzB6TnlBdE1qY2dMVFExYkMwME1EQWdMVEl3TUdNdE9DQXROaUF0TWpFZ0xURXhJQzB6TVNBdE1URmpMVEk0SURBZ0xUVXdJREl5SUMwMU1DQTFNQXBqTUNBeU1TQXhOaUEwTkNBek55QTBPWHBOTkRNM0lETTBOR00ySURRZ01USWdOeUF5TVNBM1l6STRJREFnTlRBZ0xUSXlJRFV3SUMwMU1HTXdJQzB4TnlBdE1USWdMVE0zSUMweU55QXRORFZzTFRFd05pQXROVFpqTWpRZ0xUUWdORE1nTFRJMklEUXpJQzAxTUdNd0lDMHlPQ0F0TWpNZ0xUVXhJQzAxTVNBdE5URmpMVElnTUNBdE5pQXhJQzA0SURGb0xUSXdNR010TWpZZ01TQXRORGdnTWpRZ0xUUTRJRFV3WXpBZ01UWWdNVElnTXpZZ01qWWdORFI2VFRFMU1TQXROVEJqTUNBeU15QXlNQ0ExTUNBME5pQTFNR2d6YURSb05XZ3hNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Q25NdE1qSWdMVFV3SUMwMU1DQXROVEJvTFRFd01HTXRNaUF3SUMwMklDMHhJQzA0SUMweFl5MHlPQ0F3SUMwMU1DQXlNeUF0TlRBZ05URjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamcxSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGcxT3lJZ0NtUTlJazB4T1RrZ09EQXdhREV3TUhZdE1qQXdhQzB5TURCMk1UQXdhREV3TUhZeE1EQjZUVFU0TmlBM09UZG9NV014T0NBeElETTRJREVnTlRZZ0xUTmpNellnTFRnZ05qa2dMVEkySURrM0lDMDFOR00zT0NBdE56Z2dOemdnTFRJd015QXdJQzB5T0RGc0xURTFNQ0F0TVRVd1l5MDRJQzB4TXlBdE1qZ2dMVEkwSUMwME15QXRNalJqTFRJNElEQWdMVFV3SURJeUlDMDFNQ0ExTUdNd0lERTFJREV4SURNMUlESTBJRFF6YkRFMU1DQXhOVEJqTkRBZ05EQWdNemtnTVRBMUlEQWdNVFEwWXkwME1TQTBNU0F0TVRFd0lETTBJQzB4TkRRZ01Hd3RORFFnTFRRMENtTXRPQ0F0TVRNZ0xUSTNJQzB5TkNBdE5ESWdMVEkwWXkweU9DQXdJQzAxTUNBeU1pQXROVEFnTlRCak1DQXhOU0F4TVNBek5TQXlOQ0EwTTJ3ME15QTBOR016TWlBek15QTNNaUExTXlBeE1qZ2dOVFo2VFRJd09DQTBPVEJqTkNBMUlERTBJREUySURJeUlERTJhRE5qTWlBd0lEWWdNU0E0SURGak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd1l6QWdMVEV4SUMwMklDMHlOeUF0TVRRZ0xUTTFiQzB4TlRBZ0xURTFNR010TkRBZ0xUUXdJQzB6T1NBdE1UQTFJREFnTFRFME5HTTBNU0F0TkRFZ01URXdJQzB6TkNBeE5EUWdNR3cwTkNBME5HTTRJREV6SURJM0lESTBJRFF5SURJMENtTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQmpNQ0F0TVRVZ0xURXhJQzB6TlNBdE1qUWdMVFF6YkMwME15QXRORFJqTFRJeUlDMHlNaUF0TkRnZ0xUTTNJQzAzTlNBdE5EZGpMVGN3SUMweU5TQXRNVFV4SUMwNUlDMHlNRGNnTkRkakxUYzRJRGM0SUMwM09DQXlNRE1nTUNBeU9ERjZUVFE1T1NBeU1EQm9NakF3ZGkweE1EQm9MVEV3TUhZdE1UQXdhQzB4TURCMk1qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0TmlJZ2RXNXBZMjlrWlQwaUppTjRaVEE0TmpzaUlBcGtQU0pOTlRnMklEYzVOMk14T0NBeElETTVJREVnTlRjZ0xUTmpNellnTFRnZ05qa2dMVEkySURrM0lDMDFOR00zT0NBdE56Z2dOemdnTFRJd015QXdJQzB5T0RGc0xURTFNQ0F0TVRVd1l5MDJNaUF0TmpJZ0xURXpNaUF0T0RFZ0xURTRNaUF0TnpoekxUWTVJREUzSUMwNE5DQXlOWE10TWpZZ01qY2dMVEkySURRMFl6QWdNamdnTWpJZ05URWdOVEFnTlRGak9DQXdJREU1SUMweklESTJJQzAzWXpBZ01DQXhOU0F0TVRFZ05ERWdMVEV6Y3pZeUlETWdNVEEySURRM2JERTFNQ0F4TlRCak5EQWdOREFnTXprZ01UQTFJREFnTVRRMFl5MDBNU0EwTVNBdE1URXdJRE0wSUMweE5EUWdNQXBqTFRnZ0xURXpJQzB5T0NBdE1qUWdMVFF6SUMweU5HTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdZekFnTVRVZ01URWdNelVnTWpRZ05ETmpNeklnTXpNZ056SWdOVE1nTVRJNElEVTJlazB6T0RZZ05UWTJZelV3SUMweUlEWTBJQzB4TnlBNE5TQXRNakp6TXpjZ0xUSTRJRE0zSUMwME9XTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJqTFRFd0lEQWdMVEl6SURVZ0xUTXhJREV4WXpBZ01DQXRNVGtnT1NBdE5EY2dNVEJ6TFRZeklDMDBJQzB4TURNZ0xUUTBiQzB4TlRBZ0xURTFNR010TkRBZ0xUUXdJQzB6T1NBdE1UQTFJREFnTFRFME5HTTBNU0F0TkRFZ01URXdJQzB6TkNBeE5EUWdNQXBqT0NBeE15QXlOeUF5TkNBME1pQXlOR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJqTUNBdE1UVWdMVEV3SUMwek5TQXRNak1nTFRRell5MHlNaUF0TWpJZ0xUUTRJQzB6TnlBdE56VWdMVFEzWXkwM01DQXRNalVnTFRFMU1TQXRPU0F0TWpBM0lEUTNZeTAzT0NBM09DQXROemdnTWpBeklEQWdNamd4YkRFMU1DQXhOVEJqTmpBZ05qQWdNVEk0SURjNElERTNPQ0EzTm5vaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9EY2lJSFZ1YVdOdlpHVTlJaVlqZUdVd09EYzdJaUFLWkQwaVRUQWdOekF3YURNd01IWXRNekF3YUMwek1EQjJNekF3ZWswME1EQWdOekF3YURRd01IWXRNVEF3YUMwME1EQjJNVEF3ZWswME1EQWdOVEF3YURNd01IWXRNVEF3YUMwek1EQjJNVEF3ZWswd0lETXdNR2d6TURCMkxUTXdNR2d0TXpBd2RqTXdNSHBOTkRBd0lETXdNR2cwTURCMkxURXdNR2d0TkRBd2RqRXdNSHBOTkRBd0lERXdNR2d6TURCMkxURXdNR2d0TXpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT0RnaUlIVnVhV052WkdVOUlpWWplR1V3T0RnN0lpQUtaRDBpVFRVd0lEY3dNR015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEJ6TFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCek1qSWdOVEFnTlRBZ05UQjZUVEl3TUNBM01EQm9OakF3ZGkweE1EQm9MVFl3TUhZeE1EQjZUVFV3SURVd01HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEJ6TWpJZ05UQWdOVEFnTlRCNlRUSXdNQ0ExTURCb05qQXdkaTB4TURCb0xUWXdNSFl4TURCNlRUVXdJRE13TUdNeU9DQXdJRFV3SUMweU1pQTFNQ0F0TlRCekxUSXlJQzAxTUNBdE5UQWdMVFV3Y3kwMU1DQXlNaUF0TlRBZ05UQUtjekl5SURVd0lEVXdJRFV3ZWsweU1EQWdNekF3YURZd01IWXRNVEF3YUMwMk1EQjJNVEF3ZWswMU1DQXhNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazB5TURBZ01UQXdhRFl3TUhZdE1UQXdhQzAyTURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0T1NJZ2RXNXBZMjlrWlQwaUppTjRaVEE0T1RzaUlBcGtQU0pOT0RBd0lEZ3dNR3d0TkRBd0lDMDRNREJzTFRFd01DQXpNREJzTFRNd01DQXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpoaElpQjFibWxqYjJSbFBTSW1JM2hsTURoaE95SWdhRzl5YVhvdFlXUjJMWGc5SWpZd01DSWdDbVE5SWswek1EQWdOekF3WXpFeE1DQXdJREl3TUNBdE9UQWdNakF3SUMweU1EQjJMVEV3TUdneE1EQjJMVFF3TUdndE5qQXdkalF3TUdneE1EQjJNVEF3WXpBZ01URXdJRGt3SURJd01DQXlNREFnTWpBd2VrMHpNREFnTmpBd1l5MDFOaUF3SUMweE1EQWdMVFEwSUMweE1EQWdMVEV3TUhZdE1UQXdhREl3TUhZeE1EQmpNQ0ExTmlBdE5EUWdNVEF3SUMweE1EQWdNVEF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNFlpSWdkVzVwWTI5a1pUMGlKaU40WlRBNFlqc2lJR2h2Y21sNkxXRmtkaTE0UFNJMk1EQWlJQXBrUFNKTk16QXdJRGd3TUdNeE1UQWdNQ0F5TURBZ0xUa3dJREl3TUNBdE1qQXdkaTB5TURCb01UQXdkaTAwTURCb0xUWXdNSFkwTURCb05EQXdkakl3TUdNd0lEVTJJQzAwTkNBeE1EQWdMVEV3TUNBeE1EQnpMVEV3TUNBdE5EUWdMVEV3TUNBdE1UQXdhQzB4TURCak1DQXhNVEFnT1RBZ01qQXdJREl3TUNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamhqSWlCMWJtbGpiMlJsUFNJbUkzaGxNRGhqT3lJZ0NtUTlJazAwTURBZ056QXdkaTB4TURCakxURXhNU0F3SUMweU1EQWdMVGc1SUMweU1EQWdMVEl3TUdneE1EQnNMVEUxTUNBdE1qQXdiQzB4TlRBZ01qQXdhREV3TUdNd0lERTJOU0F4TXpVZ016QXdJRE13TUNBek1EQjZUVFkxTUNBMk1EQnNNVFV3SUMweU1EQm9MVEV3TUdNd0lDMHhOalVnTFRFek5TQXRNekF3SUMwek1EQWdMVE13TUhZeE1EQmpNVEV4SURBZ01qQXdJRGc1SURJd01DQXlNREJvTFRFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPR1FpSUhWdWFXTnZaR1U5SWlZamVHVXdPR1E3SWlBS1pEMGlUVEV3TUNBNE1EQm9OakF3ZGkwek1EQm9NVEF3YkMweE5UQWdMVEkxTUd3dE1UVXdJREkxTUdneE1EQjJNakF3YUMwME1EQjJMVEV3TUdndE1UQXdkakl3TUhwTk1UVXdJRFUxTUd3eE5UQWdMVEkxTUdndE1UQXdkaTB5TURCb05EQXdkakV3TUdneE1EQjJMVEl3TUdndE5qQXdkak13TUdndE1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k0WlNJZ2RXNXBZMjlrWlQwaUppTjRaVEE0WlRzaUlBcGtQU0pOTmpBd0lEY3dNR3d5TURBZ0xURTFNR3d0TWpBd0lDMHhOVEIyTVRBd2FDMDFNREIyTFRFd01HZ3RNVEF3ZGpFd01HTXdJRFUxSURRMUlERXdNQ0F4TURBZ01UQXdhRFV3TUhZeE1EQjZUVEl3TUNBek1EQjJMVEV3TUdnMU1EQjJNVEF3YURFd01IWXRNVEF3WXpBZ0xUVTFJQzAwTlNBdE1UQXdJQzB4TURBZ0xURXdNR2d0TlRBd2RpMHhNREJzTFRJd01DQXhOVEI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SWpobUlpQjFibWxqYjJSbFBTSW1JM2hsTURobU95SWdhRzl5YVhvdFlXUjJMWGc5SWprd01DSWdDbVE5SWswek5UQWdPREF3WXpFNU15QXdJRE0xTUNBdE1UVTNJRE0xTUNBdE16VXdZekFnTFRZd0lDMHhOeUF0TVRFM0lDMDBOQ0F0TVRZMll6VWdMVE1nTVRJZ0xUZ2dNVFlnTFRFeWJERXdNQ0F0TVRBd1l6RTJJQzB4TmlBek1DQXRORGtnTXpBZ0xUY3lZekFnTFRVMklDMDBOaUF0TVRBeUlDMHhNRElnTFRFd01tTXRNak1nTUNBdE5UWWdNVFFnTFRjeUlETXdiQzB4TURBZ01UQXdZeTAwSURNZ0xUa2dPU0F0TVRJZ01UTmpMVFE1SUMweU5pQXRNVEEzSUMwME1TQXRNVFkySUMwME1XTXRNVGt6SURBZ0xUTTFNQ0F4TlRjZ0xUTTFNQ0F6TlRCek1UVTNJRE0xTUNBek5UQWdNelV3ZWswek5UQWdNakF3Q21NeE5ESWdNQ0F5TlRBZ01UQTRJREkxTUNBeU5UQmpNQ0F4TXprZ0xURXhNU0F5TlRBZ0xUSTFNQ0F5TlRCekxUSTFNQ0F0TVRFeElDMHlOVEFnTFRJMU1ITXhNVEVnTFRJMU1DQXlOVEFnTFRJMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPVEFpSUhWdWFXTnZaR1U5SWlZamVHVXdPVEE3SWlCb2IzSnBlaTFoWkhZdGVEMGlOakF3SWlBS1pEMGlUVE13TUNBNE1EQmpNVFkySURBZ016QXdJQzB4TXpRZ016QXdJQzB6TURCak1DQXRNakF3SUMwek1EQWdMVFV3TUNBdE16QXdJQzAxTURCekxUTXdNQ0F6TURBZ0xUTXdNQ0ExTURCak1DQXhOallnTVRNMElETXdNQ0F6TURBZ016QXdlazB6TURBZ056QXdZeTB4TVRBZ01DQXRNakF3SUMwNU1DQXRNakF3SUMweU1EQnpPVEFnTFRJd01DQXlNREFnTFRJd01ITXlNREFnT1RBZ01qQXdJREl3TUhNdE9UQWdNakF3SUMweU1EQWdNakF3ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNJNU1TSWdkVzVwWTI5a1pUMGlKaU40WlRBNU1Uc2lJR2h2Y21sNkxXRmtkaTE0UFNJNU1EQWlJQXBrUFNKTk1DQTRNREJvT0RBd2RpMDFOREZqTVNBdE15QXhJQzA0SURFZ0xURXhjekFnTFRjZ0xURWdMVEV3ZGkweU16aG9MVGd3TUhZNE1EQjZUVFE1TlNBeU5UQmpNQ0F5TmlBeU1pQTFNQ0ExTUNBMU1HZzFhREUxTUhZME1EQm9MVFl3TUhZdE5qQXdhRFl3TUhZeE1EQm9MVEUxTUdndE5XTXRNamdnTUNBdE5UQWdNaklnTFRVd0lEVXdlazB6TlRBZ05qQXdZemd6SURBZ01UVXdJQzAyTnlBeE5UQWdMVEUxTUdNd0lDMHhNREFnTFRFMU1DQXRNalV3SUMweE5UQWdMVEkxTUhNdE1UVXdJREUxTUNBdE1UVXdJREkxTUdNd0lEZ3pJRFkzSURFMU1DQXhOVEFnTVRVd2VrMHpOVEFnTlRBd0NtTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJ6TWpJZ0xUVXdJRFV3SUMwMU1ITTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTVNaUlnZFc1cFkyOWtaVDBpSmlONFpUQTVNanNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5NQ0EzTURCb01qQXdkaTAyTURCb0xUSXdNSFkyTURCNlRUUXdNQ0EzTURCb01qQXdkaTAyTURCb0xUSXdNSFkyTURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqa3pJaUIxYm1samIyUmxQU0ltSTNobE1Ea3pPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHdJRGN3TUd3Mk1EQWdMVE13TUd3dE5qQXdJQzB6TURCMk5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1TkNJZ2RXNXBZMjlrWlQwaUppTjRaVEE1TkRzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTXpBd0lEY3dNR014TmpZZ01DQXpNREFnTFRFek5DQXpNREFnTFRNd01ITXRNVE0wSUMwek1EQWdMVE13TUNBdE16QXdjeTB6TURBZ01UTTBJQzB6TURBZ016QXdjekV6TkNBek1EQWdNekF3SURNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPVFVpSUhWdWFXTnZaR1U5SWlZamVHVXdPVFU3SWlBS1pEMGlUVFF3TUNBM01EQjJMVFl3TUd3dE5EQXdJRE13TUhwTk5EQXdJRFF3TUd3ME1EQWdNekF3ZGkwMk1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJamsySWlCMWJtbGpiMlJsUFNJbUkzaGxNRGsyT3lJZ0NtUTlJazB3SURjd01HdzBNREFnTFRNd01Hd3ROREF3SUMwek1EQjJOakF3ZWswME1EQWdNVEF3ZGpZd01HdzBNREFnTFRNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlPVGNpSUhWdWFXTnZaR1U5SWlZamVHVXdPVGM3SWlBS1pEMGlUVEFnTnpBd2FESXdNSFl0TmpBd2FDMHlNREIyTmpBd2VrMHlNREFnTkRBd2JEVXdNQ0F6TURCMkxUWXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpT1RnaUlIVnVhV052WkdVOUlpWWplR1V3T1RnN0lpQUtaRDBpVFRBZ056QXdiRFV3TUNBdE16QXdiQzAxTURBZ0xUTXdNSFkyTURCNlRUVXdNQ0F4TURCMk5qQXdhREl3TUhZdE5qQXdhQzB5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqazVJaUIxYm1samIyUmxQU0ltSTNobE1EazVPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHdJRGN3TUdnMk1EQjJMVFl3TUdndE5qQXdkall3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaU9XRWlJSFZ1YVdOdlpHVTlJaVlqZUdVd09XRTdJaUFLWkQwaVRUSXdNQ0E0TURCb05EQXdkaTB5TURCb01qQXdkaTAwTURCb0xUSXdNSFl0TWpBd2FDMDBNREIyTWpBd2FDMHlNREIyTkRBd2FESXdNSFl5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqbGlJaUIxYm1samIyUmxQU0ltSTNobE1EbGlPeUlnQ21ROUlrMHdJRGN3TUdnNE1EQjJMVEV3TUdndE9EQXdkakV3TUhwTk1DQTBNRE5vT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRBZ01UQXphRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1WXlJZ2RXNXBZMjlrWlQwaUppTjRaVEE1WXpzaUlHaHZjbWw2TFdGa2RpMTRQU0kyTURBaUlBcGtQU0pOTWpjNElEY3dNR00zSURJZ01UTWdOQ0F5TWlBMFl6VTFJREFnTVRBd0lDMDBOU0F4TURBZ0xURXdNSFl0TkhZdE1qQXdZekFnTFRVMUlDMDBOU0F0TVRBd0lDMHhNREFnTFRFd01ITXRNVEF3SURRMUlDMHhNREFnTVRBd2RqSXdNSFl5WXpBZ05EUWdNelVnT0RnZ056Z2dPVGg2VFRNMElEVXdNR2cwYUROak15QXdJRFlnTVNBNUlERmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTB4ZGkwMU1HTXdJQzB4TVRFZ09Ea2dMVEl3TUNBeU1EQWdMVEl3TUhNeU1EQWdPRGtnTWpBd0lESXdNSFkxTUdNd0lESTRJREl5SURVd0lEVXdJRFV3Y3pVd0lDMHlNaUExTUNBdE5UQjJMVFV3Q21Nd0lDMHhORGdnTFRFd09TQXRNamN3SUMweU5UQWdMVEk1TkhZdE1UQTJhRFV3WXpVMUlEQWdNVEF3SUMwME5TQXhNREFnTFRFd01HZ3ROREF3WXpBZ05UVWdORFVnTVRBd0lERXdNQ0F4TURCb05UQjJNVEEyWXkweE5ERWdNalFnTFRJMU1DQXhORFlnTFRJMU1DQXlPVFIyTlRCMk1tTXdJREl3SURFMUlEUXlJRE0wSURRNGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSTVaQ0lnZFc1cFkyOWtaVDBpSmlONFpUQTVaRHNpSUFwa1BTSk5NQ0ExTURCb09EQXdkaTB5TURCb0xUZ3dNSFl5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUlqbGxJaUIxYm1samIyUmxQU0ltSTNobE1EbGxPeUlnQ21ROUlrMHpOQ0EzTURCb05HZ3phRFJvTldnM01EQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTAxTURCak1DQXRNamdnTFRJeUlDMDFNQ0F0TlRBZ0xUVXdhQzB5TlRCMkxURXdNR2d4TURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdhQzAyTURCak1DQTFOU0EwTlNBeE1EQWdNVEF3SURFd01HZ3hNREIyTVRBd2FDMHlOVEJqTFRJNElEQWdMVFV3SURJeUlDMDFNQ0ExTUhZMU1EQjJNbU13SURJd0lERTFJRFF5SURNMElEUTRlazB4TURBZ05qQXdkaTAwTURCb05qQXdkalF3TUdndE5qQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0k1WmlJZ2RXNXBZMjlrWlQwaUppTjRaVEE1WmpzaUlBcGtQU0pOTWpjeUlEY3dNR010TVRRZ0xUUXdJQzB5TWlBdE9ETWdMVEl5SUMweE1qaGpNQ0F0TWpJeElERTNPU0F0TkRBd0lEUXdNQ0F0TkRBd1l6UTFJREFnT0RnZ09DQXhNamdnTWpKakxUVXpJQzB4TlRnZ0xUSXdNaUF0TWpjeUlDMHpOemdnTFRJM01tTXRNakl4SURBZ0xUUXdNQ0F4TnprZ0xUUXdNQ0EwTURCak1DQXhOellnTVRFMElETXlOU0F5TnpJZ016YzRlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poTUNJZ2RXNXBZMjlrWlQwaUppTjRaVEJoTURzaUlBcGtQU0pOTXpVd0lEY3dNR3d4TlRBZ0xURTFNR2d0TVRBd2RpMHhOVEJvTVRVd2RqRXdNR3d4TlRBZ0xURTFNR3d0TVRVd0lDMHhOVEIyTVRBd2FDMHhOVEIyTFRFMU1HZ3hNREJzTFRFMU1DQXRNVFV3YkMweE5UQWdNVFV3YURFd01IWXhOVEJvTFRFMU1IWXRNVEF3YkMweE5UQWdNVFV3YkRFMU1DQXhOVEIyTFRFd01HZ3hOVEIyTVRVd2FDMHhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1FeElpQjFibWxqYjJSbFBTSW1JM2hsTUdFeE95SWdDbVE5SWswNE1EQWdPREF3ZGkwMU5UQmpNQ0F0T0RNZ0xUWTNJQzB4TlRBZ0xURTFNQ0F0TVRVd2N5MHhOVEFnTmpjZ0xURTFNQ0F4TlRCek5qY2dNVFV3SURFMU1DQXhOVEJqTVRjZ01DQXpOU0F0TkNBMU1DQXRPWFl5TURaakxUSXdNU0F0TmlBdE16STNJQzB5TnlBdE5EQXdJQzAxTUhZdE16azNZekFnTFRneklDMDJOeUF0TVRVd0lDMHhOVEFnTFRFMU1ITXRNVFV3SURZM0lDMHhOVEFnTVRVd2N6WTNJREUxTUNBeE5UQWdNVFV3WXpFM0lEQWdNelVnTFRRZ05UQWdMVGwyTkRBNWN6RXdNQ0F4TURBZ05qQXdJREV3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVlUSWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1lUSTdJaUJvYjNKcGVpMWhaSFl0ZUQwaU56QXdJaUFLWkQwaVRUUTVPU0EzTURCak5URWdNQ0F4TURJZ0xUSXdJREUwTVNBdE5UbGpOemdnTFRjNElEYzRJQzB5TURNZ01DQXRNamd4YkMweU5UQWdMVEkwTkdNdE5EZ2dMVFE0SUMweE1qY2dMVFE0SUMweE56VWdNSE10TkRnZ01USTNJREFnTVRjMWJEazJJRGszYkRZNUlDMDJPV3d0T1RBZ0xUazBiQzAzSUMwell5MHhNQ0F0TVRBZ0xURXdJQzB5T0NBd0lDMHpPSE15T0NBdE1UQWdNemdnTUd3eU5UQWdNalEzWXpNM0lEUXdJRE01SURFd01pQXdJREUwTVhNdE1UQTBJRFF3SUMweE5EUWdNR3d0TWpjNElDMHlOelZqTFRZMklDMDJPU0F0TmpnZ0xURTNPU0F3SUMweU5EY0tZelk1SUMwMk9TQXhPREVnTFRZNUlESTFNQ0F3YkRrZ01USnNNVEUySURFeE0ydzJPU0F0Tmpsc0xURXlOU0F0TVRJMVl5MHhNRGNnTFRFd055QXRNamd4SUMweE1EY2dMVE00T0NBd2N5MHhNRGNnTWpneElEQWdNemc0YkRJM09DQXlOekpqTXprZ016a2dPVEFnTlRrZ01UUXhJRFU1ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKaE15SWdkVzVwWTI5a1pUMGlKaU40WlRCaE16c2lJQXBrUFNKTk5qQXdJRGd3TUd3eU1EQWdMVEl3TUd3dE1UQXdJQzB4TURCc0xUSXdNQ0F5TURCNlRUUXdNQ0EyTURCc01qQXdJQzB5TURCc0xUUXdNQ0F0TkRBd2FDMHlNREIyTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhOQ0lnZFc1cFkyOWtaVDBpSmlONFpUQmhORHNpSUFwa1BTSk5OVFV3SURnd01HTTRNeUF3SURFMU1DQXRPVEFnTVRVd0lDMHlNREJ6TFRZM0lDMHlNREFnTFRFMU1DQXRNakF3WXkweU1pQXdJQzAwTUNBNElDMDFPU0F4T1dNMklESTJJRGtnTlRJZ09TQTRNV013SURnMElDMHlOeUF4TlRnZ0xUY3lJREl4TW1NeU55QTFNaUEzTVNBNE9DQXhNaklnT0RoNlRUSTFNQ0EzTURCak9ETWdNQ0F4TlRBZ0xUa3dJREUxTUNBdE1qQXdjeTAyTnlBdE1qQXdJQzB4TlRBZ0xUSXdNSE10TVRVd0lEa3dJQzB4TlRBZ01qQXdjelkzSURJd01DQXhOVEFnTWpBd2VrMDNNalVnTXpnMFl6UTBJQzB5TWlBM05TQXROallnTnpVZ0xURXhPSFl0TVRZMmFDMHlNREIyTmpZS1l6QWdOVEFnTFRFM0lEazJJQzAwTkNBeE16UmpOallnTWlBeE1qWWdNek1nTVRZNUlEZzBlazAzTlNBeU9EUmpORFVnTFRVeklERXdOaUF0T0RRZ01UYzFJQzA0TkhNeE16QWdNekVnTVRjMUlEZzBZelEwSUMweU1pQTNOU0F0TmpZZ056VWdMVEV4T0hZdE1UWTJhQzAxTURCMk1UWTJZekFnTlRJZ016RWdPVFlnTnpVZ01URTRlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poTlNJZ2RXNXBZMjlrWlQwaUppTjRaVEJoTlRzaUlBcGtQU0pOTkRBd0lEZ3dNR014TVRBZ01DQXlNREFnTFRFeE1pQXlNREFnTFRJMU1ITXRPVEFnTFRJMU1DQXRNakF3SUMweU5UQnpMVEl3TUNBeE1USWdMVEl3TUNBeU5UQnpPVEFnTWpVd0lESXdNQ0F5TlRCNlRURTVNU0F6TURCak5UUWdMVFl4SURFeU9DQXRNVEF3SURJd09TQXRNVEF3Y3pFMU5TQXpPU0F5TURrZ01UQXdZekV3TmlBdE5TQXhPVEVnTFRreUlERTVNU0F0TWpBd2RpMHhNREJvTFRnd01IWXhNREJqTUNBeE1EZ2dPRFVnTVRrMUlERTVNU0F5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltRTJJaUIxYm1samIyUmxQU0ltSTNobE1HRTJPeUlnYUc5eWFYb3RZV1IyTFhnOUlqWXdNQ0lnQ21ROUlrMHhPU0E0TURCb05EWXlZekV4SURBZ01Ua2dMVGdnTVRrZ0xURTVkaTAzTmpKak1DQXRNVEVnTFRnZ0xURTVJQzB4T1NBdE1UbG9MVFEyTW1NdE1URWdNQ0F0TVRrZ09DQXRNVGtnTVRsMk56WXlZekFnTVRFZ09DQXhPU0F4T1NBeE9YcE5NVEF3SURjd01IWXROVEF3YURNd01IWTFNREJvTFRNd01IcE5NalV3SURFMU1HTXRNamdnTUNBdE5UQWdMVEl5SUMwMU1DQXROVEJ6TWpJZ0xUVXdJRFV3SUMwMU1ITTFNQ0F5TWlBMU1DQTFNSE10TWpJZ05UQWdMVFV3SURVd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhOeUlnZFc1cFkyOWtaVDBpSmlONFpUQmhOenNpSUFwa1BTSk5NelV3SURnd01HTXhOeUF3SURNMElDMHhJRFV3SUMwemRpMHpPVGRzTFRJNU55QXlPVGRqTmpNZ05qUWdNVFV3SURFd015QXlORGNnTVRBemVrMDFNREFnTmprMFl6RTJPU0F0TWpVZ016QXdJQzB4TmpnZ016QXdJQzB6TkRSak1DQXRNVGt6SUMweE5UY2dMVE0xTUNBdE16VXdJQzB6TlRCakxUZzFJREFnTFRFMk1TQXpNU0F0TWpJeUlEZ3hiREkzTWlBeU56SjJNelF4ZWswNU1TQTFOakpzTWpNM0lDMHlNelJzTFRJeE1pQXRNakV5WXkwM01DQTFOU0F0TVRFMklERXpPQ0F0TVRFMklESXpOR013SURnMElETTFJREUxT0NBNU1TQXlNVEo2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1FNElpQjFibWxqYjJSbFBTSW1JM2hsTUdFNE95SWdDbVE5SWswNU1pQTJOVEJqTUNBeU15QXlNQ0ExTUNBME5pQTFNR2d6YURSb05XZzBNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNR2d0TlRCMkxUSXdNR2d4TURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdhQzB6TURCMkxUTXdNR3d0TlRZZ0xURXdNR3d0TkRRZ01UQXdkak13TUdndE16QXdZekFnTlRVZ05EVWdNVEF3SURFd01DQXhNREJvTVRBd2RqSXdNR2d0TlRCakxUSWdNQ0F0TmlBdE1TQXRPQ0F0TVdNdE1qZ2dNQ0F0TlRBZ01qTWdMVFV3SURVeGVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhPU0lnZFc1cFkyOWtaVDBpSmlONFpUQmhPVHNpSUFwa1BTSk5OREF3SURnd01HTXlNakVnTUNBME1EQWdMVEUzT1NBME1EQWdMVFF3TUhNdE1UYzVJQzAwTURBZ0xUUXdNQ0F0TkRBd2N5MDBNREFnTVRjNUlDMDBNREFnTkRBd2N6RTNPU0EwTURBZ05EQXdJRFF3TUhwTk16QXdJRFl3TUhZdE5EQXdiRE13TUNBeU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUZoSWlCMWJtbGpiMlJsUFNJbUkzaGxNR0ZoT3lJZ0NtUTlJazB6TURBZ09EQXdhREl3TUhZdE16QXdhRE13TUhZdE1qQXdhQzB6TURCMkxUTXdNR2d0TWpBd2RqTXdNR2d0TXpBd2RqSXdNR2d6TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poWWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJoWWpzaUlBcGtQU0pOTXpBd0lEZ3dNR2d4TURCMkxUUXdNR2d0TVRBd2RqUXdNSHBOTVRjeUlEWTFObXcyTWlBdE56aHNMVFF3SUMwek1XTXROVGdnTFRRMklDMDVOQ0F0TVRFM0lDMDVOQ0F0TVRrM1l6QWdMVEV6T1NBeE1URWdMVEkxTUNBeU5UQWdMVEkxTUhNeU5UQWdNVEV4SURJMU1DQXlOVEJqTUNBNE1DQXRNemtnTVRVeElDMDVOeUF4T1Rkc0xUTTNJRE14YkRZeUlEYzRiRE00SUMwek1XTTRNaUF0TmpRZ01UTTBJQzB4TmpRZ01UTTBJQzB5TnpWak1DQXRNVGt6SUMweE5UY2dMVE0xTUNBdE16VXdJQzB6TlRCekxUTTFNQ0F4TlRjZ0xUTTFNQ0F6TlRCak1DQXhNVEVnTlRNZ01qRXhJREV6TkNBeU56VjZDaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0poWXlJZ2RXNXBZMjlrWlQwaUppTjRaVEJoWXpzaUlBcGtQU0pOTWpBd0lEZ3dNR2cwTURCMkxUSXdNR2d0TkRBd2RqSXdNSHBOT1NBMU1EQm9Oemd5WXpZZ01DQTVJQzB6SURrZ0xUbDJMVEk0TW1Nd0lDMDJJQzB6SUMwNUlDMDVJQzA1YUMwNU1YWXlNREJvTFRZd01IWXRNakF3YUMwNU1XTXROaUF3SUMwNUlETWdMVGtnT1hZeU9ESmpNQ0EySURNZ09TQTVJRGw2VFRJd01DQXpNREJvTkRBd2RpMHpNREJvTFRRd01IWXpNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1Ga0lpQjFibWxqYjJSbFBTSW1JM2hsTUdGa095SWdDbVE5SWswd0lEY3dNR2d4TURCMkxUY3dNR2d0TVRBd2RqY3dNSHBOTnpBd0lEY3dNR2d4TURCMkxUY3dNR2d0TVRBd2RqY3dNSHBOTWpBd0lEWXdNR2d5TURCMkxURXdNR2d0TWpBd2RqRXdNSHBOTXpBd0lEUXdNR2d5TURCMkxURXdNR2d0TWpBd2RqRXdNSHBOTkRBd0lESXdNR2d5TURCMkxURXdNR2d0TWpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWVdVaUlIVnVhV052WkdVOUlpWWplR1V3WVdVN0lpQUtaRDBpVFRNeU5TQTNNREJqTkRJZ0xURTBNU0E0TnlBdE1qZ3dJREV6TVNBdE5ERTVZekk1SURjMElEVTVJREUwT0NBNE9DQXlNakpqTXpBZ0xUVTNJRFU0SUMweE1UUWdPRGNnTFRFM01tZ3hOamwyTFRFd01HZ3RNak14YkMweE15QXlPR010TXpjZ0xUa3lJQzAzTkNBdE1UZzBJQzB4TVRJZ0xUSTNOV010TXpnZ01USTVJQzAzT1NBeU5UY2dMVEV4T1NBek9EVmpMVFF5SUMweE16TWdMVGd6SUMweU5qY2dMVEV5TlNBdE5EQXdZeTB5T0NBNE9DQXROVFlnTVRjMUlDMDROQ0F5TmpKb0xURXhObll4TURCb01UZzRiRGtnTFRNMGJETWdMVFpqTkRJZ01UTTNJRGd6SURJM015QXhNalVnTkRBNWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmhaaUlnZFc1cFkyOWtaVDBpSmlONFpUQmhaanNpSUFwa1BTSk5NakF3SURZd01HTXdJRFUzSURReklERXdNQ0F4TURBZ01UQXdjekV3TUNBdE5ETWdNVEF3SUMweE1EQmpNQ0F0TWpnZ0xURTRJQzAwT0NBdE1qZ2dMVGN5WXkweklDMDJJQzB6SUMweE5pQXRNeUF0TWpob01qTXhkaTB5TXpGak1USWdNQ0F5TWlBd0lESTRJRE5qTWpRZ01UQWdORFFnTWpnZ056SWdNamhqTlRjZ01DQXhNREFnTFRReklERXdNQ0F0TVRBd2N5MDBNeUF0TVRBd0lDMHhNREFnTFRFd01HTXRNamdnTUNBdE5EZ2dNVGdnTFRjeUlESTRZeTAySURNZ0xURTJJRE1nTFRJNElETjJMVEl6TVdndE1qTXhZekFnTVRJZ01DQXlNaUF6SURJNFl6RXdJREkwSURJNElEUTBJREk0SURjeUNtTXdJRFUzSUMwME15QXhNREFnTFRFd01DQXhNREJ6TFRFd01DQXRORE1nTFRFd01DQXRNVEF3WXpBZ0xUSTRJREU0SUMwME9DQXlPQ0F0TnpKak15QXROaUF6SUMweE5pQXpJQzB5T0dndE1qTXhkall3TUdneU16RmpNQ0F4TWlBd0lESXlJQzB6SURJNFl5MHhNQ0F5TkNBdE1qZ2dORFFnTFRJNElEY3llaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppTUNJZ2RXNXBZMjlrWlQwaUppTjRaVEJpTURzaUlHaHZjbWw2TFdGa2RpMTRQU0kxTURBaUlBcGtQU0pOTWpRM0lEY3dNR000TkNBd0lERTBPQ0F0TWpBZ01Ua3hJQzAxT1hNMU9TQXRPVE1nTlRrZ0xURTBNV013SUMweE1UY2dMVFk1SUMweE9ERWdMVEV4T1NBdE1qSTFjeTA0TVNBdE5qY2dMVGd4SUMweE5UQjJMVEkxYUMweE1EQjJNalZqTUNBeE1UY2dOalVnTVRneElERXhOU0F5TWpWek9EVWdOamNnT0RVZ01UVXdZekFnTWpVZ0xUZ2dORGdnTFRJNElEWTJjeTAxTmlBek5DQXRNVEl5SURNMGN5MDVOeUF0TVRnZ0xURXhOaUF0TXpkekxUSTNJQzAwTXlBdE16RWdMVFk1YkMweE1EQWdNVEpqTlNBek9DQXhPU0E0T0NBMU9TQXhNamh6TVRBeklEWTJJREU0T0NBMk5ucE5NVGszSURCb01UQXdDbll0TVRBd2FDMHhNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmlNU0lnZFc1cFkyOWtaVDBpSmlONFpUQmlNVHNpSUFwa1BTSk5ORFV3SURnd01HTXhNemdnTUNBeU5UQWdMVEV4TWlBeU5UQWdMVEkxTUhZdE5UQmpOVGdnTFRJeElERXdNQ0F0T0RVZ01UQXdJQzB4TlRCak1DQXROamtnTFRRNElDMHhNamNnTFRFeE1pQXRNVFEwWXkweU1pQTFOU0F0TnpVZ09UUWdMVEV6T0NBNU5HTXRNakFnTUNBdE16a2dMVFVnTFRVMklDMHhNbU10TVRjZ05qUWdMVGMxSURFeE1pQXRNVFEwSURFeE1uTXRNVEkzSUMwME9DQXRNVFEwSUMweE1USmpMVEUzSURjZ0xUTTJJREV5SUMwMU5pQXhNbU10TXpjZ01DQXROekVnTFRFeUlDMDVOeUF0TXpSakxUTXpJRE0ySUMwMU15QTRNaUF0TlRNZ01UTTBDbU13SURFeE1DQTVNQ0F5TURBZ01qQXdJREl3TUdNeU15QXhNVFFnTVRJNUlESXdNQ0F5TlRBZ01qQXdlazB6TXpRZ016QXdhRFJvTTJNeklEQWdOaUF4SURrZ01XTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQjJMVEYyTFRJd01HTXdJQzB5T0NBdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1IWXlNREIyTW1Nd0lESXdJREUxSURReUlETTBJRFE0ZWsweE16UWdNakF3YURSb00yTXpJREFnTmlBeElEa2dNV015T0NBd0lEVXdJQzB5TWlBMU1DQXROVEIyTFRGMkxURXdNR013SUMweU9DQXRNaklnTFRVd0lDMDFNQ0F0TlRCekxUVXdJREl5SUMwMU1DQTFNSFl4TURCMk1ncGpNQ0F5TUNBeE5TQTBNaUF6TkNBME9IcE5OVE0wSURJd01HZ3phRFJqTXlBd0lEWWdNU0E1SURGak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2RpMHhkaTB4TURCak1DQXRNamdnTFRJeUlDMDFNQ0F0TlRBZ0xUVXdjeTAxTUNBeU1pQXROVEFnTlRCMk1UQXdkakpqTUNBeU1DQXhOU0EwTWlBek5DQTBPSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWWpJaUlIVnVhV052WkdVOUlpWWplR1V3WWpJN0lpQUtaRDBpVFRZd01DQTRNREJzTWpBd0lDMHhOVEJzTFRJd01DQXRNVFV3ZGpFd01HZ3ROVEJzTFRFMU15QXRNVGt4YkRFM05TQXRNakEyYkRZZ0xUTm9NakoyTVRBd2JESXdNQ0F0TVRVd2JDMHlNREFnTFRFMU1IWXhNREJvTFRJMVl5MHpOU0F3SUMwMU5pQXhNaUF0TnpnZ016aHNMVEUyTmlBeE9UQnNMVEUxTXlBdE1Ua3dZeTB5TWlBdE1qY2dMVFF6SUMwek9DQXROemdnTFRNNGFDMHhNREIyTVRBd2FERXdNR3d4TmpZZ01qQTJiQzB4TmpNZ01Ua3hiQzB6SUROb0xURXdNSFl4TURCb01UQXdZek0wSURBZ05UWWdMVEV5SURjNElDMHpPR3d4TlRNZ0xURTNPR3d4TkRFZ01UYzRDbU15TWlBeU55QTBNeUF6T0NBM09DQXpPR2cxTUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUl6SWlCMWJtbGpiMlJsUFNJbUkzaGxNR0l6T3lJZ0NtUTlJazAwTURBZ09EQXdZekV4TUNBd0lESXdPU0F0TkRjZ01qZ3hJQzB4TVRsc01URTVJREV4T1hZdE16QXdhQzB6TURCc01UQTVJREV3T1dNdE5UUWdOVFVnTFRFeU5pQTVNU0F0TWpBNUlEa3hZeTB4TmpZZ01DQXRNekF3SUMweE16UWdMVE13TUNBdE16QXdjekV6TkNBdE16QXdJRE13TUNBdE16QXdZemd6SURBZ01UVTRJRE0wSURJeE1pQTRPR3czTWlBdE56SmpMVGN5SUMwM01pQXRNVGMwSUMweE1UWWdMVEk0TkNBdE1URTJZeTB5TWpBZ01DQXROREF3SURFNE1DQXROREF3SURRd01ITXhPREFnTkRBd0lEUXdNQ0EwTURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltSTBJaUIxYm1samIyUmxQU0ltSTNobE1HSTBPeUlnQ21ROUlrMDBNREFnT0RBd2FEUXdNSFl0TkRBd2JDMHhOallnTVRZMmJDMDBNREFnTFRRd01Hd3hOallnTFRFMk5tZ3ROREF3ZGpRd01Hd3hOallnTFRFMk5tdzBNREFnTkRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmlOU0lnZFc1cFkyOWtaVDBpSmlONFpUQmlOVHNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5NalV3SURnd01Hd3lOVEFnTFRNd01HZ3RNakF3ZGkweU1EQm9NakF3YkMweU5UQWdMVE13TUd3dE1qVXdJRE13TUdneU1EQjJNakF3YUMweU1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbUkySWlCMWJtbGpiMlJsUFNJbUkzaGxNR0kyT3lJZ0NtUTlJazB6TURBZ05qQXdkaTB5TURCb01qQXdkakl3TUd3ek1EQWdMVEkxTUd3dE16QXdJQzB5TlRCMk1qQXdhQzB5TURCMkxUSXdNR3d0TXpBd0lESTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWWpjaUlIVnVhV052WkdVOUlpWWplR1V3WWpjN0lpQUtaRDBpVFRBZ09EQXdZelEwTVNBd0lEZ3dNQ0F0TXpVNUlEZ3dNQ0F0T0RBd2FDMHlNREJqTUNBek16TWdMVEkyTnlBMk1EQWdMVFl3TUNBMk1EQjJNakF3ZWswd0lEVXdNR015TnpVZ01DQTFNREFnTFRJeU5TQTFNREFnTFRVd01HZ3RNakF3WXpBZ01UWTNJQzB4TXpNZ016QXdJQzB6TURBZ016QXdkakl3TUhwTk1DQXlNREJqTVRFd0lEQWdNakF3SUMwNU1DQXlNREFnTFRJd01HZ3RNakF3ZGpJd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZamdpSUhWdWFXTnZaR1U5SWlZamVHVXdZamc3SWlBS1pEMGlUVEV3TUNBNE1EQmpNemcySURBZ056QXdJQzB6TVRRZ056QXdJQzAzTURCb0xURXdNR013SURNek1pQXRNalk0SURZd01DQXROakF3SURZd01IWXhNREI2VFRFd01DQTJNREJqTWpjMklEQWdOVEF3SUMweU1qUWdOVEF3SUMwMU1EQm9MVEV3TUdNd0lESXlNaUF0TVRjNElEUXdNQ0F0TkRBd0lEUXdNSFl4TURCNlRURXdNQ0EwTURCak1UWTFJREFnTXpBd0lDMHhNelVnTXpBd0lDMHpNREJvTFRFd01HTXdJREV4TVNBdE9Ea2dNakF3SUMweU1EQWdNakF3ZGpFd01IcE5NVEF3SURJd01HTTFOU0F3SURFd01DQXRORFVnTVRBd0lDMHhNREJ6TFRRMUlDMHhNREFnTFRFd01DQXRNVEF3Q25NdE1UQXdJRFExSUMweE1EQWdNVEF3Y3pRMUlERXdNQ0F4TURBZ01UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppT1NJZ2RXNXBZMjlrWlQwaUppTjRaVEJpT1RzaUlBcGtQU0pOTXpBd0lEZ3dNR2cwTURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdkaTB5TURCb0xUUXdNSFl4TlRCak1DQXlPQ0F0TWpJZ05UQWdMVFV3SURVd2N5MDFNQ0F0TWpJZ0xUVXdJQzAxTUhZdE1qVXdhRFF3TUhZdE16QXdZekFnTFRVMUlDMDBOU0F0TVRBd0lDMHhNREFnTFRFd01HZ3ROVEF3WXkwMU5TQXdJQzB4TURBZ05EVWdMVEV3TUNBeE1EQjJNakF3YURFd01IWXRNVFV3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQjJOVFV3WXpBZ05UVWdORFVnTVRBd0lERXdNQ0F4TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltSmhJaUIxYm1samIyUmxQU0ltSTNobE1HSmhPeUlnQ21ROUlrMDNOU0EzTURCb01qSTFkaTB4TURCb0xUSXdNSFl0TlRBd2FEUXdNSFl4TURCb01UQXdkaTB4TWpWak1DQXROREVnTFRNMElDMDNOU0F0TnpVZ0xUYzFhQzAwTlRCakxUUXhJREFnTFRjMUlETTBJQzAzTlNBM05YWTFOVEJqTUNBME1TQXpOQ0EzTlNBM05TQTNOWHBOTmpBd0lEY3dNR3d5TURBZ0xUSXdNR3d0TWpBd0lDMHlNREIyTVRBd2FDMHlNREJqTFRrMElEQWdMVEUzTXlBdE5qVWdMVEU1TkNBdE1UVXpZekl6SURFNU9TQXhPRGtnTXpVeklETTVOQ0F6TlROMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppWWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJpWWpzaUlBcGtQU0pOTlRBd0lEY3dNR3d6TURBZ0xUSTROR3d0TXpBd0lDMHpNVFoyTWpBd2FDMHhNREJqTFRJd01DQXdJQzB6TkRnZ0xURXdNaUF0TkRBd0lDMHpNREJqTUNBeU9UVWdNVEF3SURVd01DQTFNREFnTlRBd2RqSXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWW1NaUlIVnVhV052WkdVOUlpWWplR1V3WW1NN0lpQUtaRDBpVFRNNE1TQTNPVEZzTVRrZ09Xd3hPU0F0T1dNeE1qY2dMVFV6SURJMU15QXRNVEE0SURNNE1TQXRNVFl3ZGkwek1XTXdJQzB4TmpZZ0xUWTNJQzB6TVRNZ0xURTBOeUF0TkRFNVl5MDBNQ0F0TlRNZ0xUZ3pJQzA1TnlBdE1USTFJQzB4TWpoekxUZ3lJQzAxTXlBdE1USTRJQzAxTTNNdE9EWWdNaklnTFRFeU9DQTFNM010T0RVZ056VWdMVEV5TlNBeE1qaGpMVGd3SURFd055QXRNVFEzSURJMU15QXRNVFEzSURReE9YWXpNV014TWpnZ05USWdNalUwSURFd055QXpPREVnTVRZd2VrMDBNREFnTVRBd2RqVTVNV3d0TWprMElDMHhNakpqT0NBdE1USTJJRFU0SUMweU5ETWdNVEl5SUMwek1qZ0tZek0xSUMwME5pQTNNeUF0T0RZZ01UQTJJQzB4TVRCek5qSWdMVE14SURZMklDMHpNWG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWW1RaUlIVnVhV052WkdVOUlpWWplR1V3WW1RN0lpQUtaRDBpVFRZd01DQTRNREJvTVRBd2RpMDRNREJvTFRFd01IWTRNREI2VFRRd01DQTNNREJvTVRBd2RpMDNNREJvTFRFd01IWTNNREI2VFRJd01DQTFNREJvTVRBd2RpMDFNREJvTFRFd01IWTFNREI2VFRBZ016QXdhREV3TUhZdE16QXdhQzB4TURCMk16QXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0ppWlNJZ2RXNXBZMjlrWlQwaUppTjRaVEJpWlRzaUlBcGtQU0pOTXpBd0lEZ3dNR2d4TURCMkxUSXdNR2d5TURCc01UQXdJQzB4TURCc0xURXdNQ0F0TVRBd2FDMHlNREIyTFRRd01HZ3RNVEF3ZGpVd01HZ3RNakF3YkMweE1EQWdNVEF3YkRFd01DQXhNREJvTWpBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWW1ZaUlIVnVhV052WkdVOUlpWWplR1V3WW1ZN0lpQUtaRDBpVFRJd01DQTRNREJvTVRBd2RpMDJNREJvTWpBd2JDMHlOVEFnTFRJd01Hd3RNalV3SURJd01HZ3lNREIyTmpBd2VrMDBNREFnT0RBd2FESXdNSFl0TVRBd2FDMHlNREIyTVRBd2VrMDBNREFnTmpBd2FETXdNSFl0TVRBd2FDMHpNREIyTVRBd2VrMDBNREFnTkRBd2FEUXdNSFl0TVRBd2FDMDBNREIyTVRBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmpNQ0lnZFc1cFkyOWtaVDBpSmlONFpUQmpNRHNpSUFwa1BTSk5NakF3SURnd01HZ3hNREIyTFRZd01HZ3lNREJzTFRJMU1DQXRNakF3YkMweU5UQWdNakF3YURJd01IWTJNREI2VFRRd01DQTRNREJvTkRBd2RpMHhNREJvTFRRd01IWXhNREI2VFRRd01DQTJNREJvTXpBd2RpMHhNREJvTFRNd01IWXhNREI2VFRRd01DQTBNREJvTWpBd2RpMHhNREJvTFRJd01IWXhNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1NeElpQjFibWxqYjJSbFBTSW1JM2hsTUdNeE95SWdDbVE5SWswM05TQTNNREJvTmpVd1l6UXhJREFnTnpVZ0xUTTBJRGMxSUMwM05YWXROVFV3WXpBZ0xUUXhJQzB6TkNBdE56VWdMVGMxSUMwM05XZ3ROalV3WXkwME1TQXdJQzAzTlNBek5DQXROelVnTnpWMk5UVXdZekFnTkRFZ016UWdOelVnTnpVZ056VjZUVEV3TUNBMk1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVE13TUNBMk1EQjJMVEV3TUdnME1EQjJNVEF3YUMwME1EQjZUVEV3TUNBME1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVE13TUNBME1EQjJMVEV3TUdnME1EQjJNVEF3YUMwME1EQjZUVEV3TUNBeU1EQjJMVEV3TUdneE1EQjJNVEF3YUMweE1EQjZUVE13TUNBeU1EQUtkaTB4TURCb05EQXdkakV3TUdndE5EQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0pqTWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJqTWpzaUlBcGtQU0pOTkRBd0lEZ3dNR3d4TURBZ0xUTXdNR2d6TURCc0xUSTFNQ0F0TWpBd2JERXdNQ0F0TXpBd2JDMHlOVEFnTWpBd2JDMHlOVEFnTFRJd01Hd3hNREFnTXpBd2JDMHlOVEFnTWpBd2FETXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWXpNaUlIVnVhV052WkdVOUlpWWplR1V3WXpNN0lpQUtaRDBpVFRRd01DQTRNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazB4TlRBZ056QXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1IcE5OalV3SURjd01HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEJ6TWpJZ05UQWdOVEFnTlRCNlRUUXdNQ0EyTURCak1URXdJREFnTWpBd0lDMDVNQ0F5TURBZ0xUSXdNQXB6TFRrd0lDMHlNREFnTFRJd01DQXRNakF3Y3kweU1EQWdPVEFnTFRJd01DQXlNREJ6T1RBZ01qQXdJREl3TUNBeU1EQjZUVFV3SURRMU1HTXlPQ0F3SURVd0lDMHlNaUExTUNBdE5UQnpMVEl5SUMwMU1DQXROVEFnTFRVd2N5MDFNQ0F5TWlBdE5UQWdOVEJ6TWpJZ05UQWdOVEFnTlRCNlRUYzFNQ0EwTlRCak1qZ2dNQ0ExTUNBdE1qSWdOVEFnTFRVd2N5MHlNaUF0TlRBZ0xUVXdJQzAxTUhNdE5UQWdNaklnTFRVd0lEVXdjekl5SURVd0lEVXdJRFV3ZWsweE5UQWdNakF3WXpJNElEQWdOVEFnTFRJeUlEVXdJQzAxTUhNdE1qSWdMVFV3SUMwMU1DQXROVEJ6TFRVd0lESXlJQzAxTUNBMU1BcHpNaklnTlRBZ05UQWdOVEI2VFRZMU1DQXlNREJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweU1pQXROVEFnTFRVd0lDMDFNSE10TlRBZ01qSWdMVFV3SURVd2N6SXlJRFV3SURVd0lEVXdlazAwTURBZ01UQXdZekk0SURBZ05UQWdMVEl5SURVd0lDMDFNSE10TWpJZ0xUVXdJQzAxTUNBdE5UQnpMVFV3SURJeUlDMDFNQ0ExTUhNeU1pQTFNQ0ExTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZelFpSUhWdWFXTnZaR1U5SWlZamVHVXdZelE3SWlBS1pEMGlUVE0wSURnd01HZzJNekpqTVRnZ01DQXpOQ0F0TVRZZ016UWdMVE0wZGkwM016SmpNQ0F0TVRnZ0xURTJJQzB6TkNBdE16UWdMVE0wYUMwMk16SmpMVEU0SURBZ0xUTTBJREUySUMwek5DQXpOSFkzTXpKak1DQXhPQ0F4TmlBek5DQXpOQ0F6TkhwTk1UQXdJRGN3TUhZdE5UQXdhRFV3TUhZMU1EQm9MVFV3TUhwTk16VXdJREUxTUdNdE16Z2dNQ0F0TmpNZ0xUUXlJQzAwTkNBdE56VnpOamtnTFRNeklEZzRJREJ6TFRZZ056VWdMVFEwSURjMWVpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmpOU0lnZFc1cFkyOWtaVDBpSmlONFpUQmpOVHNpSUFwa1BTSk5NQ0E0TURCb016QXdiRFV3TUNBdE5UQXdiQzB6TURBZ0xUTXdNR3d0TlRBd0lEVXdNSFl6TURCNlRUSXdNQ0EzTURCakxUVTFJREFnTFRFd01DQXRORFVnTFRFd01DQXRNVEF3Y3pRMUlDMHhNREFnTVRBd0lDMHhNREJ6TVRBd0lEUTFJREV3TUNBeE1EQnpMVFExSURFd01DQXRNVEF3SURFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZellpSUhWdWFXTnZaR1U5SWlZamVHVXdZelk3SWlBS1pEMGlUVEFnTmpBd2FESXdNR3d6TURBZ0xUTXdNR3d0TWpBd0lDMHlNREJzTFRNd01DQXpNREIyTWpBd2VrMHpOREFnTmpBd2FERTJNR3d6TURBZ0xUTXdNR3d0TWpBd0lDMHlNREJzTFRjNElEYzRiREV4T1NBeE1qSjZUVEUxTUNBMU1EQmpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3Y3pJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEJ6TFRJeUlEVXdJQzAxTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZemNpSUhWdWFXTnZaR1U5SWlZamVHVXdZemM3SWlBS1pEMGlUVFF3TUNBNE1EQmpNakl3SURBZ05EQXdJQzB4T0RBZ05EQXdJQzAwTURCekxURTRNQ0F0TkRBd0lDMDBNREFnTFRRd01ITXROREF3SURFNE1DQXROREF3SURRd01ITXhPREFnTkRBd0lEUXdNQ0EwTURCNlRUUXdNQ0EzTURCakxURTJOaUF3SUMwek1EQWdMVEV6TkNBdE16QXdJQzB6TURCek1UTTBJQzB6TURBZ016QXdJQzB6TURCek16QXdJREV6TkNBek1EQWdNekF3Y3kweE16UWdNekF3SUMwek1EQWdNekF3ZWswME1EQWdOakF3WXpFeE1DQXdJREl3TUNBdE9UQWdNakF3SUMweU1EQnpMVGt3SUMweU1EQWdMVEl3TUNBdE1qQXdjeTB5TURBZ09UQWdMVEl3TUNBeU1EQUtjemt3SURJd01DQXlNREFnTWpBd2VrMDBNREFnTlRBd1l5MDFOaUF3SUMweE1EQWdMVFEwSUMweE1EQWdMVEV3TUhNME5DQXRNVEF3SURFd01DQXRNVEF3Y3pFd01DQTBOQ0F4TURBZ01UQXdjeTAwTkNBeE1EQWdMVEV3TUNBeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbU00SWlCMWJtbGpiMlJsUFNJbUkzaGxNR000T3lJZ0NtUTlJazB3SURjd01HZzFOVGxzTFRFd01DQXRNVEF3YUMwek5UbDJMVFV3TUdnMU1EQjJNVFU1YkRFd01DQXhNREIyTFRNMU9XZ3ROekF3ZGpjd01IcE5OekF3SURjd01Hd3hNREFnTFRFd01Hd3ROREF3SUMwME1EQnNMVEl3TUNBeU1EQnNNVEF3SURFd01Hd3hNREFnTFRFd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZemtpSUhWdWFXTnZaR1U5SWlZamVHVXdZems3SWlBS1pEMGlUVGtnT0RBd2FEYzRNbU0ySURBZ09TQXRNeUE1SUMwNWRpMDNPREpqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0TnpneVl5MDJJREFnTFRrZ015QXRPU0E1ZGpjNE1tTXdJRFlnTXlBNUlEa2dPWHBOTVRVd0lEY3lNbXd0TnpJZ0xUY3liREV3TUNBdE1UQXdiQzB4TURBZ0xURXdNR3czTWlBdE56SnNNVGN5SURFM01ucE5OREF3SURVd01IWXRNVEF3YURNd01IWXhNREJvTFRNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZMkVpSUhWdWFXTnZaR1U5SWlZamVHVXdZMkU3SWlBS1pEMGlUVEFnT0RBd2FEZ3dNSFl0TWpBd2FDMDFNR013SURVMUlDMDBOU0F4TURBZ0xURXdNQ0F4TURCb0xURTFNSFl0TlRVd1l6QWdMVEk0SURJeUlDMDFNQ0ExTUNBdE5UQm9OVEIyTFRFd01HZ3ROREF3ZGpFd01HZzFNR015T0NBd0lEVXdJREl5SURVd0lEVXdkalUxTUdndE1UVXdZeTAxTlNBd0lDMHhNREFnTFRRMUlDMHhNREFnTFRFd01HZ3ROVEIyTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmpZaUlnZFc1cFkyOWtaVDBpSmlONFpUQmpZanNpSUFwa1BTSk5NQ0EzTURCb01UQXdkaTAwTURCb0xURXdNSFkwTURCNlRUSXdNQ0EzTURCb016VXdZekl4SURBZ016a2dMVEV6SURRM0lDMHpNV013SURBZ01UQXpJQzB5T1RFZ01UQXpJQzB6TVRsekxUSXlJQzAxTUNBdE5UQWdMVFV3YUMweE5UQmpMVEk0SURBZ0xUVXdJQzB5TlNBdE5UQWdMVFV3Y3pNNUlDMHhOVGdnTkRjZ0xURTROSE10TlNBdE5UVWdMVE14SUMwMk0zTXROVElnTlNBdE5qWWdNekZ6TFRFd09TQXlNVGtnTFRFeU9DQXlNemh6TFRRMElESTRJQzAzTWlBeU9IWTBNREI2SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1OaklpQjFibWxqYjJSbFBTSW1JM2hsTUdOak95SWdDbVE5SWswME1EQWdOalkyWXpFd0lERTVJREk0SURNeUlEUTNJRE0wYkRFNUlDMHpZekkySUMwNElETTVJQzB6TnlBek1TQXROak56TFRRM0lDMHhOVGtnTFRRM0lDMHhPRFJ6TWpJZ0xUVXdJRFV3SUMwMU1HZ3hOVEJqTWpnZ01DQTFNQ0F0TWpJZ05UQWdMVFV3Y3kweE1ETWdMVE14T1NBdE1UQXpJQzB6TVRsakxUZ2dMVEU0SUMweU5pQXRNekVnTFRRM0lDMHpNV2d0TXpVd2RqUXdNR015T0NBd0lEVXpJRGtnTnpJZ01qaHpNVEUwSURJeE1pQXhNamdnTWpNNGVrMHdJRFF3TUdneE1EQjJMVFF3TUdndE1UQXdkalF3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVkyUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1kyUTdJaUFLWkQwaVRUSXdNQ0EzTURCb016QXdkaTB4TURCb0xURXdNSFl0Tm1NeU5TQXROQ0ExTUNBdE9DQTNNaUF0TVRac0xUTTBJQzA1TkdNdE1qZ2dNVEVnTFRVNElERTJJQzA0T0NBeE5tTXRNVE01SURBZ0xUSTFNQ0F0TVRFeElDMHlOVEFnTFRJMU1ITXhNVEVnTFRJMU1DQXlOVEFnTFRJMU1ITXlOVEFnTVRFeElESTFNQ0F5TlRCak1DQXpNU0F0TlNBMk1DQXRNVFlnT0Roc09URWdNemRqTVRRZ0xUTTRJREkxSUMwNE1TQXlOU0F0TVRJMVl6QWdMVEU1TXlBdE1UVTNJQzB6TlRBZ0xUTTFNQ0F0TXpVd2N5MHpOVEFnTVRVM0lDMHpOVEFnTXpVd1l6QWdNVGMySURFek1DQXpNak1nTXpBd0lETTBOM1l6Q21ndE1UQXdkakV3TUhwTk56QXdJRFU0TkdNd0lEQWdMVEk1TmlBdE16UTRJQzB6TVRZZ0xUTTJPSE10TkRnZ0xUSXdJQzAyT0NBd2N5MHlNQ0EwT0NBd0lEWTRjek00TkNBek1EQWdNemcwSURNd01Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlZMlVpSUhWdWFXTnZaR1U5SWlZamVHVXdZMlU3SWlBS1pEMGlUVFl3TUNBM01EQnNNakF3SUMweE5UQnNMVEl3TUNBdE1UVXdkakV3TUdndE5qQXdkakV3TUdnMk1EQjJNVEF3ZWsweU1EQWdNekF3ZGkweE1EQm9OakF3ZGkweE1EQm9MVFl3TUhZdE1UQXdiQzB5TURBZ01UVXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0pqWmlJZ2RXNXBZMjlrWlQwaUppTjRaVEJqWmpzaUlBcGtQU0pOTXpBd0lEZ3dNR2d4TURCak5UVWdNQ0F4TURBZ0xUUTFJREV3TUNBdE1UQXdhREV3TUdNMU5TQXdJREV3TUNBdE5EVWdNVEF3SUMweE1EQm9MVGN3TUdNd0lEVTFJRFExSURFd01DQXhNREFnTVRBd2FERXdNR013SURVMUlEUTFJREV3TUNBeE1EQWdNVEF3ZWsweE1EQWdOVEF3YURFd01IWXRNelV3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQjJNelV3YURFd01IWXRNelV3WXpBZ0xUSTRJREl5SUMwMU1DQTFNQ0F0TlRCek5UQWdNaklnTlRBZ05UQjJNelV3YURFd01IWXRORGd4WXpBZ0xURXhJQzA0SUMweE9TQXRNVGtnTFRFNWFDMDBOaklLWXkweE1TQXdJQzB4T1NBNElDMHhPU0F4T1hZME9ERjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVF3SWlCMWJtbGpiMlJsUFNJbUkzaGxNR1F3T3lJZ0NtUTlJazB4TURBZ09EQXdhREl3TUhZdE5EQXdZekFnTFRVMUlEUTFJQzB4TURBZ01UQXdJQzB4TURCek1UQXdJRFExSURFd01DQXhNREIyTkRBd2FERXdNSFl0TkRBd1l6QWdMVEV4TUNBdE9UQWdMVEl3TUNBdE1qQXdJQzB5TURCb0xUVXdZeTB4TXpnZ01DQXRNalV3SURrd0lDMHlOVEFnTWpBd2RqUXdNSHBOTUNBeE1EQm9OekF3ZGkweE1EQm9MVGN3TUhZeE1EQjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVF4SWlCMWJtbGpiMlJsUFNJbUkzaGxNR1F4T3lJZ0NtUTlJazA1SURjd01HZ3hPREpqTmlBd0lEa2dMVE1nT1NBdE9YWXRORGd5WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRFNE1tTXROaUF3SUMwNUlETWdMVGtnT1hZME9ESmpNQ0EySURNZ09TQTVJRGw2VFRZd09TQTNNREJvTVRneVl6WWdNQ0E1SUMweklEa2dMVGwyTFRRNE1tTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMHhPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJORGd5WXpBZ05pQXpJRGtnT1NBNWVrMHpNRGtnTlRBd2FERTRNbU0ySURBZ09TQXRNeUE1SUMwNWRpMHlPREpqTUNBdE5pQXRNeUF0T1NBdE9TQXRPV2d0TVRneVl5MDJJREFnTFRrZ015QXRPU0E1ZGpJNE1ncGpNQ0EySURNZ09TQTVJRGw2VFRBZ01UQXdhRGd3TUhZdE1UQXdhQzA0TURCMk1UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0prTWlJZ2RXNXBZMjlrWlQwaUppTjRaVEJrTWpzaUlBcGtQU0pOTVRBZ056QXdhREU0TVdNMklEQWdPU0F0TXlBNUlDMDVkaTB4T1RGb0xUSXdNSFl4T1RGak1DQTJJRFFnT1NBeE1DQTVlazAyTVRBZ056QXdhREU0TVdNMklEQWdPU0F0TXlBNUlDMDVkaTB4T1RGb0xUSXdNSFl4T1RGak1DQTJJRFVnT1NBeE1DQTVlazB6TVRBZ05qQXdhREU0TVdNMklEQWdPU0F0TXlBNUlDMDVkaTA1TVdndE1qQXdkamt4WXpBZ05pQTBJRGtnTVRBZ09YcE5NQ0EwTURCb09EQXdkaTB4TURCb0xUZ3dNSFl4TURCNlRUQWdNakF3YURJd01IWXRNVGt4WXpBZ0xUWWdMVE1nTFRrZ0xUa2dMVGxvTFRFNE1tTXROaUF3SUMwNUlETWdMVGtnT1hZeE9URjZUVE13TUNBeU1EQUthREl3TUhZdE9URmpNQ0F0TmlBdE15QXRPU0F0T1NBdE9XZ3RNVGd4WXkwMklEQWdMVEV3SURNZ0xURXdJRGwyT1RGNlRUWXdNQ0F5TURCb01qQXdkaTB4T1RGak1DQXROaUF0TXlBdE9TQXRPU0F0T1dndE1UZ3hZeTAySURBZ0xURXdJRE1nTFRFd0lEbDJNVGt4ZWlJZ0x6NEtJQ0FnSUR4bmJIbHdhQ0JuYkhsd2FDMXVZVzFsUFNKa015SWdkVzVwWTI5a1pUMGlKaU40WlRCa016c2lJQXBrUFNKTk1DQTNNREJvT0RBd2RpMHhNREJvTFRnd01IWXhNREI2VFRrZ05UQXdhREU0TW1NMklEQWdPU0F0TXlBNUlDMDVkaTAwT0RKak1DQXROaUF0TXlBdE9TQXRPU0F0T1dndE1UZ3lZeTAySURBZ0xUa2dNeUF0T1NBNWRqUTRNbU13SURZZ015QTVJRGtnT1hwTk16QTVJRFV3TUdneE9ESmpOaUF3SURrZ0xUTWdPU0F0T1hZdE1qZ3lZekFnTFRZZ0xUTWdMVGtnTFRrZ0xUbG9MVEU0TW1NdE5pQXdJQzA1SURNZ0xUa2dPWFl5T0RKak1DQTJJRE1nT1NBNUlEbDZUVFl3T1NBMU1EQm9NVGd5WXpZZ01DQTVJQzB6SURrZ0xUbDJMVFE0TW1Nd0lDMDJJQzB6SUMwNUlDMDVJQzA1YUMweE9ESUtZeTAySURBZ0xUa2dNeUF0T1NBNWRqUTRNbU13SURZZ015QTVJRGtnT1hvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVpEUWlJSFZ1YVdOdlpHVTlJaVlqZUdVd1pEUTdJaUFLWkQwaVRUVXdJRFl3TUdnMU1EQmpNamdnTUNBMU1DQXRNaklnTlRBZ0xUVXdkaTB4TlRCc01UQXdJREV3TUdneE1EQjJMVE13TUdndE1UQXdiQzB4TURBZ01UQXdkaTB4TlRCak1DQXRNamdnTFRJeUlDMDFNQ0F0TlRBZ0xUVXdhQzAxTURCakxUSTRJREFnTFRVd0lESXlJQzAxTUNBMU1IWTBNREJqTUNBeU9DQXlNaUExTUNBMU1DQTFNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWkRVaUlIVnVhV052WkdVOUlpWWplR1V3WkRVN0lpQUtaRDBpVFRNek5DQTRNREJvTmpaMkxUZ3dNR2d0Tmpac0xURXpOQ0F5TURCb0xUSXdNSFkwTURCb01qQXdlazAxTURBZ05qQXdkakV3TUdNeU5pQXdJRFV5SUMwMElEYzFJQzB4TUdNeE16QWdMVE16SURJeU5TQXRNVFV3SURJeU5TQXRNamt3Y3kwNU5TQXRNalU0SUMweU1qVWdMVEk1TVdndE0yTXRNak1nTFRZZ0xUUTNJQzA1SUMwM01pQXRPWFl4TURCak1UY2dNQ0F6TkNBeUlEVXdJRFpqT0RZZ01qSWdNVFV3SURFd01DQXhOVEFnTVRrMGN5MDJOQ0F4TnpJZ0xURTFNQ0F4T1RSakxURTJJRFFnTFRNeklEWWdMVFV3SURaNlRUVXdNQ0ExTURCc01qVWdMVE1LWXpRMElDMHhNU0EzTlNBdE5URWdOelVnTFRrM2N5MHpNaUF0T0RZZ0xUYzFJQzA1TjJ3dE1qVWdMVE4yTWpBd2VpSWdMejRLSUNBZ0lEeG5iSGx3YUNCbmJIbHdhQzF1WVcxbFBTSmtOaUlnZFc1cFkyOWtaVDBpSmlONFpUQmtOanNpSUdodmNtbDZMV0ZrZGkxNFBTSTJNREFpSUFwa1BTSk5Nek0wSURnd01HZzJObll0T0RBd2FDMDJObXd0TVRNMElESXdNR2d0TWpBd2RqUXdNR2d5TURCNlRUVXdNQ0ExTURCc01qVWdMVE5qTkRRZ0xURXhJRGMxSUMwMU1TQTNOU0F0T1RkekxUTXlJQzA0TmlBdE56VWdMVGszYkMweU5TQXRNM1l5TURCNklpQXZQZ29nSUNBZ1BHZHNlWEJvSUdkc2VYQm9MVzVoYldVOUltUTNJaUIxYm1samIyUmxQU0ltSTNobE1HUTNPeUlnYUc5eWFYb3RZV1IyTFhnOUlqUXdNQ0lnQ21ROUlrMHpNelFnT0RBd2FEWTJkaTA0TURCb0xUWTJiQzB4TXpRZ01qQXdhQzB5TURCMk5EQXdhREl3TUhvaUlDOCtDaUFnSUNBOFoyeDVjR2dnWjJ4NWNHZ3RibUZ0WlQwaVpEZ2lJSFZ1YVdOdlpHVTlJaVlqZUdVd1pEZzdJaUFLWkQwaVRUTXdPU0E0TURCb09ESmpOaUF3SURFd0lDMDBJREV5SUMwNWJESTVOQ0F0TmpneWJETWdMVEU1ZGkwNE1XTXdJQzAySUMweklDMDVJQzA1SUMwNWFDMDJPREpqTFRZZ01DQXRPU0F6SUMwNUlEbDJPREZzTXlBeE9Xd3lPVFFnTmpneVl6SWdOU0EySURrZ01USWdPWHBOTXpBd0lEVXdNSFl0TWpBd2FERXdNSFl5TURCb0xURXdNSHBOTXpBd0lESXdNSFl0TVRBd2FERXdNSFl4TURCb0xURXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWkRraUlIVnVhV052WkdVOUlpWWplR1V3WkRrN0lpQUtaRDBpVFRNM05TQTRNREJqTVRNNElEQWdNalk1SUMwek9TQXpOemdnTFRFd09Xd3ROVE1nTFRneVl5MDVNeUEyTUNBdE1qQTFJRGt4SUMwek1qVWdPVEZqTFRFeE9TQXdJQzB5TWprZ0xUTXlJQzB6TWpJZ0xUa3hiQzAxTXlBNE1tTXhNRGtnTnpBZ01qTTNJREV3T1NBek56VWdNVEE1ZWswek56VWdOVEF3WXpjNElEQWdNVFUwSUMweU15QXlNVFlnTFRZeWJDMDFNeUF0T0RWakxUUTJJRE13SUMweE1EUWdORGNnTFRFMk15QTBOMk10TmpBZ01DQXRNVEV5SUMweE55QXRNVFU1SUMwME4yd3ROVFFnT0RWak5qSWdOREFnTVRNMElEWXlJREl4TXlBMk1ucE5NemMxSURJd01BcGpOVFVnTUNBeE1EQWdMVFExSURFd01DQXRNVEF3Y3kwME5TQXRNVEF3SUMweE1EQWdMVEV3TUhNdE1UQXdJRFExSUMweE1EQWdNVEF3Y3pRMUlERXdNQ0F4TURBZ01UQXdlaUlnTHo0S0lDQWdJRHhuYkhsd2FDQm5iSGx3YUMxdVlXMWxQU0prWVNJZ2RXNXBZMjlrWlQwaUppTjRaVEJrWVRzaUlHaHZjbWw2TFdGa2RpMTRQU0k1TURBaUlBcGtQU0pOTlRVeElEZ3dNR014TmlBd0lETXlJREFnTkRjZ0xUTnNMVGszSUMwNU4zWXRNakF3YURJd01HdzVOeUE1TjJNeklDMHhOU0F6SUMwek1TQXpJQzAwTjJNd0lDMHhNemdnTFRFeE1pQXRNalV3SUMweU5UQWdMVEkxTUdNdE16SWdNQ0F0TmpJZ09DQXRPVEFnTVRsc0xUSTRPQ0F0TWpreFl5MHlNQ0F0TWpBZ0xUUTJJQzB5T0NBdE56SWdMVEk0Y3kwMU1pQTRJQzAzTWlBeU9HTXRNemtnTXprZ0xUTTVJREV3TlNBd0lERTBOR3d5T1RFZ01qZzNZeTB4TVNBeU9DQXRNVGtnTlRrZ0xURTVJRGt4WXpBZ01UTTRJREV4TWlBeU5UQWdNalV3SURJMU1IcE5NVEF4SURFMU1BcGpMVEk0SURBZ0xUVXdJQzB5TWlBdE5UQWdMVFV3Y3pJeUlDMDFNQ0ExTUNBdE5UQnpOVEFnTWpJZ05UQWdOVEJ6TFRJeUlEVXdJQzAxTUNBMU1Ib2lJQzgrQ2lBZ0lDQThaMng1Y0dnZ1oyeDVjR2d0Ym1GdFpUMGlaR0lpSUhWdWFXTnZaR1U5SWlZamVHVXdaR0k3SWlBS1pEMGlUVEUwTVNBM01EQmpPRFFnTFRnMElERTJPU0F0TVRZM0lESTFNeUF0TWpVd1l6Z3lJRGd6SURFMk55QXhOalVnTWpRM0lESTFNR3d4TkRNZ0xURTBNV3d0TWpVeklDMHlOVE5qT0RRZ0xUZ3lJREUyTnlBdE1UWTJJREkxTXlBdE1qUTNiQzB4TkRNZ0xURTBNMk10T0RFZ09EWWdMVEUyTlNBeE5qa2dMVEkwTnlBeU5UTnNMVEkxTXlBdE1qVXpiQzB4TkRFZ01UUXpZemcxSURnd0lERTJOeUF4TmpRZ01qVXdJREkwTjJNdE9ETWdPRFFnTFRFMk5pQXhOamtnTFRJMU1DQXlOVE42SWlBdlBnb2dJQ0FnUEdkc2VYQm9JR2RzZVhCb0xXNWhiV1U5SW1SaklpQjFibWxqYjJSbFBTSW1JM2hsTUdSak95SWdDbVE5SWswd0lEZ3dNR2d4TURCc01qTXhJQzB6TURCb016aHNNak14SURNd01HZ3hNREJzTFRJeU5TQXRNekF3YURJeU5YWXRNVEF3YUMwek1EQjJMVEV3TUdnek1EQjJMVEV3TUdndE16QXdkaTB5TURCb0xURXdNSFl5TURCb0xUTXdNSFl4TURCb016QXdkakV3TUdndE16QXdkakV3TUdneU1qVjZJaUF2UGdvZ0lDQWdQR2RzZVhCb0lHZHNlWEJvTFc1aGJXVTlJbVJrSWlCMWJtbGpiMlJsUFNJbUkzaGxNR1JrT3lJZ2FHOXlhWG90WVdSMkxYZzlJamt3TUNJZ0NtUTlJazB6TlRBZ09EQXdZekU1TXlBd0lETTFNQ0F0TVRVM0lETTFNQ0F0TXpVd1l6QWdMVFl4SUMweE55QXRNVEU1SUMwME5DQXRNVFk1WXpRZ0xUSWdNVEFnTFRZZ01UTWdMVGxzTVRBeklDMHhNREJqTVRZZ0xURTJJRE13SUMwME9TQXpNQ0F0TnpKak1DQXROVFlnTFRRMklDMHhNRElnTFRFd01pQXRNVEF5WXkweU15QXdJQzAxTmlBeE5DQXROeklnTXpCc0xURXdNQ0F4TUROakxUTWdNeUF0TnlBNUlDMDVJREV6WXkwMU1DQXRNamdnTFRFd09DQXRORFFnTFRFMk9TQXRORFJqTFRFNU15QXdJQzB6TlRBZ01UVTNJQzB6TlRBZ016VXdjekUxTnlBek5UQWdNelV3SURNMU1IcE5NelV3SURjd01BcGpMVEV6T1NBd0lDMHlOVEFnTFRFeE1TQXRNalV3SUMweU5UQnpNVEV4SUMweU5UQWdNalV3SUMweU5UQmpOaklnTUNBeE1Ua2dNak1nTVRZeklEWXdZemNnTVRFZ01Ua2dNalVnTXpFZ016RnNNeUF6WXpNMElEUXpJRFV6SURrM0lEVXpJREUxTm1Nd0lERXpPU0F0TVRFeElESTFNQ0F0TWpVd0lESTFNSHBOTXpBd0lEWXdNR2d4TURCMkxURXdNR2d4TURCMkxURXdNR2d0TVRBd2RpMHhNREJvTFRFd01IWXhNREJvTFRFd01IWXhNREJvTVRBd2RqRXdNSG9pSUM4K0NpQWdJQ0E4WjJ4NWNHZ2daMng1Y0dndGJtRnRaVDBpWkdVaUlIVnVhV052WkdVOUlpWWplR1V3WkdVN0lpQm9iM0pwZWkxaFpIWXRlRDBpT1RBd0lpQUtaRDBpVFRNMU1DQTRNREJqTVRreklEQWdNelV3SUMweE5UY2dNelV3SUMwek5UQmpNQ0F0TmpFZ0xURTNJQzB4TVRrZ0xUUTBJQzB4Tmpsak5DQXRNaUF4TUNBdE5pQXhNeUF0T1d3eE1ETWdMVEV3TUdNeE5pQXRNVFlnTXpBZ0xUUTVJRE13SUMwM01tTXdJQzAxTmlBdE5EWWdMVEV3TWlBdE1UQXlJQzB4TURKakxUSXpJREFnTFRVMklERTBJQzAzTWlBek1Hd3RNVEF3SURFd00yTXRNeUF6SUMwM0lEa2dMVGtnTVROakxUVXdJQzB5T0NBdE1UQTRJQzAwTkNBdE1UWTVJQzAwTkdNdE1Ua3pJREFnTFRNMU1DQXhOVGNnTFRNMU1DQXpOVEJ6TVRVM0lETTFNQ0F6TlRBZ016VXdlazB6TlRBZ056QXdDbU10TVRNNUlEQWdMVEkxTUNBdE1URXhJQzB5TlRBZ0xUSTFNSE14TVRFZ0xUSTFNQ0F5TlRBZ0xUSTFNR00yTWlBd0lERXhPU0F5TXlBeE5qTWdOakJqTnlBeE1TQXhPU0F5TlNBek1TQXpNV3d6SUROak16UWdORE1nTlRNZ09UY2dOVE1nTVRVMll6QWdNVE01SUMweE1URWdNalV3SUMweU5UQWdNalV3ZWsweU1EQWdOVEF3YURNd01IWXRNVEF3YUMwek1EQjJNVEF3ZWlJZ0x6NEtJQ0E4TDJadmJuUStDand2WkdWbWN6NDhMM04yWno0S1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMuc3ZnXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy5zdmdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtiYXNlNjQsQUFFQUFBQVBBSUFBQXdCd1JrWlVUV3Z3QWFRQUFBRDhBQUFBSEU5VEx6STBCbEZpQUFBQkdBQUFBR0JqYldGd0FBL2tpUUFBQVhnQUFBRkNZM1owSUFBQUFBQUFBR0dJQUFBQUNtWndaMjIrYitZNUFBQmhsQUFBQzJ4bllYTndBQUFBRUFBQVlZQUFBQUFJWjJ4NVpramw3cTRBQUFLOEFBQlNHR2hsWVdRQjg3dEZBQUJVMUFBQUFEWm9hR1ZoQm93RUFRQUFWUXdBQUFBa2FHMTBlSnFlQUJvQUFGVXdBQUFEaG14dlkyR2p1bzlFQUFCWXVBQUFBY1p0WVhod0Fad0wxZ0FBV29BQUFBQWdibUZ0Wlk3MkVNVUFBRnFnQUFBQ2ZIQnZjM1R0RURQK0FBQmRIQUFBQkdOd2NtVnczV3NEaFFBQWJRQUFBQUI3QUFBQUFRQUFBQURNUGFMUEFBQUFBTS9aTDJvQUFBQUF6OWt2YWdBRUF2NEJrQUFGQUFBQ0NBSXdBQUFBY0FJSUFqQUFBQUdBQUNjQXp3QUFBZ0FGQXdBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQlFaa1ZrQU1EZ0FPRGVBeUFBQUFCSUF5QUFaUUFBQUFFQUFBQUFBQUFBQUFBQUFDQUFBUUFBQUFNQUFBQURBQUFBSEFBQkFBQUFBQUE4QUFNQUFRQUFBQndBQkFBZ0FBQUFCQUFFQUFFQUFPRGUvLzhBQU9BQS8vOGdBd0FCQUFBQUFBQUFBUVlBQUFFQUFBQUFBQUFBQVFJQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUJvQUFBRHNBaFVBQXdBSEFBaTFCZ1FCQUFJdEt6TVJNeEVuTXhFakd0SzRucDRDRmYzckdnSGhBQUlBQUFBQUF5QUN2QUFIQUE0QUNMVUtDQUlBQWkwckFTRVJJVFVoRVNFZkFRYzFJVFVoQVN3QjlQNE1BWkQrY0dUSXlQNXdBWkFDdlAxRVpBSDBaSmFXWkdRQUFnQUFBQUFESUFLOEFBY0FEZ0FJdFEwSUFnQUNMU3NCSVJFaE5TRVJJUWNWSVJVaEZTY0JMQUgwL2d3QmtQNXdaQUdRL25ESUFyejlSR1FCOUdSa1pHU1dBQUFCQUFBQVpBTWdBcndBRHdBR3N3WUFBUzByRWlBV0hRRXpCeWN6TlRRbUlnWVZOTTBCSXMxa3lNaGtrdENTQXJ6TmtUTEl5REpva3BKb2tRQUJBQUFBWkFNZ0Fyd0FEd0FHc3dzQUFTMHJBQ0FXRlRRbUlnWWRBVE1ISnpNMU5BRXhBU0xOa3RDU1pNaklaQUs4elpGb2twSm9Nc2pJTXBFQUFBQUFCQUFBQUFBRElBSzhBQU1BQndBTEFBOEFEVUFLRGd3S0NBWUVBZ0FFTFNzUklSVWhGeUVWSVFjaEZTRVhJUlVoQXlEODRHUUNXUDJvWkFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUFBQUVBQUFBQUFNZ0Fyd0FBd0FIQUFzQUR3QU5RQW9PREFvSUJnUUNBQVF0S3hFaEZTRVZJUlVoRlNFVklSVWhGU0VESVB6Z0FsajlxQU1nL09BQ1dQMm9BcnhrWkdSa1pHUmtBQUFBQkFBQUFBQURJQUs4QUFNQUJ3QUxBQThBRFVBS0Rnd0tDQVlFQWdBRUxTc1JJUlVoRnlFVklRY2hGU0VYSVJVaEF5RDg0TWdDV1Ayb3lBTWcvT0RJQWxqOXFBSzhaR1JrWkdSa1pBQUFBQUFGQUFEL253TWdBcndBQlFBTEFCRUFGZ0FiQUE5QURCc1hFeElRREFnR0F3QUZMU3NCTWhjSEpUWUhGd1VtTlRRbEZoVVVCeU1sRXk0Qkp3VWhEZ0VIQVpCc1lrdit2bHl3di83S0JnS3djQkRhL3FKd1hwY3FBVXNCZERHallnSzhPK0hxTW5DSzNpUWtxR3QxbmlSQU5mNmxFWGRXSEZOcENRQUFBUUFBQUFBQjlBTWdBQVlBQnJNRUFBRXRLeE16RVRNTEFUUElaTWozL2NnRElQNE0vdFFCTEFBQUFBQUNBQUFBQUFNZ0F5QUFCd0FPQUFpMUN3Z0VBQUl0S3hJZ0ZoQUdJQ1lRSlJFakNRRWpFZW9CVE9ycS9yVHFBU3pJQVN3QkxNZ0RJT3IrdE9ycUFVeUcvdFQrMUFFc0FTd0FBQUFBQWdBQUFBQURJQU1nQUFjQURnQUl0UW9JQkFBQ0xTc1NJQllRQmlBbUVDVUpBVFVoTlNIcUFVenE2djYwNmdHUS90UUJMQUVzL3RRRElPcit0T3JxQVV5Ry90VCsxTWpJQUFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTkNBUUFBaTByRWlBV0VBWWdKaEFsRlNFVklSVUI2Z0ZNNnVyK3RPb0JrUDdVQVN3QkxBTWc2djYwNnVvQlRJYkl5TWdCTEFBQUFBSUFBQUFBQXlBRElBQUhBQTRBQ0xVTENBUUFBaTByRWlBV0VBWWdKaEFsQVRNUk14RXo2Z0ZNNnVyK3RPb0JrUDdVeU1qSUF5RHEvclRxNmdGTWh2N1UvdFFCTEFBQUFBRUFBQUJrQXlBQ1dBQUdBQWF6QlFBQkxTc0JGU0VWSVJVbEFTd0I5UDRNL3RRQ1dNaGt5UGNBQUFBQUFRQUFBR1FESUFKWUFBWUFCck1DQUFFdEt3RU5BVFVoTlNFQjlBRXMvdFQrREFIMEFsajMvY2hrQUFBQkFBQUFBQUpZQXlBQUJnQUdzd1FBQVMwckV6TVJNd2tCTThqSXlQN1gvdEhJQXlEK0RQN1VBU3dBQUFFQUFBQmtBeUFDdkFBR0FBYXpCUUFCTFNzQkZTRVZJUlVCQVN3QjlQNE0vdFFDdk1qSXlBRXBBQUFBQVFBQUFHUURJQUs4QUFZQUJyTUNBQUV0S3drQ05TRTFJUUgwQVN6KzFQNE1BZlFDdlA3WC90SEl5QUFCQUFBQUFBSllBeUFBQmdBR3N3TUFBUzByQ1FFakVTTVJJd0VwQVMvSXlNZ0RJUDdVL2d3QjlBQUFBQUVBQUFBQUFmUURJQUFHQUFhekF3QUJMU3NiQVNNUkl4RWo5LzNJWk1nRElQN1UvZ3dCOUFBRUFBQUFBQUs4QXlBQUF3QUhBQXNBRHdBTlFBb09EQW9JQmdRQ0FBUXRLd0V6RVNNRE14RWpBVE1SSXdFekZTTUJrR1JreUdSa0FaQmtaUDJvWkdRRElQemdBcno5cUFIMC9uQUJMTWdBQUFRQUFBQWlBeUFDV0FBS0FCVUFId0FwQUExQUNpUWdIQllRQ3dZQUJDMHJFeGNHRlJRWEJ5NEJOVFFsRmhVVUJnY25OalUwSndVWEJoVVVGd2NtTlRRbEZoVVVCeWMyTlRRbmRFaFlXRWczUFFLc2REMDNTRmhZL3A5RkhCeEZPd0ZWT3p0RkhCd0NXRWhZZVgxWVNEZVVVcVYwZEtWU2xEZElXSDE1V0VSSUhDa3NIRWc3VlZJNk8xRlZPMGdjTENrY0FBQUNBQUFBQUFHUUF5QUFCd0FQQUFpMURRZ0VBQUl0S3hJeUZoUUdJaVkwRXhZek1qY1JKd2QycEhaMnBIWmtOaTR0TjJSa0F5QjJwSFoycFA2VkV4UCt3V1JrQUFNQUFBQUFBeUFESUFBSEFBOEFGd0FLdHhJUURRZ0VBQU10S3hJZ0ZoQUdJQ1lRSlNJR0ZSUVhBU1lYQVJZek1qWTFOT3NCU3V2ci9yYnJBWkI4c0RnQm8wNlQvbDFPWVh5d0F5RHIvcmJyNndGS2g3QjhZVTRCb3poOS9sMDRzSHhoQUFBREFBQUFBQU1nQXJ3QUJRQUpBQTBBQ3JjTUNnZ0dCQUFETFNzUk14RWhGU0VCTXhFakFUTVJJMlFDdlB6Z0FmVEl5UDdVeU1nQ3ZQMm9aQUs4L2d3QkxQN1VBQVFBQUFBQUF5QURJQUFYQUJvQUpnQXlBQTFBQ2kwbklSc1pHQXdCQkMwckFUWVhIZ0lYTXhVakVSUUdJeUVpSmpVUkl6VXpFellYQnlFRUlnWWRBUlFXTWpZOUFUUWtJZ1lkQVJRV01qWTlBVFFCalJFUkFXeDRESUJrRkE3OTdBNFVaSURxRGhpUUFTRCs3eW9kSFNvZEFROHFIUjBxSFFNZ0FRNEJnWTRQWlA2U0RoUVVEZ0Z1WkFFWkVYNnN5QjBWWkJVZEhSVmtGUjBkRldRVkhSMFZaQlVBQWdBQUFHUURJQUs4QUE4QUV3QUl0UkVRQ1FBQ0xTc1RJVElkQVRNVkl4VVVJeUVpTlJFMEZ4RWhFUWtDcWdsa1pBbjlWZ2xrQWZRQ3ZBcSt5TDhKQ1FKR0NXVCtjQUdRQUFBQUFBRUFBQUJrQXlBQ3ZBQVBBQWF6Q1FBQkxTc1RJVElkQVRNVkl4VVVJeUVpTlJFMENRS3FDV1JrQ2YxV0NRSzhDcjdJdndrSkFrWUpBQUFBQUFJQUFQK2NBeUFDdkFBbUFDOEFDTFVzSnhZQ0FpMHJFelEyT3dNaE1oWVVCaXNCRlJJWEZoVVVCeU1HSXlFaUpqVTBOellUTlNNaUJpTWlKZ1VqRlFjR0J5RXZBVndhRXdNRkJRSDBGUjBkRlRLT0dDSXBBeXM1L2dBK1VpSVlqaklCQmdFVkhRR1l5QVkvT0FIQ2R3WUNpaElnSFNvZGpmN3pLRGN6UGlrcFVqNHpOeWdCRFkwQkhoMmlDbnRwNUFvQUFBQUNBQUFBQUFNZ0F5QUFEUUFUQUFpMUVRNEhBQUl0S3dBeUZoVVVGeFlWSVRRM05qVTBFek1VQmlJbUFUNmtkb1pDL09CQ2htVElPMUk3QXlCMlVwdHZOMDlQTjIrYlV2MjZLVHM3QUFBQUFBTUFBQUFBQWlZRElBQU5BQkFBRXdBS3R4SVJEdzRGQUFNdEt4TXpCUWNYQlNNMUJ5YzNKemNYTnhVM0J4VTNsaklCWHVIaC9xSXlTMHVXbGt0TFpKYVdsZ01nK3BPWit2cExTNWFXUzB0a3lHVEl5R1FBQUFBREFBQUFBQU1nQXlBQUZRQWRBQ1VBQ3JjZkhoY1dDd0FETFNzUklUSVdGUlFISGdFVkZBWWpJVFV5TmpVUk5DWWpJUlV6TWpZMEppTURFVE15TmpRbUl3SDBVbllzUVUrU2FQM2FLVHM3S1FFc1pDazdPeWxrbGo1WVdENERJSFpTUmpjZmVFcG9rbVE3S1FHUUtUdklPMUk3L3RUKzFGaDhXQUFBQVFBQUFBQUI5QU1nQUFVQUJyTURBQUV0S3dFUk13RVJJd0VzeVA3VXlBTWcvdFQrREFFc0FBRUFBQUFBQXJ3RElBQWJBQWF6RWdBQkxTc1RJUkUzRnhFek1oWVZFU0VpQmhRV015RVZJU0ltTlJFM1BnRTNaQUVzWkdReUZSMzkyaFVkSFJVQ0p2M2FQbGdEQmlzZEF5RCsxR1JrQVN3ZEZmM2FIU29kWkZnK0FpWVRIU3NHQUFFQUFBQUFBWkFESUFBRUFBYXpBZ0FCTFNzUklSRW5Cd0dReU1nRElQemd5TWdBQUFJQUFBQUFBeUFESUFBREFBOEFDTFVMQkFJQUFpMHJFU0VWSVJVaEZUTTFJUkVVSXlFaU5RTWcvT0FCTE1zQktRbjg4Z2tESUdSa1oyZjlzUWtKQUFBREFBQUFBQU1nQXlBQUZ3QWJBQ2NBQ3JjakhCa1lDd0FETFNzQk16SVdIUUV6TWgwQkZBWWpJU0ltUFFFME93RTFORFlYRlRNMUFSWXpJVEkzRlJRaklTSTFBU3pJS1R1L0NSMFYvVVFWSFFtL095bkkvZ3dZR2dLOEdoZ0ovUElKQXlBN0tXUUo4UlVkSFJYeENXUXBPMlJrWlA0VkNRbklDUWtBQVFBQUFBQUNXQU1nQUNRQUJyTVZBQUV0S3dFeUZoVWpOQ1lqSWdjR0ZSUVdGek1WSXdZSElSVWhOVGMyTnlNMU15NENOVFEzTmdFc1htcGtNakl2R1J3WkE2eXlGMW9CNi8yb0VGY1RlbjBDRHdneU53TWdhbDR5TWg4ak94eDNIR1JoWjJSNkRGZFBaQTFIUEI5ZVBrVUFBQUFFQUFEL25BTWdBcndBRkFBY0FDZ0FMQUFOUUFvcUtTRWRHUlVMQUFRdEt4TTdBeUV5RmhVUkZBWWpJU0ltTlJFMU5EWVdJZ1lVRmpJMk5EY2lCaFFXTXlFeU5qUW1Jd1VSSVJFaUJBTUVCUUs4RlIwZEZmMUVGUjBVbHlvZEhTb2RsaFVkSFJVQkxCVWRIUlg5MmdKWUFyd2RGZjFFRlIwZEZRSzhBZzhkWUIwcUhSMHFIUjBxSFIwcUhjaitjQUdRQUFBQUFnQUFBQUFER2dNZEFBMEFHd0FJdFJNT0J3QUNMU3NCSHdFV0J3RVBBUzRCSno4QkNRRXlGaFVVQmlNaUp6NEJOVFEyQXVnR0xBVUYvdllQR1JGUE5nd05BWGYrS0RoT25HNUtQRDFKVFFNZEF5d0ZCLzZKRFF3MlR4RVpEd0VLL25aT09HNmNJaU44U1RoT0FBQUFBQUVBQVArN0FzNEN2QUJuQUFhek1nc0JMU3NUTkRZek1oOEJOeTRCUGdFeUhnRUdCeGMzTmpNeUZoVVVCZzhCRmhjek1oWVVCaXNCRkFjWEhnRVZGQVlqSWk4QkJnY21QUWMwSmlNaUJnY1dGQWNkQXhRSEppY0hCaU1pSmpVME5qOEJKalVyQVNJbU5UUTJPd0kyTnljdUFRa2JFdzRNZ3gwY0JpUkpWa2trQlJ3Y2d3c0tGUjBRQzNNVUJVUVZIUjBWTWdaT0R4WWRGUkFQUVNWQ1BCMFZFaHdFQVFFN1F5UkNEeEFWSFJZUFRnWXlCUlVkSFJVRlJRVVVkQXdRQWNNU0lBZENGaDFZVFRnM1RWZ2VGa0lISFJVTkdnWTRJdzhkS2gwaUlDZ0VIUkFWSFFzalNDWWhKNGNFQlFZRkJWY1ZIUmNSQXhBRFVnUUZrQ2dnS1VVakN4MFZFQjBFS0NBaUhSVVVIZzhqT0FVYUFBSUFBQUFDQXJ3Q3ZBQUhBQndBQ0xVU0NRVUFBaTByQVRNeUZSRVVLd0VCSlJFbkZTSUhGeFlPQVNZbkF5TWlQUUUwT3dFQ1dGc0pDVnYrZWdFaStoY0ZTd2dPSmlvSVoxc0pDYllDdkFuOXVna0JrNVArREgwREZySVRLaEFPRXdFUUNiWUpBQUFBQndBQUFBQUN2QU1nQUFzQUR3QVRBQmNBR3dBZkFDTUFFMEFRSVNBZEhCa1lGUlFSRUEwTUJRQUhMU3NUSVRJVkVSUWpJU0kxRVRRWEZTRTFBUlV6TlRNVk16VXpFVE1SQlJVek5UTVZNelVKQXFvSkNmMVdDV1FCOVA0TVpHUmtaR1QrREdSa1pBTWdDZnp5Q1FrRERnbGt5TWorMUdSa1pHVCsxQUVzeUdSa1pHUUFCd0FBQUFBQ3ZBTWdBQU1BQ3dBUEFCTUFGd0FiQUI4QUUwQVFIUndaR0JVVUVSQU5EQWNFQWdBSExTc1JJUlVoRlNFUkZDTWhJalVURlRNMU14VXpOVE1WTXpVRkZUTTFNeFV6TlFLOC9VUUN2QW45Vmdsa1pHUmtaR1QrREdSa1pBTWd5R1QrRlFrSkFZZGtaR1JrWkdUSVpHUmtaQUFBQkFBQUFBQURJQU1nQUJnQUlBQW9BREFBRFVBS0xTa2xJUjBaQ3dBRUxTc0JNeklmQVJZN0FUSVZFUlFqSVNJMUVUUTJPd0V5UHdFMkFpSUdGQll5TmpRa0lnWVVGakkyTkNZeUZoUUdJaVkwQVptMkNBUmVCQWhTQ1FuODhnbFlQbzBJQkY0RTVpb2RIU29kQVg2a2RuYWtkdkZTT3p0U093TWdDYllKQ2YyNkNRa0J1VDVZQ2JZSi90UWRLaDBkS2gxMnBIWjJwQkk3VWpzN1VnQUFBQUVBQUFESUF5QUNXQUFDQUFhekFnQUJMU3NSSVFFRElQNXdBbGorY0FBQUFRQUFBQUFCa0FNZ0FBSUFCck1CQUFFdEt3RVJBUUdRL25BRElQemdBWkFBQUFBQUFRQUFBQUFCa0FNZ0FBSUFCck1DQUFFdEt4RUpBUUdRL25BRElQNXcvbkFBQUFBQUFRQUFBTWdESUFKWUFBSUFCck1CQUFFdEt3a0JJUUdRQVpEODRBSlkvbkFBQUFBQUF3QUFBQUFESHdKWUFDRUFLUUF4QUFxM0xpb21JaElDQXkwckVUUTJPd1F5Rmg4QklUSVdEd0VPQVNNaElpWW5MZ0V2QVNNaUJpTWlKZ0F5RmhRR0lpWTBKRElXRkFZaUpqUWJFd01GQk1nTkdnVW1BYndLQ0FOUkF4VUwvcUlLRlFNT05nMEtsZ0VGQVJVZUFWRXFIUjBxSFFGSktoMGRLaDBDSmhJZ0VRdElEd3I2Q2c4UENpbW9LUmtCSHY1VEhTb2RIU29kSFNvZEhTb0FBZ0FBQUFBRElBSzhBQVlBQ3dBSXRRa0hCZ0FDTFNzUklSVWhFU01IQVNFUkp5RUI5UDdVWkdRQkxBSDBaUDV3QXJ4ay90UmtBU3orREdRQUFRQUFBRUlERUFLOEFBMEFCck1DQUFFdEt3RVhBUzRDTHdFM0ZoYytBZ0tCai80VElFbGFHRWlOUzA0bmpuUUN2STMrRXlKS1dSbEhqVXhLSjQ1MEFBRUFBQUF5QXlBQ1dBQUZBQWF6QkFBQkxTc1RGemNYQ1FHVyt2cVcvbkQrY0FKWSt2cVcvbkFCa0FBQUFRQUFBQUFDSmdNZ0FBVUFCck1FQUFFdEt3RVhCeGNIQVFHUWx2cjZsdjV3QXlDVyt2cVdBWkFBQUFBQkFBQUFBQUltQXlBQUJRQUdzd0lBQVMwckV3a0JKemNubGdHUS9uQ1crdm9ESVA1dy9uQ1crdm9BQUFFQUFBQXlBeUFDV0FBRkFBYXpBZ0FCTFNzSkFRY25CeWNCa0FHUWx2cjZsZ0pZL25DVyt2cVdBQUFBQWdBQUFBQURJQU1nQUFjQURRQUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVDVUhKd2NYQWVvQlRPcnEvclRxQWxqNlpFaXNBVUlESU9yK3RPcnFBVXc0K21SSXJBRkNBQUFBQWdBQUFBQURJQU1nQUFjQUV3QUl0UXdJQkFBQ0xTc1NJQllRQmlBbUVEY0hGd2NYTnhjM0p6Y25CK29CVE9ycS9yVHEra2lXbGtpV2xraVdsa2lXQXlEcS9yVHE2Z0ZNT0VpV2xraVdsa2lXbGtpV0FBQUFBQUlBQUFBQUFyd0RJQUFSQUNVQUNMVWRFZ2tBQWkwckFESVdIUUV6TWhZZEFTRTFORFk3QVRVMEJUTVZJVFV6TWhZVkVSUUdJeUVpSmpVUk5EWUJTU29kU3dzTy90UU9DMHYrN1VzQjlFc0xEZzRML1hZTERnNERJQjBWTWc0TFMwc0xEaklWUjhqSURndjlkZ3NPRGdzQ2lnc09BQUFBQUFNQUFBQUFBeUFESUFBSEFBOEFHQUFLdHhVUURBZ0VBQU10S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFsTXhVV0Z3Y21Md0hyQVVycjYvNjI2d0lNK0xDdytMRCtvbVFpSmtna01CQURJT3YrdHV2ckFVcUhzUGl3c1BoTXRTUWhTQ2d3REFBQ0FBQUFBQU1nQXlBQUdRQXNBQWkxSmg0SkFBSXRLd0V5RmgwQkhnRVZGQWNqTlRRbUlnWWRBU0VtTlRRMk16NEJFenNCTWpZek1oWWRBak1ISnpNOUFUUTJBY0pva2lzNUNiOVlmRmorOEJ4MlVoR1BTZ01FQVFZQ0ZSMld5TWlXRkFNZ2ttZ3lFRlV4R2hneVBsaFlQakl4TTFKMlZuTCtjQUVkRlFHV3lNaVdBZzhkQUFBQUFnQUFBQUFESUFNZ0FCUUFId0FJdFJvVkNRQUNMU3NCTWhZZEFSNEJGUlFISXljSEl5WTFORFl6UGdFVEZ5TVZGQVlpSmowQkl3SENhSklyT1FtTnlNamVISFpTRVk5YStzZ2RLaDNJQXlDU2FESVFWVEVhR01qSU1UTlNkbFp5L2o3Nk1oVWRIUlV5QUFBQUFRQUFBR1FESUFLOEFCSUFCck1KQUFFdEt3RXlGaDBCSGdFVkZBWWpJU0ltTkRZelBnRUJ3bWlTS3psWVB2NCtVbloyVWhHUEFyeVNhRElRVlRFK1dIYWtkbFp5QUFBQUFnQUFBQUFESUFNZ0FBc0FIZ0FJdFJVTUJ3QUNMU3NUTWhjaUJnY0dCeVkxTkRZRk1oWWRBUjRCRlJRR0l5RWlKalEyTXo0QitudE5hckVxT2lvWmtnRXdhSklyT1ZnKy9qNVNkblpTRVk4RElHUnpYaEFmTkRab2tzaVNhRElRVlRFK1dIYWtkbFp5QUFBQUF3QUFBR1FESUFLOEFBTUFDUUFQQUFxM0RRb0hCQUlBQXkwckFUTUJJd016Qnhjakp5VXpGd2NqTndIMFpQN1VaR1JrWkdSa1pBSllaR1JrWkdRQ3ZQMm9BZlRJeU1qSXlNaklBQUlBQUFBQUF5QURJQUFmQUNjQUNMVWtJQkFBQWkwckFUTWZBVGNYQng4QkZROEJGd2NuRHdFakx3RUhKemN2QVRVL0FTYzNGemNXSWdZVUZqSTJOQUZlWkRJY2QwZ3lESGQzRERKSWR4d3laREljZDBneURIZDNEREpJZHh5aWZGaFlmRmdESUhjTU1raDNIREprTWh4M1NESU1kM2NNTWtoM0hESmtNaHgzU0RJTWcxaDhXRmg4QUFBQUF3QUFBQUFESUFNZ0FBTUFCZ0FLQUFxM0NRY0dCQUlBQXkwckVTRVZJUmNoQndVaEZTRURJUHpneUFHUXlQNXdBeUQ4NEFNZ3lHVEl5R1FBQXdBQUFBQURJQU1nQUFNQUJ3QUtBQXEzQ1FnR0JBSUFBeTByRVRNUkl3RXpFU01ERVNka1pBSll5TWhreUFNZy9PQURJUHpnQWxqK2NNZ0FBd0FBQUFBRElBTWdBQU1BQndBS0FBcTNDZ2dHQkFJQUF5MHJFVE1SSXdFekVTTUJGd2ZJeUFLOFpHVCtjTWpJQXlEODRBTWcvT0FDV01qSUFBQUFBQU1BQUFBQUF5QURJQUFEQUFZQUNnQUt0d2tIQlFRQ0FBTXRLeEVoRlNFRkZ5RUhJUlVoQXlEODRBR1F5UDV3eUFNZy9PQURJR1RJeUdUSUFBWUFBQUFBQXJ3Q3ZBQW5BREFBT1FBOUFFWUFUd0FSUUE1S1IwSStPem8xTVN3b0ZBQUdMU3NTTWhZZEFUTTFORFl5RmhRR0t3RVZNeklXRkFZaUpqMEJJeFVVQmlJbU5EWTdBVFVqSWlZMEZpSUdGQlk3QVRVMEpDSUdIUUV6TWpZMEJSVXpOUWNpQmhRV01qWTlBU0VWRkJZeU5qUW1JMWg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHhZV0Q0eU1qNVlxeW9kSFJVeUFYTXFIVElWSGY3VVpQb1ZIUjBxSFFFc0hTb2RIUlVDdkZnK01qSStXRmg4V0dSWWZGaFlQakl5UGxoWWZGaGtXSHdNSFNvZE1oVWRIUlV5SFNxclpHVElIU29kSFJVeU1oVWRIU29kQUFBQkFBQUFBQU1nQXlBQUNnQUdzd1lCQVMwckVUUXpJVElWRVNjaElqVUpBdzRKeVAyeENRTVhDUXI4NnNnSkFBQUVBQUFBQUFNZ0F5QUFCd0FQQUJNQUd3QU5RQW9ZRkJJUURBZ0VBQVF0S3hJZ0ZoQUdJQ1lRSkNJR0ZCWXlOalFuQXdVVEZpSUdGQll5TmpUckFVcnI2LzYyNndJTStMQ3crTEJrWlA3VVpIa3FIUjBxSFFNZzYvNjI2K3NCU29ldytMQ3crRXorMUdRQkxESWRLaDBkS2dBQUFBSUFBQUFBQXlBRElBQUhBQTBBQ0xVSkNBUUFBaTByRWlBV0VBWWdKaEFsRVRJMk5DYnJBVXJyNi82MjZ3R1FmTEN3QXlEci9yYnI2d0ZLaC8yb3NQaXdBQUFBQlFBQUFBQURJQU1nQUFNQUJ3QUxBQThBRndBUFFBd1VFQTRNQ2dnR0JBSUFCUzByRVNFVklSVWhGU0VWSVJVaEZTRVZJU1F5RmhRR0lpWTBBeUQ4NEFIMC9nd0RJUHpnQWxqOXFBTFpLaDBkS2gwRElHUmtaTWhrWkdSa0hTb2RIU29BQUFRQUFBQmtBeUFDdkFBSkFCTUFGd0FiQUExQUNoa1lGUlFPQ2dVQUJDMHJFeUV5RmgwQklUVTBOZ2NoRVJRR0l5RWlKalUzRlRNMU14VXpOUmtDN2dzTy9PQU9EZ01nRGd2OUVnc09aR1JrWkFLOERndExTd3NPeVA2SkN3NE9DNjlrWkdSa0FBQUFBd0FBQUFBRElBTWdBQklBRlFBWUFBcTNGeFlVRXdzQUF5MHJFek1WSVRjWEJ4RXpGU01WSXpVaEVTTTFNeGNSQVJjQklXUmtBY0prTW1Sa1pHVCtER1JrWkFGZU12NmlBVjRESUdSa01tVCtQbVJrWkFIMFpHVCtvZ0ZlTXY2aUFBQUFBQVVBQUFBQUF5QURJQUFIQUE4QUZ3QXNBRFFBRDBBTU1TMG1HeFFRREFnRUFBVXRLeElnRmhBR0lDWVFKQ0lHRkJZeU5qUWtNaFlVQmlJbU5BYzBOamM3QWpJZkFUY3lGaFFHSWlZMU55Y21KRElXRkFZaUpqVHJBVXJyNi82MjZ3SU0rTEN3K0xEK3Z5b2RIU29kbGhRT0F3TUlGZzViR1NrN08xSTdCbG9RQVVrcUhSMHFIUU1nNi82MjYrc0JTb2V3K0xDdytFd2RLaDBkS25jUEhRUVFXZ1k3VWpzN0tSbGJEa1lkS2gwZEtnQUFBQUlBQUFBQUF5QURJQUFHQUFvQUNMVUpCd1FBQWkwckFUTVJNd2tCTXdFaEZTRUJMTWpJL3RUKzFNaisxQU1nL09BRElQN1UvdFFCTFA1d1pBQUFBQUFDQUFBQUFBTWdBeUFBQXdBS0FBaTFCd1FDQUFJdEt4RWhGU0VGQVNNUkl4RWpBeUQ4NEFHUUFTekl5TWdESUdSay90VCsxQUVzQUFJQUFBQmtBeUFDdkFBRUFCQUFDTFVKQlFJQUFpMHJFeUVSSVFNbEJ4Y0hGemNYTnljM0p3ZklBbGo5cU1nQlhraVdsa2lXbGtpV2xraVdBcno5cUFFczNraVdsa2lXbGtpV2xraVdBQUFBQWdBQUFHUURJQUs4QUFzQUdBQUl0Uk1NQXdBQ0xTc1NJQllWSXpRbUlnWVZJelFsRnpjZUFSVVVCaUltTlRRMjZ3Rks2MlN3K0xCa0FWVTdPejVQZHFSMlR3Szg2NlY4c0xCOHBScFlXQk5wUTFKMmRsSkRhUUFBQUFBRkFBQUFBQUs4QXlBQUJRQUlBQXdBRUFBVUFBOUFEQklSRGcwS0NRY0dCQUFGTFNzUklSRWhFU0VKQVNFbEZUTTFCeFV6TlFjVklUVUJMQUdRL1VRQmtBRXMvdFQrMUdSa1pHUUJrQU1nL25EK2NBTWcvdFJrWkdUSVpHVElaR1FBQUFBQUFRQUEvNXdCOUFLOEFEc0FCck1lQUFFdEt4TXpGVE15RnhZZEFTTTFKaXNCSWdZZEFSUVdGd1VlQVIwQkZBWXJBUlVqTlNNaUp5WTlBVE1WRmpzQk1qWTlBVFFtSnlVdUFUMEJORFk3QWNoa1N6RWdMR1FJRWZvTERoY0xBUUV4UEVvelMyUkxNU0FzWkFnUitnc09Gd3YrL3pFOFNqTkxBcnhrRmg4dlpGNEdEZ3N5Q3g0RFFReE9Nekl6U21Sa0ZoOHZaRjRHRGdzeUN4NERRUXhPTXpJelNnQUNBQUFBWkFNZ0Fyd0FBd0FIQUFpMUJ3UURBQUl0S3hFaEVRa0JJUkVCQVN6KzFBSDBBU3orMUFLOC90VCsxQUpZL3RUKzFBQUFBQUlBQUFCa0F5QUN2QUFEQUFjQUNMVUZCQUVBQWkwckFSRWhFUUVSSVJFQkxQN1VBeUQrMUFLOC9hZ0JMQUVzL2FnQkxBQUNBQUFBWkFNZ0Fyd0FDZ0FWQUFpMUVRc0dBQUl0S3dFVklnWVZNeEVoRVRRMklSVWlCaFV6RVNFUk5EWUJMRk4xeVA3VXNBSndVM1hJL3RTd0FyeGtkVlArMUFFc2ZMQmtkVlArMUFFc2ZMQUFBQUFDQUFBQVpBTWdBcndBQ2dBVkFBaTFEd3NFQUFJdEt4RWhFUlFHSXpVeU5qVWpBU0VSRkFZak5USTJOU01CTExCOFUzWElBZlFCTExCOFUzWElBcnorMUh5d1pIVlRBU3orMUh5d1pIVlRBQUlBQVAvcUFsZ0RJQUFTQUNJQUNMVVlFd2tBQWkwckFSY2VCQlVVQmlJbU5UUStBemNDSWdZVkZCWXpNalkwSmlNaUpqVTBBU3dpRFNoWlJUZXcrTEEzUlZrb0RWOHFIWFpTRlIwZEZTazdBeUFpRFN0eWI1STlmTEN3ZkQyU2IzSXJEZjVLSFJWU2RoMHFIVHNwRlFBQ0FBQUFBQU1nQXlBQUFnQUdBQWkxQlFNQkFBSXRLd2tCSVJVaEZTRUJrQUdRL09BRElQemdBeUQrREdUSUFBQUNBQUFBQUFKWUF5QUFBZ0FGQUFpMUJRTUJBQUl0S3drQklSVWhBUUVzQVN6OXFBSlkvdFFESVA3VXlQN1VBQUFEQUFBQkxBTWdBZlFBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSUFmVEl5TWpJeUFBQUFBQUNBQUFBWkFNZ0Fyd0FCQUFKQUFpMUNBVURBQUl0S3hFaEZRVWxGUVVsRVNFRElQNXcvbkFCa0FHUS9PQUN2R1RJeUdUSXlQNXdBQU1BQUFBQUF5QURJQUFFQUFvQUR3QUt0dzRMQ0FVQ0FBTXRLd0VGRVNFUkpRVVZCU1UxQlNFVkJ5Y0JrQUdRL09BQmtQN1VBU3dCTFA0TUFaREl5QU1neVAyb0FsaFlscnlXbHJ3bVpHUmtBQUFBQUFFQUFQK2NBeUFDdkFBakFBYXpGUUFCTFNzQk1oY0hKaUlHQnlFSElSUVhJUWNqRmpNeU54VUdJeUltSnlFM015WTFJemN6UGdFQ1dHTmNFRTdDbVI4QlN4RCtzaE1CS1JEZVdvUnlWbDVxYkxZMi93QVR4UkRJR2I4aTFBSzhNbW80YjFsa0xUZGtaRTU2T0cxYlpFQWtaSU9wQUFBQUFBWUFBQUFBQXlBQ3ZBQURBQWNBQ3dBUEFCTUFGd0FSUUE0V0ZCSVFEZ3dLQ0FZRUFnQUdMU3NSSVJVaEZTRVZJUlVoRlNFVk14VWpOek1WSXpjekZTTUN2UDFFQWZUK0RBTWcvT0JrWk1oa1pNaGtaQUs4WkdSa1pHUmtaR1JrWkdRQUFBQURBQUFBQUFNZ0F5QUFBd0FHQUFvQUNyY0pCd1lFQWdBRExTc1JJUlVoRnlFSEJTRVZJUU1nL09ESUFaREkvbkFESVB6Z0F5QmtaTWpJeUFBREFBQUFBQU1nQXlBQUF3QUhBQW9BQ3JjS0NBWUVBZ0FETFNzUk14RWpBVE1SSXdFWEIyUmtBbGpJeVA1d3lNZ0RJUHpnQXlEODRBSll5TWdBQUFBQUF3QUFBQUFESUFNZ0FBTUFCd0FLQUFxM0NRZ0dCQUlBQXkwckVUTVJJd0V6RVNNREVTZkl5QUs4WkdSa3lBTWcvT0FESVB6Z0FsaitjTWdBQXdBQUFBQURJQU1nQUFNQUJnQUtBQXEzQ1FjRkJBSUFBeTByRVNFVklRVVhJUWNoRlNFRElQemdBWkRJL25ESUF5RDg0QU1neU1qSVpHUUFBZ0FBQUFBRElBTWdBQWtBRUFBSXRRNEtDQUFDTFNzUk14VWpFU0UxTXhVaEFTRVJKd2NuTjhoa0FsaGsvT0FCa0FHUWx2cGsrZ01nWlAyb1pNZ0RJUDV3bHZwaytnQUFBd0FBQUdRRElBSzhBQnNBSXdBMUFBcTNNU1FnSEEwQUF5MHJBVEllQkI4QkRnUWpJaTRDTHdFK0JoWWlCaFFXTWpZMEp6SVhCaFVVRmpNeU54WVZGQVlpSmpRMkFaTXlZMHhGTVNRSkNRWVhUMWFHUlVlSFhFY1JFUU1NS1M1SVRXU0RwSFoycEhiSUNoSWNIUlVlRGdZN1VqczdBcndoTlVCQU5SRVFEQ2xuVDBFK1dGZ2ZId1lXUGpsRk1pSmtkcVIyZHFRU0JnNGVGUjBjRWdvcE96dFNPd0FDQUFEL25BTWlBcjBBSVFBbEFBaTFKQ0laQXdJdEt3RTdBVFl6TWg4Qk56WXlGeFlVRHdFWEZoVVVCaU1pTHdFQklSRUJKeVkxTkRZWEFSY0JBVXNEQXdNSEZnOWVRaXQrS3l3c1FWMFNIUlVaRHo3K2cvN3pBWGMvRUJXQy9zZUFBVHdDdkFFUlhVRXJLeXg4TEVKZURoZ1ZIUlJCL29NQkVBRjlQdzRXRHgzWC9zV0VBVHdBQWdBQUFBQUN2QU1nQUFVQUNBQUl0UWNHQkFBQ0xTc1JJUkVoRVNFSkFTRUJMQUdRL1VRQmtBRXMvdFFESVA1dy9uQURJUDdVQUFBQ0FBQUFBQUs4QXlBQUdnQXNBQWkxSXhzTkFBSXRLeE1lQkJVVURnUVhMZ1ExTkQ0RU5BRWVCQlVVQmlNaE5ENEVOTWdJRzBVMUt5czlRUzBMR1FnYlJUVXJJVEU1TVNBQkdBZ2JSVFVyUHlYKzFDRXhPVEVnQXlBRUVEaEFhRGd1WFVkU1Jsd3VCQkE0UUdnNEtGQkFRa0ZDVHY3OUJCQTRRR2c0Wm1Jb1VFQkNRVUpPQUFBQUFnQUFBQUFESUFNZ0FBTUFEQUFJdFFrRUFnQUNMU3NSTXhFakV5RVZJUWNYSVRValpHVElBU3dCTE1qSS9uRElBeUQ4NEFNZ1pNdkZaQUFBQVFBQUFBQUJrQU1nQUFvQUJyTUdBQUV0S3hNekJ6TURNd0VETXpjamxwWmt5SmFXL3RSa2hrTElBeURJL3RUKzFBRXN5QUFBQUFBQ0FBQUFBQU1nQXlBQUJRQVBBQWkxQ2dZRUFBSXRLeEVoRlNFVklSVWhFUlFHSXlFaUpqVUJMQUgwL09BRElCMFYvVVFWSFFNZ1pHUmsvajRWSFIwVkFBQUFBQUVBQUFBQUFyd0RJQUF3QUFhekpRQUJMU3NTTWhZVkZBWUhGVFk3QVRJMlBRRXVBVFUwTmpJV0ZSUUdCeFVVQmlzQklnY2VBUlVVQmlJbU5UUTJOelV1QVRVMFdIeFlOeTBiRjhnVkhTMDNXSHhZTnkxWVBzZ1NFQ1l1V0h4WU55MHROd01nV0Q0eFRROTJDUjBWT3c5Tk1UNVlXRDR4VFE4N1BsZ1FFa2dzUGxoWVBqRk5EOW9QVFRFK0FBQUFBQUlBQUFBQUF5QURJQUFHQUEwQUNMVUtCd1FBQWkwckVTRUhGd2NuQnlFWE54RWhOeWNCa0phV1pKYVdBZlNXbHY1d2xwWURJSmFXWkphV2xwYitjSmFXQUFBQUFnQUFBQUFESUFNZ0FBWUFEUUFJdFFzSEF3QUNMU3NURnpjUklUY25BU0VIRndjbkIyU1dsdjV3bHBZQmtBR1FscFprbHBZRElKYVcvbkNXbHY3VWxwWmtscFlBQUFBQUF3QUFBQUFESUFNZ0FBY0FSZ0JWQUFxM1VVY25DQVFBQXkwckVpQVdFQVlnSmhBbElnY1hGZ1lIQmlJR0Z4WUdMZ0VIQmg0QkJ5Y2lCeFlYSGdFWEhnRUhGak15TmpjMkppTWlMZ0kzUGdNbkpqNEJOVFFtSnlZK0F6Y21GdzRCRnhZMkZ4NERQd0UxSnVvQlRPcnEvclRxQVpCUVNSWVdEUllLS3hFRkJnb09Gd1lUR1NBSE93b0dBUklKVGcwbE5oQTZNRXVES1FJWEhSNHdNUnNCQVI4ZUVRME5CUlJFQVFFREN3WVRBem5DSXprRkF6WUlBd2tIRUFrV0VBTWc2djYwNnVvQlRJWXNFdzhqQ1FRT0Z4UUlDUWdFRWtOR0FTSUtIallEQ1EwV2FTQVdRem9VR0FjVEtSNFBMQ0VvQ3hJTkdRb1ZGd1lGQ3cwSEVnSVRiUW9mREFnQkJnTVVEUVlMRmdNbUFBQUNBQUFBQUFNZ0F5QUFCd0FMQUFpMUNnZ0VBQUl0S3dFWEFTY0hKd0VYQVNFVklRSy9ZZjV3Wk1oa0FTeGsvbkFESVB6Z0F5QmsvbkJreTJRQkwyVCtjR1FBQUJBQUFBQUFBcndDdkFBREFBY0FDd0FQQUJNQUZ3QWJBQjhBSXdBbkFDc0FMd0F6QURjQU93QS9BQ1ZBSWo0OE9qZzJOREl3TGl3cUtDWWtJaUFlSEJvWUZoUVNFQTRNQ2dnR0JBSUFFQzByRVRNVkl6Y3pGU00zTXhVak56TVZJd1V6RlNNM014VWpOek1WSXpjekZTTUZNeFVqTnpNVkl6Y3pGU00zTXhVakJUTVZJemN6RlNNM014VWpOek1WSTJSa3lHUmt5R1JreUdSay9haGtaTWhrWk1oa1pNaGtaUDJvWkdUSVpHVElaR1RJWkdUOXFHUmt5R1JreUdSa3lHUmtBcnhrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa0FBa0FBQUFBQXlBRElBQURBQWNBQ3dBUEFCTUFGd0FiQUI4QUl3QVhRQlFpSUI0Y0doZ1dGQklRRGd3S0NBWUVBZ0FKTFNzUk14VWpKVE1WSXlVekZTTUZNeFVqSlRNVkl5VXpGU01GTXhVakpUTVZJeVV6RlNQSXlBRXN5TWdCTE1qSS9hakl5QUVzeU1nQkxNakkvYWpJeUFFc3lNZ0JMTWpJQXlESXlNakl5R1RJeU1qSXlHVEl5TWpJeUFBQUFBUUFBQUFBQXlBRElBQURBQWNBQ3dBUEFBMUFDZzRNQ2dnR0JBSUFCQzByRVNFUklRRWhFU0VGSVJFaEFTRVJJUUVzL3RRQjlBRXMvdFQrREFFcy90UUI5QUVzL3RRRElQN1VBU3orMU1qKzFBRXMvdFFBQUFBREFBQUFBQUs4QXlBQURRQVpBQ0VBQ3JjZUdoVU9CZ0FETFNzVElUSVZFUlFHSXlFaUpqVVJOQkVXTXlFeU54RVVJeUVpTlNRaUJoUVdNalkwRXdLV0V4MFYvYWdWSFJnYUFsZ2FHQlA5YWhNQ095b2RIU29kQXlBVC9yVVZIUjBWQVVzVC9oVUpDZjdlRXhPMUhTb2RIU29BQUFFQUFBQUFBcndDdkFBekFBYXpHZ0FCTFNzUklSVWpJZ1lkQVNFMU5DWXJBVFVoRlNNaUJoVVJGQlk3QVJVaE5UTXlOajBCSVJVVUZqc0JGU0UxTXpJMk5SRTBKaXNCQVN3eUZSMEJMQjBWTWdFc01oVWRIUlV5L3RReUZSMysxQjBWTXY3VU1oVWRIUlV5QXJ4a0hSV1dsaFVkWkdRZEZmNXdGUjFrWkIwVmxwWVZIV1JrSFJVQmtCVWRBQUFBQUFFQUFBQUFBeUFDdkFBbEFBYXpDd0FCTFNzQU1oWWRBVE15RmgwQkZBWXJBU0ltTlJFMEppSUdGUkVVQmlzQklpWTlBVFEyT3dFMU5BRVUrTEF5RlIwZEZXUVZIWFdtZFIwVlpCVWRIUlV5QXJ5d2ZHUWRGY2dWSFIwVkFWNVRkWFZUL3FJVkhSMFZ5QlVkWkh3QUFBQUJBQUFBRXdNZ0Fyd0FEUUFHc3d3Q0FTMHJFRFEyTWhZVk5EWXlGaFFIQ1FGMnBIWjJwSFk3L3F2K3F3R2lwSFoyVWxKMmRxUTcvcXdCVkFBQkFBQUFBQU1nQXJ3QUNnQUdzd01BQVMwckNRRW5FU00xSXhVakVTTUJrQUdRWk1qSXlHUUN2UDdVQS81dHlNZ0JrQUFBQWdBQUFBQURJQU1nQUFNQURRQUl0UWNFQWdBQ0xTc1JJUkVoRXhFM0FUTTFKemNYRVFNZy9PQmtaQUdRWk1oa1pBTWcvT0FDdlA3VVpQNXdaTWhrWkFFc0FBQUNBQUFBQUFNZ0F5QUFDd0FUQUFpMUR3d0ZBQUl0S3hNaE1oVVJGQ01oSWpVUk5CY1JNeGN6TnpNUkV3TDZFeFA5QmhOa1pHVElaR1FESUJQOUJoTVRBdm9UeVA3VVpHUUJMQUFBQXdBQUFNZ0RJQUpZQUJVQUlBQXJBQXEzSmlFYUZnb0FBeTByRXpJV0Z6NEJNeklXRkFZaklpWW5EZ0VqSWlZME5oY2lCaFFXTXpJMk55NEJJU0lHQng0Qk16STJOQ2JJTjE0ek0xNDNYV3RyWFRkZU16TmZObDFyYTEwek1URXpIVDhxS2o4QmN4MC9LaW8vSFRNeE1RSllRRG82UUhpZ2VFQTZPa0I0b0hoa1BGQThOREF3TkRRd01EUThVRHdBQWdBQUFBQUJrQU1nQUFjQUpRQUl0UllJQkFBQ0xTc0FNaFlVQmlJbU5BWXlGaFVVQmhVVUZqSTJOVE1VQmlNaUpqVTBQZ0UxTkNZaUJoVWpOQUVEVWpzN1VqdHdmRmhrSFNvZFpGZytQMWN5TWgwcUhXUURJRHRTT3p0U3YxazlKY2NPRlIwZEZUNVlWa0FsY1ZvS0ZSMGRGVDRBQUFBQUFRQUFBQUFDdkFNZ0FCQUFCck1IQUFFdEt4TWhGU01EQnpNVklUVXpQZ0kvQVNQSUFmUjY2Z2FpL2d4NklrNWdHZ2VqQXlCay9iUU1aR1JZeE85QkRBQUFBQUFFQUFBQUFBTWdBcndBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt4RWhGU0VWSVJVaEZTRVZJUmNoRlNFRElQemdBeUQ4NEFNZy9PQmtBbGo5cUFLOFpHUmtaR1JrWkFBQUJBQUFBQUFESUFLOEFBTUFCd0FMQUE4QURVQUtEZ3dLQ0FZRUFnQUVMU3NSSVJVaEZTRVZJUlVoRlNFVklSVWhBeUQ4NEFNZy9PQURJUHpnQWxqOXFBSzhaR1JrWkdSa1pBQUFBQVFBQUFBQUF5QUN2QUFEQUFjQUN3QVBBQTFBQ2c0TUNnZ0dCQUlBQkMwckVTRVZJUlVoRlNFVklSVWhGeUVWSVFNZy9PQURJUHpnQXlEODRNZ0NXUDJvQXJ4a1pHUmtaR1JrQUFBQ0FBQUFBQU1nQXlBQUVRQVpBQWkxRmhJTEFBSXRLd0F5RmhRR0l5SW5CeFVqRlNFMUFTWTFOQ1FpQmhRV01qWTBBYjdRa3BKb0lBOER5UDdVQVM4REFWVlNPenRTT3dNZ2t0Q1NBd05reU1nQkx3OGdhQzQ3VWpzN1VnQUFBQUFDQUFBQUFBTWdBbGdBR0FBZ0FBaTFIQmtOQUFJdEt4TTdBeUV5RmhVUk14VVVCaU1oSWlZOUFUTVJOVFEyRnhFekZUTTFNeEdHQXdRRUJRSDBGUjFrSFJYOVJCVWRaQlJRWk1oa0FsZ2RGZjZpbGhVZEhSV1dBVjRDRHgxZy90UmtaQUVzQUFBQUFBTUFBQUFBQXlBRElBQURBQWtBRHdBS3R3d0tCZ1FDQUFNdEt4RWhFU0VsTXhFaE5TRTNNeEVoTlNFQmtQNXdBZlJrL25BQkxNaGsvbkFCTEFNZy9uREkvbkJrWlA1d1pBQUFBQUFFQUFEL213SDhBcjBBRVFBakFEMEFVQUFOUUFwTlFESWxIQk1LQVFRdEt3RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0J3VUdJeUltTlRRMk55RTJNeklXRlJRR0R3RWVBUlVVQmlNaUppc0JMZ0UxTkRZM0Z6UTJPd1F5RmhRR0t3RWlCaU1pSmdGUkNnc1ZIUkFML3RRUEVCVWRGZzhCa0FzS0ZSMFFDLzV3RHhBVkhSWVBBWkFMQ2hVZEVBdHFFaGtlRlFFR0FjZ1RIUThMRGhzVEF3UUZaQlVkSFJWa0FRWUJGUjBDdGdjZEZRMGFCcFlMSFJVUUhRUUhIUlVOR2diSUN4MFZFQjBFQngwVkRSb0dPQU1kRWhVZUFRRWRGQXdhQnZRU0lCMHFIUUVlQUFRQUFBQUFBeDRESUFBRkFDY0FTZ0JRQUExQUNrOUxSUzBRQ0FJQUJDMHJFek1WSXpVekpUTTJGeFlYRmhRUEFRWWpJaVkxTkQ4Qk5pWW5KZ1lQQVFZaklpWTFORDhCTmdFMk93RXlOak15RmhRUEFRWVdGeFkyUHdFMk16SVdGUlFQQVFZSEJpWW5KalEzQlRNVkl4VWp4MlRJWkFHREFTSVdOeW82T3BZUEhCVWRHSlllQVIwZ1ZSc3NEeHNWSFJnck12N1VEUWtEQVFZQkZSME9saDRCSFNCVkd5d1BHeFVkR0NzZkxEUnlLVG82QWJuSVpHUURJTWhrWVFJRkRDbzZwRHVXR0IwVkhBK1dIbFVkSGdNYkxCZ2RGUndQTERUKzBSQUJIU29PbGg1VkhSNERHeXdZSFJVY0R5d2ZFQk1aS1R1a09veGtaQUFBQUFJQUFBQUZBeDRESFFBckFGUUFDTFZVVFFrQkFpMHJBVFlYRmhjV0ZBOEJCaWN1QlNNbU5UUTJNeklYRmhjV1B3RTJKaWNtQmdjR0l5SW1OVFEzTmdjZUFoY2VBUlVVQmlNaUp5WW5KZzhCQmhZWEZqWTNOak15RmhVVUJ3WUhCaVluSmpRL0FUWUNTaU1XTnlvNk9wWlVZZ3dXRFJFRkRnRWFIUlVPREE4YU56T1dIZ0VkSUZVYkR4d1ZIUmd5ZWhZZ0dBY1BGaDBWRUE4VEhEa3VsaDRCSFNCVkd3OGJGUjBYSHl3MGNpazZPcFpRQXgwQ0JRd3FPcVE3bGxRR0FRTURCd01JRGg0VkhnY0xBZ1F6bGg1VkhSNERHeGdkRlJ3UE5PTUJDQXNDQkIwUUZSMExDUUVDTHBZZVZSMGVBeHNZSFJVZERoOFFFeGtwTzZRNmxsQUFBQUFBQmdBQUFBQURJQUs4QUFNQUJ3QUxBQThBRXdBWEFCRkFEaFlVRWhBT0RBb0lCZ1FDQUFZdEt4RWhFU0VCSVJVaEZTRVZJUVVoRVNFQklSVWhGU0VWSVFFcy90UUJrQUdRL25BQkxQN1UvbkFCTFA3VUFaQUJrUDV3QVN6KzFBSzgvdFFCTEdSa1pHVCsxQUVzWkdSa0FBZ0FBQUFBQXlBQ3ZBQUhBQXNBRXdBWEFCOEFJd0FyQUM4QUZVQVNMaXdvSkNJZ0hCZ1dGQkFNQ2dnRUFBZ3RLeEl5RmhRR0lpWTBOeUVWSVFZeUZoUUdJaVkwTnlFVklRWXlGaFFHSWlZME55RVZJUVl5RmhRR0lpWTBOeUVWSVIwcUhSMHFIY2dDV1Ayb3F5b2RIU29keUFKWS9haXJLaDBkS2gzSUFsajlxS3NxSFIwcUhjZ0NXUDJvQXJ3ZEtoMGRLaDFrWkIwcUhSMHFIV1JrSFNvZEhTb2RaR1FkS2gwZEtoMWtBQUFBQVFBQUFBQURJQU1nQUFNQUJyTUJBQUV0S3drQkF5VURJUDV3WlA3VUF5RDg0QUVzWkFBQUFBSUFBQUFBQWxnQ3ZBQUxBQk1BQ0xVUURBWUFBaTByRWpJV0hRRXpFU0VSTXpVME5pSUdIUUV6TlRUYXBIWmsvYWhrOGxRNnlBSzhkbEprL25BQmtHUlNFam9xWkdRcUFBRUFBQUFBQWxnRElBQVJBQWF6QmdBQkxTc1NNaFlkQVRNUklSRWhOVFFtSWdZVkl6VGFwSFprL2FnQmtEcFVPbVFESUhaU3lQNXdBWkRJS2pvNktsSUFBQUFBQWdBQUFHUURJQUs4QUFvQUZRQUl0UThMQmdBQ0xTc0JGU0lHRlRNSEp6TTBOZ1VYSXhRR0l6VXlOalVqQVpCVGRXU1dsbVN3QVhhV1pMQjhVM1ZrQXJ4a2RWUEl5SHl3Wk1oOHNHUjFVd0FDQUFBQUFBTWdBeUFBQ2dBVkFBaTFFZ3NFQUFJdEt4TWhFVE1ISnpNMUlSVWpId0VqRlNFMU14VWhFU05rQWxoa2xwWmsvbkJrTXBaa0FaQmsvYWhrQXlEKzFQcjZ5R1F5K3Noa3lBRXNBQUlBQUFBQUF5QUN2QUFMQUJjQUNMVVdEQUlBQWkwckFSY0hOU0VWSXpVME5qTWhBUlVoTlRNVkZBWWpJUlVuQWxqSXlQNE1aRHNwQWZUK2NBSDBaRHNwL2d6SUFyeVdsbVJrWkNrNy90UmtaR1FwTzJTV0FBQUNBQUQvL2dNaUF5QUFHUUFqQUFpMUh4b05BQUl0S3hJZ0ZoVVVCeFlmQVI0QkZSUUdJeUltTHdFbUp3WWpJaVlRQVRJMk5UUW1JZ1lVRnMwQklzMHNDZ1prREJJOEtoRXJER1FGQjAxWmtjMEJYbXFRa3RDU2tnTWd6WkZXVUFZR1pBd3JFU284RWd4a0JBa3B6UUVpL25XUWFtaVNrdENTQUFBQUFnQUFBQUFDV0FNZ0FCQUFHQUFJdFJVUkNRQUNMU3NTTWhZVkZBNENEd0V1QkRVMEpDSUdGQll5TmpTdytMQStXRmdmSHd3cFowOUJBWDZrZG5ha2RnTWdzSHc0a0g1dUlDQU1LMzExa3poOFRIYWtkbmFrQUFRQUFBQUFBeUVESUFBSUFCY0FKZ0F1QUExQUNpc25IeGdSRHdjQUJDMHJFU0VSRmhVVUJ4VWhKVFEyT3dJUklSRWhOU3NCSWlZQ01oWVZGQVlQQVM0RU5UUVdJZ1lVRmpJMk5BTWdBUUg4NEFIdkhSVUZsdjJvQWxpV0JSVWR6M3hZU3lVbUJoUTBLQ0NyS2gwZEtoMERJUDNqQXdnSEErNzZGQjRCa1Ayb1pCMEJjMWcrTEgwcEtBWVdQanBLSEQ0TUhTb2RIU29BQWdBQUFHUUNXQUs4QUFNQUJ3QUl0UVlFQWdBQ0xTc1JNeEVqQVRNUkk4aklBWkRJeUFLOC9hZ0NXUDJvQUFBQUFRQUFBR1FDV0FLOEFBSUFCck1DQUFFdEt4RUpBUUpZL2FnQ3ZQN1UvdFFBQUFBQUFRQUFBR1FDV0FLOEFBY0FCck1FQUFFdEt4SXlGaFFHSWlZMHNQaXdzUGl3QXJ5dytMQ3crQUFBQUFBQ0FBQUFaQU1nQXJ3QUFnQUZBQWkxQlFRQkFBSXRLd0VSQVNFQkVRR1EvbkFCa0FHUUFyejlxQUVzQVN6OXFBQUNBQUFBWkFNZ0Fyd0FBZ0FGQUFpMUJBTUNBQUl0S3hFSkFTRVJBUUdRL25BQmtBR1FBcnorMVA3VUFsaisxQUFDQUFBQVpBSzhBcndBQXdBR0FBaTFCZ1VDQUFJdEt4RXpFU01UQVJISXlNZ0I5QUs4L2FnQkxBRXMvYWdBQUFBQ0FBQUFaQUs4QXJ3QUFnQUdBQWkxQkFNQ0FBSXRLeEVKQVNFUk14RUI5UDRNQWZUSUFyeisxUDdVQWxqOXFBQUJBQUFBWkFKWUFyd0FBd0FHc3dJQUFTMHJFU0VSSVFKWS9hZ0N2UDJvQUFFQUFBQUFBeUFESUFBTEFBYXpCZ0FCTFNzVElSVXpFU01WSVRVakVUUElBWkRJeVA1d3lNZ0RJTWorY01qSUFaQUFBQUFEQUFBQUF3TWdBcndBQXdBSEFBc0FDcmNLQ0FZRUFnQURMU3NSSVJVaEZTRVZJUlVoRlNFRElQemdBeUQ4NEFNZy9PQUN2R1RGWk1oa0FBQUNBQUQvbkFKWUFzQUFFQUE4QUFpMUx4VUpBUUl0S3dFMk16SVdIUUlVQmlJbVBRSTBOZ2M3QVRJMk16SVdIUUlVRmpJMlBRRTBOaklXSFFFVUJnY1ZNeklXRlNFME5qc0JOUzRCUFFJME5nRVdEZ2dwT3p0U095N1VCQU1CQmdJVkhYV21kUjBxSFk5ck1pazcvbkE3S1RKcmp4UUN2QVE3S1FUSUtUczdLY2dDSVRyQkFSMFZBVEpUZFhWVE1oVWRIUlV5YnFZU2Fqc3BLVHRxRXFadU1nSVBIUUFBQUFBQkFBQUJMQU1nQWZRQUF3QUdzd0lBQVMwckVTRVZJUU1nL09BQjlNZ0FBQUlBQVArY0F5QUN2QUFnQUNRQUNMVWlJUklBQWkwckV6c0RJVElXRlJFVUJpc0JGVE15RmhVaE5EWTdBVFVqSWlZMUVUVTBOaGNSSVJFaUJBTUVCUUs4RlIwZEZmcGtLVHY5cURzcFpQb1ZIUlJRQWxnQ3ZCMFYvZ3dWSFdRN0tTazdaQjBWQWZRQ0R4MWcvbkFCa0FBQkFBRC9zZ01LQXJ3QUR3QUdzd2tBQVMwckFRWVZGQll6TWpjT0FTTWlKalUwTmdFUUZ1cW1RVDhvMElLbTZwZ0N2RDlCcHVvV2VKanFwb0xRQUFBQUFRQUFBQUFDdkFLOEFCY0FCck1NQUFFdEt3RVhJeFV6TlJjSE5TTVZNd2NuTXpVakZTYzNGVE0xSXdGZWxtU1dscGFXWkphV1pKYVdscFprQXJ5V2xtU1dsbVNXbHBhV1pKYVdaSllBQUFBQkFBQUFBQU1nQXlBQUhRQUdzeEFBQVMwckFSRVVCaUltTkRZek1oYzFCQWNSRkFZaUpqUTJNeklYRVQ0RUF5QllmRmhZUGhjYi92V0ZXSHhZV0Q0WEd3UVVXSGprQXlEOTJqNVlXSHhZQ2M0SUt2NXpQbGhZZkZnSkFaa0VEaUlhRmdBQUFRQUEvNTBDdWdLOEFDd0FCck1uQUFFdEt3QXlGeFlVRHdFR0lpWTBQd0VYRHdFR0ZCWXlQd0UrQVNjdUFRY0JEZ0VYRmpJL0FoY0hCaUltTkRjQkFhR2tPem82K2lSblNDUmdSVm9IQnc0WUIvb2NBUjBkVlI3KzZqSUJNelNTTkFsMFJYMVE1S0JRQVJZQ3ZEczdwRHIwSkVobkpHRkZYZ01JRmhBSTl4NVJIaDBCSHY3dE5KQXpORFFNY1VWOVVLRGtVQUVRQUFBQ0FBQUFBQU1nQXlBQUF3QUlBQWkxQmdRQ0FBSXRLd0VYQnljSEZ3RWpOUUpZeUdUSVpNaitjTWdESU1oa3lHVEkvbkRJQUFBQUFBUUFBQUFBQXlBRElBQU1BQlFBSGdBcUFBMUFDaVlmR1JVUkRRUUFCQzByQVRJV0ZBWWpJaWMyTlRRbk5nUXlGaFFHSWlZMEJSNEJIUUVqTlRRbk5nVVdNamNlQVIwQklUVTBOZ0ltUGxoWVBob2hDVWd1L3VKOFdGaDhXQUp4SWluSUxHWDl1a2ZRUnlJcC9nd3BBeUIxcG5VVEp5cCtWbGhrZGFaMWRhYkhFVDhtcGtKSVBnTVRWRlFSUHlhbXBpWS9BQUFDQUFBQUFBTWdBeUFBQndBVEFBaTFEd2dFQUFJdEt3QXlGaFFHSWlZMEF4WXlOeDRCSFFFaE5UUTJBVDJtZFhXbWRRbFo4RmxRYi96Z2J3TWdrODZUazg3K24yUmtCSE5SWkdSUmN3QUFBQU1BQUFBQUFmUURJQUFMQUE4QUZ3QUt0eFFRRFF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjUklSRUNJZ1lVRmpJMk5CTUJ6aE1UL2pJVFpBRXNnU29kSFNvZEF5QVQvUVlURXdMNkUyVCtEQUgwL2RvZEtoMGRLZ0FBQXdBQUFBQURJQU1nQUFVQUR3QVdBQXEzRWhBTEJnTUFBeTByQVRJWEVRRTJCUjRCRlJRR0l5SW5BU1VYQnk0Qk5UUUJYaG9ZL3RkbEFTaUFyTTJSZTJNQkVQNW43ZFEyUGdNZ0EvNXpBU2xuYWhQQ2c1SE5VUUVRMGVyVUtucEdmQUFBQUFFQUFQK2NBcndDdkFBakFBYXpGUUlCTFNzVE5EWTdBeUV5RmhRR0t3RVZNeklXRlNFUkJ5Y1JJVFEyT3dFMUl5SUdJeUltWEJzVEF3UUZBWkFWSFIwVk1tUXBPLzdVT0N6KzFEc3BaRElCQmdFVkhRS0tFaUFkS2gzSU95bisxR1JrQVN3cE84Z0JIZ0FBQUFJQUFBQUFBeUFESUFBSEFBb0FDTFVKQ0FRQUFpMHJFaUFXRUFZZ0poQWxFU1hxQVV6cTZ2NjA2Z0VzQVN3RElPcit0T3JxQVV3aS9uRElBQUVBQUFBQUF5QURJQUFMQUFhekJnQUJMU3NCTXhFaEZTRVJJeEVoTlNFQkxNZ0JMUDdVeVA3VUFTd0RJUDdVeVA3VUFTeklBQUFBQWdBQUFBQUN2QU1nQUFNQUhnQUl0UmdFQWdBQ0xTc0JNeEVqQXhjSEJoVVVGakkyTlRRbUx3RTNGeDRCRlJRR0lDWTFORFkzQVN4a1pJQStLRjZTMEpJMExTVStKajVJemY3ZXpVZytBeUQrY0FFQVRoOUxlbWlTa21nN1p5TWZUaDh4a0ZLUnpjMlJVcEF4QUFBQUFBTUFBQUFBQXlBRElBQURBQk1BRndBS3R4WVVDUVFDQUFNdEt4TWhGU0VISVRJVkVSUXJBVFVoRlNNaU5SRTBGeUVSSWNnQmtQNXd2d01PQ1FsYi9haGJDY2dCa1A1d0F5RElaQW4rNWduSXlBa0JHZ25JL3RRQUFBQUFCUUFBQUFBRElBSzhBQU1BQndBTEFBOEFFd0FQUUF3U0VBNE1DZ2dHQkFJQUJTMHJFVE1SSXdFekVTTUJNeFVqRnpNVkl4Y3pGU05rWkFLOFpHVCtETWpJWk1qSVpNaklBcno5UkFLOC9VUUNXR1JrWkdSa0FBRUFBUC9oQXlBQ3ZBQWJBQWF6RWdBQkxTc0JGaE0rQVRjV0Z6TVZJeWNHQnlZREJnSUhKaWNqTlRNZkFUWVNBVVVhYVE4NkR4UkRxZWNOU2lZV1lSVlRGUnc0ZEx3SkF3OVdBcnhYL3JRbGxDVW1obVFjdUZ0SkFUaEQvdlpEV0s1a0lnWXhBUnNBQVFBQS81d0RJQUs4QURrQUJyTWZBZ0V0S3hNME5qSVdGUlFPQVFjR0ZUTVZNamMrQWpNeUZoUUdJeUl1QVNjbUl4VWpORGMrQWpVMEppSUdGUlFlQVJjV0ZTTVJNelFuTGdMSU9WWTVDUkFEQStjV0JnY2RGdzByT1RrckRSY2RCd1lXNXdNREVBazVWamtKRUFNRDUrY0RBeEFKQWxnck9Ua3JEUmNkQndZVzV3TURFQWs1VmprSkVBTUQ1eFlHQngwWERTczVPU3NORngwSEJoWUNXQllHQngwWEFBQUFBZ0FBLzV3QjhRSzhBQ3NBTHdBSXRTNHNEd0FDTFNzVE1oY1dGUlFPQVFjT0JCMEJJelUwUGdFM1BnZzFOQ2NtSXlJSEJnY25OamMyRXpNVkkvZCtRVHNyS2lJWEN4NElDV1FvS2lFQ0d3UVZCQThEQndJY0psUlBKUmdIWkFveFFraGtaQUs4T3paWE5sOHVIaFFMSVJZb0dCa1pObDR3SFFJWEJSUUlFdzRXRnc0cEdTSWxHQzBNVHpGQy9VUmtBQUFBQUFRQUFBQUFBeUFESUFBZkFETUFSd0JiQUExQUNsUk1RRGdzSkFvQUJDMHJBVElXSFFFZUFSVVVCZ2N1QVNNaUJ5NEJJZ1lISmlNaUJ5WTFORFl6UGdFRE93RXlOak15RmgwQ0ZBWWlKajBDTkRZSE93RXlOak15RmgwQ0ZBWWlKajBDTkRZbE93RXlOak15RmgwQ0ZBWWlKajBDTkRZQndtaVNLemsvTVJGTExoc2REVkJtVUEwZEd6a29OWFpTRVk4YUJBTUJCZ0lWSFIwcUhSUzZCQU1CQmdJVkhSMHFIUlFCbmdNRUFRWUNGUjBkS2gwVUF5Q1NhRElRVlRFelVBMHFOQXd4UHo4eERDSTZURkoyVm5MK0RBRWRGUUhJRlIwZEZjZ0NEeDFnQVIwVkFXUVZIUjBWWkFJUEhRUUJIUlVCWkJVZEhSVmtBZzhkQUFFQUFBQUFBeUFESUFBakFBYXpDd0FCTFNzQkZ3YzFJd2NmQVRNMUZ3YzFJeUl2QVFjR0t3RTFNemN2QVNNMU16SWZBVGMyT3dFQ1dNaklNcG12QmhiSXlCa3VJS2FaSHk5a1pLYWpBMlJrTGlDWmpSOHZNZ01nbHBaa3Y4NERaSmFXWkNhK3ZpWmt6cjhEWkNheXNpWUFBQUFBQVFBQUFBQURJQU1nQUJVQUJyTVFBQUV0S3dFeUZ6Y1JJVGNtSXlJR0ZCWXlOeGNHSXlJbUVEWUJrS0ozZC83VWJWbDRmTEN3K0ZoSWRLaWw2K3NESUhkMy90UnRXN0Q0c0ZoSWRPc0JTdXNBQUFBQUFRQUFBQUFESUFNZ0FBa0FCck1GQUFFdEt3RWhFU2NCRnlFUkZ3RUJrQUdRcHY1d3B2NXdwZ0dRQXlEK2NLYitjS1lCa0tZQmtBQUJBQUFBQUFIMEF5QUFDUUFHc3dVQUFTMHJHd0VqRlRNTEFUTTFJL3I2eU1qNitzaklBeUQrMU1qKzFBRXN5QUFCQUFBQVpBTWdBbGdBQ1FBR3N3VUFBUzByQVJVek5RMEJOU01WSlFFc3lBRXMvdFRJL3RRQ1dNakkrdnJJeVBvQUFBQUFBd0FBQUFBRElBTWdBQW9BRWdBWEFBcTNGaE1PQ3dVQUF5MHJFVElFRmhJVkl6UUNKQ01WTWdBVkl6UW1JeFV5RmhVam9nRXAxbi9Jb1A3c3BNNEJKc2l2ZlZKMnlBTWdmOWIrMTZLa0FSU2daUDdhem4ydlpIWlNBQUFFQUFBQUFBTWdBeUFBQ2dBVEFCc0FJd0FOUUFvZ0hCY1VEd3NFQUFRdEt4TXlCQklWSXpRdUFpTVZNaDRCRlNNMEppTVZNaFlWSXpRbUl3WXlGaFFHSWlZMFpMNEJRcnhrWDZEZmVvam1obVRxcG55d1pIVlRLVkk3TzFJN0F5QzgvcjYrZXQrZ1gyU0c1b2ltNm1Td2ZGTjFaRHRTT3p0U0FBQUFBUUFBQUFBRElBTWdBQ0VBQnJNUkFBRXRLd0VoTWhZZEFTRTFOQ1lpQmgwQklSRVVCaU1oSWlZOUFUTVZGQll5TmpVUk5EWUJMQUdRS1R2K2NCMHFIUUdRT3luK0RDazdaQjBxSFRzRElEc3B5SllWSFIwVit2N1VLVHM3S2NpV0ZSMGRGUUltS1RzQUFBQUFBZ0FBQUFBRElBSzhBQklBSFFBSXRSb1RDZ0FDTFNzVE14VWpFU0UxTXhVVUJpTWhJaVkxRVRRMklSY0hOU01pQmdjK0FUTkw0Y2dCa0dRc0gvNCtIeXdzQWl6SXlNaEdiQkFSNEprQ3ZHVCtER1I5SHl3c0h3SW1IeXpJeUdSV1E1YkxBQUVBQUFBQUF5QUN2QUFNQUFhekJ3QUJMU3NKQWpVaklnWUhORDRDTXdIMEFTeisxR1NZMGlZdGJjaVNBcnorNVA3RXlKcVNkcXlMUndBQUFBSUFBQUFBQXlBRElBQVVBQndBQ0xVV0ZRc0JBaTByQVRjWEZnUVhGUlFIQmdjR0lpY21KeVk5QVRZa0V4RUZGaGNXRnhZQmZSTVRKUUVPU3BNOVFFaHdTRUE5azBvQkRqaisyZ3h1T0RJckF4Y0pDUTl6SGgvZ3cxRXZOVFV2VWNYZUh4NXovVndDVDNxMWswb2tId0FFQUFBQUFBSzhBeUFBQXdBSEFBc0FEd0FOUUFvT0RBb0lCZ1FDQUFRdEt3RXpFU01ETXhFakF6TVJJd016RVNNQ1dHUmt5R1JreUdSa3lHUmtBeUQ4NEFLOC9VUUI5UDRNQVN6KzFBQUFBQUVBQUFBQUFyd0RJQUFOQUFhekJ3QUJMU3NCTXhVekZ3Y2pFU01SSXljM013RXNaTWhrWk1oa3lHUmt5QU1neUdSay9uQUI5R1JrQUFBQUFBUUFBQUFBQXlBRElBQUdBQW9BRGdBU0FBMUFDaEVQRFFzSkJ3UUFCQzByRXpNUk13Y25NeE16RlNNVklSVWhGU0VWSWNoa3lQcjZ5TWpJeUFFcy90UUJrUDV3QXlEOXFNaklBbGhrWkdSa1pBQUFBQVFBQUFBQUF5QURJQUFHQUFvQURnQVNBQTFBQ2hFUERRc0pCd1FBQkMwckV6TVJNd2NuTXhNaEZTRVZJUlVoRlRNVkk4aGt5UHI2eU1nQmtQNXdBU3orMU1qSUF5RDlxTWpJQWxoa1pHUmtaQUFBQUFjQUFBQUFBeUFDdkFBUEFCTUFGd0FiQUI4QUl3QW5BQk5BRUNVa0lTQWRIQmtZRlJRUkVBY0FCeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNWTXpVekZTRTFCUlV6TlRNVklUVUZGVE0xTXhVaE5Vc0NpaDhzTEIvOWRoOHNMRGhrWkFHUS9haGtaQUdRL2Foa1pBR1FBcndzSC8zYUh5d3NId0ltSHl4a1pHUmtaTWhrWkdSa3lHUmtaR1FBQUFFQUFBQUFBeUFESUFBSkFBYXpCQUFCTFNzQkV5RUhFeWNIRXljaEFaQmtBU3o2WlByNlpQb0JMQU1nL3RUSS90VEl5QUVzeUFBQUNRQUFBQUFESUFNZ0FBY0FEd0FYQUI4QUp3QXZBRGNBUHdCSEFCZEFGRVJBUERnME1Dd29KQ0FjR0JRUURBZ0VBQWt0S3dBeUZoUUdJaVkwQmpJV0ZBWWlKalFrTWhZVUJpSW1OQVF5RmhRR0lpWTBCaklXRkFZaUpqUWtNaFlVQmlJbU5BUXlGaFFHSWlZMEpESVdGQVlpSmpRR01oWVVCaUltTkFGN0toMGRLaDNkS2gwZEtoMENFU29kSFNvZC91YWtkbmFrZHFzcUhSMHFIUUxaS2gwZEtoMzl4U29kSFNvZEFoRXFIUjBxSGQwcUhSMHFIUU1nSFNvZEhTcEhIU29kSFNvZEhTb2RIU3BIZHFSMmRxUWdIU29kSFNvZEhTb2RIU3JkSFNvZEhTb2RIU29kSFNwSEhTb2RIU29BQXdBQUFBQUN2QU1nQUE4QUV3QVpBQXEzRnhRUkVBY0FBeTByRXlFeUZoVVJGQVlqSVNJbU5SRTBOaGNSSVJFQ0lnWVdNallpQW5nT0ZCUU8vWWdPRkJSUUFmVGRPaDBjUEJ3RElCUU8vU1FPRkJRT0F0d09GR1QrREFIMC9kb3lNaklBQUFJQUFBQUFBeUFESUFBRUFBd0FDTFVKQlFNQUFpMHJFU0VKQWpZaUJoUVdNalkwQVN3QjlQN1UvZ3p4VWpzN1Vqc0RJUDRNL3RRQjlNZzdVanM3VWdBREFBQUFaQU1nQWxnQUJBQUtBQklBQ3JjUEN3Z0ZBd0FETFNzUk13RUhBU1V6QVFjbk55UWlCaFFXTWpZMHlBRXN5UDdVQVZTZ0FTeklUbmYrS2lvZEhTb2RBbGorMU1nQkxNaisxTWhPZXNnZEtoMGRLZ0FBQkFBQUFBQURJQU1nQUFjQUR3QVhBQjhBRFVBS0hCZ1VFQXdJQkFBRUxTc1NJQllRQmlBbUVDUWlCaFFXTWpZMEpESVdGQVlpSmpRMklnWVVGakkyTk9zQlN1dnIvcmJyQWd6NHNMRDRzUDZDcEhaMnBIYnlWRG82VkRvRElPdit0dXZyQVVxSHNQaXdzUGhNZHFSMmRxUVNPbFE2T2xRQUFnQUFBQUFESUFLOEFBa0FEd0FJdFF3S0NBQUNMU3NSSVFjaEVTRTFOeEVoQVJjQkp6Y1hBaTlrL3BrQjlHVDlSQUs4WlA1d3lHUmtBcnhrL2d5ZlpQNlpBcnhrL25ESVpHUUFBQU1BQUFBQUF5QURJQUFMQUJFQUZRQUt0eE1TRUF3RkFBTXRLeE1oTWhVUkZDTWhJalVSTkJjSEZ3Y1hOeGNWSVRVSkF3NEpDZnp5Q1paSVpHUklyRTRCTEFNZ0NmenlDUWtERGdsT1NHUmtTS3d5WkdRQUFBQUJBQUFBQUFNZ0F5QUFHUUFHc3cwQUFTMHJFU0VWSXpRbUt3RVJGQlk3QVJVaE5UTXlOalVSSXlJR0ZTTURJREk3S1pZZEZUTCtjRElWSFpZcE96SURJTWdwTy8zYUZSMWtaQjBWQWlZN0tRQUFBQUFDQUFBQUF3SzhBcndBQXdBZEFBaTFGUVFDQUFJdEt4RXpFU01USVRJWEVoVVVCaXNCSWdZVkZCY1dEZ0VtSnk0Q0p5WWpaR1RJQVY0aERtY2RGWllVSGk4R0VpWWtDd0krT0FnY0xBSzgvbkFCa0IvKzNSd1ZIUjhUSDVrVUpRd1JGQU43YUFnY0FBSUFBQUFBQXJ3Q3ZBQWNBQ0FBQ0xVZkhSUUNBaTByQVRZM0Z4NEJCd1lWRkJZN0FUSVdGUlFHRHdFR0l5RVJNamMrQWdFekVTTUJrQkFmRXhNU0JpOGVGSllWSFRRYUdRNGgvcUlzSEFnNFB2NXlaR1FDbWg4REF3WWxGSmtmRXg4ZEZReWdTa2tmQVpBY0NHaDcvdm4rY0FBQUFnQUEvNXdDdkFLOEFCOEFLZ0FJdFNNZ0Z3QUNMU3NUSVJVakZSWVhCeVlqSWdZVUZqSTJOVFFuTnhZVkZBWWdKalUwTmpjMUl3VUFCd1lpSmpRM1BnRTN5QUVzWkRJV0lpa3ZhSktTMEpJUVd4bk4vdDdOcklCa0FmVCsyQlFQSmg0UENjQmJBcnhrQmdnSVhoQ1MwSktTYUM4cEpVUTVrYzNOa1lQR0VnTVEvcVFVRHg0bUR3bVdSd0FDQUFBQUFBTWdBcndBQmdBTkFBaTFEQWNDQUFJdEt3RVhCelVoTlNFQkZTRVZJUlVuQWxqSXlQMm9BbGorY0FKWS9haklBcnlXbG1Say90UmtaR1NXQUFBQUFBSUFBQUFBQXJ3RElBQVBBQ2NBQ0xVakVBZ0FBaTByQVRNeUZoVXpNaFlWSVRRMk93RTBOZ016RVJRV01qWTFFVE1SRkJZeU5qVVJNeEVVSXlFaU5RRXNaQ2s3WkNrNy9VUTdLV1E3bjJRZEtoMWtIU29kWkJQK01oTURJRHNwT3lrcE95azcvdFQrb2hVZEhSVUJYdjZpRlIwZEZRRmUvaDhURXdBQ0FBQUFBQUs4QXlBQUVRQVZBQWkxRkJJTUFBSXRLeE16RVJRV01qWTFFVE1SRkFZckFTSW1OUU1oRlNGa3lEdFNPMlIyVWpKbmsyUUN2UDFFQXlEK2NDazdPeWtCa1A1d1VuWjFVLzdVWkFBQUFBQUVBQUFBQUFNZ0Fyd0FDd0FYQUNNQUp3QU5RQW9tSkIwWUVRd0ZBQVF0S3hNek1oVVJGQ3NCSWpVUk5DRXpNaFVSRkNzQklqVVJOQVV6TWhVUkZDc0JJalVSTkFFaEZTRUp0Z2tKdGdrQ1liWUpDYllKL3QyMkNRbTJDZjdVQXlEODRBSzhDZjRlQ1FrQjRna0ovaDRKQ1FIaUNjZ0ovdVlKQ1FFYUNmNXdaQUFBQUFBSEFBQUFBQU1nQXJ3QUJ3QVBBQmNBR3dBakFDc0FNd0FUUUJBdkxDY2tIeHdhR0JRUURBZ0VBQWN0S3hNek1oMEJJelUwSVRNeUhRRWpOVFFGTXpJZEFTTTFOQVVoRlNFVk14VVVLd0VpTlNVekZSUXJBU0kxSlRNVkZDc0JJalVLdFFuSUFtSzFDY2orM3JVSnlQN1VBeUQ4NE1nSnRna0JMTWdKdFFvQkxNZ0p0UW9DdkFtL3Z3a0p2NzhKWkFsYld3bklaR1MvQ1FtL1d3a0pXNzhKQ1FBQUFBUUFBQUFBQXlBQ3ZBQURBQThBR3dBbkFBMUFDaUVjRlJBSkJBSUFCQzByRVNFVklSY3pNaFVSRkNzQklqVVJOQ0V6TWhVUkZDc0JJalVSTkNFek1oVVJGQ3NCSWpVUk5BTWcvT0FKdGdrSnRna0JOYllKQ2JZSkFUVzJDUW0yQ1FLOFpHUUovaDRKQ1FIaUNRbis1Z2tKQVJvSkNmNGVDUWtCNGdrQUFBQUFBUUFBQUdRRElBSllBQlVBQnJNTkFBRXRLeE1oTWhZZEFUY3pFU01uRlJRR0l5RWlKalVSTkRZeUFmUVZIV1JrWkdRZEZmNE1GUjBkQWxnZEZaWmsvdFJrbGhVZEhSVUJrQlVkQUFNQUFBQUFBeUFESUFBSEFCd0FKQUFLdHlRZEVna0NBQU10S3dFekVTTW5JeEV6SVRVeUZ4NEJGQVlISXdZak5USTNQZ0UwSmljbUJ4Y2VBUlFHRHdFQlRrSkNoc2pJQVN3bEptSi9mMklESWlZYUdFRlZWVUVZR2hraEtpc2dHUU1nL09ESUFaQmtDaG1oMEtJWkNXUUdFV3VNYXhFR1pBTUlOMFEzQ0FNQUFnQUFBQUFDV0FNZ0FBY0FEd0FJdFE4SUFnQUNMU3NCTXhFakp5TVJNd1VYSGdFVUJnOEJBVTVDUW9iSXlBRXNHU0VxS3lBWkF5RDg0TWdCa0dRRENEZEVOd2dEQUFBQUFRQUFBQUFCa0FNZ0FBY0FCck1DQUFFdEt3RXpFU01uSXhFekFVNUNRb2JJeUFNZy9PRElBWkFBQUFBREFBQUFBQUs4QXlBQUR3QVRBQmNBQ3JjVkZCRVFCd0FETFNzQk16SVhBUmNWRkNNaElqMEJOd0UyQXhVek5RTVZNelVCTlZJSUJBRW1Bd245VmdrREFTWUVBV1JrWkFNZ0NmMVdFMUVKQ1ZFVEFxb0ovdFRJeVA3VVpHUUFBQUFEQUFBQUFBTHhBeUFBQ1FBU0FCb0FDcmNYRXcwS0F3QURMU3NCTWhjSEppTWlCeWMyRWpJWEJ5WWpJZ2NuRmpJV0ZBWWlKalFCZDlDcU5ZMjRzNDgxcWxqcVl6VklXMVZLTnF4U096dFNPd01nYlZKYlcxSnQvdFErVlM4dlZlNDdVanM3VWdBQUFBSUFBQUFBQXlFRElBQVpBQ0VBQ0xVZUdnOEFBaTByQVRJWEJ4VXpOeFlWRkFZaklpY0JCaUluSmpRM0FTWTFORFlBSWdZVUZqSTJOQUluSUE5aHlHRURrMmNxTVA3Z0hGZ2NIUjBCSXhPVC9yb3FIUjBxSFFNZ0EySElZUThnYUpJVC90MGNIQjFXSFFFZk1DdG9rdjEySFNvZEhTb0FBQUVBQVArc0F4QUN2QUFYQUFhekRRQUJMU3NURmhjK0FqY1hCeDRDRndjdUFpY0hKelkzSmllTkFmd2JabElrai8wY1psVW1qeVJUWlJ2OWpUUEgrUUVDdkFINUhHVlRKbzM5RzJWVEpJOG1WV1ljL1k4d3gvd0JBQUFBQVFBQUFBQUN2QU1nQUJjQUJyTU9BQUV0S3hFekV6TVRNd016RlNFVklSVWhGU00xSVRVaE5TRTFNMlRuSnVkazRlSCsxQUVzL3RSay90UUJMUDdVNFFNZy90UUJMUDdVWkdSa3lNaGtaR1FBQUFBQUF3QUEvLzRESWdNZ0FCa0FKd0F6QUFxM0xpZ2VHZzBBQXkwckVpQVdGUlFIRmg4QkhnRVZGQVlqSWlZdkFTWW5CaU1pSmhBa0lnWVVGak15TnpZL0FUWTFOQ1V6RlRNVkl4VWpOU00xTTgwQklzMHNDQVZuREJJOEtoRXJER1FGQkU5YWtjMEJ4dENTa21oY1J3NFJBelgrMUdSa1pHUmtaQU1nelpGWVVRUUZaQXdyRVNvOEVneG5CUWdzelFFaWFaTFFrandYQ0FORFdXZ3VaR1JrWkdRQUFBQURBQUQvL2dNaUF5QUFHUUFuQUNzQUNyY3FLQjRhRFFBRExTc1NJQllWRkFjV0h3RWVBUlVVQmlNaUppOEJKaWNHSXlJbUVDUWlCaFFXTXpJM05qOEJOalUwQlNFVkljMEJJczBzQ0FWbkRCSThLaEVyREdRRkJFOWFrYzBCeHRDU2ttaGNSdzRSQXpYK2NBRXMvdFFESU0yUldGRUVCV1FNS3hFcVBCSU1ad1VJTE0wQkltbVMwSkk4RndnRFExbG9ObVFBQVFBQUFBRVptU3NLMXpWZkR6ejFBQXNESUFBQUFBRFAyUzlxQUFBQUFNL1pMMm9BQVArYkF5SURJQUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUCtiQUVnRGhBQUFBQUFESWdBQkFBQUFBQUFBQUFBQUFBQUFBQUFBNFFFZ0FCb0FBQUFBQVFvQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBSllBQUFDV0FBQUF5QUFBQU1nQUFBQmtBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBbGdBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFCa0FBQUFaQUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQWxnQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUFsZ0FBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU9FQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUJrQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFKWUFBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQTRRQUFBSllBQUFEaEFBQUFsZ0FBQUpZQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSllBQUFESUFBQUF5QUFBQUpZQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBSzhBQUFESUFBQUF5QUFBQU1nQUFBQ1dBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBZlFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFDV0FBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQURJQUFBQXlBQUFBTWdBQUFESUFBQUF5QUFBQU1nQUFBRElBQUFBeUFBQUFNZ0FBQUNXQUFBQVpBQUFBTWdBQUFESUFBQUE0UUFBQU1nQUFBRElBQUFBNFFBQUFBQUFBQUFBQUFXQUJZQUZnQTRBRm9BZUFDWUFNQUE1Z0VPQVV3QllnR0lBYTRCMGdIMkFnd0NJZ0k0QWs0Q1pBSjZBbzRDdGdNQUF5SURWQU4yQThnRDdnUU1CRllFZmdTcUJPZ0UvQVVzQlQ0RlhnV2NCZFlHSUFaWUJ1SUhGZ2RZQjVRSDVBZjBDQVlJR0FncUNIZ0lsZ2kyQ013STRnajRDUTRKTWdsZUNab0p6QW9RQ2tZS2FncWdDc1lMREFzcUMwZ0xhQXVHQy9vTUVneE1ERzRNb0F6VURRWU5ZQTJBRFp3TnhBM3lEaVFPZGc2U0Rxd08xZzcrRHpZUFRnOW1ENFFQb0EvS0VBWVFPQkJXRUhZUWxCQ3lFTllSS0JGc0VZZ1J6QkhxRWdZU0tCSndFcElTdGhNK0UyQVQwaFFhRkVZVWdCVElGUUFWSGhVNEZWb1ZnQlhJRmdRV0poWk1GbklXbUJiSUZ2d1hJaGVZR0JZWW1CalFHU2daUEJsZ0dZSVpxaG5TR2Y0YVBCcG9HclFhekJyZUd2UWJEQnNrR3p3YlZCdGtHMzRibkJ2d0hBQWNPQnhZSElBY3NoeitIUm9kWkIyTUhib2Q3QjRpSGtBZVhCNlVIc0llN2g4aUgzWWZ3Q0ErSUhnZ29pQytJTllnOENFZUlWd2hraUhFSWVJaUdpSkNJbUFpaWlLMEl2d2pHQ09RSThJajRpUU9KRW9rY0NTY0pNWWsraVUwSlhvbG5DWGFKZ1FtUmlhWUp0Z20vaWMrSjJJbmVDZW9KOXdvR0NoR0tIQW93aWtNQUFBQUFRQUFBT0lBYUFBUUFBQUFBQUFDQUFBQUFBQnpBQUFBTmd0c0FBQUFBQUFBQUE0QXJnQUJBQUFBQUFBQUFFSUFoZ0FCQUFBQUFBQUJBQVVBMVFBQkFBQUFBQUFDQUFZQTZRQUJBQUFBQUFBREFDUUJPZ0FCQUFBQUFBQUVBQWtCY3dBQkFBQUFBQUFGQUE0Qm13QUJBQUFBQUFBR0FBc0J3Z0FEQUFFRUNRQUFBSVFBQUFBREFBRUVDUUFCQUFvQXlRQURBQUVFQ1FBQ0FBd0Eyd0FEQUFFRUNRQURBRWdBOEFBREFBRUVDUUFFQUJJQlh3QURBQUVFQ1FBRkFCd0JmUUFEQUFFRUNRQUdBQllCcWdCREFISUFaUUJoQUhRQVpRQmtBQ0FBWWdCNUFDQUFVQUF1QUVvQUxnQWdBRThBYmdCdkFISUFhUUFnQUhjQWFRQjBBR2dBSUFCR0FHOEFiZ0IwQUVZQWJ3QnlBR2NBWlFBZ0FESUFMZ0F3QUNBQUtBQm9BSFFBZEFCd0FEb0FMd0F2QUdZQWJ3QnVBSFFBWmdCdkFISUFad0JsQUM0QWN3Qm1BQzRBYmdCbEFIUUFLUUFBUTNKbFlYUmxaQ0JpZVNCUUxrb3VJRTl1YjNKcElIZHBkR2dnUm05dWRFWnZjbWRsSURJdU1DQW9hSFIwY0RvdkwyWnZiblJtYjNKblpTNXpaaTV1WlhRcEFBQkpBR01BYndCdUFITUFBRWxqYjI1ekFBQnBBR01BYndCdUFHa0FZd0FBYVdOdmJtbGpBQUJHQUc4QWJnQjBBRVlBYndCeUFHY0FaUUFnQURJQUxnQXdBQ0FBT2dBZ0FGVUFiZ0IwQUdrQWRBQnNBR1VBWkFBeEFDQUFPZ0FnQURFQUxRQTNBQzBBTWdBd0FERUFOQUFBUm05dWRFWnZjbWRsSURJdU1DQTZJRlZ1ZEdsMGJHVmtNU0E2SURFdE55MHlNREUwQUFCVkFHNEFkQUJwQUhRQWJBQmxBR1FBTVFBQVZXNTBhWFJzWldReEFBQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREVBTGdBeEFDQUFBRlpsY25OcGIyNGdNUzR4TGpFZ0FBQnZBSEFBWlFCdUFDMEFhUUJqQUc4QWJnQnBBR01BQUc5d1pXNHRhV052Ym1sakFBQUNBQUFBQUFBQS80TUFNZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9JQUFBQUJBQUlCQWdFREFRUUJCUUVHQVFjQkNBRUpBUW9CQ3dCRUFFVUFSZ0JIQUVnQVNRRU1BUTBCRGdFUEFSQUJFUUVTQVJNQkZBRVZBUllCRndFWUFSa0JHZ0ViQVJ3QkhRRWVBUjhCSUFFaEFTSUJJd0VrQVNVQkpnRW5BU2dCS1FFcUFTc0JMQUV0QVM0Qkx3RXdBVEVCTWdFekFUUUJOUUUyQVRjQk9BRTVBVG9CT3dFOEFUMEJQZ0UvQVVBQlFRRkNBVU1CUkFGRkFVWUJSd0ZJQVVrQlNnRkxBVXdCVFFGT0FVOEJVQUZSQVZJQlV3RlVBVlVCVmdGWEFWZ0JXUUZhQVZzQlhBRmRBVjRCWHdGZ0FXRUJZZ0ZqQVdRQlpRRm1BV2NCYUFGcEFXb0Jhd0ZzQVcwQmJnRnZBWEFCY1FGeUFYTUJkQUYxQVhZQmR3RjRBWGtCZWdGN0FYd0JmUUYrQVg4QmdBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0FvQUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0FjTUJ4QUhGQWNZQnh3SElBY2tCeWdITEFjd0J6UUhPQWM4QjBBSFJBZElCMHdIVUFkVUIxZ0hYQWRnQjJRQUJNUUV5QVRNQk5BRTFBVFlCTndFNEFUa0NNVEFDTVRFQ01USUNNVE1DTVRRQ01UVUNNVFlDTVRjQ01UZ0NNVGtDTVdFQ01XSUNNV01DTVdRQ01XVUNNV1lDTWpBQ01qRUNNaklDTWpNQ01qUUNNalVDTWpZQ01qY0NNamdDTWprQ01tRUNNbUlDTW1NQ01tUUNNbVVDTW1ZQ016QUNNekVDTXpJQ016TUNNelFDTXpVQ016WUNNemNDTXpnQ016a0NNMkVDTTJJQ00yTUNNMlFDTTJVQ00yWUNOREFDTkRFQ05ESUNORE1DTkRRQ05EVUNORFlDTkRjQ05EZ0NORGtDTkdFQ05HSUNOR01DTkdRQ05HVUNOR1lDTlRBQ05URUNOVElDTlRNQ05UUUNOVFVDTlRZQ05UY0NOVGdDTlRrQ05XRUNOV0lDTldNQ05XUUNOV1VDTldZQ05qQUNOakVDTmpJQ05qTUNOalFDTmpVQ05qWUNOamNDTmpnQ05qa0NObUVDTm1JQ05tTUNObVFDTm1VQ05tWUNOekFDTnpFQ056SUNOek1DTnpRQ056VUNOellDTnpjQ056Z0NOemtDTjJFQ04ySUNOMk1DTjJRQ04yVUNOMllDT0RBQ09ERUNPRElDT0RNQ09EUUNPRFVDT0RZQ09EY0NPRGdDT0RrQ09HRUNPR0lDT0dNQ09HUUNPR1VDT0dZQ09UQUNPVEVDT1RJQ09UTUNPVFFDT1RVQ09UWUNPVGNDT1RnQ09Ua0NPV0VDT1dJQ09XTUNPV1FDT1dVQ09XWUNZVEFDWVRFQ1lUSUNZVE1DWVRRQ1lUVUNZVFlDWVRjQ1lUZ0NZVGtDWVdFQ1lXSUNZV01DWVdRQ1lXWUNZakFDWWpFQ1lqSUNZak1DWWpRQ1lqVUNZallDWWpjQ1lqZ0NZamtDWW1FQ1ltSUNZbU1DWW1RQ1ltVUNZbVlDWXpBQ1l6RUNZeklDWXpNQ1l6UUNZelVDWXpZQ1l6Y0NZemdDWXprQ1kyRUNZMklDWTJNQ1kyUUNZMlVDWTJZQ1pEQUNaREVDWkRJQ1pETUNaRFFDWkRVQ1pEWUNaRGNDWkRnQ1pEa0NaR0VDWkdJQ1pHTUNaR1FDWkdVQUFBRUFBZi8vQUE4QUFBQUFBQUFBQUFBQUFBQ3dBQ3dnc0FCVldFVlpJQ0JMdUFBT1VVdXdCbE5hV0xBMEc3QW9XV0JtSUlwVldMQUNKV0c1Q0FBSUFHTmpJMkliSVNHd0FGbXdBRU1qUkxJQUFRQkRZRUl0c0FFc3NDQmdaaTJ3QWl3Z1pDQ3d3RkN3QkNaYXNpZ0JDa05GWTBWU1cxZ2hJeUViaWxnZ3NGQlFXQ0d3UUZrYklMQTRVRmdoc0RoWldTQ3hBUXBEUldORllXU3dLRkJZSWJFQkNrTkZZMFVnc0RCUVdDR3dNRmtiSUxEQVVGZ2daaUNLaW1FZ3NBcFFXR0FiSUxBZ1VGZ2hzQXBnR3lDd05sQllJYkEyWUJ0Z1dWbFpHN0FCSzFsWkk3QUFVRmhsV1ZrdHNBTXNJRVVnc0FRbFlXUWdzQVZEVUZpd0JTTkNzQVlqUWhzaElWbXdBV0F0c0FRc0l5RWpJU0Jrc1FWaVFpQ3dCaU5Dc1FFS1EwVmpzQXBEc0FCZ1JiQURLaUVnc0FaRElJb2dpckFCSzdFd0JTV0tVVmhnVUJ0aFVsbFlJMWtoSUxCQVUxaXdBU3NiSWJCQVdTT3dBRkJZWlZrdHNBVXNzQWRESzdJQUFnQkRZRUl0c0FZc3NBY2pRaU1nc0FBalFtR3dBbUptc0FGanNBRmdzQVVxTGJBSExDQWdSU0N3QzBOanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ1JMQUJZQzJ3Q0N5eUJ3c0FRMFZDS2lHeUFBRUFRMkJDTGJBSkxMQUFReU5Fc2dBQkFFTmdRaTJ3Q2l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtJTEFnVUZnaHNBQWJzREJRV0xBZ0c3QkFXVmtqc0FCUVdHVlpzQU1sSTJGRVJMQUJZQzJ3Q3l3Z0lFVWdzQUVySTdBQVE3QUVKV0FnUllvallTQmtzQ1JRV0xBQUc3QkFXU093QUZCWVpWbXdBeVVqWVVSRXNBRmdMYkFNTENDd0FDTkNzZ3NLQTBWWUlSc2pJVmtxSVMyd0RTeXhBZ0pGc0dSaFJDMndEaXl3QVdBZ0lMQU1RMHF3QUZCWUlMQU1JMEpac0ExRFNyQUFVbGdnc0EwalFsa3RzQThzSUxBUVltYXdBV01ndUFRQVk0b2pZYkFPUTJBZ2ltQWdzQTRqUWlNdHNCQXNTMVJZc1FSa1JGa2tzQTFsSTNndHNCRXNTMUZZUzFOWXNRUmtSRmtiSVZra3NCTmxJM2d0c0JJc3NRQVBRMVZZc1E4UFE3QUJZVUt3RHl0WnNBQkRzQUlsUXJFTUFpVkNzUTBDSlVLd0FSWWpJTEFESlZCWXNRRUFRMkN3QkNWQ2lvb2dpaU5oc0E0cUlTT3dBV0VnaWlOaHNBNHFJUnV4QVFCRFlMQUNKVUt3QWlWaHNBNHFJVm13REVOSHNBMURSMkN3QW1JZ3NBQlFXTEJBWUZsbXNBRmpJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDeEFBQVRJMFN3QVVPd0FENnlBUUVCUTJCQ0xiQVRMQUN4QUFKRlZGaXdEeU5DSUVXd0N5TkNzQW9qc0FCZ1FpQmdzQUZodFJBUUFRQU9BRUpDaW1DeEVnWXJzSElyR3lKWkxiQVVMTEVBRXlzdHNCVXNzUUVUS3kyd0ZpeXhBaE1yTGJBWExMRURFeXN0c0Jnc3NRUVRLeTJ3R1N5eEJSTXJMYkFhTExFR0V5c3RzQnNzc1FjVEt5MndIQ3l4Q0JNckxiQWRMTEVKRXlzdHNCNHNBTEFOSzdFQUFrVlVXTEFQSTBJZ1JiQUxJMEt3Q2lPd0FHQkNJR0N3QVdHMUVCQUJBQTRBUWtLS1lMRVNCaXV3Y2lzYklsa3RzQjhzc1FBZUt5MndJQ3l4QVI0ckxiQWhMTEVDSGlzdHNDSXNzUU1lS3kyd0l5eXhCQjRyTGJBa0xMRUZIaXN0c0NVc3NRWWVLeTJ3Sml5eEJ4NHJMYkFuTExFSUhpc3RzQ2dzc1FrZUt5MndLU3dnUExBQllDMndLaXdnWUxBUVlDQkRJN0FCWUVPd0FpVmhzQUZnc0NrcUlTMndLeXl3S2l1d0tpb3RzQ3dzSUNCSElDQ3dDME5qdUFRQVlpQ3dBRkJZc0VCZ1dXYXdBV05nSTJFNEl5Q0tWVmdnUnlBZ3NBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZQ05oT0JzaFdTMndMU3dBc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0xpd0FzQTByc1FBQ1JWUllzQUVXc0N3cXNBRVZNQnNpV1Myd0x5d2dOYkFCWUMyd01Dd0FzQUZGWTdnRUFHSWdzQUJRV0xCQVlGbG1zQUZqc0FFcnNBdERZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpzQUVyc0FBV3RBQUFBQUFBUkQ0ak9MRXZBUlVxTGJBeExDQThJRWNnc0F0RFk3Z0VBR0lnc0FCUVdMQkFZRmxtc0FGallMQUFRMkU0TGJBeUxDNFhQQzJ3TXl3Z1BDQkhJTEFMUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJDd0FFTmhzQUZEWXpndHNEUXNzUUlBRmlVZ0xpQkhzQUFqUXJBQ0pVbUtpa2NqUnlOaElGaGlHeUZac0FFalFySXpBUUVWRkNvdHNEVXNzQUFXc0FRbHNBUWxSeU5ISTJHd0NVTXJaWW91SXlBZ1BJbzRMYkEyTExBQUZyQUVKYkFFSlNBdVJ5TkhJMkVnc0FRalFyQUpReXNnc0dCUVdDQ3dRRkZZc3dJZ0F5QWJzd0ltQXhwWlFrSWpJTEFJUXlDS0kwY2pSeU5oSTBaZ3NBUkRzQUppSUxBQVVGaXdRR0JaWnJBQlkyQWdzQUVySUlxS1lTQ3dBa05nWkNPd0EwTmhaRkJZc0FKRFlSdXdBME5nV2JBREpiQUNZaUN3QUZCWXNFQmdXV2F3QVdOaEl5QWdzQVFtSTBaaE9Cc2pzQWhEUnJBQ0piQUlRMGNqUnlOaFlDQ3dCRU93QW1JZ3NBQlFXTEJBWUZsbXNBRmpZQ01nc0FFckk3QUVRMkN3QVN1d0JTVmhzQVVsc0FKaUlMQUFVRml3UUdCWlpyQUJZN0FFSm1FZ3NBUWxZR1Fqc0FNbFlHUlFXQ0ViSXlGWkl5QWdzQVFtSTBaaE9Ga3RzRGNzc0FBV0lDQWdzQVVtSUM1SEkwY2pZU004T0Myd09DeXdBQllnc0FnalFpQWdJRVlqUjdBQkt5TmhPQzJ3T1N5d0FCYXdBeVd3QWlWSEkwY2pZYkFBVkZndUlEd2pJUnV3QWlXd0FpVkhJMGNqWVNDd0JTV3dCQ1ZISTBjalliQUdKYkFGSlVtd0FpVmh1UWdBQ0FCall5TWdXR0liSVZsanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ0l5NGpJQ0E4aWpnaklWa3RzRG9zc0FBV0lMQUlReUF1UnlOSEkyRWdZTEFnWUdhd0FtSWdzQUJRV0xCQVlGbG1zQUZqSXlBZ1BJbzRMYkE3TENNZ0xrYXdBaVZHVWxnZ1BGa3VzU3NCRkNzdHNEd3NJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UFN3aklDNUdzQUlsUmxKWUlEeFpJeUF1UnJBQ0pVWlFXQ0E4V1M2eEt3RVVLeTJ3UGl5d05Tc2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJMYkEvTExBMks0b2dJRHl3QkNOQ2lqZ2pJQzVHc0FJbFJsSllJRHhaTHJFckFSUXJzQVJETHJBckt5MndRQ3l3QUJhd0JDV3dCQ1lnTGtjalJ5TmhzQWxES3lNZ1BDQXVJeml4S3dFVUt5MndRU3l4Q0FRbFFyQUFGckFFSmJBRUpTQXVSeU5ISTJFZ3NBUWpRckFKUXlzZ3NHQlFXQ0N3UUZGWXN3SWdBeUFic3dJbUF4cFpRa0lqSUVld0JFT3dBbUlnc0FCUVdMQkFZRmxtc0FGallDQ3dBU3NnaW9waElMQUNRMkJrSTdBRFEyRmtVRml3QWtOaEc3QURRMkJac0FNbHNBSmlJTEFBVUZpd1FHQlpackFCWTJHd0FpVkdZVGdqSUR3ak9Cc2hJQ0JHSTBld0FTc2pZVGdoV2JFckFSUXJMYkJDTExBMUt5NnhLd0VVS3kyd1F5eXdOaXNoSXlBZ1BMQUVJMElqT0xFckFSUXJzQVJETHJBckt5MndSQ3l3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckF4S2kyd1JTeXdBQlVnUjdBQUkwS3lBQUVCRlJRVExyQXhLaTJ3Uml5eEFBRVVFN0F5S2kyd1J5eXdOQ290c0Vnc3NBQVdSU01nTGlCR2lpTmhPTEVyQVJRckxiQkpMTEFJSTBLd1NDc3RzRW9zc2dBQVFTc3RzRXNzc2dBQlFTc3RzRXdzc2dFQVFTc3RzRTBzc2dFQlFTc3RzRTRzc2dBQVFpc3RzRThzc2dBQlFpc3RzRkFzc2dFQVFpc3RzRkVzc2dFQlFpc3RzRklzc2dBQVBpc3RzRk1zc2dBQlBpc3RzRlFzc2dFQVBpc3RzRlVzc2dFQlBpc3RzRllzc2dBQVFDc3RzRmNzc2dBQlFDc3RzRmdzc2dFQVFDc3RzRmtzc2dFQlFDc3RzRm9zc2dBQVF5c3RzRnNzc2dBQlF5c3RzRndzc2dFQVF5c3RzRjBzc2dFQlF5c3RzRjRzc2dBQVB5c3RzRjhzc2dBQlB5c3RzR0Fzc2dFQVB5c3RzR0Vzc2dFQlB5c3RzR0lzc0RjckxyRXJBUlFyTGJCakxMQTNLN0E3S3kyd1pDeXdOeXV3UENzdHNHVXNzQUFXc0RjcnNEMHJMYkJtTExBNEt5NnhLd0VVS3kyd1p5eXdPQ3V3T3lzdHNHZ3NzRGdyc0R3ckxiQnBMTEE0SzdBOUt5MndhaXl3T1NzdXNTc0JGQ3N0c0dzc3NEa3JzRHNyTGJCc0xMQTVLN0E4S3kyd2JTeXdPU3V3UFNzdHNHNHNzRG9yTHJFckFSUXJMYkJ2TExBNks3QTdLeTJ3Y0N5d09pdXdQQ3N0c0hFc3NEb3JzRDByTGJCeUxMTUpCQUlEUlZnaEd5TWhXVUlyc0FobHNBTWtVSGl3QVJVd0xRQkx1QURJVWxpeEFRR09XYkFCdVFnQUNBQmpjTEVBQlVLeEFBQXFzUUFGUXJFQUNDcXhBQVZDc1FBSUtyRUFCVUs1QUFBQUNTcXhBQVZDdVFBQUFBa3FzUU1BUkxFa0FZaFJXTEJBaUZpeEEyUkVzU1lCaUZGWXVnaUFBQUVFUUloalZGaXhBd0JFV1ZsWldiRUFEQ3E0QWYrRnNBU05zUUlBUkFBPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL29wZW4taWNvbmljL2ZvbnQvZm9udHMvb3Blbi1pY29uaWMudHRmXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvb3Blbi1pY29uaWMvZm9udC9mb250cy9vcGVuLWljb25pYy50dGZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBRHFJQUE4QUFBQUFiWHdBQVJtWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQldBQUFBQm9BQUFBY2EvQUJwRTlUTHpJQUFBRjBBQUFBUmdBQUFHQTBCbEZpWTIxaGNBQUFBYndBQUFCQ0FBQUJRZ0FQNUlsamRuUWdBQUFDQUFBQUFBb0FBQUFLQUFBQUFHWndaMjBBQUFJTUFBQUZrZ0FBQzJ5K2IrWTVaMkZ6Y0FBQUI2QUFBQUFJQUFBQUNBQUFBQkJuYkhsbUFBQUhxQUFBSzRNQUFGSVlTT1h1cm1obFlXUUFBRE1zQUFBQU1BQUFBRFlCODd0RmFHaGxZUUFBTTF3QUFBQWVBQUFBSkFhTUJBRm9iWFI0QUFBemZBQUFBR01BQUFPR21wNEFHbXh2WTJFQUFEUGdBQUFCeGdBQUFjYWp1bzlFYldGNGNBQUFOYWdBQUFBZUFBQUFJQUdjQzladVlXMWxBQUExeUFBQUFXa0FBQUo4anZZUXhYQnZjM1FBQURjMEFBQUM3QUFBQkdQdEVEUCtjSEpsY0FBQU9pQUFBQUJsQUFBQWU5MXJBNFY0bkdOZ1lHQmtBSUl6dG92T2cranpOL1d6WURRQVRQVUcvZ0FBZUp4allHSDZ4emlCZ1pXQmdZbUR5WUNCZ2FFQVFqTTJNS2d6bkFlS01yQXlNOENCQUlMSkVKRG1tc0p3NEFIRGczdk1Da0N1QjVCTUJkS01TRW9VR0JnQjlTUUo1Z0FBZUp4allHQmdab0JnR1FaR0JoQ3dBZklZd1h3V0JnVWd6UUtFUVA2RGUvLy9BMG1HLy84Vm1LRXFHUmpaR0dCTUJrWW1JTUhFZ0FvWUdZWTlBQUFiZVFkNUFBQUFBQUFBQUFBQUFBQUFBQUI0bksxV2FYUFVSaEFkN2VFVEg4RUhDVXBneEhnZHN4b3Q1aklHRm1Pa1hTL2dIT3Nya1NDSDVGMDc5OFVuZm9OK1RXdEpxc2czZmxwZXp4N1lZQ2RWVkNocSswM3JhYWI3ZFUvTEpMUWtzUmZXSXlrM1g0ckpyVTBhMm5rUzBnMmJscUw0VUtaN0llVkt5ZDhqWWtTMFdtcmZkaHdTRVlsQTFUckNFa0hzZTJScGt2R2hSemt0MjVKZU5hbXcrS1N6WkkwRjlWWjkrMm5vS01kT1Ewbk5adWpRZW1STFdtVzBHa1V5NjVLU05pM0IxVnRKV3Vibnk4eDgxUXdsZ2tnVFNXUE5NSVpIOHJNeFJpdU1WbUk3anFMSUpzdU5Ja1dpR1I1RWtVZDVMYkZQb1pRZ29HTFFES21vZkJwU1BzS1B5SW85S21pRnVHUTdLKzc3a3A5MEQ2ZXhnRVJjcDN6WmdUZVFxVXl4YzdaY0xLVmJZZHkwayswb1ZCR2VyZStFZUdCelFyMVRQU3BxR2c3Y2pzaDFaUm5DVXZrSzhpby9vZHorSVZrdG5FM0Zza2ZEV25LQTQwSHJaVUhzUzk2QjF1T0lLWEhOQkRpaU84UGpJcWo3WldjZzlLZytMdnhZZHhmTFJRZ0JzbzFsUFZVSkY4R29KR3hXa3FTTklQdFJVcjZra2xyM2lQRlRYcWNGdkNYczE2a2RmZW1NTmdsMXhzZnk5ZEN4bFJPVkhZOG1kSmJMMWFtZDFEeWExQ0JLU1dlQ3gvdzZnUElqbXVEVk5sWVRXSGswaFcybWpTUVNDclJ3TGswR3NVeGpTWk1RemFOcHZia2Jab1YyTFZxZ2lRUDEzS1AzOU9aV3VMblRkZG9PL0RQR2YxWm5ZaXJZQzdPcHFZQ3N4S2NwbHhzVWJldG5aL2huQWo5a3phTVMrVkl6ekZnOFpPdW5LQzRmVzNZVVh1dGp1L3VjWDBIZnN5ZENKZzNFMzREM2VLbE9LV0FteEl5Q1dtaWx0WTVsV2FaV00xcGtJbGZmRFdsSytiSk80MmpJTWVnYit6TEc4WDlOVDF0aVV2aCtHbWRuaDF4NjV0cVhJTk1zY3B0eFBaclRtY1YySGpxelBhZXpQTnYzZFZaZys0SE9pbXpQNjJ5SXJhMnpZYllmNm15RTdVYzZHMlY3UVF1YWNOOGhrSXNJNUFJMmtBaUVyWU5BMkY1Q0lHd1ZBbUc3Z0VEWWxoQUkyMFVFd3ZaakJNSjJDWUd3dmF4bDFmUlRXZVBZNlZnR0tFSWNHTTF4Unk1elU3bWF5aTZWY1YwME9yVWhUNUZiSmF1SzU5Uy9NdEF2SG5tREdsanpwTXRrelMyYjVDcEhWVG4rNklxV04wMmN5K0JZOWJjM3gvVTU4VkQyaS9rL0JmK3JyYW5WN0lvMWgweXVJbThFZW5LYzZOcGsxYU5ydW5LdTZ0SDEvNktpdzFxZzMwQXB4SHhKVm1TRGJ5WWtmSlNtRGRYQVZRNHhyekh2Y0Yydlc5YmNMTTYvaVJFeWorN0hmME9oMGNBOVNDdEt5bXFLdlZaZVA1YVY3aDVVd0o1Z1NZcjVNcTl2aFM5eU1pL3RGN25GL1BuSTV3RTNna0dwREZ0dDRHb0ZiOTZUbUlkTWQ0cm5ncml0S0I4a2JUek9CWWtOSFBPQWVmT2RCQ0hoUTZJMlVEdUZFemFRRjR3NUJmdWRjSWpxanJJQ2JpKzBMNktSaW0vdGloMDVvNUlKQXIvTjdnaDdmUlpLZm9zMWtQQVVGM3NhcUNxa1dUVnVHc0dsa1hKRE5mZ3dydFp0SXhrbjBGTlU3SVlWV2NWSGp5UHVPU1hIMHBkOHFJVFZvNk9mMVc2aFR1cmNYbVVVdCsrZFhnUkJ2elF4ZjNmZlRMRmZ5cnRheVFxcnRvR3BXNDBxbVd2TjR1SlZCKzdtVWZlOTQrd1RPV3VhYnJvbmJucGYwNHFiNG1CdUZrVDdOZ2RscVpBTDZ2cWd3L3JxY25NcHRIb0ZsNlM3M1FNTUN3em9kMmpGeHYvVmZSdyt6NVdxd3VnNFVtOG42c1hvc3hqOS9BUE8zMUU5QVhwNURGS3VJZVc1N3VYRXB4djNjS1pDVjNFWDY2ZjROekJycmRrWnVnYmMwSFFENWlHclZvZXVjZ1BmcWI1T2p6UzNJejBFZkt3N1Fqd0EyQVN3R0h5aU81YnhmQXBnUEo4eHh3ZjRuRGtNbXN4aHNNVWNCdHZNV1FQWVlRNkRYZVl3MkdNT2d5K1lzdzd3SlhNWWhNeGhFREdId1JQbUJBQlBtY1BnSytZdytKbzVETDVoem4yQWI1bkRJR1lPZzRRNURQWTEzUnJJM09JRjNRVnFHMVFGT2pEOWhNVTlMQTQxclE3WTMvSENzTDgzaU5rL0dNVFVIelhkSGxCLzRvV2gvbXdRVTM4eGlLbS9hcm96b1A3R0MwUDkzU0NtL21FUVU1L3BGNk9GWFA4dkk5K2xrUVBLTHpTZjgvZkUrd2NrZkVBQkFBQUFBUUFCLy84QUQzaWNuWHdMbEJ2bGxXYjlWWkpLcGZlclZQM1FXOTFTcTF2dWRrc3RxZDJ5MWJiQnVMSEJqOFkyQWtNbmtFcHNUSUFPRDVzWU95RmhsbVN5NDlDMHM1b3d5U2FNQXo1TTRHdzhURXd5YkMrZVlZYWh6dWFZSlhOOEpycytDd016T2NrZWs4Y2s0NTBrUG5TeDkvNS9sVlJxbXcyTTNWSzkvL29mOTcvM3UvZCt2emllNitNNDdtZTh6QW1jeURsUE8yeUU0MWVObElQbFlMNGN6UGI5L2ZlLzhRMWVYbjZuajd6TjhYQW5KNlQ0SmJqVEIvZTZuRHplUzlMQmRBVStTU0pXWUljVXlVWGRReGIwZVZYVDlIbXl3Qzh0WDYyU2kycXJwYXFYbGVIdExrT1UwL0EvYnlrRHZ6U3pDUGpYNGpnQ1JhaTBERC9uK0FzSFIxYU5oRkxST0NtTCtYSmxJcGR4eUJOblNlWXN2RjVkZkgyUlh6cjdlRW5UU3ZzWEYvYy92dUpaTno3THBhSXlQbVVXUU1iaFlYZ1FuOGVIOFVFczRIR3N1cTFkZit3dk41VGlYZS95ZVZ4T2g0M25iS3RHZ2xCL0JUNmlzUlZTNzc2bDhzM2xaOVQySHIra3NuOGZ0RHpyZnl3RkN6RzMxc0wrUFhYVHNCQ3R2ZGRWTnp2SHZmZE5XcDRkU2d0eVVhNmY4Ni8zOUN2aFVNRGpkQWljSFFhdXBJaURWVkd4NXlvVGcxRTVJbVlIdzZNa2IwLzdpRWdXUG5uN1Z2MmxXMDZkMGYrN2d6ODFIeml2bjVpZisrTmhzcFhjUC82dDIvbWwrdHNYU3ZOZmVuTmc0Sms3SC9qR3dQcUsvblR3MEo3WURYZEliSXc1Y2xGSWNRNFlKeHVPVXhpRTBrM0ttcXI5WmhscXJIdjBjNlNJdHhreUJmY3ltWEk3YlNoVElCTUJSeW9YR0F4bUpaSU5YaURYWGJpZ2YvY0NLV29nWGtVb0FZL2c3S1A2T1N6cHltVzVWcFFsRVpUeGRsa0w3RW45WEhkcG1uYWxzcndyeXFJalNsYVcxU2xKMHpSYXFkL1hQb0t6dFd3dEI1NWMyVHl1TTIrYXRFL3QyS2VFMW1HUXpUZjlITi9FM3VVdXU1ZW45M3BwMjhsRmJDL016b3Q4RXdaQ05jYUtiNjRjS3duR0NqVEFqL1FmV2thck0vOVcxSUcwNjdDRTdTNXdLKytsZFpENEZWVllvdVZySytvZzBIdGgwT0UvS1pBeDJoL3NDVzZsYk5GNys5bTkySjdPblhRKzhVdHczNVhuRS9SN1ZvQVBvUjg1U3haVVZWTlYzTUI4cHhNZUZOY3owS3g1a0RjMlB6TzBUMTJjekNXNUFwWTNrSXBGQTI0SGxoZFdISEpFRVVjSm0wb09NVit0VE9UdDdLdzV2K2k1KzJlYXpabmFPdjY1KzlmVllGZi81cVpZYkZPZDdLN1hZWWR2empRL2ZSU3VmMlgyNmZ2dmYzcjJLM0RMMFU4M3I1NkpGWXF4bWZydTJhbjZ6dDMxbVZpeEVETmtpeXhRMmZKYlpMUVVqVGd5dVlsd3RGeXFCZlBpd2FjT3dwOWFIVjFWdzRiUlEvMC9oY1A2WDRPcUVDenk2ZWNVenZXOVVBRExFU3d5bXNGR2tKeENvRUJvd1R0a3l6dnY2Qys4UXhhT25Kb2szOXAyWEw5MTIyMUhUZ2twUEFrWHYzRHF5RzNieUxjbWorcTNUc0l1Wjc2RDZpS0o4OEk3NkRqZ08wRDRRWUNJTVJDZ3N0OTlpMXdFd1lOWmdOMFBKMkEwUVY1TS9RajFWTURxNWJnUzl2K3FmTHEvdDhkRGNEeXJTb0pYWUNDREVVYzJuY2xWZ3RsS09WeFZ4TFFOclVNa1dxcXVJeE1EbG4xeUxCZ2tuM3pRODdBYThTMy96QmRSSDc3ZzYxa2dLZjJYdy9INGNKejQ2VVpJRVIvNTNKZjlxcjdvaTBSODVHNlY5QVkvODV3V2wxVTUzdjFGeDhPMFQyRVlqMkJBd3ZFSXAwdHhGREU1QWhXckJDZVVZRG9vOGQrV1ZGVmEzaU9wT0JGY0wybG5KSW0vUmxMUjZITGNTanNwMFhtNW9weE9HWllDRE4zMTN0ZnBzemx1RE9wUnpFZDVyTWRFdFM2a1VUaGcyb1lVcXZCWlgwM1VxdUZLTnVQSVpuTDJyQ3c2eFBRWXVhVXZMTmp0NUNLMnJmVGxua3hCR0ZtamM0M1pUTStYUzhSQjVEajVxdWFZbmlRdkgzTHdYd3Fsb0t1TzZmODZWQ3MzQ29YWlJyazJSTHpIU0NKK3d2WFFIVDkyZGVsQkwrc2JuNGg5dzVXZ0dsQ1ZORlNoTWhFdW8rQ1N4bE1ISDkzNDdsc2JIMVcxK213ZEpIYjJhL2ZVdG0rdjNmTzEyZVVYQy9VNkxZbzJORWZMQzBDSklMZEJ2OCtPTWhVdTI4R21aU3RpdnBhdktUVzVKc3ExVm9uTXZmMjJmcUswZFd1cnRYVXI0Sm1Xa0xwMC9JbExsNHdUR2lJR2pyUE1CNW1MYzROUWJqS2hSTjFVVnROWVdURkJaQlN4Q2t5RjRFUXVtNVpoVXNCV0NMSXR1VGg3c0xoaCsrTCs1Zk5RMVFJcHFyaFJXNDFtczRGTnVhYVdmSERML2tVVkxpMFU2dGhBMVBITkkwMnJick9idW8wRXl3VG1SaEZuaEtIYmlvYStSTjNXRC9lRm1Hd0Vhd3JVSUNvSDB4bEhKRnFHV1lXVG9OWWdOUlhxb0piaytQSjVIRXMrdDN5KzBSUWNJM0VzRHpSZU1TNHZuNGZoVTVzTlBoZU9qemlNZXFCZXNabTZHMFEyRDVoQVkyaERzNDZuUUhXUDIwYXhvQUY1eW9BSHFaVGk3YVQ0QTFLUTN2MjFKS1JVZGQrKzVUK1hKR3MvSzlDS1BQUnpOdGJiUS91WlFETkEwRUhZMlZTR3VWb0h0VnBWb0ZoUVFlbFNqYzBBNkpWQy9Zd0UxYjlhamt0bjZnVk45L1QwOFV0OVBleGwwT3ZTcjdESnY1SmdEQUFYNmJJa2FmRHlqcjBaZ1BiSnRKK2g1N0l3ZWhrUmRGMFU5WWdEa1ZhbFZxMkJIaG5sY1lxUTR0d0J0VlFhNjQzMUNzODlyOXhNM2xsK0puQmorUEJSM3U4czFZVFVnYmxTS1ptdHh3N0YxTnYycVljOU4yNVh2WnZYSnVjYW14aStNK1praEl0eFExd1I5ZGR3SVIzdmxkM1VmdENwS2JlMUY3UTNpZ01KTWxWakEwcWx5dzREa2JFSk5qdS9oQzNEbGtmK21DcXFGaDZUSWoxN25tL3lTK3dxRFBnUzc0OS9ORTV2WW4rYW9XVFlHUFlKY1poRC9UQ0dZVFluU1pKRVJlSW5BQVduaVlROUE1WEs1QnM0QnZ6L2NSVHRkdjNmL0wzQjdWV1BseHpTaHlhM2ZmM3VMV3ZYWFh1OUVCZUtkbEgvUTYrbnVqM1k2eWN1L2VDMnlidS9uc2tldVhaeW02SFQzdnV2L0d2UUIvdWczMHR1UW5WU3VaUWt0VkhTSUtVRWNZaEtyVnFtYi9RVEdBYW1yQ0tpd2laZFpnenV5SzBUY2FBY1lqUWl4b1dJbU11THFMaWdjdE1rVnhraGRMZk9WMnY1VVNMMWgzMmVSK0l4eDhDMWU2NGRzTWRpajdoZGNqemd2aTlpcDMxVGNtenpSK055d0w5aGNPUGF1QnlLMlFpcFh6V3cwUitRNDFIL05rZkpqbmZaTjlrajkzc0M1RzlDS1hGak5ONjhmckoyZlRNUjNTakdaVytmWXpMcmh6N05wSVpzY1hqS25aM0pwZk5mc05rZGR2dU5jbHdKQ2dGaDFtWmZHRW9WTm1YZDhLcTRiU2lWaWN1UmhEODdhZStqWThEREVLRlBGWU14Q0VsMk9nYmxFc2pDQ0NHRHdieWNFWldvaitUeVFqWkQ1d0xmM0N0SmUvWERKSE5Kc1c5MStuTER6bjF3NWdWK1NWcCtVU0xIait1ZW8wTDArZkJ3d0JjbUFla0ZOQXBpVzJlNHFYWENXWmZrc2x4NGZTQ2Rpc1BVa3lQQmdOZGo1MFJxYU9TZ2FheGdFaENZZUdYOGdMVzJHL3RvZkF6enBYdW8xMEUzUWdybm5pVDRKSFFnejlIemdCMDE2cFowNmlCMDFRTHEwS21CQ0lwRU5CVUpxMFhZZkQ5OHpQZWpWNG50aFJwWTM2N1JTVTYrd0U2eTExcXdRdytYZ3JtM21tS0h3aUJNUGpmRGdpQ0MwVHJwdExvS0I5T2t5aHN6Y01EWTVneGtSWjU0d1dtYnN6bG5KV3h0czNFTWozN0NZTU5uS05yNjFXeWRtaTdvZkJ3VGlmeGxvd243K2prMkF5a0dDOVh4SnNQV2F4UmI4aDE5UzBBOXovTk5mWjZ6NkdPOFRwaGRJT2hjVS9YYXhndWRlMWdaa25HUFBvK2xySHdQWVRnN1RSYklBdnFqN0I2bWw1TndUeG93N2pqbzVkSGhYQ2JFby8yRGJyR1Zva2tDaXNvUHFBZ1ZGY3l4TWNLUUEyZDB6b0N4N1FmOFlOTzhmZlljV1hJNWhaMkM3TlpQdUdUQlYvVzZXc1JPNUFUWnlicnNXcnJoYzZGVTBEM2pkMTF5K2YydXdqT0ZYcExRYjdEb0xVdjh3UUh5NHp3dGlRN1Q1Z1N6SWdFVEJkNEZzMm5rSWlBcGNJamhDT0NqUjZWdDN5Z0U0Rmx2MnlkU3lDZy9SbXBScGNIem4zdE1ENmV1dmJsbjV0aldiZmt2Mzg4dkhkUERtUzAzOVc0K2R0MFdPS2JQbDJqZjJkdCtrbEpUSk5LNmRLbUZIY3czNlE2T0JtbGprL2E5UkJFVkVZYUQzUzJrY0VzSHJ2dGVXcSt3UkFDNXRIRHM0RFkyZkxERHJhZ0Q4Nm1JbUJmek9JUllJZzRpYmxmNG5WN29LODhLdnhNZVU5cnVLOVJkblhtT2JHejduWlBzZUVVNTRjdkxxVUd6b0JzQWFPVkZzN1JMTTYyVytkY3AwWEt5N1Y5VFhSQUVsT1U4SFE5SkJoNk1NL3VmUmkwT0pzZGVCZzFVdHByR2lTcEt6RmEzVHovbmMyL1ZmNzZWWElRRG4zdjVJSHdMS2REcWNCck9sT1RObW1hY2R2TmZjdnM2OG0zNk96MGczM0xBMCszdm1MTjlzQ3hId1hjYkk2YkR3M3QrZStyVWIwL3BKOVJNYm1aZ2RjRGk4ZUNGNjA0UHBHZUdWbnNzZmRZTGR0NTVPcGVnYlNQWUxEUmtZcmJDWWxacE5GWGxCZ21EdWtHekYrY3hpZ1U2dmtwZTNyODRza1k2QTdoUS81Zll3ZG5nWTFzRUczSHdjcnlsYWEySWtGcmNYd3JzSHUvcktTR3VMSTJYWncvdXVSZWtEeUFBM2dBV3YydnNJcUJsbmFmNzVKWDF5SXRac3dvSytCVU9CRnRaNDkzSE5PMU4rdWFiTDJrSUdqcnYxRFRqZlkxTEpXcEZ1L3lWa09tdnROOUR4NDIraFJYZGJPaU4yWU5ZTkwvRXltdzBRU1B1dWJlcnptNHVBWFdXUFJTVGhFc0tXSHdIZXRKVisrWGxYbnJvK2dOL1BqdzEzTHRJVm5lL0FURG5mWE9CNUVSMS82SzI4bDFDdTg0QytLVitrQVd2QzgwUHhhQWtLNVJGSlpzZkxDdGl0b2I2NUp3Ulh1T2JiRVBEQXhyN1o2bDNFdENzOC9SQUtzRHNPSUFiUlV3UzJROHFJTzhuMlRHWXNiVXhVcGttNkp5WUdJL01xYVhZb1ptUzU5QWhUMm5tVUt6VWZYamlTQk1rUVVoZDhhSjUrRWdUNytxU2NRRTBwUXZhQlpxU3RZdUZFVVc3R1VFRVNNK3NDSnBPOUlDc3o0cnNXYWY1ck9HbEM4RThkb0pHd3kzNEpMTWUyaFdlZGExOEZqb0JQWHV3MS9PYTVXa1djN3RTdmUyZGV0c1ZHdjFrTmcrcWJUeVAxZGJnZnFwUFlDenpZTi9YY091NGE3anRYSEM5Yjh2bWpZMzZWR1c4T0JUaEhEUTRBZ29HcE1qd2c4dk1Xb0hZVS9Hbk9nZU0yUVFkR05RL05HU0FyaDBpRDVFTjF6cVNsaGtneUVLZnE5anZqUkxPUk92QnM4TTROY2g5dzNHWUpDQThsMlJxN0lwb3l3Q1VYK0VKZHVDSjB5ZmcyZmp3czRCaDZQMmxFbjNhc0JlMGoxd1lQeWRvNXlmS0NOanlnRndRZUduZ1lBbUs1SHIzZ2laWnNZOUlFVmMvWXArZVNJZ3FQZHZsU2k4djJNT21VSzdRZXdqbDFFOGJVWkZ1elVmTmJJbFo2Y3R0ajdReXBvczlaNDBpV1dKSHk4OUFpUnlOWDF0a3lVMWpVLzcxbmtqQWpPSFpMNCt2bThpRFNnakEwbmFjL1g4WmxUWWhvVkZSVzN2K1N3WVdoYjVCSE9wejJhbFBsallOa1pnMnJVL053Sis5L0MvY3ZuZmZRb01ESmliazlqR1Z3Q3lQcHY4aDJwenZHTUg0amx5SE9KbmFIQ1VhQ2J0WnJFSk9nMzRJWWxnbkMwNHpPSnRLRUlCSkdrRE15MnFwald6SlhFay9RZWF3Q1NWVmIrQ1ppM0RwQkQzUGRmVVhpK01WdVFuc3IvRlZ1ZjRJSFd2NzVXTnQ5cGM0VWEzVmVYVEQySWxLTFo4enI2MjBmV2VZc3hueENZSXo2dHZiVzBDYzY3ZzVZSUM0bFlKQmUvcVFQMjRMM094QXVGdm8zZXU3NW5JNXdkbU9lTTdHZENhTlB4TU1EQmJSaTlEUGFSaWt4OG5PNHVINnZNcHgzVEVJZkY3c3hDRHNMQ2JNZEFXV29tSFhHZEgwVHB6T3hnWHd2WGFleGVtQ2FXSFFBbWhZZm9YTVdhQUxWZnJGTjd2QlRLYzhONHd1K05FZXdaQjNqQ2xrSFBBOXFOU294YUxPS2ZhcGloTUtnNzZON1dDT3R2Tkw3endOOCtESTAzM05admlPcTlCMlhYVkhlMXdwVHJKelRzNEQ5WTNndUlhQ1BxOEx0VHFiQi9nZm9Qd2dxaWo2QWFldFNCYVdyOGJHWTZ0UmtOQTdRQ3pKNGo0NEV6U1dLMEsvL09zWWh1VHFvRk1TTEFjQW1sRUI2YzlXY3VCUzA2aXBZazhRak1tQTFzeUNqc3lEMGdTRWhOQUZFRXN1UHpoS0VMblVpYVp1SFU4VlZXZndrdHVudUFrWlg3dWx2TFhyblA0ZVBRZDJJSm9jVStjY1BuZkpuUkEyZUxhVlMrVXQ2cFZPV3ZxWTVUcEZtOERHR3J5Y05EaEQwRXFXV2VDWHNMMWdrT0M3YTJ6WWMzYVdJeVh3SVAzUTlBOCtoZU5LaXZodGVRWmovYzdUUVRmMU00Z01RMW1HaHlhcTZjNHVLZDd3QUlqbktYN2UyQzZwRDl5QVluYmtWSHVucXg2c1RML2JadFFmRkF2R0VyUEVzbHM4ZFFSS3d3YlJIV3dUTFE2clMzZG9qUGNDaldHRnVBeVUxeE5tMkU1SjJBd3hhd2cxSGlQM1VSYVh4Rk9rbVBFTzNiU3BCckpYMjNUVGtQY2o0SW5Pb3FrcGdLdWE4WTdjZTgvaU9wVENkWXYzM0R2aTFiZkU1ZG1ETUZuckJka3kxOEIzeEg0VWFEOUtoR3BlNWtNYVU5U2ptdkZCV2o4ZUpiZnJmc0o2R3NjSSsxN0RnUUlkaWVremN0SFE5MTNZUWM0T0doL01xaGtmQnIyNHJyNjFnU1ozbm5iYURkbVE3WVB3QjdPYXlyM2g2QzVSd0FENHdhS1hiVEFxaVA5OGJxZWQ0VDhNdEEzYTRla0tZQ1htWWFFcU1WS0dIaFlLMWJBUnpkWlNxN1dVVXkxemlkWWwyNGt0Z2hjQjZCWFFTd1FnVEJiVE1qSjZ6UGwwclp5clpHc0FZUG5teDI0SmJIdjVpU1RaR3RDZkQ1TkM0TTJiLytEZVBYTUhQdmxDOVQwdS9FcEE2ejJUQVNrdEhaaTg1eVlWRXpuYkRrL2V0VmRkUDZBKzhtZjRYa2ZiTnpidEpWbzB3RDlSc1BXbXpYU3NzSm5Rb1RYamcvRVUwMmFhdXFHZFVMN01qbjBZWEFsRmFSOFVHekpjK2Z1dzRmdmpVb1l0LzMrNDlJUGpTcWgxaC9NQXowclVWdmhjVGlwYm1Ha0N2eFNFR1NQaitacUdiZ0UxTnVDSnErQzFZeG9SUS9iemVHajFOZnBCTWlwUWgvR0JWTXhMWmEyVXNDV0p6NWJOWURpaTRURGhWNzZrc09sYml4cllsQnd2ZmV5NlRlTURrdVJRdHU5NWROUG1MOXl5T1JnVVBJWFJtZXZWUjJqZ1NYT0ZZbkU1NGFQV2xsOUtWOWF2cndRRG5zSys3UnNBWUNhVGptaGp6YVpTUm1VUktJY3ZJY2RqSVJlMTRrYmVLTVAvTnk1TmZmS0JUSytBT3FWT1dKQzJDaFloQW41TTFJakZvdUxObzBGVEFMR1FyWUlnaUZILzNNYVJ6NHdVaXh0dURjWGxYbjlEZjBUL1YzSm9PaUIvWG4vMVliS1dYeUxCV3plTWpCU1BGRGZPK1hya2VHU0QvZ2dKa0tQVHZxZy8vaVA5bFQ4Z2F5MnhBYlI1b09zZHBxNWtaczVxMmpvbXpScFQ2S04rZDdiZlMrMDZxa1NmVFJtMWdWSzBUUkNxSWJOcDNOZWMvWnNxSXlQck5xeHk5OUxkOVBpYThSVHBvZnZUZy9vNWVpeWtiSUhKOWZzblIyL2RQSHZOTGFQc1lHakgrbzBiTm03VGw5bmhKMjQzVHF6QUpSN0VGd1l1QVJrTkk0VkRTVmV5SUtTVXlXRHhZMzd3aW1xTjQ3bE1ma3k0TEphRk1oSEt0V3lycFdxdEZwanZSemVpK21GNFpnVmZ3VTd6TVM2enoyUWprTXJnSzBiRzhHVXNPVUFSc2Q1QUM4QzFZMUhZZjZ2aDNZT1VtME5qOGFKY1pXWWUwOXRWNHhRQ2dZellRVFcxQ2w0Rkg2YTJxbC9SNVBpcUd0MXZOclJRSURkSzkxZlZoRlN6TVg2OS82QVVsK3YrNjhjeGVBR0g5VVl6RUpvcEdrZm44VUozbXh6VWozQ0pScHNBbytYRnRGSUxwbXVnbWFGVFdpMXlFZnBsSHJONjlKQWRYS0VNdDBodFE5aDRtQldsc3R2cDVNV25zUkE4b1oramh5dmpSdGR3dTJIKzd0eWNYNWtuRjVXb1EzUmtITEFaSmFJakFhNStSb3dxQ2JES1JFUTdYS3ZtY0piWEdrSStoL21VSEd5RVdrN3h3YVNxS2dsaG1sUnlIUzdJam11alVXL1VOUkswTzF3K3hSSHVUWWwxbDRPRXBHM2V3V3BnYXZYV1J3cThFaytzSHU4bkpKa0llcjMyeU5XRUNHNUhXRmp6Y25hTlhhZzZCVWtNU05GQWgxQlNEUHV6a3MyblJKemdsWVd1dW9aa1hJbXFJSG1qZDZTaVYwMUZlc1J3SWVFdnBvZmNJVyt2UzFZY2RyZFhEUEhodTF4Smo1TTRoSWpYNFk0S3VXNGZ6OTNoMm9BaXdIaWtnbWFlUDNNYjhzZ3cvZGkyQlhEaUJ5b1pVeW1DRDdSOWRxdk5Zbm1KUERmQ2pYRmxyZ2FZZEpvYlhKOXBySjJhckU2VVZvOFdoNGR5QTVsVUl0YlhZN1Z0QWFhVWE1YVAvVU1lbTNaUFl4eVFEM0RRWlNHdjlJK1RMdk5qTzIxVTFrY3ViNGZVRFhqczc3UGZBVUxnb2x4eG4xb3dDblhhMzV3MUh2QitQTE1nbXJTMDNkaDJnRFVqWXJCOTFMZTQxZGpHbkI5VWQzaTVYckFmcnU4bCttU2ZnL3E0Tkoxa0JtK0ROSVBMRWkybUl4cm1XMkhRU00vSThaNCt2dG5YRTE0K0VPYnJoa01aMWsvVDFPYldNS1oyOURmRDRkT0dBMG5hOGxNR2ZkWEg4aVp5bGtaV1lXNk5rQW85Z3BlRGwwS2p5RWJreGp6Q0JQNElvTkdTakhFWnVVVDNZS3Vmb3lFYmN3KzJNTkJ4dWRXUzR5cHM5WG0yTlkvSmdoeHY2MDlxNHdmYi9NUjJQSnVxUyt5QUhLMFJQV0wrRXVEeXlHOVBsUXdteVFNbkh6QVlKZkRTVTBlZ2VJMDJmKzZHQjhDZE9JSDdjRUk5WXJ3dlROK0hPUTBQRCs4TFVQVk1vMXVpUkJqenA2NC9xejlMVHNEK0xQaVZUOVgxNThndVMxMWRIYzVWUGdpT25ZeThLOUNFS0RMSXZ6a242SGVCUkMxMDJ6V3YxZDhPcHNQQkdpbFg4alVseUFBa1BtNnlxTUJjVVQyZ0lvZk1HdC9GZklMZll6YzRNcDJVWTdDc2xHdmxZSmkvRkE0dk84TE1Wd1ZCZ0gwOHA3RVVENU01bHMrU3VSVG9DOWYzY3VtK3FJdktYQ21xTkFnTjdpSFE5aEdNNlZVVm1ra0hOVHhLMGdESUV6U3VsOU5xYytYeVhPM1dPKys4RmZjK1VzVzk4dmg0T1Q0OVBEeE43cU9iT0p6Z20rdW5wdFkvK09TRHhrWmR1MlB0eE9yVkUvaUJYYzdLeDBMOEZHVTYwVXlNT2FqaHBJSERTam5DY3RiVUNOQUlBUkZveW5EK1NGTmxaSXpwRzBzWVVZT0cwenpobVp2V0RiN3F3K0Z2TlBlc0gvelV6UzY2MzIyM0F6Q1dJdU9EeUZsQnBLbVRCajlOc3VBdUhiN2dPS0Y3RG1lMmZiUlAvQmJpMCs5NlZMWDV0Ny9jNE9HNEQ4ZGxOZm1uNW1jbE0vYmZ3NHZ0SVBZUHo0dDl2M3F0Wk1WMlpDOElPZ3JHSitSdWowODJreGZsTE1aTmNwVjJ2cGU4OVByaTR2NlVYMEE5TnlhUTNVWldkL0gxUlVHQStVSEcvS245bzJZYTF5d2Y1Qkh6ek03VHNWNkdQdzFxUjFrMitTeGxwSGVBbU5PYytxT0N6VVo1VmlvRFpXcGtoNHJlQk9pWkU1VFUwU0p6eU9Bd3BiN2JGMko1QzQrcjdZY0YwNE5sNUdQWDZEY21FV2t1RkhQdytJMTRHVENucWhveE5PU2xmSTI4QzVnL0NCWnBIYmNEKy9mNjlhWEJXTmpGZUhXTWppSGFEWkpGTGYyK1oveEdWaVlEU3BVaXhackNVc1pVMitGNXN0UGxSdjZGZm80eExNZ0M0MlBvODkzSEIwSzlDWms0aUJhTys5MisvckJnc3pPU0hXV2U4Uzh3NWtXTDhTbllnV1k5bUJUaUlUbEJTRHppNlhOY3BPdzBrakJrS1VFeGNwN2J3dHE2ZmV1bVZRRW5sYVV3Mk5WS2ViQmNWYUxVMFdIdG15WlZnR2tPeXlHcEd2azZ2QWR1clU0YnZRU0hvZ051bnFqWmFVRDNWVVEvajVCTXREWThOZFh5eDhDK3RSSWtudHJkWC9UM3c4RUkyQmV2Sk5CRyticXZKSXNUOXhhbXBzaGZhb3pXY0J0djl3eFBQVlZ2OWNUbG1MK1YyQjFQQ1AxRmVsQ2MwSDhZSVBGaFgvZlpaQ0RjVzZnL05mVkhkQjZoYk5xaDdYSFFrN3RBTm5kZEx4R2UwaWFOdHVaSDdTd1hXTUl6UnFNTlprMnRLaVo0azRPVGh3dEd1dzJ1am1pMEdoa1RXN0tzc2J0dTkwUzlRYnVQOU1WbG44ZmZWeXNiN2FPOVVEb2NUZldJakhvVGpxMFpOYTlCMHhXajVhMGRRdHhzOHk0SEFkOVNjSUszbWhEZHZLMXN0SlEyZE9LZmlSUE9VZklOdEdtMGN5M3VNL3VndGVQRHhVZ1ErekNkWXJmc1UveXpRS2NVNHFINTdtTTBkTWkwWTR3WFZEak85dnRFYXUwVWl2b1ExOHJyUTZQRklVQ3hNY0IrQVErQ1oyZUh1RnVEZHprK3dMN0I1a0l0OSt6djIrV1gyTjFHOHVQeUxXZk5MUWtkZm9nd2lDcERaUUY0YUJmWGp1M1JlRGZhOElESFlmQ09BZXRBNTJGNmpXYk5LaFBubnpxSWlQblh1NlkwZnVuZ0xLVzNxck9ocVdGVkhiYnc4SUx0dFNCbUdXblRMcklTeU1MVXJpa2tMODlTOHBvR0lqYmMxcm5kY1ZWTHJGYk1seWVxZGlYYmpxc3UzUEFBTG1VNVJRN0MxeEU0b05GYVRUdHlTdFhhY2RWMmZnM0xDN0U0YlJoYWhRdE13S3dtQ1pxSk1uSk9NT1lEeFVIM2xGb0llZWhLRWYzY3BVdWFXb0tQWnNTU09TTTNvS0ROOGJBMU00cUlaZUY4UzFNd1NtMkRuS2ZoTHcrU1F5OVN4VjB2NkI3b09WeCtveGJxTkc1ZnFPTTZHb3pWNkVLR2NneXlVRzZ5ejJ2bUhDSmlOTm5XeEdNa2w4ZHRnQ0IxTzRlR0RkZlhGRjBPMVJOYU94d2M4YWgyOGZxYkhqOUw1ZzRzZ0YxYkZGSm5IOSt6d3dHWFI0TERhME1lMVNZVjRBbjlnWVVEK3hmaEJzNGEydzNRZkljY2xJenhseU0rM2s4dzBHS2EwRk8vUFVYalRqUUNaWkNqaE5TcEk1TUxuN2s3bGZLTUhIM2crT1NSNnloUU5mUXptSENZT1FxWDQwWlJQNC9ra3oxQnYyajRKdGc2T1QySUJEOHFKSWlpZWNQNDRHdk4ySm1RSWdURTlaZHgyZDdDSUczTExzZi94NUhtMXNHY0l6SXhsSHJXOEMyVy8xbHdpc0l2TGtVU1pBRUdMMDd1YXphS1J3dERqbWhqYWt1czRlbndqbFFxNytZNnEzWThCK09PQ0k0WlhSMG5takdQMlAxV0xoYWJoVVphd25LUGFIS0V6T2xQTTJlbkFQemp0bHZHalZpNm1jTWdhZmdzc01oMko0TngyZjAyZ2RXWFpVcmE5NXQ1RXFOOXpBL0gyTDdEM29sWGtTQ3U2TGhvS1oyejNNOXlBZGJ5eTBHNit1dWlacFlQVHhCTC8zWDR4R25XSWNaMTB5Y3dZMTVwR2Q0T0V5TWJMTlB1WlRGaHVxRzhLY1JBZ2tXWFcrUEo3d2N0bDlSWFZFMDErUEZRbjc4QytWMEw5UitURFZ0SUtUaVVEc0JQVk1VMktjZFlNRkJsYnB5SW5BRTVUVDIzVVlKM2txalBTU09vbytkc0FpWHBvQk0zSEgvc3poTE0yZmw2b1hUbll4Rit5Vll2MkRRa2cydDhldXF2a2FwVFFwK09PWmgzbnd3ZHFCY0s5UU9oazNlWEdIMEgrNldkRTJuM214R292cWhaZWY3SVpIYWV6cVJEVnJ4cDhodU11bVlOV3JIU1RTRytCQXBsK1psNkFma0prUjJNT0t4N0FJWmliZEM1dlVqQkp4TGJNTGZ4dk9DeXJra2dSb1NhT2xoUU9BbEVMNXpjTUQzMCt1ZFBYdmdxdnpTOTRlU0Y2SU5mdlhEeTg2OXpWbjlkUVgrVjhlS3lBSUpCR1dhcHRvWk5IalBzV1RMSG9uaXFFYzFUcVE1c1dVNTIyYXM0bEJkZ3ZFZ1dLUWNVVTdHSm5ZTmd3eWFrS05GQzZkZi83Mzh3OW15UjVvTS9CaTF3bm5JdnBOZWN3L3A5YkpjOFlmTmwrcUlzbi9PZitSZWh6a1Y0UjU3NTlBd3haUkR4S0xBRDhqRk5HaVEvU2tTQ2tielNOSytJMUVnVDhxZFAxYWVtTGczc214bjQ2S2FiUmRIWEkxNktrWGg4ZDBLL1VDTGxpY1VKNmY1TlIzZjgrTWtkSk1vdjFRR3FYQnlZMlRkdzI2WTV3UmtOT0grVDJKa0E1S3IvZkdLaFBESGgrUlRjK3VTUGQ1QkF0eS91N09na0pCbUpDc2xXNkdvd2xVV1h6VDJMbndmUGViZ0lsK0NHVWNmbWtyMXkwRXY1SU1Sd2huQ2xVdFZtYUNTYStNM2lHWHUwVk1NREpFWHdPUXpZOXFXbG1WSDlueWhCaWY5VXBxQVZQNzc4NHViWE4yZkFjaFdFRk15RWNINzRNM3VhS3V3OWNQTFY0SFR1NU1hWmhoRGV0UXQzVCthbUwrY1krcnY5WnNIeVRySU9TM2xBdXVsZmJ0cHh6N3R2M1NPa2pyOTIvUGhyK2pkVjFYYmZUbFhkZVovcEg5RjFGRzVqVFZPRVVwdUZsWEdHZE5CaytJYkphK0d3WGdxRGgvVTVNKzVraEJ0VVZHZDBoUVRHbkRxK0Y4YlpvM1M5bE5zaHNEeU9FaVJWdXdtVHlTQmJEa2JtK25yMEgzMmNERDM4M05uSEgvb1lDZWo3Zm42dTJvQXk5UHRJWWQrQjhNdVBQSDUySnduODhNSzU0Y1BYR0hFZDBFOUxaZzZSSnl2Vzd0QTVIUlR6UVhOaW80Ry9oWHBKR0lvQ2JVS3h3aVNBVXBqWGJMV09zVVpIQTBCQi9jaENYUU9QcUx2dlhWZmk2Z3gyMWw1YTFqZG1VSnl1b0xkSm1iRnhxZStKaXpXTkdLR1I1MlhKaWs2ZVJxQWN2eDVEZGpHSHA0aEdoR1FDb0V1TitSd3A2bVVpcG42NE1UUUhHR1JpMVdBajE1ZzVxNzk1RmtRSjRDbmh0aVczSHNiRnZ2VjkyZVMyNVBqQzdPTm56ejQrdXpDKzBsOE9VM21JUmlSbUsyZytKczI0OWpSYWlISUJ0a2xETTNsRzhFblMzdVZuOWtvYUkxSnJxcVQvUk5JMGlmUkpHclBqOWl2NEZNalA2T0lwV2RZWktzYUh4WTRCM0drc0hjMzQ3UEJoNUVJcUEyOGIrVUpqalErSmhodklWb2FuOHc0eEp6aDRNWmNIaHpWSnFpR3lxZThPLzVRL2N0V2YvZFM3SlJlOVRiNUJqazNldnlRSi9qMzgwbzM2ZHdlL01waDdWSTE5ZisrMVpQSXEvZCt1YXY0WE5lTVlKLzJXZlBVYWVFL1NrRFdLNUFnTVJWa3UxUnE4RVVjYkpma2NlTFVUY0lhaGM0Qk5TbFFHRXoyUkgrVzFOWHZXU0FGQitHblVJY1lWNzhpYU5TTmVKUzQ2b2o4VmhJQmtYcVFIZlBOOXJxNThsRy9TTTV4aDY4aXZvSjRqZEUzYmFORnY4RUpaVlgwMnFxR2dneHBPVUZSMEpZK1lCdzhWbmZyZmZHWkRmV1E0bzdnVFRra2RHazd6L1RiWjVoZEVQcGJidFgyd1IxUmQ0eHRuY0VUcTFSdXJIeGxOUk56cDZGQlBiMjkxYm5XY1Yrd1JaOWdYVlh5RjNzeGd6eXJQOXZHTnkxZXIzYm8weVpXNXpkeGUxS1c3cmxzL1dSeHdHYnJVSUtxQ0lvQUtqWklNakJ2c0dKeGJvWU13THNjY3hwbkJ5ODR3RHUzMGVIRHJhSC9jdStNVE83engvalZERlNTNzlobndBeVo2NUVYTFB2bUdRUjdHQTVQSFc5N2hIWjd3akU5UGozc3lVOWRSUHE4SFFRa05OMnRvOVBHSWhWM2d5TloxWkpuN1dUUFdqVDVOVmt3U1pzOHpZeUEvTUtuS3RURVlHSlkveHFVcm1sWjY0anVPcUtiMWpxWk9QcEVjVTlXVDN4SlVkVFQxeExIa1dJbW03ODY4SnFDSno3MzBVazU5N1l5ZzVwNS9QdGVPY3hwcjgweDdYNktKUEZ3UEJGcWpwbEJYcDBvV1RodzZwSis3NjZZSGp3Q0ViczdjLzh6VDc3d2pwT2k1dlFDcjRReHlzTHJMbE5wcm10UEJQQUVsb0JERXlTZjFlZnhqNUNtMmQ1SmhJY1BHdEovckI4Y1FGN2xYc3VBQWF2aXhhTDNPbXV6T2V3RG9lRUY5NHhKdVUxTmkvOUNudS9XV2l3c3h2UlgydWFrZEM1WnMwUkJNUlg0Z0s1YzR1blJOeGlWc0owamhIejZyUGFuLzdLblhTRTc3enRIWmcxQ0p6LzZEL3FNVFQ1SElrNnArL3JXajMxRVB6bHBsMTBWWm9WbVUzVlJNaVNBeENXTmhKUnVXUDhwRHVTREM3UmZBMWd4QnFDK1JqVXZxUjU3OHg4TmYvTW1qNm9XVDFJRXVHQ0hTSmYybGx3Ny80NU1mVVIvOXlSZFBYbURPdG5XOUMzdDNHdm9peVByY29Gb3lYbnl3SFNsbHhvRHlySEM5cEQ2UG9id0ZkSXNSblE3SDY3ak9UNk54MGt2Nk9ZcXVXMnlaWTZGdWpja2lMejJPSFBpd2krb05rNy9SV1ZTUXBsTHJFQnVrdlBWdFVQaHFNYWsza3NVaWorekJhejRaQ0w3MUJDNG84YWhINFdTU3p5WGh2THJucXRZUExMa1VqeGwvbDNoYTFnVG9UcFl4VTcvNjk3bFZkMm1MNEJiOVdQOWI3VThXRHo3M0h6ZDMyZDhJWGY4VmxkM1VGNmtwVVp2Q1FtczA0cmFPVkFmQ1FYc1VnM1BrYURnOFNIeGJqcTliUHpNL3MzN2Q4UzNFTjZtZjk5dzlXUm9SRkVueTM1ZEl2dlUzTzhjcWxiR2RyN3laVE55M2ZBdS8vZkRwNDFzR2toOTRYYno1UVh2VVRuY2FxK0lwVWNqSSszVnlEMTZ6N1RCb3lKbEgvbVcrVmdhelRSL1dLQzFIdzhBelVsZTc5U2V5Y253d1FsQ1hvTi9yUmlLb2pmMFFBVGdGT0ZhbVB3Zmw0UFRRTkJaN1E2T01PVS9UYW43d01pMFVLS05NTTQ2SDA3YTdUTEU5dnQwWjZ2RDZ3T0JBWi9XY2FLeWQ2MXFxb2xDK2NOcFl0OWJaYnVXL2hHSzBmQkMrSnpGZmhubGw4NXRmZ2l2blRUSHJMR1V6MXJOMTZ5eTJ2aWljRnNONStFdUQ0SkxpSmZVUy9MVmhGMDBJYzVaY05PTUk0MHFGTWE3R1RZUHRVdFpIcmw2L2RuSmlkWEZvSUJYcllaeGhxU3Q1MWJXNnkvWjd6ZytzdUU0ZW9yRDZEYmJVSzBnMytrOW9PSWdGWXd5Uzl2SXIxanZlTUxBNEJkK2JMV3ZCTnRPSVVjcHk1ZzNyVlFiV096bHBITGRlNUYzVFlSS3VNRXpNRndCZGsrRWZ4SVgreTErRTd4M2s0aHRUOGRqYW1KQ0NNd040bnYvZnZvamhFWlJLSmV2OHRUR3VqOGs5bFBpcW1VWENIOGM0cDN2TU5ZSDA1elF1YWt3Ym1yeXdKdVVnaHFDT2ZqZnlGeW12RGZ6SndUS3VGekdqYVJwZENVNTJQUW5iYllmMFlkWlhUUmhodGtSODIySE53bTN2SG11WUIrYTRYb0gzYjQ1WDljcmNmLzN6ZEtoK3ZXdHFhdGZVU3BJMzQ1Sk40VFdMdnBVb0Q4bGo4T1VBWllPK0JWdU5ESkdhd28rcCtoT2dCeEQwNGxvUUNvZDF6emZockhuQ2F2L3dGMnhrNkJ2ODhackwvVGhHMllaSmhjc2ZjRVZtQzhEY3pIUGJVUDdONWFqYjZLbVMyaDNuN29YNTR6VjVBOGdGQ0ZySkFjZ2R5QXFwVXIzUVFpckFmRW1PdHdwMXdDaGFvWTZMNlRIM3orZnFCZFBPQ0VZTURlMk1iT1Y4bFpRUW8wdmhEMm5RcGJ5alBFQlU1SUROcFgzNzRuSXJraGh6aEhJRGJyNHg2WXdWd1VqTWs0V2sva1pNamlmRHlTY2lnNTVnUkhob3Z6Tm0razd3bmhqTk1TYmpFWjdHcnRCWG9yNVRuUmp4VUJEdUlLSjM2bm9zQkpMaGNNZ3hsb2lBZVp6bzYvV2w5UlBGbUhPeW9kOExmZjhuU1VGd0RFYWVnSmZGWmMrVFc2NU5rb1dZYy85RCt1OXdWU2pmOWtlVDNERHk2bElLaTRtRFhzWVZjZ3g4WWNTQU1oV1p1MWJKMmprV0JBRk1EdUtwbHFLWndoZ05JUWYyOXFMcjl0ekR1SGo0ZjBiOHVZUmYrcXU5TU80T3AzTXVnRUhvL1dPRndhdlhvQXYzeU4rRmhJRCtWTVNmeVBtbDFtYUxmREUrbDBmc3hOTXJhZlp6TkRTS1R2bkY4NVRCeitMbk5IaStZdTJobjY3VnlnYWN4cHJyYUNkZU5sRUY4OGZBaDJYTGZuY0FZL0FnQWxlRGQxMy9KazNYNHdmakI0aEdNSENHL2pjamE1QzU5aFpHd1BMdUlNMHZSRUllaGtjNjcyQkVFUUZhUW4vL0F1QmFhZDl4WEc1Mk5VSlErcU1TWUtwbUR5SzdmTVh2VUdHT0FTMFR4blFHNGoxQkQxdkhZaXdteDhtU3R1emJMZnVZNDhMRnlpOUkvRzEwbzcvQk51ZVkwWmYwaENTUmY1TE1yWWFlTVByQlJoNjVZeU9adnVtbm1hNHkyc2l4WW40Z0dlc3pkSTlJNjBPZHRiU3h0WnRiWnBCcGpRWlhiRjJuSlkyL0hiNzBOL0dMMWtxRCtvSGVrMDY3MkRmVThzd1pDVCtxdEJlY2RsWEZJMXdyZndaL2NxS0xTK0NudnpvQi9aU095UUhKOGh0Yjc5TlgxbjE4TitzclVyRnUwS1B2OUJQckh2UFk5RFZVZzY5aTZCMjJ4S2dHTXpSdmdhSWxTZ2RRS2RmSUE4S0RaSUFXQ2pEN2tRZWtHMW41aURGdUFIVGpRRHdrR1dzWG9UUnd5dE9WRXVnRWNENnptUDZDYVloMFE1R2U4aE95YmVQR1J4RVhET1p1Lyt4bmJ4Y3l1YjZlRGJ0M2IranA2MDBQajZSNkRSYTM2dXI5MDlkUDlFcXFJM2puSDkwWmRLaUNzM1oxelNsWWNrRHN0NGY4em5ZTUI5OXRYL21hN2xMTlVxeDhWN0c5THRzb3czaldlTWIwaDlyMkhQMGgyYlRuTUhjVm90RGZCVmxIYXFRcUFNekNENm5NT20wa0orQVBCUWdrWnlQc053cVc5NFIzU3RMT01QOXRDZEVScW9aMitiK2l1Q3JFOVNGZUNIdGRabXlQZXU3NWFzamNpNXJJNXREcjM2NGMrLzVmUEZiNWR2UEN4eW96ZTNkdnFUNW5tUHE3WnZmdW5iMUxQOWZZUFRhMit4ZW0vOE4wV0pyYW56VDBYYUxQejlibEtxSmNyaGsvdDBFUTkwL1VrSTVTNVF5anpPZFQvdHUwMjRUais0Wlg2Mi9GbXJFNHpKdndjZjFGQXlZSmNOR2YycjhZQnNzUmkrK0prK1Rxa2YyTHl3YzdmTG4zbnFOcjRKVzIvT0hpOTVxQzZYMFJiQkpHVEhMNVkrVGQvay9NRGp5MkhQdkU3dHhqQXpkOHZILzVXUG5WM3hGK2lmd3U5dkViY3NlVyt6OSt3OEJqdWQyZmlDMC90dnJWZDBtWEg0QmwrNmhOQmVRZUxndGxBMmxuVVVIRC83TDYwOXhQMWJmZlp0UkJsVzNlTmhtRmlISTFZeTJGWU1seDVrR1h1TDQzT3BUbzh4cWMyL2ZKY3c0d2psY05TUmtWWE1QTmx0WmxLMldhOTNUYTk3WHpucmJ0Tno5K2x2d2QycHRiTnZ1Q1FzVmM0b3M1ME9aT205M01nZTZ6TzR2dzlCMWdtdFlxVHVHcW0vYVBXdFpFV09xSUhMVGhEMXRIVkhzZm9HN3pqSGo1KzJwV1ZmOGZMQ0xhTWdCNG5HTmdaR0JnWUpTY3FjM2RJeG5QYi9PVmdadFpBU2pDY1A2bWZoYUMvaitiV1Frc3pzSEFCQklGQUJ0cUNjdDRuR05nWkdCZ1Z2Zy9tOEdEdVlVQkNKaVZHQmdaVU1GREFFeDJBNVVBQUhpY1kxUmdrR0lBQWtZdUJnWm1CZnlZS1lJNE9SQWJtYzg0Z1RoellUU3llbngySXB1UHl3NTB0OUFMWTdNVDNaOUU0eFpNLzFMRGpjVEdDMUZoMmdJVmEwSEk0d3NEdk9idkljNGRHUDc1UXJ3ZjZKMFdVTUs2QlpYTndBQUFPQThxTEFBQUFBQVdBQllBRmdBNEFGb0FlQUNZQU1BQTVnRU9BVXdCWWdHSUFhNEIwZ0gyQWd3Q0lnSTRBazRDWkFKNkFvNEN0Z01BQXlJRFZBTjJBOGdEN2dRTUJGWUVmZ1NxQk9nRS9BVXNCVDRGWGdXY0JkWUdJQVpZQnVJSEZnZFlCNVFINUFmMENBWUlHQWdxQ0hnSWxnaTJDTXdJNGdqNENRNEpNZ2xlQ1pvSnpBb1FDa1lLYWdxZ0NzWUxEQXNxQzBnTGFBdUdDL29NRWd4TURHNE1vQXpVRFFZTllBMkFEWndOeEEzeURpUU9kZzZTRHF3TzFnNytEellQVGc5bUQ0UVBvQS9LRUFZUU9CQldFSFlRbEJDeUVOWVJLQkZzRVlnUnpCSHFFZ1lTS0JKd0VwSVN0aE0rRTJBVDBoUWFGRVlVZ0JUSUZRQVZIaFU0RlZvVmdCWElGZ1FXSmhaTUZuSVdtQmJJRnZ3WEloZVlHQllZbUJqUUdTZ1pQQmxnR1lJWnFoblNHZjRhUEJwb0dyUWF6QnJlR3ZRYkRCc2tHendiVkJ0a0czNGJuQnZ3SEFBY09CeFlISUFjc2h6K0hSb2RaQjJNSGJvZDdCNGlIa0FlWEI2VUhzSWU3aDhpSDNZZndDQStJSGdnb2lDK0lOWWc4Q0VlSVZ3aGtpSEVJZUlpR2lKQ0ltQWlpaUswSXZ3akdDT1FJOElqNGlRT0pFb2tjQ1NjSk1ZaytpVTBKWG9sbkNYYUpnUW1SaWFZSnRnbS9pYytKMkluZUNlb0o5d29HQ2hHS0hBb3dpa01BQUI0bkdOZ1pHQmdlTVNRd1NEQUFBSk1ZTElZaU0yNGMwQk1BQ3lZQW40QUFIaWNmWkMvU2tNeEdNVlArZytxMHNIQnlTR0RReDF1Mm5zUkNuZTBVTFJMdTlSVitpZTNEWlRjY20rZ2RIQVRYOEkzY1BBaDNId0FKNS9BelVmdzNHc29GTUdFTDk4dkp5Zkpsd0JvNFJVQ3YrMGFUNTRGNnZqd1hFRURYNTZydUJDeDV4cWFJdmRjUjBzOGUyN2dXTHpSS1dwTnpoN0xYUVVMSE9IZGN3VW4rUFJjeFEyK1BkZHdLdTQ5MTNFdUhqdzNjQ1plMEVjR2pTa2N4d1VrWnRoeEhFTmh5SkFZd1NLbHg1QzNIQjFXcEFFMVN4NlVhMHZ1bFlqbzd6SzM2WERzRzhUb3NDZmVtK3k5Q2psbmlxcW1mZ24wTXoxMWVpRm5PemxXUXlWSE5zMk0zQnEza29QVXVrR2FMYldNVkZlMlY4NXQ0azRub1pvVXFzb1RaYlhqR2JlWWx4Zmx4SGxxbVl4WGlneER6VEQvVjNuTW1KU3J4VHZYNVkrRVhnOFJvTWVJNkF4eHhZTU9Db3ZseERyajFub1Jrc09nRjBUZGtLNi94MkZ2Qk82b1phellsRVVWbHlnZmtvczZ5MDFxWmFqWU9VLzVvNXEyNFBCaDZVYmJ3TC91QjZqdmJRRUFBQUI0bkcyUVF4ZGxSd0FHWDMyeGJkdkpiWGZIR01hMmJ2ZDlMN1k1U1NhMmpZbHQyN2FUYmY1SU1pZmJwTTZwVmUxcXBORy8vRDE3WkVmL3gxOXpaU1RFUE16TGZNelBBaXpJUWl6TUlxTXBvNm1qYWFQcG94bWptU3pLWWl6T0VpekpVaXpOTWl6TGNpelBDcXpJU3F6TUtxekthcXpPR3F6Sldxek5PcXpMZXF6UEJteklSbXpNSm16S1ptek9GblFZTEE1UElKTElGTFprSzdabUc3WmxPN1puQjNaa0o2WXdsV2xNWndZejJabGQySlhkMkowOTJKTzkySnQ5MkpmOTJKOERPSkNET0poRE9KVERPSndqT0pLZVNtTmd6SVNqT0pwak9KYmpPSjRUT0pHVE9KbFRPSlhUT0owek9KT3pPSnR6T0pmek9KOEx1SkJaWE1URlhNSnNMdVV5THVjS3J1UXFydVlhcnVVNnJ1Y0didVFtYnVZV2J1VTJidWNPN3VRdTd1WWU3dVUrN3VjQjV2QWdEL0V3ai9Bb2ovRTRUL0RrYUE1UDhUVFA4Q3pQOFR3djhDSXY4VEt2OENxdjhUcHY4Q1p2OFRidjhDN3Y4VDRmOENFZjhUR2Y4Q21mOFRsZjhDVmY4VFhmOEMzZjhUMC84Q00vOFRPLzhDdS84VHQvOE9mb3YxTmxPaGtqWTJXY2pKY0pNbEVteVdTWnViV1hxVEpOWnBBWnkweGtPMWtqYTJXZHJKY05zbEUyeVdiWkl0dkxWdGttTzhpT1pTZHluWnlSczNKT3pzc0Z1U2lYNUxKY2tldmxxbHlURytUR2NoUDVUdDdJVzNrbjcrV0RmSlJQOGxtK3lQZnlWYjdKRC9KaitZbENwMkFVcklKVDhBcEJJU29raGF4UUZIcUZxdEFVQm9XeHdrU3hVelNLVnRFcGVzV2dHQldUWWxZc2lyMWlWV3lLZytKWWNhTFVLUmtscStTVXZGSlFpa3BKS1NzVnBWNnBLaldsUVdtc05GSHVsSTJ5VlhiS1hqa29SK1drbkpXTGNxOWNsWnZ5b0R4V25xaDBLa2JGcWpnVnJ4SlVva3BTeVNwRnBWZXBLazFsVUJtclROUjM2bzE2cTk2cDkrcUQrcWcrcWMvcWkvcGVmVlhmMUEvcUo2cWRxbEcxcWs3VnF3YlZxSnBVczJwUjdWV3JhbE1kVk1lcUU3Vk96YWhaTmFmbTFZSmFWRXRxV2EybzlXcFZyYWtOYW1PMWlZWk9nOUZnTlRnTlhrUFFFRFVrRFZsRDBkQnJxQnFhaGtIRCtCL3g2OU43ZUp4ajhON0JjQ0lvWWlNalkxL2tCc2FkSEF3Y0RNa0ZHeGxZblRZeU1HaEJhQTRVZWljREF3TW5Nb3Vad1dXakNtTkhZTVFHaDQ2SWpjd3BMaHZWUUx4ZEhBME1qQ3dPSGNraEVTQWxrVUN3a1lGSGF3ZmovOVlOTEwwYm1SaGNBQWZUSXJnQUFBQT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLndvZmZcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9vcGVuLWljb25pYy9mb250L2ZvbnRzL29wZW4taWNvbmljLndvZmZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IENvbXBvbmVudCwgY2xvbmVFbGVtZW50LCBoLCBvcHRpb25zLCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuXG52YXIgdmVyc2lvbiA9ICcxNS4xLjAnOyAvLyB0cmljayBsaWJyYXJpZXMgdG8gdGhpbmsgd2UgYXJlIHJlYWN0XG5cbnZhciBFTEVNRU5UUyA9ICdhIGFiYnIgYWRkcmVzcyBhcmVhIGFydGljbGUgYXNpZGUgYXVkaW8gYiBiYXNlIGJkaSBiZG8gYmlnIGJsb2NrcXVvdGUgYm9keSBiciBidXR0b24gY2FudmFzIGNhcHRpb24gY2l0ZSBjb2RlIGNvbCBjb2xncm91cCBkYXRhIGRhdGFsaXN0IGRkIGRlbCBkZXRhaWxzIGRmbiBkaWFsb2cgZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWQgaGVhZGVyIGhncm91cCBociBodG1sIGkgaWZyYW1lIGltZyBpbnB1dCBpbnMga2JkIGtleWdlbiBsYWJlbCBsZWdlbmQgbGkgbGluayBtYWluIG1hcCBtYXJrIG1lbnUgbWVudWl0ZW0gbWV0YSBtZXRlciBuYXYgbm9zY3JpcHQgb2JqZWN0IG9sIG9wdGdyb3VwIG9wdGlvbiBvdXRwdXQgcCBwYXJhbSBwaWN0dXJlIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbCBzb3VyY2Ugc3BhbiBzdHJvbmcgc3R5bGUgc3ViIHN1bW1hcnkgc3VwIHRhYmxlIHRib2R5IHRkIHRleHRhcmVhIHRmb290IHRoIHRoZWFkIHRpbWUgdGl0bGUgdHIgdHJhY2sgdSB1bCB2YXIgdmlkZW8gd2JyIGNpcmNsZSBjbGlwUGF0aCBkZWZzIGVsbGlwc2UgZyBpbWFnZSBsaW5lIGxpbmVhckdyYWRpZW50IG1hc2sgcGF0aCBwYXR0ZXJuIHBvbHlnb24gcG9seWxpbmUgcmFkaWFsR3JhZGllbnQgcmVjdCBzdG9wIHN2ZyB0ZXh0IHRzcGFuJy5zcGxpdCgnICcpO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2whPT0ndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHwgMHhlYWM3O1xuXG52YXIgQ09NUE9ORU5UX1dSQVBQRVJfS0VZID0gdHlwZW9mIFN5bWJvbCE9PSd1bmRlZmluZWQnID8gU3ltYm9sLmZvcignX19wcmVhY3RDb21wYXRXcmFwcGVyJykgOiAnX19wcmVhY3RDb21wYXRXcmFwcGVyJztcblxuLy8gZG9uJ3QgYXV0b2JpbmQgdGhlc2UgbWV0aG9kcyBzaW5jZSB0aGV5IGFscmVhZHkgaGF2ZSBndWFyYW50ZWVkIGNvbnRleHQuXG52YXIgQVVUT0JJTkRfQkxBQ0tMSVNUID0ge1xuXHRjb25zdHJ1Y3RvcjogMSxcblx0cmVuZGVyOiAxLFxuXHRzaG91bGRDb21wb25lbnRVcGRhdGU6IDEsXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IDEsXG5cdGNvbXBvbmVudFdpbGxVcGRhdGU6IDEsXG5cdGNvbXBvbmVudERpZFVwZGF0ZTogMSxcblx0Y29tcG9uZW50V2lsbE1vdW50OiAxLFxuXHRjb21wb25lbnREaWRNb3VudDogMSxcblx0Y29tcG9uZW50V2lsbFVubW91bnQ6IDEsXG5cdGNvbXBvbmVudERpZFVubW91bnQ6IDFcbn07XG5cblxudmFyIENBTUVMX1BST1BTID0gL14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcHxjb2xvcnxmaWxsfGZsb29kfGZvbnR8Z2x5cGh8aG9yaXp8bWFya2VyfG92ZXJsaW5lfHBhaW50fHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dHx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KVtBLVpdLztcblxuXG52YXIgQllQQVNTX0hPT0sgPSB7fTtcblxuLypnbG9iYWwgcHJvY2VzcyovXG52YXIgREVWID0gdHlwZW9mIHByb2Nlc3M9PT0ndW5kZWZpbmVkJyB8fCAhcHJvY2Vzcy5lbnYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbic7XG5cbi8vIGEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBub3RoaW5nLiBVc2VkIHRvIHJlcGxhY2UgY29tcG9uZW50cyBmb3IgdW5tb3VudENvbXBvbmVudEF0Tm9kZS5cbmZ1bmN0aW9uIEVtcHR5Q29tcG9uZW50KCkgeyByZXR1cm4gbnVsbDsgfVxuXG5cblxuLy8gbWFrZSByZWFjdCB0aGluayB3ZSdyZSByZWFjdC5cbnZhciBWTm9kZSA9IGgoJ2EnLCBudWxsKS5jb25zdHJ1Y3RvcjtcblZOb2RlLnByb3RvdHlwZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblZOb2RlLnByb3RvdHlwZS5wcmVhY3RDb21wYXRVcGdyYWRlZCA9IGZhbHNlO1xuVk5vZGUucHJvdG90eXBlLnByZWFjdENvbXBhdE5vcm1hbGl6ZWQgPSBmYWxzZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZOb2RlLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vZGVOYW1lOyB9LFxuXHRzZXQ6IGZ1bmN0aW9uKHYpIHsgdGhpcy5ub2RlTmFtZSA9IHY7IH0sXG5cdGNvbmZpZ3VyYWJsZTp0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZOb2RlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzOyB9LFxuXHRzZXQ6IGZ1bmN0aW9uKHYpIHsgdGhpcy5hdHRyaWJ1dGVzID0gdjsgfSxcblx0Y29uZmlndXJhYmxlOnRydWVcbn0pO1xuXG5cblxudmFyIG9sZEV2ZW50SG9vayA9IG9wdGlvbnMuZXZlbnQ7XG5vcHRpb25zLmV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcblx0aWYgKG9sZEV2ZW50SG9vaykgeyBlID0gb2xkRXZlbnRIb29rKGUpOyB9XG5cdGUucGVyc2lzdCA9IE9iamVjdDtcblx0ZS5uYXRpdmVFdmVudCA9IGU7XG5cdHJldHVybiBlO1xufTtcblxuXG52YXIgb2xkVm5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSBmdW5jdGlvbiAodm5vZGUpIHtcblx0aWYgKCF2bm9kZS5wcmVhY3RDb21wYXRVcGdyYWRlZCkge1xuXHRcdHZub2RlLnByZWFjdENvbXBhdFVwZ3JhZGVkID0gdHJ1ZTtcblxuXHRcdHZhciB0YWcgPSB2bm9kZS5ub2RlTmFtZSxcblx0XHRcdGF0dHJzID0gdm5vZGUuYXR0cmlidXRlcyA9IGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyk7XG5cblx0XHRpZiAodHlwZW9mIHRhZz09PSdmdW5jdGlvbicpIHtcblx0XHRcdGlmICh0YWdbQ09NUE9ORU5UX1dSQVBQRVJfS0VZXT09PXRydWUgfHwgKHRhZy5wcm90b3R5cGUgJiYgJ2lzUmVhY3RDb21wb25lbnQnIGluIHRhZy5wcm90b3R5cGUpKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAmJiBTdHJpbmcodm5vZGUuY2hpbGRyZW4pPT09JycpIHsgdm5vZGUuY2hpbGRyZW4gPSB1bmRlZmluZWQ7IH1cblx0XHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuKSB7IGF0dHJzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47IH1cblxuXHRcdFx0XHRpZiAoIXZub2RlLnByZWFjdENvbXBhdE5vcm1hbGl6ZWQpIHtcblx0XHRcdFx0XHRub3JtYWxpemVWTm9kZSh2bm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFuZGxlQ29tcG9uZW50Vk5vZGUodm5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAmJiBTdHJpbmcodm5vZGUuY2hpbGRyZW4pPT09JycpIHsgdm5vZGUuY2hpbGRyZW4gPSB1bmRlZmluZWQ7IH1cblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbikgeyBhdHRycy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuOyB9XG5cblx0XHRcdGlmIChhdHRycy5kZWZhdWx0VmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhdHRycy52YWx1ZSAmJiBhdHRycy52YWx1ZSE9PTApIHtcblx0XHRcdFx0XHRhdHRycy52YWx1ZSA9IGF0dHJzLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgYXR0cnMuZGVmYXVsdFZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRoYW5kbGVFbGVtZW50Vk5vZGUodm5vZGUsIGF0dHJzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAob2xkVm5vZGVIb29rKSB7IG9sZFZub2RlSG9vayh2bm9kZSk7IH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbXBvbmVudFZOb2RlKHZub2RlKSB7XG5cdHZhciB0YWcgPSB2bm9kZS5ub2RlTmFtZSxcblx0XHRhID0gdm5vZGUuYXR0cmlidXRlcztcblxuXHR2bm9kZS5hdHRyaWJ1dGVzID0ge307XG5cdGlmICh0YWcuZGVmYXVsdFByb3BzKSB7IGV4dGVuZCh2bm9kZS5hdHRyaWJ1dGVzLCB0YWcuZGVmYXVsdFByb3BzKTsgfVxuXHRpZiAoYSkgeyBleHRlbmQodm5vZGUuYXR0cmlidXRlcywgYSk7IH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudFZOb2RlKHZub2RlLCBhKSB7XG5cdHZhciBzaG91bGRTYW5pdGl6ZSwgYXR0cnMsIGk7XG5cdGlmIChhKSB7XG5cdFx0Zm9yIChpIGluIGEpIHsgaWYgKChzaG91bGRTYW5pdGl6ZSA9IENBTUVMX1BST1BTLnRlc3QoaSkpKSB7IGJyZWFrOyB9IH1cblx0XHRpZiAoc2hvdWxkU2FuaXRpemUpIHtcblx0XHRcdGF0dHJzID0gdm5vZGUuYXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0Zm9yIChpIGluIGEpIHtcblx0XHRcdFx0aWYgKGEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRhdHRyc1sgQ0FNRUxfUFJPUFMudGVzdChpKSA/IGkucmVwbGFjZSgvKFtBLVowLTldKS8sICctJDEnKS50b0xvd2VyQ2FzZSgpIDogaSBdID0gYVtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cblxuLy8gcHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG5mdW5jdGlvbiByZW5kZXIkMSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHR2YXIgcHJldiA9IHBhcmVudCAmJiBwYXJlbnQuX3ByZWFjdENvbXBhdFJlbmRlcmVkICYmIHBhcmVudC5fcHJlYWN0Q29tcGF0UmVuZGVyZWQuYmFzZTtcblxuXHQvLyBpZ25vcmUgaW1wb3NzaWJsZSBwcmV2aW91cyByZW5kZXJzXG5cdGlmIChwcmV2ICYmIHByZXYucGFyZW50Tm9kZSE9PXBhcmVudCkgeyBwcmV2ID0gbnVsbDsgfVxuXG5cdC8vIGRlZmF1bHQgdG8gZmlyc3QgRWxlbWVudCBjaGlsZFxuXHRpZiAoIXByZXYgJiYgcGFyZW50KSB7IHByZXYgPSBwYXJlbnQuZmlyc3RFbGVtZW50Q2hpbGQ7IH1cblxuXHQvLyByZW1vdmUgdW5hZmZlY3RlZCBzaWJsaW5nc1xuXHRmb3IgKHZhciBpPXBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0hPT1wcmV2KSB7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmNoaWxkTm9kZXNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdHZhciBvdXQgPSByZW5kZXIodm5vZGUsIHBhcmVudCwgcHJldik7XG5cdGlmIChwYXJlbnQpIHsgcGFyZW50Ll9wcmVhY3RDb21wYXRSZW5kZXJlZCA9IG91dCAmJiAob3V0Ll9jb21wb25lbnQgfHwgeyBiYXNlOiBvdXQgfSk7IH1cblx0aWYgKHR5cGVvZiBjYWxsYmFjaz09PSdmdW5jdGlvbicpIHsgY2FsbGJhY2soKTsgfVxuXHRyZXR1cm4gb3V0ICYmIG91dC5fY29tcG9uZW50IHx8IG91dDtcbn1cblxuXG52YXIgQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24gKCkge307XG5cbkNvbnRleHRQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5wcm9wcy5jb250ZXh0O1xufTtcbkNvbnRleHRQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlblswXTtcbn07XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgdm5vZGUsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcblx0dmFyIHdyYXAgPSBoKENvbnRleHRQcm92aWRlciwgeyBjb250ZXh0OiBwYXJlbnRDb21wb25lbnQuY29udGV4dCB9LCB2bm9kZSk7XG5cdHZhciByZW5kZXJDb250YWluZXIgPSByZW5kZXIkMSh3cmFwLCBjb250YWluZXIpO1xuXHR2YXIgY29tcG9uZW50ID0gcmVuZGVyQ29udGFpbmVyLl9jb21wb25lbnQgfHwgcmVuZGVyQ29udGFpbmVyLmJhc2U7XG5cdGlmIChjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCwgcmVuZGVyQ29udGFpbmVyKTsgfVxuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG5cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XG5cdHZhciBleGlzdGluZyA9IGNvbnRhaW5lci5fcHJlYWN0Q29tcGF0UmVuZGVyZWQgJiYgY29udGFpbmVyLl9wcmVhY3RDb21wYXRSZW5kZXJlZC5iYXNlO1xuXHRpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcucGFyZW50Tm9kZT09PWNvbnRhaW5lcikge1xuXHRcdHJlbmRlcihoKEVtcHR5Q29tcG9uZW50KSwgY29udGFpbmVyLCBleGlzdGluZyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cblxudmFyIEFSUiA9IFtdO1xuXG4vLyBUaGlzIEFQSSBpcyBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGZvciBQcmVhY3QsIHNvIGl0J3MgYmFzaWNhbGx5IHBhc3N0aHJvdWdoLlxudmFyIENoaWxkcmVuID0ge1xuXHRtYXA6IGZ1bmN0aW9uKGNoaWxkcmVuLCBmbiwgY3R4KSB7XG5cdFx0aWYgKGNoaWxkcmVuID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRjaGlsZHJlbiA9IENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChjdHggJiYgY3R4IT09Y2hpbGRyZW4pIHsgZm4gPSBmbi5iaW5kKGN0eCk7IH1cblx0XHRyZXR1cm4gY2hpbGRyZW4ubWFwKGZuKTtcblx0fSxcblx0Zm9yRWFjaDogZnVuY3Rpb24oY2hpbGRyZW4sIGZuLCBjdHgpIHtcblx0XHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdGNoaWxkcmVuID0gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG5cdFx0aWYgKGN0eCAmJiBjdHghPT1jaGlsZHJlbikgeyBmbiA9IGZuLmJpbmQoY3R4KTsgfVxuXHRcdGNoaWxkcmVuLmZvckVhY2goZm4pO1xuXHR9LFxuXHRjb3VudDogZnVuY3Rpb24oY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoIHx8IDA7XG5cdH0sXG5cdG9ubHk6IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG5cdFx0Y2hpbGRyZW4gPSBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoIT09MSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLm9ubHkoKSBleHBlY3RzIG9ubHkgb25lIGNoaWxkLicpOyB9XG5cdFx0cmV0dXJuIGNoaWxkcmVuWzBdO1xuXHR9LFxuXHR0b0FycmF5OiBmdW5jdGlvbihjaGlsZHJlbikge1xuXHRcdGlmIChjaGlsZHJlbiA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuXHRcdHJldHVybiBBUlIuY29uY2F0KGNoaWxkcmVuKTtcblx0fVxufTtcblxuXG4vKiogVHJhY2sgY3VycmVudCByZW5kZXIoKSBjb21wb25lbnQgZm9yIHJlZiBhc3NpZ25tZW50ICovXG52YXIgY3VycmVudENvbXBvbmVudDtcblxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5KHR5cGUpIHtcblx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbn1cblxuXG52YXIgRE9NID0ge307XG5mb3IgKHZhciBpPUVMRU1FTlRTLmxlbmd0aDsgaS0tOyApIHtcblx0RE9NW0VMRU1FTlRTW2ldXSA9IGNyZWF0ZUZhY3RvcnkoRUxFTUVOVFNbaV0pO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlVG9WTm9kZXMoYXJyLCBvZmZzZXQpIHtcblx0Zm9yICh2YXIgaT1vZmZzZXQgfHwgMDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgb2JqID0gYXJyW2ldO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdHVwZ3JhZGVUb1ZOb2RlcyhvYmopO1xuXHRcdH1cblx0XHRlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaj09PSdvYmplY3QnICYmICFpc1ZhbGlkRWxlbWVudChvYmopICYmICgob2JqLnByb3BzICYmIG9iai50eXBlKSB8fCAob2JqLmF0dHJpYnV0ZXMgJiYgb2JqLm5vZGVOYW1lKSB8fCBvYmouY2hpbGRyZW4pKSB7XG5cdFx0XHRhcnJbaV0gPSBjcmVhdGVFbGVtZW50KG9iai50eXBlIHx8IG9iai5ub2RlTmFtZSwgb2JqLnByb3BzIHx8IG9iai5hdHRyaWJ1dGVzLCBvYmouY2hpbGRyZW4pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpc1N0YXRlbGVzc0NvbXBvbmVudChjKSB7XG5cdHJldHVybiB0eXBlb2YgYz09PSdmdW5jdGlvbicgJiYgIShjLnByb3RvdHlwZSAmJiBjLnByb3RvdHlwZS5yZW5kZXIpO1xufVxuXG5cbi8vIHdyYXBzIHN0YXRlbGVzcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMgaW4gYSBQcm9wVHlwZXMgdmFsaWRhdG9yXG5mdW5jdGlvbiB3cmFwU3RhdGVsZXNzQ29tcG9uZW50KFdyYXBwZWRDb21wb25lbnQpIHtcblx0cmV0dXJuIGNyZWF0ZUNsYXNzKHtcblx0XHRkaXNwbGF5TmFtZTogV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUsXG5cdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBXcmFwcGVkQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG5mdW5jdGlvbiBzdGF0ZWxlc3NDb21wb25lbnRIb29rKEN0b3IpIHtcblx0dmFyIFdyYXBwZWQgPSBDdG9yW0NPTVBPTkVOVF9XUkFQUEVSX0tFWV07XG5cdGlmIChXcmFwcGVkKSB7IHJldHVybiBXcmFwcGVkPT09dHJ1ZSA/IEN0b3IgOiBXcmFwcGVkOyB9XG5cblx0V3JhcHBlZCA9IHdyYXBTdGF0ZWxlc3NDb21wb25lbnQoQ3Rvcik7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWQsIENPTVBPTkVOVF9XUkFQUEVSX0tFWSwgeyBjb25maWd1cmFibGU6dHJ1ZSwgdmFsdWU6dHJ1ZSB9KTtcblx0V3JhcHBlZC5kaXNwbGF5TmFtZSA9IEN0b3IuZGlzcGxheU5hbWU7XG5cdFdyYXBwZWQucHJvcFR5cGVzID0gQ3Rvci5wcm9wVHlwZXM7XG5cdFdyYXBwZWQuZGVmYXVsdFByb3BzID0gQ3Rvci5kZWZhdWx0UHJvcHM7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEN0b3IsIENPTVBPTkVOVF9XUkFQUEVSX0tFWSwgeyBjb25maWd1cmFibGU6dHJ1ZSwgdmFsdWU6V3JhcHBlZCB9KTtcblxuXHRyZXR1cm4gV3JhcHBlZDtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuXHR2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHR3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG5cdHVwZ3JhZGVUb1ZOb2RlcyhhcmdzLCAyKTtcblx0cmV0dXJuIG5vcm1hbGl6ZVZOb2RlKGguYXBwbHkodm9pZCAwLCBhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUodm5vZGUpIHtcblx0dm5vZGUucHJlYWN0Q29tcGF0Tm9ybWFsaXplZCA9IHRydWU7XG5cblx0YXBwbHlDbGFzc05hbWUodm5vZGUpO1xuXG5cdGlmIChpc1N0YXRlbGVzc0NvbXBvbmVudCh2bm9kZS5ub2RlTmFtZSkpIHtcblx0XHR2bm9kZS5ub2RlTmFtZSA9IHN0YXRlbGVzc0NvbXBvbmVudEhvb2sodm5vZGUubm9kZU5hbWUpO1xuXHR9XG5cblx0dmFyIHJlZiA9IHZub2RlLmF0dHJpYnV0ZXMucmVmLFxuXHRcdHR5cGUgPSByZWYgJiYgdHlwZW9mIHJlZjtcblx0aWYgKGN1cnJlbnRDb21wb25lbnQgJiYgKHR5cGU9PT0nc3RyaW5nJyB8fCB0eXBlPT09J251bWJlcicpKSB7XG5cdFx0dm5vZGUuYXR0cmlidXRlcy5yZWYgPSBjcmVhdGVTdHJpbmdSZWZQcm94eShyZWYsIGN1cnJlbnRDb21wb25lbnQpO1xuXHR9XG5cblx0YXBwbHlFdmVudE5vcm1hbGl6YXRpb24odm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQkMShlbGVtZW50LCBwcm9wcykge1xuXHR2YXIgY2hpbGRyZW4gPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cdHdoaWxlICggbGVuLS0gPiAwICkgY2hpbGRyZW5bIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cblx0aWYgKCFpc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgeyByZXR1cm4gZWxlbWVudDsgfVxuXHR2YXIgZWxlbWVudFByb3BzID0gZWxlbWVudC5hdHRyaWJ1dGVzIHx8IGVsZW1lbnQucHJvcHM7XG5cdHZhciBub2RlID0gaChcblx0XHRlbGVtZW50Lm5vZGVOYW1lIHx8IGVsZW1lbnQudHlwZSxcblx0XHRlbGVtZW50UHJvcHMsXG5cdFx0ZWxlbWVudC5jaGlsZHJlbiB8fCBlbGVtZW50UHJvcHMgJiYgZWxlbWVudFByb3BzLmNoaWxkcmVuXG5cdCk7XG5cdC8vIE9ubHkgcHJvdmlkZSB0aGUgM3JkIGFyZ3VtZW50IGlmIG5lZWRlZC5cblx0Ly8gQXJndW1lbnRzIDMrIG92ZXJ3cml0ZSBlbGVtZW50LmNoaWxkcmVuIGluIHByZWFjdENsb25lRWxlbWVudFxuXHR2YXIgY2xvbmVBcmdzID0gW25vZGUsIHByb3BzXTtcblx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdGNsb25lQXJncy5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRlbHNlIGlmIChwcm9wcyAmJiBwcm9wcy5jaGlsZHJlbikge1xuXHRcdGNsb25lQXJncy5wdXNoKHByb3BzLmNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gbm9ybWFsaXplVk5vZGUoY2xvbmVFbGVtZW50LmFwcGx5KHZvaWQgMCwgY2xvbmVBcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuXHRyZXR1cm4gZWxlbWVudCAmJiAoKGVsZW1lbnQgaW5zdGFuY2VvZiBWTm9kZSkgfHwgZWxlbWVudC4kJHR5cGVvZj09PVJFQUNUX0VMRU1FTlRfVFlQRSk7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nUmVmUHJveHkobmFtZSwgY29tcG9uZW50KSB7XG5cdHJldHVybiBjb21wb25lbnQuX3JlZlByb3hpZXNbbmFtZV0gfHwgKGNvbXBvbmVudC5fcmVmUHJveGllc1tuYW1lXSA9IGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuXHRcdGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnJlZnMpIHtcblx0XHRcdGNvbXBvbmVudC5yZWZzW25hbWVdID0gcmVzb2x2ZWQ7XG5cdFx0XHRpZiAocmVzb2x2ZWQ9PT1udWxsKSB7XG5cdFx0XHRcdGRlbGV0ZSBjb21wb25lbnQuX3JlZlByb3hpZXNbbmFtZV07XG5cdFx0XHRcdGNvbXBvbmVudCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuXG5mdW5jdGlvbiBhcHBseUV2ZW50Tm9ybWFsaXphdGlvbihyZWYpIHtcblx0dmFyIG5vZGVOYW1lID0gcmVmLm5vZGVOYW1lO1xuXHR2YXIgYXR0cmlidXRlcyA9IHJlZi5hdHRyaWJ1dGVzO1xuXG5cdGlmICghYXR0cmlidXRlcyB8fCB0eXBlb2Ygbm9kZU5hbWUhPT0nc3RyaW5nJykgeyByZXR1cm47IH1cblx0dmFyIHByb3BzID0ge307XG5cdGZvciAodmFyIGkgaW4gYXR0cmlidXRlcykge1xuXHRcdHByb3BzW2kudG9Mb3dlckNhc2UoKV0gPSBpO1xuXHR9XG5cdGlmIChwcm9wcy5vbmRvdWJsZWNsaWNrKSB7XG5cdFx0YXR0cmlidXRlcy5vbmRibGNsaWNrID0gYXR0cmlidXRlc1twcm9wcy5vbmRvdWJsZWNsaWNrXTtcblx0XHRkZWxldGUgYXR0cmlidXRlc1twcm9wcy5vbmRvdWJsZWNsaWNrXTtcblx0fVxuXHQvLyBmb3IgKnRleHR1YWwgaW5wdXRzKiAoaW5jbCB0ZXh0YXJlYSksIG5vcm1hbGl6ZSBgb25DaGFuZ2VgIC0+IGBvbklucHV0YDpcblx0aWYgKHByb3BzLm9uY2hhbmdlICYmIChub2RlTmFtZT09PSd0ZXh0YXJlYScgfHwgKG5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT0naW5wdXQnICYmICEvXmZpbHxjaGV8cmFkL2kudGVzdChhdHRyaWJ1dGVzLnR5cGUpKSkpIHtcblx0XHR2YXIgbm9ybWFsaXplZCA9IHByb3BzLm9uaW5wdXQgfHwgJ29uaW5wdXQnO1xuXHRcdGlmICghYXR0cmlidXRlc1tub3JtYWxpemVkXSkge1xuXHRcdFx0YXR0cmlidXRlc1tub3JtYWxpemVkXSA9IG11bHRpaG9vayhbYXR0cmlidXRlc1tub3JtYWxpemVkXSwgYXR0cmlidXRlc1twcm9wcy5vbmNoYW5nZV1dKTtcblx0XHRcdGRlbGV0ZSBhdHRyaWJ1dGVzW3Byb3BzLm9uY2hhbmdlXTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBhcHBseUNsYXNzTmFtZSh2bm9kZSkge1xuXHR2YXIgYSA9IHZub2RlLmF0dHJpYnV0ZXMgfHwgKHZub2RlLmF0dHJpYnV0ZXMgPSB7fSk7XG5cdGNsYXNzTmFtZURlc2NyaXB0b3IuZW51bWVyYWJsZSA9ICdjbGFzc05hbWUnIGluIGE7XG5cdGlmIChhLmNsYXNzTmFtZSkgeyBhLmNsYXNzID0gYS5jbGFzc05hbWU7IH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcbn1cblxuXG52YXIgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbGFzczsgfSxcblx0c2V0OiBmdW5jdGlvbih2KSB7IHRoaXMuY2xhc3MgPSB2OyB9XG59O1xuXG5mdW5jdGlvbiBleHRlbmQoYmFzZSwgcHJvcHMpIHtcblx0dmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG5cdGZvciAodmFyIGk9MSwgb2JqID0gKHZvaWQgMCk7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKChvYmogPSBhcmd1bWVudHMkMVtpXSkpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0YmFzZVtrZXldID0gb2JqW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59XG5cblxuZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKHZhciBpIGluIGEpIHsgaWYgKCEoaSBpbiBiKSkgeyByZXR1cm4gdHJ1ZTsgfSB9XG5cdGZvciAodmFyIGkkMSBpbiBiKSB7IGlmIChhW2kkMV0hPT1iW2kkMV0pIHsgcmV0dXJuIHRydWU7IH0gfVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50KSB7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50LmJhc2UgfHwgY29tcG9uZW50O1xufVxuXG5cbmZ1bmN0aW9uIEYoKXt9XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzKG9iaikge1xuXHRmdW5jdGlvbiBjbChwcm9wcywgY29udGV4dCkge1xuXHRcdGJpbmRBbGwodGhpcyk7XG5cdFx0Q29tcG9uZW50JDEuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCwgQllQQVNTX0hPT0spO1xuXHRcdG5ld0NvbXBvbmVudEhvb2suY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XG5cdH1cblxuXHRvYmogPSBleHRlbmQoeyBjb25zdHJ1Y3RvcjogY2wgfSwgb2JqKTtcblxuXHQvLyBXZSBuZWVkIHRvIGFwcGx5IG1peGlucyBoZXJlIHNvIHRoYXQgZ2V0RGVmYXVsdFByb3BzIGlzIGNvcnJlY3RseSBtaXhlZFxuXHRpZiAob2JqLm1peGlucykge1xuXHRcdGFwcGx5TWl4aW5zKG9iaiwgY29sbGF0ZU1peGlucyhvYmoubWl4aW5zKSk7XG5cdH1cblx0aWYgKG9iai5zdGF0aWNzKSB7XG5cdFx0ZXh0ZW5kKGNsLCBvYmouc3RhdGljcyk7XG5cdH1cblx0aWYgKG9iai5wcm9wVHlwZXMpIHtcblx0XHRjbC5wcm9wVHlwZXMgPSBvYmoucHJvcFR5cGVzO1xuXHR9XG5cdGlmIChvYmouZGVmYXVsdFByb3BzKSB7XG5cdFx0Y2wuZGVmYXVsdFByb3BzID0gb2JqLmRlZmF1bHRQcm9wcztcblx0fVxuXHRpZiAob2JqLmdldERlZmF1bHRQcm9wcykge1xuXHRcdGNsLmRlZmF1bHRQcm9wcyA9IG9iai5nZXREZWZhdWx0UHJvcHMoKTtcblx0fVxuXG5cdEYucHJvdG90eXBlID0gQ29tcG9uZW50JDEucHJvdG90eXBlO1xuXHRjbC5wcm90b3R5cGUgPSBleHRlbmQobmV3IEYoKSwgb2JqKTtcblxuXHRjbC5kaXNwbGF5TmFtZSA9IG9iai5kaXNwbGF5TmFtZSB8fCAnQ29tcG9uZW50JztcblxuXHRyZXR1cm4gY2w7XG59XG5cblxuLy8gRmxhdHRlbiBhbiBBcnJheSBvZiBtaXhpbnMgdG8gYSBtYXAgb2YgbWV0aG9kIG5hbWUgdG8gbWl4aW4gaW1wbGVtZW50YXRpb25zXG5mdW5jdGlvbiBjb2xsYXRlTWl4aW5zKG1peGlucykge1xuXHR2YXIga2V5ZWQgPSB7fTtcblx0Zm9yICh2YXIgaT0wOyBpPG1peGlucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBtaXhpbiA9IG1peGluc1tpXTtcblx0XHRmb3IgKHZhciBrZXkgaW4gbWl4aW4pIHtcblx0XHRcdGlmIChtaXhpbi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBtaXhpbltrZXldPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHQoa2V5ZWRba2V5XSB8fCAoa2V5ZWRba2V5XT1bXSkpLnB1c2gobWl4aW5ba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBrZXllZDtcbn1cblxuXG4vLyBhcHBseSBhIG1hcHBpbmcgb2YgQXJyYXlzIG9mIG1peGluIG1ldGhvZHMgdG8gYSBjb21wb25lbnQgcHJvdG90eXBlXG5mdW5jdGlvbiBhcHBseU1peGlucyhwcm90bywgbWl4aW5zKSB7XG5cdGZvciAodmFyIGtleSBpbiBtaXhpbnMpIHsgaWYgKG1peGlucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0cHJvdG9ba2V5XSA9IG11bHRpaG9vayhcblx0XHRcdG1peGluc1trZXldLmNvbmNhdChwcm90b1trZXldIHx8IEFSUiksXG5cdFx0XHRrZXk9PT0nZ2V0RGVmYXVsdFByb3BzJyB8fCBrZXk9PT0nZ2V0SW5pdGlhbFN0YXRlJyB8fCBrZXk9PT0nZ2V0Q2hpbGRDb250ZXh0J1xuXHRcdCk7XG5cdH0gfVxufVxuXG5cbmZ1bmN0aW9uIGJpbmRBbGwoY3R4KSB7XG5cdGZvciAodmFyIGkgaW4gY3R4KSB7XG5cdFx0dmFyIHYgPSBjdHhbaV07XG5cdFx0aWYgKHR5cGVvZiB2PT09J2Z1bmN0aW9uJyAmJiAhdi5fX2JvdW5kICYmICFBVVRPQklORF9CTEFDS0xJU1QuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdChjdHhbaV0gPSB2LmJpbmQoY3R4KSkuX19ib3VuZCA9IHRydWU7XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gY2FsbE1ldGhvZChjdHgsIG0sIGFyZ3MpIHtcblx0aWYgKHR5cGVvZiBtPT09J3N0cmluZycpIHtcblx0XHRtID0gY3R4LmNvbnN0cnVjdG9yLnByb3RvdHlwZVttXTtcblx0fVxuXHRpZiAodHlwZW9mIG09PT0nZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIG0uYXBwbHkoY3R4LCBhcmdzKTtcblx0fVxufVxuXG5mdW5jdGlvbiBtdWx0aWhvb2soaG9va3MsIHNraXBEdXBsaWNhdGVzKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHR2YXIgcmV0O1xuXHRcdGZvciAodmFyIGk9MDsgaTxob29rcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHIgPSBjYWxsTWV0aG9kKHRoaXMkMSwgaG9va3NbaV0sIGFyZ3VtZW50cyQxKTtcblxuXHRcdFx0aWYgKHNraXBEdXBsaWNhdGVzICYmIHIhPW51bGwpIHtcblx0XHRcdFx0aWYgKCFyZXQpIHsgcmV0ID0ge307IH1cblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHIpIHsgaWYgKHIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdHJldFtrZXldID0gcltrZXldO1xuXHRcdFx0XHR9IH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiByIT09J3VuZGVmaW5lZCcpIHsgcmV0ID0gcjsgfVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufVxuXG5cbmZ1bmN0aW9uIG5ld0NvbXBvbmVudEhvb2socHJvcHMsIGNvbnRleHQpIHtcblx0cHJvcHNIb29rLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR0aGlzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBtdWx0aWhvb2soW3Byb3BzSG9vaywgdGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHx8ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJ10pO1xuXHR0aGlzLnJlbmRlciA9IG11bHRpaG9vayhbcHJvcHNIb29rLCBiZWZvcmVSZW5kZXIsIHRoaXMucmVuZGVyIHx8ICdyZW5kZXInLCBhZnRlclJlbmRlcl0pO1xufVxuXG5cbmZ1bmN0aW9uIHByb3BzSG9vayhwcm9wcywgY29udGV4dCkge1xuXHRpZiAoIXByb3BzKSB7IHJldHVybjsgfVxuXG5cdC8vIFJlYWN0IGFubm95aW5nbHkgc3BlY2lhbC1jYXNlcyBzaW5nbGUgY2hpbGRyZW4sIGFuZCBzb21lIHJlYWN0IGNvbXBvbmVudHMgYXJlIHJpZGljdWxvdXNseSBzdHJpY3QgYWJvdXQgdGhpcy5cblx0dmFyIGMgPSBwcm9wcy5jaGlsZHJlbjtcblx0aWYgKGMgJiYgQXJyYXkuaXNBcnJheShjKSAmJiBjLmxlbmd0aD09PTEgJiYgKHR5cGVvZiBjWzBdPT09J3N0cmluZycgfHwgdHlwZW9mIGNbMF09PT0nZnVuY3Rpb24nIHx8IGNbMF0gaW5zdGFuY2VvZiBWTm9kZSkpIHtcblx0XHRwcm9wcy5jaGlsZHJlbiA9IGNbMF07XG5cblx0XHQvLyBidXQgaXRzIHRvdGFsbHkgc3RpbGwgZ29pbmcgdG8gYmUgYW4gQXJyYXkuXG5cdFx0aWYgKHByb3BzLmNoaWxkcmVuICYmIHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdvYmplY3QnKSB7XG5cdFx0XHRwcm9wcy5jaGlsZHJlbi5sZW5ndGggPSAxO1xuXHRcdFx0cHJvcHMuY2hpbGRyZW5bMF0gPSBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH1cblxuXHQvLyBhZGQgcHJvcHR5cGUgY2hlY2tpbmdcblx0aWYgKERFVikge1xuXHRcdHZhciBjdG9yID0gdHlwZW9mIHRoaXM9PT0nZnVuY3Rpb24nID8gdGhpcyA6IHRoaXMuY29uc3RydWN0b3IsXG5cdFx0XHRwcm9wVHlwZXMgPSB0aGlzLnByb3BUeXBlcyB8fCBjdG9yLnByb3BUeXBlcztcblx0XHR2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZTtcblxuXHRcdGlmIChwcm9wVHlwZXMpIHtcblx0XHRcdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIGRpc3BsYXlOYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBiZWZvcmVSZW5kZXIocHJvcHMpIHtcblx0Y3VycmVudENvbXBvbmVudCA9IHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFmdGVyUmVuZGVyKCkge1xuXHRpZiAoY3VycmVudENvbXBvbmVudD09PXRoaXMpIHtcblx0XHRjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcblx0fVxufVxuXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50JDEocHJvcHMsIGNvbnRleHQsIG9wdHMpIHtcblx0Q29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDoge307XG5cdHRoaXMucmVmcyA9IHt9O1xuXHR0aGlzLl9yZWZQcm94aWVzID0ge307XG5cdGlmIChvcHRzIT09QllQQVNTX0hPT0spIHtcblx0XHRuZXdDb21wb25lbnRIb29rLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXHR9XG59XG5leHRlbmQoQ29tcG9uZW50JDEucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpLCB7XG5cdGNvbnN0cnVjdG9yOiBDb21wb25lbnQkMSxcblxuXHRpc1JlYWN0Q29tcG9uZW50OiB7fSxcblxuXHRyZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKHN0YXRlLCBjYWxsYmFjaykge1xuXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcyQxLnN0YXRlKSB7XG5cdFx0XHRpZiAoIShpIGluIHN0YXRlKSkge1xuXHRcdFx0XHRkZWxldGUgdGhpcyQxLnN0YXRlW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRET01Ob2RlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5iYXNlO1xuXHR9LFxuXG5cdGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5iYXNlO1xuXHR9XG59KTtcblxuXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0Q29tcG9uZW50JDEuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XG59XG5GLnByb3RvdHlwZSA9IENvbXBvbmVudCQxLnByb3RvdHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IEYoKTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKTtcbn07XG5cbnZhciBpbmRleCA9IHtcblx0dmVyc2lvbjogdmVyc2lvbixcblx0RE9NOiBET00sXG5cdFByb3BUeXBlczogUHJvcFR5cGVzLFxuXHRDaGlsZHJlbjogQ2hpbGRyZW4sXG5cdHJlbmRlcjogcmVuZGVyJDEsXG5cdGNyZWF0ZUNsYXNzOiBjcmVhdGVDbGFzcyxcblx0Y3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblx0Y2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQkMSxcblx0aXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXHRmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGU6IHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdENvbXBvbmVudDogQ29tcG9uZW50JDEsXG5cdFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG5cdHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcixcblx0X19zcHJlYWQ6IGV4dGVuZFxufTtcblxuZXhwb3J0IHsgdmVyc2lvbiwgRE9NLCBQcm9wVHlwZXMsIENoaWxkcmVuLCByZW5kZXIkMSBhcyByZW5kZXIsIGNyZWF0ZUNsYXNzLCBjcmVhdGVGYWN0b3J5LCBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQkMSBhcyBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50LCBmaW5kRE9NTm9kZSwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgQ29tcG9uZW50JDEgYXMgQ29tcG9uZW50LCBQdXJlQ29tcG9uZW50LCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciBhcyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgZXh0ZW5kIGFzIF9fc3ByZWFkIH07ZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QtY29tcGF0LmVzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3ByZWFjdC1jb21wYXQvZGlzdC9wcmVhY3QtY29tcGF0LmVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJlYWN0LWNvbXBhdC9kaXN0L3ByZWFjdC1jb21wYXQuZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFZpcnR1YWwgRE9NIE5vZGUgKi9cbmZ1bmN0aW9uIFZOb2RlKCkge31cblxuLyoqIEdsb2JhbCBvcHRpb25zXG4gKlx0QHB1YmxpY1xuICpcdEBuYW1lc3BhY2Ugb3B0aW9ucyB7T2JqZWN0fVxuICovXG52YXIgb3B0aW9ucyA9IHtcblxuXHQvKiogSWYgYHRydWVgLCBgcHJvcGAgY2hhbmdlcyB0cmlnZ2VyIHN5bmNocm9ub3VzIGNvbXBvbmVudCB1cGRhdGVzLlxuICAqXHRAbmFtZSBzeW5jQ29tcG9uZW50VXBkYXRlc1xuICAqXHRAdHlwZSBCb29sZWFuXG4gICpcdEBkZWZhdWx0IHRydWVcbiAgKi9cblx0Ly9zeW5jQ29tcG9uZW50VXBkYXRlczogdHJ1ZSxcblxuXHQvKiogUHJvY2Vzc2VzIGFsbCBjcmVhdGVkIFZOb2Rlcy5cbiAgKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdEEgbmV3bHktY3JlYXRlZCBWTm9kZSB0byBub3JtYWxpemUvcHJvY2Vzc1xuICAqL1xuXHQvL3Zub2RlKHZub2RlKSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGFmdGVyIGEgY29tcG9uZW50IGlzIG1vdW50ZWQuICovXG5cdC8vIGFmdGVyTW91bnQoY29tcG9uZW50KSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGFmdGVyIHRoZSBET00gaXMgdXBkYXRlZCB3aXRoIGEgY29tcG9uZW50J3MgbGF0ZXN0IHJlbmRlci4gKi9cblx0Ly8gYWZ0ZXJVcGRhdGUoY29tcG9uZW50KSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuICovXG5cdC8vIGJlZm9yZVVubW91bnQoY29tcG9uZW50KSB7IH1cbn07XG5cbnZhciBzdGFjayA9IFtdO1xuXG52YXIgRU1QVFlfQ0hJTERSRU4gPSBbXTtcblxuLyoqIEpTWC9oeXBlcnNjcmlwdCByZXZpdmVyXG4qXHRCZW5jaG1hcmtzOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3ZWU4ZjhlMzMwYWIwOTkwMGExYTFhMFxuICpcdEBzZWUgaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4XG4gKlx0QHB1YmxpY1xuICovXG5mdW5jdGlvbiBoKG5vZGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHZhciBjaGlsZHJlbiA9IEVNUFRZX0NISUxEUkVOLFxuXHQgICAgbGFzdFNpbXBsZSxcblx0ICAgIGNoaWxkLFxuXHQgICAgc2ltcGxlLFxuXHQgICAgaTtcblx0Zm9yIChpID0gYXJndW1lbnRzLmxlbmd0aDsgaS0tID4gMjspIHtcblx0XHRzdGFjay5wdXNoKGFyZ3VtZW50c1tpXSk7XG5cdH1cblx0aWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0aWYgKCFzdGFjay5sZW5ndGgpIHN0YWNrLnB1c2goYXR0cmlidXRlcy5jaGlsZHJlbik7XG5cdFx0ZGVsZXRlIGF0dHJpYnV0ZXMuY2hpbGRyZW47XG5cdH1cblx0d2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuXHRcdGlmICgoY2hpbGQgPSBzdGFjay5wb3AoKSkgJiYgY2hpbGQucG9wICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAoaSA9IGNoaWxkLmxlbmd0aDsgaS0tOykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGNoaWxkW2ldKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSBjaGlsZCA9IG51bGw7XG5cblx0XHRcdGlmIChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKGNoaWxkID09IG51bGwpIGNoaWxkID0gJyc7ZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykgY2hpbGQgPSBTdHJpbmcoY2hpbGQpO2Vsc2UgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycpIHNpbXBsZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2ltcGxlICYmIGxhc3RTaW1wbGUpIHtcblx0XHRcdFx0Y2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gKz0gY2hpbGQ7XG5cdFx0XHR9IGVsc2UgaWYgKGNoaWxkcmVuID09PSBFTVBUWV9DSElMRFJFTikge1xuXHRcdFx0XHRjaGlsZHJlbiA9IFtjaGlsZF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHRcdH1cblxuXHRcdFx0bGFzdFNpbXBsZSA9IHNpbXBsZTtcblx0XHR9XG5cdH1cblxuXHR2YXIgcCA9IG5ldyBWTm9kZSgpO1xuXHRwLm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cdHAuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0cC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXR0cmlidXRlcztcblx0cC5rZXkgPSBhdHRyaWJ1dGVzID09IG51bGwgPyB1bmRlZmluZWQgOiBhdHRyaWJ1dGVzLmtleTtcblxuXHQvLyBpZiBhIFwidm5vZGUgaG9va1wiIGlzIGRlZmluZWQsIHBhc3MgZXZlcnkgY3JlYXRlZCBWTm9kZSB0byBpdFxuXHRpZiAob3B0aW9ucy52bm9kZSAhPT0gdW5kZWZpbmVkKSBvcHRpb25zLnZub2RlKHApO1xuXG5cdHJldHVybiBwO1xufVxuXG4vKiogQ29weSBvd24tcHJvcGVydGllcyBmcm9tIGBwcm9wc2Agb250byBgb2JqYC5cbiAqXHRAcmV0dXJucyBvYmpcbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRlbmQob2JqLCBwcm9wcykge1xuICBmb3IgKHZhciBpIGluIHByb3BzKSB7XG4gICAgb2JqW2ldID0gcHJvcHNbaV07XG4gIH1yZXR1cm4gb2JqO1xufVxuXG4vKiogQ2FsbCBhIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5LCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICpcdEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbnZhciBkZWZlciA9IHR5cGVvZiBQcm9taXNlID09ICdmdW5jdGlvbicgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KHZub2RlLCBwcm9wcykge1xuXHRyZXR1cm4gaCh2bm9kZS5ub2RlTmFtZSwgZXh0ZW5kKGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyksIHByb3BzKSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiB2bm9kZS5jaGlsZHJlbik7XG59XG5cbi8vIERPTSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIE5PVCBoYXZlIFwicHhcIiBhZGRlZCB3aGVuIG51bWVyaWNcbnZhciBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcblxuLyoqIE1hbmFnZWQgcXVldWUgb2YgZGlydHkgY29tcG9uZW50cyB0byBiZSByZS1yZW5kZXJlZCAqL1xuXG52YXIgaXRlbXMgPSBbXTtcblxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpIHtcblx0aWYgKCFjb21wb25lbnQuX2RpcnR5ICYmIChjb21wb25lbnQuX2RpcnR5ID0gdHJ1ZSkgJiYgaXRlbXMucHVzaChjb21wb25lbnQpID09IDEpIHtcblx0XHQob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyB8fCBkZWZlcikocmVyZW5kZXIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyKCkge1xuXHR2YXIgcCxcblx0ICAgIGxpc3QgPSBpdGVtcztcblx0aXRlbXMgPSBbXTtcblx0d2hpbGUgKHAgPSBsaXN0LnBvcCgpKSB7XG5cdFx0aWYgKHAuX2RpcnR5KSByZW5kZXJDb21wb25lbnQocCk7XG5cdH1cbn1cblxuLyoqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgZXF1aXZhbGVudC5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqXHRAcGFyYW0ge1ZOb2RlfSB2bm9kZVxuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZU5vZGVUeXBlKG5vZGUsIHZub2RlLCBoeWRyYXRpbmcpIHtcblx0aWYgKHR5cGVvZiB2bm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZub2RlID09PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiBub2RlLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmICh0eXBlb2Ygdm5vZGUubm9kZU5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICFub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciAmJiBpc05hbWVkTm9kZShub2RlLCB2bm9kZS5ub2RlTmFtZSk7XG5cdH1cblx0cmV0dXJuIGh5ZHJhdGluZyB8fCBub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG59XG5cbi8qKiBDaGVjayBpZiBhbiBFbGVtZW50IGhhcyBhIGdpdmVuIG5vcm1hbGl6ZWQgbmFtZS5cbipcdEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuKlx0QHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGlzTmFtZWROb2RlKG5vZGUsIG5vZGVOYW1lKSB7XG5cdHJldHVybiBub2RlLm5vcm1hbGl6ZWROb2RlTmFtZSA9PT0gbm9kZU5hbWUgfHwgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIFJlY29uc3RydWN0IENvbXBvbmVudC1zdHlsZSBgcHJvcHNgIGZyb20gYSBWTm9kZS5cbiAqIEVuc3VyZXMgZGVmYXVsdC9mYWxsYmFjayB2YWx1ZXMgZnJvbSBgZGVmYXVsdFByb3BzYDpcbiAqIE93bi1wcm9wZXJ0aWVzIG9mIGBkZWZhdWx0UHJvcHNgIG5vdCBwcmVzZW50IGluIGB2bm9kZS5hdHRyaWJ1dGVzYCBhcmUgYWRkZWQuXG4gKiBAcGFyYW0ge1ZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge09iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKHZub2RlKSB7XG5cdHZhciBwcm9wcyA9IGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyk7XG5cdHByb3BzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cblx0dmFyIGRlZmF1bHRQcm9wcyA9IHZub2RlLm5vZGVOYW1lLmRlZmF1bHRQcm9wcztcblx0aWYgKGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiBkZWZhdWx0UHJvcHMpIHtcblx0XHRcdGlmIChwcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHByb3BzW2ldID0gZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwcm9wcztcbn1cblxuLyoqIENyZWF0ZSBhbiBlbGVtZW50IHdpdGggdGhlIGdpdmVuIG5vZGVOYW1lLlxuICpcdEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gW2lzU3ZnPWZhbHNlXVx0SWYgYHRydWVgLCBjcmVhdGVzIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBTVkcgbmFtZXNwYWNlLlxuICpcdEByZXR1cm5zIHtFbGVtZW50fSBub2RlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUobm9kZU5hbWUsIGlzU3ZnKSB7XG5cdHZhciBub2RlID0gaXNTdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbm9kZU5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG5cdG5vZGUubm9ybWFsaXplZE5vZGVOYW1lID0gbm9kZU5hbWU7XG5cdHJldHVybiBub2RlO1xufVxuXG4vKiogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuXG4gKlx0QHBhcmFtIHtFbGVtZW50fSBub2RlXHRcdFRoZSBub2RlIHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0dmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG4vKiogU2V0IGEgbmFtZWQgYXR0cmlidXRlIG9uIHRoZSBnaXZlbiBOb2RlLCB3aXRoIHNwZWNpYWwgYmVoYXZpb3IgZm9yIHNvbWUgbmFtZXMgYW5kIGV2ZW50IGhhbmRsZXJzLlxuICpcdElmIGB2YWx1ZWAgaXMgYG51bGxgLCB0aGUgYXR0cmlidXRlL2hhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gbm9kZVx0QW4gZWxlbWVudCB0byBtdXRhdGVcbiAqXHRAcGFyYW0ge3N0cmluZ30gbmFtZVx0VGhlIG5hbWUva2V5IHRvIHNldCwgc3VjaCBhcyBhbiBldmVudCBvciBhdHRyaWJ1dGUgbmFtZVxuICpcdEBwYXJhbSB7YW55fSBvbGRcdFRoZSBsYXN0IHZhbHVlIHRoYXQgd2FzIHNldCBmb3IgdGhpcyBuYW1lL25vZGUgcGFpclxuICpcdEBwYXJhbSB7YW55fSB2YWx1ZVx0QW4gYXR0cmlidXRlIHZhbHVlLCBzdWNoIGFzIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBhcyBhbiBldmVudCBoYW5kbGVyXG4gKlx0QHBhcmFtIHtCb29sZWFufSBpc1N2Z1x0QXJlIHdlIGN1cnJlbnRseSBkaWZmaW5nIGluc2lkZSBhbiBzdmc/XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0QWNjZXNzb3Iobm9kZSwgbmFtZSwgb2xkLCB2YWx1ZSwgaXNTdmcpIHtcblx0aWYgKG5hbWUgPT09ICdjbGFzc05hbWUnKSBuYW1lID0gJ2NsYXNzJztcblxuXHRpZiAobmFtZSA9PT0gJ2tleScpIHtcblx0XHQvLyBpZ25vcmVcblx0fSBlbHNlIGlmIChuYW1lID09PSAncmVmJykge1xuXHRcdGlmIChvbGQpIG9sZChudWxsKTtcblx0XHRpZiAodmFsdWUpIHZhbHVlKG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIWlzU3ZnKSB7XG5cdFx0bm9kZS5jbGFzc05hbWUgPSB2YWx1ZSB8fCAnJztcblx0fSBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvbGQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRub2RlLnN0eWxlLmNzc1RleHQgPSB2YWx1ZSB8fCAnJztcblx0XHR9XG5cdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGkgaW4gdmFsdWUpKSBub2RlLnN0eWxlW2ldID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0bm9kZS5zdHlsZVtpXSA9IHR5cGVvZiB2YWx1ZVtpXSA9PT0gJ251bWJlcicgJiYgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3QoaSkgPT09IGZhbHNlID8gdmFsdWVbaV0gKyAncHgnIDogdmFsdWVbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAodmFsdWUpIG5vZGUuaW5uZXJIVE1MID0gdmFsdWUuX19odG1sIHx8ICcnO1xuXHR9IGVsc2UgaWYgKG5hbWVbMF0gPT0gJ28nICYmIG5hbWVbMV0gPT0gJ24nKSB7XG5cdFx0dmFyIHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGQpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50UHJveHksIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0XHQobm9kZS5fbGlzdGVuZXJzIHx8IChub2RlLl9saXN0ZW5lcnMgPSB7fSkpW25hbWVdID0gdmFsdWU7XG5cdH0gZWxzZSBpZiAobmFtZSAhPT0gJ2xpc3QnICYmIG5hbWUgIT09ICd0eXBlJyAmJiAhaXNTdmcgJiYgbmFtZSBpbiBub2RlKSB7XG5cdFx0c2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIG5zID0gaXNTdmcgJiYgbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpO1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0aWYgKG5zKSBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgbmFtZS50b0xvd2VyQ2FzZSgpKTtlbHNlIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZiAobnMpIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtlbHNlIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIEF0dGVtcHQgdG8gc2V0IGEgRE9NIHByb3BlcnR5IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXHRJRSAmIEZGIHRocm93IGZvciBjZXJ0YWluIHByb3BlcnR5LXZhbHVlIGNvbWJpbmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcblx0dHJ5IHtcblx0XHRub2RlW25hbWVdID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8qKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGVdKG9wdGlvbnMuZXZlbnQgJiYgb3B0aW9ucy5ldmVudChlKSB8fCBlKTtcbn1cblxuLyoqIFF1ZXVlIG9mIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gbW91bnRlZCBhbmQgYXJlIGF3YWl0aW5nIGNvbXBvbmVudERpZE1vdW50ICovXG52YXIgbW91bnRzID0gW107XG5cbi8qKiBEaWZmIHJlY3Vyc2lvbiBjb3VudCwgdXNlZCB0byB0cmFjayB0aGUgZW5kIG9mIHRoZSBkaWZmIGN5Y2xlLiAqL1xudmFyIGRpZmZMZXZlbCA9IDA7XG5cbi8qKiBHbG9iYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBkaWZmIGlzIGN1cnJlbnRseSB3aXRoaW4gYW4gU1ZHICovXG52YXIgaXNTdmdNb2RlID0gZmFsc2U7XG5cbi8qKiBHbG9iYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBkaWZmIGlzIHBlcmZvcm1pbmcgaHlkcmF0aW9uICovXG52YXIgaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKiBJbnZva2UgcXVldWVkIGNvbXBvbmVudERpZE1vdW50IGxpZmVjeWNsZSBtZXRob2RzICovXG5mdW5jdGlvbiBmbHVzaE1vdW50cygpIHtcblx0dmFyIGM7XG5cdHdoaWxlIChjID0gbW91bnRzLnBvcCgpKSB7XG5cdFx0aWYgKG9wdGlvbnMuYWZ0ZXJNb3VudCkgb3B0aW9ucy5hZnRlck1vdW50KGMpO1xuXHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50KSBjLmNvbXBvbmVudERpZE1vdW50KCk7XG5cdH1cbn1cblxuLyoqIEFwcGx5IGRpZmZlcmVuY2VzIGluIGEgZ2l2ZW4gdm5vZGUgKGFuZCBpdCdzIGRlZXAgY2hpbGRyZW4pIHRvIGEgcmVhbCBET00gTm9kZS5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IFtkb209bnVsbF1cdFx0QSBET00gbm9kZSB0byBtdXRhdGUgaW50byB0aGUgc2hhcGUgb2YgdGhlIGB2bm9kZWBcbiAqXHRAcGFyYW0ge1ZOb2RlfSB2bm9kZVx0XHRcdEEgVk5vZGUgKHdpdGggZGVzY2VuZGFudHMgZm9ybWluZyBhIHRyZWUpIHJlcHJlc2VudGluZyB0aGUgZGVzaXJlZCBET00gc3RydWN0dXJlXG4gKlx0QHJldHVybnMge0VsZW1lbnR9IGRvbVx0XHRcdFRoZSBjcmVhdGVkL211dGF0ZWQgZWxlbWVudFxuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIHBhcmVudCwgY29tcG9uZW50Um9vdCkge1xuXHQvLyBkaWZmTGV2ZWwgaGF2aW5nIGJlZW4gMCBoZXJlIGluZGljYXRlcyBpbml0aWFsIGVudHJ5IGludG8gdGhlIGRpZmYgKG5vdCBhIHN1YmRpZmYpXG5cdGlmICghZGlmZkxldmVsKyspIHtcblx0XHQvLyB3aGVuIGZpcnN0IHN0YXJ0aW5nIHRoZSBkaWZmLCBjaGVjayBpZiB3ZSdyZSBkaWZmaW5nIGFuIFNWRyBvciB3aXRoaW4gYW4gU1ZHXG5cdFx0aXNTdmdNb2RlID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0Ly8gaHlkcmF0aW9uIGlzIGluZGljYXRlZCBieSB0aGUgZXhpc3RpbmcgZWxlbWVudCB0byBiZSBkaWZmZWQgbm90IGhhdmluZyBhIHByb3AgY2FjaGVcblx0XHRoeWRyYXRpbmcgPSBkb20gIT0gbnVsbCAmJiAhKCdfX3ByZWFjdGF0dHJfJyBpbiBkb20pO1xuXHR9XG5cblx0dmFyIHJldCA9IGlkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBjb21wb25lbnRSb290KTtcblxuXHQvLyBhcHBlbmQgdGhlIGVsZW1lbnQgaWYgaXRzIGEgbmV3IHBhcmVudFxuXHRpZiAocGFyZW50ICYmIHJldC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChyZXQpO1xuXG5cdC8vIGRpZmZMZXZlbCBiZWluZyByZWR1Y2VkIHRvIDAgbWVhbnMgd2UncmUgZXhpdGluZyB0aGUgZGlmZlxuXHRpZiAoISAtLWRpZmZMZXZlbCkge1xuXHRcdGh5ZHJhdGluZyA9IGZhbHNlO1xuXHRcdC8vIGludm9rZSBxdWV1ZWQgY29tcG9uZW50RGlkTW91bnQgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRpZiAoIWNvbXBvbmVudFJvb3QpIGZsdXNoTW91bnRzKCk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG4vKiogSW50ZXJuYWxzIG9mIGBkaWZmKClgLCBzZXBhcmF0ZWQgdG8gYWxsb3cgYnlwYXNzaW5nIGRpZmZMZXZlbCAvIG1vdW50IGZsdXNoaW5nLiAqL1xuZnVuY3Rpb24gaWRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIGNvbXBvbmVudFJvb3QpIHtcblx0dmFyIG91dCA9IGRvbSxcblx0ICAgIHByZXZTdmdNb2RlID0gaXNTdmdNb2RlO1xuXG5cdC8vIGVtcHR5IHZhbHVlcyAobnVsbCwgdW5kZWZpbmVkLCBib29sZWFucykgcmVuZGVyIGFzIGVtcHR5IFRleHQgbm9kZXNcblx0aWYgKHZub2RlID09IG51bGwgfHwgdHlwZW9mIHZub2RlID09PSAnYm9vbGVhbicpIHZub2RlID0gJyc7XG5cblx0Ly8gRmFzdCBjYXNlOiBTdHJpbmdzICYgTnVtYmVycyBjcmVhdGUvdXBkYXRlIFRleHQgbm9kZXMuXG5cdGlmICh0eXBlb2Ygdm5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2bm9kZSA9PT0gJ251bWJlcicpIHtcblxuXHRcdC8vIHVwZGF0ZSBpZiBpdCdzIGFscmVhZHkgYSBUZXh0IG5vZGU6XG5cdFx0aWYgKGRvbSAmJiBkb20uc3BsaXRUZXh0ICE9PSB1bmRlZmluZWQgJiYgZG9tLnBhcmVudE5vZGUgJiYgKCFkb20uX2NvbXBvbmVudCB8fCBjb21wb25lbnRSb290KSkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovIC8qIEJyb3dzZXIgcXVpcmsgdGhhdCBjYW4ndCBiZSBjb3ZlcmVkOiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9jb21taXQvZmQ0ZjIxZjVjNDVkZmQ3NTE1MWJkMjdiNGMyMTdkODAwM2FhNWViOSAqL1xuXHRcdFx0aWYgKGRvbS5ub2RlVmFsdWUgIT0gdm5vZGUpIHtcblx0XHRcdFx0ZG9tLm5vZGVWYWx1ZSA9IHZub2RlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpdCB3YXNuJ3QgYSBUZXh0IG5vZGU6IHJlcGxhY2UgaXQgd2l0aCBvbmUgYW5kIHJlY3ljbGUgdGhlIG9sZCBFbGVtZW50XG5cdFx0XHRvdXQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZSk7XG5cdFx0XHRpZiAoZG9tKSB7XG5cdFx0XHRcdGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcblx0XHRcdFx0cmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdXRbJ19fcHJlYWN0YXR0cl8nXSA9IHRydWU7XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0Ly8gSWYgdGhlIFZOb2RlIHJlcHJlc2VudHMgYSBDb21wb25lbnQsIHBlcmZvcm0gYSBjb21wb25lbnQgZGlmZjpcblx0dmFyIHZub2RlTmFtZSA9IHZub2RlLm5vZGVOYW1lO1xuXHRpZiAodHlwZW9mIHZub2RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBidWlsZENvbXBvbmVudEZyb21WTm9kZShkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdH1cblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aXNTdmdNb2RlID0gdm5vZGVOYW1lID09PSAnc3ZnJyA/IHRydWUgOiB2bm9kZU5hbWUgPT09ICdmb3JlaWduT2JqZWN0JyA/IGZhbHNlIDogaXNTdmdNb2RlO1xuXG5cdC8vIElmIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgZWxlbWVudCBvciBpdCdzIHRoZSB3cm9uZyB0eXBlLCBjcmVhdGUgYSBuZXcgb25lOlxuXHR2bm9kZU5hbWUgPSBTdHJpbmcodm5vZGVOYW1lKTtcblx0aWYgKCFkb20gfHwgIWlzTmFtZWROb2RlKGRvbSwgdm5vZGVOYW1lKSkge1xuXHRcdG91dCA9IGNyZWF0ZU5vZGUodm5vZGVOYW1lLCBpc1N2Z01vZGUpO1xuXG5cdFx0aWYgKGRvbSkge1xuXHRcdFx0Ly8gbW92ZSBjaGlsZHJlbiBpbnRvIHRoZSByZXBsYWNlbWVudCBub2RlXG5cdFx0XHR3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0b3V0LmFwcGVuZENoaWxkKGRvbS5maXJzdENoaWxkKTtcblx0XHRcdH0gLy8gaWYgdGhlIHByZXZpb3VzIEVsZW1lbnQgd2FzIG1vdW50ZWQgaW50byB0aGUgRE9NLCByZXBsYWNlIGl0IGlubGluZVxuXHRcdFx0aWYgKGRvbS5wYXJlbnROb2RlKSBkb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQob3V0LCBkb20pO1xuXG5cdFx0XHQvLyByZWN5Y2xlIHRoZSBvbGQgZWxlbWVudCAoc2tpcHMgbm9uLUVsZW1lbnQgbm9kZSB0eXBlcylcblx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGZjID0gb3V0LmZpcnN0Q2hpbGQsXG5cdCAgICBwcm9wcyA9IG91dFsnX19wcmVhY3RhdHRyXyddLFxuXHQgICAgdmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cblx0aWYgKHByb3BzID09IG51bGwpIHtcblx0XHRwcm9wcyA9IG91dFsnX19wcmVhY3RhdHRyXyddID0ge307XG5cdFx0Zm9yICh2YXIgYSA9IG91dC5hdHRyaWJ1dGVzLCBpID0gYS5sZW5ndGg7IGktLTspIHtcblx0XHRcdHByb3BzW2FbaV0ubmFtZV0gPSBhW2ldLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8vIE9wdGltaXphdGlvbjogZmFzdC1wYXRoIGZvciBlbGVtZW50cyBjb250YWluaW5nIGEgc2luZ2xlIFRleHROb2RlOlxuXHRpZiAoIWh5ZHJhdGluZyAmJiB2Y2hpbGRyZW4gJiYgdmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmNoaWxkcmVuWzBdID09PSAnc3RyaW5nJyAmJiBmYyAhPSBudWxsICYmIGZjLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkICYmIGZjLm5leHRTaWJsaW5nID09IG51bGwpIHtcblx0XHRpZiAoZmMubm9kZVZhbHVlICE9IHZjaGlsZHJlblswXSkge1xuXHRcdFx0ZmMubm9kZVZhbHVlID0gdmNoaWxkcmVuWzBdO1xuXHRcdH1cblx0fVxuXHQvLyBvdGhlcndpc2UsIGlmIHRoZXJlIGFyZSBleGlzdGluZyBvciBuZXcgY2hpbGRyZW4sIGRpZmYgdGhlbTpcblx0ZWxzZSBpZiAodmNoaWxkcmVuICYmIHZjaGlsZHJlbi5sZW5ndGggfHwgZmMgIT0gbnVsbCkge1xuXHRcdFx0aW5uZXJEaWZmTm9kZShvdXQsIHZjaGlsZHJlbiwgY29udGV4dCwgbW91bnRBbGwsIGh5ZHJhdGluZyB8fCBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKTtcblx0XHR9XG5cblx0Ly8gQXBwbHkgYXR0cmlidXRlcy9wcm9wcyBmcm9tIFZOb2RlIHRvIHRoZSBET00gRWxlbWVudDpcblx0ZGlmZkF0dHJpYnV0ZXMob3V0LCB2bm9kZS5hdHRyaWJ1dGVzLCBwcm9wcyk7XG5cblx0Ly8gcmVzdG9yZSBwcmV2aW91cyBTVkcgbW9kZTogKGluIGNhc2Ugd2UncmUgZXhpdGluZyBhbiBTVkcgbmFtZXNwYWNlKVxuXHRpc1N2Z01vZGUgPSBwcmV2U3ZnTW9kZTtcblxuXHRyZXR1cm4gb3V0O1xufVxuXG4vKiogQXBwbHkgY2hpbGQgYW5kIGF0dHJpYnV0ZSBjaGFuZ2VzIGJldHdlZW4gYSBWTm9kZSBhbmQgYSBET00gTm9kZSB0byB0aGUgRE9NLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRcdFx0RWxlbWVudCB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgY29tcGFyZWQgJiBtdXRhdGVkXG4gKlx0QHBhcmFtIHtBcnJheX0gdmNoaWxkcmVuXHRcdEFycmF5IG9mIFZOb2RlcyB0byBjb21wYXJlIHRvIGBkb20uY2hpbGROb2Rlc2BcbiAqXHRAcGFyYW0ge09iamVjdH0gY29udGV4dFx0XHRcdEltcGxpY2l0bHkgZGVzY2VuZGFudCBjb250ZXh0IG9iamVjdCAoZnJvbSBtb3N0IHJlY2VudCBgZ2V0Q2hpbGRDb250ZXh0KClgKVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gbW91bnRBbGxcbiAqXHRAcGFyYW0ge0Jvb2xlYW59IGlzSHlkcmF0aW5nXHRJZiBgdHJ1ZWAsIGNvbnN1bWVzIGV4dGVybmFsbHkgY3JlYXRlZCBlbGVtZW50cyBzaW1pbGFyIHRvIGh5ZHJhdGlvblxuICovXG5mdW5jdGlvbiBpbm5lckRpZmZOb2RlKGRvbSwgdmNoaWxkcmVuLCBjb250ZXh0LCBtb3VudEFsbCwgaXNIeWRyYXRpbmcpIHtcblx0dmFyIG9yaWdpbmFsQ2hpbGRyZW4gPSBkb20uY2hpbGROb2Rlcyxcblx0ICAgIGNoaWxkcmVuID0gW10sXG5cdCAgICBrZXllZCA9IHt9LFxuXHQgICAga2V5ZWRMZW4gPSAwLFxuXHQgICAgbWluID0gMCxcblx0ICAgIGxlbiA9IG9yaWdpbmFsQ2hpbGRyZW4ubGVuZ3RoLFxuXHQgICAgY2hpbGRyZW5MZW4gPSAwLFxuXHQgICAgdmxlbiA9IHZjaGlsZHJlbiA/IHZjaGlsZHJlbi5sZW5ndGggOiAwLFxuXHQgICAgaixcblx0ICAgIGMsXG5cdCAgICBmLFxuXHQgICAgdmNoaWxkLFxuXHQgICAgY2hpbGQ7XG5cblx0Ly8gQnVpbGQgdXAgYSBtYXAgb2Yga2V5ZWQgY2hpbGRyZW4gYW5kIGFuIEFycmF5IG9mIHVua2V5ZWQgY2hpbGRyZW46XG5cdGlmIChsZW4gIT09IDApIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgX2NoaWxkID0gb3JpZ2luYWxDaGlsZHJlbltpXSxcblx0XHRcdCAgICBwcm9wcyA9IF9jaGlsZFsnX19wcmVhY3RhdHRyXyddLFxuXHRcdFx0ICAgIGtleSA9IHZsZW4gJiYgcHJvcHMgPyBfY2hpbGQuX2NvbXBvbmVudCA/IF9jaGlsZC5fY29tcG9uZW50Ll9fa2V5IDogcHJvcHMua2V5IDogbnVsbDtcblx0XHRcdGlmIChrZXkgIT0gbnVsbCkge1xuXHRcdFx0XHRrZXllZExlbisrO1xuXHRcdFx0XHRrZXllZFtrZXldID0gX2NoaWxkO1xuXHRcdFx0fSBlbHNlIGlmIChwcm9wcyB8fCAoX2NoaWxkLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkID8gaXNIeWRyYXRpbmcgPyBfY2hpbGQubm9kZVZhbHVlLnRyaW0oKSA6IHRydWUgOiBpc0h5ZHJhdGluZykpIHtcblx0XHRcdFx0Y2hpbGRyZW5bY2hpbGRyZW5MZW4rK10gPSBfY2hpbGQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKHZsZW4gIT09IDApIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuXHRcdFx0dmNoaWxkID0gdmNoaWxkcmVuW2ldO1xuXHRcdFx0Y2hpbGQgPSBudWxsO1xuXG5cdFx0XHQvLyBhdHRlbXB0IHRvIGZpbmQgYSBub2RlIGJhc2VkIG9uIGtleSBtYXRjaGluZ1xuXHRcdFx0dmFyIGtleSA9IHZjaGlsZC5rZXk7XG5cdFx0XHRpZiAoa2V5ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGtleWVkTGVuICYmIGtleWVkW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNoaWxkID0ga2V5ZWRba2V5XTtcblx0XHRcdFx0XHRrZXllZFtrZXldID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGtleWVkTGVuLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGF0dGVtcHQgdG8gcGx1Y2sgYSBub2RlIG9mIHRoZSBzYW1lIHR5cGUgZnJvbSB0aGUgZXhpc3RpbmcgY2hpbGRyZW5cblx0XHRcdGVsc2UgaWYgKCFjaGlsZCAmJiBtaW4gPCBjaGlsZHJlbkxlbikge1xuXHRcdFx0XHRcdGZvciAoaiA9IG1pbjsgaiA8IGNoaWxkcmVuTGVuOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZHJlbltqXSAhPT0gdW5kZWZpbmVkICYmIGlzU2FtZU5vZGVUeXBlKGMgPSBjaGlsZHJlbltqXSwgdmNoaWxkLCBpc0h5ZHJhdGluZykpIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBjO1xuXHRcdFx0XHRcdFx0XHRjaGlsZHJlbltqXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0aWYgKGogPT09IGNoaWxkcmVuTGVuIC0gMSkgY2hpbGRyZW5MZW4tLTtcblx0XHRcdFx0XHRcdFx0aWYgKGogPT09IG1pbikgbWluKys7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBtb3JwaCB0aGUgbWF0Y2hlZC9mb3VuZC9jcmVhdGVkIERPTSBjaGlsZCB0byBtYXRjaCB2Y2hpbGQgKGRlZXApXG5cdFx0XHRjaGlsZCA9IGlkaWZmKGNoaWxkLCB2Y2hpbGQsIGNvbnRleHQsIG1vdW50QWxsKTtcblxuXHRcdFx0ZiA9IG9yaWdpbmFsQ2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgJiYgY2hpbGQgIT09IGRvbSAmJiBjaGlsZCAhPT0gZikge1xuXHRcdFx0XHRpZiAoZiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZG9tLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaGlsZCA9PT0gZi5uZXh0U2libGluZykge1xuXHRcdFx0XHRcdHJlbW92ZU5vZGUoZik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9tLmluc2VydEJlZm9yZShjaGlsZCwgZik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyByZW1vdmUgdW51c2VkIGtleWVkIGNoaWxkcmVuOlxuXHRpZiAoa2V5ZWRMZW4pIHtcblx0XHRmb3IgKHZhciBpIGluIGtleWVkKSB7XG5cdFx0XHRpZiAoa2V5ZWRbaV0gIT09IHVuZGVmaW5lZCkgcmVjb2xsZWN0Tm9kZVRyZWUoa2V5ZWRbaV0sIGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHQvLyByZW1vdmUgb3JwaGFuZWQgdW5rZXllZCBjaGlsZHJlbjpcblx0d2hpbGUgKG1pbiA8PSBjaGlsZHJlbkxlbikge1xuXHRcdGlmICgoY2hpbGQgPSBjaGlsZHJlbltjaGlsZHJlbkxlbi0tXSkgIT09IHVuZGVmaW5lZCkgcmVjb2xsZWN0Tm9kZVRyZWUoY2hpbGQsIGZhbHNlKTtcblx0fVxufVxuXG4vKiogUmVjdXJzaXZlbHkgcmVjeWNsZSAob3IganVzdCB1bm1vdW50KSBhIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cy5cbiAqXHRAcGFyYW0ge05vZGV9IG5vZGVcdFx0XHRcdFx0XHRET00gbm9kZSB0byBzdGFydCB1bm1vdW50L3JlbW92YWwgZnJvbVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gW3VubW91bnRPbmx5PWZhbHNlXVx0SWYgYHRydWVgLCBvbmx5IHRyaWdnZXJzIHVubW91bnQgbGlmZWN5Y2xlLCBza2lwcyByZW1vdmFsXG4gKi9cbmZ1bmN0aW9uIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsIHVubW91bnRPbmx5KSB7XG5cdHZhciBjb21wb25lbnQgPSBub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjb21wb25lbnQpIHtcblx0XHQvLyBpZiBub2RlIGlzIG93bmVkIGJ5IGEgQ29tcG9uZW50LCB1bm1vdW50IHRoYXQgY29tcG9uZW50IChlbmRzIHVwIHJlY3Vyc2luZyBiYWNrIGhlcmUpXG5cdFx0dW5tb3VudENvbXBvbmVudChjb21wb25lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSBub2RlJ3MgVk5vZGUgaGFkIGEgcmVmIGZ1bmN0aW9uLCBpbnZva2UgaXQgd2l0aCBudWxsIGhlcmUuXG5cdFx0Ly8gKHRoaXMgaXMgcGFydCBvZiB0aGUgUmVhY3Qgc3BlYywgYW5kIHNtYXJ0IGZvciB1bnNldHRpbmcgcmVmZXJlbmNlcylcblx0XHRpZiAobm9kZVsnX19wcmVhY3RhdHRyXyddICE9IG51bGwgJiYgbm9kZVsnX19wcmVhY3RhdHRyXyddLnJlZikgbm9kZVsnX19wcmVhY3RhdHRyXyddLnJlZihudWxsKTtcblxuXHRcdGlmICh1bm1vdW50T25seSA9PT0gZmFsc2UgfHwgbm9kZVsnX19wcmVhY3RhdHRyXyddID09IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUobm9kZSk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlQ2hpbGRyZW4obm9kZSk7XG5cdH1cbn1cblxuLyoqIFJlY29sbGVjdC91bm1vdW50IGFsbCBjaGlsZHJlbi5cbiAqXHQtIHdlIHVzZSAubGFzdENoaWxkIGhlcmUgYmVjYXVzZSBpdCBjYXVzZXMgbGVzcyByZWZsb3cgdGhhbiAuZmlyc3RDaGlsZFxuICpcdC0gaXQncyBhbHNvIGNoZWFwZXIgdGhhbiBhY2Nlc3NpbmcgdGhlIC5jaGlsZE5vZGVzIExpdmUgTm9kZUxpc3RcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuXHRub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0dmFyIG5leHQgPSBub2RlLnByZXZpb3VzU2libGluZztcblx0XHRyZWNvbGxlY3ROb2RlVHJlZShub2RlLCB0cnVlKTtcblx0XHRub2RlID0gbmV4dDtcblx0fVxufVxuXG4vKiogQXBwbHkgZGlmZmVyZW5jZXMgaW4gYXR0cmlidXRlcyBmcm9tIGEgVk5vZGUgdG8gdGhlIGdpdmVuIERPTSBFbGVtZW50LlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRcdEVsZW1lbnQgd2l0aCBhdHRyaWJ1dGVzIHRvIGRpZmYgYGF0dHJzYCBhZ2FpbnN0XG4gKlx0QHBhcmFtIHtPYmplY3R9IGF0dHJzXHRcdFRoZSBkZXNpcmVkIGVuZC1zdGF0ZSBrZXktdmFsdWUgYXR0cmlidXRlIHBhaXJzXG4gKlx0QHBhcmFtIHtPYmplY3R9IG9sZFx0XHRcdEN1cnJlbnQvcHJldmlvdXMgYXR0cmlidXRlcyAoZnJvbSBwcmV2aW91cyBWTm9kZSBvciBlbGVtZW50J3MgcHJvcCBjYWNoZSlcbiAqL1xuZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMoZG9tLCBhdHRycywgb2xkKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIHJlbW92ZSBhdHRyaWJ1dGVzIG5vIGxvbmdlciBwcmVzZW50IG9uIHRoZSB2bm9kZSBieSBzZXR0aW5nIHRoZW0gdG8gdW5kZWZpbmVkXG5cdGZvciAobmFtZSBpbiBvbGQpIHtcblx0XHRpZiAoIShhdHRycyAmJiBhdHRyc1tuYW1lXSAhPSBudWxsKSAmJiBvbGRbbmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0c2V0QWNjZXNzb3IoZG9tLCBuYW1lLCBvbGRbbmFtZV0sIG9sZFtuYW1lXSA9IHVuZGVmaW5lZCwgaXNTdmdNb2RlKTtcblx0XHR9XG5cdH1cblxuXHQvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuXHRmb3IgKG5hbWUgaW4gYXR0cnMpIHtcblx0XHRpZiAobmFtZSAhPT0gJ2NoaWxkcmVuJyAmJiBuYW1lICE9PSAnaW5uZXJIVE1MJyAmJiAoIShuYW1lIGluIG9sZCkgfHwgYXR0cnNbbmFtZV0gIT09IChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdjaGVja2VkJyA/IGRvbVtuYW1lXSA6IG9sZFtuYW1lXSkpKSB7XG5cdFx0XHRzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gYXR0cnNbbmFtZV0sIGlzU3ZnTW9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKiBSZXRhaW5zIGEgcG9vbCBvZiBDb21wb25lbnRzIGZvciByZS11c2UsIGtleWVkIG9uIGNvbXBvbmVudCBuYW1lLlxuICpcdE5vdGU6IHNpbmNlIGNvbXBvbmVudCBuYW1lcyBhcmUgbm90IHVuaXF1ZSBvciBldmVuIG5lY2Vzc2FyaWx5IGF2YWlsYWJsZSwgdGhlc2UgYXJlIHByaW1hcmlseSBhIGZvcm0gb2Ygc2hhcmRpbmcuXG4gKlx0QHByaXZhdGVcbiAqL1xudmFyIGNvbXBvbmVudHMgPSB7fTtcblxuLyoqIFJlY2xhaW0gYSBjb21wb25lbnQgZm9yIGxhdGVyIHJlLXVzZSBieSB0aGUgcmVjeWNsZXIuICovXG5mdW5jdGlvbiBjb2xsZWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuXHR2YXIgbmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuXHQoY29tcG9uZW50c1tuYW1lXSB8fCAoY29tcG9uZW50c1tuYW1lXSA9IFtdKSkucHVzaChjb21wb25lbnQpO1xufVxuXG4vKiogQ3JlYXRlIGEgY29tcG9uZW50LiBOb3JtYWxpemVzIGRpZmZlcmVuY2VzIGJldHdlZW4gUEZDJ3MgYW5kIGNsYXNzZnVsIENvbXBvbmVudHMuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ3RvciwgcHJvcHMsIGNvbnRleHQpIHtcblx0dmFyIGxpc3QgPSBjb21wb25lbnRzW0N0b3IubmFtZV0sXG5cdCAgICBpbnN0O1xuXG5cdGlmIChDdG9yLnByb3RvdHlwZSAmJiBDdG9yLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRpbnN0ID0gbmV3IEN0b3IocHJvcHMsIGNvbnRleHQpO1xuXHRcdENvbXBvbmVudC5jYWxsKGluc3QsIHByb3BzLCBjb250ZXh0KTtcblx0fSBlbHNlIHtcblx0XHRpbnN0ID0gbmV3IENvbXBvbmVudChwcm9wcywgY29udGV4dCk7XG5cdFx0aW5zdC5jb25zdHJ1Y3RvciA9IEN0b3I7XG5cdFx0aW5zdC5yZW5kZXIgPSBkb1JlbmRlcjtcblx0fVxuXG5cdGlmIChsaXN0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07KSB7XG5cdFx0XHRpZiAobGlzdFtpXS5jb25zdHJ1Y3RvciA9PT0gQ3Rvcikge1xuXHRcdFx0XHRpbnN0Lm5leHRCYXNlID0gbGlzdFtpXS5uZXh0QmFzZTtcblx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gaW5zdDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuXG4vKiogU2V0IGEgY29tcG9uZW50J3MgYHByb3BzYCAoZ2VuZXJhbGx5IGRlcml2ZWQgZnJvbSBKU1ggYXR0cmlidXRlcykuXG4gKlx0QHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKlx0QHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucmVuZGVyU3luYz1mYWxzZV1cdElmIGB0cnVlYCBhbmQge0BsaW5rIG9wdGlvbnMuc3luY0NvbXBvbmVudFVwZGF0ZXN9IGlzIGB0cnVlYCwgdHJpZ2dlcnMgc3luY2hyb25vdXMgcmVuZGVyaW5nLlxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucmVuZGVyPXRydWVdXHRcdFx0SWYgYGZhbHNlYCwgbm8gcmVuZGVyIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICovXG5mdW5jdGlvbiBzZXRDb21wb25lbnRQcm9wcyhjb21wb25lbnQsIHByb3BzLCBvcHRzLCBjb250ZXh0LCBtb3VudEFsbCkge1xuXHRpZiAoY29tcG9uZW50Ll9kaXNhYmxlKSByZXR1cm47XG5cdGNvbXBvbmVudC5fZGlzYWJsZSA9IHRydWU7XG5cblx0aWYgKGNvbXBvbmVudC5fX3JlZiA9IHByb3BzLnJlZikgZGVsZXRlIHByb3BzLnJlZjtcblx0aWYgKGNvbXBvbmVudC5fX2tleSA9IHByb3BzLmtleSkgZGVsZXRlIHByb3BzLmtleTtcblxuXHRpZiAoIWNvbXBvbmVudC5iYXNlIHx8IG1vdW50QWxsKSB7XG5cdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0fSBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuXHRcdGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzLCBjb250ZXh0KTtcblx0fVxuXG5cdGlmIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGNvbXBvbmVudC5jb250ZXh0KSB7XG5cdFx0aWYgKCFjb21wb25lbnQucHJldkNvbnRleHQpIGNvbXBvbmVudC5wcmV2Q29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuXHRcdGNvbXBvbmVudC5jb250ZXh0ID0gY29udGV4dDtcblx0fVxuXG5cdGlmICghY29tcG9uZW50LnByZXZQcm9wcykgY29tcG9uZW50LnByZXZQcm9wcyA9IGNvbXBvbmVudC5wcm9wcztcblx0Y29tcG9uZW50LnByb3BzID0gcHJvcHM7XG5cblx0Y29tcG9uZW50Ll9kaXNhYmxlID0gZmFsc2U7XG5cblx0aWYgKG9wdHMgIT09IDApIHtcblx0XHRpZiAob3B0cyA9PT0gMSB8fCBvcHRpb25zLnN5bmNDb21wb25lbnRVcGRhdGVzICE9PSBmYWxzZSB8fCAhY29tcG9uZW50LmJhc2UpIHtcblx0XHRcdHJlbmRlckNvbXBvbmVudChjb21wb25lbnQsIDEsIG1vdW50QWxsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb21wb25lbnQuX19yZWYpIGNvbXBvbmVudC5fX3JlZihjb21wb25lbnQpO1xufVxuXG4vKiogUmVuZGVyIGEgQ29tcG9uZW50LCB0cmlnZ2VyaW5nIG5lY2Vzc2FyeSBsaWZlY3ljbGUgZXZlbnRzIGFuZCB0YWtpbmcgSGlnaC1PcmRlciBDb21wb25lbnRzIGludG8gYWNjb3VudC5cbiAqXHRAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gKlx0QHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYnVpbGQ9ZmFsc2VdXHRcdElmIGB0cnVlYCwgY29tcG9uZW50IHdpbGwgYnVpbGQgYW5kIHN0b3JlIGEgRE9NIG5vZGUgaWYgbm90IGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIG9uZS5cbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCBvcHRzLCBtb3VudEFsbCwgaXNDaGlsZCkge1xuXHRpZiAoY29tcG9uZW50Ll9kaXNhYmxlKSByZXR1cm47XG5cblx0dmFyIHByb3BzID0gY29tcG9uZW50LnByb3BzLFxuXHQgICAgc3RhdGUgPSBjb21wb25lbnQuc3RhdGUsXG5cdCAgICBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQsXG5cdCAgICBwcmV2aW91c1Byb3BzID0gY29tcG9uZW50LnByZXZQcm9wcyB8fCBwcm9wcyxcblx0ICAgIHByZXZpb3VzU3RhdGUgPSBjb21wb25lbnQucHJldlN0YXRlIHx8IHN0YXRlLFxuXHQgICAgcHJldmlvdXNDb250ZXh0ID0gY29tcG9uZW50LnByZXZDb250ZXh0IHx8IGNvbnRleHQsXG5cdCAgICBpc1VwZGF0ZSA9IGNvbXBvbmVudC5iYXNlLFxuXHQgICAgbmV4dEJhc2UgPSBjb21wb25lbnQubmV4dEJhc2UsXG5cdCAgICBpbml0aWFsQmFzZSA9IGlzVXBkYXRlIHx8IG5leHRCYXNlLFxuXHQgICAgaW5pdGlhbENoaWxkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9jb21wb25lbnQsXG5cdCAgICBza2lwID0gZmFsc2UsXG5cdCAgICByZW5kZXJlZCxcblx0ICAgIGluc3QsXG5cdCAgICBjYmFzZTtcblxuXHQvLyBpZiB1cGRhdGluZ1xuXHRpZiAoaXNVcGRhdGUpIHtcblx0XHRjb21wb25lbnQucHJvcHMgPSBwcmV2aW91c1Byb3BzO1xuXHRcdGNvbXBvbmVudC5zdGF0ZSA9IHByZXZpb3VzU3RhdGU7XG5cdFx0Y29tcG9uZW50LmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG5cdFx0aWYgKG9wdHMgIT09IDIgJiYgY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJiBjb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlKHByb3BzLCBzdGF0ZSwgY29udGV4dCkgPT09IGZhbHNlKSB7XG5cdFx0XHRza2lwID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG5cdFx0XHRjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuXHRcdH1cblx0XHRjb21wb25lbnQucHJvcHMgPSBwcm9wcztcblx0XHRjb21wb25lbnQuc3RhdGUgPSBzdGF0ZTtcblx0XHRjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG5cdH1cblxuXHRjb21wb25lbnQucHJldlByb3BzID0gY29tcG9uZW50LnByZXZTdGF0ZSA9IGNvbXBvbmVudC5wcmV2Q29udGV4dCA9IGNvbXBvbmVudC5uZXh0QmFzZSA9IG51bGw7XG5cdGNvbXBvbmVudC5fZGlydHkgPSBmYWxzZTtcblxuXHRpZiAoIXNraXApIHtcblx0XHRyZW5kZXJlZCA9IGNvbXBvbmVudC5yZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcblxuXHRcdC8vIGNvbnRleHQgdG8gcGFzcyB0byB0aGUgY2hpbGQsIGNhbiBiZSB1cGRhdGVkIHZpYSAoZ3JhbmQtKXBhcmVudCBjb21wb25lbnRcblx0XHRpZiAoY29tcG9uZW50LmdldENoaWxkQ29udGV4dCkge1xuXHRcdFx0Y29udGV4dCA9IGV4dGVuZChleHRlbmQoe30sIGNvbnRleHQpLCBjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdH1cblxuXHRcdHZhciBjaGlsZENvbXBvbmVudCA9IHJlbmRlcmVkICYmIHJlbmRlcmVkLm5vZGVOYW1lLFxuXHRcdCAgICB0b1VubW91bnQsXG5cdFx0ICAgIGJhc2U7XG5cblx0XHRpZiAodHlwZW9mIGNoaWxkQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBzZXQgdXAgaGlnaCBvcmRlciBjb21wb25lbnQgbGlua1xuXG5cdFx0XHR2YXIgY2hpbGRQcm9wcyA9IGdldE5vZGVQcm9wcyhyZW5kZXJlZCk7XG5cdFx0XHRpbnN0ID0gaW5pdGlhbENoaWxkQ29tcG9uZW50O1xuXG5cdFx0XHRpZiAoaW5zdCAmJiBpbnN0LmNvbnN0cnVjdG9yID09PSBjaGlsZENvbXBvbmVudCAmJiBjaGlsZFByb3BzLmtleSA9PSBpbnN0Ll9fa2V5KSB7XG5cdFx0XHRcdHNldENvbXBvbmVudFByb3BzKGluc3QsIGNoaWxkUHJvcHMsIDEsIGNvbnRleHQsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvVW5tb3VudCA9IGluc3Q7XG5cblx0XHRcdFx0Y29tcG9uZW50Ll9jb21wb25lbnQgPSBpbnN0ID0gY3JlYXRlQ29tcG9uZW50KGNoaWxkQ29tcG9uZW50LCBjaGlsZFByb3BzLCBjb250ZXh0KTtcblx0XHRcdFx0aW5zdC5uZXh0QmFzZSA9IGluc3QubmV4dEJhc2UgfHwgbmV4dEJhc2U7XG5cdFx0XHRcdGluc3QuX3BhcmVudENvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0XHRcdFx0c2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMCwgY29udGV4dCwgZmFsc2UpO1xuXHRcdFx0XHRyZW5kZXJDb21wb25lbnQoaW5zdCwgMSwgbW91bnRBbGwsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRiYXNlID0gaW5zdC5iYXNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYmFzZSA9IGluaXRpYWxCYXNlO1xuXG5cdFx0XHQvLyBkZXN0cm95IGhpZ2ggb3JkZXIgY29tcG9uZW50IGxpbmtcblx0XHRcdHRvVW5tb3VudCA9IGluaXRpYWxDaGlsZENvbXBvbmVudDtcblx0XHRcdGlmICh0b1VubW91bnQpIHtcblx0XHRcdFx0Y2Jhc2UgPSBjb21wb25lbnQuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbml0aWFsQmFzZSB8fCBvcHRzID09PSAxKSB7XG5cdFx0XHRcdGlmIChjYmFzZSkgY2Jhc2UuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0XHRcdGJhc2UgPSBkaWZmKGNiYXNlLCByZW5kZXJlZCwgY29udGV4dCwgbW91bnRBbGwgfHwgIWlzVXBkYXRlLCBpbml0aWFsQmFzZSAmJiBpbml0aWFsQmFzZS5wYXJlbnROb2RlLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaW5pdGlhbEJhc2UgJiYgYmFzZSAhPT0gaW5pdGlhbEJhc2UgJiYgaW5zdCAhPT0gaW5pdGlhbENoaWxkQ29tcG9uZW50KSB7XG5cdFx0XHR2YXIgYmFzZVBhcmVudCA9IGluaXRpYWxCYXNlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoYmFzZVBhcmVudCAmJiBiYXNlICE9PSBiYXNlUGFyZW50KSB7XG5cdFx0XHRcdGJhc2VQYXJlbnQucmVwbGFjZUNoaWxkKGJhc2UsIGluaXRpYWxCYXNlKTtcblxuXHRcdFx0XHRpZiAoIXRvVW5tb3VudCkge1xuXHRcdFx0XHRcdGluaXRpYWxCYXNlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKGluaXRpYWxCYXNlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodG9Vbm1vdW50KSB7XG5cdFx0XHR1bm1vdW50Q29tcG9uZW50KHRvVW5tb3VudCk7XG5cdFx0fVxuXG5cdFx0Y29tcG9uZW50LmJhc2UgPSBiYXNlO1xuXHRcdGlmIChiYXNlICYmICFpc0NoaWxkKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50LFxuXHRcdFx0ICAgIHQgPSBjb21wb25lbnQ7XG5cdFx0XHR3aGlsZSAodCA9IHQuX3BhcmVudENvbXBvbmVudCkge1xuXHRcdFx0XHQoY29tcG9uZW50UmVmID0gdCkuYmFzZSA9IGJhc2U7XG5cdFx0XHR9XG5cdFx0XHRiYXNlLl9jb21wb25lbnQgPSBjb21wb25lbnRSZWY7XG5cdFx0XHRiYXNlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9IGNvbXBvbmVudFJlZi5jb25zdHJ1Y3Rvcjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWlzVXBkYXRlIHx8IG1vdW50QWxsKSB7XG5cdFx0bW91bnRzLnVuc2hpZnQoY29tcG9uZW50KTtcblx0fSBlbHNlIGlmICghc2tpcCkge1xuXHRcdC8vIEVuc3VyZSB0aGF0IHBlbmRpbmcgY29tcG9uZW50RGlkTW91bnQoKSBob29rcyBvZiBjaGlsZCBjb21wb25lbnRzXG5cdFx0Ly8gYXJlIGNhbGxlZCBiZWZvcmUgdGhlIGNvbXBvbmVudERpZFVwZGF0ZSgpIGhvb2sgaW4gdGhlIHBhcmVudC5cblx0XHQvLyBOb3RlOiBkaXNhYmxlZCBhcyBpdCBjYXVzZXMgZHVwbGljYXRlIGhvb2tzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvaXNzdWVzLzc1MFxuXHRcdC8vIGZsdXNoTW91bnRzKCk7XG5cblx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZSkge1xuXHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlLCBwcmV2aW91c0NvbnRleHQpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5hZnRlclVwZGF0ZSkgb3B0aW9ucy5hZnRlclVwZGF0ZShjb21wb25lbnQpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzICE9IG51bGwpIHtcblx0XHR3aGlsZSAoY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5wb3AoKS5jYWxsKGNvbXBvbmVudCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFkaWZmTGV2ZWwgJiYgIWlzQ2hpbGQpIGZsdXNoTW91bnRzKCk7XG59XG5cbi8qKiBBcHBseSB0aGUgQ29tcG9uZW50IHJlZmVyZW5jZWQgYnkgYSBWTm9kZSB0byB0aGUgRE9NLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRUaGUgRE9NIG5vZGUgdG8gbXV0YXRlXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdEEgQ29tcG9uZW50LXJlZmVyZW5jaW5nIFZOb2RlXG4gKlx0QHJldHVybnMge0VsZW1lbnR9IGRvbVx0VGhlIGNyZWF0ZWQvbXV0YXRlZCBlbGVtZW50XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRDb21wb25lbnRGcm9tVk5vZGUoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwpIHtcblx0dmFyIGMgPSBkb20gJiYgZG9tLl9jb21wb25lbnQsXG5cdCAgICBvcmlnaW5hbENvbXBvbmVudCA9IGMsXG5cdCAgICBvbGREb20gPSBkb20sXG5cdCAgICBpc0RpcmVjdE93bmVyID0gYyAmJiBkb20uX2NvbXBvbmVudENvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZSxcblx0ICAgIGlzT3duZXIgPSBpc0RpcmVjdE93bmVyLFxuXHQgICAgcHJvcHMgPSBnZXROb2RlUHJvcHModm5vZGUpO1xuXHR3aGlsZSAoYyAmJiAhaXNPd25lciAmJiAoYyA9IGMuX3BhcmVudENvbXBvbmVudCkpIHtcblx0XHRpc093bmVyID0gYy5jb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG5cdH1cblxuXHRpZiAoYyAmJiBpc093bmVyICYmICghbW91bnRBbGwgfHwgYy5fY29tcG9uZW50KSkge1xuXHRcdHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAzLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdFx0ZG9tID0gYy5iYXNlO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChvcmlnaW5hbENvbXBvbmVudCAmJiAhaXNEaXJlY3RPd25lcikge1xuXHRcdFx0dW5tb3VudENvbXBvbmVudChvcmlnaW5hbENvbXBvbmVudCk7XG5cdFx0XHRkb20gPSBvbGREb20gPSBudWxsO1xuXHRcdH1cblxuXHRcdGMgPSBjcmVhdGVDb21wb25lbnQodm5vZGUubm9kZU5hbWUsIHByb3BzLCBjb250ZXh0KTtcblx0XHRpZiAoZG9tICYmICFjLm5leHRCYXNlKSB7XG5cdFx0XHRjLm5leHRCYXNlID0gZG9tO1xuXHRcdFx0Ly8gcGFzc2luZyBkb20vb2xkRG9tIGFzIG5leHRCYXNlIHdpbGwgcmVjeWNsZSBpdCBpZiB1bnVzZWQsIHNvIGJ5cGFzcyByZWN5Y2xpbmcgb24gTDIyOTpcblx0XHRcdG9sZERvbSA9IG51bGw7XG5cdFx0fVxuXHRcdHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAxLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdFx0ZG9tID0gYy5iYXNlO1xuXG5cdFx0aWYgKG9sZERvbSAmJiBkb20gIT09IG9sZERvbSkge1xuXHRcdFx0b2xkRG9tLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0cmVjb2xsZWN0Tm9kZVRyZWUob2xkRG9tLCBmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHJlY3ljbGUgaXQuXG4gKlx0QHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudFx0VGhlIENvbXBvbmVudCBpbnN0YW5jZSB0byB1bm1vdW50XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudChjb21wb25lbnQpIHtcblx0aWYgKG9wdGlvbnMuYmVmb3JlVW5tb3VudCkgb3B0aW9ucy5iZWZvcmVVbm1vdW50KGNvbXBvbmVudCk7XG5cblx0dmFyIGJhc2UgPSBjb21wb25lbnQuYmFzZTtcblxuXHRjb21wb25lbnQuX2Rpc2FibGUgPSB0cnVlO1xuXG5cdGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXG5cdGNvbXBvbmVudC5iYXNlID0gbnVsbDtcblxuXHQvLyByZWN1cnNpdmVseSB0ZWFyIGRvd24gJiByZWNvbGxlY3QgaGlnaC1vcmRlciBjb21wb25lbnQgY2hpbGRyZW46XG5cdHZhciBpbm5lciA9IGNvbXBvbmVudC5fY29tcG9uZW50O1xuXHRpZiAoaW5uZXIpIHtcblx0XHR1bm1vdW50Q29tcG9uZW50KGlubmVyKTtcblx0fSBlbHNlIGlmIChiYXNlKSB7XG5cdFx0aWYgKGJhc2VbJ19fcHJlYWN0YXR0cl8nXSAmJiBiYXNlWydfX3ByZWFjdGF0dHJfJ10ucmVmKSBiYXNlWydfX3ByZWFjdGF0dHJfJ10ucmVmKG51bGwpO1xuXG5cdFx0Y29tcG9uZW50Lm5leHRCYXNlID0gYmFzZTtcblxuXHRcdHJlbW92ZU5vZGUoYmFzZSk7XG5cdFx0Y29sbGVjdENvbXBvbmVudChjb21wb25lbnQpO1xuXG5cdFx0cmVtb3ZlQ2hpbGRyZW4oYmFzZSk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50Ll9fcmVmKSBjb21wb25lbnQuX19yZWYobnVsbCk7XG59XG5cbi8qKiBCYXNlIENvbXBvbmVudCBjbGFzcy5cbiAqXHRQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2ggdHJpZ2dlciByZW5kZXJpbmcuXG4gKlx0QHB1YmxpY1xuICpcbiAqXHRAZXhhbXBsZVxuICpcdGNsYXNzIE15Rm9vIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqXHRcdHJlbmRlcihwcm9wcywgc3RhdGUpIHtcbiAqXHRcdFx0cmV0dXJuIDxkaXYgLz47XG4gKlx0XHR9XG4gKlx0fVxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXG5cdC8qKiBAcHVibGljXG4gICpcdEB0eXBlIHtvYmplY3R9XG4gICovXG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cblx0LyoqIEBwdWJsaWNcbiAgKlx0QHR5cGUge29iamVjdH1cbiAgKi9cblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXG5cdC8qKiBAcHVibGljXG4gICpcdEB0eXBlIHtvYmplY3R9XG4gICovXG5cdHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xufVxuXG5leHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwge1xuXG5cdC8qKiBSZXR1cm5zIGEgYGJvb2xlYW5gIGluZGljYXRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgcmUtcmVuZGVyIHdoZW4gcmVjZWl2aW5nIHRoZSBnaXZlbiBgcHJvcHNgIGFuZCBgc3RhdGVgLlxuICAqXHRAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICpcdEBwYXJhbSB7b2JqZWN0fSBuZXh0U3RhdGVcbiAgKlx0QHBhcmFtIHtvYmplY3R9IG5leHRDb250ZXh0XG4gICpcdEByZXR1cm5zIHtCb29sZWFufSBzaG91bGQgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJcbiAgKlx0QG5hbWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gICpcdEBmdW5jdGlvblxuICAqL1xuXG5cdC8qKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGJ5IGNvcHlpbmcgcHJvcGVydGllcyBmcm9tIGBzdGF0ZWAgdG8gYHRoaXMuc3RhdGVgLlxuICAqXHRAcGFyYW0ge29iamVjdH0gc3RhdGVcdFx0QSBoYXNoIG9mIHN0YXRlIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlc1xuICAqXHRAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1x0QSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXMgdXBkYXRlZFxuICAqL1xuXHRzZXRTdGF0ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHMgPSB0aGlzLnN0YXRlO1xuXHRcdGlmICghdGhpcy5wcmV2U3RhdGUpIHRoaXMucHJldlN0YXRlID0gZXh0ZW5kKHt9LCBzKTtcblx0XHRleHRlbmQocywgdHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nID8gc3RhdGUocywgdGhpcy5wcm9wcykgOiBzdGF0ZSk7XG5cdFx0aWYgKGNhbGxiYWNrKSAodGhpcy5fcmVuZGVyQ2FsbGJhY2tzID0gdGhpcy5fcmVuZGVyQ2FsbGJhY2tzIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9LFxuXG5cblx0LyoqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudC5cbiAgKlx0QHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcdFx0QSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHJlLXJlbmRlcmVkLlxuICAqXHRAcHJpdmF0ZVxuICAqL1xuXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoY2FsbGJhY2spIHtcblx0XHRpZiAoY2FsbGJhY2spICh0aGlzLl9yZW5kZXJDYWxsYmFja3MgPSB0aGlzLl9yZW5kZXJDYWxsYmFja3MgfHwgW10pLnB1c2goY2FsbGJhY2spO1xuXHRcdHJlbmRlckNvbXBvbmVudCh0aGlzLCAyKTtcblx0fSxcblxuXG5cdC8qKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gICpcdFZpcnR1YWwgRE9NIGlzIGdlbmVyYWxseSBjb25zdHJ1Y3RlZCB2aWEgW0pTWF0oaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4KS5cbiAgKlx0QHBhcmFtIHtvYmplY3R9IHByb3BzXHRcdFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50IGVsZW1lbnQvY29tcG9uZW50XG4gICpcdEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVx0XHRUaGUgY29tcG9uZW50J3MgY3VycmVudCBzdGF0ZVxuICAqXHRAcGFyYW0ge29iamVjdH0gY29udGV4dFx0XHRDb250ZXh0IG9iamVjdCAoaWYgYSBwYXJlbnQgY29tcG9uZW50IGhhcyBwcm92aWRlZCBjb250ZXh0KVxuICAqXHRAcmV0dXJucyBWTm9kZVxuICAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHt9XG59KTtcblxuLyoqIFJlbmRlciBKU1ggaW50byBhIGBwYXJlbnRgIEVsZW1lbnQuXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdFx0QSAoSlNYKSBWTm9kZSB0byByZW5kZXJcbiAqXHRAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFx0XHRET00gZWxlbWVudCB0byByZW5kZXIgaW50b1xuICpcdEBwYXJhbSB7RWxlbWVudH0gW21lcmdlXVx0QXR0ZW1wdCB0byByZS11c2UgYW4gZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGBtZXJnZWBcbiAqXHRAcHVibGljXG4gKlxuICpcdEBleGFtcGxlXG4gKlx0Ly8gcmVuZGVyIGEgZGl2IGludG8gPGJvZHk+OlxuICpcdHJlbmRlcig8ZGl2IGlkPVwiaGVsbG9cIj5oZWxsbyE8L2Rpdj4sIGRvY3VtZW50LmJvZHkpO1xuICpcbiAqXHRAZXhhbXBsZVxuICpcdC8vIHJlbmRlciBhIFwiVGhpbmdcIiBjb21wb25lbnQgaW50byAjZm9vOlxuICpcdGNvbnN0IFRoaW5nID0gKHsgbmFtZSB9KSA9PiA8c3Bhbj57IG5hbWUgfTwvc3Bhbj47XG4gKlx0cmVuZGVyKDxUaGluZyBuYW1lPVwib25lXCIgLz4sIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmb28nKSk7XG4gKi9cbmZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBtZXJnZSkge1xuICByZXR1cm4gZGlmZihtZXJnZSwgdm5vZGUsIHt9LCBmYWxzZSwgcGFyZW50LCBmYWxzZSk7XG59XG5cbnZhciBwcmVhY3QgPSB7XG5cdGg6IGgsXG5cdGNyZWF0ZUVsZW1lbnQ6IGgsXG5cdGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuXHRDb21wb25lbnQ6IENvbXBvbmVudCxcblx0cmVuZGVyOiByZW5kZXIsXG5cdHJlcmVuZGVyOiByZXJlbmRlcixcblx0b3B0aW9uczogb3B0aW9uc1xufTtcblxuZXhwb3J0IHsgaCwgaCBhcyBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQsIENvbXBvbmVudCwgcmVuZGVyLCByZXJlbmRlciwgb3B0aW9ucyB9O2V4cG9ydCBkZWZhdWx0IHByZWFjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5lc20uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0LmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5lc20uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc2FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nXG4gIHZhciByZXNcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdXG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV1cbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoXG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XVxuICAgIHZhciBwcmVmaXggPSByZXNbMl1cbiAgICB2YXIgbmFtZSA9IHJlc1szXVxuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdXG4gICAgdmFyIGdyb3VwID0gcmVzWzVdXG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddXG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKVxuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KVxuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KVxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpXG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fVxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXVxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKVxuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXNcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlXG4gIHZhciByb3V0ZSA9ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KVxuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSdcblxuICAgICAga2V5cy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmVcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJylcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXJcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/J1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJ1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSdcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRobmFtZSkge1xuICByZXR1cm4gcGF0aG5hbWUuY2hhckF0KDApID09PSAnLyc7XG59XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkge1xuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICB9XG5cbiAgbGlzdC5wb3AoKTtcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBoZWF2aWx5IG9uIG5vZGUncyB1cmwucGFyc2VcbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZSh0bykge1xuICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgdmFyIHRvUGFydHMgPSB0byAmJiB0by5zcGxpdCgnLycpIHx8IFtdO1xuICB2YXIgZnJvbVBhcnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcvJykgfHwgW107XG5cbiAgdmFyIGlzVG9BYnMgPSB0byAmJiBpc0Fic29sdXRlKHRvKTtcbiAgdmFyIGlzRnJvbUFicyA9IGZyb20gJiYgaXNBYnNvbHV0ZShmcm9tKTtcbiAgdmFyIG11c3RFbmRBYnMgPSBpc1RvQWJzIHx8IGlzRnJvbUFicztcblxuICBpZiAodG8gJiYgaXNBYnNvbHV0ZSh0bykpIHtcbiAgICAvLyB0byBpcyBhYnNvbHV0ZVxuICAgIGZyb21QYXJ0cyA9IHRvUGFydHM7XG4gIH0gZWxzZSBpZiAodG9QYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyB0byBpcyByZWxhdGl2ZSwgZHJvcCB0aGUgZmlsZW5hbWVcbiAgICBmcm9tUGFydHMucG9wKCk7XG4gICAgZnJvbVBhcnRzID0gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKTtcbiAgfVxuXG4gIGlmICghZnJvbVBhcnRzLmxlbmd0aCkgcmV0dXJuICcvJztcblxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbiAgaWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdCA9IGZyb21QYXJ0c1tmcm9tUGFydHMubGVuZ3RoIC0gMV07XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nIHx8IGxhc3QgPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBmcm9tUGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gZnJvbVBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXVzdEVuZEFicykgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgZnJvbVBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gIH1pZiAobXVzdEVuZEFicyAmJiBmcm9tUGFydHNbMF0gIT09ICcnICYmICghZnJvbVBhcnRzWzBdIHx8ICFpc0Fic29sdXRlKGZyb21QYXJ0c1swXSkpKSBmcm9tUGFydHMudW5zaGlmdCgnJyk7XG5cbiAgdmFyIHJlc3VsdCA9IGZyb21QYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgcmVzdWx0LnN1YnN0cigtMSkgIT09ICcvJykgcmVzdWx0ICs9ICcvJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlUGF0aG5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdCb3g9XFxcIjAgMCAyMyAyN1xcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIj48ZyBpZD1cXFwiTVZQXFxcIiBzdHJva2U9XFxcIm5vbmVcXFwiIHN0cm9rZS13aWR0aD1cXFwiMVxcXCIgZmlsbD1cXFwibm9uZVxcXCIgZmlsbC1ydWxlPVxcXCJldmVub2RkXFxcIj48ZyBpZD1cXFwibGlua1N0YXR1czJcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC04OTkuMDAwMDAwLCAtNjM4LjAwMDAwMClcXFwiIGZpbGw9XFxcIiMxQjI0MzdcXFwiPjxnIGlkPVxcXCJHcm91cC02XFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSg2NTUuMDAwMDAwLCA2MzEuMDAwMDAwKVxcXCI+PHBhdGggZD1cXFwiTTI1NS40NTIsNi45OTkyIEwyNDQsMTUuODE1MiBMMjQ0LDI0LjQ2ODIgTDI1NS40NTIsMzMuMjg0MiBMMjY2LjkwNCwyNC40NjgyIEwyNjYuOTA0LDE1LjgxNTIgTDI1NS40NTIsNi45OTkyIFogTTI1OS44NzQsMTguMTM3MiBMMjU2LjIyNCwxNS4zMjgyIEwyNTYuMjI0LDkuNzAzMiBMMjY0Ljc2MSwxNi4yNzQyIEwyNjEuMjYxLDE4Ljk3MDIgTDI1OC45NjUsMjAuNzM5MiBMMjU4Ljk2MywyMC43MzcyIEwyNTUuNDUyLDIzLjQ0MTIgTDI1Mi40LDIxLjA5MjIgTDI1MS4wMzEsMjIuMTQ2MiBMMjU0LjY3OSwyNC45NTYyIEwyNTQuNjc5LDMwLjU4MTIgTDI0Ni4xNDIsMjQuMDA5MiBMMjQ5Ljc5NiwyMS4xOTYyIEwyNTEuOTQxLDE5LjU0NDIgTDI1MS45NDEsMTkuNTQ1MiBMMjU1LjQ1MiwxNi44NDIyIEwyNTguNTA0LDE5LjE5MTIgTDI1OS44NzQsMTguMTM3MiBaIE0yNDguNTYyLDE4LjEzNzIgTDI0Ni4xNDIsMTYuMjc0MiBMMjU0LjY3OSw5LjcwMzIgTDI1NC42NzksMTUuMzI4MiBMMjQ5Ljc5NiwxOS4wODcyIEwyNDguNDI3LDIwLjE0MTIgTDI0OC4zODEsMjAuMTc3MiBMMjQ3LjY1MiwyMC43MzgyIEwyNDUuNTQ2LDIyLjM1OTIgTDI0NS41NDYsMTcuOTIzMiBMMjQ3LjE5MywxOS4xOTAyIEwyNDguNTYyLDE4LjEzNzIgWiBNMjU2LjIyNCwyNC45NTYyIEwyNjEuMTA4LDIxLjE5NjIgTDI2My4wODEsMTkuNjc2MiBMMjY1LjM1OCwxNy45MjMyIEwyNjUuMzU4LDIyLjM1OTIgTDI2My43MTEsMjEuMDkyMiBMMjYyLjM0MiwyMi4xNDYyIEwyNjQuNzYxLDI0LjAwOTIgTDI1Ni4yMjQsMzAuNTgxMiBMMjU2LjIyNCwyNC45NTYyIFpcXFwiIGlkPVxcXCJQYWdlLTFcXFwiPjwvcGF0aD48L2c+PC9nPjwvZz48L3N2Zz5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9zdmctaW5saW5lLWxvYWRlcj9yZW1vdmVUYWdzPXRydWUmcmVtb3ZlU1ZHVGFnQXR0cnM9dHJ1ZSEuL2ltYWdlcy9jdWJlLnN2Z1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3N2Zy1pbmxpbmUtbG9hZGVyL2luZGV4LmpzP3JlbW92ZVRhZ3M9dHJ1ZSZyZW1vdmVTVkdUYWdBdHRycz10cnVlIS4vaW1hZ2VzL2N1YmUuc3ZnXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYWRzTGlzdF9fc2VsZi0tMUNPajkgLmFkc0xpc3RfX3Jvdy0tMmVNNWZ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93O3BhZGRpbmc6MTBweH0uYWRzTGlzdF9fc2VsZi0tMUNPajkgLmFkc0xpc3RfX2J1dHRvbi0tby1Dbjh7bWFyZ2luLWxlZnQ6YXV0b31cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLDJDQUFXLG9CQUFvQixvQkFBb0IsYUFBYSw4QkFBOEIsNkJBQTZCLHVCQUF1QixtQkFBbUIsWUFBWSxDQUFDLDhDQUFjLGdCQUFnQixDQUFDXCIsXCJmaWxlXCI6XCJhZHNMaXN0LnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGYgLnJvd3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzoxMHB4fS5zZWxmIC5idXR0b257bWFyZ2luLWxlZnQ6YXV0b31cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImFkc0xpc3RfX3NlbGYtLTFDT2o5XCIsXG5cdFwicm93XCI6IFwiYWRzTGlzdF9fcm93LS0yZU01ZlwiLFxuXHRcImJ1dHRvblwiOiBcImFkc0xpc3RfX2J1dHRvbi0tby1DbjhcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYnV0dG9uX19zZWxmLS0xSEJWc3tib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmU7Zm9udC1mYW1pbHk6UFQgU2Fuczstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtiYWNrZ3JvdW5kLWNvbG9yOiMyNjNmZmY7bGV0dGVyLXNwYWNpbmc6LjAxZW19LmJ1dHRvbl9fc2VsZi0tMUhCVnMuYnV0dG9uX19wcmltYXJ5LS0ybXJLdntmb250LXdlaWdodDozMDA7Y29sb3I6I2ZmZjtmb250LXNpemU6MTVweDtib3JkZXItcmFkaXVzOjNweDtwYWRkaW5nOjEzcHggMjVweCFpbXBvcnRhbnR9LmJ1dHRvbl9fc2VsZi0tMUhCVnMuYnV0dG9uX19zZWNvbmRhcnktLTJJbW94e2Zsb2F0OnJpZ2h0O2JhY2tncm91bmQtY29sb3I6I2NmZDlmYTtib3JkZXItcmFkaXVzOjUwcHg7Y29sb3I6IzI2M2ZmZjtoZWlnaHQ6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo3MDA7LXdlYmtpdC1ib3gtc2hhZG93OjAgNXB4IDEycHggcmdiYSgxODQsMTg4LDIwNiwuNSk7Ym94LXNoYWRvdzowIDVweCAxMnB4IHJnYmEoMTg0LDE4OCwyMDYsLjUpfS5idXR0b25fX3NlbGYtLTFIQlZzLmJ1dHRvbl9fc2Vjb25kYXJ5LS0ySW1veDpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOiM4OTkzOWY7b3BhY2l0eTouNDtjdXJzb3I6bm90LWFsbG93ZWQ7Y29sb3I6I2ZmZn0uYnV0dG9uX19zZWxmLS0xSEJWcy5idXR0b25fX3NlY29uZGFyeS0tMkltb3g6bm90KFtkaXNhYmxlZF0pOmhvdmVyey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTJweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTJweCl9LmJ1dHRvbl9fc2VsZi0tMUhCVnM6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojODk5MzlmO29wYWNpdHk6LjQ7Y3Vyc29yOm5vdC1hbGxvd2VkO2NvbG9yOiNmZmZ9LmJ1dHRvbl9fc2VsZi0tMUhCVnM6bm90KFtkaXNhYmxlZF0pOmhvdmVye2N1cnNvcjpwb2ludGVyO2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMjYzZmZmOy13ZWJraXQtYm94LXNoYWRvdzowIDVweCAxNXB4IHJnYmEoNTAsOTMsMjU1LC40NSk7Ym94LXNoYWRvdzowIDVweCAxNXB4IHJnYmEoNTAsOTMsMjU1LC40NSk7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMXB4KX0uYnV0dG9uX19zZWxmLS0xSEJWczphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMjYzZmZmfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxxQkFBTSxZQUFZLGFBQWEsb0JBQXNCLG1DQUFtQyxrQ0FBa0MseUJBQXlCLG9CQUFxQixDQUFDLDRDQUFjLGdCQUFnQixXQUFXLGVBQWUsa0JBQWtCLDJCQUE0QixDQUFDLDhDQUFnQixZQUFZLHlCQUF5QixtQkFBbUIsY0FBYyxZQUFZLGtCQUFrQixlQUFlLGdCQUFnQixtREFBc0QsMENBQTZDLENBQUMsdURBQXlCLHlCQUF5QixXQUFZLG1CQUFtQixVQUFVLENBQUMsb0VBQXNDLG1DQUFtQywwQkFBMEIsQ0FBQyw4QkFBZSx5QkFBeUIsV0FBWSxtQkFBbUIsVUFBVSxDQUFDLDJDQUE0QixlQUFlLFdBQVcseUJBQXlCLGtEQUFxRCwwQ0FBNkMsbUNBQW1DLDBCQUEwQixDQUFDLDRCQUFhLHdCQUF3QixDQUFDXCIsXCJmaWxlXCI6XCJidXR0b24uc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmU7Zm9udC1mYW1pbHk6J1BUIFNhbnMnOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2JhY2tncm91bmQtY29sb3I6IzI2M2ZmZjtsZXR0ZXItc3BhY2luZzowLjAxZW19LnNlbGYucHJpbWFyeXtmb250LXdlaWdodDozMDA7Y29sb3I6I2ZmZjtmb250LXNpemU6MTVweDtib3JkZXItcmFkaXVzOjNweDtwYWRkaW5nOjEzcHggMjVweCAhaW1wb3J0YW50fS5zZWxmLnNlY29uZGFyeXtmbG9hdDpyaWdodDtiYWNrZ3JvdW5kLWNvbG9yOiNjZmQ5ZmE7Ym9yZGVyLXJhZGl1czo1MHB4O2NvbG9yOiMyNjNmZmY7aGVpZ2h0OjIwcHg7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NzAwOy13ZWJraXQtYm94LXNoYWRvdzowcHggNXB4IDEycHggcmdiYSgxODQsMTg4LDIwNiwwLjUpO2JveC1zaGFkb3c6MHB4IDVweCAxMnB4IHJnYmEoMTg0LDE4OCwyMDYsMC41KX0uc2VsZi5zZWNvbmRhcnk6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojODk5MzlmO29wYWNpdHk6MC40O2N1cnNvcjpub3QtYWxsb3dlZDtjb2xvcjojZmZmfS5zZWxmLnNlY29uZGFyeTpub3QoW2Rpc2FibGVkXSk6aG92ZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMnB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMnB4KX0uc2VsZjpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOiM4OTkzOWY7b3BhY2l0eTowLjQ7Y3Vyc29yOm5vdC1hbGxvd2VkO2NvbG9yOiNmZmZ9LnNlbGY6bm90KFtkaXNhYmxlZF0pOmhvdmVye2N1cnNvcjpwb2ludGVyO2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMjYzZmZmOy13ZWJraXQtYm94LXNoYWRvdzowcHggNXB4IDE1cHggcmdiYSg1MCw5MywyNTUsMC40NSk7Ym94LXNoYWRvdzowcHggNXB4IDE1cHggcmdiYSg1MCw5MywyNTUsMC40NSk7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMXB4KX0uc2VsZjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMjYzZmZmfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwiYnV0dG9uX19zZWxmLS0xSEJWc1wiLFxuXHRcInByaW1hcnlcIjogXCJidXR0b25fX3ByaW1hcnktLTJtckt2XCIsXG5cdFwic2Vjb25kYXJ5XCI6IFwiYnV0dG9uX19zZWNvbmRhcnktLTJJbW94XCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2J1dHRvbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYnV0dG9uLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5pY29uX19zZWxmLS0xaHROSHtmb250LXNpemU6LjhlbX1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG1CQUFNLGNBQWUsQ0FBQ1wiLFwiZmlsZVwiOlwiaWNvbi5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme2ZvbnQtc2l6ZTowLjhlbX1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImljb25fX3NlbGYtLTFodE5IXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2ljb24uc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2ljb24uc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmlucHV0X19zZWxmLS1TdGE2VXtwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tYm90dG9tOjIwcHg7bWFyZ2luLXRvcDoyMHB4O3dpZHRoOjEwMCU7Zm9udC1mYW1pbHk6UFQgU2Fuczstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTstd2Via2l0LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH0uaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9faW5wdXQtLTFoNktNe2ZvbnQtc2l6ZToxNXB4O3BhZGRpbmc6MTBweDt3aWR0aDpjYWxjKDEwMCUgLSAzMHB4KTtiYWNrZ3JvdW5kLWNvbG9yOiNmNWY3ZmE7Ym9yZGVyOjFweCBzb2xpZCAjZWVmMWYyO2JvcmRlci1yYWRpdXM6M3B4Oy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9faW5wdXQtLTFoNktNOmZvY3Vze291dGxpbmU6bm9uZTtib3JkZXI6MXB4IHNvbGlkICMyNjNmZmY7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19pbnB1dC0tMWg2S006LW1vei1wbGFjZWhvbGRlcntib3gtc2hhZG93Om5vbmUhaW1wb3J0YW50fS5pbnB1dF9fc2VsZi0tU3RhNlUuaW5wdXRfX2ludmFsaWQtLTNWbWhve21hcmdpbi1ib3R0b206Y2FsYygzMHB4IC0gMWVtKX0uaW5wdXRfX3NlbGYtLVN0YTZVLmlucHV0X19pbnZhbGlkLS0zVm1obz4uaW5wdXRfX2lucHV0LS0xaDZLTXstd2Via2l0LWJveC1zaGFkb3c6MCAwIDVweCAxcHggcmVkO2JveC1zaGFkb3c6MCAwIDVweCAxcHggcmVkfS5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19wbGFjZWhvbGRlci0tMjZLOHl7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwcHg7bGVmdDo1cHg7Y29sb3I6Izg5OTM5Zjtmb250LXNpemU6MTVweDstd2Via2l0LXRyYW5zaXRpb246LjJzO3RyYW5zaXRpb246LjJzfS5pbnB1dF9fc2VsZi0tU3RhNlUgLmlucHV0X19pbnB1dC0tMWg2S006ZGlzYWJsZWR+LmlucHV0X19wbGFjZWhvbGRlci0tMjZLOHksLmlucHV0X19zZWxmLS1TdGE2VSAuaW5wdXRfX2lucHV0LS0xaDZLTTpmb2N1c34uaW5wdXRfX3BsYWNlaG9sZGVyLS0yNks4eSwuaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9faW5wdXQtLTFoNktNOnZhbGlkfi5pbnB1dF9fcGxhY2Vob2xkZXItLTI2Szh5e2NvbG9yOiMxYjI0Mzc7Zm9udC1zaXplOjExcHg7dG9wOi0xNnB4O2xlZnQ6MH0uaW5wdXRfX3NlbGYtLVN0YTZVIC5pbnB1dF9fZXJyb3ItLTNtVW84e2NvbG9yOnJlZDtoZWlnaHQ6MWVtO2ZvbnQtc2l6ZTouOGVtO2ZvbnQtd2VpZ2h0OjYwMH1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaW5wdXQuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxvQkFBTSxrQkFBa0IsbUJBQW1CLGdCQUFnQixXQUFXLG9CQUFzQixtQ0FBbUMsa0NBQWtDLGtDQUFtQyx5QkFBMEIsQ0FBQyx5Q0FBYSxlQUFlLGFBQWEsd0JBQXdCLHlCQUF5Qix5QkFBeUIsa0JBQWtCLHdCQUF3QixlQUFlLENBQUMsK0NBQW1CLGFBQWEseUJBQXlCLHFCQUFxQixDQUFDLDBEQUE4Qix5QkFBMEIsQ0FBQywwQ0FBYyw4QkFBOEIsQ0FBQywrREFBcUIsbUNBQW1DLDBCQUEwQixDQUFDLCtDQUFtQixrQkFBa0IsU0FBUyxTQUFTLGNBQWMsZUFBZSx1QkFBd0IsY0FBZSxDQUFDLGlPQUF5RyxjQUFjLGVBQWUsVUFBVSxNQUFRLENBQUMseUNBQWEsVUFBVSxXQUFXLGVBQWdCLGVBQWUsQ0FBQ1wiLFwiZmlsZVwiOlwiaW5wdXQuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tYm90dG9tOjIwcHg7bWFyZ2luLXRvcDoyMHB4O3dpZHRoOjEwMCU7Zm9udC1mYW1pbHk6J1BUIFNhbnMnOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtdHJhbnNpdGlvbjpub25lICFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lICFpbXBvcnRhbnR9LnNlbGYgLmlucHV0e2ZvbnQtc2l6ZToxNXB4O3BhZGRpbmc6MTBweDt3aWR0aDpjYWxjKDEwMCUgLSAzMHB4KTtiYWNrZ3JvdW5kLWNvbG9yOiNmNWY3ZmE7Ym9yZGVyOjFweCBzb2xpZCAjZWVmMWYyO2JvcmRlci1yYWRpdXM6M3B4Oy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uc2VsZiAuaW5wdXQ6Zm9jdXN7b3V0bGluZTpub25lO2JvcmRlcjoxcHggc29saWQgIzI2M2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnNlbGYgLmlucHV0Oi1tb3otcGxhY2Vob2xkZXJ7Ym94LXNoYWRvdzpub25lICFpbXBvcnRhbnR9LnNlbGYuaW52YWxpZHttYXJnaW4tYm90dG9tOmNhbGMoMzBweCAtIDFlbSl9LnNlbGYuaW52YWxpZD4uaW5wdXR7LXdlYmtpdC1ib3gtc2hhZG93OjAgMCA1cHggMXB4IHJlZDtib3gtc2hhZG93OjAgMCA1cHggMXB4IHJlZH0uc2VsZiAucGxhY2Vob2xkZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwcHg7bGVmdDo1cHg7Y29sb3I6Izg5OTM5Zjtmb250LXNpemU6MTVweDstd2Via2l0LXRyYW5zaXRpb246MC4yczt0cmFuc2l0aW9uOjAuMnN9LnNlbGYgLmlucHV0OmZvY3VzIH4gLnBsYWNlaG9sZGVyLC5zZWxmIC5pbnB1dDp2YWxpZCB+IC5wbGFjZWhvbGRlciwuc2VsZiAuaW5wdXQ6ZGlzYWJsZWQgfiAucGxhY2Vob2xkZXJ7Y29sb3I6IzFiMjQzNztmb250LXNpemU6MTFweDt0b3A6LTE2cHg7bGVmdDowcHh9LnNlbGYgLmVycm9ye2NvbG9yOnJlZDtoZWlnaHQ6MWVtO2ZvbnQtc2l6ZTowLjhlbTtmb250LXdlaWdodDo2MDB9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJpbnB1dF9fc2VsZi0tU3RhNlVcIixcblx0XCJpbnB1dFwiOiBcImlucHV0X19pbnB1dC0tMWg2S01cIixcblx0XCJpbnZhbGlkXCI6IFwiaW5wdXRfX2ludmFsaWQtLTNWbWhvXCIsXG5cdFwicGxhY2Vob2xkZXJcIjogXCJpbnB1dF9fcGxhY2Vob2xkZXItLTI2Szh5XCIsXG5cdFwiZXJyb3JcIjogXCJpbnB1dF9fZXJyb3ItLTNtVW84XCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pbnB1dC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubGFiZWxfX3NlbGYtLTMzcEJ1e2ZvbnQtc2l6ZToxNXB4O3RleHQtYWxpZ246bGVmdDtmb250LWZhbWlseTpQVCBTYW5zOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2NvbG9yOiM4OTkzOWZ9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsb0JBQU0sZUFBZSxnQkFBZ0Isb0JBQXNCLG1DQUFtQyxrQ0FBa0MsYUFBYSxDQUFDXCIsXCJmaWxlXCI6XCJsYWJlbC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme2ZvbnQtc2l6ZToxNXB4O3RleHQtYWxpZ246bGVmdDtmb250LWZhbWlseTonUFQgU2Fucyc7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7Y29sb3I6Izg5OTM5Zn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImxhYmVsX19zZWxmLS0zM3BCdVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEvYXBwcy9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sYWJlbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGFiZWwuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmxpbmtfX3NlbGYtLTJsTGFMe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47bWluLXdpZHRoOjc1JTtmb250LXdlaWdodDozMDB9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX190aXRsZS0tM1docXV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMyNjNmZmY7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc2l6ZToxLjJlbTstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19oZWFkZXItLURiVVFQey13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19zdW1tYXJ5LS0zLVYyQ3tjb2xvcjojNTQ1NDU0fS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXMyLS1JWDJTSntvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7bGluZS1oZWlnaHQ6MS4yZW07bWF4LWhlaWdodDoyLjRlbTt0ZXh0LWFsaWduOmp1c3RpZnl9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19zdW1tYXJ5LS0zLVYyQy5saW5rX19saW5lczItLUlYMlNKOmJlZm9yZXtjb250ZW50OlxcXCIuLi5cXFwiO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7Ym90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXMyLS1JWDJTSjphZnRlcntjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7d2lkdGg6MWVtO2hlaWdodDoxZW07bWFyZ2luLXRvcDouMmVtO2JhY2tncm91bmQtY29sb3I6I2ZmZn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX3N1bW1hcnktLTMtVjJDLmxpbmtfX2xpbmVzOC0tM0JYajh7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2xpbmUtaGVpZ2h0OjEuMmVtO21heC1oZWlnaHQ6OS42ZW07dGV4dC1hbGlnbjpqdXN0aWZ5fS5saW5rX19zZWxmLS0ybExhTCAubGlua19fc3VtbWFyeS0tMy1WMkMubGlua19fbGluZXM4LS0zQlhqODpiZWZvcmV7Y29udGVudDpcXFwiLi4uXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2JhY2tncm91bmQtY29sb3I6I2ZmZn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX3N1bW1hcnktLTMtVjJDLmxpbmtfX2xpbmVzOC0tM0JYajg6YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3dpZHRoOjFlbTtoZWlnaHQ6MWVtO21hcmdpbi10b3A6LjJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19mb290ZXItLTNsSTkwey13ZWJraXQtYm94LWFsaWduOmVuZDstbXMtZmxleC1hbGlnbjplbmQ7YWxpZ24taXRlbXM6ZmxleC1lbmQ7LXdlYmtpdC1ib3gtcGFjazpqdXN0aWZ5Oy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX2xpbmstLTItQVoxe2Rpc3BsYXk6YmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMwMDY2MjE7Zm9udC1zaXplOi44ZW07LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowO291dGxpbmU6bm9uZX0ubGlua19fc2VsZi0tMmxMYUwgLmxpbmtfX2xpbmstLTItQVoxOmxpbmssLmxpbmtfX3NlbGYtLTJsTGFMIC5saW5rX19saW5rLS0yLUFaMTp2aXNpdGVke3RleHQtZGVjb3JhdGlvbjpub25lfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsbUJBQU0sb0JBQW9CLG9CQUFvQixhQUFhLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLHNCQUFzQixjQUFjLGVBQWUsQ0FBQyx1Q0FBYSxtQkFBbUIsZ0JBQWdCLHVCQUF1QixjQUFjLGdCQUFnQixnQkFBZ0Isb0JBQW9CLGFBQWEsQ0FBQyx3Q0FBYyx5QkFBeUIsc0JBQXNCLDZCQUE2QixDQUFDLHlDQUFlLGFBQWEsQ0FBQyw2REFBc0IsZ0JBQWdCLGtCQUFrQixrQkFBa0IsaUJBQWlCLGtCQUFrQixDQUFDLG9FQUE2QixjQUFjLGtCQUFrQixRQUFRLFNBQVMscUJBQXFCLENBQUMsbUVBQTRCLFdBQVcsa0JBQWtCLFFBQVEsVUFBVSxXQUFXLGdCQUFpQixxQkFBcUIsQ0FBQyw2REFBc0IsZ0JBQWdCLGtCQUFrQixrQkFBa0IsaUJBQWlCLGtCQUFrQixDQUFDLG9FQUE2QixjQUFjLGtCQUFrQixRQUFRLFNBQVMscUJBQXFCLENBQUMsbUVBQTRCLFdBQVcsa0JBQWtCLFFBQVEsVUFBVSxXQUFXLGdCQUFpQixxQkFBcUIsQ0FBQyx3Q0FBYyxzQkFBc0IsbUJBQW1CLHFCQUFxQix5QkFBeUIsc0JBQXNCLDZCQUE2QixDQUFDLHNDQUFZLGNBQWMsbUJBQW1CLGdCQUFnQix1QkFBdUIsY0FBYyxlQUFnQixvQkFBb0IsY0FBYyxZQUFZLENBQUMsQUFBc0MseUZBQW9CLG9CQUFvQixDQUFDXCIsXCJmaWxlXCI6XCJsaW5rLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttaW4td2lkdGg6NzUlO2ZvbnQtd2VpZ2h0OjMwMH0uc2VsZiAudGl0bGV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMyNjNmZmY7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc2l6ZToxLjJlbTstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9LnNlbGYgLmhlYWRlcnstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5zZWxmIC5zdW1tYXJ5e2NvbG9yOiM1NDU0NTR9LnNlbGYgLnN1bW1hcnkubGluZXMye292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTtsaW5lLWhlaWdodDoxLjJlbTttYXgtaGVpZ2h0OjIuNGVtO3RleHQtYWxpZ246anVzdGlmeX0uc2VsZiAuc3VtbWFyeS5saW5lczI6YmVmb3Jle2NvbnRlbnQ6Jy4uLic7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnNlbGYgLnN1bW1hcnkubGluZXMyOmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt3aWR0aDoxZW07aGVpZ2h0OjFlbTttYXJnaW4tdG9wOjAuMmVtO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uc2VsZiAuc3VtbWFyeS5saW5lczh7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2xpbmUtaGVpZ2h0OjEuMmVtO21heC1oZWlnaHQ6OS42ZW07dGV4dC1hbGlnbjpqdXN0aWZ5fS5zZWxmIC5zdW1tYXJ5LmxpbmVzODpiZWZvcmV7Y29udGVudDonLi4uJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uc2VsZiAuc3VtbWFyeS5saW5lczg6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3dpZHRoOjFlbTtoZWlnaHQ6MWVtO21hcmdpbi10b3A6MC4yZW07YmFja2dyb3VuZC1jb2xvcjojZmZmfS5zZWxmIC5mb290ZXJ7LXdlYmtpdC1ib3gtYWxpZ246ZW5kOy1tcy1mbGV4LWFsaWduOmVuZDthbGlnbi1pdGVtczpmbGV4LWVuZDstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5zZWxmIC5saW5re2Rpc3BsYXk6YmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2NvbG9yOiMwMDY2MjE7Zm9udC1zaXplOjAuOGVtOy1tcy1mbGV4LW5lZ2F0aXZlOjA7ZmxleC1zaHJpbms6MDtvdXRsaW5lOm5vbmV9LnNlbGYgLmxpbms6bGlua3t0ZXh0LWRlY29yYXRpb246bm9uZX0uc2VsZiAubGluazp2aXNpdGVke3RleHQtZGVjb3JhdGlvbjpub25lfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwibGlua19fc2VsZi0tMmxMYUxcIixcblx0XCJ0aXRsZVwiOiBcImxpbmtfX3RpdGxlLS0zV2hxdVwiLFxuXHRcImhlYWRlclwiOiBcImxpbmtfX2hlYWRlci0tRGJVUVBcIixcblx0XCJzdW1tYXJ5XCI6IFwibGlua19fc3VtbWFyeS0tMy1WMkNcIixcblx0XCJsaW5lczJcIjogXCJsaW5rX19saW5lczItLUlYMlNKXCIsXG5cdFwibGluZXM4XCI6IFwibGlua19fbGluZXM4LS0zQlhqOFwiLFxuXHRcImZvb3RlclwiOiBcImxpbmtfX2Zvb3Rlci0tM2xJOTBcIixcblx0XCJsaW5rXCI6IFwibGlua19fbGluay0tMi1BWjFcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubGlua0xpc3RfX3NlbGYtLVk4UU9xIC5saW5rTGlzdF9fcm93LS1MeHByWHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzoxMHB4fS5saW5rTGlzdF9fc2VsZi0tWThRT3EgLmxpbmtMaXN0X19idXR0b24tLWVsejFYe21hcmdpbi1sZWZ0OmF1dG99XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsNkNBQVcsb0JBQW9CLG9CQUFvQixhQUFhLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQixZQUFZLENBQUMsZ0RBQWMsZ0JBQWdCLENBQUNcIixcImZpbGVcIjpcImxpbmtMaXN0LnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGYgLnJvd3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzoxMHB4fS5zZWxmIC5idXR0b257bWFyZ2luLWxlZnQ6YXV0b31cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcImxpbmtMaXN0X19zZWxmLS1ZOFFPcVwiLFxuXHRcInJvd1wiOiBcImxpbmtMaXN0X19yb3ctLUx4cHJYXCIsXG5cdFwiYnV0dG9uXCI6IFwibGlua0xpc3RfX2J1dHRvbi0tZWx6MVhcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGlua0xpc3Quc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmtMaXN0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5sb2FkZXJfX3NlbGYtLTJVOWFze2JvcmRlcjoxcHggc29saWQgI2VlZjFmMjtib3JkZXItdG9wOjFweCBzb2xpZCAjMjYzZmZmO2JvcmRlci1yYWRpdXM6NTAlO3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7LXdlYmtpdC1hbmltYXRpb246bG9hZGVyX19zcGluLS0xV3NtMiAycyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOmxvYWRlcl9fc3Bpbi0tMVdzbTIgMnMgbGluZWFyIGluZmluaXRlfUAtd2Via2l0LWtleWZyYW1lcyBsb2FkZXJfX3NwaW4tLTFXc20yezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxdHVybik7dHJhbnNmb3JtOnJvdGF0ZSgxdHVybil9fUBrZXlmcmFtZXMgbG9hZGVyX19zcGluLS0xV3NtMnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMXR1cm4pO3RyYW5zZm9ybTpyb3RhdGUoMXR1cm4pfX1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEscUJBQU0seUJBQXlCLDZCQUE2QixrQkFBa0IsV0FBVyxZQUFZLHlEQUEwQyxnREFBaUMsQ0FBQyx1Q0FBd0IsR0FBRywrQkFBK0Isc0JBQXNCLENBQUMsR0FBSyxnQ0FBaUMsdUJBQXdCLENBQUMsQ0FBQywrQkFBZ0IsR0FBRywrQkFBK0Isc0JBQXNCLENBQUMsR0FBSyxnQ0FBaUMsdUJBQXdCLENBQUMsQ0FBQ1wiLFwiZmlsZVwiOlwibG9hZGVyLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlbGZ7Ym9yZGVyOjFweCBzb2xpZCAjZWVmMWYyO2JvcmRlci10b3A6MXB4IHNvbGlkICMyNjNmZmY7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDstd2Via2l0LWFuaW1hdGlvbjpzcGluIDJzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246c3BpbiAycyBsaW5lYXIgaW5maW5pdGV9QC13ZWJraXQta2V5ZnJhbWVzIHNwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9MTAwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgc3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJsb2FkZXJfX3NlbGYtLTJVOWFzXCIsXG5cdFwic3BpblwiOiBcImxvYWRlcl9fc3Bpbi0tMVdzbTJcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sb2FkZXIuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnBhcGVyX19zZWxmLS0xcXROaXstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6MTtmbGV4OjE7YmFja2dyb3VuZC1jb2xvcjojZmZmOy13ZWJraXQtYm94LXNoYWRvdzowIDVweCAyMHB4IDAgcmdiYSgxOSwzOCwxMTAsLjA4KTtib3gtc2hhZG93OjAgNXB4IDIwcHggMCByZ2JhKDE5LDM4LDExMCwuMDgpO21hcmdpbi10b3A6MjBweDtib3JkZXItcmFkaXVzOjNweH1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxvQkFBTSxtQkFBbUIsV0FBVyxPQUFPLHNCQUFzQixvREFBeUQsNENBQWlELGdCQUFnQixpQkFBaUIsQ0FBQ1wiLFwiZmlsZVwiOlwicGFwZXIuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZnstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6MTtmbGV4OjE7YmFja2dyb3VuZC1jb2xvcjojZmZmOy13ZWJraXQtYm94LXNoYWRvdzowcHggNXB4IDIwcHggMHB4IHJnYmEoMTksMzgsMTEwLDAuMDgpO2JveC1zaGFkb3c6MHB4IDVweCAyMHB4IDBweCByZ2JhKDE5LDM4LDExMCwwLjA4KTttYXJnaW4tdG9wOjIwcHg7Ym9yZGVyLXJhZGl1czozcHh9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJwYXBlcl9fc2VsZi0tMXF0TmlcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvcGFwZXIuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3BhcGVyLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50ZXh0V2l0aExhYmVsX19zZWxmLS0zU2VCS3twYWRkaW5nOjFlbX0udGV4dFdpdGhMYWJlbF9fc2VsZi0tM1NlQksgLnRleHRXaXRoTGFiZWxfX3RleHQtLTJsTUZ6e21hcmdpbi10b3A6NXB4O2ZvbnQtc2l6ZToxNXB4O2NvbG9yOiMxYjI0Mzc7dGV4dC1hbGlnbjpsZWZ0O292ZXJmbG93OmhpZGRlbjt3b3JkLXdyYXA6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3RleHRXaXRoTGFiZWwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSw0QkFBTSxXQUFXLENBQUMsd0RBQVksZUFBZSxlQUFlLGNBQWMsZ0JBQWdCLGdCQUFnQixpQkFBaUIsc0JBQXNCLENBQUNcIixcImZpbGVcIjpcInRleHRXaXRoTGFiZWwuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZntwYWRkaW5nOjFlbX0uc2VsZiAudGV4dHttYXJnaW4tdG9wOjVweDtmb250LXNpemU6MTVweDtjb2xvcjojMWIyNDM3O3RleHQtYWxpZ246bGVmdDtvdmVyZmxvdzpoaWRkZW47d29yZC13cmFwOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJzZWxmXCI6IFwidGV4dFdpdGhMYWJlbF9fc2VsZi0tM1NlQktcIixcblx0XCJ0ZXh0XCI6IFwidGV4dFdpdGhMYWJlbF9fdGV4dC0tMmxNRnpcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYj97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hL2FwcHMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYj97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hL2FwcHMvbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlLFwicGx1Z2luc1wiOltudWxsXX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/e1wic291cmNlTWFwXCI6dHJ1ZX0hLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudG9vbHRpcF9fc2VsZi0tMmg4cDN7cG9zaXRpb246cmVsYXRpdmV9LnRvb2x0aXBfX3NlbGYtLTJoOHAzIC50b29sdGlwX190ZXh0LS0xY3o0ZXt2aXNpYmlsaXR5OmhpZGRlbjt3aWR0aDoxMjBweDtiYWNrZ3JvdW5kLWNvbG9yOiMxYjI0Mzc7Y29sb3I6I2ZmZjt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjVweCAwO2JvcmRlci1yYWRpdXM6NnB4O3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtdHJhbnNpdGlvbi1kZWxheTowczt0cmFuc2l0aW9uLWRlbGF5OjBzfS50b29sdGlwX19zZWxmLS0yaDhwMzpob3ZlciAudG9vbHRpcF9fdGV4dC0tMWN6NGV7dmlzaWJpbGl0eTp2aXNpYmxlOy13ZWJraXQtdHJhbnNpdGlvbi1kZWxheTouNXM7dHJhbnNpdGlvbi1kZWxheTouNXN9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxzQkFBTSxpQkFBaUIsQ0FBQyw0Q0FBWSxrQkFBa0IsWUFBWSx5QkFBeUIsV0FBVyxrQkFBa0IsY0FBYyxrQkFBa0Isa0JBQWtCLDRCQUE0QixtQkFBbUIsQ0FBQyxrREFBa0IsbUJBQW1CLDZCQUE4QixvQkFBcUIsQ0FBQ1wiLFwiZmlsZVwiOlwidG9vbHRpcC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme3Bvc2l0aW9uOnJlbGF0aXZlfS5zZWxmIC50ZXh0e3Zpc2liaWxpdHk6aGlkZGVuO3dpZHRoOjEyMHB4O2JhY2tncm91bmQtY29sb3I6IzFiMjQzNztjb2xvcjojZmZmO3RleHQtYWxpZ246Y2VudGVyO3BhZGRpbmc6NXB4IDA7Ym9yZGVyLXJhZGl1czo2cHg7cG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5OjBzO3RyYW5zaXRpb24tZGVsYXk6MHN9LnNlbGY6aG92ZXIgLnRleHR7dmlzaWJpbGl0eTp2aXNpYmxlOy13ZWJraXQtdHJhbnNpdGlvbi1kZWxheTowLjVzO3RyYW5zaXRpb24tZGVsYXk6MC41c31cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwic2VsZlwiOiBcInRvb2x0aXBfX3NlbGYtLTJoOHAzXCIsXG5cdFwidGV4dFwiOiBcInRvb2x0aXBfX3RleHQtLTFjejRlXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLlN0YXR1c19fc2VsZi0tMmp0d297d2lkdGg6MTAwdnc7aGVpZ2h0OjEwMHZoO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOnN0YXJ0Oy1tcy1mbGV4LWFsaWduOnN0YXJ0O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5TdGF0dXNfX3NlbGYtLTJqdHdvey13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy13ZWJraXQtYm94LXBhY2s6c3RhcnQ7LW1zLWZsZXgtcGFjazpzdGFydDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn19LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fcHJldmlldy0tMUlVVjB7d2lkdGg6MzAwcHg7aGVpZ2h0OjI1MHB4O21hcmdpbi1yaWdodDozMHB4O3BhZGRpbmc6MTBweDstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6YXV0bztmbGV4OmF1dG87LXdlYmtpdC1ib3gtZmxleDowOy1tcy1mbGV4LXBvc2l0aXZlOjA7ZmxleC1ncm93OjA7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX3ByZXZpZXctLTFJVVYwe3dpZHRoOmNhbGMoMTAwdncgLSAyMHB4KTtoZWlnaHQ6dW5zZXQ7bWFyZ2luOjA7bWFyZ2luLWJvdHRvbToyMHB4fX0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19sb2FkZXItLTJGa3NQe3dpZHRoOjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fY29udGVudC0tMVJ1WTd7dGV4dC1hbGlnbjpjZW50ZXI7bWF4LXdpZHRoOjQwdnc7cGFkZGluZzoxMHB4fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MTIwMHB4KXsuU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19jb250ZW50LS0xUnVZN3ttYXgtd2lkdGg6Y2FsYygxMDB2dyAtIDIwcHgpO21hcmdpbjowfX0uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19sYWJlbC0tbEdRcFl7d2lkdGg6MTAwJTtwYWRkaW5nOjA7bWFyZ2luLXRvcDotMWVtfS5TdGF0dXNfX3NlbGYtLTJqdHdvIC5TdGF0dXNfX2xpbmstbGFiZWwtLTJjYzVke2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd30uU3RhdHVzX19zZWxmLS0yanR3byAuU3RhdHVzX19saW5rLS0yV2F1VXtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXB9LlN0YXR1c19fc2VsZi0tMmp0d28gLlN0YXR1c19fYWRkLWJvb2ttYXJrLS1INl9KS3std2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6YXV0bztmbGV4OmF1dG87LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9hcHBzL2xpbmtzL3NyYy9wYWdlcy9TdGF0dXMvU3RhdHVzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEscUJBQU0sWUFBWSxhQUFhLG9CQUFvQixvQkFBb0IsYUFBYSw4QkFBOEIsNkJBQTZCLHVCQUF1QixtQkFBbUIsd0JBQXdCLHFCQUFxQix1QkFBdUIsd0JBQXdCLHFCQUFxQixzQkFBc0IsQ0FBQyxxQ0FBc0MscUJBQU0sNEJBQTRCLDZCQUE2QiwwQkFBMEIsc0JBQXNCLHVCQUF1QixvQkFBb0IsMkJBQTJCLHlCQUF5QixzQkFBc0Isa0JBQWtCLENBQUMsQ0FBQyw2Q0FBZSxZQUFZLGFBQWEsa0JBQWtCLGFBQWEsbUJBQW1CLGNBQWMsVUFBVSxtQkFBbUIsb0JBQW9CLFlBQVksb0JBQW9CLGNBQWMsb0JBQW9CLG9CQUFvQixhQUFhLHlCQUF5QixzQkFBc0Isa0JBQWtCLENBQUMscUNBQXNDLDZDQUFlLHlCQUF5QixhQUFhLFNBQVMsa0JBQWtCLENBQUMsQ0FBQyw0Q0FBYyxXQUFXLG9CQUFvQixvQkFBb0IsYUFBYSw4QkFBOEIsNkJBQTZCLHVCQUF1QixtQkFBbUIsd0JBQXdCLHFCQUFxQix1QkFBdUIseUJBQXlCLHNCQUFzQixrQkFBa0IsQ0FBQyw2Q0FBZSxrQkFBa0IsZUFBZSxZQUFZLENBQUMscUNBQXNDLDZDQUFlLDZCQUE2QixRQUFRLENBQUMsQ0FBQywyQ0FBYSxXQUFXLFVBQVUsZUFBZSxDQUFDLGdEQUFrQixvQkFBb0Isb0JBQW9CLGFBQWEsOEJBQThCLDZCQUE2Qix1QkFBdUIsa0JBQWtCLENBQUMsMENBQVksZ0JBQWdCLHVCQUF1QixrQkFBa0IsQ0FBQyxrREFBb0IsbUJBQW1CLGNBQWMsVUFBVSxvQkFBb0IsYUFBYSxDQUFDXCIsXCJmaWxlXCI6XCJTdGF0dXMuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZnt3aWR0aDoxMDB2dztoZWlnaHQ6MTAwdmg7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246c3RhcnQ7LW1zLWZsZXgtYWxpZ246c3RhcnQ7YWxpZ24taXRlbXM6ZmxleC1zdGFydH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmey13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy13ZWJraXQtYm94LXBhY2s6c3RhcnQ7LW1zLWZsZXgtcGFjazpzdGFydDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn19LnNlbGYgLnByZXZpZXd7d2lkdGg6MzAwcHg7aGVpZ2h0OjI1MHB4O21hcmdpbi1yaWdodDozMHB4O3BhZGRpbmc6MTBweDstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6YXV0bztmbGV4OmF1dG87LXdlYmtpdC1ib3gtZmxleDowOy1tcy1mbGV4LXBvc2l0aXZlOjA7ZmxleC1ncm93OjA7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZiAucHJldmlld3t3aWR0aDpjYWxjKDEwMHZ3IC0gMjBweCk7aGVpZ2h0OnVuc2V0O21hcmdpbjowO21hcmdpbi1ib3R0b206MjBweH19LnNlbGYgLmxvYWRlcnt3aWR0aDoxMDAlO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5zZWxmIC5jb250ZW50e3RleHQtYWxpZ246Y2VudGVyO21heC13aWR0aDo0MHZ3O3BhZGRpbmc6MTBweH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmIC5jb250ZW50e21heC13aWR0aDpjYWxjKDEwMHZ3IC0gMjBweCk7bWFyZ2luOjB9fS5zZWxmIC5sYWJlbHt3aWR0aDoxMDAlO3BhZGRpbmc6MDttYXJnaW4tdG9wOi0xZW19LnNlbGYgLmxpbmstbGFiZWx7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93fS5zZWxmIC5saW5re292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcH0uc2VsZiAuYWRkLWJvb2ttYXJrey13ZWJraXQtYm94LWZsZXg6MTstbXMtZmxleDphdXRvO2ZsZXg6YXV0bzstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJTdGF0dXNfX3NlbGYtLTJqdHdvXCIsXG5cdFwicHJldmlld1wiOiBcIlN0YXR1c19fcHJldmlldy0tMUlVVjBcIixcblx0XCJsb2FkZXJcIjogXCJTdGF0dXNfX2xvYWRlci0tMkZrc1BcIixcblx0XCJjb250ZW50XCI6IFwiU3RhdHVzX19jb250ZW50LS0xUnVZN1wiLFxuXHRcImxhYmVsXCI6IFwiU3RhdHVzX19sYWJlbC0tbEdRcFlcIixcblx0XCJsaW5rLWxhYmVsXCI6IFwiU3RhdHVzX19saW5rLWxhYmVsLS0yY2M1ZFwiLFxuXHRcImxpbmtMYWJlbFwiOiBcIlN0YXR1c19fbGluay1sYWJlbC0tMmNjNWRcIixcblx0XCJsaW5rXCI6IFwiU3RhdHVzX19saW5rLS0yV2F1VVwiLFxuXHRcImFkZC1ib29rbWFya1wiOiBcIlN0YXR1c19fYWRkLWJvb2ttYXJrLS1INl9KS1wiLFxuXHRcImFkZEJvb2ttYXJrXCI6IFwiU3RhdHVzX19hZGQtYm9va21hcmstLUg2X0pLXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnN0ZXBzX19zZWxmLS0zS3lIbXt3aWR0aDoxMDAlO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5zdGVwc19fc2VsZi0tM0t5SG17LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd319LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3Byb2dyZXNzLWNvdGFpbmVyLS0xbTJsUHtwb3NpdGlvbjpyZWxhdGl2ZX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fcHJvZ3Jlc3MtLTMyZmFCe3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MjBweDt6LWluZGV4OjE7d2lkdGg6MTAwJTtoZWlnaHQ6MWVtO2JvcmRlci1yYWRpdXM6MWVtO2JhY2tncm91bmQtY29sb3I6I2VlZjFmMn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3Byb2dyZXNzLS0zMmZhQnt3aWR0aDoxZW07aGVpZ2h0OjEwMCU7dG9wOjA7bGVmdDoyMHB4fX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcHMtY29udGFpbmVyLS0xRnhOV3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7LXdlYmtpdC1ib3gtcGFjazpqdXN0aWZ5Oy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjEyMDBweCl7LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXBzLWNvbnRhaW5lci0tMUZ4Tld7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59fS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uO3otaW5kZXg6MjttYXJnaW4tdG9wOmNhbGMoMjBweCArIC41ZW0gLSAxLjVlbSl9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUnstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93O21hcmdpbi10b3A6MDttYXJnaW4tbGVmdDpjYWxjKDIwcHggKyAuNWVtIC0gMS41ZW0pfX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlIuc3RlcHNfX2Rpc2FibGVkLS1nVlJJcXtvcGFjaXR5Oi41O2N1cnNvcjpub3QtYWxsb3dlZH0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlIuc3RlcHNfX3dhaXRpbmctLVpINDZte29wYWNpdHk6LjV9LnN0ZXBzX19zZWxmLS0zS3lIbSAuc3RlcHNfX3N0ZXAtLTNCRWZSLnN0ZXBzX19kb25lLS0yQ3ZNRCAuc3RlcHNfX2ljb24tLTJibzVzLC5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUi5zdGVwc19fZG9uZS0tMkN2TUQgcGF0aHtjb2xvcjpsaW1lO2ZpbGw6bGltZX0uc3RlcHNfX3NlbGYtLTNLeUhtIC5zdGVwc19fc3RlcC0tM0JFZlIgLnN0ZXBzX19pY29uLS0yYm81c3stbXMtZmxleC1pdGVtLWFsaWduOmNlbnRlcjthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDozZW07aGVpZ2h0OjNlbTtiYWNrZ3JvdW5kLWNvbG9yOiNlZWYxZjI7Ym9yZGVyLXJhZGl1czozZW07ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUiAuc3RlcHNfX2NvbnRlbnQtLTFhS2x6e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDoxMjAwcHgpey5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19zdGVwLS0zQkVmUiAuc3RlcHNfX2NvbnRlbnQtLTFhS2x6ey13ZWJraXQtYm94LWFsaWduOnN0YXJ0Oy1tcy1mbGV4LWFsaWduOnN0YXJ0O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7cGFkZGluZy1sZWZ0OjIwcHh9fS5zdGVwc19fc2VsZi0tM0t5SG0gLnN0ZXBzX19pY29uLS0yYm81c3tmb250LXNpemU6MWVtfVwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvYXBwcy9hcHBzL2xpbmtzL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9zdGVwcy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG9CQUFNLFdBQVcsb0JBQW9CLG9CQUFvQixhQUFhLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLHFCQUFxQixDQUFDLHFDQUFzQyxvQkFBTSw4QkFBOEIsNkJBQTZCLHVCQUF1QixrQkFBa0IsQ0FBQyxDQUFDLHFEQUF5QixpQkFBaUIsQ0FBQyw0Q0FBZ0Isa0JBQWtCLE9BQU8sU0FBUyxVQUFVLFdBQVcsV0FBVyxrQkFBa0Isd0JBQXdCLENBQUMscUNBQXNDLDRDQUFnQixVQUFVLFlBQVksTUFBTSxTQUFTLENBQUMsQ0FBQyxtREFBdUIsb0JBQW9CLG9CQUFvQixhQUFhLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQix5QkFBeUIsc0JBQXNCLDZCQUE2QixDQUFDLHFDQUFzQyxtREFBdUIsNEJBQTRCLDZCQUE2QiwwQkFBMEIscUJBQXFCLENBQUMsQ0FBQyx3Q0FBWSxvQkFBb0Isb0JBQW9CLGFBQWEsNEJBQTRCLDZCQUE2QiwwQkFBMEIsc0JBQXNCLFVBQVUsb0NBQXFDLENBQUMscUNBQXNDLHdDQUFZLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1CQUFtQixhQUFhLHFDQUFzQyxDQUFDLENBQUMsK0RBQXFCLFdBQVksa0JBQWtCLENBQUMsOERBQW9CLFVBQVcsQ0FBQywrSUFBNkMsV0FBVyxTQUFTLENBQUMsNERBQWtCLDJCQUEyQixrQkFBa0IsVUFBVSxXQUFXLHlCQUF5QixrQkFBa0Isb0JBQW9CLG9CQUFvQixhQUFhLHdCQUF3QixxQkFBcUIsdUJBQXVCLHlCQUF5QixzQkFBc0Isa0JBQWtCLENBQUMsK0RBQXFCLG9CQUFvQixvQkFBb0IsYUFBYSw0QkFBNEIsNkJBQTZCLDBCQUEwQixzQkFBc0IseUJBQXlCLHNCQUFzQixrQkFBa0IsQ0FBQyxxQ0FBc0MsK0RBQXFCLHdCQUF3QixxQkFBcUIsdUJBQXVCLGlCQUFpQixDQUFDLENBQUMsd0NBQVksYUFBYSxDQUFDXCIsXCJmaWxlXCI6XCJzdGVwcy5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zZWxme3dpZHRoOjEwMCU7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmey13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3d9fS5zZWxmIC5wcm9ncmVzcy1jb3RhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX0uc2VsZiAucHJvZ3Jlc3N7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDoyMHB4O3otaW5kZXg6MTt3aWR0aDoxMDAlO2hlaWdodDoxZW07Ym9yZGVyLXJhZGl1czoxZW07YmFja2dyb3VuZC1jb2xvcjojZWVmMWYyfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLnByb2dyZXNze3dpZHRoOjFlbTtoZWlnaHQ6MTAwJTt0b3A6MDtsZWZ0OjIwcHh9fS5zZWxmIC5zdGVwcy1jb250YWluZXJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTIwMHB4KXsuc2VsZiAuc3RlcHMtY29udGFpbmVyey13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1ufX0uc2VsZiAuc3RlcHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uO3otaW5kZXg6MjttYXJnaW4tdG9wOmNhbGMoMjBweCArIDAuNWVtIC0gMS41ZW0pfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEyMDBweCl7LnNlbGYgLnN0ZXB7LXdlYmtpdC1ib3gtb3JpZW50Omhvcml6b250YWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzttYXJnaW4tdG9wOjA7bWFyZ2luLWxlZnQ6Y2FsYygyMHB4ICsgMC41ZW0gLSAxLjVlbSl9fS5zZWxmIC5zdGVwLmRpc2FibGVke29wYWNpdHk6MC41O2N1cnNvcjpub3QtYWxsb3dlZH0uc2VsZiAuc3RlcC53YWl0aW5ne29wYWNpdHk6MC41fS5zZWxmIC5zdGVwLmRvbmUgLmljb24sLnNlbGYgLnN0ZXAuZG9uZSBwYXRoe2NvbG9yOmxpbWU7ZmlsbDpsaW1lfS5zZWxmIC5zdGVwIC5pY29uey1tcy1mbGV4LWl0ZW0tYWxpZ246Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyO3dpZHRoOjNlbTtoZWlnaHQ6M2VtO2JhY2tncm91bmQtY29sb3I6I2VlZjFmMjtib3JkZXItcmFkaXVzOjNlbTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LnNlbGYgLnN0ZXAgLmNvbnRlbnR7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpey5zZWxmIC5zdGVwIC5jb250ZW50ey13ZWJraXQtYm94LWFsaWduOnN0YXJ0Oy1tcy1mbGV4LWFsaWduOnN0YXJ0O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7cGFkZGluZy1sZWZ0OjIwcHh9fS5zZWxmIC5pY29ue2ZvbnQtc2l6ZToxZW19XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJzdGVwc19fc2VsZi0tM0t5SG1cIixcblx0XCJwcm9ncmVzcy1jb3RhaW5lclwiOiBcInN0ZXBzX19wcm9ncmVzcy1jb3RhaW5lci0tMW0ybFBcIixcblx0XCJwcm9ncmVzc0NvdGFpbmVyXCI6IFwic3RlcHNfX3Byb2dyZXNzLWNvdGFpbmVyLS0xbTJsUFwiLFxuXHRcInByb2dyZXNzXCI6IFwic3RlcHNfX3Byb2dyZXNzLS0zMmZhQlwiLFxuXHRcInN0ZXBzLWNvbnRhaW5lclwiOiBcInN0ZXBzX19zdGVwcy1jb250YWluZXItLTFGeE5XXCIsXG5cdFwic3RlcHNDb250YWluZXJcIjogXCJzdGVwc19fc3RlcHMtY29udGFpbmVyLS0xRnhOV1wiLFxuXHRcInN0ZXBcIjogXCJzdGVwc19fc3RlcC0tM0JFZlJcIixcblx0XCJkaXNhYmxlZFwiOiBcInN0ZXBzX19kaXNhYmxlZC0tZ1ZSSXFcIixcblx0XCJ3YWl0aW5nXCI6IFwic3RlcHNfX3dhaXRpbmctLVpINDZtXCIsXG5cdFwiZG9uZVwiOiBcInN0ZXBzX19kb25lLS0yQ3ZNRFwiLFxuXHRcImljb25cIjogXCJzdGVwc19faWNvbi0tMmJvNXNcIixcblx0XCJjb250ZW50XCI6IFwic3RlcHNfX2NvbnRlbnQtLTFhS2x6XCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWI/e1wibmFtZWRFeHBvcnRcIjp0cnVlLFwibW9kdWxlc1wiOnRydWUsXCJpbXBvcnRMb2FkZXJzXCI6MSxcInNvdXJjZU1hcFwiOnRydWUsXCJjYW1lbENhc2VcIjp0cnVlLFwibG9jYWxJZGVudE5hbWVcIjpcIltuYW1lXV9fW2xvY2FsXS0tW2hhc2g6YmFzZTY0OjVdXCJ9IS9hcHBzL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWI/e1wic291cmNlTWFwXCI6dHJ1ZSxcInBsdWdpbnNcIjpbbnVsbF19IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL3N0ZXBzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOnRydWUsXCJwbHVnaW5zXCI6W251bGxdfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuL3NyYy9wYWdlcy9TdGF0dXMvY29tcG9uZW50cy9zdGVwcy5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuV2hpdGVsaXN0X19zZWxmLS0xQmtNent3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7bWFyZ2luLXRvcDoxMHB4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LldoaXRlbGlzdF9fc2VsZi0tMUJrTXogLldoaXRlbGlzdF9fcGFwZXItLTJaQ3N1e3dpZHRoOjcwJTtwYWRkaW5nOjEwcHh9XCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHBzL2FwcHMvbGlua3Mvc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHdCQUFNLFdBQVcsWUFBWSxvQkFBb0Isb0JBQW9CLGFBQWEsZ0JBQWdCLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLHNCQUFzQix3QkFBd0IscUJBQXFCLHVCQUF1Qix5QkFBeUIsc0JBQXNCLGtCQUFrQixDQUFDLGlEQUFhLFVBQVUsWUFBWSxDQUFDXCIsXCJmaWxlXCI6XCJXaGl0ZWxpc3Quc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc2VsZnt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7bWFyZ2luLXRvcDoxMHB4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LnNlbGYgLnBhcGVye3dpZHRoOjcwJTtwYWRkaW5nOjEwcHh9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlbGZcIjogXCJXaGl0ZWxpc3RfX3NlbGYtLTFCa016XCIsXG5cdFwicGFwZXJcIjogXCJXaGl0ZWxpc3RfX3BhcGVyLS0yWkNzdVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuL3NyYy9wYWdlcy9XaGl0ZWxpc3Quc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVBUK1NhbnM6NDAwLDcwMCk7XCIsIFwiXCJdKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5e2ZvbnQtZmFtaWx5OlBUIFNhbnMsc2Fucy1zZXJpZn1cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcHMvYXBwcy9saW5rcy9zdHlsZXMvYWxsLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQXVFLEtBQUssOEJBQWlDLENBQUNcIixcImZpbGVcIjpcImFsbC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBpbXBvcnQgdXJsKFxcXCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9UFQrU2Fuczo0MDAsNzAwXFxcIik7Ym9keXtmb250LWZhbWlseTonUFQgU2FucycsIHNhbnMtc2VyaWZ9XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliP3tcIm5hbWVkRXhwb3J0XCI6dHJ1ZSxcIm1vZHVsZXNcIjp0cnVlLFwiaW1wb3J0TG9hZGVyc1wiOjEsXCJzb3VyY2VNYXBcIjp0cnVlLFwiY2FtZWxDYXNlXCI6dHJ1ZSxcImxvY2FsSWRlbnROYW1lXCI6XCJbbmFtZV1fX1tsb2NhbF0tLVtoYXNoOmJhc2U2NDo1XVwifSEvYXBwcy9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliP3tcInNvdXJjZU1hcFwiOnRydWV9IS9hcHBzL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3tcInNvdXJjZU1hcFwiOnRydWV9IS4vc3R5bGVzL2FsbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJuYW1lZEV4cG9ydFwiOnRydWUsXCJtb2R1bGVzXCI6dHJ1ZSxcImltcG9ydExvYWRlcnNcIjoxLFwic291cmNlTWFwXCI6dHJ1ZSxcImNhbWVsQ2FzZVwiOnRydWUsXCJsb2NhbElkZW50TmFtZVwiOlwiW25hbWVdX19bbG9jYWxdLS1baGFzaDpiYXNlNjQ6NV1cIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJzb3VyY2VNYXBcIjp0cnVlfSEuL3N0eWxlcy9hbGwuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4xLjInLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy91dGY4L3V0ZjguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy91dGY4L3V0ZjguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiB2YWx1ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhVHlwZSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKTtcbiAgdmFyIGJUeXBlID0gdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpO1xuXG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHJldHVybiBmYWxzZTtcblxuICBpZiAoYVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFWYWx1ZSA9IGEudmFsdWVPZigpO1xuICAgIHZhciBiVmFsdWUgPSBiLnZhbHVlT2YoKTtcblxuICAgIGlmIChhVmFsdWUgIT09IGEgfHwgYlZhbHVlICE9PSBiKSByZXR1cm4gdmFsdWVFcXVhbChhVmFsdWUsIGJWYWx1ZSk7XG5cbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGFba2V5XSwgYltrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVFcXVhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdlYjMgPSByZXF1aXJlKCcuL2xpYi93ZWIzJyk7XG5cbi8vIGRvbnQgb3ZlcnJpZGUgZ2xvYmFsIHZhcmlhYmxlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5XZWIzID09PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5XZWIzID0gV2ViMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWIzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW3tcImNvbnN0YW50XCI6dHJ1ZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfb3duZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwibmFtZVwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJvX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcIm93bmVyXCIsXCJvdXRwdXRzXCI6W3tcIm5hbWVcIjpcIlwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOnRydWUsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiY29udGVudFwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcImFkZHJcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwicmVzZXJ2ZVwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcInN1YlJlZ2lzdHJhclwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfbmV3T3duZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwidHJhbnNmZXJcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwiX3JlZ2lzdHJhclwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJuYW1lXCI6XCJzZXRTdWJSZWdpc3RyYXJcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbXSxcIm5hbWVcIjpcIlJlZ2lzdHJhclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfYVwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJuYW1lXCI6XCJfcHJpbWFyeVwiLFwidHlwZVwiOlwiYm9vbFwifV0sXCJuYW1lXCI6XCJzZXRBZGRyZXNzXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcIl9jb250ZW50XCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcInNldENvbnRlbnRcIixcIm91dHB1dHNcIjpbXSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiZGlzb3duXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcIl93aW5uZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwiQXVjdGlvbkVuZGVkXCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcIl9iaWRkZXJcIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wiaW5kZXhlZFwiOmZhbHNlLFwibmFtZVwiOlwiX3ZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIk5ld0JpZFwiLFwidHlwZVwiOlwiZXZlbnRcIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJuYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcIkNoYW5nZWRcIixcInR5cGVcIjpcImV2ZW50XCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwibmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImFkZHJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwiUHJpbWFyeUNoYW5nZWRcIixcInR5cGVcIjpcImV2ZW50XCJ9XVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb25cbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb25cbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBbe1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcIm93bmVyXCIsXCJvdXRwdXRzXCI6W3tcIm5hbWVcIjpcIlwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcIl9yZWZ1bmRcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwiZGlzb3duXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOnRydWUsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiYWRkclwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifV0sXCJuYW1lXCI6XCJyZXNlcnZlXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9uYW1lXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcIl9uZXdPd25lclwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJuYW1lXCI6XCJ0cmFuc2ZlclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJfbmFtZVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJfYVwiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJuYW1lXCI6XCJzZXRBZGRyXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIm5hbWVcIixcInR5cGVcIjpcImJ5dGVzMzJcIn1dLFwibmFtZVwiOlwiQ2hhbmdlZFwiLFwidHlwZVwiOlwiZXZlbnRcIn1dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb25cbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW3tcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOlwidWludDI1NlwifV0sXCJuYW1lXCI6XCJ0cmFuc2ZlclwiLFwib3V0cHV0c1wiOltdLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJuYW1lXCI6XCJmcm9tXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LHtcIm5hbWVcIjpcImluZGlyZWN0SWRcIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjpcInVpbnQyNTZcIn1dLFwibmFtZVwiOlwiaWNhcFRyYW5zZmVyXCIsXCJvdXRwdXRzXCI6W10sXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9XSxcIm5hbWVcIjpcImRlcG9zaXRcIixcIm91dHB1dHNcIjpbXSxcInBheWFibGVcIjp0cnVlLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiYW5vbnltb3VzXCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJmcm9tXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIkFub255bW91c0RlcG9zaXRcIixcInR5cGVcIjpcImV2ZW50XCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIkRlcG9zaXRcIixcInR5cGVcIjpcImV2ZW50XCJ9LHtcImFub255bW91c1wiOmZhbHNlLFwiaW5wdXRzXCI6W3tcImluZGV4ZWRcIjp0cnVlLFwibmFtZVwiOlwiZnJvbVwiLFwidHlwZVwiOlwiYnl0ZXMzMlwifSx7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcInRvXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIlRyYW5zZmVyXCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImZyb21cIixcInR5cGVcIjpcImJ5dGVzMzJcIn0se1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJ0b1wiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJpbmRpcmVjdElkXCIsXCJ0eXBlXCI6XCJieXRlczMyXCJ9LHtcImluZGV4ZWRcIjpmYWxzZSxcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcIm5hbWVcIjpcIkljYXBUcmFuc2ZlclwiLFwidHlwZVwiOlwiZXZlbnRcIn1dXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9jb250cmFjdHMvU21hcnRFeGNoYW5nZS5qc29uXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlQWRkcmVzcyBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyBhZGRyZXNzIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBhZGRyZXNzXG4gKiBhZGRyZXNzW11cbiAqIGFkZHJlc3NbNF1cbiAqIGFkZHJlc3NbXVtdXG4gKiBhZGRyZXNzWzNdW11cbiAqIGFkZHJlc3NbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0SW50O1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0QWRkcmVzcztcbn07XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVBZGRyZXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvYWRkcmVzcyhcXFsoWzAtOV0qKVxcXSk/Lyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYWRkcmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2FkZHJlc3MuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVCb29sIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIGJvb2wgdHlwZVxuICogSXQgbWF0Y2hlczpcbiAqIGJvb2xcbiAqIGJvb2xbXVxuICogYm9vbFs0XVxuICogYm9vbFtdW11cbiAqIGJvb2xbM11bXVxuICogYm9vbFtdWzZdW10sIC4uLlxuICovXG52YXIgU29saWRpdHlUeXBlQm9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRCb29sO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0Qm9vbDtcbn07XG5cblNvbGlkaXR5VHlwZUJvb2wucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVCb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUJvb2w7XG5cblNvbGlkaXR5VHlwZUJvb2wucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXmJvb2woXFxbKFswLTldKilcXF0pKiQvKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlQm9vbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9ib29sLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYm9vbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZUJ5dGVzIGlzIGEgcHJvdG90eXBlIHRoYXQgcmVwcmVzZW50cyB0aGUgYnl0ZXMgdHlwZS5cbiAqIEl0IG1hdGNoZXM6XG4gKiBieXRlc1xuICogYnl0ZXNbXVxuICogYnl0ZXNbNF1cbiAqIGJ5dGVzW11bXVxuICogYnl0ZXNbM11bXVxuICogYnl0ZXNbXVs2XVtdLCAuLi5cbiAqIGJ5dGVzMzJcbiAqIGJ5dGVzOFs0XVxuICogYnl0ZXNbM11bXVxuICovXG52YXIgU29saWRpdHlUeXBlQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0Qnl0ZXM7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRCeXRlcztcbn07XG5cblNvbGlkaXR5VHlwZUJ5dGVzLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlQnl0ZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlQnl0ZXM7XG5cblNvbGlkaXR5VHlwZUJ5dGVzLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15ieXRlcyhbMC05XXsxLH0pKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUJ5dGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2J5dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYnl0ZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgY29kZXIuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcblxudmFyIFNvbGlkaXR5VHlwZUFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcbnZhciBTb2xpZGl0eVR5cGVCb29sID0gcmVxdWlyZSgnLi9ib29sJyk7XG52YXIgU29saWRpdHlUeXBlSW50ID0gcmVxdWlyZSgnLi9pbnQnKTtcbnZhciBTb2xpZGl0eVR5cGVVSW50ID0gcmVxdWlyZSgnLi91aW50Jyk7XG52YXIgU29saWRpdHlUeXBlRHluYW1pY0J5dGVzID0gcmVxdWlyZSgnLi9keW5hbWljYnl0ZXMnKTtcbnZhciBTb2xpZGl0eVR5cGVTdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZycpO1xudmFyIFNvbGlkaXR5VHlwZVJlYWwgPSByZXF1aXJlKCcuL3JlYWwnKTtcbnZhciBTb2xpZGl0eVR5cGVVUmVhbCA9IHJlcXVpcmUoJy4vdXJlYWwnKTtcbnZhciBTb2xpZGl0eVR5cGVCeXRlcyA9IHJlcXVpcmUoJy4vYnl0ZXMnKTtcblxudmFyIGlzRHluYW1pYyA9IGZ1bmN0aW9uIChzb2xpZGl0eVR5cGUsIHR5cGUpIHtcbiAgIHJldHVybiBzb2xpZGl0eVR5cGUuaXNEeW5hbWljVHlwZSh0eXBlKSB8fFxuICAgICAgICAgIHNvbGlkaXR5VHlwZS5pc0R5bmFtaWNBcnJheSh0eXBlKTtcbn07XG5cbi8qKlxuICogU29saWRpdHlDb2RlciBwcm90b3R5cGUgc2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlL2RlY29kZSBzb2xpZGl0eSBwYXJhbXMgb2YgYW55IHR5cGVcbiAqL1xudmFyIFNvbGlkaXR5Q29kZXIgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICB0aGlzLl90eXBlcyA9IHR5cGVzO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byB0cmFuc2Zvcm0gdHlwZSB0byBTb2xpZGl0eVR5cGVcbiAqXG4gKiBAbWV0aG9kIF9yZXF1aXJlVHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm5zIHtTb2xpZGl0eVR5cGV9XG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3dzIGlmIG5vIG1hdGNoaW5nIHR5cGUgaXMgZm91bmRcbiAqL1xuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuX3JlcXVpcmVUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgc29saWRpdHlUeXBlID0gdGhpcy5fdHlwZXMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzVHlwZSh0eXBlKTtcbiAgICB9KVswXTtcblxuICAgIGlmICghc29saWRpdHlUeXBlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdpbnZhbGlkIHNvbGlkaXR5IHR5cGUhOiAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvbGlkaXR5VHlwZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIHBsYWluIHBhcmFtXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZVBhcmFtID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1zKFt0eXBlXSwgW3BhcmFtXSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBsaXN0IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFyYW1zXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgbGlzdCBvZiBwYXJhbXNcbiAqL1xuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZW5jb2RlUGFyYW1zID0gZnVuY3Rpb24gKHR5cGVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc29saWRpdHlUeXBlcyA9IHRoaXMuZ2V0U29saWRpdHlUeXBlcyh0eXBlcyk7XG5cbiAgICB2YXIgZW5jb2RlZHMgPSBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLmVuY29kZShwYXJhbXNbaW5kZXhdLCB0eXBlc1tpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGR5bmFtaWNPZmZzZXQgPSBzb2xpZGl0eVR5cGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzb2xpZGl0eVR5cGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBzdGF0aWNQYXJ0TGVuZ3RoID0gc29saWRpdHlUeXBlLnN0YXRpY1BhcnRMZW5ndGgodHlwZXNbaW5kZXhdKTtcbiAgICAgICAgdmFyIHJvdW5kZWRTdGF0aWNQYXJ0TGVuZ3RoID0gTWF0aC5mbG9vcigoc3RhdGljUGFydExlbmd0aCArIDMxKSAvIDMyKSAqIDMyO1xuXG4gICAgICAgIHJldHVybiBhY2MgKyAoaXNEeW5hbWljKHNvbGlkaXR5VHlwZXNbaW5kZXhdLCB0eXBlc1tpbmRleF0pID9cbiAgICAgICAgICAgIDMyIDpcbiAgICAgICAgICAgIHJvdW5kZWRTdGF0aWNQYXJ0TGVuZ3RoKTtcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLmVuY29kZU11bHRpV2l0aE9mZnNldCh0eXBlcywgc29saWRpdHlUeXBlcywgZW5jb2RlZHMsIGR5bmFtaWNPZmZzZXQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZU11bHRpV2l0aE9mZnNldCA9IGZ1bmN0aW9uICh0eXBlcywgc29saWRpdHlUeXBlcywgZW5jb2RlZHMsIGR5bmFtaWNPZmZzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgICAgIGlmIChpc0R5bmFtaWMoc29saWRpdHlUeXBlc1tpXSwgdHlwZXNbaV0pKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZi5mb3JtYXRJbnB1dEludChkeW5hbWljT2Zmc2V0KS5lbmNvZGUoKTtcbiAgICAgICAgICAgIHZhciBlID0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICBkeW5hbWljT2Zmc2V0ICs9IGUubGVuZ3RoIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGFkZCBsZW5ndGggdG8gZHluYW1pY09mZnNldC4gaXQncyBhbHJlYWR5IGNvdW50ZWRcbiAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQodHlwZXNbaV0sIHNvbGlkaXR5VHlwZXNbaV0sIGVuY29kZWRzW2ldLCBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgbmVzdGVkIGFycmF5c1xuICAgIH0pO1xuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICBpZiAoaXNEeW5hbWljKHNvbGlkaXR5VHlwZXNbaV0sIHR5cGVzW2ldKSkge1xuICAgICAgICAgICAgdmFyIGUgPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQodHlwZXNbaV0sIHNvbGlkaXR5VHlwZXNbaV0sIGVuY29kZWRzW2ldLCBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIGR5bmFtaWNPZmZzZXQgKz0gZS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gVE9ETzogcmVmYWN0b3Igd2hvbGUgZW5jb2RpbmchXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVXaXRoT2Zmc2V0ID0gZnVuY3Rpb24gKHR5cGUsIHNvbGlkaXR5VHlwZSwgZW5jb2RlZCwgb2Zmc2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBvZmZzZXQgd2FzIGFscmVhZHkgc2V0XG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNvbGlkaXR5VHlwZS5uZXN0ZWROYW1lKHR5cGUpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGUuc3RhdGljUGFydExlbmd0aChuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbmNvZGVkWzBdO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0xlbmd0aCA9IDI7IC8vIGluIGludFxuICAgICAgICAgICAgICAgIGlmIChzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkobmVzdGVkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0xlbmd0aCArPSArKGVuY29kZWRbaSAtIDFdKVswXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGYuZm9ybWF0SW5wdXRJbnQob2Zmc2V0ICsgaSAqIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggKyBwcmV2aW91c0xlbmd0aCAqIDMyKS5lbmNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgbGVuZ3RoLCBza2lwIGl0XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxPZmZzZXQgPSByZXN1bHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KG5lc3RlZE5hbWUsIHNvbGlkaXR5VHlwZSwgZW5jb2RlZFtpICsgMV0sIG9mZnNldCArICBhZGRpdGlvbmFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuXG4gICAgfSBlbHNlIGlmIChzb2xpZGl0eVR5cGUuaXNTdGF0aWNBcnJheSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc29saWRpdHlUeXBlLm5lc3RlZE5hbWUodHlwZSk7XG4gICAgICAgICAgICB2YXIgbmVzdGVkU3RhdGljUGFydExlbmd0aCA9IHNvbGlkaXR5VHlwZS5zdGF0aWNQYXJ0TGVuZ3RoKG5lc3RlZE5hbWUpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cblxuICAgICAgICAgICAgaWYgKHNvbGlkaXR5VHlwZS5pc0R5bmFtaWNBcnJheShuZXN0ZWROYW1lKSkge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0xlbmd0aCA9IDA7IC8vIGluIGludFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBsZW5ndGggb2YgcHJldmlvdXMgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNMZW5ndGggKz0gKyhlbmNvZGVkW2kgLSAxXSB8fCBbXSlbMF0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmLmZvcm1hdElucHV0SW50KG9mZnNldCArIGkgKiBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgcHJldmlvdXNMZW5ndGggKiAzMikuZW5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbE9mZnNldCA9IHJlc3VsdCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQobmVzdGVkTmFtZSwgc29saWRpdHlUeXBlLCBlbmNvZGVkW2ldLCBvZmZzZXQgKyBhZGRpdGlvbmFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgYnl0ZXMgdG8gcGxhaW4gcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBsYWluIHBhcmFtXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtID0gZnVuY3Rpb24gKHR5cGUsIGJ5dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1zKFt0eXBlXSwgYnl0ZXMpWzBdO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtcyA9IGZ1bmN0aW9uICh0eXBlcywgYnl0ZXMpIHtcbiAgICB2YXIgc29saWRpdHlUeXBlcyA9IHRoaXMuZ2V0U29saWRpdHlUeXBlcyh0eXBlcyk7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLmdldE9mZnNldHModHlwZXMsIHNvbGlkaXR5VHlwZXMpO1xuXG4gICAgcmV0dXJuIHNvbGlkaXR5VHlwZXMubWFwKGZ1bmN0aW9uIChzb2xpZGl0eVR5cGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzb2xpZGl0eVR5cGUuZGVjb2RlKGJ5dGVzLCBvZmZzZXRzW2luZGV4XSwgIHR5cGVzW2luZGV4XSwgaW5kZXgpO1xuICAgIH0pO1xufTtcblxuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uICh0eXBlcywgc29saWRpdHlUeXBlcykge1xuICAgIHZhciBsZW5ndGhzID0gIHNvbGlkaXR5VHlwZXMubWFwKGZ1bmN0aW9uIChzb2xpZGl0eVR5cGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzb2xpZGl0eVR5cGUuc3RhdGljUGFydExlbmd0aCh0eXBlc1tpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAvLyBzdW0gd2l0aCBsZW5ndGggb2YgcHJldmlvdXMgZWxlbWVudFxuICAgICAgICBsZW5ndGhzW2ldICs9IGxlbmd0aHNbaSAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBsZW5ndGhzLm1hcChmdW5jdGlvbiAobGVuZ3RoLCBpbmRleCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGN1cnJlbnQgbGVuZ3RoLCBzbyB0aGUgbGVuZ3RoIGlzIHN1bSBvZiBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICB2YXIgc3RhdGljUGFydExlbmd0aCA9IHNvbGlkaXR5VHlwZXNbaW5kZXhdLnN0YXRpY1BhcnRMZW5ndGgodHlwZXNbaW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCAtIHN0YXRpY1BhcnRMZW5ndGg7XG4gICAgfSk7XG59O1xuXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5nZXRTb2xpZGl0eVR5cGVzID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3JlcXVpcmVUeXBlKHR5cGUpO1xuICAgIH0pO1xufTtcblxudmFyIGNvZGVyID0gbmV3IFNvbGlkaXR5Q29kZXIoW1xuICAgIG5ldyBTb2xpZGl0eVR5cGVBZGRyZXNzKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUJvb2woKSxcbiAgICBuZXcgU29saWRpdHlUeXBlSW50KCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZVVJbnQoKSxcbiAgICBuZXcgU29saWRpdHlUeXBlRHluYW1pY0J5dGVzKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUJ5dGVzKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZVN0cmluZygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVSZWFsKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZVVSZWFsKClcbl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2NvZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvY29kZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxudmFyIFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXREeW5hbWljQnl0ZXM7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXREeW5hbWljQnl0ZXM7XG59O1xuXG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlRHluYW1pY0J5dGVzO1xuXG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXmJ5dGVzKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5Tb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMucHJvdG90eXBlLmlzRHluYW1pY1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9keW5hbWljYnl0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9keW5hbWljYnl0ZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZm9ybWF0dGVycy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIGMgPSByZXF1aXJlKCcuLi91dGlscy9jb25maWcnKTtcbnZhciBTb2xpZGl0eVBhcmFtID0gcmVxdWlyZSgnLi9wYXJhbScpO1xuXG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIGludFxuICogSWYgdmFsdWUgaXMgbmVnYXRpdmUsIHJldHVybiBpdCdzIHR3bydzIGNvbXBsZW1lbnRcbiAqIElmIHRoZSB2YWx1ZSBpcyBmbG9hdGluZyBwb2ludCwgcm91bmQgaXQgZG93blxuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRJbnRcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ9IHZhbHVlIHRoYXQgbmVlZHMgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0SW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgQmlnTnVtYmVyLmNvbmZpZyhjLkVUSF9CSUdOVU1CRVJfUk9VTkRJTkdfTU9ERSk7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLnBhZExlZnQodXRpbHMudG9Ud29zQ29tcGxlbWVudCh2YWx1ZSkudG9TdHJpbmcoMTYpLCA2NCk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgaW5wdXQgYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0Qnl0ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dEJ5dGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLnRvSGV4KHZhbHVlKS5zdWJzdHIoMik7XG4gICAgdmFyIGwgPSBNYXRoLmZsb29yKChyZXN1bHQubGVuZ3RoICsgNjMpIC8gNjQpO1xuICAgIHJlc3VsdCA9IHV0aWxzLnBhZFJpZ2h0KHJlc3VsdCwgbCAqIDY0KTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0ocmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0RHluYW1pY0lucHV0Qnl0ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dER5bmFtaWNCeXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB1dGlscy50b0hleCh2YWx1ZSkuc3Vic3RyKDIpO1xuICAgIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoIC8gMjtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IoKHJlc3VsdC5sZW5ndGggKyA2MykgLyA2NCk7XG4gICAgcmVzdWx0ID0gdXRpbHMucGFkUmlnaHQocmVzdWx0LCBsICogNjQpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShmb3JtYXRJbnB1dEludChsZW5ndGgpLnZhbHVlICsgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dFN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB1dGlscy5mcm9tVXRmOCh2YWx1ZSkuc3Vic3RyKDIpO1xuICAgIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoIC8gMjtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IoKHJlc3VsdC5sZW5ndGggKyA2MykgLyA2NCk7XG4gICAgcmVzdWx0ID0gdXRpbHMucGFkUmlnaHQocmVzdWx0LCBsICogNjQpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShmb3JtYXRJbnB1dEludChsZW5ndGgpLnZhbHVlICsgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIGJvb2xcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0Qm9vbFxuICogQHBhcmFtIHtCb29sZWFufVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dEJvb2wgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgKyAodmFsdWUgPyAgJzEnIDogJzAnKTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0ocmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCB2YWx1ZSB0byBieXRlIHJlcHJlc2VudGF0aW9uIG9mIHJlYWxcbiAqIFZhbHVlcyBhcmUgbXVsdGlwbGllZCBieSAyXm0gYW5kIGVuY29kZWQgYXMgaW50ZWdlcnNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0UmVhbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXRSZWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdElucHV0SW50KG5ldyBCaWdOdW1iZXIodmFsdWUpLnRpbWVzKG5ldyBCaWdOdW1iZXIoMikucG93KDEyOCkpKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaW5wdXQgdmFsdWUgaXMgbmVnYXRpdmVcbiAqXG4gKiBAbWV0aG9kIHNpZ25lZElzTmVnYXRpdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBpcyBoZXggZm9ybWF0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBzaWduZWRJc05lZ2F0aXZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQmlnTnVtYmVyKHZhbHVlLnN1YnN0cigwLCAxKSwgMTYpLnRvU3RyaW5nKDIpLnN1YnN0cigwLCAxKSkgPT09ICcxJztcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byBpbnRcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dEludFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBwYXJhbVxuICogQHJldHVybnMge0JpZ051bWJlcn0gcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIGJpZyBudW1iZXJcbiAqL1xudmFyIGZvcm1hdE91dHB1dEludCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcmFtLnN0YXRpY1BhcnQoKSB8fCBcIjBcIjtcblxuICAgIC8vIGNoZWNrIGlmIGl0J3MgbmVnYXRpdmUgbnVtYmVyXG4gICAgLy8gaXQgaXQgaXMsIHJldHVybiB0d28ncyBjb21wbGVtZW50XG4gICAgaWYgKHNpZ25lZElzTmVnYXRpdmUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbHVlLCAxNikubWludXMobmV3IEJpZ051bWJlcignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KSkubWludXMoMSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbHVlLCAxNik7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgdG8gdWludFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0VUludFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfVxuICogQHJldHVybnMge0JpZ051bWViZXJ9IHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIGZvcm1hdHRlZCB0byB1aW50XG4gKi9cbnZhciBmb3JtYXRPdXRwdXRVSW50ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyYW0uc3RhdGljUGFydCgpIHx8IFwiMFwiO1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbHVlLCAxNik7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgdG8gcmVhbFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0UmVhbFxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfVxuICogQHJldHVybnMge0JpZ051bWJlcn0gaW5wdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIHJlYWxcbiAqL1xudmFyIGZvcm1hdE91dHB1dFJlYWwgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gZm9ybWF0T3V0cHV0SW50KHBhcmFtKS5kaXZpZGVkQnkobmV3IEJpZ051bWJlcigyKS5wb3coMTI4KSk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgdG8gdXJlYWxcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFVSZWFsXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBpbnB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gdXJlYWxcbiAqL1xudmFyIGZvcm1hdE91dHB1dFVSZWFsID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIGZvcm1hdE91dHB1dFVJbnQocGFyYW0pLmRpdmlkZWRCeShuZXcgQmlnTnVtYmVyKDIpLnBvdygxMjgpKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBib29sXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRCb29sXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmlnaHQtYWxpZ25lZCBpbnB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gYm9vbFxuICovXG52YXIgZm9ybWF0T3V0cHV0Qm9vbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbS5zdGF0aWNQYXJ0KCkgPT09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyA/IHRydWUgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0Qnl0ZXNcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gbGVmdC1hbGlnbmVkIGhleCByZXByZXNlbnRhdGlvbiBvZiBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHR5cGUgbmFtZVxuICogQHJldHVybnMge1N0cmluZ30gaGV4IHN0cmluZ1xuICovXG52YXIgZm9ybWF0T3V0cHV0Qnl0ZXMgPSBmdW5jdGlvbiAocGFyYW0sIG5hbWUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IG5hbWUubWF0Y2goL15ieXRlcyhbMC05XSopLyk7XG4gICAgdmFyIHNpemUgPSBwYXJzZUludChtYXRjaGVzWzFdKTtcbiAgICByZXR1cm4gJzB4JyArIHBhcmFtLnN0YXRpY1BhcnQoKS5zbGljZSgwLCAyICogc2l6ZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dER5bmFtaWNCeXRlc1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBsZWZ0LWFsaWduZWQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHN0cmluZ1xuICovXG52YXIgZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIGxlbmd0aCA9IChuZXcgQmlnTnVtYmVyKHBhcmFtLmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCwgNjQpLCAxNikpLnRvTnVtYmVyKCkgKiAyO1xuICAgIHJldHVybiAnMHgnICsgcGFyYW0uZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsIGxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRTdHJpbmdcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gbGVmdC1hbGlnbmVkIGhleCByZXByZXNlbnRhdGlvbiBvZiBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZ1xuICovXG52YXIgZm9ybWF0T3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIGxlbmd0aCA9IChuZXcgQmlnTnVtYmVyKHBhcmFtLmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCwgNjQpLCAxNikpLnRvTnVtYmVyKCkgKiAyO1xuICAgIHJldHVybiB1dGlscy50b1V0ZjgocGFyYW0uZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsIGxlbmd0aCkpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dEFkZHJlc3NcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gcmlnaHQtYWxpZ25lZCBpbnB1dCBieXRlc1xuICogQHJldHVybnMge1N0cmluZ30gYWRkcmVzc1xuICovXG52YXIgZm9ybWF0T3V0cHV0QWRkcmVzcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcmFtLnN0YXRpY1BhcnQoKTtcbiAgICByZXR1cm4gXCIweFwiICsgdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gNDAsIHZhbHVlLmxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb3JtYXRJbnB1dEludDogZm9ybWF0SW5wdXRJbnQsXG4gICAgZm9ybWF0SW5wdXRCeXRlczogZm9ybWF0SW5wdXRCeXRlcyxcbiAgICBmb3JtYXRJbnB1dER5bmFtaWNCeXRlczogZm9ybWF0SW5wdXREeW5hbWljQnl0ZXMsXG4gICAgZm9ybWF0SW5wdXRTdHJpbmc6IGZvcm1hdElucHV0U3RyaW5nLFxuICAgIGZvcm1hdElucHV0Qm9vbDogZm9ybWF0SW5wdXRCb29sLFxuICAgIGZvcm1hdElucHV0UmVhbDogZm9ybWF0SW5wdXRSZWFsLFxuICAgIGZvcm1hdE91dHB1dEludDogZm9ybWF0T3V0cHV0SW50LFxuICAgIGZvcm1hdE91dHB1dFVJbnQ6IGZvcm1hdE91dHB1dFVJbnQsXG4gICAgZm9ybWF0T3V0cHV0UmVhbDogZm9ybWF0T3V0cHV0UmVhbCxcbiAgICBmb3JtYXRPdXRwdXRVUmVhbDogZm9ybWF0T3V0cHV0VVJlYWwsXG4gICAgZm9ybWF0T3V0cHV0Qm9vbDogZm9ybWF0T3V0cHV0Qm9vbCxcbiAgICBmb3JtYXRPdXRwdXRCeXRlczogZm9ybWF0T3V0cHV0Qnl0ZXMsXG4gICAgZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzOiBmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXMsXG4gICAgZm9ybWF0T3V0cHV0U3RyaW5nOiBmb3JtYXRPdXRwdXRTdHJpbmcsXG4gICAgZm9ybWF0T3V0cHV0QWRkcmVzczogZm9ybWF0T3V0cHV0QWRkcmVzc1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9mb3JtYXR0ZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvZm9ybWF0dGVycy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZUludCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyBpbnQgdHlwZVxuICogSXQgbWF0Y2hlczpcbiAqIGludFxuICogaW50W11cbiAqIGludFs0XVxuICogaW50W11bXVxuICogaW50WzNdW11cbiAqIGludFtdWzZdW10sIC4uLlxuICogaW50MzJcbiAqIGludDY0W11cbiAqIGludDhbNF1cbiAqIGludDI1NltdW11cbiAqIGludFszXVtdXG4gKiBpbnQ2NFtdWzZdW10sIC4uLlxuICovXG52YXIgU29saWRpdHlUeXBlSW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEludDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dEludDtcbn07XG5cblNvbGlkaXR5VHlwZUludC5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZUludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVJbnQ7XG5cblNvbGlkaXR5VHlwZUludC5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9eaW50KFswLTldKik/KFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9pbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIHBhcmFtLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbi8qKlxuICogU29saWRpdHlQYXJhbSBvYmplY3QgcHJvdG90eXBlLlxuICogU2hvdWxkIGJlIHVzZWQgd2hlbiBlbmNvZGluZywgZGVjb2Rpbmcgc29saWRpdHkgYnl0ZXNcbiAqL1xudmFyIFNvbGlkaXR5UGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDsgLy8gb2Zmc2V0IGluIGJ5dGVzXG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGdldCBsZW5ndGggb2YgcGFyYW1zJ3MgZHluYW1pYyBwYXJ0XG4gKiBcbiAqIEBtZXRob2QgZHluYW1pY1BhcnRMZW5ndGhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBkeW5hbWljIHBhcnQgKGluIGJ5dGVzKVxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5keW5hbWljUGFydExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5keW5hbWljUGFydCgpLmxlbmd0aCAvIDI7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBjb3B5IG9mIHNvbGlkaXR5IHBhcmFtIHdpdGggZGlmZmVyZW50IG9mZnNldFxuICpcbiAqIEBtZXRob2Qgd2l0aE9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBsZW5ndGggaW4gYnl0ZXNcbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfSBuZXcgc29saWRpdHkgcGFyYW0gd2l0aCBhcHBsaWVkIG9mZnNldFxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS53aXRoT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbSh0aGlzLnZhbHVlLCBvZmZzZXQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjb21iaW5lIHNvbGlkaXR5IHBhcmFtcyB0b2dldGhlclxuICogZWcuIHdoZW4gYXBwZW5kaW5nIGFuIGFycmF5XG4gKlxuICogQG1ldGhvZCBjb21iaW5lXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IHBhcmFtIHdpdGggd2hpY2ggd2Ugc2hvdWxkIGNvbWJpbmVcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gcmVzdWx0IG9mIGNvbWJpbmF0aW9uXG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0odGhpcy52YWx1ZSArIHBhcmFtLnZhbHVlKTsgXG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgcGFyYW0gaGFzIGR5bmFtaWMgc2l6ZS5cbiAqIElmIGl0IGhhcywgaXQgcmV0dXJucyB0cnVlLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRHluYW1pY1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmlzRHluYW1pYyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgIT09IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byB0cmFuc2Zvcm0gb2Zmc2V0IHRvIGJ5dGVzXG4gKlxuICogQG1ldGhvZCBvZmZzZXRBc0J5dGVzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBieXRlcyByZXByZXNlbnRhdGlvbiBvZiBvZmZzZXRcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUub2Zmc2V0QXNCeXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNEeW5hbWljKCkgPyAnJyA6IHV0aWxzLnBhZExlZnQodXRpbHMudG9Ud29zQ29tcGxlbWVudCh0aGlzLm9mZnNldCkudG9TdHJpbmcoMTYpLCA2NCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHN0YXRpYyBwYXJ0IG9mIHBhcmFtXG4gKlxuICogQG1ldGhvZCBzdGF0aWNQYXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBvZmZzZXQgaWYgaXQgaXMgYSBkeW5hbWljIHBhcmFtLCBvdGhlcndpc2UgdmFsdWVcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuc3RhdGljUGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEeW5hbWljKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7IFxuICAgIH0gXG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0QXNCeXRlcygpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGdldCBkeW5hbWljIHBhcnQgb2YgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGR5bmFtaWNQYXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSByZXR1cm5zIGEgdmFsdWUgaWYgaXQgaXMgYSBkeW5hbWljIHBhcmFtLCBvdGhlcndpc2UgZW1wdHkgc3RyaW5nXG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmR5bmFtaWNQYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzRHluYW1pYygpID8gdGhpcy52YWx1ZSA6ICcnO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGVuY29kZSBwYXJhbVxuICpcbiAqIEBtZXRob2QgZW5jb2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljUGFydCgpICsgdGhpcy5keW5hbWljUGFydCgpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIGVuY29kZSBhcnJheSBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGVuY29kZUxpc3RcbiAqIEBwYXJhbSB7QXJyYXlbU29saWRpdHlQYXJhbV19IHBhcmFtc1xuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuU29saWRpdHlQYXJhbS5lbmNvZGVMaXN0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIFxuICAgIC8vIHVwZGF0aW5nIG9mZnNldHNcbiAgICB2YXIgdG90YWxPZmZzZXQgPSBwYXJhbXMubGVuZ3RoICogMzI7XG4gICAgdmFyIG9mZnNldFBhcmFtcyA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIGlmICghcGFyYW0uaXNEeW5hbWljKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gdG90YWxPZmZzZXQ7XG4gICAgICAgIHRvdGFsT2Zmc2V0ICs9IHBhcmFtLmR5bmFtaWNQYXJ0TGVuZ3RoKCk7XG4gICAgICAgIHJldHVybiBwYXJhbS53aXRoT2Zmc2V0KG9mZnNldCk7XG4gICAgfSk7XG5cbiAgICAvLyBlbmNvZGUgZXZlcnl0aGluZyFcbiAgICByZXR1cm4gb2Zmc2V0UGFyYW1zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwYXJhbSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcGFyYW0uZHluYW1pY1BhcnQoKTtcbiAgICB9LCBvZmZzZXRQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhcmFtKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBwYXJhbS5zdGF0aWNQYXJ0KCk7XG4gICAgfSwgJycpKTtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5UGFyYW07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9wYXJhbS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3BhcmFtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlUmVhbCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyByZWFsIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiByZWFsXG4gKiByZWFsW11cbiAqIHJlYWxbNF1cbiAqIHJlYWxbXVtdXG4gKiByZWFsWzNdW11cbiAqIHJlYWxbXVs2XVtdLCAuLi5cbiAqIHJlYWwzMlxuICogcmVhbDY0W11cbiAqIHJlYWw4WzRdXG4gKiByZWFsMjU2W11bXVxuICogcmVhbFszXVtdXG4gKiByZWFsNjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVJlYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0UmVhbDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFJlYWw7XG59O1xuXG5Tb2xpZGl0eVR5cGVSZWFsLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlUmVhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVSZWFsO1xuXG5Tb2xpZGl0eVR5cGVSZWFsLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL3JlYWwoWzAtOV0qKT8oXFxbKFswLTldKilcXF0pPy8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVSZWFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3JlYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9yZWFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0U3RyaW5nO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0U3RyaW5nO1xufTtcblxuU29saWRpdHlUeXBlU3RyaW5nLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZVN0cmluZztcblxuU29saWRpdHlUeXBlU3RyaW5nLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15zdHJpbmcoXFxbKFswLTldKilcXF0pKiQvKTtcbn07XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuaXNEeW5hbWljVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3N0cmluZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5UGFyYW0gPSByZXF1aXJlKCcuL3BhcmFtJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlIHByb3RvdHlwZSBpcyB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGNlcnRhaW4gdHlwZVxuICovXG52YXIgU29saWRpdHlUeXBlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gY29uZmlnLmlucHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGNvbmZpZy5vdXRwdXRGb3JtYXR0ZXI7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0aGlzIFNvbGlkaXR5VHlwZSBkbyBtYXRjaCBnaXZlbiBuYW1lXG4gKlxuICogQG1ldGhvZCBpc1R5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIHR5cGUgbWF0Y2ggdGhpcyBTb2xpZGl0eVR5cGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgXCJ0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJ3cml0dGVuIGZvciB0eXBlIFwiICsgbmFtZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoYXQgaXMgdGhlIGxlbmd0aCBvZiBzdGF0aWMgcGFydCBpbiBnaXZlbiB0eXBlXG4gKlxuICogQG1ldGhvZCBzdGF0aWNQYXJ0TGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2Ygc3RhdGljIHBhcnQgaW4gYnl0ZXNcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5zdGF0aWNQYXJ0TGVuZ3RoID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBJZiBuYW1lIGlzbid0IGFuIGFycmF5IHRoZW4gdHJlYXQgaXQgbGlrZSBhIHNpbmdsZSBlbGVtZW50IGFycmF5LlxuICAgIHJldHVybiAodGhpcy5uZXN0ZWRUeXBlcyhuYW1lKSB8fCBbJ1sxXSddKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIG9mIHRoZSBuZXN0ZWQgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0eXBlLnNsaWNlKDEsIC0xKSwgMTApIHx8IDE7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKiBjdXJyZW50O1xuICAgICAgICAvLyBhbGwgYmFzaWMgdHlwZXMgYXJlIDMyIGJ5dGVzIGxvbmdcbiAgICAgICAgfSwgMzIpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdHlwZSBpcyBkeW5hbWljIGFycmF5XG4gKiBlZzpcbiAqIFwidHlwZVtdXCIgPT4gdHJ1ZVxuICogXCJ0eXBlWzRdXCIgPT4gZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRHluYW1pY0FycmF5XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBkeW5hbWljIGFycmF5XG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuaXNEeW5hbWljQXJyYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBuZXN0ZWRUeXBlcyA9IHRoaXMubmVzdGVkVHlwZXMobmFtZSk7XG4gICAgcmV0dXJuICEhbmVzdGVkVHlwZXMgJiYgIW5lc3RlZFR5cGVzW25lc3RlZFR5cGVzLmxlbmd0aCAtIDFdLm1hdGNoKC9bMC05XXsxLH0vZyk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0eXBlIGlzIHN0YXRpYyBhcnJheVxuICogZWc6XG4gKiBcInR5cGVbXVwiID0+IGZhbHNlXG4gKiBcInR5cGVbNF1cIiA9PiB0cnVlXG4gKlxuICogQG1ldGhvZCBpc1N0YXRpY0FycmF5XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBzdGF0aWMgYXJyYXlcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5pc1N0YXRpY0FycmF5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbmVzdGVkVHlwZXMgPSB0aGlzLm5lc3RlZFR5cGVzKG5hbWUpO1xuICAgIHJldHVybiAhIW5lc3RlZFR5cGVzICYmICEhbmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1swLTldezEsfS9nKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiBsZW5ndGggb2Ygc3RhdGljIGFycmF5XG4gKiBlZy5cbiAqIFwiaW50WzMyXVwiID0+IDMyXG4gKiBcImludDI1NlsxNF1cIiA9PiAxNFxuICogXCJpbnRbMl1bM11cIiA9PiAzXG4gKiBcImludFwiID0+IDFcbiAqIFwiaW50WzFdXCIgPT4gMVxuICogXCJpbnRbXVwiID0+IDFcbiAqXG4gKiBAbWV0aG9kIHN0YXRpY0FycmF5TGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7TnVtYmVyfSBzdGF0aWMgYXJyYXkgbGVuZ3RoXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuc3RhdGljQXJyYXlMZW5ndGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBuZXN0ZWRUeXBlcyA9IHRoaXMubmVzdGVkVHlwZXMobmFtZSk7XG4gICAgaWYgKG5lc3RlZFR5cGVzKSB7XG4gICAgICAgcmV0dXJuIHBhcnNlSW50KG5lc3RlZFR5cGVzW25lc3RlZFR5cGVzLmxlbmd0aCAtIDFdLm1hdGNoKC9bMC05XXsxLH0vZykgfHwgMSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIG5lc3RlZCB0eXBlXG4gKiBlZy5cbiAqIFwiaW50WzMyXVwiID0+IFwiaW50XCJcbiAqIFwiaW50MjU2WzE0XVwiID0+IFwiaW50MjU2XCJcbiAqIFwiaW50WzJdWzNdXCIgPT4gXCJpbnRbMl1cIlxuICogXCJpbnRcIiA9PiBcImludFwiXG4gKiBcImludFtdXCIgPT4gXCJpbnRcIlxuICpcbiAqIEBtZXRob2QgbmVzdGVkTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gbmVzdGVkIG5hbWVcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5uZXN0ZWROYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyByZW1vdmUgbGFzdCBbXSBpbiBuYW1lXG4gICAgdmFyIG5lc3RlZFR5cGVzID0gdGhpcy5uZXN0ZWRUeXBlcyhuYW1lKTtcbiAgICBpZiAoIW5lc3RlZFR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIG5lc3RlZFR5cGVzW25lc3RlZFR5cGVzLmxlbmd0aCAtIDFdLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0eXBlIGhhcyBkeW5hbWljIHNpemUgYnkgZGVmYXVsdFxuICogc3VjaCB0eXBlcyBhcmUgXCJzdHJpbmdcIiwgXCJieXRlc1wiXG4gKlxuICogQG1ldGhvZCBpc0R5bmFtaWNUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiBpcyBkeW5hbWljLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiBhcnJheSBvZiBuZXN0ZWQgdHlwZXNcbiAqIGVnLlxuICogXCJpbnRbMl1bM11bXVwiID0+IFtcIlsyXVwiLCBcIlszXVwiLCBcIltdXCJdXG4gKiBcImludFtdID0+IFtcIltdXCJdXG4gKiBcImludFwiID0+IG51bGxcbiAqXG4gKiBAbWV0aG9kIG5lc3RlZFR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIG5lc3RlZCB0eXBlc1xuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLm5lc3RlZFR5cGVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyByZXR1cm4gbGlzdCBvZiBzdHJpbmdzIGVnLiBcIltdXCIsIFwiWzNdXCIsIFwiW11cIiwgXCJbMl1cIlxuICAgIHJldHVybiBuYW1lLm1hdGNoKC8oXFxbWzAtOV0qXFxdKS9nKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHRoZSB2YWx1ZVxuICpcbiAqIEBtZXRob2QgZW5jb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgdmFsdWVcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuaXNEeW5hbWljQXJyYXkobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc2VsZi5uZXN0ZWROYW1lKG5hbWUpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICByZXN1bHQucHVzaChmLmZvcm1hdElucHV0SW50KGxlbmd0aCkuZW5jb2RlKCkpO1xuXG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5lbmNvZGUodiwgbmVzdGVkTmFtZSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdGF0aWNBcnJheShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHNlbGYuc3RhdGljQXJyYXlMZW5ndGgobmFtZSk7ICAgICAgICAgIC8vIGluIGludFxuICAgICAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzZWxmLm5lc3RlZE5hbWUobmFtZSk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLmVuY29kZSh2YWx1ZVtpXSwgbmVzdGVkTmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lucHV0Rm9ybWF0dGVyKHZhbHVlLCBuYW1lKS5lbmNvZGUoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIHZhbHVlIGZyb20gYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IGluIGJ5dGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0eXBlIG5hbWVcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlY29kZWQgdmFsdWVcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMsIG9mZnNldCwgbmFtZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzRHluYW1pY0FycmF5KG5hbWUpKSB7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXlPZmZzZXQgPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKG9mZnNldCAqIDIsIDY0KSk7IC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoJzB4JyArIGJ5dGVzLnN1YnN0cihhcnJheU9mZnNldCAqIDIsIDY0KSk7IC8vIGluIGludFxuICAgICAgICAgICAgdmFyIGFycmF5U3RhcnQgPSBhcnJheU9mZnNldCArIDMyOyAvLyBhcnJheSBzdGFydHMgYWZ0ZXIgbGVuZ3RoOyAvLyBpbiBieXRlc1xuXG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNlbGYubmVzdGVkTmFtZShuYW1lKTtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gc2VsZi5zdGF0aWNQYXJ0TGVuZ3RoKG5lc3RlZE5hbWUpOyAgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aCA9IE1hdGguZmxvb3IoKG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggKyAzMSkgLyAzMikgKiAzMjtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggKiByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aDsgaSArPSByb3VuZGVkTmVzdGVkU3RhdGljUGFydExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuZGVjb2RlKGJ5dGVzLCBhcnJheVN0YXJ0ICsgaSwgbmVzdGVkTmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGljQXJyYXkobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBzZWxmLnN0YXRpY0FycmF5TGVuZ3RoKG5hbWUpOyAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBhcnJheVN0YXJ0ID0gb2Zmc2V0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBieXRlc1xuXG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNlbGYubmVzdGVkTmFtZShuYW1lKTtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gc2VsZi5zdGF0aWNQYXJ0TGVuZ3RoKG5lc3RlZE5hbWUpOyAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gTWF0aC5mbG9vcigobmVzdGVkU3RhdGljUGFydExlbmd0aCArIDMxKSAvIDMyKSAqIDMyO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAqIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoOyBpICs9IHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5kZWNvZGUoYnl0ZXMsIGFycmF5U3RhcnQgKyBpLCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRHluYW1pY1R5cGUobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gcGFyc2VJbnQoJzB4JyArIGJ5dGVzLnN1YnN0cihvZmZzZXQgKiAyLCA2NCkpOyAgICAgIC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoJzB4JyArIGJ5dGVzLnN1YnN0cihkeW5hbWljT2Zmc2V0ICogMiwgNjQpKTsgICAgICAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIHJvdW5kZWRMZW5ndGggPSBNYXRoLmZsb29yKChsZW5ndGggKyAzMSkgLyAzMik7ICAgICAgICAgICAgICAgICAgICAgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBuZXcgU29saWRpdHlQYXJhbShieXRlcy5zdWJzdHIoZHluYW1pY09mZnNldCAqIDIsICggMSArIHJvdW5kZWRMZW5ndGgpICogNjQpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9vdXRwdXRGb3JtYXR0ZXIocGFyYW0sIG5hbWUpO1xuICAgICAgICB9KSgpO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSB0aGlzLnN0YXRpY1BhcnRMZW5ndGgobmFtZSk7XG4gICAgdmFyIHBhcmFtID0gbmV3IFNvbGlkaXR5UGFyYW0oYnl0ZXMuc3Vic3RyKG9mZnNldCAqIDIsIGxlbmd0aCAqIDIpKTtcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0Rm9ybWF0dGVyKHBhcmFtLCBuYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS90eXBlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlVUludCBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyB1aW50IHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiB1aW50XG4gKiB1aW50W11cbiAqIHVpbnRbNF1cbiAqIHVpbnRbXVtdXG4gKiB1aW50WzNdW11cbiAqIHVpbnRbXVs2XVtdLCAuLi5cbiAqIHVpbnQzMlxuICogdWludDY0W11cbiAqIHVpbnQ4WzRdXG4gKiB1aW50MjU2W11bXVxuICogdWludFszXVtdXG4gKiB1aW50NjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVVJbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0SW50O1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0VUludDtcbn07XG5cblNvbGlkaXR5VHlwZVVJbnQucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZVVJbnQ7XG5cblNvbGlkaXR5VHlwZVVJbnQucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXnVpbnQoWzAtOV0qKT8oXFxbKFswLTldKilcXF0pKiQvKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlUeXBlVUludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91aW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdWludC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVVSZWFsIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIHVyZWFsIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiB1cmVhbFxuICogdXJlYWxbXVxuICogdXJlYWxbNF1cbiAqIHVyZWFsW11bXVxuICogdXJlYWxbM11bXVxuICogdXJlYWxbXVs2XVtdLCAuLi5cbiAqIHVyZWFsMzJcbiAqIHVyZWFsNjRbXVxuICogdXJlYWw4WzRdXG4gKiB1cmVhbDI1NltdW11cbiAqIHVyZWFsWzNdW11cbiAqIHVyZWFsNjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVVSZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFJlYWw7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRVUmVhbDtcbn07XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlVVJlYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlVVJlYWw7XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL151cmVhbChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVVUmVhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91cmVhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3VyZWFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gZ28gZW52IGRvZXNuJ3QgaGF2ZSBhbmQgbmVlZCBYTUxIdHRwUmVxdWVzdFxuaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0ge307XG59IGVsc2Uge1xuICAgIGV4cG9ydHMuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9icm93c2VyLXhoci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL2Jyb3dzZXIteGhyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgY29uZmlnLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuLyoqXG4gKiBVdGlsc1xuICogXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICogXG4gKiBAY2xhc3MgW3V0aWxzXSBjb25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxuLy8vIHJlcXVpcmVkIHRvIGRlZmluZSBFVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREVcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxudmFyIEVUSF9VTklUUyA9IFtcbiAgICAnd2VpJyxcbiAgICAna3dlaScsXG4gICAgJ013ZWknLFxuICAgICdHd2VpJyxcbiAgICAnc3phYm8nLFxuICAgICdmaW5uZXknLFxuICAgICdmZW10b2V0aGVyJyxcbiAgICAncGljb2V0aGVyJyxcbiAgICAnbmFub2V0aGVyJyxcbiAgICAnbWljcm9ldGhlcicsXG4gICAgJ21pbGxpZXRoZXInLFxuICAgICduYW5vJyxcbiAgICAnbWljcm8nLFxuICAgICdtaWxsaScsXG4gICAgJ2V0aGVyJyxcbiAgICAnZ3JhbmQnLFxuICAgICdNZXRoZXInLFxuICAgICdHZXRoZXInLFxuICAgICdUZXRoZXInLFxuICAgICdQZXRoZXInLFxuICAgICdFZXRoZXInLFxuICAgICdaZXRoZXInLFxuICAgICdZZXRoZXInLFxuICAgICdOZXRoZXInLFxuICAgICdEZXRoZXInLFxuICAgICdWZXRoZXInLFxuICAgICdVZXRoZXInXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFVEhfUEFERElORzogMzIsXG4gICAgRVRIX1NJR05BVFVSRV9MRU5HVEg6IDQsXG4gICAgRVRIX1VOSVRTOiBFVEhfVU5JVFMsXG4gICAgRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFOiB7IFJPVU5ESU5HX01PREU6IEJpZ051bWJlci5ST1VORF9ET1dOIH0sXG4gICAgRVRIX1BPTExJTkdfVElNRU9VVDogMTAwMC8yLFxuICAgIGRlZmF1bHRCbG9jazogJ2xhdGVzdCcsXG4gICAgZGVmYXVsdEFjY291bnQ6IHVuZGVmaW5lZFxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgc2hhMy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCdjcnlwdG8tanMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnY3J5cHRvLWpzL3NoYTMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAmJiB2YWx1ZS5zdWJzdHIoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYTModmFsdWUsIHtcbiAgICAgICAgb3V0cHV0TGVuZ3RoOiAyNTZcbiAgICB9KS50b1N0cmluZygpO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL3NoYTMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9zaGEzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIHV0aWxzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbi8qKlxuICogVXRpbHNcbiAqXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICpcbiAqIEBjbGFzcyBbdXRpbHNdIHV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi9zaGEzLmpzJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxudmFyIHVuaXRNYXAgPSB7XG4gICAgJ25vZXRoZXInOiAgICAgICcwJyxcbiAgICAnd2VpJzogICAgICAgICAgJzEnLFxuICAgICdrd2VpJzogICAgICAgICAnMTAwMCcsXG4gICAgJ0t3ZWknOiAgICAgICAgICcxMDAwJyxcbiAgICAnYmFiYmFnZSc6ICAgICAgJzEwMDAnLFxuICAgICdmZW10b2V0aGVyJzogICAnMTAwMCcsXG4gICAgJ213ZWknOiAgICAgICAgICcxMDAwMDAwJyxcbiAgICAnTXdlaSc6ICAgICAgICAgJzEwMDAwMDAnLFxuICAgICdsb3ZlbGFjZSc6ICAgICAnMTAwMDAwMCcsXG4gICAgJ3BpY29ldGhlcic6ICAgICcxMDAwMDAwJyxcbiAgICAnZ3dlaSc6ICAgICAgICAgJzEwMDAwMDAwMDAnLFxuICAgICdHd2VpJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3NoYW5ub24nOiAgICAgICcxMDAwMDAwMDAwJyxcbiAgICAnbmFub2V0aGVyJzogICAgJzEwMDAwMDAwMDAnLFxuICAgICduYW5vJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3N6YWJvJzogICAgICAgICcxMDAwMDAwMDAwMDAwJyxcbiAgICAnbWljcm9ldGhlcic6ICAgJzEwMDAwMDAwMDAwMDAnLFxuICAgICdtaWNybyc6ICAgICAgICAnMTAwMDAwMDAwMDAwMCcsXG4gICAgJ2Zpbm5leSc6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWlsbGlldGhlcic6ICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWlsbGknOiAgICAgICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnZXRoZXInOiAgICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdrZXRoZXInOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2dyYW5kJzogICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWV0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdnZXRoZXInOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ3RldGhlcic6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCBwYWRMZWZ0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJhY3RlcnMgdGhhdCByZXN1bHQgc3RyaW5nIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbiwgYnkgZGVmYXVsdCAwXG4gKiBAcmV0dXJucyB7U3RyaW5nfSByaWdodCBhbGlnbmVkIHN0cmluZ1xuICovXG52YXIgcGFkTGVmdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpICsgc3RyaW5nO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCBwYWRSaWdodFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFyYWN0ZXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIHBhZFJpZ2h0ID0gZnVuY3Rpb24gKHN0cmluZywgY2hhcnMsIHNpZ24pIHtcbiAgICByZXR1cm4gc3RyaW5nICsgKG5ldyBBcnJheShjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbnZhciB0b1V0ZjggPSBmdW5jdGlvbihoZXgpIHtcbi8vIEZpbmQgdGVybWluYXRpb25cbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDAsIGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgIGkgPSAyO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkrPTIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIGlmIChjb2RlID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGY4LmRlY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgdG9Bc2NpaSA9IGZ1bmN0aW9uKGhleCkge1xuLy8gRmluZCB0ZXJtaW5hdGlvblxuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMCwgbCA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgaSA9IDI7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbDsgaSs9Mikge1xuICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgZnJvbVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgICBzdHIgPSB1dGY4LmVuY29kZShzdHIpO1xuICAgIHZhciBoZXggPSBcIlwiO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgIH1cblxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgZnJvbUFzY2lpID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGhleCA9IFwiXCI7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZSBmcm9tIGpzb24gYWJpXG4gKlxuICogQG1ldGhvZCB0cmFuc2Zvcm1Ub0Z1bGxOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbi1hYmlcbiAqIEByZXR1cm4ge1N0cmluZ30gZnVsbCBmbmN0aW9uL2V2ZW50IG5hbWVcbiAqL1xudmFyIHRyYW5zZm9ybVRvRnVsbE5hbWUgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIGlmIChqc29uLm5hbWUuaW5kZXhPZignKCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ganNvbi5uYW1lO1xuICAgIH1cblxuICAgIHZhciB0eXBlTmFtZSA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gaS50eXBlOyB9KS5qb2luKCk7XG4gICAgcmV0dXJuIGpzb24ubmFtZSArICcoJyArIHR5cGVOYW1lICsgJyknO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBkaXNwbGF5IG5hbWUgb2YgY29udHJhY3QgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3REaXNwbGF5TmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgZnVuY3Rpb24vZXZlbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGRpc3BsYXkgbmFtZSBmb3IgZnVuY3Rpb24vZXZlbnQgZWcuIG11bHRpcGx5KHVpbnQyNTYpIC0+IG11bHRpcGx5XG4gKi9cbnZhciBleHRyYWN0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBsZW5ndGggPSBuYW1lLmluZGV4T2YoJygnKTtcbiAgICByZXR1cm4gbGVuZ3RoICE9PSAtMSA/IG5hbWUuc3Vic3RyKDAsIGxlbmd0aCkgOiBuYW1lO1xufTtcblxuLy8vIEByZXR1cm5zIG92ZXJsb2FkZWQgcGFydCBvZiBmdW5jdGlvbi9ldmVudCBuYW1lXG52YXIgZXh0cmFjdFR5cGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLy8gVE9ETzogbWFrZSBpdCBpbnZ1bG5lcmFibGVcbiAgICB2YXIgbGVuZ3RoID0gbmFtZS5pbmRleE9mKCcoJyk7XG4gICAgcmV0dXJuIGxlbmd0aCAhPT0gLTEgPyBuYW1lLnN1YnN0cihsZW5ndGggKyAxLCBuYW1lLmxlbmd0aCAtIDEgLSAobGVuZ3RoICsgMSkpLnJlcGxhY2UoJyAnLCAnJykgOiBcIlwiO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gaW4gc3RyaW5nXG4gKlxuICogQG1ldGhvZCB0b0RlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCaWdOdW1iZXJ9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b0RlY2ltYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdG9CaWdOdW1iZXIodmFsdWUpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCBmcm9tRGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGZyb21EZWNpbWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG51bWJlciA9IHRvQmlnTnVtYmVyKHZhbHVlKTtcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyLnRvU3RyaW5nKDE2KTtcblxuICAgIHJldHVybiBudW1iZXIubGVzc1RoYW4oMCkgPyAnLTB4JyArIHJlc3VsdC5zdWJzdHIoMSkgOiAnMHgnICsgcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBdXRvIGNvbnZlcnRzIGFueSBnaXZlbiB2YWx1ZSBpbnRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEFuZCBldmVuIHN0cmluZ2lmeXMgb2JqZWN0cyBiZWZvcmUuXG4gKlxuICogQG1ldGhvZCB0b0hleFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcnxPYmplY3R9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b0hleCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG5cbiAgICBpZiAoaXNCb29sZWFuKHZhbCkpXG4gICAgICAgIHJldHVybiBmcm9tRGVjaW1hbCgrdmFsKTtcblxuICAgIGlmIChpc0JpZ051bWJlcih2YWwpKVxuICAgICAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcblxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZyb21VdGY4KEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuXG4gICAgLy8gaWYgaXRzIGEgbmVnYXRpdmUgbnVtYmVyLCBwYXNzIGl0IHRocm91Z2ggZnJvbURlY2ltYWxcbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgICBpZiAodmFsLmluZGV4T2YoJy0weCcpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21EZWNpbWFsKHZhbCk7XG4gICAgICAgIGVsc2UgaWYodmFsLmluZGV4T2YoJzB4JykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBlbHNlIGlmICghaXNGaW5pdGUodmFsKSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQXNjaWkodmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZSBvZiB1bml0IGluIFdlaVxuICpcbiAqIEBtZXRob2QgZ2V0VmFsdWVPZlVuaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHZhbHVlIG9mIHRoZSB1bml0IChpbiBXZWkpXG4gKiBAdGhyb3dzIGVycm9yIGlmIHRoZSB1bml0IGlzIG5vdCBjb3JyZWN0OndcbiAqL1xudmFyIGdldFZhbHVlT2ZVbml0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB1bml0ID0gdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6ICdldGhlcic7XG4gICAgdmFyIHVuaXRWYWx1ZSA9IHVuaXRNYXBbdW5pdF07XG4gICAgaWYgKHVuaXRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IGRvZXNuXFwndCBleGlzdHMsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzJyArIEpTT04uc3RyaW5naWZ5KHVuaXRNYXAsIG51bGwsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodW5pdFZhbHVlLCAxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIHdlaSBhbmQgY29udmVydHMgaXQgdG8gYW55IG90aGVyIGV0aGVyIHVuaXQuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIGZyb21XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9IFdoZW4gZ2l2ZW4gYSBCaWdOdW1iZXIgb2JqZWN0IGl0IHJldHVybnMgb25lIGFzIHdlbGwsIG90aGVyd2lzZSBhIG51bWJlclxuKi9cbnZhciBmcm9tV2VpID0gZnVuY3Rpb24obnVtYmVyLCB1bml0KSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gdG9CaWdOdW1iZXIobnVtYmVyKS5kaXZpZGVkQnkoZ2V0VmFsdWVPZlVuaXQodW5pdCkpO1xuXG4gICAgcmV0dXJuIGlzQmlnTnVtYmVyKG51bWJlcikgPyByZXR1cm5WYWx1ZSA6IHJldHVyblZhbHVlLnRvU3RyaW5nKDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYSB1bml0IGFuZCBjb252ZXJ0cyBpdCB0byB3ZWkuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIHRvV2VpXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8QmlnTnVtYmVyfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCBmcm9tLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSBXaGVuIGdpdmVuIGEgQmlnTnVtYmVyIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiovXG52YXIgdG9XZWkgPSBmdW5jdGlvbihudW1iZXIsIHVuaXQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSB0b0JpZ051bWJlcihudW1iZXIpLnRpbWVzKGdldFZhbHVlT2ZVbml0KHVuaXQpKTtcblxuICAgIHJldHVybiBpc0JpZ051bWJlcihudW1iZXIpID8gcmV0dXJuVmFsdWUgOiByZXR1cm5WYWx1ZS50b1N0cmluZygxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGlucHV0IGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gYW4gYmlnbnVtYmVyXG4gKlxuICogQG1ldGhvZCB0b0JpZ051bWJlclxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJpZ051bWJlcn0gYSBudW1iZXIsIHN0cmluZywgSEVYIHN0cmluZyBvciBCaWdOdW1iZXJcbiAqIEByZXR1cm4ge0JpZ051bWJlcn0gQmlnTnVtYmVyXG4qL1xudmFyIHRvQmlnTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG4gICAgbnVtYmVyID0gbnVtYmVyIHx8IDA7XG4gICAgaWYgKGlzQmlnTnVtYmVyKG51bWJlcikpXG4gICAgICAgIHJldHVybiBudW1iZXI7XG5cbiAgICBpZiAoaXNTdHJpbmcobnVtYmVyKSAmJiAobnVtYmVyLmluZGV4T2YoJzB4JykgPT09IDAgfHwgbnVtYmVyLmluZGV4T2YoJy0weCcpID09PSAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihudW1iZXIucmVwbGFjZSgnMHgnLCcnKSwgMTYpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG51bWJlci50b1N0cmluZygxMCksIDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW5kIGlucHV0IHRyYW5zZm9ybXMgaXQgaW50byBiaWdudW1iZXIgYW5kIGlmIGl0IGlzIG5lZ2F0aXZlIHZhbHVlLCBpbnRvIHR3bydzIGNvbXBsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIHRvVHdvc0NvbXBsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCaWdOdW1iZXJ9XG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9XG4gKi9cbnZhciB0b1R3b3NDb21wbGVtZW50ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHZhciBiaWdOdW1iZXIgPSB0b0JpZ051bWJlcihudW1iZXIpLnJvdW5kKCk7XG4gICAgaWYgKGJpZ051bWJlci5sZXNzVGhhbigwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIiwgMTYpLnBsdXMoYmlnTnVtYmVyKS5wbHVzKDEpO1xuICAgIH1cbiAgICByZXR1cm4gYmlnTnVtYmVyO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBzdHJpY3RseSBhbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc1N0cmljdEFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cbnZhciBpc1N0cmljdEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHJldHVybiAvXjB4WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xudmFyIGlzQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaGFzIHRoZSBiYXNpYyByZXF1aXJlbWVudHMgb2YgYW4gYWRkcmVzc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NDB9JC8udGVzdChhZGRyZXNzKSB8fCAvXigweCk/WzAtOUEtRl17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICAvLyBJZiBpdCdzIGFsbCBzbWFsbCBjYXBzIG9yIGFsbCBhbGwgY2FwcywgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGVhY2ggY2FzZVxuICAgICAgICByZXR1cm4gaXNDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiovXG52YXIgaXNDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIC8vIENoZWNrIGVhY2ggY2FzZVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrICkge1xuICAgICAgICAvLyB0aGUgbnRoIGxldHRlciBzaG91bGQgYmUgdXBwZXJjYXNlIGlmIHRoZSBudGggZGlnaXQgb2YgY2FzZW1hcCBpcyAxXG4gICAgICAgIGlmICgocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcgJiYgYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpICE9PSBhZGRyZXNzW2ldKSB8fCAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA8PSA3ICYmIGFkZHJlc3NbaV0udG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vKipcbiAqIE1ha2VzIGEgY2hlY2tzdW0gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgdG9DaGVja3N1bUFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4qL1xudmFyIHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG5cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzKTtcbiAgICB2YXIgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA5IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtQWRkcmVzcztcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBnaXZlbiBzdHJpbmcgdG8gdmFsaWQgMjAgYnl0ZXMtbGVuZ3RoIGFkZHJlcyB3aXRoIDB4IHByZWZpeFxuICpcbiAqIEBtZXRob2QgdG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgYWRkcmVzc1xuICovXG52YXIgdG9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNTdHJpY3RBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cblxuICAgIGlmICgvXlswLTlhLWZdezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBhZGRyZXNzO1xuICAgIH1cblxuICAgIHJldHVybiAnMHgnICsgcGFkTGVmdCh0b0hleChhZGRyZXNzKS5zdWJzdHIoMiksIDQwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBCaWdOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCaWdOdW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBCaWdOdW1iZXIgfHxcbiAgICAgICAgKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCaWdOdW1iZXInKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNTdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAob2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvciAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ1N0cmluZycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgT2JqZXQsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgIT09IG51bGwgJiYgIShvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0Jvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Jvb2xlYW4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzQXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEFycmF5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIHZhbGlkIGpzb24gb2JqZWN0XG4gKlxuICogQG1ldGhvZCBpc0pzb25cbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSnNvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFKU09OLnBhcnNlKHN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgRXRoZXJldW0gYmxvY2sgaGVhZGVyIGJsb29tLlxuICpcbiAqIEBtZXRob2QgaXNCbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGhleCBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmxvb20gPSBmdW5jdGlvbiAoYmxvb20pIHtcbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs1MTJ9JC9pLnRlc3QoYmxvb20pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKC9eKDB4KT9bMC05YS1mXXs1MTJ9JC8udGVzdChibG9vbSkgfHwgL14oMHgpP1swLTlBLUZdezUxMn0kLy50ZXN0KGJsb29tKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgbG9nIHRvcGljLlxuICpcbiAqIEBtZXRob2QgaXNUb3BpY1xuICogQHBhcmFtIHtTdHJpbmd9IGhleCBlbmNvZGVkIHRvcGljXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUb3BpYyA9IGZ1bmN0aW9uICh0b3BpYykge1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezY0fSQvaS50ZXN0KHRvcGljKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NjR9JC8udGVzdCh0b3BpYykgfHwgL14oMHgpP1swLTlBLUZdezY0fSQvLnRlc3QodG9waWMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYWRMZWZ0OiBwYWRMZWZ0LFxuICAgIHBhZFJpZ2h0OiBwYWRSaWdodCxcbiAgICB0b0hleDogdG9IZXgsXG4gICAgdG9EZWNpbWFsOiB0b0RlY2ltYWwsXG4gICAgZnJvbURlY2ltYWw6IGZyb21EZWNpbWFsLFxuICAgIHRvVXRmODogdG9VdGY4LFxuICAgIHRvQXNjaWk6IHRvQXNjaWksXG4gICAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICAgIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICAgIHRyYW5zZm9ybVRvRnVsbE5hbWU6IHRyYW5zZm9ybVRvRnVsbE5hbWUsXG4gICAgZXh0cmFjdERpc3BsYXlOYW1lOiBleHRyYWN0RGlzcGxheU5hbWUsXG4gICAgZXh0cmFjdFR5cGVOYW1lOiBleHRyYWN0VHlwZU5hbWUsXG4gICAgdG9XZWk6IHRvV2VpLFxuICAgIGZyb21XZWk6IGZyb21XZWksXG4gICAgdG9CaWdOdW1iZXI6IHRvQmlnTnVtYmVyLFxuICAgIHRvVHdvc0NvbXBsZW1lbnQ6IHRvVHdvc0NvbXBsZW1lbnQsXG4gICAgdG9BZGRyZXNzOiB0b0FkZHJlc3MsXG4gICAgaXNCaWdOdW1iZXI6IGlzQmlnTnVtYmVyLFxuICAgIGlzU3RyaWN0QWRkcmVzczogaXNTdHJpY3RBZGRyZXNzLFxuICAgIGlzQWRkcmVzczogaXNBZGRyZXNzLFxuICAgIGlzQ2hlY2tzdW1BZGRyZXNzOiBpc0NoZWNrc3VtQWRkcmVzcyxcbiAgICB0b0NoZWNrc3VtQWRkcmVzczogdG9DaGVja3N1bUFkZHJlc3MsXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgaXNKc29uOiBpc0pzb24sXG4gICAgaXNCbG9vbTogaXNCbG9vbSxcbiAgICBpc1RvcGljOiBpc1RvcGljLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3V0aWxzL3V0aWxzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1widmVyc2lvblwiOlwiMC4yMC4xXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3ZlcnNpb24uanNvblxuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3ZlcnNpb24uanNvblxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSB3ZWIzLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiAgIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqICAgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgUmVxdWVzdE1hbmFnZXIgPSByZXF1aXJlKCcuL3dlYjMvcmVxdWVzdG1hbmFnZXInKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnLi93ZWIzL2liYW4nKTtcbnZhciBFdGggPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9ldGgnKTtcbnZhciBEQiA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL2RiJyk7XG52YXIgU2hoID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvc2hoJyk7XG52YXIgTmV0ID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvbmV0Jyk7XG52YXIgUGVyc29uYWwgPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9wZXJzb25hbCcpO1xudmFyIFN3YXJtID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvc3dhcm0nKTtcbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vd2ViMy9zZXR0aW5ncycpO1xudmFyIHZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24uanNvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91dGlscycpO1xudmFyIHNoYTMgPSByZXF1aXJlKCcuL3V0aWxzL3NoYTMnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3dlYjMvZXh0ZW5kJyk7XG52YXIgQmF0Y2ggPSByZXF1aXJlKCcuL3dlYjMvYmF0Y2gnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vd2ViMy9wcm9wZXJ0eScpO1xudmFyIEh0dHBQcm92aWRlciA9IHJlcXVpcmUoJy4vd2ViMy9odHRwcHJvdmlkZXInKTtcbnZhciBJcGNQcm92aWRlciA9IHJlcXVpcmUoJy4vd2ViMy9pcGNwcm92aWRlcicpO1xudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuXG5cblxuZnVuY3Rpb24gV2ViMyAocHJvdmlkZXIpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IG5ldyBSZXF1ZXN0TWFuYWdlcihwcm92aWRlcik7XG4gICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLmV0aCA9IG5ldyBFdGgodGhpcyk7XG4gICAgdGhpcy5kYiA9IG5ldyBEQih0aGlzKTtcbiAgICB0aGlzLnNoaCA9IG5ldyBTaGgodGhpcyk7XG4gICAgdGhpcy5uZXQgPSBuZXcgTmV0KHRoaXMpO1xuICAgIHRoaXMucGVyc29uYWwgPSBuZXcgUGVyc29uYWwodGhpcyk7XG4gICAgdGhpcy5ienogPSBuZXcgU3dhcm0odGhpcyk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuICAgIHRoaXMudmVyc2lvbiA9IHtcbiAgICAgICAgYXBpOiB2ZXJzaW9uLnZlcnNpb25cbiAgICB9O1xuICAgIHRoaXMucHJvdmlkZXJzID0ge1xuICAgICAgICBIdHRwUHJvdmlkZXI6IEh0dHBQcm92aWRlcixcbiAgICAgICAgSXBjUHJvdmlkZXI6IElwY1Byb3ZpZGVyXG4gICAgfTtcbiAgICB0aGlzLl9leHRlbmQgPSBleHRlbmQodGhpcyk7XG4gICAgdGhpcy5fZXh0ZW5kKHtcbiAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcygpXG4gICAgfSk7XG59XG5cbi8vIGV4cG9zZSBwcm92aWRlcnMgb24gdGhlIGNsYXNzXG5XZWIzLnByb3ZpZGVycyA9IHtcbiAgICBIdHRwUHJvdmlkZXI6IEh0dHBQcm92aWRlcixcbiAgICBJcGNQcm92aWRlcjogSXBjUHJvdmlkZXJcbn07XG5cbldlYjMucHJvdG90eXBlLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIuc2V0UHJvdmlkZXIocHJvdmlkZXIpO1xuICAgIHRoaXMuY3VycmVudFByb3ZpZGVyID0gcHJvdmlkZXI7XG59O1xuXG5XZWIzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChrZWVwSXNTeW5jaW5nKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIucmVzZXQoa2VlcElzU3luY2luZyk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xufTtcblxuV2ViMy5wcm90b3R5cGUuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xuV2ViMy5wcm90b3R5cGUudG9IZXggPSB1dGlscy50b0hleDtcbldlYjMucHJvdG90eXBlLnRvQXNjaWkgPSB1dGlscy50b0FzY2lpO1xuV2ViMy5wcm90b3R5cGUudG9VdGY4ID0gdXRpbHMudG9VdGY4O1xuV2ViMy5wcm90b3R5cGUuZnJvbUFzY2lpID0gdXRpbHMuZnJvbUFzY2lpO1xuV2ViMy5wcm90b3R5cGUuZnJvbVV0ZjggPSB1dGlscy5mcm9tVXRmODtcbldlYjMucHJvdG90eXBlLnRvRGVjaW1hbCA9IHV0aWxzLnRvRGVjaW1hbDtcbldlYjMucHJvdG90eXBlLmZyb21EZWNpbWFsID0gdXRpbHMuZnJvbURlY2ltYWw7XG5XZWIzLnByb3RvdHlwZS50b0JpZ051bWJlciA9IHV0aWxzLnRvQmlnTnVtYmVyO1xuV2ViMy5wcm90b3R5cGUudG9XZWkgPSB1dGlscy50b1dlaTtcbldlYjMucHJvdG90eXBlLmZyb21XZWkgPSB1dGlscy5mcm9tV2VpO1xuV2ViMy5wcm90b3R5cGUuaXNBZGRyZXNzID0gdXRpbHMuaXNBZGRyZXNzO1xuV2ViMy5wcm90b3R5cGUuaXNDaGVja3N1bUFkZHJlc3MgPSB1dGlscy5pc0NoZWNrc3VtQWRkcmVzcztcbldlYjMucHJvdG90eXBlLnRvQ2hlY2tzdW1BZGRyZXNzID0gdXRpbHMudG9DaGVja3N1bUFkZHJlc3M7XG5XZWIzLnByb3RvdHlwZS5pc0lCQU4gPSB1dGlscy5pc0lCQU47XG5XZWIzLnByb3RvdHlwZS5wYWRMZWZ0ID0gdXRpbHMucGFkTGVmdDtcbldlYjMucHJvdG90eXBlLnBhZFJpZ2h0ID0gdXRpbHMucGFkUmlnaHQ7XG5cblxuV2ViMy5wcm90b3R5cGUuc2hhMyA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiAnMHgnICsgc2hhMyhzdHJpbmcsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGRpcmVjdCBpY2FwIHRvIGFkZHJlc3NcbiAqL1xuV2ViMy5wcm90b3R5cGUuZnJvbUlDQVAgPSBmdW5jdGlvbiAoaWNhcCkge1xuICAgIHZhciBpYmFuID0gbmV3IEliYW4oaWNhcCk7XG4gICAgcmV0dXJuIGliYW4uYWRkcmVzcygpO1xufTtcblxudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLm5vZGUnLFxuICAgICAgICAgICAgZ2V0dGVyOiAnd2ViM19jbGllbnRWZXJzaW9uJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLm5ldHdvcmsnLFxuICAgICAgICAgICAgZ2V0dGVyOiAnbmV0X3ZlcnNpb24nLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLmV0aGVyZXVtJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9wcm90b2NvbFZlcnNpb24nLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uLndoaXNwZXInLFxuICAgICAgICAgICAgZ2V0dGVyOiAnc2hoX3ZlcnNpb24nLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5XZWIzLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRQcm92aWRlciAmJiB0aGlzLmN1cnJlbnRQcm92aWRlci5pc0Nvbm5lY3RlZCgpKTtcbn07XG5cbldlYjMucHJvdG90eXBlLmNyZWF0ZUJhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQmF0Y2godGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYjM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBhbGxldmVudHMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIHNoYTMgPSByZXF1aXJlKCcuLi91dGlscy9zaGEzJyk7XG52YXIgU29saWRpdHlFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgd2F0Y2hlcyA9IHJlcXVpcmUoJy4vbWV0aG9kcy93YXRjaGVzJyk7XG5cbnZhciBBbGxTb2xpZGl0eUV2ZW50cyA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwganNvbiwgYWRkcmVzcykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5fanNvbiA9IGpzb247XG4gICAgdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG59O1xuXG5BbGxTb2xpZGl0eUV2ZW50cy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBbJ2Zyb21CbG9jaycsICd0b0Jsb2NrJ10uZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2ZdICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXN1bHRbZl0gPSBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9uc1tmXSk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQuYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3M7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8ICcnO1xuICAgIGRhdGEudG9waWNzID0gZGF0YS50b3BpY3MgfHwgW107XG5cbiAgICB2YXIgZXZlbnRUb3BpYyA9IGRhdGEudG9waWNzWzBdLnNsaWNlKDIpO1xuICAgIHZhciBtYXRjaCA9IHRoaXMuX2pzb24uZmlsdGVyKGZ1bmN0aW9uIChqKSB7XG4gICAgICAgIHJldHVybiBldmVudFRvcGljID09PSBzaGEzKHV0aWxzLnRyYW5zZm9ybVRvRnVsbE5hbWUoaikpO1xuICAgIH0pWzBdO1xuXG4gICAgaWYgKCFtYXRjaCkgeyAvLyBjYW5ub3QgZmluZCBtYXRjaGluZyBldmVudD9cbiAgICAgICAgY29uc29sZS53YXJuKCdjYW5ub3QgZmluZCBldmVudCBmb3IgbG9nJyk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHZhciBldmVudCA9IG5ldyBTb2xpZGl0eUV2ZW50KHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCBtYXRjaCwgdGhpcy5fYWRkcmVzcyk7XG4gICAgcmV0dXJuIGV2ZW50LmRlY29kZShkYXRhKTtcbn07XG5cbkFsbFNvbGlkaXR5RXZlbnRzLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbyA9IHRoaXMuZW5jb2RlKG9wdGlvbnMpO1xuICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmRlY29kZS5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBuZXcgRmlsdGVyKG8sICdldGgnLCB0aGlzLl9yZXF1ZXN0TWFuYWdlciwgd2F0Y2hlcy5ldGgoKSwgZm9ybWF0dGVyLCBjYWxsYmFjayk7XG59O1xuXG5BbGxTb2xpZGl0eUV2ZW50cy5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgY29udHJhY3QuYWxsRXZlbnRzID0gZXhlY3V0ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsU29saWRpdHlFdmVudHM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2FsbGV2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvYWxsZXZlbnRzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBiYXRjaC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgSnNvbnJwYyA9IHJlcXVpcmUoJy4vanNvbnJwYycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbnZhciBCYXRjaCA9IGZ1bmN0aW9uICh3ZWIzKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMucmVxdWVzdHMgPSBbXTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgY3JlYXRlIG5ldyByZXF1ZXN0IHRvIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtPYmplY3R9IGpzb25ycGMgcmVxdWV0IG9iamVjdFxuICovXG5CYXRjaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICB0aGlzLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZXhlY3V0ZSBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBleGVjdXRlXG4gKi9cbkJhdGNoLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXF1ZXN0cyA9IHRoaXMucmVxdWVzdHM7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5zZW5kQmF0Y2gocmVxdWVzdHMsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gICAgICAgIHJlcXVlc3RzLm1hcChmdW5jdGlvbiAocmVxdWVzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzW2luZGV4XSB8fCB7fTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RzW2luZGV4XS5jYWxsYmFjaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0c1tpbmRleF0uY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0c1tpbmRleF0uY2FsbGJhY2sobnVsbCwgKHJlcXVlc3RzW2luZGV4XS5mb3JtYXQgPyByZXF1ZXN0c1tpbmRleF0uZm9ybWF0KHJlc3VsdC5yZXN1bHQpIDogcmVzdWx0LnJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTsgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhdGNoO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9iYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvYmF0Y2guanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgY29udHJhY3QuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjb2RlciA9IHJlcXVpcmUoJy4uL3NvbGlkaXR5L2NvZGVyJyk7XG52YXIgU29saWRpdHlFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcbnZhciBTb2xpZGl0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9mdW5jdGlvbicpO1xudmFyIEFsbEV2ZW50cyA9IHJlcXVpcmUoJy4vYWxsZXZlbnRzJyk7XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBlbmNvZGUgY29uc3RydWN0b3IgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtc1xuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJ1Y3RvciBwYXJhbXNcbiAqL1xudmFyIGVuY29kZUNvbnN0cnVjdG9yUGFyYW1zID0gZnVuY3Rpb24gKGFiaSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiBqc29uLmlucHV0cy5sZW5ndGggPT09IHBhcmFtcy5sZW5ndGg7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQudHlwZTtcbiAgICAgICAgfSk7XG4gICAgfSkubWFwKGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICByZXR1cm4gY29kZXIuZW5jb2RlUGFyYW1zKHR5cGVzLCBwYXJhbXMpO1xuICAgIH0pWzBdIHx8ICcnO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFkZCBmdW5jdGlvbnMgdG8gY29udHJhY3Qgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBhZGRGdW5jdGlvbnNUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fSBjb250cmFjdFxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKi9cbnZhciBhZGRGdW5jdGlvbnNUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgY29udHJhY3QuYWJpLmZpbHRlcihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4ganNvbi50eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IFNvbGlkaXR5RnVuY3Rpb24oY29udHJhY3QuX2V0aCwganNvbiwgY29udHJhY3QuYWRkcmVzcyk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICBmLmF0dGFjaFRvQ29udHJhY3QoY29udHJhY3QpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFkZCBldmVudHMgdG8gY29udHJhY3Qgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBhZGRFdmVudHNUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fSBjb250cmFjdFxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKi9cbnZhciBhZGRFdmVudHNUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV2ZW50cyA9IGNvbnRyYWN0LmFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2V2ZW50JztcbiAgICB9KTtcblxuICAgIHZhciBBbGwgPSBuZXcgQWxsRXZlbnRzKGNvbnRyYWN0Ll9ldGguX3JlcXVlc3RNYW5hZ2VyLCBldmVudHMsIGNvbnRyYWN0LmFkZHJlc3MpO1xuICAgIEFsbC5hdHRhY2hUb0NvbnRyYWN0KGNvbnRyYWN0KTtcblxuICAgIGV2ZW50cy5tYXAoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb2xpZGl0eUV2ZW50KGNvbnRyYWN0Ll9ldGguX3JlcXVlc3RNYW5hZ2VyLCBqc29uLCBjb250cmFjdC5hZGRyZXNzKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuYXR0YWNoVG9Db250cmFjdChjb250cmFjdCk7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiB0aGUgY29udHJhY3QgZ2V0cyBwcm9wZXJseSBkZXBsb3llZCBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7VW5kZWZpbmVkfVxuICovXG52YXIgY2hlY2tGb3JDb250cmFjdEFkZHJlc3MgPSBmdW5jdGlvbihjb250cmFjdCwgY2FsbGJhY2spe1xuICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgIGNhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblxuICAgIC8vIHdhaXQgZm9yIHJlY2VpcHRcbiAgICB2YXIgZmlsdGVyID0gY29udHJhY3QuX2V0aC5maWx0ZXIoJ2xhdGVzdCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZiAoIWUgJiYgIWNhbGxiYWNrRmlyZWQpIHtcbiAgICAgICAgICAgIGNvdW50Kys7XG5cbiAgICAgICAgICAgIC8vIHN0b3Agd2F0Y2hpbmcgYWZ0ZXIgNTAgYmxvY2tzICh0aW1lb3V0KVxuICAgICAgICAgICAgaWYgKGNvdW50ID4gNTApIHtcblxuICAgICAgICAgICAgICAgIGZpbHRlci5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKSB7fSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGaXJlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignQ29udHJhY3QgdHJhbnNhY3Rpb24gY291bGRuXFwndCBiZSBmb3VuZCBhZnRlciA1MCBibG9ja3MnKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkblxcJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzJyk7XG5cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGNvbnRyYWN0Ll9ldGguZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGNvbnRyYWN0LnRyYW5zYWN0aW9uSGFzaCwgZnVuY3Rpb24oZSwgcmVjZWlwdCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlY2VpcHQgJiYgIWNhbGxiYWNrRmlyZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3QuX2V0aC5nZXRDb2RlKHJlY2VpcHQuY29udHJhY3RBZGRyZXNzLCBmdW5jdGlvbihlLCBjb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA2ICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFja0ZpcmVkIHx8ICFjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuc3RvcFdhdGNoaW5nKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29kZS5sZW5ndGggPiAzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgZGVwbG95ZWQhJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3QuYWRkcmVzcyA9IHJlY2VpcHQuY29udHJhY3RBZGRyZXNzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBldmVudHMgYW5kIG1ldGhvZHMgYWdhaW4gYWZ0ZXIgd2UgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGdW5jdGlvbnNUb0NvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRzVG9Db250cmFjdChjb250cmFjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBjYWxsYmFjayBmb3IgdGhlIHNlY29uZCB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY29udHJhY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjb250cmFjdCBjb2RlIGNvdWxkblxcJ3QgYmUgc3RvcmVkLCBwbGVhc2UgY2hlY2sgeW91ciBnYXMgYW1vdW50LicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29udHJhY3QgY29kZSBjb3VsZG5cXCd0IGJlIHN0b3JlZCwgcGxlYXNlIGNoZWNrIHlvdXIgZ2FzIGFtb3VudC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBDb250cmFjdEZhY3RvcnkgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIENvbnRyYWN0RmFjdG9yeVxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKi9cbnZhciBDb250cmFjdEZhY3RvcnkgPSBmdW5jdGlvbiAoZXRoLCBhYmkpIHtcbiAgICB0aGlzLmV0aCA9IGV0aDtcbiAgICB0aGlzLmFiaSA9IGFiaTtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBjb250cmFjdCBvbiBhIGJsb2NrY2hhaW5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV3XG4gICAgICogQHBhcmFtIHtBbnl9IGNvbnRyYWN0IGNvbnN0cnVjdG9yIHBhcmFtMSAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHtBbnl9IGNvbnRyYWN0IGNvbnN0cnVjdG9yIHBhcmFtMiAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRyYWN0IHRyYW5zYWN0aW9uIG9iamVjdCAocmVxdWlyZWQpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7Q29udHJhY3R9IHJldHVybnMgY29udHJhY3QgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNyAqL1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHRoaXMuZXRoLCB0aGlzLmFiaSk7XG5cbiAgICAgICAgLy8gcGFyc2UgYXJndW1lbnRzXG4gICAgICAgIHZhciBvcHRpb25zID0ge307IC8vIHJlcXVpcmVkIVxuICAgICAgICB2YXIgY2FsbGJhY2s7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHV0aWxzLmlzT2JqZWN0KGxhc3QpICYmICF1dGlscy5pc0FycmF5KGxhc3QpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnZhbHVlID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yQWJpID0gYWJpLmZpbHRlcihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicgJiYganNvbi5pbnB1dHMubGVuZ3RoID09PSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgIH0pWzBdIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIWNvbnN0cnVjdG9yQWJpLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtcyh0aGlzLmFiaSwgYXJncyk7XG4gICAgICAgIG9wdGlvbnMuZGF0YSArPSBieXRlcztcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcblxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNvbnRyYWN0IGFkZHJlc3MgYWRuIGNoZWNrIGlmIHRoZSBjb2RlIHdhcyBkZXBsb3llZFxuICAgICAgICAgICAgdGhpcy5ldGguc2VuZFRyYW5zYWN0aW9uKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0LnRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBjYWxsYmFjayBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY29udHJhY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzKGNvbnRyYWN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuZXRoLnNlbmRUcmFuc2FjdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAgICAgY29udHJhY3QudHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcbiAgICAgICAgICAgIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzKGNvbnRyYWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9O1xuXG4gICAgdGhpcy5uZXcuZ2V0RGF0YSA9IHRoaXMuZ2V0RGF0YS5iaW5kKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgQ29udHJhY3RGYWN0b3J5XG4gKlxuICogQG1ldGhvZCBjb250cmFjdFxuICogQHBhcmFtIHtBcnJheX0gYWJpXG4gKiBAcmV0dXJucyB7Q29udHJhY3RGYWN0b3J5fSBuZXcgY29udHJhY3QgZmFjdG9yeVxuICovXG4vL3ZhciBjb250cmFjdCA9IGZ1bmN0aW9uIChhYmkpIHtcbiAgICAvL3JldHVybiBuZXcgQ29udHJhY3RGYWN0b3J5KGFiaSk7XG4vL307XG5cblxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFjY2VzcyB0byBleGlzdGluZyBjb250cmFjdCBvbiBhIGJsb2NrY2hhaW5cbiAqXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0ge0FkZHJlc3N9IGNvbnRyYWN0IGFkZHJlc3MgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sge29wdGlvbmFsKVxuICogQHJldHVybnMge0NvbnRyYWN0fSByZXR1cm5zIGNvbnRyYWN0IGlmIG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQsXG4gKiBvdGhlcndpc2UgY2FsbHMgY2FsbGJhY2sgZnVuY3Rpb24gKGVyciwgY29udHJhY3QpXG4gKi9cbkNvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoYWRkcmVzcywgY2FsbGJhY2spIHtcbiAgICB2YXIgY29udHJhY3QgPSBuZXcgQ29udHJhY3QodGhpcy5ldGgsIHRoaXMuYWJpLCBhZGRyZXNzKTtcblxuICAgIC8vIHRoaXMgZnVuY3Rpb25zIGFyZSBub3QgcGFydCBvZiBwcm90b3R5cGUsXG4gICAgLy8gYmVjYXVzZSB3ZSBkb250IHdhbnQgdG8gc3BvaWwgdGhlIGludGVyZmFjZVxuICAgIGFkZEZ1bmN0aW9uc1RvQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGFkZEV2ZW50c1RvQ29udHJhY3QoY29udHJhY3QpO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRyYWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyYWN0O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhLCB3aGljaCBpcyBkYXRhIHRvIGRlcGxveSBwbHVzIGNvbnN0cnVjdG9yIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZ2V0RGF0YVxuICovXG5Db250cmFjdEZhY3RvcnkucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gcmVxdWlyZWQhXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgdmFyIGxhc3QgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGxhc3QpICYmICF1dGlscy5pc0FycmF5KGxhc3QpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzLnBvcCgpO1xuICAgIH1cblxuICAgIHZhciBieXRlcyA9IGVuY29kZUNvbnN0cnVjdG9yUGFyYW1zKHRoaXMuYWJpLCBhcmdzKTtcbiAgICBvcHRpb25zLmRhdGEgKz0gYnl0ZXM7XG5cbiAgICByZXR1cm4gb3B0aW9ucy5kYXRhO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgY29udHJhY3QgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIENvbnRyYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhYmlcbiAqIEBwYXJhbSB7QWRkcmVzc30gY29udHJhY3QgYWRkcmVzc1xuICovXG52YXIgQ29udHJhY3QgPSBmdW5jdGlvbiAoZXRoLCBhYmksIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9ldGggPSBldGg7XG4gICAgdGhpcy50cmFuc2FjdGlvbkhhc2ggPSBudWxsO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyYWN0RmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2NvbnRyYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9jb250cmFjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgZXJyb3JzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEludmFsaWROdW1iZXJPZlNvbGlkaXR5QXJnczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgdG8gU29saWRpdHkgZnVuY3Rpb24nKTtcbiAgICB9LFxuICAgIEludmFsaWROdW1iZXJPZlJQQ1BhcmFtczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBpbnB1dCBwYXJhbWV0ZXJzIHRvIFJQQyBtZXRob2QnKTtcbiAgICB9LFxuICAgIEludmFsaWRDb25uZWN0aW9uOiBmdW5jdGlvbiAoaG9zdCl7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0NPTk5FQ1RJT04gRVJST1I6IENvdWxkblxcJ3QgY29ubmVjdCB0byBub2RlICcrIGhvc3QgKycuJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkUHJvdmlkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignUHJvdmlkZXIgbm90IHNldCBvciBpbnZhbGlkJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXN1bHQpe1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICEhcmVzdWx0ICYmICEhcmVzdWx0LmVycm9yICYmICEhcmVzdWx0LmVycm9yLm1lc3NhZ2UgPyByZXN1bHQuZXJyb3IubWVzc2FnZSA6ICdJbnZhbGlkIEpTT04gUlBDIHJlc3BvbnNlOiAnICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9LFxuICAgIENvbm5lY3Rpb25UaW1lb3V0OiBmdW5jdGlvbiAobXMpe1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdDT05ORUNUSU9OIFRJTUVPVVQ6IHRpbWVvdXQgb2YgJyArIG1zICsgJyBtcyBhY2hpdmVkJyk7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Vycm9ycy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXJyb3JzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV2ZW50LmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgd2F0Y2hlcyA9IHJlcXVpcmUoJy4vbWV0aG9kcy93YXRjaGVzJyk7XG5cbi8qKlxuICogVGhpcyBwcm90b3R5cGUgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGV2ZW50IGZpbHRlcnNcbiAqL1xudmFyIFNvbGlkaXR5RXZlbnQgPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMuX3BhcmFtcyA9IGpzb24uaW5wdXRzO1xuICAgIHRoaXMuX25hbWUgPSB1dGlscy50cmFuc2Zvcm1Ub0Z1bGxOYW1lKGpzb24pO1xuICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHRoaXMuX2Fub255bW91cyA9IGpzb24uYW5vbnltb3VzO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZmlsdGVyZWQgcGFyYW0gdHlwZXNcbiAqXG4gKiBAbWV0aG9kIHR5cGVzXG4gKiBAcGFyYW0ge0Jvb2x9IGRlY2lkZSBpZiByZXR1cm5lZCB0eXBlZCBzaG91bGQgYmUgaW5kZXhlZFxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHR5cGVzXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLnR5cGVzID0gZnVuY3Rpb24gKGluZGV4ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS5pbmRleGVkID09PSBpbmRleGVkO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZXZlbnQgZGlzcGxheSBuYW1lXG4gKlxuICogQG1ldGhvZCBkaXNwbGF5TmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBldmVudCBkaXNwbGF5IG5hbWVcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuZGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmV4dHJhY3REaXNwbGF5TmFtZSh0aGlzLl9uYW1lKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGV2ZW50IHR5cGUgbmFtZVxuICpcbiAqIEBtZXRob2QgdHlwZU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZXZlbnQgdHlwZSBuYW1lXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5leHRyYWN0VHlwZU5hbWUodGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBldmVudCBzaWduYXR1cmVcbiAqXG4gKiBAbWV0aG9kIHNpZ25hdHVyZVxuICogQHJldHVybiB7U3RyaW5nfSBldmVudCBzaWduYXR1cmVcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuc2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzaGEzKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgaW5kZXhlZCBwYXJhbXMgYW5kIG9wdGlvbnMgdG8gb25lIGZpbmFsIG9iamVjdFxuICpcbiAqIEBtZXRob2QgZW5jb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5kZXhlZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gZXZlcnl0aGluZyBjb21iaW5lZCB0b2dldGhlciBhbmQgZW5jb2RlZFxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoaW5kZXhlZCwgb3B0aW9ucykge1xuICAgIGluZGV4ZWQgPSBpbmRleGVkIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIFsnZnJvbUJsb2NrJywgJ3RvQmxvY2snXS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbZl0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJlc3VsdFtmXSA9IGZvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihvcHRpb25zW2ZdKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC50b3BpY3MgPSBbXTtcblxuICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fYWRkcmVzcztcbiAgICBpZiAoIXRoaXMuX2Fub255bW91cykge1xuICAgICAgICByZXN1bHQudG9waWNzLnB1c2goJzB4JyArIHRoaXMuc2lnbmF0dXJlKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleGVkVG9waWNzID0gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS5pbmRleGVkID09PSB0cnVlO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleGVkW2kubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMHgnICsgY29kZXIuZW5jb2RlUGFyYW0oaS50eXBlLCB2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnMHgnICsgY29kZXIuZW5jb2RlUGFyYW0oaS50eXBlLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQudG9waWNzID0gcmVzdWx0LnRvcGljcy5jb25jYXQoaW5kZXhlZFRvcGljcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgaW5kZXhlZCBwYXJhbXMgYW5kIG9wdGlvbnNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0IG9iamVjdCB3aXRoIGRlY29kZWQgaW5kZXhlZCAmJiBub3QgaW5kZXhlZCBwYXJhbXNcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCAnJztcbiAgICBkYXRhLnRvcGljcyA9IGRhdGEudG9waWNzIHx8IFtdO1xuXG4gICAgdmFyIGFyZ1RvcGljcyA9IHRoaXMuX2Fub255bW91cyA/IGRhdGEudG9waWNzIDogZGF0YS50b3BpY3Muc2xpY2UoMSk7XG4gICAgdmFyIGluZGV4ZWREYXRhID0gYXJnVG9waWNzLm1hcChmdW5jdGlvbiAodG9waWNzKSB7IHJldHVybiB0b3BpY3Muc2xpY2UoMik7IH0pLmpvaW4oXCJcIik7XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBjb2Rlci5kZWNvZGVQYXJhbXModGhpcy50eXBlcyh0cnVlKSwgaW5kZXhlZERhdGEpO1xuXG4gICAgdmFyIG5vdEluZGV4ZWREYXRhID0gZGF0YS5kYXRhLnNsaWNlKDIpO1xuICAgIHZhciBub3RJbmRleGVkUGFyYW1zID0gY29kZXIuZGVjb2RlUGFyYW1zKHRoaXMudHlwZXMoZmFsc2UpLCBub3RJbmRleGVkRGF0YSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIoZGF0YSk7XG4gICAgcmVzdWx0LmV2ZW50ID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIHJlc3VsdC5hZGRyZXNzID0gZGF0YS5hZGRyZXNzO1xuXG4gICAgcmVzdWx0LmFyZ3MgPSB0aGlzLl9wYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnJlbnQpIHtcbiAgICAgICAgYWNjW2N1cnJlbnQubmFtZV0gPSBjdXJyZW50LmluZGV4ZWQgPyBpbmRleGVkUGFyYW1zLnNoaWZ0KCkgOiBub3RJbmRleGVkUGFyYW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgZGVsZXRlIHJlc3VsdC5kYXRhO1xuICAgIGRlbGV0ZSByZXN1bHQudG9waWNzO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIG5ldyBmaWx0ZXIgb2JqZWN0IGZyb20gZXZlbnRcbiAqXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmRleGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSBmaWx0ZXIgb2JqZWN0XG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoaW5kZXhlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIGluZGV4ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUoaW5kZXhlZCwgb3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIobywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXIsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gYXR0YWNoIGV2ZW50IHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH1cbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIGlmICghY29udHJhY3RbZGlzcGxheU5hbWVdKSB7XG4gICAgICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXSA9IGV4ZWN1dGU7XG4gICAgfVxuICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXVt0aGlzLnR5cGVOYW1lKCldID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcywgY29udHJhY3QpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eUV2ZW50O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZXZlbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBNZXRob2QgPSByZXF1aXJlKCcuL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vLyBUT0RPOiByZWZhY3Rvciwgc28gdGhlIGlucHV0IHBhcmFtcyBhcmUgbm90IGFsdGVyZWQuXG4vLyBpdCdzIG5lY2Vzc2FyeSB0byBtYWtlIHNhbWUgJ2V4dGVuc2lvbicgd29yayB3aXRoIG11bHRpcGxlIHByb3ZpZGVyc1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uICh3ZWIzKSB7XG4gICAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6NSAqL1xuICAgIHZhciBleCA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcblxuICAgICAgICB2YXIgZXh0ZW5kZWRPYmplY3Q7XG4gICAgICAgIGlmIChleHRlbnNpb24ucHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmICghd2ViM1tleHRlbnNpb24ucHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgd2ViM1tleHRlbnNpb24ucHJvcGVydHldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbmRlZE9iamVjdCA9IHdlYjNbZXh0ZW5zaW9uLnByb3BlcnR5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuZGVkT2JqZWN0ID0gd2ViMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb24ubWV0aG9kcykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KGV4dGVuZGVkT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0ZW5zaW9uLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbi5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkuYXR0YWNoVG9PYmplY3QoZXh0ZW5kZWRPYmplY3QpO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnNldFJlcXVlc3RNYW5hZ2VyKHdlYjMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGV4LmZvcm1hdHRlcnMgPSBmb3JtYXR0ZXJzOyBcbiAgICBleC51dGlscyA9IHV0aWxzO1xuICAgIGV4Lk1ldGhvZCA9IE1ldGhvZDtcbiAgICBleC5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xuXG4gICAgcmV0dXJuIGV4O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9leHRlbmQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2V4dGVuZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGZpbHRlci5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEplZmZyZXkgV2lsY2tlIDxqZWZmQGV0aGRldi5jb20+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBNYXJpYW4gT2FuY2VhIDxtYXJpYW5AZXRoZGV2LmNvbT5cbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiAgIEdhdiBXb29kIDxnQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbi8qKlxuKiBDb252ZXJ0cyBhIGdpdmVuIHRvcGljIHRvIGEgaGV4IHN0cmluZywgYnV0IGFsc28gYWxsb3dzIG51bGwgdmFsdWVzLlxuKlxuKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuKiBAcmV0dXJuIHtTdHJpbmd9XG4qL1xudmFyIHRvVG9waWMgPSBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICBpZih2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblxuICAgIGlmKHZhbHVlLmluZGV4T2YoJzB4JykgPT09IDApXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB1dGlscy5mcm9tVXRmOCh2YWx1ZSk7XG59O1xuXG4vLy8gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbiBvcHRpb25zIG9iamVjdCwgdG8gdmVyaWZ5IGRlcHJlY2F0ZWQgcHJvcGVydGllcyAmJiBsYXp5IGxvYWQgZHluYW1pYyBvbmVzXG4vLy8gQHBhcmFtIHNob3VsZCBiZSBzdHJpbmcgb3Igb2JqZWN0XG4vLy8gQHJldHVybnMgb3B0aW9ucyBzdHJpbmcgb3Igb2JqZWN0XG52YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zLCB0eXBlKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuXG4gICAgaWYgKHV0aWxzLmlzU3RyaW5nKG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlICdldGgnOlxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG9waWNzLCBnZXQgY29udmVydGVkIHRvIGhleFxuICAgICAgICAgICAgb3B0aW9ucy50b3BpY3MgPSBvcHRpb25zLnRvcGljcyB8fCBbXTtcbiAgICAgICAgICAgIG9wdGlvbnMudG9waWNzID0gb3B0aW9ucy50b3BpY3MubWFwKGZ1bmN0aW9uKHRvcGljKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHV0aWxzLmlzQXJyYXkodG9waWMpKSA/IHRvcGljLm1hcCh0b1RvcGljKSA6IHRvVG9waWModG9waWMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9waWNzOiBvcHRpb25zLnRvcGljcyxcbiAgICAgICAgICAgICAgICBmcm9tOiBvcHRpb25zLmZyb20sXG4gICAgICAgICAgICAgICAgdG86IG9wdGlvbnMudG8sXG4gICAgICAgICAgICAgICAgYWRkcmVzczogb3B0aW9ucy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZyb21CbG9jazogZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKG9wdGlvbnMuZnJvbUJsb2NrKSxcbiAgICAgICAgICAgICAgICB0b0Jsb2NrOiBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9ucy50b0Jsb2NrKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnc2hoJzpcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbn07XG5cbi8qKlxuQWRkcyB0aGUgY2FsbGJhY2sgYW5kIHNldHMgdXAgdGhlIG1ldGhvZHMsIHRvIGl0ZXJhdGUgb3ZlciB0aGUgcmVzdWx0cy5cblxuQG1ldGhvZCBnZXRMb2dzQXRTdGFydFxuQHBhcmFtIHtPYmplY3R9IHNlbGZcbkBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4qL1xudmFyIGdldExvZ3NBdFN0YXJ0ID0gZnVuY3Rpb24oc2VsZiwgY2FsbGJhY2spe1xuICAgIC8vIGNhbGwgZ2V0RmlsdGVyTG9ncyBmb3IgdGhlIGZpcnN0IHdhdGNoIGNhbGxiYWNrIHN0YXJ0XG4gICAgaWYgKCF1dGlscy5pc1N0cmluZyhzZWxmLm9wdGlvbnMpKSB7XG4gICAgICAgIHNlbGYuZ2V0KGZ1bmN0aW9uIChlcnIsIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBzZW5kIGFsbCB0aGUgcmVzcG9uc2VzIHRvIGFsbCB0aGUgd2F0Y2hlcyBhZ2Fpbi4uLiBqdXN0IHRvIHNlbGYgb25lXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodXRpbHMuaXNBcnJheShtZXNzYWdlcykpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbkFkZHMgdGhlIGNhbGxiYWNrIGFuZCBzZXRzIHVwIHRoZSBtZXRob2RzLCB0byBpdGVyYXRlIG92ZXIgdGhlIHJlc3VsdHMuXG5cbkBtZXRob2QgcG9sbEZpbHRlclxuQHBhcmFtIHtPYmplY3R9IHNlbGZcbiovXG52YXIgcG9sbEZpbHRlciA9IGZ1bmN0aW9uKHNlbGYpIHtcblxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyb3IsIG1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih1dGlscy5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzZWxmLmZvcm1hdHRlciA/IHNlbGYuZm9ybWF0dGVyKG1lc3NhZ2UpIDogbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYucmVxdWVzdE1hbmFnZXIuc3RhcnRQb2xsaW5nKHtcbiAgICAgICAgbWV0aG9kOiBzZWxmLmltcGxlbWVudGF0aW9uLnBvbGwuY2FsbCxcbiAgICAgICAgcGFyYW1zOiBbc2VsZi5maWx0ZXJJZF0sXG4gICAgfSwgc2VsZi5maWx0ZXJJZCwgb25NZXNzYWdlLCBzZWxmLnN0b3BXYXRjaGluZy5iaW5kKHNlbGYpKTtcblxufTtcblxudmFyIEZpbHRlciA9IGZ1bmN0aW9uIChvcHRpb25zLCB0eXBlLCByZXF1ZXN0TWFuYWdlciwgbWV0aG9kcywgZm9ybWF0dGVyLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IHt9O1xuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihyZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChpbXBsZW1lbnRhdGlvbik7XG4gICAgfSk7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMub3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucywgdHlwZSk7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbiA9IGltcGxlbWVudGF0aW9uO1xuICAgIHRoaXMuZmlsdGVySWQgPSBudWxsO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5nZXRMb2dzQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5wb2xsRmlsdGVycyA9IFtdO1xuICAgIHRoaXMuZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb24ubmV3RmlsdGVyKHRoaXMub3B0aW9ucywgZnVuY3Rpb24oZXJyb3IsIGlkKXtcbiAgICAgICAgaWYoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oY2Ipe1xuICAgICAgICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZmlsdGVySWQgPSBpZDtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGdldCBwZW5kaW5nIGNhbGxiYWNrcyBhcyBhIGNvbnNlcXVlbmNlXG4gICAgICAgICAgICAvLyBvZiBjYWxsaW5nIGdldCgpIHdpdGggZmlsdGVySWQgdW5hc3NpZ25lZC5cbiAgICAgICAgICAgIHNlbGYuZ2V0TG9nc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYil7XG4gICAgICAgICAgICAgICAgc2VsZi5nZXQoY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmdldExvZ3NDYWxsYmFja3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gZ2V0IGZpbHRlciBsb2dzIGZvciB0aGUgYWxyZWFkeSBleGlzdGluZyB3YXRjaCBjYWxsc1xuICAgICAgICAgICAgc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYil7XG4gICAgICAgICAgICAgICAgZ2V0TG9nc0F0U3RhcnQoc2VsZiwgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZihzZWxmLmNhbGxiYWNrcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHBvbGxGaWx0ZXIoc2VsZik7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRvIHdhdGNoIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi53YXRjaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG4gICAgaWYodGhpcy5maWx0ZXJJZCkge1xuICAgICAgICBnZXRMb2dzQXRTdGFydCh0aGlzLCBjYWxsYmFjayk7XG4gICAgICAgIHBvbGxGaWx0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnN0b3BXYXRjaGluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIuc3RvcFBvbGxpbmcodGhpcy5maWx0ZXJJZCk7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICAvLyByZW1vdmUgZmlsdGVyIGFzeW5jXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24udW5pbnN0YWxsRmlsdGVyKHRoaXMuZmlsdGVySWQsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBsZW1lbnRhdGlvbi51bmluc3RhbGxGaWx0ZXIodGhpcy5maWx0ZXJJZCk7XG4gICAgfVxufTtcblxuRmlsdGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBmaWx0ZXJJZCBpcyBub3Qgc2V0IHlldCwgY2FsbCBpdCBiYWNrXG4gICAgICAgICAgICAvLyB3aGVuIG5ld0ZpbHRlcigpIGFzc2lnbnMgaXQuXG4gICAgICAgICAgICB0aGlzLmdldExvZ3NDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCwgZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMubWFwKGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdHRlciA/IHNlbGYuZm9ybWF0dGVyKGxvZykgOiBsb2c7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlciBJRCBFcnJvcjogZmlsdGVyKCkuZ2V0KCkgY2FuXFwndCBiZSBjaGFpbmVkIHN5bmNocm9ub3VzLCBwbGVhc2UgcHJvdmlkZSBhIGNhbGxiYWNrIGZvciB0aGUgZ2V0KCkgbWV0aG9kLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2dzID0gdGhpcy5pbXBsZW1lbnRhdGlvbi5nZXRMb2dzKHRoaXMuZmlsdGVySWQpO1xuICAgICAgICByZXR1cm4gbG9ncy5tYXAoZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobG9nKSA6IGxvZztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9maWx0ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGZvcm1hdHRlcnMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgSWJhbiA9IHJlcXVpcmUoJy4vaWJhbicpO1xuXG4vKipcbiAqIFNob3VsZCB0aGUgZm9ybWF0IG91dHB1dCB0byBhIGJpZyBudW1iZXJcbiAqXG4gKiBAbWV0aG9kIG91dHB1dEJpZ051bWJlckZvcm1hdHRlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IG9iamVjdFxuICovXG52YXIgb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHJldHVybiB1dGlscy50b0JpZ051bWJlcihudW1iZXIpO1xufTtcblxudmFyIGlzUHJlZGVmaW5lZEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgcmV0dXJuIGJsb2NrTnVtYmVyID09PSAnbGF0ZXN0JyB8fCBibG9ja051bWJlciA9PT0gJ3BlbmRpbmcnIHx8IGJsb2NrTnVtYmVyID09PSAnZWFybGllc3QnO1xufTtcblxudmFyIGlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgaWYgKGJsb2NrTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5kZWZhdWx0QmxvY2s7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKGJsb2NrTnVtYmVyKTtcbn07XG5cbnZhciBpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgaWYgKGJsb2NrTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGlzUHJlZGVmaW5lZEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy50b0hleChibG9ja051bWJlcik7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIGlucHV0IG9mIGEgdHJhbnNhY3Rpb24gYW5kIGNvbnZlcnRzIGFsbCB2YWx1ZXMgdG8gSEVYXG4gKlxuICogQG1ldGhvZCBpbnB1dENhbGxGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBvYmplY3RcbiovXG52YXIgaW5wdXRDYWxsRm9ybWF0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpe1xuXG4gICAgb3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tIHx8IGNvbmZpZy5kZWZhdWx0QWNjb3VudDtcblxuICAgIGlmIChvcHRpb25zLmZyb20pIHtcbiAgICAgICAgb3B0aW9ucy5mcm9tID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudG8pIHsgLy8gaXQgbWlnaHQgYmUgY29udHJhY3QgY3JlYXRpb25cbiAgICAgICAgb3B0aW9ucy50byA9IGlucHV0QWRkcmVzc0Zvcm1hdHRlcihvcHRpb25zLnRvKTtcbiAgICB9XG5cbiAgICBbJ2dhc1ByaWNlJywgJ2dhcycsICd2YWx1ZScsICdub25jZSddLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHV0aWxzLmZyb21EZWNpbWFsKG9wdGlvbnNba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB0cmFuc2FjdGlvbiBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBvYmplY3RcbiovXG52YXIgaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlciA9IGZ1bmN0aW9uIChvcHRpb25zKXtcblxuICAgIG9wdGlvbnMuZnJvbSA9IG9wdGlvbnMuZnJvbSB8fCBjb25maWcuZGVmYXVsdEFjY291bnQ7XG4gICAgb3B0aW9ucy5mcm9tID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMuZnJvbSk7XG5cbiAgICBpZiAob3B0aW9ucy50bykgeyAvLyBpdCBtaWdodCBiZSBjb250cmFjdCBjcmVhdGlvblxuICAgICAgICBvcHRpb25zLnRvID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMudG8pO1xuICAgIH1cblxuICAgIFsnZ2FzUHJpY2UnLCAnZ2FzJywgJ3ZhbHVlJywgJ25vbmNlJ10uZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgb3B0aW9uc1trZXldID0gdXRpbHMuZnJvbURlY2ltYWwob3B0aW9uc1trZXldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSB0cmFuc2FjdGlvbiB0byBpdHMgcHJvcGVyIHZhbHVlc1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFxuICogQHJldHVybnMge09iamVjdH1cbiovXG52YXIgb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIgPSBmdW5jdGlvbiAodHgpe1xuICAgIGlmKHR4LmJsb2NrTnVtYmVyICE9PSBudWxsKVxuICAgICAgICB0eC5ibG9ja051bWJlciA9IHV0aWxzLnRvRGVjaW1hbCh0eC5ibG9ja051bWJlcik7XG4gICAgaWYodHgudHJhbnNhY3Rpb25JbmRleCAhPT0gbnVsbClcbiAgICAgICAgdHgudHJhbnNhY3Rpb25JbmRleCA9IHV0aWxzLnRvRGVjaW1hbCh0eC50cmFuc2FjdGlvbkluZGV4KTtcbiAgICB0eC5ub25jZSA9IHV0aWxzLnRvRGVjaW1hbCh0eC5ub25jZSk7XG4gICAgdHguZ2FzID0gdXRpbHMudG9EZWNpbWFsKHR4Lmdhcyk7XG4gICAgdHguZ2FzUHJpY2UgPSB1dGlscy50b0JpZ051bWJlcih0eC5nYXNQcmljZSk7XG4gICAgdHgudmFsdWUgPSB1dGlscy50b0JpZ051bWJlcih0eC52YWx1ZSk7XG4gICAgcmV0dXJuIHR4O1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSB0cmFuc2FjdGlvbiByZWNlaXB0IHRvIGl0cyBwcm9wZXIgdmFsdWVzXG4gKlxuICogQG1ldGhvZCBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNlaXB0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbnZhciBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXIgPSBmdW5jdGlvbiAocmVjZWlwdCl7XG4gICAgaWYocmVjZWlwdC5ibG9ja051bWJlciAhPT0gbnVsbClcbiAgICAgICAgcmVjZWlwdC5ibG9ja051bWJlciA9IHV0aWxzLnRvRGVjaW1hbChyZWNlaXB0LmJsb2NrTnVtYmVyKTtcbiAgICBpZihyZWNlaXB0LnRyYW5zYWN0aW9uSW5kZXggIT09IG51bGwpXG4gICAgICAgIHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCA9IHV0aWxzLnRvRGVjaW1hbChyZWNlaXB0LnRyYW5zYWN0aW9uSW5kZXgpO1xuICAgIHJlY2VpcHQuY3VtdWxhdGl2ZUdhc1VzZWQgPSB1dGlscy50b0RlY2ltYWwocmVjZWlwdC5jdW11bGF0aXZlR2FzVXNlZCk7XG4gICAgcmVjZWlwdC5nYXNVc2VkID0gdXRpbHMudG9EZWNpbWFsKHJlY2VpcHQuZ2FzVXNlZCk7XG5cbiAgICBpZih1dGlscy5pc0FycmF5KHJlY2VpcHQubG9ncykpIHtcbiAgICAgICAgcmVjZWlwdC5sb2dzID0gcmVjZWlwdC5sb2dzLm1hcChmdW5jdGlvbihsb2cpe1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExvZ0Zvcm1hdHRlcihsb2cpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWlwdDtcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgYmxvY2sgdG8gaXRzIHByb3BlciB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kIG91dHB1dEJsb2NrRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gYmxvY2tcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4qL1xudmFyIG91dHB1dEJsb2NrRm9ybWF0dGVyID0gZnVuY3Rpb24oYmxvY2spIHtcblxuICAgIC8vIHRyYW5zZm9ybSB0byBudW1iZXJcbiAgICBibG9jay5nYXNMaW1pdCA9IHV0aWxzLnRvRGVjaW1hbChibG9jay5nYXNMaW1pdCk7XG4gICAgYmxvY2suZ2FzVXNlZCA9IHV0aWxzLnRvRGVjaW1hbChibG9jay5nYXNVc2VkKTtcbiAgICBibG9jay5zaXplID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLnNpemUpO1xuICAgIGJsb2NrLnRpbWVzdGFtcCA9IHV0aWxzLnRvRGVjaW1hbChibG9jay50aW1lc3RhbXApO1xuICAgIGlmKGJsb2NrLm51bWJlciAhPT0gbnVsbClcbiAgICAgICAgYmxvY2subnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLm51bWJlcik7XG5cbiAgICBibG9jay5kaWZmaWN1bHR5ID0gdXRpbHMudG9CaWdOdW1iZXIoYmxvY2suZGlmZmljdWx0eSk7XG4gICAgYmxvY2sudG90YWxEaWZmaWN1bHR5ID0gdXRpbHMudG9CaWdOdW1iZXIoYmxvY2sudG90YWxEaWZmaWN1bHR5KTtcblxuICAgIGlmICh1dGlscy5pc0FycmF5KGJsb2NrLnRyYW5zYWN0aW9ucykpIHtcbiAgICAgICAgYmxvY2sudHJhbnNhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICBpZighdXRpbHMuaXNTdHJpbmcoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIGxvZ1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0TG9nRm9ybWF0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbG9nIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gbG9nXG4qL1xudmFyIG91dHB1dExvZ0Zvcm1hdHRlciA9IGZ1bmN0aW9uKGxvZykge1xuICAgIGlmKGxvZy5ibG9ja051bWJlcilcbiAgICAgICAgbG9nLmJsb2NrTnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKGxvZy5ibG9ja051bWJlcik7XG4gICAgaWYobG9nLnRyYW5zYWN0aW9uSW5kZXgpXG4gICAgICAgIGxvZy50cmFuc2FjdGlvbkluZGV4ID0gdXRpbHMudG9EZWNpbWFsKGxvZy50cmFuc2FjdGlvbkluZGV4KTtcbiAgICBpZihsb2cubG9nSW5kZXgpXG4gICAgICAgIGxvZy5sb2dJbmRleCA9IHV0aWxzLnRvRGVjaW1hbChsb2cubG9nSW5kZXgpO1xuXG4gICAgcmV0dXJuIGxvZztcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB3aGlzcGVyIHBvc3QgYW5kIGNvbnZlcnRzIGFsbCB2YWx1ZXMgdG8gSEVYXG4gKlxuICogQG1ldGhvZCBpbnB1dFBvc3RGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4qL1xudmFyIGlucHV0UG9zdEZvcm1hdHRlciA9IGZ1bmN0aW9uKHBvc3QpIHtcblxuICAgIC8vIHBvc3QucGF5bG9hZCA9IHV0aWxzLnRvSGV4KHBvc3QucGF5bG9hZCk7XG4gICAgcG9zdC50dGwgPSB1dGlscy5mcm9tRGVjaW1hbChwb3N0LnR0bCk7XG4gICAgcG9zdC53b3JrVG9Qcm92ZSA9IHV0aWxzLmZyb21EZWNpbWFsKHBvc3Qud29ya1RvUHJvdmUpO1xuICAgIHBvc3QucHJpb3JpdHkgPSB1dGlscy5mcm9tRGVjaW1hbChwb3N0LnByaW9yaXR5KTtcblxuICAgIC8vIGZhbGxiYWNrXG4gICAgaWYgKCF1dGlscy5pc0FycmF5KHBvc3QudG9waWNzKSkge1xuICAgICAgICBwb3N0LnRvcGljcyA9IHBvc3QudG9waWNzID8gW3Bvc3QudG9waWNzXSA6IFtdO1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCB0aGUgZm9sbG93aW5nIG9wdGlvbnNcbiAgICBwb3N0LnRvcGljcyA9IHBvc3QudG9waWNzLm1hcChmdW5jdGlvbih0b3BpYyl7XG4gICAgICAgIC8vIGNvbnZlcnQgb25seSBpZiBub3QgaGV4XG4gICAgICAgIHJldHVybiAodG9waWMuaW5kZXhPZignMHgnKSA9PT0gMCkgPyB0b3BpYyA6IHV0aWxzLmZyb21VdGY4KHRvcGljKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwb3N0O1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSByZWNlaXZlZCBwb3N0IG1lc3NhZ2VcbiAqXG4gKiBAbWV0aG9kIG91dHB1dFBvc3RGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xudmFyIG91dHB1dFBvc3RGb3JtYXR0ZXIgPSBmdW5jdGlvbihwb3N0KXtcblxuICAgIHBvc3QuZXhwaXJ5ID0gdXRpbHMudG9EZWNpbWFsKHBvc3QuZXhwaXJ5KTtcbiAgICBwb3N0LnNlbnQgPSB1dGlscy50b0RlY2ltYWwocG9zdC5zZW50KTtcbiAgICBwb3N0LnR0bCA9IHV0aWxzLnRvRGVjaW1hbChwb3N0LnR0bCk7XG4gICAgcG9zdC53b3JrUHJvdmVkID0gdXRpbHMudG9EZWNpbWFsKHBvc3Qud29ya1Byb3ZlZCk7XG4gICAgLy8gcG9zdC5wYXlsb2FkUmF3ID0gcG9zdC5wYXlsb2FkO1xuICAgIC8vIHBvc3QucGF5bG9hZCA9IHV0aWxzLnRvQXNjaWkocG9zdC5wYXlsb2FkKTtcblxuICAgIC8vIGlmICh1dGlscy5pc0pzb24ocG9zdC5wYXlsb2FkKSkge1xuICAgIC8vICAgICBwb3N0LnBheWxvYWQgPSBKU09OLnBhcnNlKHBvc3QucGF5bG9hZCk7XG4gICAgLy8gfVxuXG4gICAgLy8gZm9ybWF0IHRoZSBmb2xsb3dpbmcgb3B0aW9uc1xuICAgIGlmICghcG9zdC50b3BpY3MpIHtcbiAgICAgICAgcG9zdC50b3BpY3MgPSBbXTtcbiAgICB9XG4gICAgcG9zdC50b3BpY3MgPSBwb3N0LnRvcGljcy5tYXAoZnVuY3Rpb24odG9waWMpe1xuICAgICAgICByZXR1cm4gdXRpbHMudG9Bc2NpaSh0b3BpYyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcG9zdDtcbn07XG5cbnZhciBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHZhciBpYmFuID0gbmV3IEliYW4oYWRkcmVzcyk7XG4gICAgaWYgKGliYW4uaXNWYWxpZCgpICYmIGliYW4uaXNEaXJlY3QoKSkge1xuICAgICAgICByZXR1cm4gJzB4JyArIGliYW4uYWRkcmVzcygpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNTdHJpY3RBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgYWRkcmVzcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHJlc3MnKTtcbn07XG5cblxudmFyIG91dHB1dFN5bmNpbmdGb3JtYXR0ZXIgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5zdGFydGluZ0Jsb2NrID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5zdGFydGluZ0Jsb2NrKTtcbiAgICByZXN1bHQuY3VycmVudEJsb2NrID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5jdXJyZW50QmxvY2spO1xuICAgIHJlc3VsdC5oaWdoZXN0QmxvY2sgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0LmhpZ2hlc3RCbG9jayk7XG4gICAgaWYgKHJlc3VsdC5rbm93blN0YXRlcykge1xuICAgICAgICByZXN1bHQua25vd25TdGF0ZXMgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0Lmtub3duU3RhdGVzKTtcbiAgICAgICAgcmVzdWx0LnB1bGxlZFN0YXRlcyA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQucHVsbGVkU3RhdGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXI6IGlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyLFxuICAgIGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXI6IGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsXG4gICAgaW5wdXRDYWxsRm9ybWF0dGVyOiBpbnB1dENhbGxGb3JtYXR0ZXIsXG4gICAgaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcjogaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcixcbiAgICBpbnB1dEFkZHJlc3NGb3JtYXR0ZXI6IGlucHV0QWRkcmVzc0Zvcm1hdHRlcixcbiAgICBpbnB1dFBvc3RGb3JtYXR0ZXI6IGlucHV0UG9zdEZvcm1hdHRlcixcbiAgICBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXI6IG91dHB1dEJpZ051bWJlckZvcm1hdHRlcixcbiAgICBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcjogb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIsXG4gICAgb3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyOiBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXIsXG4gICAgb3V0cHV0QmxvY2tGb3JtYXR0ZXI6IG91dHB1dEJsb2NrRm9ybWF0dGVyLFxuICAgIG91dHB1dExvZ0Zvcm1hdHRlcjogb3V0cHV0TG9nRm9ybWF0dGVyLFxuICAgIG91dHB1dFBvc3RGb3JtYXR0ZXI6IG91dHB1dFBvc3RGb3JtYXR0ZXIsXG4gICAgb3V0cHV0U3luY2luZ0Zvcm1hdHRlcjogb3V0cHV0U3luY2luZ0Zvcm1hdHRlclxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZm9ybWF0dGVycy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvZm9ybWF0dGVycy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmdW5jdGlvbi5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNhbGwvc2VuZFRyYW5zYWN0aW9uIHRvIHNvbGlkaXR5IGZ1bmN0aW9uc1xuICovXG52YXIgU29saWRpdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIChldGgsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9ldGggPSBldGg7XG4gICAgdGhpcy5faW5wdXRUeXBlcyA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX291dHB1dFR5cGVzID0ganNvbi5vdXRwdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX2NvbnN0YW50ID0ganNvbi5jb25zdGFudDtcbiAgICB0aGlzLl9wYXlhYmxlID0ganNvbi5wYXlhYmxlO1xuICAgIHRoaXMuX25hbWUgPSB1dGlscy50cmFuc2Zvcm1Ub0Z1bGxOYW1lKGpzb24pO1xuICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xufTtcblxuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcblxuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZXh0cmFjdERlZmF1bHRCbG9jayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gdGhpcy5faW5wdXRUeXBlcy5sZW5ndGggJiYgIXV0aWxzLmlzT2JqZWN0KGFyZ3NbYXJncy5sZW5ndGggLTFdKSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcihhcmdzLnBvcCgpKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBjb3JyZWN0XG4gKlxuICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIG5vdFxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS52YWxpZGF0ZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBpbnB1dEFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgLy8gZmlsdGVyIHRoZSBvcHRpb25zIG9iamVjdCBidXQgbm90IGFyZ3VtZW50cyB0aGF0IGFyZSBhcnJheXNcbiAgICAgIHJldHVybiAhKCAodXRpbHMuaXNPYmplY3QoYSkgPT09IHRydWUpICYmXG4gICAgICAgICAgICAgICAgKHV0aWxzLmlzQXJyYXkoYSkgPT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICAgICh1dGlscy5pc0JpZ051bWJlcihhKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKGlucHV0QXJncy5sZW5ndGggIT09IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3MoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBwYXlsb2FkIGZyb20gYXJndW1lbnRzXG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IHNvbGlkaXR5IGZ1bmN0aW9uIHBhcmFtc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbmFsIHBheWxvYWQgb3B0aW9uc1xuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS50b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gdGhpcy5faW5wdXRUeXBlcy5sZW5ndGggJiYgdXRpbHMuaXNPYmplY3QoYXJnc1thcmdzLmxlbmd0aCAtMV0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVBcmdzKGFyZ3MpO1xuICAgIG9wdGlvbnMudG8gPSB0aGlzLl9hZGRyZXNzO1xuICAgIG9wdGlvbnMuZGF0YSA9ICcweCcgKyB0aGlzLnNpZ25hdHVyZSgpICsgY29kZXIuZW5jb2RlUGFyYW1zKHRoaXMuX2lucHV0VHlwZXMsIGFyZ3MpO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKlxuICogQG1ldGhvZCBzaWduYXR1cmVcbiAqIEByZXR1cm4ge1N0cmluZ30gZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnNpZ25hdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2hhMyh0aGlzLl9uYW1lKS5zbGljZSgwLCA4KTtcbn07XG5cblxuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudW5wYWNrT3V0cHV0ID0gZnVuY3Rpb24gKG91dHB1dCkge1xuICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvdXRwdXQgPSBvdXRwdXQubGVuZ3RoID49IDIgPyBvdXRwdXQuc2xpY2UoMikgOiBvdXRwdXQ7XG4gICAgdmFyIHJlc3VsdCA9IGNvZGVyLmRlY29kZVBhcmFtcyh0aGlzLl9vdXRwdXRUeXBlcywgb3V0cHV0KTtcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBjb250cmFjdCBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGNhbGxcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBDb250cmFjdCBmdW5jdGlvbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IElmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIHRoZSBjb250cmFjdCBmdW5jdGlvblxuICogICBjYWxsIHdpbGwgYmUgYXN5bmNocm9ub3VzLCBhbmQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgcGFzc2VkIHRoZVxuICogICBlcnJvciBhbmQgcmVzdWx0LlxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXQgYnl0ZXNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChhKSB7cmV0dXJuIGEgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIGRlZmF1bHRCbG9jayA9IHRoaXMuZXh0cmFjdERlZmF1bHRCbG9jayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9ldGguY2FsbChwYXlsb2FkLCBkZWZhdWx0QmxvY2spO1xuICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tPdXRwdXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fZXRoLmNhbGwocGF5bG9hZCwgZGVmYXVsdEJsb2NrLCBmdW5jdGlvbiAoZXJyb3IsIG91dHB1dCkge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG5cbiAgICAgICAgdmFyIHVucGFja2VkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVucGFja2VkID0gc2VsZi51bnBhY2tPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHVucGFja2VkKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc2VuZFRyYW5zYWN0aW9uIHRvIHNvbGlkaXR5IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBzZW5kVHJhbnNhY3Rpb25cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtyZXR1cm4gYSAhPT0gdW5kZWZpbmVkOyB9KTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgaWYgKHBheWxvYWQudmFsdWUgPiAwICYmICF0aGlzLl9wYXlhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2V0aC5zZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlc3RpbWF0ZUdhcyBvZiBzb2xpZGl0eSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgZXN0aW1hdGVHYXNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZXN0aW1hdGVHYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy50b1BheWxvYWQoYXJncyk7XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGguZXN0aW1hdGVHYXMocGF5bG9hZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXRoLmVzdGltYXRlR2FzKHBheWxvYWQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBlbmNvZGVkIGRhdGEgb2YgdGhlIGNhbGxcbiAqXG4gKiBAbWV0aG9kIGdldERhdGFcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGVuY29kZWQgZGF0YVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZ1bmN0aW9uIGRpc3BsYXkgbmFtZVxuICpcbiAqIEBtZXRob2QgZGlzcGxheU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZGlzcGxheSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZnVuY3Rpb24gdHlwZSBuYW1lXG4gKlxuICogQG1ldGhvZCB0eXBlTmFtZVxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5leHRyYWN0VHlwZU5hbWUodGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHJwYyByZXF1ZXN0cyBmcm9tIHNvbGlkaXR5IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnVucGFja091dHB1dC5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLl9jb25zdGFudCA/ICdldGhfY2FsbCcgOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcGFyYW1zOiBbcGF5bG9hZF0sXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgfTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBleGVjdXRlIGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBleGVjdXRlXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uID0gIXRoaXMuX2NvbnN0YW50O1xuXG4gICAgLy8gc2VuZCB0cmFuc2FjdGlvblxuICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgLy8gY2FsbFxuICAgIHJldHVybiB0aGlzLmNhbGwuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gYXR0YWNoIGZ1bmN0aW9uIHRvIGNvbnRyYWN0XG4gKlxuICogQG1ldGhvZCBhdHRhY2hUb0NvbnRyYWN0XG4gKiBAcGFyYW0ge0NvbnRyYWN0fVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV4ZWN1dGUgPSB0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmNhbGwgPSB0aGlzLmNhbGwuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLnNlbmRUcmFuc2FjdGlvbiA9IHRoaXMuc2VuZFRyYW5zYWN0aW9uLmJpbmQodGhpcyk7XG4gICAgZXhlY3V0ZS5lc3RpbWF0ZUdhcyA9IHRoaXMuZXN0aW1hdGVHYXMuYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmdldERhdGEgPSB0aGlzLmdldERhdGEuYmluZCh0aGlzKTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lKCk7XG4gICAgaWYgKCFjb250cmFjdFtkaXNwbGF5TmFtZV0pIHtcbiAgICAgICAgY29udHJhY3RbZGlzcGxheU5hbWVdID0gZXhlY3V0ZTtcbiAgICB9XG4gICAgY29udHJhY3RbZGlzcGxheU5hbWVdW3RoaXMudHlwZU5hbWUoKV0gPSBleGVjdXRlOyAvLyBjaXJjdWxhciEhISFcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlGdW5jdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Z1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGh0dHBwcm92aWRlci5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBNYXJpYW4gT2FuY2VhIDxtYXJpYW5AZXRoZGV2LmNvbT5cbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbi8vIHdvcmthcm91bmQgdG8gdXNlIGh0dHBwcm92aWRlciBpbiBkaWZmZXJlbnQgZW52c1xuXG4vLyBicm93c2VyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gIFhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0OyAvLyBqc2hpbnQgaWdub3JlOiBsaW5lXG4vLyBub2RlXG59IGVsc2Uge1xuICBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0JykuWE1MSHR0cFJlcXVlc3Q7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcbn1cblxudmFyIFhIUjIgPSByZXF1aXJlKCd4aHIyJyk7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcblxuLyoqXG4gKiBIdHRwUHJvdmlkZXIgc2hvdWxkIGJlIHVzZWQgdG8gc2VuZCBycGMgY2FsbHMgb3ZlciBodHRwXG4gKi9cbnZhciBIdHRwUHJvdmlkZXIgPSBmdW5jdGlvbiAoaG9zdCwgdGltZW91dCwgdXNlciwgcGFzc3dvcmQpIHtcbiAgdGhpcy5ob3N0ID0gaG9zdCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JztcbiAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCAwO1xuICB0aGlzLnVzZXIgPSB1c2VyO1xuICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcHJlcGFyZSBuZXcgWE1MSHR0cFJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHByZXBhcmVSZXF1ZXN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUgaWYgcmVxdWVzdCBzaG91bGQgYmUgYXN5bmNcbiAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fSBvYmplY3RcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5wcmVwYXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChhc3luYykge1xuICB2YXIgcmVxdWVzdDtcblxuICBpZiAoYXN5bmMpIHtcbiAgICByZXF1ZXN0ID0gbmV3IFhIUjIoKTtcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG5cbiAgcmVxdWVzdC5vcGVuKCdQT1NUJywgdGhpcy5ob3N0LCBhc3luYyk7XG4gIGlmICh0aGlzLnVzZXIgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgIHZhciBhdXRoID0gJ0Jhc2ljICcgKyBuZXcgQnVmZmVyKHRoaXMudXNlciArICc6JyArIHRoaXMucGFzc3dvcmQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBhdXRoKTtcbiAgfSByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIHJldHVybiByZXF1ZXN0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3luYyByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgdmFyIHJlcXVlc3QgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KGZhbHNlKTtcblxuICB0cnkge1xuICAgIHJlcXVlc3Quc2VuZChKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKHRoaXMuaG9zdCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZEFzeW5jXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGVuZCB3aXRoIChlcnIsIHJlc3VsdClcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgdmFyIHJlcXVlc3QgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KHRydWUpO1xuXG4gIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgJiYgcmVxdWVzdC50aW1lb3V0ICE9PSAxKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gICAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yID0gZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhlcnJvcnMuQ29ubmVjdGlvblRpbWVvdXQodGhpcy50aW1lb3V0KSk7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0LnNlbmQoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHRyaWVzIHRvIG1ha2UgSHR0cCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBpc0Nvbm5lY3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHJlcXVlc3QgaGF2ZW4ndCBmYWlsZWQuIE90aGVyd2lzZSBmYWxzZVxuICovXG5IdHRwUHJvdmlkZXIucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHRoaXMuc2VuZCh7XG4gICAgICBpZDogOTk5OTk5OTk5OSxcbiAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgbWV0aG9kOiAnbmV0X2xpc3RlbmluZycsXG4gICAgICBwYXJhbXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHR0cFByb3ZpZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaHR0cHByb3ZpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9odHRwcHJvdmlkZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGliYW4uanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuXG52YXIgcGFkTGVmdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGJ5dGVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHN0cmluZztcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGJ5dGVzICogMikge1xuICAgICAgICByZXN1bHQgPSAnMCcgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgYW4gSUJBTiBmb3IgbW9kIDk3IGNvbXB1dGF0aW9uIGJ5IG1vdmluZyB0aGUgZmlyc3QgNCBjaGFycyB0byB0aGUgZW5kIGFuZCB0cmFuc2Zvcm1pbmcgdGhlIGxldHRlcnMgdG9cbiAqIG51bWJlcnMgKEEgPSAxMCwgQiA9IDExLCAuLi4sIFogPSAzNSksIGFzIHNwZWNpZmllZCBpbiBJU08xMzYxNi5cbiAqXG4gKiBAbWV0aG9kIGlzbzEzNjE2UHJlcGFyZVxuICogQHBhcmFtIHtTdHJpbmd9IGliYW4gdGhlIElCQU5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBwcmVwYXJlZCBJQkFOXG4gKi9cbnZhciBpc28xMzYxNlByZXBhcmUgPSBmdW5jdGlvbiAoaWJhbikge1xuICAgIHZhciBBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIFogPSAnWicuY2hhckNvZGVBdCgwKTtcblxuICAgIGliYW4gPSBpYmFuLnRvVXBwZXJDYXNlKCk7XG4gICAgaWJhbiA9IGliYW4uc3Vic3RyKDQpICsgaWJhbi5zdWJzdHIoMCw0KTtcblxuICAgIHJldHVybiBpYmFuLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24obil7XG4gICAgICAgIHZhciBjb2RlID0gbi5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAoY29kZSA+PSBBICYmIGNvZGUgPD0gWil7XG4gICAgICAgICAgICAvLyBBID0gMTAsIEIgPSAxMSwgLi4uIFogPSAzNVxuICAgICAgICAgICAgcmV0dXJuIGNvZGUgLSBBICsgMTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBNT0QgOTcgMTAgb2YgdGhlIHBhc3NlZCBJQkFOIGFzIHNwZWNpZmllZCBpbiBJU083MDY0LlxuICpcbiAqIEBtZXRob2QgbW9kOTcxMFxuICogQHBhcmFtIHtTdHJpbmd9IGliYW5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbnZhciBtb2Q5NzEwID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICB2YXIgcmVtYWluZGVyID0gaWJhbixcbiAgICAgICAgYmxvY2s7XG5cbiAgICB3aGlsZSAocmVtYWluZGVyLmxlbmd0aCA+IDIpe1xuICAgICAgICBibG9jayA9IHJlbWFpbmRlci5zbGljZSgwLCA5KTtcbiAgICAgICAgcmVtYWluZGVyID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgcmVtYWluZGVyLnNsaWNlKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlSW50KHJlbWFpbmRlciwgMTApICUgOTc7XG59O1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBpYmFuIG9iamVjdCBmcm9tIGliYW4gY29ycmVjdCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhblxuICovXG52YXIgSWJhbiA9IGZ1bmN0aW9uIChpYmFuKSB7XG4gICAgdGhpcy5faWJhbiA9IGliYW47XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBpYmFuIG9iamVjdCBmcm9tIGV0aGVyZXVtIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGZyb21BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7SWJhbn0gdGhlIElCQU4gb2JqZWN0XG4gKi9cbkliYW4uZnJvbUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHZhciBhc0JuID0gbmV3IEJpZ051bWJlcihhZGRyZXNzLCAxNik7XG4gICAgdmFyIGJhc2UzNiA9IGFzQm4udG9TdHJpbmcoMzYpO1xuICAgIHZhciBwYWRkZWQgPSBwYWRMZWZ0KGJhc2UzNiwgMTUpO1xuICAgIHJldHVybiBJYmFuLmZyb21CYmFuKHBhZGRlZC50b1VwcGVyQ2FzZSgpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcGFzc2VkIEJCQU4gdG8gYW4gSUJBTiBmb3IgdGhpcyBjb3VudHJ5IHNwZWNpZmljYXRpb24uXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IDxpPlwiZ2VuZXJhdGlvbiBvZiB0aGUgSUJBTiBzaGFsbCBiZSB0aGUgZXhjbHVzaXZlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBiYW5rL2JyYW5jaCBzZXJ2aWNpbmcgdGhlIGFjY291bnRcIjwvaT4uXG4gKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBwcmVmZXJyZWQgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlciNHZW5lcmF0aW5nX0lCQU5fY2hlY2tfZGlnaXRzXG4gKlxuICogQG1ldGhvZCBmcm9tQmJhblxuICogQHBhcmFtIHtTdHJpbmd9IGJiYW4gdGhlIEJCQU4gdG8gY29udmVydCB0byBJQkFOXG4gKiBAcmV0dXJucyB7SWJhbn0gdGhlIElCQU4gb2JqZWN0XG4gKi9cbkliYW4uZnJvbUJiYW4gPSBmdW5jdGlvbiAoYmJhbikge1xuICAgIHZhciBjb3VudHJ5Q29kZSA9ICdYRSc7XG5cbiAgICB2YXIgcmVtYWluZGVyID0gbW9kOTcxMChpc28xMzYxNlByZXBhcmUoY291bnRyeUNvZGUgKyAnMDAnICsgYmJhbikpO1xuICAgIHZhciBjaGVja0RpZ2l0ID0gKCcwJyArICg5OCAtIHJlbWFpbmRlcikpLnNsaWNlKC0yKTtcblxuICAgIHJldHVybiBuZXcgSWJhbihjb3VudHJ5Q29kZSArIGNoZWNrRGlnaXQgKyBiYmFuKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIElCQU4gb2JqZWN0IGZvciBnaXZlbiBpbnN0aXR1dGlvbiBhbmQgaWRlbnRpZmllclxuICpcbiAqIEBtZXRob2QgY3JlYXRlSW5kaXJlY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLCByZXF1aXJlZCBvcHRpb25zIGFyZSBcImluc3RpdHV0aW9uXCIgYW5kIFwiaWRlbnRpZmllclwiXG4gKiBAcmV0dXJuIHtJYmFufSB0aGUgSUJBTiBvYmplY3RcbiAqL1xuSWJhbi5jcmVhdGVJbmRpcmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEliYW4uZnJvbUJiYW4oJ0VUSCcgKyBvcHRpb25zLmluc3RpdHV0aW9uICsgb3B0aW9ucy5pZGVudGlmaWVyKTtcbn07XG5cbi8qKlxuICogVGhvcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gY2hlY2sgaWYgZ2l2ZW4gc3RyaW5nIGlzIHZhbGlkIGliYW4gb2JqZWN0XG4gKlxuICogQG1ldGhvZCBpc1ZhbGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gaWJhbiBzdHJpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMgdmFsaWQgSUJBTlxuICovXG5JYmFuLmlzVmFsaWQgPSBmdW5jdGlvbiAoaWJhbikge1xuICAgIHZhciBpID0gbmV3IEliYW4oaWJhbik7XG4gICAgcmV0dXJuIGkuaXNWYWxpZCgpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIGliYW4gaXMgY29ycmVjdFxuICpcbiAqIEBtZXRob2QgaXNWYWxpZFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5JYmFuLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvXlhFWzAtOV17Mn0oRVRIWzAtOUEtWl17MTN9fFswLTlBLVpdezMwLDMxfSkkLy50ZXN0KHRoaXMuX2liYW4pICYmXG4gICAgICAgIG1vZDk3MTAoaXNvMTM2MTZQcmVwYXJlKHRoaXMuX2liYW4pKSA9PT0gMTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIG51bWJlciBpcyBkaXJlY3RcbiAqXG4gKiBAbWV0aG9kIGlzRGlyZWN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbkliYW4ucHJvdG90eXBlLmlzRGlyZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pYmFuLmxlbmd0aCA9PT0gMzQgfHwgdGhpcy5faWJhbi5sZW5ndGggPT09IDM1O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIGliYW4gbnVtYmVyIGlmIGluZGlyZWN0XG4gKlxuICogQG1ldGhvZCBpc0luZGlyZWN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBpcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbkliYW4ucHJvdG90eXBlLmlzSW5kaXJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2liYW4ubGVuZ3RoID09PSAyMDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaWJhbiBjaGVja3N1bVxuICogVXNlcyB0aGUgbW9kLTk3LTEwIGNoZWNrc3VtbWluZyBwcm90b2NvbCAoSVNPL0lFQyA3MDY0OjIwMDMpXG4gKlxuICogQG1ldGhvZCBjaGVja3N1bVxuICogQHJldHVybnMge1N0cmluZ30gY2hlY2tzdW1cbiAqL1xuSWJhbi5wcm90b3R5cGUuY2hlY2tzdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2liYW4uc3Vic3RyKDIsIDIpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBpbnN0aXR1dGlvbiBpZGVudGlmaWVyXG4gKiBlZy4gWFJFR1xuICpcbiAqIEBtZXRob2QgaW5zdGl0dXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGluc3RpdHV0aW9uIGlkZW50aWZpZXJcbiAqL1xuSWJhbi5wcm90b3R5cGUuaW5zdGl0dXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpID8gdGhpcy5faWJhbi5zdWJzdHIoNywgNCkgOiAnJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgY2xpZW50IGlkZW50aWZpZXIgd2l0aGluIGluc3RpdHV0aW9uXG4gKiBlZy4gR0FWT0ZZT1JLXG4gKlxuICogQG1ldGhvZCBjbGllbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGNsaWVudCBpZGVudGlmaWVyXG4gKi9cbkliYW4ucHJvdG90eXBlLmNsaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luZGlyZWN0KCkgPyB0aGlzLl9pYmFuLnN1YnN0cigxMSkgOiAnJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgY2xpZW50IGRpcmVjdCBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBhZGRyZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBjbGllbnQgZGlyZWN0IGFkZHJlc3NcbiAqL1xuSWJhbi5wcm90b3R5cGUuYWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0RpcmVjdCgpKSB7XG4gICAgICAgIHZhciBiYXNlMzYgPSB0aGlzLl9pYmFuLnN1YnN0cig0KTtcbiAgICAgICAgdmFyIGFzQm4gPSBuZXcgQmlnTnVtYmVyKGJhc2UzNiwgMzYpO1xuICAgICAgICByZXR1cm4gcGFkTGVmdChhc0JuLnRvU3RyaW5nKDE2KSwgMjApO1xuICAgIH0gXG5cbiAgICByZXR1cm4gJyc7XG59O1xuXG5JYmFuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWJhbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWJhbjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaWJhbi5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaWJhbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGlwY3Byb3ZpZGVyLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuXG52YXIgSXBjUHJvdmlkZXIgPSBmdW5jdGlvbiAocGF0aCwgbmV0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICBcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXQuY29ubmVjdCh7cGF0aDogdGhpcy5wYXRofSk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0lQQyBDb25uZWN0aW9uIEVycm9yJywgZSk7XG4gICAgICAgIF90aGlzLl90aW1lb3V0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIF90aGlzLl90aW1lb3V0KCk7XG4gICAgfSk7IFxuXG5cbiAgICAvLyBMSVNURU4gRk9SIENPTk5FQ1RJT04gUkVTUE9OU0VTXG4gICAgdGhpcy5jb25uZWN0aW9uLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA2ICovXG5cbiAgICAgICAgX3RoaXMuX3BhcnNlUmVzcG9uc2UoZGF0YS50b1N0cmluZygpKS5mb3JFYWNoKGZ1bmN0aW9uKHJlc3VsdCl7XG5cbiAgICAgICAgICAgIHZhciBpZCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgaWQgd2hpY2ggbWF0Y2hlcyB0aGUgcmV0dXJuZWQgaWRcbiAgICAgICAgICAgIGlmKHV0aWxzLmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uKGxvYWQpe1xuICAgICAgICAgICAgICAgICAgICBpZihfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tsb2FkLmlkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gbG9hZC5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWQgPSByZXN1bHQuaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICBpZihfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0obnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuV2lsbCBwYXJzZSB0aGUgcmVzcG9uc2UgYW5kIG1ha2UgYW4gYXJyYXkgb3V0IG9mIGl0LlxuXG5AbWV0aG9kIF9wYXJzZVJlc3BvbnNlXG5AcGFyYW0ge1N0cmluZ30gZGF0YVxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICByZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICBcbiAgICAvLyBERS1DSFVOS0VSXG4gICAgdmFyIGRlY2h1bmtlZERhdGEgPSBkYXRhXG4gICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXHsvZywnfXwtLXx7JykgLy8gfXtcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcW1xcey9nLCd9XXwtLXxbeycpIC8vIH1dW3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcW1xcey9nLCd9fC0tfFt7JykgLy8gfVt7XG4gICAgICAgIC5yZXBsYWNlKC9cXH1cXF1bXFxuXFxyXT9cXHsvZywnfV18LS18eycpIC8vIH1de1xuICAgICAgICAuc3BsaXQoJ3wtLXwnKTtcblxuICAgIGRlY2h1bmtlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhKXtcblxuICAgICAgICAvLyBwcmVwZW5kIHRoZSBsYXN0IGNodW5rXG4gICAgICAgIGlmKF90aGlzLmxhc3RDaHVuaylcbiAgICAgICAgICAgIGRhdGEgPSBfdGhpcy5sYXN0Q2h1bmsgKyBkYXRhO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAgIH0gY2F0Y2goZSkge1xuXG4gICAgICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBkYXRhO1xuXG4gICAgICAgICAgICAvLyBzdGFydCB0aW1lb3V0IHRvIGNhbmNlbCBhbGwgcmVxdWVzdHNcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVua1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKGRhdGEpO1xuICAgICAgICAgICAgfSwgMTAwMCAqIDE1KTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FuY2VsIHRpbWVvdXQgYW5kIHNldCBjaHVuayB0byBudWxsXG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgX3RoaXMubGFzdENodW5rID0gbnVsbDtcblxuICAgICAgICBpZihyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm5WYWx1ZXMucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbn07XG5cblxuLyoqXG5HZXQgdGhlIGFkZHMgYSBjYWxsYmFjayB0byB0aGUgcmVzcG9uc2VDYWxsYmFja3Mgb2JqZWN0LFxud2hpY2ggd2lsbCBiZSBjYWxsZWQgaWYgYSByZXNwb25zZSBtYXRjaGluZyB0aGUgcmVzcG9uc2UgSWQgd2lsbCBhcnJpdmUuXG5cbkBtZXRob2QgX2FkZFJlc3BvbnNlQ2FsbGJhY2tcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuX2FkZFJlc3BvbnNlQ2FsbGJhY2sgPSBmdW5jdGlvbihwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IHBheWxvYWQuaWQgfHwgcGF5bG9hZFswXS5pZDtcbiAgICB2YXIgbWV0aG9kID0gcGF5bG9hZC5tZXRob2QgfHwgcGF5bG9hZFswXS5tZXRob2Q7XG5cbiAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdLm1ldGhvZCA9IG1ldGhvZDtcbn07XG5cbi8qKlxuVGltZW91dCBhbGwgcmVxdWVzdHMgd2hlbiB0aGUgZW5kL2Vycm9yIGV2ZW50IGlzIGZpcmVkXG5cbkBtZXRob2QgX3RpbWVvdXRcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuX3RpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIGtleSBpbiB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzKSB7XG4gICAgICAgIGlmKHRoaXMucmVzcG9uc2VDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2tleV0oZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKCdvbiBJUEMnKSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1trZXldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbkNoZWNrIGlmIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gaXMgc3RpbGwgdmFsaWQuXG5cbkBtZXRob2QgaXNDb25uZWN0ZWRcbiovXG5JcGNQcm92aWRlci5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICBpZighX3RoaXMuY29ubmVjdGlvbi53cml0YWJsZSlcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOiBfdGhpcy5wYXRofSk7XG5cbiAgICByZXR1cm4gISF0aGlzLmNvbm5lY3Rpb24ud3JpdGFibGU7XG59O1xuXG5JcGNQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG5cbiAgICBpZih0aGlzLmNvbm5lY3Rpb24ud3JpdGVTeW5jKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICAgICAgaWYoIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZSlcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOiB0aGlzLnBhdGh9KTtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UoZGF0YSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHRyaWVkIHRvIHNlbmQgXCInKyBwYXlsb2FkLm1ldGhvZCArJ1wiIHN5bmNocm9ub3VzbHkuIFN5bmNocm9ub3VzIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUEMgcHJvdmlkZXIuJyk7XG4gICAgfVxufTtcblxuSXBjUHJvdmlkZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIC8vIHRyeSByZWNvbm5lY3QsIHdoZW4gY29ubmVjdGlvbiBpcyBnb25lXG4gICAgaWYoIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZSlcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IHRoaXMucGF0aH0pO1xuXG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ud3JpdGUoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgIHRoaXMuX2FkZFJlc3BvbnNlQ2FsbGJhY2socGF5bG9hZCwgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJcGNQcm92aWRlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvaXBjcHJvdmlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2lwY3Byb3ZpZGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUganNvbnJwYy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBBYXJvbiBLdW1hdmlzIDxhYXJvbkBrdW1hdmlzLm1lPlxuICogQGRhdGUgMjAxNVxuICovXG5cbi8vIEluaXRpYWxpemUgSnNvbnJwYyBhcyBhIHNpbXBsZSBvYmplY3Qgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucy5cbnZhciBKc29ucnBjID0ge1xuICAgIG1lc3NhZ2VJZDogMFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHZhbGlkIGpzb24gY3JlYXRlIHBheWxvYWQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBvZiBqc29ucnBjIGNhbGwsIHJlcXVpcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMsIGFuIGFycmF5IG9mIG1ldGhvZCBwYXJhbXMsIG9wdGlvbmFsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWxpZCBqc29ucnBjIHBheWxvYWQgb2JqZWN0XG4gKi9cbkpzb25ycGMudG9QYXlsb2FkID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgaWYgKCFtZXRob2QpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzb25ycGMgbWV0aG9kIHNob3VsZCBiZSBzcGVjaWZpZWQhJyk7XG5cbiAgICAvLyBhZHZhbmNlIG1lc3NhZ2UgSURcbiAgICBKc29ucnBjLm1lc3NhZ2VJZCsrO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGlkOiBKc29ucnBjLm1lc3NhZ2VJZCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHBhcmFtczogcGFyYW1zIHx8IFtdXG4gICAgfTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBqc29ucnBjIHJlc3BvbnNlIGlzIHZhbGlkXG4gKlxuICogQG1ldGhvZCBpc1ZhbGlkUmVzcG9uc2VcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgcmVzcG9uc2UgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5Kc29ucnBjLmlzVmFsaWRSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSA/IHJlc3BvbnNlLmV2ZXJ5KHZhbGlkYXRlU2luZ2xlTWVzc2FnZSkgOiB2YWxpZGF0ZVNpbmdsZU1lc3NhZ2UocmVzcG9uc2UpO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTaW5nbGVNZXNzYWdlKG1lc3NhZ2Upe1xuICAgICAgcmV0dXJuICEhbWVzc2FnZSAmJlxuICAgICAgICAhbWVzc2FnZS5lcnJvciAmJlxuICAgICAgICBtZXNzYWdlLmpzb25ycGMgPT09ICcyLjAnICYmXG4gICAgICAgIHR5cGVvZiBtZXNzYWdlLmlkID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkOyAvLyBvbmx5IHVuZGVmaW5lZCBpcyBub3QgdmFsaWQganNvbiBvYmplY3RcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIGJhdGNoIHBheWxvYWQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCB0b0JhdGNoUGF5bG9hZFxuICogQHBhcmFtIHtBcnJheX0gbWVzc2FnZXMsIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBtZXRob2QgKHJlcXVpcmVkKSBhbmQgcGFyYW1zIChvcHRpb25hbCkgZmllbGRzXG4gKiBAcmV0dXJucyB7QXJyYXl9IGJhdGNoIHBheWxvYWRcbiAqL1xuSnNvbnJwYy50b0JhdGNoUGF5bG9hZCA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIEpzb25ycGMudG9QYXlsb2FkKG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25ycGM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2pzb25ycGMuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2pzb25ycGMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgbWV0aG9kLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxudmFyIE1ldGhvZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuY2FsbCA9IG9wdGlvbnMuY2FsbDtcbiAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zIHx8IDA7XG4gICAgdGhpcy5pbnB1dEZvcm1hdHRlciA9IG9wdGlvbnMuaW5wdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5vdXRwdXRGb3JtYXR0ZXIgPSBvcHRpb25zLm91dHB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gbnVsbDtcbn07XG5cbk1ldGhvZC5wcm90b3R5cGUuc2V0UmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocm0pIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcm07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBuYW1lIG9mIHRoZSBqc29ucnBjIG1ldGhvZCBiYXNlZCBvbiBhcmd1bWVudHNcbiAqXG4gKiBAbWV0aG9kIGdldENhbGxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7U3RyaW5nfSBuYW1lIG9mIGpzb25ycGMgbWV0aG9kXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZ2V0Q2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzRnVuY3Rpb24odGhpcy5jYWxsKSA/IHRoaXMuY2FsbChhcmdzKSA6IHRoaXMuY2FsbDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZXh0cmFjdCBjYWxsYmFjayBmcm9tIGFycmF5IG9mIGFyZ3VtZW50cy4gTW9kaWZpZXMgaW5wdXQgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3RDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxOdWxsfSBjYWxsYmFjaywgaWYgZXhpc3RzXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGlzIGNvcnJlY3RcbiAqIFxuICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIG5vdFxuICovXG5NZXRob2QucHJvdG90eXBlLnZhbGlkYXRlQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSB0aGlzLnBhcmFtcykge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZE51bWJlck9mUlBDUGFyYW1zKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBpbnB1dCBhcmdzIG9mIG1ldGhvZFxuICogXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0XG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0SW5wdXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICghdGhpcy5pbnB1dEZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnB1dEZvcm1hdHRlci5tYXAoZnVuY3Rpb24gKGZvcm1hdHRlciwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlcihhcmdzW2luZGV4XSkgOiBhcmdzW2luZGV4XTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgb3V0cHV0KHJlc3VsdCkgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5NZXRob2QucHJvdG90eXBlLmZvcm1hdE91dHB1dCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzdWx0ID8gdGhpcy5vdXRwdXRGb3JtYXR0ZXIocmVzdWx0KSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBwYXlsb2FkIGZyb20gZ2l2ZW4gaW5wdXQgYXJnc1xuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9QYXlsb2FkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgY2FsbCA9IHRoaXMuZ2V0Q2FsbChhcmdzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5mb3JtYXRJbnB1dChhcmdzKTtcbiAgICB0aGlzLnZhbGlkYXRlQXJncyhwYXJhbXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiBjYWxsLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfTtcbn07XG5cbk1ldGhvZC5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGZ1bmMgPSB0aGlzLmJ1aWxkQ2FsbCgpO1xuICAgIGZ1bmMuY2FsbCA9IHRoaXMuY2FsbDsgLy8gVE9ETyEhISB0aGF0J3MgdWdseS4gZmlsdGVyLmpzIHVzZXMgaXRcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZS5zcGxpdCgnLicpO1xuICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gb2JqW25hbWVbMF1dIHx8IHt9O1xuICAgICAgICBvYmpbbmFtZVswXV1bbmFtZVsxXV0gPSBmdW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtuYW1lWzBdXSA9IGZ1bmM7IFxuICAgIH1cbn07XG5cbk1ldGhvZC5wcm90b3R5cGUuYnVpbGRDYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXM7XG4gICAgdmFyIHNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbWV0aG9kLnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHBheWxvYWQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QucmVxdWVzdE1hbmFnZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2soZXJyLCBtZXRob2QuZm9ybWF0T3V0cHV0KHJlc3VsdCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5mb3JtYXRPdXRwdXQobWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmQocGF5bG9hZCkpO1xuICAgIH07XG4gICAgc2VuZC5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHNlbmQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIHB1cmUgSlNPTlJQQyByZXF1ZXN0IHdoaWNoIGNhbiBiZSB1c2VkIGluIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RcbiAqIEBwYXJhbSB7Li4ufSBwYXJhbXNcbiAqIEByZXR1cm4ge09iamVjdH0ganNvbnJwYyByZXF1ZXN0XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHBheWxvYWQuZm9ybWF0ID0gdGhpcy5mb3JtYXRPdXRwdXQuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBkYi5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcblxudmFyIERCID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIG1ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkgeyBcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufTtcblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHB1dFN0cmluZyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncHV0U3RyaW5nJyxcbiAgICAgICAgY2FsbDogJ2RiX3B1dFN0cmluZycsXG4gICAgICAgIHBhcmFtczogM1xuICAgIH0pO1xuXG4gICAgdmFyIGdldFN0cmluZyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0U3RyaW5nJyxcbiAgICAgICAgY2FsbDogJ2RiX2dldFN0cmluZycsXG4gICAgICAgIHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgdmFyIHB1dEhleCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncHV0SGV4JyxcbiAgICAgICAgY2FsbDogJ2RiX3B1dEhleCcsXG4gICAgICAgIHBhcmFtczogM1xuICAgIH0pO1xuXG4gICAgdmFyIGdldEhleCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0SGV4JyxcbiAgICAgICAgY2FsbDogJ2RiX2dldEhleCcsXG4gICAgICAgIHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHV0U3RyaW5nLCBnZXRTdHJpbmcsIHB1dEhleCwgZ2V0SGV4XG4gICAgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gREI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2RiLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2RiLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG52YXIgYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbmZpZycpO1xudmFyIENvbnRyYWN0ID0gcmVxdWlyZSgnLi4vY29udHJhY3QnKTtcbnZhciB3YXRjaGVzID0gcmVxdWlyZSgnLi93YXRjaGVzJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyJyk7XG52YXIgSXNTeW5jaW5nID0gcmVxdWlyZSgnLi4vc3luY2luZycpO1xudmFyIG5hbWVyZWcgPSByZXF1aXJlKCcuLi9uYW1lcmVnJyk7XG52YXIgSWJhbiA9IHJlcXVpcmUoJy4uL2liYW4nKTtcbnZhciB0cmFuc2ZlciA9IHJlcXVpcmUoJy4uL3RyYW5zZmVyJyk7XG5cbnZhciBibG9ja0NhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/IFwiZXRoX2dldEJsb2NrQnlIYXNoXCIgOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCI7XG59O1xuXG52YXIgdHJhbnNhY3Rpb25Gcm9tQmxvY2tDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHV0aWxzLmlzU3RyaW5nKGFyZ3NbMF0pICYmIGFyZ3NbMF0uaW5kZXhPZignMHgnKSA9PT0gMCkgPyAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCcgOiAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4Jztcbn07XG5cbnZhciB1bmNsZUNhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JyA6ICdldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgnO1xufTtcblxudmFyIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJyA6ICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXInO1xufTtcblxudmFyIHVuY2xlQ291bnRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gKHV0aWxzLmlzU3RyaW5nKGFyZ3NbMF0pICYmIGFyZ3NbMF0uaW5kZXhPZignMHgnKSA9PT0gMCkgPyAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCcgOiAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJztcbn07XG5cbmZ1bmN0aW9uIEV0aCh3ZWIzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIG1ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG5cbiAgICBwcm9wZXJ0aWVzKCkuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgIHAuYXR0YWNoVG9PYmplY3Qoc2VsZik7XG4gICAgICAgIHAuc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG5cbiAgICB0aGlzLmliYW4gPSBJYmFuO1xuICAgIHRoaXMuc2VuZElCQU5UcmFuc2FjdGlvbiA9IHRyYW5zZmVyLmJpbmQobnVsbCwgdGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdGgucHJvdG90eXBlLCAnZGVmYXVsdEJsb2NrJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYy5kZWZhdWx0QmxvY2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgYy5kZWZhdWx0QmxvY2sgPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdGgucHJvdG90eXBlLCAnZGVmYXVsdEFjY291bnQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjLmRlZmF1bHRBY2NvdW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGMuZGVmYXVsdEFjY291bnQgPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufSk7XG5cbnZhciBtZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZXRCYWxhbmNlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCYWxhbmNlJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJpZ051bWJlckZvcm1hdHRlclxuICAgIH0pO1xuXG4gICAgdmFyIGdldFN0b3JhZ2VBdCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0U3RvcmFnZUF0JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRTdG9yYWdlQXQnLFxuICAgICAgICBwYXJhbXM6IDMsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgdXRpbHMudG9IZXgsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0Q29kZSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0Q29kZScsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0Q29kZScsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBnZXRCbG9jayA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0QmxvY2snLFxuICAgICAgICBjYWxsOiBibG9ja0NhbGwsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsIGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICEhdmFsOyB9XSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VW5jbGUgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFVuY2xlJyxcbiAgICAgICAgY2FsbDogdW5jbGVDYWxsLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCB1dGlscy50b0hleF0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRCbG9ja0Zvcm1hdHRlcixcblxuICAgIH0pO1xuXG4gICAgdmFyIGdldENvbXBpbGVycyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0Q29tcGlsZXJzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRDb21waWxlcnMnLFxuICAgICAgICBwYXJhbXM6IDBcbiAgICB9KTtcblxuICAgIHZhciBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgIGNhbGw6IGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudENhbGwsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrVW5jbGVDb3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0QmxvY2tVbmNsZUNvdW50JyxcbiAgICAgICAgY2FsbDogdW5jbGVDb3VudENhbGwsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIGdldFRyYW5zYWN0aW9uID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgIH0pO1xuXG4gICAgdmFyIGdldFRyYW5zYWN0aW9uRnJvbUJsb2NrID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkZyb21CbG9jaycsXG4gICAgICAgIGNhbGw6IHRyYW5zYWN0aW9uRnJvbUJsb2NrQ2FsbCxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciwgdXRpbHMudG9IZXhdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRUcmFuc2FjdGlvblJlY2VpcHQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb25Db3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICB9KTtcblxuICAgIHZhciBzZW5kUmF3VHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRSYXdUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgc2VuZFRyYW5zYWN0aW9uID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBjYWxsOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgc2lnblRyYW5zYWN0aW9uID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduVHJhbnNhY3Rpb24nLFxuICAgICAgICBjYWxsOiAnZXRoX3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgc2lnbiA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc2lnbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2lnbicsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBjYWxsID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjYWxsJyxcbiAgICAgICAgY2FsbDogJ2V0aF9jYWxsJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRDYWxsRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgIH0pO1xuXG4gICAgdmFyIGVzdGltYXRlR2FzID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdlc3RpbWF0ZUdhcycsXG4gICAgICAgIGNhbGw6ICdldGhfZXN0aW1hdGVHYXMnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIGNvbXBpbGVTb2xpZGl0eSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnY29tcGlsZS5zb2xpZGl0eScsXG4gICAgICAgIGNhbGw6ICdldGhfY29tcGlsZVNvbGlkaXR5JyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgY29tcGlsZUxMTCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnY29tcGlsZS5sbGwnLFxuICAgICAgICBjYWxsOiAnZXRoX2NvbXBpbGVMTEwnLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBjb21waWxlU2VycGVudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnY29tcGlsZS5zZXJwZW50JyxcbiAgICAgICAgY2FsbDogJ2V0aF9jb21waWxlU2VycGVudCcsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIHN1Ym1pdFdvcmsgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3N1Ym1pdFdvcmsnLFxuICAgICAgICBjYWxsOiAnZXRoX3N1Ym1pdFdvcmsnLFxuICAgICAgICBwYXJhbXM6IDNcbiAgICB9KTtcblxuICAgIHZhciBnZXRXb3JrID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRXb3JrJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRXb3JrJyxcbiAgICAgICAgcGFyYW1zOiAwXG4gICAgfSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBnZXRCYWxhbmNlLFxuICAgICAgICBnZXRTdG9yYWdlQXQsXG4gICAgICAgIGdldENvZGUsXG4gICAgICAgIGdldEJsb2NrLFxuICAgICAgICBnZXRVbmNsZSxcbiAgICAgICAgZ2V0Q29tcGlsZXJzLFxuICAgICAgICBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQsXG4gICAgICAgIGdldEJsb2NrVW5jbGVDb3VudCxcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb24sXG4gICAgICAgIGdldFRyYW5zYWN0aW9uRnJvbUJsb2NrLFxuICAgICAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQsXG4gICAgICAgIGdldFRyYW5zYWN0aW9uQ291bnQsXG4gICAgICAgIGNhbGwsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBzZW5kUmF3VHJhbnNhY3Rpb24sXG4gICAgICAgIHNpZ25UcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZFRyYW5zYWN0aW9uLFxuICAgICAgICBzaWduLFxuICAgICAgICBjb21waWxlU29saWRpdHksXG4gICAgICAgIGNvbXBpbGVMTEwsXG4gICAgICAgIGNvbXBpbGVTZXJwZW50LFxuICAgICAgICBzdWJtaXRXb3JrLFxuICAgICAgICBnZXRXb3JrXG4gICAgXTtcbn07XG5cblxudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdjb2luYmFzZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfY29pbmJhc2UnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ21pbmluZycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfbWluaW5nJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdoYXNocmF0ZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfaGFzaHJhdGUnLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnc3luY2luZycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfc3luY2luZycsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0U3luY2luZ0Zvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdnYXNQcmljZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJpZ051bWJlckZvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdhY2NvdW50cycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfYWNjb3VudHMnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9ibG9ja051bWJlcicsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdwcm90b2NvbFZlcnNpb24nLFxuICAgICAgICAgICAgZ2V0dGVyOiAnZXRoX3Byb3RvY29sVmVyc2lvbidcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuRXRoLnByb3RvdHlwZS5jb250cmFjdCA9IGZ1bmN0aW9uIChhYmkpIHtcbiAgICB2YXIgZmFjdG9yeSA9IG5ldyBDb250cmFjdCh0aGlzLCBhYmkpO1xuICAgIHJldHVybiBmYWN0b3J5O1xufTtcblxuRXRoLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2ssIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKG9wdGlvbnMsICdldGgnLCB0aGlzLl9yZXF1ZXN0TWFuYWdlciwgd2F0Y2hlcy5ldGgoKSwgZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spO1xufTtcblxuRXRoLnByb3RvdHlwZS5uYW1lcmVnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0KG5hbWVyZWcuZ2xvYmFsLmFiaSkuYXQobmFtZXJlZy5nbG9iYWwuYWRkcmVzcyk7XG59O1xuXG5FdGgucHJvdG90eXBlLmljYXBOYW1lcmVnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyYWN0KG5hbWVyZWcuaWNhcC5hYmkpLmF0KG5hbWVyZWcuaWNhcC5hZGRyZXNzKTtcbn07XG5cbkV0aC5wcm90b3R5cGUuaXNTeW5jaW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBJc1N5bmNpbmcodGhpcy5fcmVxdWVzdE1hbmFnZXIsIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9ldGguanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvZXRoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgZXRoLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG5cbnZhciBOZXQgPSBmdW5jdGlvbiAod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBwcm9wZXJ0aWVzKCkuZm9yRWFjaChmdW5jdGlvbihwKSB7IFxuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHdlYjMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn07XG5cbi8vLyBAcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgd2ViMy5ldGggYXBpIHByb3BlcnRpZXNcbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbGlzdGVuaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ25ldF9saXN0ZW5pbmcnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3BlZXJDb3VudCcsXG4gICAgICAgICAgICBnZXR0ZXI6ICduZXRfcGVlckNvdW50JyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pXG4gICAgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9uZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvbmV0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4uL2Zvcm1hdHRlcnMnKTtcblxuZnVuY3Rpb24gUGVyc29uYWwod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfbmV3QWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGltcG9ydFJhd0tleSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnaW1wb3J0UmF3S2V5Jyxcblx0XHRjYWxsOiAncGVyc29uYWxfaW1wb3J0UmF3S2V5Jyxcblx0XHRwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHZhciBzaWduID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduJyxcblx0XHRjYWxsOiAncGVyc29uYWxfc2lnbicsXG5cdFx0cGFyYW1zOiAzLFxuXHRcdGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgZWNSZWNvdmVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdlY1JlY292ZXInLFxuXHRcdGNhbGw6ICdwZXJzb25hbF9lY1JlY292ZXInLFxuXHRcdHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgdmFyIHVubG9ja0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VubG9ja0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfdW5sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzZW5kVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGxvY2tBY2NvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdsb2NrQWNjb3VudCcsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ld0FjY291bnQsXG4gICAgICAgIGltcG9ydFJhd0tleSxcbiAgICAgICAgdW5sb2NrQWNjb3VudCxcbiAgICAgICAgZWNSZWNvdmVyLFxuICAgICAgICBzaWduLFxuICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgIGxvY2tBY2NvdW50XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbGlzdEFjY291bnRzJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3BlcnNvbmFsX2xpc3RBY2NvdW50cydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnNvbmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9wZXJzb25hbC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9wZXJzb25hbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIHNoaC5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhjb3JlLmlvPlxuICogQGRhdGUgMjAxN1xuICovXG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuLi9maWx0ZXInKTtcbnZhciB3YXRjaGVzID0gcmVxdWlyZSgnLi93YXRjaGVzJyk7XG5cbnZhciBTaGggPSBmdW5jdGlvbiAod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xufTtcblxuU2hoLnByb3RvdHlwZS5uZXdNZXNzYWdlRmlsdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihvcHRpb25zLCAnc2hoJywgdGhpcy5fcmVxdWVzdE1hbmFnZXIsIHdhdGNoZXMuc2hoKCksIG51bGwsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spO1xufTtcblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfdmVyc2lvbicsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2luZm8nLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9pbmZvJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnc2V0TWF4TWVzc2FnZVNpemUnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9zZXRNYXhNZXNzYWdlU2l6ZScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3NldE1pblBvVycsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3NldE1pblBvVycsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ21hcmtUcnVzdGVkUGVlcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX21hcmtUcnVzdGVkUGVlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ25ld0tleVBhaXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdLZXlQYWlyJyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnYWRkUHJpdmF0ZUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2FkZFByaXZhdGVLZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdkZWxldGVLZXlQYWlyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlS2V5UGFpcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc0tleVBhaXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9oYXNLZXlQYWlyJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UHVibGljS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZ2V0UHVibGljS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0UHJpdmF0ZUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldFByaXZhdGVLZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICduZXdTeW1LZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdTeW1LZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAwXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdhZGRTeW1LZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9hZGRTeW1LZXknLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCcsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dlbmVyYXRlU3ltS2V5RnJvbVBhc3N3b3JkJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnaGFzU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfaGFzU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0U3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZ2V0U3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZGVsZXRlU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcblxuICAgICAgICAvLyBzdWJzY3JpYmUgYW5kIHVuc3Vic2NyaWJlIG1pc3NpbmdcblxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdwb3N0JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfcG9zdCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgICAgIH0pXG4gICAgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2hoO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3NoaC5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zaGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgYnp6LmpzXG4gKiBAYXV0aG9yIEFsZXggQmVyZWdzemFzemkgPGFsZXhAcnRmcy5odT5cbiAqIEBkYXRlIDIwMTZcbiAqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9ibG9iL3N3YXJtL2ludGVybmFsL3dlYjNleHQvd2ViM2V4dC5nbyNMMzNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcblxuZnVuY3Rpb24gU3dhcm0od2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJsb2NrTmV0d29ya1JlYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBjYWxsOiAnYnp6X2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzeW5jRW5hYmxlZCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3luY0VuYWJsZWQnLFxuICAgICAgICBjYWxsOiAnYnp6X3N5bmNFbmFibGVkJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgc3dhcEVuYWJsZWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3N3YXBFbmFibGVkJyxcbiAgICAgICAgY2FsbDogJ2J6el9zd2FwRW5hYmxlZCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGRvd25sb2FkID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdkb3dubG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfZG93bmxvYWQnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciB1cGxvYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VwbG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfdXBsb2FkJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcmV0cmlldmUgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3JldHJpZXZlJyxcbiAgICAgICAgY2FsbDogJ2J6el9yZXRyaWV2ZScsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIHN0b3JlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzdG9yZScsXG4gICAgICAgIGNhbGw6ICdienpfc3RvcmUnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBnZXQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldCcsXG4gICAgICAgIGNhbGw6ICdienpfZ2V0JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcHV0ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgICBjYWxsOiAnYnp6X3B1dCcsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIG1vZGlmeSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnbW9kaWZ5JyxcbiAgICAgICAgY2FsbDogJ2J6el9tb2RpZnknLFxuICAgICAgICBwYXJhbXM6IDQsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGJsb2NrTmV0d29ya1JlYWQsXG4gICAgICAgIHN5bmNFbmFibGVkLFxuICAgICAgICBzd2FwRW5hYmxlZCxcbiAgICAgICAgZG93bmxvYWQsXG4gICAgICAgIHVwbG9hZCxcbiAgICAgICAgcmV0cmlldmUsXG4gICAgICAgIHN0b3JlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHB1dCxcbiAgICAgICAgbW9kaWZ5XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaGl2ZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaGl2ZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaW5mbycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaW5mbydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN3YXJtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zd2FybS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9zd2FybS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIHdhdGNoZXMuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZSgnLi4vbWV0aG9kJyk7XG5cbi8vLyBAcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgd2ViMy5ldGguZmlsdGVyIGFwaSBtZXRob2RzXG52YXIgZXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdGaWx0ZXJDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmdzWzBdO1xuXG4gICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdsYXRlc3QnOlxuICAgICAgICAgICAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdldGhfbmV3QmxvY2tGaWx0ZXInO1xuICAgICAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgICAgICAgICAgYXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2V0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXInO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2V0aF9uZXdGaWx0ZXInO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBuZXdGaWx0ZXIgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0ZpbHRlcicsXG4gICAgICAgIGNhbGw6IG5ld0ZpbHRlckNhbGwsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIHVuaW5zdGFsbEZpbHRlciA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAndW5pbnN0YWxsRmlsdGVyJyxcbiAgICAgICAgY2FsbDogJ2V0aF91bmluc3RhbGxGaWx0ZXInLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBnZXRMb2dzID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRMb2dzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRGaWx0ZXJMb2dzJyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgcG9sbCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAncG9sbCcsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0RmlsdGVyQ2hhbmdlcycsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3RmlsdGVyLFxuICAgICAgICB1bmluc3RhbGxGaWx0ZXIsXG4gICAgICAgIGdldExvZ3MsXG4gICAgICAgIHBvbGxcbiAgICBdO1xufTtcblxuLy8vIEByZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyB3ZWIzLnNoaC53YXRjaCBhcGkgbWV0aG9kc1xudmFyIHNoaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ25ld0ZpbHRlcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX25ld01lc3NhZ2VGaWx0ZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICd1bmluc3RhbGxGaWx0ZXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9kZWxldGVNZXNzYWdlRmlsdGVyJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0TG9ncycsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldEZpbHRlck1lc3NhZ2VzJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAncG9sbCcsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldEZpbHRlck1lc3NhZ2VzJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBldGg6IGV0aCxcbiAgICBzaGg6IHNoaFxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy93YXRjaGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3dhdGNoZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIG5hbWVyZWcuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGdsb2JhbFJlZ2lzdHJhckFiaSA9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9HbG9iYWxSZWdpc3RyYXIuanNvbicpO1xudmFyIGljYXBSZWdpc3RyYXJBYmk9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb24nKTtcblxudmFyIGdsb2JhbE5hbWVyZWdBZGRyZXNzID0gJzB4YzZkOWQyY2Q0NDlhNzU0YzQ5NDI2NGUxODA5YzUwZTM0ZDY0NTYyYic7XG52YXIgaWNhcE5hbWVyZWdBZGRyZXNzID0gJzB4YTFhMTExYmMwNzRjOWNmYTc4MWYwYzM4ZTYzYmQ1MWM5MWI4YWYwMCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdsb2JhbDoge1xuICAgICAgICBhYmk6IGdsb2JhbFJlZ2lzdHJhckFiaSxcbiAgICAgICAgYWRkcmVzczogZ2xvYmFsTmFtZXJlZ0FkZHJlc3NcbiAgICB9LFxuICAgIGljYXA6IHtcbiAgICAgICAgYWJpOiBpY2FwUmVnaXN0cmFyQWJpLFxuICAgICAgICBhZGRyZXNzOiBpY2FwTmFtZXJlZ0FkZHJlc3NcbiAgICB9XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9uYW1lcmVnLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9uYW1lcmVnLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIHByb3BlcnR5LmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBmcm96ZW1hbi5kZT5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxudmFyIFByb3BlcnR5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5nZXR0ZXIgPSBvcHRpb25zLmdldHRlcjtcbiAgICB0aGlzLnNldHRlciA9IG9wdGlvbnMuc2V0dGVyO1xuICAgIHRoaXMub3V0cHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5vdXRwdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5pbnB1dEZvcm1hdHRlciA9IG9wdGlvbnMuaW5wdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IG51bGw7XG59O1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuc2V0UmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocm0pIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcm07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IGlucHV0IGFyZ3Mgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dFxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUuZm9ybWF0SW5wdXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRGb3JtYXR0ZXIgPyB0aGlzLmlucHV0Rm9ybWF0dGVyKGFyZykgOiBhcmc7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IG91dHB1dChyZXN1bHQpIG9mIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLmZvcm1hdE91dHB1dCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkID8gdGhpcy5vdXRwdXRGb3JtYXR0ZXIocmVzdWx0KSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZXh0cmFjdCBjYWxsYmFjayBmcm9tIGFycmF5IG9mIGFyZ3VtZW50cy4gTW9kaWZpZXMgaW5wdXQgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3RDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxOdWxsfSBjYWxsYmFjaywgaWYgZXhpc3RzXG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MucG9wKCk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG5cbi8qKlxuICogU2hvdWxkIGF0dGFjaCBmdW5jdGlvbiB0byBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGF0dGFjaFRvT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5hdHRhY2hUb09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcHJvdG8gPSB7XG4gICAgICAgIGdldDogdGhpcy5idWlsZEdldCgpLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfTtcblxuICAgIHZhciBuYW1lcyA9IHRoaXMubmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciBuYW1lID0gbmFtZXNbMF07XG4gICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb2JqW25hbWVzWzBdXSA9IG9ialtuYW1lc1swXV0gfHwge307XG4gICAgICAgIG9iaiA9IG9ialtuYW1lc1swXV07XG4gICAgICAgIG5hbWUgPSBuYW1lc1sxXTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBwcm90byk7XG4gICAgb2JqW2FzeW5jR2V0dGVyTmFtZShuYW1lKV0gPSB0aGlzLmJ1aWxkQXN5bmNHZXQoKTtcbn07XG5cbnZhciBhc3luY0dldHRlck5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnZ2V0JyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xufTtcblxuUHJvcGVydHkucHJvdG90eXBlLmJ1aWxkR2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5LmZvcm1hdE91dHB1dChwcm9wZXJ0eS5yZXF1ZXN0TWFuYWdlci5zZW5kKHtcbiAgICAgICAgICAgIG1ldGhvZDogcHJvcGVydHkuZ2V0dGVyXG4gICAgICAgIH0pKTtcbiAgICB9O1xufTtcblxuUHJvcGVydHkucHJvdG90eXBlLmJ1aWxkQXN5bmNHZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcztcbiAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHByb3BlcnR5LnJlcXVlc3RNYW5hZ2VyLnNlbmRBc3luYyh7XG4gICAgICAgICAgICBtZXRob2Q6IHByb3BlcnR5LmdldHRlclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcHJvcGVydHkuZm9ybWF0T3V0cHV0KHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGdldC5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIGdldDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgcHVyZSBKU09OUlBDIHJlcXVlc3Qgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFxuICogQHBhcmFtIHsuLi59IHBhcmFtc1xuICogQHJldHVybiB7T2JqZWN0fSBqc29ucnBjIHJlcXVlc3RcbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIG1ldGhvZDogdGhpcy5nZXR0ZXIsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIGNhbGxiYWNrOiB0aGlzLmV4dHJhY3RDYWxsYmFjayhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgIH07XG4gICAgcGF5bG9hZC5mb3JtYXQgPSB0aGlzLmZvcm1hdE91dHB1dC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9wZXJ0eTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3Byb3BlcnR5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSByZXF1ZXN0bWFuYWdlci5qc1xuICogQGF1dGhvciBKZWZmcmV5IFdpbGNrZSA8amVmZkBldGhkZXYuY29tPlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgTWFyaWFuIE9hbmNlYSA8bWFyaWFuQGV0aGRldi5jb20+XG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogQGF1dGhvciBHYXYgV29vZCA8Z0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciBKc29ucnBjID0gcmVxdWlyZSgnLi9qc29ucnBjJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIGMgPSByZXF1aXJlKCcuLi91dGlscy9jb25maWcnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vKipcbiAqIEl0J3MgcmVzcG9uc2libGUgZm9yIHBhc3NpbmcgbWVzc2FnZXMgdG8gcHJvdmlkZXJzXG4gKiBJdCdzIGFsc28gcmVzcG9uc2libGUgZm9yIHBvbGxpbmcgdGhlIGV0aGVyZXVtIG5vZGUgZm9yIGluY29taW5nIG1lc3NhZ2VzXG4gKiBEZWZhdWx0IHBvbGwgdGltZW91dCBpcyAxIHNlY29uZFxuICogU2luZ2xldG9uXG4gKi9cbnZhciBSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLnBvbGxzID0ge307XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc3luY2hyb25vdXNseSBzZW5kIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHNlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGF5bG9hZCA9IEpzb25ycGMudG9QYXlsb2FkKGRhdGEubWV0aG9kLCBkYXRhLnBhcmFtcyk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucHJvdmlkZXIuc2VuZChwYXlsb2FkKTtcblxuICAgIGlmICghSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGFzeW5jaHJvbm91c2x5IHNlbmQgcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZEFzeW5jXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICB9XG5cbiAgICB2YXIgcGF5bG9hZCA9IEpzb25ycGMudG9QYXlsb2FkKGRhdGEubWV0aG9kLCBkYXRhLnBhcmFtcyk7XG4gICAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gYXN5bmNocm9ub3VzbHkgc2VuZCBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kQmF0Y2hcbiAqIEBwYXJhbSB7QXJyYXl9IGJhdGNoIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZW5kQmF0Y2ggPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUHJvdmlkZXIoKSk7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvQmF0Y2hQYXlsb2FkKGRhdGEpO1xuXG4gICAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXRpbHMuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVzdWx0cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTsgXG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHNldCBwcm92aWRlciBvZiByZXF1ZXN0IG1hbmFnZXJcbiAqXG4gKiBAbWV0aG9kIHNldFByb3ZpZGVyXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKHApIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc3RhcnQgcG9sbGluZ1xuICpcbiAqIEBtZXRob2Qgc3RhcnRQb2xsaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IHBvbGxJZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHVuaW5zdGFsbFxuICpcbiAqIEB0b2RvIGNsZWFudXAgbnVtYmVyIG9mIHBhcmFtc1xuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc3RhcnRQb2xsaW5nID0gZnVuY3Rpb24gKGRhdGEsIHBvbGxJZCwgY2FsbGJhY2ssIHVuaW5zdGFsbCkge1xuICAgIHRoaXMucG9sbHNbcG9sbElkXSA9IHtkYXRhOiBkYXRhLCBpZDogcG9sbElkLCBjYWxsYmFjazogY2FsbGJhY2ssIHVuaW5zdGFsbDogdW5pbnN0YWxsfTtcblxuXG4gICAgLy8gc3RhcnQgcG9sbGluZ1xuICAgIGlmICghdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gc3RvcCBwb2xsaW5nIGZvciBmaWx0ZXIgd2l0aCBnaXZlbiBpZFxuICpcbiAqIEBtZXRob2Qgc3RvcFBvbGxpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb2xsSWRcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnN0b3BQb2xsaW5nID0gZnVuY3Rpb24gKHBvbGxJZCkge1xuICAgIGRlbGV0ZSB0aGlzLnBvbGxzW3BvbGxJZF07XG5cbiAgICAvLyBzdG9wIHBvbGxpbmdcbiAgICBpZihPYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGggPT09IDAgJiYgdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byByZXNldCB0aGUgcG9sbGluZyBtZWNoYW5pc20gb2YgdGhlIHJlcXVlc3QgbWFuYWdlclxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGtlZXBJc1N5bmNpbmcpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjUgKi9cblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnBvbGxzKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgcG9sbHMsIGV4Y2VwdCBzeW5jIHBvbGxzLFxuICAgICAgICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVtb3ZlZCBtYW51YWxseSBieSBjYWxsaW5nIHN5bmNpbmcuc3RvcFdhdGNoaW5nKClcbiAgICAgICAgaWYoIWtlZXBJc1N5bmNpbmcgfHwga2V5LmluZGV4T2YoJ3N5bmNQb2xsXycpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb2xsc1trZXldLnVuaW5zdGFsbCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucG9sbHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0b3AgcG9sbGluZ1xuICAgIGlmKE9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBvbGwgZm9yIGNoYW5nZXMgb24gZmlsdGVyIHdpdGggZ2l2ZW4gaWRcbiAqXG4gKiBAbWV0aG9kIHBvbGxcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5wb2xsLmJpbmQodGhpcyksIGMuRVRIX1BPTExJTkdfVElNRU9VVCk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvbGxzRGF0YSA9IFtdO1xuICAgIHZhciBwb2xsc0lkcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnBvbGxzKSB7XG4gICAgICAgIHBvbGxzRGF0YS5wdXNoKHRoaXMucG9sbHNba2V5XS5kYXRhKTtcbiAgICAgICAgcG9sbHNJZHMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGlmIChwb2xsc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF5bG9hZCA9IEpzb25ycGMudG9CYXRjaFBheWxvYWQocG9sbHNEYXRhKTtcbiAgICBcbiAgICAvLyBtYXAgdGhlIHJlcXVlc3QgaWQgdG8gdGhleSBwb2xsIGlkXG4gICAgdmFyIHBvbGxzSWRNYXAgPSB7fTtcbiAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24obG9hZCwgaW5kZXgpe1xuICAgICAgICBwb2xsc0lkTWFwW2xvYWQuaWRdID0gcG9sbHNJZHNbaW5kZXhdO1xuICAgIH0pO1xuXG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVycm9yLCByZXN1bHRzKSB7XG5cblxuICAgICAgICAvLyBUT0RPOiBjb25zb2xlIGxvZz9cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGlkID0gcG9sbHNJZE1hcFtyZXN1bHQuaWRdO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGZpbHRlciBpcyBzdGlsbCBpbnN0YWxsZWQgYWZ0ZXIgYXJyaXZhbCBvZiB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHNlbGYucG9sbHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNhbGxiYWNrID0gc2VsZi5wb2xsc1tpZF0uY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXJlc3VsdDsgXG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSBKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayhudWxsLCByZXN1bHQucmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RNYW5hZ2VyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9yZXF1ZXN0bWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcmVxdWVzdG1hbmFnZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbnZhciBTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRCbG9jayA9ICdsYXRlc3QnO1xuICAgIHRoaXMuZGVmYXVsdEFjY291bnQgPSB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdzO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9zZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc2V0dGluZ3MuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBzeW5jaW5nLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG5cbnZhciBjb3VudCA9IDE7XG5cbi8qKlxuQWRkcyB0aGUgY2FsbGJhY2sgYW5kIHNldHMgdXAgdGhlIG1ldGhvZHMsIHRvIGl0ZXJhdGUgb3ZlciB0aGUgcmVzdWx0cy5cblxuQG1ldGhvZCBwb2xsU3luY2luZ1xuQHBhcmFtIHtPYmplY3R9IHNlbGZcbiovXG52YXIgcG9sbFN5bmNpbmcgPSBmdW5jdGlvbihzZWxmKSB7XG5cbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24gKGVycm9yLCBzeW5jKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih1dGlscy5pc09iamVjdChzeW5jKSAmJiBzeW5jLnN0YXJ0aW5nQmxvY2spXG4gICAgICAgICAgICBzeW5jID0gZm9ybWF0dGVycy5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyKHN5bmMpO1xuXG4gICAgICAgIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5sYXN0U3luY1N0YXRlICE9PSBzeW5jKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0cnVlIGZpcnN0IHNvIHRoZSBhcHAgY2FuIHN0b3AgYW55dGhpbmcsIGJlZm9yZSByZWNlaXZpbmcgdGhlIHN5bmMgZGF0YVxuICAgICAgICAgICAgICAgIGlmKCFzZWxmLmxhc3RTeW5jU3RhdGUgJiYgdXRpbHMuaXNPYmplY3Qoc3luYykpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNhbGwgb24gdGhlIG5leHQgQ1BVIGN5Y2xlLCBzbyB0aGUgYWN0aW9ucyBvZiB0aGUgc3luYyBzdG9wIGNhbiBiZSBwcm9jZXNzZXMgZmlyc3RcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzeW5jKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RTeW5jU3RhdGUgPSBzeW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe1xuICAgICAgICBtZXRob2Q6ICdldGhfc3luY2luZycsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgfSwgc2VsZi5wb2xsSWQsIG9uTWVzc2FnZSwgc2VsZi5zdG9wV2F0Y2hpbmcuYmluZChzZWxmKSk7XG5cbn07XG5cbnZhciBJc1N5bmNpbmcgPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMucG9sbElkID0gJ3N5bmNQb2xsXycrIGNvdW50Kys7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmFkZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB0aGlzLmxhc3RTeW5jU3RhdGUgPSBmYWxzZTtcbiAgICBwb2xsU3luY2luZyh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuSXNTeW5jaW5nLnByb3RvdHlwZS5hZGRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbklzU3luY2luZy5wcm90b3R5cGUuc3RvcFdhdGNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIuc3RvcFBvbGxpbmcodGhpcy5wb2xsSWQpO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzU3luY2luZztcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgdHJhbnNmZXIuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEliYW4gPSByZXF1aXJlKCcuL2liYW4nKTtcbnZhciBleGNoYW5nZUFiaSA9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb24nKTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBtYWtlIEliYW4gdHJhbnNmZXJcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvIGliYW5cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5mZXJlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2ssIGNhbGxiYWNrXG4gKi9cbnZhciB0cmFuc2ZlciA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKHRvKTsgXG4gICAgaWYgKCFpYmFuLmlzVmFsaWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaWJhbiBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKGliYW4uaXNEaXJlY3QoKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmZXJUb0FkZHJlc3MoZXRoLCBmcm9tLCBpYmFuLmFkZHJlc3MoKSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB2YXIgYWRkcmVzcyA9IGV0aC5pY2FwTmFtZXJlZygpLmFkZHIoaWJhbi5pbnN0aXR1dGlvbigpKTtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSk7XG4gICAgfVxuXG4gICAgZXRoLmljYXBOYW1lcmVnKCkuYWRkcihpYmFuLmluc3RpdHV0aW9uKCksIGZ1bmN0aW9uIChlcnIsIGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byB0cmFuc2ZlciBmdW5kcyB0byBjZXJ0YWluIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyVG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSB0byBiZSB0cmFuZmVyZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgdHJhbnNmZXJUb0FkZHJlc3MgPSBmdW5jdGlvbiAoZXRoLCBmcm9tLCB0bywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV0aC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICBhZGRyZXNzOiB0byxcbiAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXBvc2l0IGZ1bmRzIHRvIGdlbmVyaWMgRXhjaGFuZ2UgY29udHJhY3QgKG11c3QgaW1wbGVtZW50IGRlcG9zaXQoYnl0ZXMzMikgbWV0aG9kISlcbiAqXG4gKiBAbWV0aG9kIGRlcG9zaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5zZmVyZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGllbnQgdW5pcXVlIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgZGVwb3NpdCA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2xpZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBhYmkgPSBleGNoYW5nZUFiaTtcbiAgICByZXR1cm4gZXRoLmNvbnRyYWN0KGFiaSkuYXQodG8pLmRlcG9zaXQoY2xpZW50LCB7XG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3RyYW5zZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy90cmFuc2Zlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4uLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy94aHIyL2xpYi9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9ub2RlX21vZHVsZXMveGhyMi9saWIvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2Fkc0xpc3Quc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2Fkc0xpc3Quc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2Fkc0xpc3Quc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvYWRzTGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9hZHNMaXN0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9idXR0b24uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2J1dHRvbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vYnV0dG9uLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2J1dHRvbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9idXR0b24uc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2ljb24uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2ljb24uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2ljb24uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvaWNvbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9pY29uLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9pbnB1dC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vaW5wdXQuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2lucHV0LnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2lucHV0LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9sYWJlbC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGFiZWwuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xhYmVsLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xhYmVsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL2xpbmsuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbGluay5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbGlua0xpc3Quc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xpbmtMaXN0LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9saW5rTGlzdC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rTGlzdC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9saW5rTGlzdC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vbG9hZGVyLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9sb2FkZXIuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2xvYWRlci5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9sb2FkZXIuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvbG9hZGVyLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9wYXBlci5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vcGFwZXIuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3BhcGVyLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3BhcGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3BhcGVyLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi90ZXh0V2l0aExhYmVsLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi90ZXh0V2l0aExhYmVsLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi90ZXh0V2l0aExhYmVsLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3RleHRXaXRoTGFiZWwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi4vLi4vcGFja2FnZXMvY29tcG9uZW50cy9zcmMvdGV4dFdpdGhMYWJlbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdG9vbHRpcC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdG9vbHRpcC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vdG9vbHRpcC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy90b29sdGlwLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL3Rvb2x0aXAuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lQejRLUEhOMlp5QjNhV1IwYUQwaU1UUXhjSGdpSUdobGFXZG9kRDBpTVRNeGNIZ2lJSFpwWlhkQ2IzZzlJakFnTUNBeE5ERWdNVE14SWlCMlpYSnphVzl1UFNJeExqRWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaVBnb2dJQ0FnUENFdExTQkhaVzVsY21GMGIzSTZJRk5yWlhSamFDQTBOaTR5SUNnME5EUTVOaWtnTFNCb2RIUndPaTh2ZDNkM0xtSnZhR1Z0YVdGdVkyOWthVzVuTG1OdmJTOXphMlYwWTJnZ0xTMCtDaUFnSUNBOGRHbDBiR1UrUjNKdmRYQWdNend2ZEdsMGJHVStDaUFnSUNBOFpHVnpZejVEY21WaGRHVmtJSGRwZEdnZ1UydGxkR05vTGp3dlpHVnpZejRLSUNBZ0lEeGtaV1p6UGdvZ0lDQWdJQ0FnSUR4amFYSmpiR1VnYVdROUluQmhkR2d0TVNJZ1kzZzlJall3TGpjNE5qRXpNamdpSUdONVBTSTFPUzQzT0RZeE16STRJaUJ5UFNJME5TNDNPRFl4TXpJNElqNDhMMk5wY21Oc1pUNEtJQ0FnSUNBZ0lDQThabWxzZEdWeUlIZzlJaTB6TlM0MUpTSWdlVDBpTFRNd0xqQWxJaUIzYVdSMGFEMGlNVGN4TGpBbElpQm9aV2xuYUhROUlqRTNNUzR3SlNJZ1ptbHNkR1Z5Vlc1cGRITTlJbTlpYW1WamRFSnZkVzVrYVc1blFtOTRJaUJwWkQwaVptbHNkR1Z5TFRJaVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Wm1WUFptWnpaWFFnWkhnOUlqQWlJR1I1UFNJMUlpQnBiajBpVTI5MWNtTmxRV3h3YUdFaUlISmxjM1ZzZEQwaWMyaGhaRzkzVDJabWMyVjBUM1YwWlhJeElqNDhMMlpsVDJabWMyVjBQZ29nSUNBZ0lDQWdJQ0FnSUNBOFptVkhZWFZ6YzJsaGJrSnNkWElnYzNSa1JHVjJhV0YwYVc5dVBTSXhNQ0lnYVc0OUluTm9ZV1J2ZDA5bVpuTmxkRTkxZEdWeU1TSWdjbVZ6ZFd4MFBTSnphR0ZrYjNkQ2JIVnlUM1YwWlhJeElqNDhMMlpsUjJGMWMzTnBZVzVDYkhWeVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Wm1WRGIyeHZjazFoZEhKcGVDQjJZV3gxWlhNOUlqQWdNQ0F3SURBZ01DNHdNelV5T1RReE1UYzJJQ0FnTUNBd0lEQWdNQ0F3TGpnek5USTVOREV4T0NBZ0lEQWdNQ0F3SURBZ01DNDBPRFl5TnpRMU1TQWdNQ0F3SURBZ01DNDBOU0F3SWlCMGVYQmxQU0p0WVhSeWFYZ2lJR2x1UFNKemFHRmtiM2RDYkhWeVQzVjBaWEl4SWo0OEwyWmxRMjlzYjNKTllYUnlhWGcrQ2lBZ0lDQWdJQ0FnUEM5bWFXeDBaWEkrQ2lBZ0lDQThMMlJsWm5NK0NpQWdJQ0E4WnlCcFpEMGlUVlpRSWlCemRISnZhMlU5SW01dmJtVWlJSE4wY205clpTMTNhV1IwYUQwaU1TSWdabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWo0S0lDQWdJQ0FnSUNBOFp5QnBaRDBpWTNKbFlYUmxUbVYzUVdSRGIyNW1hWEp0WVhScGIyNGlJSFJ5WVc1elptOXliVDBpZEhKaGJuTnNZWFJsS0MwM016WXVNREF3TURBd0xDQXRNell4TGpBd01EQXdNQ2tpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThaeUJwWkQwaVIzSnZkWEF0TWlJZ2RISmhibk5tYjNKdFBTSjBjbUZ1YzJ4aGRHVW9OelF4TGpBd01EQXdNQ3dnTXpZeUxqQXdNREF3TUNraVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWtkeWIzVndMVE1pUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeGphWEpqYkdVZ2FXUTlJazkyWVd3dE1pSWdabWxzYkMxdmNHRmphWFI1UFNJd0xqSWlJR1pwYkd3OUlpTXdPVVExTjBNaUlHTjRQU0l4TURNaUlHTjVQU0l6TXlJZ2NqMGlNek1pUGp3dlkybHlZMnhsUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeGphWEpqYkdVZ2FXUTlJazkyWVd3dE1pSWdabWxzYkMxdmNHRmphWFI1UFNJd0xqSWlJR1pwYkd3OUlpTXdPVVExTjBNaUlHTjRQU0l6TXlJZ1kzazlJamN6SWlCeVBTSXpNeUkrUEM5amFYSmpiR1UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWs5MllXd2lQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThkWE5sSUdacGJHdzlJbUpzWVdOcklpQm1hV3hzTFc5d1lXTnBkSGs5SWpFaUlHWnBiSFJsY2owaWRYSnNLQ05tYVd4MFpYSXRNaWtpSUhoc2FXNXJPbWh5WldZOUlpTndZWFJvTFRFaVBqd3ZkWE5sUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4ZFhObElHWnBiR3c5SWlNd09VUTFOME1pSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ2VHeHBibXM2YUhKbFpqMGlJM0JoZEdndE1TSStQQzkxYzJVK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeG5JR2xrUFNKdWIzVnVYemMwTnpNd01sOWpZeUlnZEhKaGJuTm1iM0p0UFNKMGNtRnVjMnhoZEdVb016WXVNREF3TURBd0xDQTBNaTR3TURBd01EQXBJaUJtYVd4c0xYSjFiR1U5SW01dmJucGxjbThpSUdacGJHdzlJaU5HUmtaR1JrWWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NVE11T1RVMk1EUTBMREF1TVRBNU9Ea3dNVEVnUXpFMkxqY3dNekk1Tmpjc0xUTXVNRFF3TmpJek16RmxMVEUwSURFNUxqQTJOVGt6TkRFc01DNDVPRGt3TVRBNU9Ea2dNakF1T0RJME1UYzFPQ3d5TGpnMU56RTBNamcySUV3eU5DNDRPVEF4TURrNUxEY3VNVFF5T0RVM01UUWdRekl6TGpjek5qSTJNemNzT0M0ME5qRTFNemcwTmlBeU1pNDROVGN4TkRJNUxEa3VNemsxTmpBME5DQXlNaTQxTWpjME56STFMRGt1T0RNMU1UWTBPRFFnUXpJeExqa3lNekEzTmprc09TNHhOelU0TWpReE9DQXlNQzQwTXprMU5qQTBMRGN1TkRjeU5USTNORGNnTVRndU9UVTJNRFEwTERVdU9EYzVNVEl3T0RnZ1F6RTNMalU0TWpReE56WXNOQzR6T1RVMk1EUTBJREUxTGpjeE5ESTROVGNzTXk0Mk9ERXpNVGcyT0NBeE15NDNNell5TmpNM0xETXVOemt4TWpBNE56a2dRekV4TGpnMk9ERXpNVGtzTXk0NU1ERXdPVGc1SURFd0xqRTJORGd6TlRJc05DNDNPREF5TVRrM09DQTVMakk0TlRjeE5ESTVMRFV1T1RnNU1ERXdPVGtnUXpVdU9UZzVNREV3T1Rrc01UQXVOVFE1TkRVd05TQTVMakk0TlRjeE5ESTVMREUwTGpZeE5UTTRORFlnT1M0eU9EVTNNVFF5T1N3eE5DNDJOekF6TWprM0lFd3lOQzQ0TXpVeE5qUTRMRE15TGpZek56TTJNallnUXpJekxqWTRNVE14T0Rjc016TXVPVFUyTURRMElESXlMamcxTnpFME1qa3NNelF1T1RRMU1EVTBPU0F5TWk0ME56STFNamMxTERNMUxqTXlPVFkzTURNZ1F6SXdMamczT1RFeU1Ea3NNek11TXpVeE5qUTROQ0F4TUM0ek9EUTJNVFUwTERJeExqUXlPRFUzTVRRZ05pNHlNRGczT1RFeU1Td3hOaTQxT1RNME1EWTJJRU0xTGpJeE9UYzRNREl5TERFMUxqUTVORFV3TlRVZ015NHhNekU0TmpneE15d3hNUzQxT1RNME1EWTJJRFF1T0RNMU1UWTBPRFFzTmk0M05UZ3lOREUzTmlCRE5pNDBPRE0xTVRZME9Dd3lMakF6TWprMk56QXpJREV3TGpjMk9USXpNRGdzTUM0eU1UazNPREF5TWlBeE15NDVOVFl3TkRRc01DNHhNRGs0T1RBeE1TQmFJaUJwWkQwaVUyaGhjR1VpUGp3dmNHRjBhRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEl6TGpBM05qa3lNekVzTVRZdU16RTROamd4TXlCRE1qUXVORFV3TlRRNU5Td3hOQzQzTWpVeU56UTNJREk0TGprMU5qQTBOQ3c1TGpRMU1EVTBPVFExSURNeExqYzFPREkwTVRnc05pNHpOek0yTWpZek55QkRNekl1T0RVM01UUXlPU3cxTGpFMk5EZ3pOVEUySURNMExqSTROVGN4TkRNc05DNDBOVEExTkRrME5TQXpOUzQ1T0Rrd01URXNOQzR6T1RVMk1EUTBJRU16Tnk0ek1EYzJPVEl6TERRdU16UXdOalU1TXpRZ016Z3VOamd4TXpFNE55dzBMamN5TlRJM05EY3pJRE01TGpjeU5USTNORGNzTlM0ME16azFOakEwTkNCRE16WXVOVGt6TkRBMk5pdzFMalkxT1RNME1EWTJJRE0xTGpBMU5EazBOVEVzTnk0MU1qYzBOekkxTXlBek5TdzNMalU0TWpReE56VTRJRXd5Tnk0Mk16Y3pOakkyTERFMkxqTXhPRFk0TVRNZ1RESXpMakEzTmpreU16RXNNVFl1TXpFNE5qZ3hNeUJhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRNdU1EYzJPVEl6TURnc01Ua3VORFV3TlRRNU5TQkRNQzQ1T0Rrd01UQTVPRGtzTVRjdU1ETXlPVFkzSURBdU1UWTBPRE0xTVRZMUxERXpMamM1TVRJd09EZ2dNQzQzTVRReU9EVTNNVFFzTVRBdU1UWTBPRE0xTWlCRE1TNHhOVE00TkRZeE5TdzNMakF6TWprMk56QXpJRE11TnpNMk1qWXpOelFzTkM0d05qVTVNelF3TnlBMkxqWTBPRE0xTVRZMUxESXVOelEzTWpVeU56VWdRelV1TmpVNU16UXdOallzTXk0M09URXlNRGczT1NBMExqZ3pOVEUyTkRnMExEVXVNRFUwT1RRMU1EVWdOQzR5T0RVM01UUXlPU3cyTGpVNU16UXdOalU1SUVNeUxqUTNNalV5TnpRM0xERXhMalU1TXpRd05qWWdOQzQzTWpVeU56UTNNeXd4TlM0NE1qUXhOelU0SURVdU56WTVNak13Tnpjc01UWXVPVGM0TURJeUlFTXhNQzR5TnpRM01qVXpMREl5TGpFNU56Z3dNaklnTWpJdU1UUXlPRFUzTVN3ek5TNDRNalF4TnpVNElESXlMakkxTWpjME56TXNNelV1T1RNME1EWTFPU0JNTWpJdU5USTNORGN5TlN3ek5pNHlOak0zTXpZeklFd3lNaTQzTkRjeU5USTNMRE0yTGpBME16azFOaUJETWpJdU9URXlNRGczT1N3ek5TNDROemt4TWpBNUlETTNMalEzTWpVeU56VXNNVGt1TURZMU9UTTBNU0EwTUM0M01UUXlPRFUzTERFMUxqUXpPVFUyTURRZ1F6UXpMalEyTVRVek9EVXNNVEl1TXpBM05qa3lNeUEwTXk0d056WTVNak14TERjdU5qTTNNell5TmpRZ05EQXVPREkwTVRjMU9DdzFMalUwT1RRMU1EVTFJRU16T1M0Mk1UVXpPRFEyTERRdU16azFOakEwTkNBek55NDRNREl4T1RjNExETXVOek0yTWpZek56UWdNell1TURRek9UVTJMRE11T1RBeE1EazRPU0JETXpRdU1qTXdOelk1TWl3ekxqazFOakEwTXprMklETXlMall6TnpNMk1qWXNOQzQzT0RBeU1UazNPQ0F6TVM0ME1qZzFOekUwTERZdU1EUXpPVFUyTURRZ1F6STRMalV4TmpRNE16VXNPUzR5TXpBM05qa3lNeUF5TXk0Mk1qWXpOek0yTERFMExqZzVNREV3T1RrZ01qSXVOVEkzTkRjeU5Td3hOaTR4TlRNNE5EWXlJRU15TVM0MU16ZzBOakUxTERFMExqazBOVEExTkRrZ01UY3VNVGszT0RBeU1pdzVMalkzTURNeU9UWTNJREUwTGprME5UQTFORGtzTnk0eE9UYzRNREl5SUVNeE5DNHlNekEzTmpreUxEWXVOREk0TlRjeE5ETWdNVE11TURJeE9UYzRMRFV1TmpBME16azFOaUF4TUM0M05qa3lNekE0TERVdU16ZzBOakUxTXpnZ1F6RXhMalU1TXpRd05qWXNOQzQzT0RBeU1UazNPQ0F4TWk0Mk9USXpNRGMzTERRdU5EVXdOVFE1TkRVZ01UTXVOemt4TWpBNE9DdzBMak0wTURZMU9UTTBJRU14TlM0d05UUTVORFV4TERRdU1qZzFOekUwTWprZ01UWXVPVEl6TURjMk9TdzBMalV3TlRRNU5EVXhJREU0TGpVeE5qUTRNelVzTmk0eU5qTTNNell5TmlCRE1qQXVNemcwTmpFMU5DdzRMakkwTVRjMU9ESTBJREl5TGpJMU1qYzBOek1zTVRBdU5ETTVOVFl3TkNBeU1pNHlOVEkzTkRjekxERXdMalF6T1RVMk1EUWdUREl5TGpRM01qVXlOelVzTVRBdU5qVTVNelF3TnlCTU1qSXVOamt5TXpBM055d3hNQzQwTXprMU5qQTBJRU15TWk0Mk9USXpNRGMzTERFd0xqUXpPVFUyTURRZ01qVXNOeTQ0TURJeE9UYzRJREk0TGpFNE5qZ3hNeklzTkM0eE56VTRNalF4T0NCRE16QXVPVE0wTURZMU9Td3hMakE1T0Rrd01URWdNelF1TWpNd056WTVNaXd3SURNMkxqUTRNelV4TmpVc01DQkRNemd1TnpNMk1qWXpOeXd3SURRekxqUTJNVFV6T0RVc01TNHpOek0yTWpZek55QTBOUzQwT1RRMU1EVTFMRFl1TmpRNE16VXhOalVnUXpRMkxqY3dNekk1Tmpjc09TNDRNelV4TmpRNE5DQTBOaTR4TlRNNE5EWXlMREUwTGpBMk5Ua3pOREVnTkRRdU1UYzFPREkwTWl3eE5pNHpNVGcyT0RFeklFTXpPQzQxTnpFME1qZzJMREl5TGpnMU56RTBNamtnTWpRdU1UYzFPREkwTWl3ek9TNHlPRFUzTVRReklESXlMak13TnpZNU1qTXNOREV1TkRnek5URTJOU0JETWpBdU16ZzBOakUxTkN3ek9TNHlPRFUzTVRReklEVXVNamMwTnpJMU1qY3NNakV1T1RJek1EYzJPU0F6TGpBM05qa3lNekE0TERFNUxqUTFNRFUwT1RVZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHdZWFJvSUdROUlrMDBOeTQ1Tmpjd016TXNNVGd1TkRZeE5UTTROU0JETkRNdU5UY3hOREk0Tml3eU15NDBNRFkxT1RNMElESTVMakUzTlRneU5ESXNOREF1TXpJNU5qY3dNeUF5Tnk0NU1USXdPRGM1TERReExqYzFPREkwTVRnZ1RESXpMakF5TVRrM09DdzBNUzQzTlRneU5ERTRJRU15TlM0MU5EazBOVEExTERNNExqYzVNVEl3T0RnZ016a3VNamcxTnpFME15d3lNeTR4TXpFNE5qZ3hJRFEwTGpjeU5USTNORGNzTVRZdU9ERXpNVGcyT0NCRE5EWXVPRFk0TVRNeE9Td3hOQzR6T1RVMk1EUTBJRFEzTGpReE56VTRNalFzTVRBZ05EWXVNRGs0T1RBeE1TdzJMalU1TXpRd05qVTVJRU0wTlM0ME16azFOakEwTERVZ05EUXVOakUxTXpnME5pd3pMalk0TVRNeE9EWTRJRFF6TGpZeU5qTTNNellzTWk0M05EY3lOVEkzTlNCRE5EWXVNRFF6T1RVMkxETXVOemt4TWpBNE56a2dORGN1T1RFeU1EZzNPU3cxTGpRNU5EVXdOVFE1SURRNUxqQXhNRGs0T1N3M0xqa3hNakE0TnpreElFdzBPUzR3TmpVNU16UXhMRGd1TURJeE9UYzRNRElnUXpRNUxqQXhNRGs0T1N3M0xqazJOekF6TWprM0lEVXhMamd4TXpFNE5qZ3NNVFF1TURFd09UZzVJRFEzTGprMk56QXpNeXd4T0M0ME5qRTFNemcxSUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUNBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lEd3ZaejRLUEM5emRtYytcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW1hZ2VzL2hlYXJ0LnN2Z1xuLy8gbW9kdWxlIGlkID0gLi9pbWFnZXMvaGVhcnQuc3ZnXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHV0dGluZyBoaXN0b3J5IG9uIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICBoaXN0b3J5OiB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2gocGF0aG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogJy8nLFxuICAgICAgdXJsOiAnLycsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNFeGFjdDogcGF0aG5hbWUgPT09ICcvJ1xuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcblxuXG4gICAgaW52YXJpYW50KGNoaWxkcmVuID09IG51bGwgfHwgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAxLCAnQSA8Um91dGVyPiBtYXkgaGF2ZSBvbmx5IG9uZSBjaGlsZCBlbGVtZW50Jyk7XG5cbiAgICAvLyBEbyB0aGlzIGhlcmUgc28gd2UgY2FuIHNldFN0YXRlIHdoZW4gYSA8UmVkaXJlY3Q+IGNoYW5nZXMgdGhlXG4gICAgLy8gbG9jYXRpb24gaW4gY29tcG9uZW50V2lsbE1vdW50LiBUaGlzIGhhcHBlbnMgZS5nLiB3aGVuIGRvaW5nXG4gICAgLy8gc2VydmVyIHJlbmRlcmluZyB1c2luZyBhIDxTdGF0aWNSb3V0ZXI+LlxuICAgIHRoaXMudW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICBtYXRjaDogX3RoaXMyLmNvbXB1dGVNYXRjaChoaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKHRoaXMucHJvcHMuaGlzdG9yeSA9PT0gbmV4dFByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+Jyk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIEhUTUw1IGhpc3RvcnkuXG4gKi9cblxudmFyIEJyb3dzZXJSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQnJvd3NlclJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnJvd3NlclJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyb3dzZXJSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPEJyb3dzZXJSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgQnJvd3NlclJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBCcm93c2VyUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Ccm93c2VyUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZvcmNlUmVmcmVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0Jyb3dzZXJSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyB3aW5kb3cubG9jYXRpb24uaGFzaC5cbiAqL1xuXG52YXIgSGFzaFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhIYXNoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIYXNoUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8SGFzaFJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBIYXNoUm91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkhhc2hSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGhhc2hUeXBlOiBQcm9wVHlwZXMub25lT2YoWydoYXNoYmFuZycsICdub3NsYXNoJywgJ3NsYXNoJ10pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgSGFzaFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuXG52YXIgaXNNb2RpZmllZEV2ZW50ID0gZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExpbmssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2xpY2spIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgLy8gb25DbGljayBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIGlnbm9yZSByaWdodCBjbGlja3NcbiAgICAgICFfdGhpcy5wcm9wcy50YXJnZXQgJiYgLy8gbGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIGlnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgdmFyIGhpc3RvcnkgPSBfdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5O1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgICByZXBsYWNlID0gX3RoaXMkcHJvcHMucmVwbGFjZSxcbiAgICAgICAgICAgICAgdG8gPSBfdGhpcyRwcm9wcy50bztcblxuXG4gICAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHJlcGxhY2UgPSBfcHJvcHMucmVwbGFjZSxcbiAgICAgICAgdG8gPSBfcHJvcHMudG8sXG4gICAgICAgIGlubmVyUmVmID0gX3Byb3BzLmlubmVyUmVmLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsncmVwbGFjZScsICd0bycsICdpbm5lclJlZiddKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPExpbms+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgdmFyIGhyZWYgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuY3JlYXRlSHJlZih0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8geyBwYXRobmFtZTogdG8gfSA6IHRvKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssIGhyZWY6IGhyZWYsIHJlZjogaW5uZXJSZWYgfSkpO1xuICB9O1xuXG4gIHJldHVybiBMaW5rO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5MaW5rLnByb3BUeXBlcyA9IHtcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgcmVwbGFjZTogUHJvcFR5cGVzLmJvb2wsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSlcbn07XG5MaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgcmVwbGFjZTogZmFsc2Vcbn07XG5MaW5rLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBwdXNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcmVwbGFjZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIGNyZWF0ZUhyZWY6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTGluaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9MaW5rLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtb3J5Um91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPE1lbW9yeVJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgTWVtb3J5Um91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBNZW1vcnlSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTWVtb3J5Um91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tICdwYXRoLXRvLXJlZ2V4cCc7XG5cbnZhciBwYXR0ZXJuQ2FjaGUgPSB7fTtcbnZhciBjYWNoZUxpbWl0ID0gMTAwMDA7XG52YXIgY2FjaGVDb3VudCA9IDA7XG5cbnZhciBjb21waWxlUGF0aCA9IGZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlS2V5ID0gJycgKyBvcHRpb25zLmVuZCArIG9wdGlvbnMuc3RyaWN0ICsgb3B0aW9ucy5zZW5zaXRpdmU7XG4gIHZhciBjYWNoZSA9IHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gfHwgKHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gPSB7fSk7XG5cbiAgaWYgKGNhY2hlW3BhdHRlcm5dKSByZXR1cm4gY2FjaGVbcGF0dGVybl07XG5cbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHBhdHRlcm4sIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0geyByZTogcmUsIGtleXM6IGtleXMgfTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkUGF0dGVybjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRQYXR0ZXJuO1xufTtcblxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIFVSTCBwYXRobmFtZSB0byBhIHBhdGggcGF0dGVybi5cbiAqL1xudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykgb3B0aW9ucyA9IHsgcGF0aDogb3B0aW9ucyB9O1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwYXRoID0gX29wdGlvbnMucGF0aCxcbiAgICAgIHBhdGggPSBfb3B0aW9ucyRwYXRoID09PSB1bmRlZmluZWQgPyAnLycgOiBfb3B0aW9ucyRwYXRoLFxuICAgICAgX29wdGlvbnMkZXhhY3QgPSBfb3B0aW9ucy5leGFjdCxcbiAgICAgIGV4YWN0ID0gX29wdGlvbnMkZXhhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZXhhY3QsXG4gICAgICBfb3B0aW9ucyRzdHJpY3QgPSBfb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfb3B0aW9ucyRzdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc3RyaWN0LFxuICAgICAgX29wdGlvbnMkc2Vuc2l0aXZlID0gX29wdGlvbnMuc2Vuc2l0aXZlLFxuICAgICAgc2Vuc2l0aXZlID0gX29wdGlvbnMkc2Vuc2l0aXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHNlbnNpdGl2ZTtcblxuICB2YXIgX2NvbXBpbGVQYXRoID0gY29tcGlsZVBhdGgocGF0aCwgeyBlbmQ6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSksXG4gICAgICByZSA9IF9jb21waWxlUGF0aC5yZSxcbiAgICAgIGtleXMgPSBfY29tcGlsZVBhdGgua2V5cztcblxuICB2YXIgbWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcblxuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgdXJsID0gbWF0Y2hbMF0sXG4gICAgICB2YWx1ZXMgPSBtYXRjaC5zbGljZSgxKTtcblxuICB2YXIgaXNFeGFjdCA9IHBhdGhuYW1lID09PSB1cmw7XG5cbiAgaWYgKGV4YWN0ICYmICFpc0V4YWN0KSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsIC8vIHRoZSBwYXRoIHBhdHRlcm4gdXNlZCB0byBtYXRjaFxuICAgIHVybDogcGF0aCA9PT0gJy8nICYmIHVybCA9PT0gJycgPyAnLycgOiB1cmwsIC8vIHRoZSBtYXRjaGVkIHBvcnRpb24gb2YgdGhlIFVSTFxuICAgIGlzRXhhY3Q6IGlzRXhhY3QsIC8vIHdoZXRoZXIgb3Igbm90IHdlIG1hdGNoZWQgZXhhY3RseVxuICAgIHBhcmFtczoga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGtleSwgaW5kZXgpIHtcbiAgICAgIG1lbW9ba2V5Lm5hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbnZhciBpc0VtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgc2luZ2xlIHBhdGggYW5kIHJlbmRlcmluZy5cbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcywgX3RoaXMuY29udGV4dC5yb3V0ZXIpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMubG9jYXRpb24gfHwgdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChfcmVmLCByb3V0ZXIpIHtcbiAgICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgICBzZW5zaXRpdmUgPSBfcmVmLnNlbnNpdGl2ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICBpbnZhcmlhbnQocm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZT4gb3Igd2l0aFJvdXRlcigpIG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgdmFyIHJvdXRlID0gcm91dGVyLnJvdXRlO1xuXG4gICAgdmFyIHBhdGhuYW1lID0gKGxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uKS5wYXRobmFtZTtcblxuICAgIHJldHVybiBwYXRoID8gbWF0Y2hQYXRoKHBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIHN0cmljdDogc3RyaWN0LCBleGFjdDogZXhhY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgcmVuZGVyPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIHJlbmRlcj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLnJlbmRlciAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSByZW5kZXI+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtYXRjaDogdGhpcy5jb21wdXRlTWF0Y2gobmV4dFByb3BzLCBuZXh0Q29udGV4dC5yb3V0ZXIpXG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0YXRlLm1hdGNoO1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gX3Byb3BzLmNvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyID0gX3Byb3BzLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICByZXR1cm4gY29tcG9uZW50ID8gLy8gY29tcG9uZW50IHByb3AgZ2V0cyBmaXJzdCBwcmlvcml0eSwgb25seSBjYWxsZWQgaWYgdGhlcmUncyBhIG1hdGNoXG4gICAgbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbCA6IHJlbmRlciA/IC8vIHJlbmRlciBwcm9wIGlzIG5leHQsIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gcmVuZGVyKHByb3BzKSA6IG51bGwgOiBjaGlsZHJlbiA/IC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHByb3BzKSA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlLnByb3BUeXBlcyA9IHtcbiAgY29tcHV0ZWRNYXRjaDogUHJvcFR5cGVzLm9iamVjdCwgLy8gcHJpdmF0ZSwgZnJvbSA8U3dpdGNoPlxuICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZS5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59O1xuUm91dGUuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Sb3V0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJvdXRlIGZyb20gJy4vUm91dGUnO1xuaW1wb3J0IExpbmsgZnJvbSAnLi9MaW5rJztcblxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xudmFyIE5hdkxpbmsgPSBmdW5jdGlvbiBOYXZMaW5rKF9yZWYpIHtcbiAgdmFyIHRvID0gX3JlZi50byxcbiAgICAgIGV4YWN0ID0gX3JlZi5leGFjdCxcbiAgICAgIHN0cmljdCA9IF9yZWYuc3RyaWN0LFxuICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3JlZi5hY3RpdmVDbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGFjdGl2ZVN0eWxlID0gX3JlZi5hY3RpdmVTdHlsZSxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIGdldElzQWN0aXZlID0gX3JlZi5pc0FjdGl2ZSxcbiAgICAgIGFyaWFDdXJyZW50ID0gX3JlZi5hcmlhQ3VycmVudCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWyd0bycsICdleGFjdCcsICdzdHJpY3QnLCAnbG9jYXRpb24nLCAnYWN0aXZlQ2xhc3NOYW1lJywgJ2NsYXNzTmFtZScsICdhY3RpdmVTdHlsZScsICdzdHlsZScsICdpc0FjdGl2ZScsICdhcmlhQ3VycmVudCddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge1xuICAgIHBhdGg6ICh0eXBlb2YgdG8gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRvKSkgPT09ICdvYmplY3QnID8gdG8ucGF0aG5hbWUgOiB0byxcbiAgICBleGFjdDogZXhhY3QsXG4gICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihfcmVmMikge1xuICAgICAgdmFyIGxvY2F0aW9uID0gX3JlZjIubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2ggPSBfcmVmMi5tYXRjaDtcblxuICAgICAgdmFyIGlzQWN0aXZlID0gISEoZ2V0SXNBY3RpdmUgPyBnZXRJc0FjdGl2ZShtYXRjaCwgbG9jYXRpb24pIDogbWF0Y2gpO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCBfZXh0ZW5kcyh7XG4gICAgICAgIHRvOiB0byxcbiAgICAgICAgY2xhc3NOYW1lOiBpc0FjdGl2ZSA/IFtjbGFzc05hbWUsIGFjdGl2ZUNsYXNzTmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pLmpvaW4oJyAnKSA6IGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IGlzQWN0aXZlID8gX2V4dGVuZHMoe30sIHN0eWxlLCBhY3RpdmVTdHlsZSkgOiBzdHlsZSxcbiAgICAgICAgJ2FyaWEtY3VycmVudCc6IGlzQWN0aXZlICYmIGFyaWFDdXJyZW50XG4gICAgICB9LCByZXN0KSk7XG4gICAgfVxuICB9KTtcbn07XG5cbk5hdkxpbmsucHJvcFR5cGVzID0ge1xuICB0bzogTGluay5wcm9wVHlwZXMudG8sXG4gIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gIGFjdGl2ZUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhY3RpdmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGlzQWN0aXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgYXJpYUN1cnJlbnQ6IFByb3BUeXBlcy5vbmVPZihbJ3BhZ2UnLCAnc3RlcCcsICdsb2NhdGlvbicsICd0cnVlJ10pXG59O1xuXG5OYXZMaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWN0aXZlQ2xhc3NOYW1lOiAnYWN0aXZlJyxcbiAgYXJpYUN1cnJlbnQ6ICd0cnVlJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2TGluaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHJvbXB0aW5nIHRoZSB1c2VyIGJlZm9yZSBuYXZpZ2F0aW5nIGF3YXlcbiAqIGZyb20gYSBzY3JlZW4gd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUHJvbXB0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb21wdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUHJvbXB0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9tcHQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBQcm9tcHQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykgdGhpcy51bmJsb2NrKCk7XG5cbiAgICB0aGlzLnVuYmxvY2sgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuYmxvY2sobWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB7XG4gICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgIHRoaXMudW5ibG9jayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxQcm9tcHQ+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMud2hlbikgdGhpcy5lbmFibGUodGhpcy5wcm9wcy5tZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMud2hlbikge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLndoZW4gfHwgdGhpcy5wcm9wcy5tZXNzYWdlICE9PSBuZXh0UHJvcHMubWVzc2FnZSkgdGhpcy5lbmFibGUobmV4dFByb3BzLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQcm9tcHQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblByb21wdC5wcm9wVHlwZXMgPSB7XG4gIHdoZW46IFByb3BUeXBlcy5ib29sLFxuICBtZXNzYWdlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLmlzUmVxdWlyZWRcbn07XG5Qcm9tcHQuZGVmYXVsdFByb3BzID0ge1xuICB3aGVuOiB0cnVlXG59O1xuUHJvbXB0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBibG9jazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBQcm9tcHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFByb21wdCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUHJvbXB0JztcblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1Byb21wdC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCB2YXIgYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBoYXNCYXNlbmFtZSA9IGZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXggKyAnKFxcXFwvfFxcXFw/fCN8JCknLCAnaScpLnRlc3QocGF0aCk7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgcGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG5leHBvcnQgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcblxuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgcmVzb2x2ZVBhdGhuYW1lIGZyb20gJ3Jlc29sdmUtcGF0aG5hbWUnO1xuaW1wb3J0IHZhbHVlRXF1YWwgZnJvbSAndmFsdWUtZXF1YWwnO1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSByZXNvbHZlUGF0aG5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbmV4cG9ydCB2YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgdmFsdWVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgd2FybmluZyhwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCB2YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuZXhwb3J0IHZhciBhZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUuYWRkRXZlbnRMaXN0ZW5lciA/IG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbmV4cG9ydCB2YXIgZ2V0Q29uZmlybWF0aW9uID0gZnVuY3Rpb24gZ2V0Q29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cbmV4cG9ydCB2YXIgc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cbmV4cG9ydCB2YXIgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cbmV4cG9ydCB2YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBmdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvcHN0YXRlIGV2ZW50IGlzIGFuIGV4dHJhbmVvdXMgV2ViS2l0IGV2ZW50LlxuICogQWNjb3VudHMgZm9yIHRoZSBmYWN0IHRoYXQgQ2hyb21lIG9uIGlPUyBmaXJlcyByZWFsIHBvcHN0YXRlIGV2ZW50c1xuICogY29udGFpbmluZyB1bmRlZmluZWQgc3RhdGUgd2hlbiBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uXG4gKi9cbmV4cG9ydCB2YXIgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvRE9NVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzSGlzdG9yeSwgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSwgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBMZWFkaW5nU2xhc2gsIHN0cmlwVHJhaWxpbmdTbGFzaCwgaGFzQmFzZW5hbWUsIHN0cmlwQmFzZW5hbWUsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjYW5Vc2VET00sIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGdldENvbmZpcm1hdGlvbiwgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBzdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgdmFyIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgbG9jYXRpb25zQXJlRXF1YWwocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09IGNyZWF0ZVBhdGgobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgodG9Mb2NhdGlvbikpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGZyb21Mb2NhdGlvbikpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gW2NyZWF0ZVBhdGgoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbikpO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG5cbiAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpO1xuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB3YXJuaW5nKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSGFzaEhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBwcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB1bmRlZmluZWQgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBwcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBjcmVhdGVQYXRoO1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IGZyb20gJy4vY3JlYXRlQnJvd3Nlckhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IGFzIGNyZWF0ZUJyb3dzZXJIaXN0b3J5IH07XG5pbXBvcnQgX2NyZWF0ZUhhc2hIaXN0b3J5IGZyb20gJy4vY3JlYXRlSGFzaEhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZUhhc2hIaXN0b3J5IGFzIGNyZWF0ZUhhc2hIaXN0b3J5IH07XG5pbXBvcnQgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgZnJvbSAnLi9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGFzIGNyZWF0ZU1lbW9yeUhpc3RvcnkgfTtcblxuZXhwb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmV4cG9ydCB7IHBhcnNlUGF0aCwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJ2hpc3RvcnknO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciB1cGRhdGluZyB0aGUgbG9jYXRpb24gcHJvZ3JhbW1hdGljYWxseVxuICogd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUmVkaXJlY3QgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVkaXJlY3QsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlZGlyZWN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWRpcmVjdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5pc1N0YXRpYyA9IGZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm91dGVyICYmIHRoaXMuY29udGV4dC5yb3V0ZXIuc3RhdGljQ29udGV4dDtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxSZWRpcmVjdD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICBpZiAodGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcHJldlRvID0gY3JlYXRlTG9jYXRpb24ocHJldlByb3BzLnRvKTtcbiAgICB2YXIgbmV4dFRvID0gY3JlYXRlTG9jYXRpb24odGhpcy5wcm9wcy50byk7XG5cbiAgICBpZiAobG9jYXRpb25zQXJlRXF1YWwocHJldlRvLCBuZXh0VG8pKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnWW91IHRyaWVkIHRvIHJlZGlyZWN0IHRvIHRoZSBzYW1lIHJvdXRlIHlvdVxcJ3JlIGN1cnJlbnRseSBvbjogJyArICgnXCInICsgbmV4dFRvLnBhdGhuYW1lICsgbmV4dFRvLnNlYXJjaCArICdcIicpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIHBlcmZvcm0oKSB7XG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHB1c2ggPSBfcHJvcHMucHVzaCxcbiAgICAgICAgdG8gPSBfcHJvcHMudG87XG5cblxuICAgIGlmIChwdXNoKSB7XG4gICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgIH1cbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZWRpcmVjdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVkaXJlY3QucHJvcFR5cGVzID0ge1xuICBwdXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkXG59O1xuUmVkaXJlY3QuZGVmYXVsdFByb3BzID0ge1xuICBwdXNoOiBmYWxzZVxufTtcblJlZGlyZWN0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBwdXNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcmVwbGFjZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJlZGlyZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJlZGlyZWN0IGZyb20gJ3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IFJlZGlyZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JlZGlyZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIGNyZWF0ZVBhdGgsIHBhcnNlUGF0aCB9IGZyb20gJ2hpc3RvcnkvUGF0aFV0aWxzJztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG52YXIgbm9ybWFsaXplTG9jYXRpb24gPSBmdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbihvYmplY3QpIHtcbiAgdmFyIF9vYmplY3QkcGF0aG5hbWUgPSBvYmplY3QucGF0aG5hbWUsXG4gICAgICBwYXRobmFtZSA9IF9vYmplY3QkcGF0aG5hbWUgPT09IHVuZGVmaW5lZCA/ICcvJyA6IF9vYmplY3QkcGF0aG5hbWUsXG4gICAgICBfb2JqZWN0JHNlYXJjaCA9IG9iamVjdC5zZWFyY2gsXG4gICAgICBzZWFyY2ggPSBfb2JqZWN0JHNlYXJjaCA9PT0gdW5kZWZpbmVkID8gJycgOiBfb2JqZWN0JHNlYXJjaCxcbiAgICAgIF9vYmplY3QkaGFzaCA9IG9iamVjdC5oYXNoLFxuICAgICAgaGFzaCA9IF9vYmplY3QkaGFzaCA9PT0gdW5kZWZpbmVkID8gJycgOiBfb2JqZWN0JGhhc2g7XG5cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgYWRkQmFzZW5hbWUgPSBmdW5jdGlvbiBhZGRCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKSArIGxvY2F0aW9uLnBhdGhuYW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgdmFyIGJhc2UgPSBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpO1xuXG4gIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2UpICE9PSAwKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHIoYmFzZS5sZW5ndGgpXG4gIH0pO1xufTtcblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgobG9jYXRpb24pIDogbm9ybWFsaXplTG9jYXRpb24obG9jYXRpb24pO1xufTtcblxudmFyIGNyZWF0ZVVSTCA9IGZ1bmN0aW9uIGNyZWF0ZVVSTChsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/IGxvY2F0aW9uIDogY3JlYXRlUGF0aChsb2NhdGlvbik7XG59O1xuXG52YXIgc3RhdGljSGFuZGxlciA9IGZ1bmN0aW9uIHN0YXRpY0hhbmRsZXIobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGludmFyaWFudChmYWxzZSwgJ1lvdSBjYW5ub3QgJXMgd2l0aCA8U3RhdGljUm91dGVyPicsIG1ldGhvZE5hbWUpO1xuICB9O1xufTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbi8qKlxuICogVGhlIHB1YmxpYyB0b3AtbGV2ZWwgQVBJIGZvciBhIFwic3RhdGljXCIgPFJvdXRlcj4sIHNvLWNhbGxlZCBiZWNhdXNlIGl0XG4gKiBjYW4ndCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnQgbG9jYXRpb24uIEluc3RlYWQsIGl0IGp1c3QgcmVjb3Jkc1xuICogbG9jYXRpb24gY2hhbmdlcyBpbiBhIGNvbnRleHQgb2JqZWN0LiBVc2VmdWwgbWFpbmx5IGluIHRlc3RpbmcgYW5kXG4gKiBzZXJ2ZXItcmVuZGVyaW5nIHNjZW5hcmlvcy5cbiAqL1xuXG52YXIgU3RhdGljUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0YXRpY1JvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGljUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGljUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nU2xhc2goX3RoaXMucHJvcHMuYmFzZW5hbWUgKyBjcmVhdGVVUkwocGF0aCkpO1xuICAgIH0sIF90aGlzLmhhbmRsZVB1c2ggPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gJ1BVU0gnO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlUmVwbGFjZSA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wczIuY29udGV4dDtcblxuICAgICAgY29udGV4dC5hY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVMaXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGhpcy5oYW5kbGVCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjoge1xuICAgICAgICBzdGF0aWNDb250ZXh0OiB0aGlzLnByb3BzLmNvbnRleHRcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxTdGF0aWNSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgU3RhdGljUm91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmFzZW5hbWUgPSBfcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgIGNvbnRleHQgPSBfcHJvcHMuY29udGV4dCxcbiAgICAgICAgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydiYXNlbmFtZScsICdjb250ZXh0JywgJ2xvY2F0aW9uJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB7XG4gICAgICBjcmVhdGVIcmVmOiB0aGlzLmNyZWF0ZUhyZWYsXG4gICAgICBhY3Rpb246ICdQT1AnLFxuICAgICAgbG9jYXRpb246IHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSksXG4gICAgICBwdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICByZXBsYWNlOiB0aGlzLmhhbmRsZVJlcGxhY2UsXG4gICAgICBnbzogc3RhdGljSGFuZGxlcignZ28nKSxcbiAgICAgIGdvQmFjazogc3RhdGljSGFuZGxlcignZ29CYWNrJyksXG4gICAgICBnb0ZvcndhcmQ6IHN0YXRpY0hhbmRsZXIoJ2dvRm9yd2FyZCcpLFxuICAgICAgbGlzdGVuOiB0aGlzLmhhbmRsZUxpc3RlbixcbiAgICAgIGJsb2NrOiB0aGlzLmhhbmRsZUJsb2NrXG4gICAgfTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7IGhpc3Rvcnk6IGhpc3RvcnkgfSkpO1xuICB9O1xuXG4gIHJldHVybiBTdGF0aWNSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblN0YXRpY1JvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSlcbn07XG5TdGF0aWNSb3V0ZXIuZGVmYXVsdFByb3BzID0ge1xuICBiYXNlbmFtZTogJycsXG4gIGxvY2F0aW9uOiAnLydcbn07XG5TdGF0aWNSb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRpY1JvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgU3RhdGljUm91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3RhdGljUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyB0aGUgZmlyc3QgPFJvdXRlPiB0aGF0IG1hdGNoZXMuXG4gKi9cblxudmFyIFN3aXRjaCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTd2l0Y2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN3aXRjaCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3dpdGNoKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFN3aXRjaD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcbiAgfTtcblxuICBTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uO1xuXG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICBjaGlsZCA9IHZvaWQgMDtcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2VsZW1lbnQkcHJvcHMgPSBlbGVtZW50LnByb3BzLFxuICAgICAgICAgIHBhdGhQcm9wID0gX2VsZW1lbnQkcHJvcHMucGF0aCxcbiAgICAgICAgICBleGFjdCA9IF9lbGVtZW50JHByb3BzLmV4YWN0LFxuICAgICAgICAgIHN0cmljdCA9IF9lbGVtZW50JHByb3BzLnN0cmljdCxcbiAgICAgICAgICBzZW5zaXRpdmUgPSBfZWxlbWVudCRwcm9wcy5zZW5zaXRpdmUsXG4gICAgICAgICAgZnJvbSA9IF9lbGVtZW50JHByb3BzLmZyb207XG5cbiAgICAgIHZhciBwYXRoID0gcGF0aFByb3AgfHwgZnJvbTtcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBlbGVtZW50O1xuICAgICAgICBtYXRjaCA9IHBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgZXhhY3Q6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSkgOiByb3V0ZS5tYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaCA/IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgeyBsb2NhdGlvbjogbG9jYXRpb24sIGNvbXB1dGVkTWF0Y2g6IG1hdGNoIH0pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU3dpdGNoO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Td2l0Y2guY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuU3dpdGNoLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN3aXRjaCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3dpdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9hcHBzL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGgnO1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IFJvdXRlIGZyb20gJy4vUm91dGUnO1xuXG4vKipcbiAqIEEgcHVibGljIGhpZ2hlci1vcmRlciBjb21wb25lbnQgdG8gYWNjZXNzIHRoZSBpbXBlcmF0aXZlIEFQSVxuICovXG52YXIgd2l0aFJvdXRlciA9IGZ1bmN0aW9uIHdpdGhSb3V0ZXIoQ29tcG9uZW50KSB7XG4gIHZhciBDID0gZnVuY3Rpb24gQyhwcm9wcykge1xuICAgIHZhciB3cmFwcGVkQ29tcG9uZW50UmVmID0gcHJvcHMud3JhcHBlZENvbXBvbmVudFJlZixcbiAgICAgICAgcmVtYWluaW5nUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFsnd3JhcHBlZENvbXBvbmVudFJlZiddKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7IHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJvdXRlQ29tcG9uZW50UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcmVtYWluaW5nUHJvcHMsIHJvdXRlQ29tcG9uZW50UHJvcHMsIHsgcmVmOiB3cmFwcGVkQ29tcG9uZW50UmVmIH0pKTtcbiAgICAgIH0gfSk7XG4gIH07XG5cbiAgQy5kaXNwbGF5TmFtZSA9ICd3aXRoUm91dGVyKCcgKyAoQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lKSArICcpJztcbiAgQy5XcmFwcGVkQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICBDLnByb3BUeXBlcyA9IHtcbiAgICB3cmFwcGVkQ29tcG9uZW50UmVmOiBQcm9wVHlwZXMuZnVuY1xuICB9O1xuXG4gIHJldHVybiBob2lzdFN0YXRpY3MoQywgQ29tcG9uZW50KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2FwcHMvbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy93aXRoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCB3aXRoUm91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy93aXRoUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gJy4vQnJvd3NlclJvdXRlcic7XG5leHBvcnQgeyBfQnJvd3NlclJvdXRlciBhcyBCcm93c2VyUm91dGVyIH07XG5pbXBvcnQgX0hhc2hSb3V0ZXIgZnJvbSAnLi9IYXNoUm91dGVyJztcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfTmF2TGluayBmcm9tICcuL05hdkxpbmsnO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvYXBwcy9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2J1dHRvbi5zY3NzJztcblxuY29uc3QgY3ggPSBjbGFzc25hbWVzLmJpbmQoc3R5bGUpO1xuXG50eXBlIFRCdXR0b25Qcm9wcyA9IEpTWC5IVE1MQXR0cmlidXRlcyAmIHtcbiAgc2Vjb25kYXJ5PzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IEJ1dHRvbiA9ICh7IGNsYXNzOiBjbGFzc05hbWUsIHNlY29uZGFyeSA9IGZhbHNlLCAuLi5yZXN0UHJvcHMgfTogVEJ1dHRvblByb3BzKSA9PiAoXG4gIDxidXR0b24gY2xhc3M9e2N4KHN0eWxlLnNlbGYsIGNsYXNzTmFtZSwgeyBwcmltYXJ5OiAhc2Vjb25kYXJ5LCBzZWNvbmRhcnkgfSl9IHsuLi5yZXN0UHJvcHN9IC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvQnV0dG9uLnRzeCIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG5pbXBvcnQgQnV0dG9uIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9CdXR0b24nO1xuXG5jb25zdCBIb21lID0gKCkgPT4gKFxuICA8ZGl2PlxuICAgIDxMaW5rIHRvPVwiL3doaXRlbGlzdFwiPjxCdXR0b24+V2hpdGVsaXN0PC9CdXR0b24+PC9MaW5rPlxuICAgIDxMaW5rIHRvPVwiL3N0YXR1c1wiPjxCdXR0b24+U3RhdHVzPC9CdXR0b24+PC9MaW5rPlxuICAgIDxMaW5rIHRvPVwiL2xpbmtsaXN0XCI+PEJ1dHRvbj5MaW5rTGlzdDwvQnV0dG9uPjwvTGluaz5cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BhZ2VzL0hvbWUudHN4IiwiaW1wb3J0ICogYXMgV2ViMyBmcm9tICd3ZWIzJztcblxubGV0IHdlYjM7XG5cbmlmICh0eXBlb2Ygd2luZG93LndlYjMgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdlYjMgPSBuZXcgV2ViMyh3aW5kb3cud2ViMy5jdXJyZW50UHJvdmlkZXIpO1xufSBlbHNlIHtcbiAgd2ViMyA9IG5ldyBXZWIzKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdlYjM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvdXRpbHMvc3JjL3dlYjMudHMiLCJleHBvcnQgeyBkZWZhdWx0IGFzIHdlYjMgfSBmcm9tICcuL3dlYjMnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL3V0aWxzL3NyYy9pbmRleC50cyIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2JpbmQnO1xuXG5pbXBvcnQgeyBJTGluayB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9saW5rLnNjc3MnO1xuXG5jb25zdCBjeCA9IGNsYXNzbmFtZXMuYmluZChzdHlsZSk7XG5cbmludGVyZmFjZSBJTGlua1Byb3BzIHtcbiAgbGluazogSUxpbms7XG4gIGNsYXNzPzogc3RyaW5nO1xuICBsaW5lcz86IG51bWJlcjtcbiAgc3R5bGU/OiBzdHJpbmcgfCB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgc3RyaW5nfTtcbn1cblxuY29uc3Qgc3RvcFByb3BhZ2F0aW9uID0gKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbmNvbnN0IExpbmsgPSAoeyBjbGFzczogY2xhc3NOYW1lLCBsaW5rLCBsaW5lcyA9IDIsIHN0eWxlOiBleHRlcm5hbFN0eWxlIH06IElMaW5rUHJvcHMpID0+IHtcbiAgaWYgKCEobGluZXMgPT09IDIgfHwgbGluZXMgPT09IDgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDIgYW5kIDggbGluZXMgbGlua3MgYXJlIGF2YWlsYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPXtjbGFzc25hbWVzKHN0eWxlLnNlbGYsIGNsYXNzTmFtZSl9IHN0eWxlPXtleHRlcm5hbFN0eWxlfT5cbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnRpdGxlfT57bGluay50aXRsZX08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9e2N4KCdzdW1tYXJ5JywgeyBsaW5lczI6IGxpbmVzID09PSAyLCBsaW5lczg6IGxpbmVzID09PSA4IH0pfT57bGluay5zdW1tYXJ5fTwvZGl2PlxuICAgICAgPGFcbiAgICAgICAgY2xhc3M9e3N0eWxlLmxpbmt9XG4gICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgIGhyZWY9e2xpbmsudGFyZ2V0fVxuICAgICAgICBvbkNsaWNrPXtzdG9wUHJvcGFnYXRpb259XG4gICAgICA+XG4gICAgICAgIHtsaW5rLnRhcmdldH1cbiAgICAgIDwvYT5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExpbms7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTGluay50c3giLCJpbXBvcnQgeyBoLCBGdW5jdGlvbmFsQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vcGFwZXIuc2Nzcyc7XG5cbmNvbnN0IFBhcGVyOiBGdW5jdGlvbmFsQ29tcG9uZW50PEpTWC5IVE1MQXR0cmlidXRlcz4gPSAoeyBjbGFzczogY2xhc3NOYW1lLCAuLi5yZXN0UHJvcHMgfSkgPT4gKFxuICA8ZGl2IHsuLi5yZXN0UHJvcHN9IGNsYXNzPXtjbGFzc25hbWVzKGNsYXNzTmFtZSwgc3R5bGUuc2VsZil9IC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBQYXBlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9QYXBlci50c3giLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vbG9hZGVyLnNjc3MnO1xuXG5pbnRlcmZhY2UgSUxvYWRlclByb3BzIHtcbiAgY2xhc3M/OiBzdHJpbmc7XG59XG5cbmNvbnN0IExvYWRlciA9ICh7IGNsYXNzOiBjbGFzc05hbWV9OiBJTG9hZGVyUHJvcHMpID0+IHtcbiAgcmV0dXJuIDxkaXYgY2xhc3M9e2NsYXNzbmFtZXMoc3R5bGUuc2VsZiwgY2xhc3NOYW1lKX0gLz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2FkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvTG9hZGVyLnRzeCIsImltcG9ydCB7IGgsIEZ1bmN0aW9uYWxDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2xhYmVsLnNjc3MnO1xuXG5jb25zdCBMYWJlbDogRnVuY3Rpb25hbENvbXBvbmVudDx7fT4gPSAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIDxwIGNsYXNzPXtzdHlsZS5zZWxmfT57cHJvcHMuY2hpbGRyZW59PC9wPjtcbiAgfVxuXG4gIHJldHVybiA8cCBjbGFzcz17c3R5bGUuc2VsZn0gLz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYWJlbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9MYWJlbC50c3giLCJpbXBvcnQgeyBoLCBGdW5jdGlvbmFsQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vdGV4dFdpdGhMYWJlbC5zY3NzJztcblxuaW1wb3J0IExhYmVsIGZyb20gJy4vTGFiZWwnO1xuXG5pbnRlcmZhY2UgSVRleHRXaXRoTGFiZWxQcm9wcyB7XG4gIGxhYmVsOiBzdHJpbmcgfEpTWC5FbGVtZW50O1xuICB0ZXh0Pzogc3RyaW5nIHwgbnVtYmVyO1xuICBjbGFzcz86IHN0cmluZztcbn1cblxuY29uc3QgVGV4dFdpdGhMYWJlbDogRnVuY3Rpb25hbENvbXBvbmVudDxJVGV4dFdpdGhMYWJlbFByb3BzPiA9ICh7IGxhYmVsLCB0ZXh0LCBjbGFzczogY2xhc3NOYW1lLCBjaGlsZHJlbiB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz17Y2xhc3NuYW1lcyhzdHlsZS5zZWxmLCBjbGFzc05hbWUpfT5cbiAgICAgIDxMYWJlbD57bGFiZWx9PC9MYWJlbD5cbiAgICAgIDxwIGNsYXNzPXtzdHlsZS50ZXh0fT57dGV4dCB8fCBjaGlsZHJlbn08L3A+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0V2l0aExhYmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1RleHRXaXRoTGFiZWwudHN4IiwiaW1wb3J0IHsgaCwgRnVuY3Rpb25hbENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IGdldFN2Z0NvbnRlbnRSZWd4cCA9IC88c3ZnW14+XSo+KC4qKTxcXC9zdmc+LztcblxuaW50ZXJmYWNlIElTdmdQcm9wcyB7XG4gIGNsYXNzPzogc3RyaW5nO1xuICBzdmc6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyIHwgc3RyaW5nO1xuICB2aWV3Qm94OiBzdHJpbmc7XG59XG5cbmNvbnN0IFN2ZyA9ICh7IHN2Zywgc2l6ZSwgdmlld0JveCwgY2xhc3M6IGNsYXNzTmFtZSB9OiBJU3ZnUHJvcHMpID0+IHtcbiAgbGV0IHN2Z0NvbnRlbnQ7XG4gIGNvbnN0IHJlZ2V4cFJlc3VsdCA9IGdldFN2Z0NvbnRlbnRSZWd4cC5leGVjKHN2Zyk7XG4gIGlmIChyZWdleHBSZXN1bHQpIHtcbiAgICBzdmdDb250ZW50ID0gcmVnZXhwUmVzdWx0WzFdO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzcz17Y2xhc3NOYW1lfVxuICAgICAgc3R5bGU9e3sgd2lkdGg6IHNpemUgfX1cbiAgICAgIGFsdD17bmFtZX1cbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogc3ZnQ29udGVudCB9fVxuICAgICAgdmlld0JveD17dmlld0JveH1cbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgIC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTdmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvU3ZnLnRzeCIsImltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCAnb3Blbi1pY29uaWMvZm9udC9jc3Mvb3Blbi1pY29uaWMubWluLmNzcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vaWNvbi5zY3NzJztcblxuaW50ZXJmYWNlIElJY29uUHJvcHMge1xuICBuYW1lOiBzdHJpbmc7XG4gIGNsYXNzPzogc3RyaW5nO1xufVxuXG5jb25zdCBJY29uID0gKHsgbmFtZSwgY2xhc3M6IGNsYXNzTmFtZSwgLi4ucmVzdFByb3BzIH06IElJY29uUHJvcHMpID0+IChcbiAgPHNwYW4gY2xhc3M9e2NsYXNzbmFtZXMoc3R5bGUuc2VsZiwgY2xhc3NOYW1lLCAnb2knKX0gZGF0YS1nbHlwaD17bmFtZX0gYXJpYS1oaWRkZW49XCJ0cnVlXCIgey4uLnJlc3RQcm9wc30gLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvSWNvbi50c3giLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vdG9vbHRpcC5zY3NzJztcblxuaW50ZXJmYWNlIElUb29sdGlwUHJvcHMge1xuICB0ZXh0Pzogc3RyaW5nO1xuICBjaGlsZHJlbj86IEpTWC5FbGVtZW50O1xuICBjbGFzcz86IHN0cmluZztcbiAgc3R5bGU/OiBzdHJpbmcgfCB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IHN0cmluZyB9O1xufVxuXG5jb25zdCBUb29sdGlwID0gKHsgY2xhc3M6IGNsYXNzTmFtZSwgc3R5bGU6IGV4dGVybmFsU3R5bGUsIHRleHQsIGNoaWxkcmVuIH06IElUb29sdGlwUHJvcHMpID0+IChcbiAgPGRpdiBzdHlsZT17ZXh0ZXJuYWxTdHlsZX0gY2xhc3M9e2NsYXNzbmFtZXMoc3R5bGUuc2VsZiwgY2xhc3NOYW1lKX0+XG4gICAge2NoaWxkcmVufVxuICAgIHt0ZXh0ICYmIDxkaXYgY2xhc3M9e3N0eWxlLnRleHR9Pnt0ZXh0fTwvZGl2Pn1cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL1Rvb2x0aXAudHN4IiwiaW1wb3J0IHsgaCwgRnVuY3Rpb25hbENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMvYmluZCc7XG5cbmltcG9ydCBTdmcgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL1N2Zyc7XG5pbXBvcnQgSWNvbiBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvSWNvbic7XG5pbXBvcnQgVG9vbHRpcCBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvVG9vbHRpcCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vc3RlcHMuc2Nzcyc7XG5jb25zdCBjeCA9IGNsYXNzbmFtZXMuYmluZChzdHlsZSk7XG5cbmNvbnN0IGN1YmVTdmcgPSByZXF1aXJlKCchIXN2Zy1pbmxpbmUtbG9hZGVyP3JlbW92ZVRhZ3M9dHJ1ZSZyZW1vdmVTVkdUYWdBdHRycz10cnVlIS4uLy4uLy4uLy4uL2ltYWdlcy9jdWJlLnN2ZycpO1xuXG5pbnRlcmZhY2UgSVN0ZXBQcm9wcyB7XG4gIGljb246IEpTWC5FbGVtZW50O1xuICBzdGF0ZTogJ2Rpc2FibGVkJyB8ICd3YWl0aW5nJyB8ICdkb25lJztcbn1cblxuY29uc3QgU3RlcDogRnVuY3Rpb25hbENvbXBvbmVudDxJU3RlcFByb3BzPiA9ICh7IGljb24sIHN0YXRlLCBjaGlsZHJlbiB9KSA9PiAoXG4gIDxkaXYgY2xhc3M9e2N4KHN0eWxlLnN0ZXAsIHsgW3N0YXRlXTogdHJ1ZSB9KX0+XG4gICAgPGRpdiBjbGFzcz17c3R5bGUuaWNvbn0+e2ljb259PC9kaXY+XG4gICAgPGRpdiBjbGFzcz17c3R5bGUuY29udGVudH0+e2NoaWxkcmVufTwvZGl2PlxuICA8L2Rpdj5cbik7XG5cbmludGVyZmFjZSBJU3RlcHNQcm9wcyB7XG4gIGNvbnRleHQ6IHN0cmluZztcbiAgbGlua0lkOiBzdHJpbmc7XG4gIGxpbms/OiBhbnk7XG4gIGJsb2NrY2hhaW5TdGF0ZToge1xuICAgIHdlYjNBdmFpbGFibGU6IGJvb2xlYW47XG4gICAgYmxvY2tOdW1iZXI6IG51bWJlciB8IG51bGw7XG4gICAgY3VycmVudEJsb2NrTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICB9O1xufVxuXG5jb25zdCBTdGVwcyA9ICh7IGNvbnRleHQsIGxpbmtJZCwgbGluaywgYmxvY2tjaGFpblN0YXRlIH06IElTdGVwc1Byb3BzKSA9PiB7XG4gIGxldCBzdGVwMFN0YXRlO1xuICBsZXQgc3RlcDBSZWFzb247XG4gIGlmIChibG9ja2NoYWluU3RhdGUud2ViM0F2YWlsYWJsZSkge1xuICAgIGlmIChibG9ja2NoYWluU3RhdGUuYmxvY2tOdW1iZXIpIHtcbiAgICAgIHN0ZXAwU3RhdGUgPSAnZG9uZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZXAwU3RhdGUgPSAnd2FpdGluZyc7XG4gICAgICBzdGVwMFJlYXNvbiA9ICdXYWl0aW5nIGZvciBibG9ja2NoYWluJztcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICBzdGVwMFN0YXRlID0gJ2Rpc2FibGVkJztcbiAgICBzdGVwMFJlYXNvbiA9ICdXZWIgaXMgdW5hdmFpbGFibGUnO1xuICB9XG5cbiAgY29uc3Qgc3RlcDFTdGF0ZSA9IGxpbmsgPyAnZG9uZScgOiAnd2FpdGluZyc7XG4gIGNvbnN0IHN0ZXAyU3RhdGUgPSBsaW5rICYmIGxpbmsud2hpdGVsaXN0ZWQgPyAnZG9uZScgOiAnd2FpdGluZyc7XG5cbiAgY29uc3QgW25ldHdvcmtdID0gY29udGV4dC5zcGxpdCgnOicpO1xuICBjb25zdCBuZXR3b3JrUHJlZml4ID0gbmV0d29yayAhPT0gJ2V0aCcgPyBgJHtuZXR3b3JrfS5gIDogJyc7XG4gIGNvbnN0IFssIHR4XSA9IGxpbmtJZC5zcGxpdCgnOicpO1xuICBjb25zdCBldGhlcnNjYW5VcmwgPSBsaW5rID8gYGh0dHBzOi8vJHtuZXR3b3JrUHJlZml4fWV0aGVyc2Nhbi5pby90eC8ke3R4fWAgOiAnJztcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgICAgPGRpdiBjbGFzcz17c3R5bGUucHJvZ3Jlc3NDb3RhaW5lcn0+XG4gICAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnByb2dyZXNzfSAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPXtzdHlsZS5zdGVwc0NvbnRhaW5lcn0+XG4gICAgICAgIDxTdGVwXG4gICAgICAgICAgc3RhdGU9e3N0ZXAwU3RhdGV9XG4gICAgICAgICAgaWNvbj17PFRvb2x0aXAgdGV4dD17c3RlcDBSZWFzb259PjxJY29uIGNsYXNzPXtzdHlsZS5pY29ufSBuYW1lPVwiZXllXCIgLz48L1Rvb2x0aXA+fVxuICAgICAgICA+XG4gICAgICAgICAgPHA+VmlzaWJsZSBvbiBibG9ja2NoYWluPC9wPlxuICAgICAgICAgIDxhIGhyZWY9e2V0aGVyc2NhblVybH0gdGFyZ2V0PVwiX2JsYW5rXCI+RXRoZXJzY2FuIDxJY29uIG5hbWU9XCJleHRlcm5hbC1saW5rXCIgLz48L2E+XG4gICAgICAgIDwvU3RlcD5cbiAgICAgICAgPFN0ZXBcbiAgICAgICAgICBzdGF0ZT17c3RlcDFTdGF0ZX1cbiAgICAgICAgICBpY29uPXs8U3ZnIHN2Zz17Y3ViZVN2Z30gc2l6ZT1cIjEuMmVtXCIgdmlld0JveD1cIjAgMCAyMyAyN1wiIC8+fVxuICAgICAgICA+XG4gICAgICAgICAgPHA+VXNlcmZlZWRzIEFkZHJlc3M8L3A+XG4gICAgICAgICAgPHNwYW4+VmlzaWJsZSB0byBwdWJsaXNoZXI8L3NwYW4+XG4gICAgICAgIDwvU3RlcD5cbiAgICAgICAgPFN0ZXBcbiAgICAgICAgICBzdGF0ZT17c3RlcDJTdGF0ZX1cbiAgICAgICAgICBpY29uPXs8SWNvbiBjbGFzcz17c3R5bGUuaWNvbn0gbmFtZT1cImNoZWNrXCIgLz59XG4gICAgICAgID5cbiAgICAgICAgICA8cD5QdXQgb24gd2hpdGVsaXN0PC9wPlxuICAgICAgICAgIDxzcGFuPkFsbCBzZXQhPC9zcGFuPlxuICAgICAgICA8L1N0ZXA+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0ZXBzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BhZ2VzL1N0YXR1cy9jb21wb25lbnRzL1N0ZXBzLnRzeCIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmltcG9ydCB7IHdlYjMgfSBmcm9tICdAdXNlcmZlZWRzL3V0aWxzJztcbmltcG9ydCBTdmcgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL1N2Zyc7XG5pbXBvcnQgTGluayBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvTGluayc7XG5pbXBvcnQgUGFwZXIgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL1BhcGVyJztcbmltcG9ydCBMb2FkZXIgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL0xvYWRlcic7XG5pbXBvcnQgQnV0dG9uIGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9CdXR0b24nO1xuaW1wb3J0IFRleHRXaXRoTGFiZWwgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL1RleHRXaXRoTGFiZWwnO1xuXG5pbXBvcnQgU3RlcHMgZnJvbSAnLi9jb21wb25lbnRzL1N0ZXBzJztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9TdGF0dXMuc2Nzcyc7XG5cbmNvbnN0IGhlYXJ0U3ZnID0gcmVxdWlyZSgnLi4vLi4vLi4vaW1hZ2VzL2hlYXJ0LnN2ZycpO1xuXG5jb25zdCBnZXRUcmFuc2FjdGlvblJlY2VpcHQgPSAodHg6IHN0cmluZykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdlYjMuZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmNvbnN0IGdldEJsb2NrTnVtYmVyOiAoKSA9PiBQcm9taXNlPG51bWJlcj4gPSAoKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd2ViMy5ldGguZ2V0QmxvY2tOdW1iZXIoKGVycm9yLCBjdXJyZW50QmxvY2tOdW1iZXIpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjdXJyZW50QmxvY2tOdW1iZXIpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmNvbnN0IHdhaXQgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuaW50ZXJmYWNlIElTdGF0dXNQcm9wcyB7XG4gIGxvY2F0aW9uOiBhbnk7XG59XG5cbmludGVyZmFjZSBJU3RhdHVzU3RhdGUge1xuICBsaW5rPzogYW55O1xuICBsaW5rSWQ6IHN0cmluZztcbiAgY29udGV4dDogc3RyaW5nO1xuICBhbGdvcml0aG06IHN0cmluZztcbiAgd2hpdGVsaXN0OiBzdHJpbmc7XG4gIHB1Ymxpc2hlck5vdGU6IHN0cmluZztcbiAgd2lkZ2V0TG9jYXRpb246IHN0cmluZztcbiAgYmxvY2tjaGFpbjoge1xuICAgIHdlYjNBdmFpbGFibGU6IGJvb2xlYW47XG4gICAgYmxvY2tOdW1iZXI6IG51bWJlciB8IG51bGw7XG4gICAgY3VycmVudEJsb2NrTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0dXMgZXh0ZW5kcyBDb21wb25lbnQ8SVN0YXR1c1Byb3BzLCBJU3RhdHVzU3RhdGU+IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHByb3BzLmxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gcGFyYW1zLmdldCgnY29udGV4dCcpIHx8ICcnO1xuICAgIGNvbnN0IGFsZ29yaXRobSA9IHBhcmFtcy5nZXQoJ2FsZ29yaXRobScpIHx8ICcnO1xuICAgIGNvbnN0IHdoaXRlbGlzdCA9IHBhcmFtcy5nZXQoJ3doaXRlbGlzdCcpIHx8ICcnO1xuICAgIGNvbnN0IGxpbmtJZCA9IHBhcmFtcy5nZXQoJ2xpbmtJZCcpIHx8ICcnO1xuICAgIGNvbnN0IHB1Ymxpc2hlck5vdGUgPSBwYXJhbXMuZ2V0KCdwdWJsaXNoZXJOb3RlJykgfHwgJyc7XG4gICAgY29uc3Qgd2lkZ2V0TG9jYXRpb24gPSBwYXJhbXMuZ2V0KCd3aWRnZXRMb2NhdGlvbicpIHx8ICcnO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxpbmtJZCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBhbGdvcml0aG0sXG4gICAgICB3aGl0ZWxpc3QsXG4gICAgICBwdWJsaXNoZXJOb3RlLFxuICAgICAgd2lkZ2V0TG9jYXRpb24sXG4gICAgICBibG9ja2NoYWluOiB7XG4gICAgICAgIHdlYjNBdmFpbGFibGU6IGZhbHNlLFxuICAgICAgICBibG9ja051bWJlcjogbnVsbCxcbiAgICAgICAgY3VycmVudEJsb2NrTnVtYmVyOiBudWxsLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgdGhpcy5fb2JzZXJ2ZUJsb2NrY2hhaW5TdGF0ZShsaW5rSWQpO1xuICAgIHRoaXMuX2ZldGNoTGlua3MoY29udGV4dCwgYWxnb3JpdGhtLCB3aGl0ZWxpc3QpXG4gICAgICAudGhlbih0aGlzLl9maW5kTGlua0J5SWQobGlua0lkKSlcbiAgICAgIC50aGVuKChsaW5rKSA9PiB7XG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIGNvbnN0IHNldFRpbWVvdXRGb3JGZXRjaCA9ICgpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9mZXRjaExpbmtzKGNvbnRleHQsIGFsZ29yaXRobSwgd2hpdGVsaXN0KVxuICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuX2ZpbmRMaW5rQnlJZChsaW5rSWQpKVxuICAgICAgICAgICAgICAgIC50aGVuKChsaW5rKSA9PiAhbGluayAmJiBzZXRUaW1lb3V0Rm9yRmV0Y2goKSk7XG4gICAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2V0VGltZW91dEZvckZldGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5jb250ZXh0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxpbmtJZCwgY29udGV4dCwgbGluaywgYmxvY2tjaGFpbiwgd2lkZ2V0TG9jYXRpb24gfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgICAgICA8UGFwZXIgY2xhc3M9e3N0eWxlLnByZXZpZXd9PlxuICAgICAgICAgIHtsaW5rICYmIDxMaW5rIGxpbms9e2xpbmt9IC8+fVxuICAgICAgICAgIHshbGluayAmJiA8ZGl2IGNsYXNzPXtzdHlsZS5sb2FkZXJ9PjxMb2FkZXIgLz48L2Rpdj59XG4gICAgICAgIDwvUGFwZXI+XG4gICAgICAgIDxQYXBlciBjbGFzcz17c3R5bGUuY29udGVudH0+XG4gICAgICAgICAgPGltZyBzcmM9e2hlYXJ0U3ZnfSAvPlxuICAgICAgICAgIDxoMj5Zb3VyIGxpbmsgaGFzIGJlZW4gc3VjY2VzZnVsbHkgc3VibWl0ZWQhPC9oMj5cbiAgICAgICAgICA8cD5JbiBvcmRlciB0byB0cmFjayBpdHMgcHJvZ3Jlc3MgcGxlYXNlIHNhdmUgdGhlIGxpbms8L3A+XG4gICAgICAgICAgPFRleHRXaXRoTGFiZWwgY2xhc3M9e3N0eWxlLmxhYmVsfSBsYWJlbD1cIkxpbmsgc3RhdHVzOlwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz17c3R5bGUubGlua0xhYmVsfT5cbiAgICAgICAgICAgICAgPGEgY2xhc3M9e3N0eWxlLmxpbmt9IGhyZWY9e3dpbmRvdy5sb2NhdGlvbi5ocmVmfT57d2luZG93LmxvY2F0aW9uLmhyZWZ9PC9hPlxuICAgICAgICAgICAgICA8QnV0dG9uIHNlY29uZGFyeSBjbGFzcz17c3R5bGUuYWRkQm9va21hcmt9PkFkZCB0byBib29rbWFya3M8L0J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvVGV4dFdpdGhMYWJlbD5cbiAgICAgICAgICA8VGV4dFdpdGhMYWJlbCBjbGFzcz17c3R5bGUubGFiZWx9IGxhYmVsPVwiV2lkZ2V0IGxvY2F0aW9uOlwiPlxuICAgICAgICAgICAgPGEgaHJlZj17d2lkZ2V0TG9jYXRpb259Pnt3aWRnZXRMb2NhdGlvbn08L2E+XG4gICAgICAgICAgPC9UZXh0V2l0aExhYmVsPlxuICAgICAgICAgIDxTdGVwc1xuICAgICAgICAgICAgbGlua0lkPXtsaW5rSWR9XG4gICAgICAgICAgICBjb250ZXh0PXtjb250ZXh0fVxuICAgICAgICAgICAgbGluaz17bGlua31cbiAgICAgICAgICAgIGJsb2NrY2hhaW5TdGF0ZT17YmxvY2tjaGFpbn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L1BhcGVyPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIF9mZXRjaExpbmtzID0gYXN5bmMgKGNvbnRleHQsIGFsZ29yaXRobSwgd2hpdGVsaXN0KSA9PiB7XG4gICAgY29uc3QgYmFzZVVSTCA9ICdodHRwczovL2FwaS51c2VyZmVlZHMuaW8vcmFua2luZyc7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsTGlua3NSZXF1ZXN0ID0gZmV0Y2goYCR7YmFzZVVSTH0vJHtjb250ZXh0fS8ke2FsZ29yaXRobX0vYClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG4gICAgICBjb25zdCB3aGl0ZWxpc3RlZExpbmtzUmVxdWVzdCA9IGZldGNoKGAke2Jhc2VVUkx9LyR7Y29udGV4dH0vJHthbGdvcml0aG19Lz93aGl0ZWxpc3Q9JHt3aGl0ZWxpc3R9YClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG5cbiAgICAgIGNvbnN0IFthbGxMaW5rcywgd2hpdGVsaXN0ZWRMaW5rc10gPSBhd2FpdCBQcm9taXNlLmFsbChbYWxsTGlua3NSZXF1ZXN0LFxuICAgICAgICB3aGl0ZWxpc3RlZExpbmtzUmVxdWVzdF0pO1xuICAgICAgY29uc3QgbGlua3MgPSBhbGxMaW5rcy5pdGVtcy5tYXAoKGxpbmspID0+IHtcbiAgICAgICAgY29uc3Qgd2hpdGVsaXN0ZWQgPSB3aGl0ZWxpc3RlZExpbmtzLml0ZW1zLmZpbmQoKGEpID0+IGxpbmsuaWQgPT09IGEuaWQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubGluayxcbiAgICAgICAgICB3aGl0ZWxpc3RlZDogISF3aGl0ZWxpc3RlZCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbGlua3M7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIF9vYnNlcnZlQmxvY2tjaGFpblN0YXRlID0gYXN5bmMgKGxpbmtJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF3ZWIzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHsgYmxvY2tjaGFpbjogeyAuLi50aGlzLnN0YXRlLmJsb2NrY2hhaW4sIHdlYjNBdmFpbGFibGU6IGZhbHNlIH19KTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGJsb2NrY2hhaW46IHsgLi4udGhpcy5zdGF0ZS5ibG9ja2NoYWluLCB3ZWIzQXZhaWxhYmxlOiB0cnVlIH19KTtcblxuICAgIGNvbnN0IFssIHR4XSA9IGxpbmtJZC5zcGxpdCgnOicpO1xuXG4gICAgbGV0IHJlY2VpcHQ7XG4gICAgZG8ge1xuICAgICAgcmVjZWlwdCA9IGF3YWl0IGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eCk7XG4gICAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgIH0gd2hpbGUgKCFyZWNlaXB0KTtcblxuICAgIGNvbnN0IGN1cnJlbnRCbG9ja051bWJlciA9IGF3YWl0IGdldEJsb2NrTnVtYmVyKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBibG9ja2NoYWluOiB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUuYmxvY2tjaGFpbixcbiAgICAgICAgYmxvY2tOdW1iZXI6IHJlY2VpcHQuYmxvY2tOdW1iZXIsXG4gICAgICAgIGN1cnJlbnRCbG9ja051bWJlcixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgYXdhaXQgd2FpdCgxMDAwMCk7XG4gICAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBhd2FpdCBnZXRCbG9ja051bWJlcigpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGJsb2NrY2hhaW46IHsgLi4udGhpcy5zdGF0ZS5ibG9ja2NoYWluLCBjdXJyZW50QmxvY2tOdW1iZXIgfX0pO1xuICAgIH1cbiAgfVxuXG4gIF9maW5kTGlua0J5SWQgPSAobGlua0lkKSA9PiAobGlua3MpID0+IHtcbiAgICBjb25zdCBsaW5rID0gbGlua3MuZmluZCgobCkgPT4gbC5pZCA9PT0gbGlua0lkKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgbGluayB9KTtcblxuICAgIHJldHVybiBsaW5rO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGFnZXMvU3RhdHVzL2luZGV4LnRzeCIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMvYmluZCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vaW5wdXQuc2Nzcyc7XG5cbmNvbnN0IGN4ID0gY2xhc3NuYW1lcy5iaW5kKHN0eWxlKTtcblxudHlwZSBUSW5wdXRQcm9wcyA9IEpTWC5IVE1MQXR0cmlidXRlcyAmIHtcbiAgcGxhY2Vob2xkZXI6IHN0cmluZztcbiAgbXVsdGlsaW5lPzogYm9vbGVhbjtcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQ8VElucHV0UHJvcHMsIHt9PiB7XG5cbiAgaW5wdXQ6IHtcbiAgICBmb2N1cygpOiB2b2lkO1xuICB9IHwgdW5kZWZpbmVkO1xuXG4gIHJlbmRlcih7IGNsYXNzOiBjbGFzc05hbWUsIHBsYWNlaG9sZGVyLCBlcnJvck1lc3NhZ2UsIHZhbHVlLCBtdWx0aWxpbmUsIGRpc2FibGVkID0gZmFsc2UsIC4uLnJlc3RQcm9wcyB9XG4gICAgOiBUSW5wdXRQcm9wcykge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPXtjeChzdHlsZS5zZWxmLCBjbGFzc05hbWUsIHsgaW52YWxpZDogISFlcnJvck1lc3NhZ2UgfSl9PlxuICAgICAgICB7IW11bHRpbGluZSA/IChcbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHJlZj17dGhpcy5fb25JbnB1dFJlZn1cbiAgICAgICAgICAgIGNsYXNzPXtzdHlsZS5pbnB1dH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICB7Li4ucmVzdFByb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICByZWY9e3RoaXMuX29uSW5wdXRSZWZ9XG4gICAgICAgICAgICBjbGFzcz17c3R5bGUuaW5wdXR9XG4gICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgcm93cz17M31cbiAgICAgICAgICAgIHsuLi5yZXN0UHJvcHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgICAgPHNwYW4gY2xhc3M9e3N0eWxlLnBsYWNlaG9sZGVyfSBvbkNsaWNrPXt0aGlzLl9vblBsYWNlaG9sZGVyQ2xpY2t9PntwbGFjZWhvbGRlcn08L3NwYW4+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiYgPHNwYW4gY2xhc3M9e3N0eWxlLmVycm9yfT57ZXJyb3JNZXNzYWdlfTwvc3Bhbj59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgX29uSW5wdXRSZWYgPSAocmVmKSA9PiB0aGlzLmlucHV0ID0gcmVmO1xuXG4gIF9vblBsYWNlaG9sZGVyQ2xpY2sgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuaW5wdXQpIHtcbiAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvYXBwcy9wYWNrYWdlcy9jb21wb25lbnRzL3NyYy9JbnB1dC50c3giLCJpbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCBCdXR0b24gZnJvbSAnLi9CdXR0b24nO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL2Fkc0xpc3Quc2Nzcyc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiBudWxsO1xuXG5pbnRlcmZhY2UgSUFkUHJvcHMge1xuICBhZDogYW55O1xuICBvbkNsaWNrKGl0ZW06IGFueSk6IHZvaWQ7XG59XG5cbmNvbnN0IEFkID0gKHsgYWQsIG9uQ2xpY2sgfTogSUFkUHJvcHMpID0+IChcbiAgPGRpdiBjbGFzcz17c3R5bGUucm93fT5cbiAgICA8ZGl2PlxuICAgICAgPGRpdj5VUkw6IDxhIGhyZWY9e2FkLnRhcmdldH0+e2FkLnRhcmdldH08L2E+PC9kaXY+XG4gICAgICA8ZGl2PnNjb3JlOiB7d2ViMy5mcm9tV2VpKGFkLnNjb3JlLCAnZXRoZXInKX08L2Rpdj5cbiAgICAgIDxkaXY+e2FkLnRpdGxlfTwvZGl2PlxuICAgICAgPGRpdj57YWQuc3VtbWFyeX08L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPXtzdHlsZS5idXR0b259PlxuICAgICAgPEJ1dHRvblxuICAgICAgICBvbkNsaWNrPXtvbkNsaWNrLmJpbmQobnVsbCwgYWQpfVxuICAgICAgICBkaXNhYmxlZD17YWQud2hpdGVsaXN0ZWR9XG4gICAgICA+XG4gICAgICAgIEFkZCB0byB3aGl0ZWxpc3RcbiAgICAgIDwvQnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbik7XG5cbmludGVyZmFjZSBJQWRzTGlzdFByb3BzIHtcbiAgYWRzOiBhbnlbXTtcbiAgb25JdGVtQ2xpY2s/OiAoaXRlbTogYW55KSA9PiB2b2lkO1xufVxuXG5jb25zdCBBZHNMaXN0ID0gKHsgYWRzID0gW10sIG9uSXRlbUNsaWNrID0gbm9vcCB9OiBJQWRzTGlzdFByb3BzKSA9PiAoXG4gIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgIHthZHMubWFwKChhZCkgPT4gKDxBZCBhZD17YWR9IG9uQ2xpY2s9e29uSXRlbUNsaWNrfSAvPikpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEFkc0xpc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2FwcHMvcGFja2FnZXMvY29tcG9uZW50cy9zcmMvQWRzTGlzdC50c3giLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5pbXBvcnQgY29yZSBmcm9tICdAdXNlcmZlZWRzL2NvcmUnO1xuXG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcblxuaW1wb3J0IElucHV0IGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9JbnB1dCc7XG5pbXBvcnQgUGFwZXIgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL1BhcGVyJztcbmltcG9ydCBBZHNMaXN0IGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9BZHNMaXN0JztcblxuaW1wb3J0ICogYXMgc3R5bGUgZnJvbSAnLi9XaGl0ZWxpc3Quc2Nzcyc7XG5cbmludGVyZmFjZSBJV2hpdGVsaXN0UHJvcHMge1xuICBsb2NhdGlvbjogYW55O1xufVxuXG5pbnRlcmZhY2UgSVdoaXRlbGlzdFN0YXRlIHtcbiAgbGlua3M6IGFueVtdO1xuICBmZXRjaGluZzogYm9vbGVhbjtcbiAgY29udGV4dDogc3RyaW5nO1xuICBhbGdvcml0aG06IHN0cmluZztcbiAgd2hpdGVsaXN0OiBzdHJpbmc7XG4gIGNvbnRleHRGcm9tUGFyYW1zOiBib29sZWFuO1xuICB3aGl0ZWxpc3RGcm9tUGFyYW1zOiBib29sZWFuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcmVhdG9yIGV4dGVuZHMgQ29tcG9uZW50PElXaGl0ZWxpc3RQcm9wcywgSVdoaXRlbGlzdFN0YXRlPiB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHByb3BzLmxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbGlua3M6IFtdLFxuICAgICAgZmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgY29udGV4dDogcGFyYW1zLmdldCgnY29udGV4dCcpIHx8ICcnLFxuICAgICAgYWxnb3JpdGhtOiBwYXJhbXMuZ2V0KCdhbGdvcml0aG0nKSB8fCAnbGlua3MnLFxuICAgICAgd2hpdGVsaXN0OiBwYXJhbXMuZ2V0KCd3aGl0ZWxpc3QnKSB8fCAnJyxcbiAgICAgIGNvbnRleHRGcm9tUGFyYW1zOiBwYXJhbXMuaGFzKCdjb250ZXh0JyksXG4gICAgICB3aGl0ZWxpc3RGcm9tUGFyYW1zOiBwYXJhbXMuaGFzKCd3aGl0ZWxpc3QnKSxcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmNvbnRleHRGcm9tUGFyYW1zKSB7XG4gICAgICB0aGlzLl9mZXRjaExpbmtzKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPXtzdHlsZS5zZWxmfT5cbiAgICAgICAgPFBhcGVyIGNsYXNzPXtzdHlsZS5wYXBlcn0+XG4gICAgICAgICAgPElucHV0XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlVzZXJmZWVkIElEXCJcbiAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmNvbnRleHR9XG4gICAgICAgICAgICBvbklucHV0PXt0aGlzLl9vbkNvbnRleHRDaGFuZ2V9XG4gICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5zdGF0ZS5jb250ZXh0RnJvbVBhcmFtc31cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJXaGl0ZWxpc3QgSURcIlxuICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUud2hpdGVsaXN0fVxuICAgICAgICAgICAgb25JbnB1dD17dGhpcy5fb25XaGl0ZWxpc3RDaGFuZ2V9XG4gICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5zdGF0ZS53aGl0ZWxpc3RGcm9tUGFyYW1zfVxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICA8QWRzTGlzdCBhZHM9e3RoaXMuc3RhdGUubGlua3N9IG9uSXRlbUNsaWNrPXt0aGlzLl9vbkxpbmtDbGlja30gLz5cbiAgICAgICAgPC9QYXBlcj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBfb25Db250ZXh0Q2hhbmdlID0gKGUpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgY29udGV4dDogZS50YXJnZXQudmFsdWUgfSk7XG4gICAgdGhpcy5fZmV0Y2hMaW5rcygpO1xuICB9XG5cbiAgX29uV2hpdGVsaXN0Q2hhbmdlID0gKGUpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgd2hpdGVsaXN0OiBlLnRhcmdldC52YWx1ZSB9KTtcbiAgICB0aGlzLl9mZXRjaExpbmtzKCk7XG4gIH1cblxuICBfZmV0Y2hMaW5rcyA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGFsZ29yaXRobSwgd2hpdGVsaXN0IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZldGNoaW5nOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgYmFzZVVSTCA9ICdodHRwczovL2FwaS51c2VyZmVlZHMuaW8vcmFua2luZyc7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsTGlua3NSZXF1ZXN0ID0gZmV0Y2goYCR7YmFzZVVSTH0vJHtjb250ZXh0fS8ke2FsZ29yaXRobX0vYClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG4gICAgICBjb25zdCB3aGl0ZWxpc3RlZExpbmtzUmVxdWVzdCA9IGZldGNoKGAke2Jhc2VVUkx9LyR7Y29udGV4dH0vJHthbGdvcml0aG19Lz93aGl0ZWxpc3Q9JHt3aGl0ZWxpc3R9YClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG5cbiAgICAgIGNvbnN0IFthbGxMaW5rcywgd2hpdGVsaXN0ZWRMaW5rc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGFsbExpbmtzUmVxdWVzdCxcbiAgICAgICAgd2hpdGVsaXN0ZWRMaW5rc1JlcXVlc3QsXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgbGlua3MgPSBhbGxMaW5rcy5pdGVtcy5tYXAoKGxpbmspID0+IHtcbiAgICAgICAgY29uc3Qgd2hpdGVsaXN0ZWQgPSAhIXdoaXRlbGlzdGVkTGlua3MuaXRlbXMuZmluZCgoYSkgPT4gbGluay5pZCA9PT0gYS5pZCk7XG5cbiAgICAgICAgcmV0dXJuIHsgLi4ubGluaywgd2hpdGVsaXN0ZWQgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxpbmtzLCBmZXRjaGluZzogZmFsc2UgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZldGNoaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gIH0sIDUwMCk7XG5cbiAgX29uTGlua0NsaWNrID0gKGxpbmspID0+IHtcbiAgICBjb25zdCBbXywgYWRkcmVzc10gPSB0aGlzLnN0YXRlLndoaXRlbGlzdC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IGNsYWltID0ge1xuICAgICAgY2xhaW06IHsgdGFyZ2V0OiBsaW5rLmlkIH0sXG4gICAgICBjcmVkaXRzOiBbe1xuICAgICAgICB0eXBlOiAnaW50ZXJmYWNlJyxcbiAgICAgICAgdmFsdWU6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgfV0sXG4gICAgfTtcblxuICAgIGNvcmUuZXRoZXJldW0uY2xhaW1zLnNlbmRDbGFpbShhZGRyZXNzLCBjbGFpbSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wYWdlcy9XaGl0ZWxpc3QudHN4IiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5cbmltcG9ydCAqIGFzIHN0eWxlIGZyb20gJy4vbGlua0xpc3Quc2Nzcyc7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiBudWxsO1xuXG5pbnRlcmZhY2UgSUxpbmtQcm9wcyB7XG4gIGxpbms6IGFueTtcbn1cblxuY29uc3QgTGluayA9ICh7IGxpbmsgfTogSUxpbmtQcm9wcykgPT4gKFxuICA8ZGl2IGNsYXNzPXtzdHlsZS5yb3d9PlxuICAgIDxkaXY+XG4gICAgICA8ZGl2PlVSTDogPGEgaHJlZj17bGluay50YXJnZXR9PntsaW5rLnRhcmdldH08L2E+PC9kaXY+XG4gICAgICA8ZGl2PntsaW5rLnN1bW1hcnl9PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuKTtcblxuaW50ZXJmYWNlIElMaW5rTGlzdFByb3BzIHtcbiAgbGlua3M6IGFueVtdO1xuICBvbkl0ZW1DbGljaz86IChpdGVtOiBhbnkpID0+IHZvaWQ7XG59XG5cbmNvbnN0IExpbmtMaXN0ID0gKHsgbGlua3MgPSBbXX06IElMaW5rTGlzdFByb3BzKSA9PiAoXG4gIDxkaXYgY2xhc3M9e3N0eWxlLnNlbGZ9PlxuICAgIHtsaW5rcy5tYXAoKGxpbmspID0+ICg8TGluayBsaW5rPXtsaW5rfSAvPikpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9hcHBzL3BhY2thZ2VzL2NvbXBvbmVudHMvc3JjL0xpbmtMaXN0LnRzeCIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcblxuaW1wb3J0IElucHV0IGZyb20gJ0B1c2VyZmVlZHMvYXBwcy1jb21wb25lbnRzL3NyYy9JbnB1dCc7XG5pbXBvcnQgUGFwZXIgZnJvbSAnQHVzZXJmZWVkcy9hcHBzLWNvbXBvbmVudHMvc3JjL1BhcGVyJztcbmltcG9ydCBMaW5rTGlzdENvbXBvbmVudCBmcm9tICdAdXNlcmZlZWRzL2FwcHMtY29tcG9uZW50cy9zcmMvTGlua0xpc3QnO1xuXG5pbXBvcnQgKiBhcyBzdHlsZSBmcm9tICcuL1doaXRlbGlzdC5zY3NzJztcblxuaW50ZXJmYWNlIElMaW5rTGlzdFByb3BzIHtcbiAgbG9jYXRpb246IGFueTtcbn1cblxuaW50ZXJmYWNlIElMaW5rTGlzdFN0YXRlIHtcbiAgbGlua3M6IGFueVtdO1xuICBmZXRjaGluZzogYm9vbGVhbjtcbiAgY29udGV4dDogc3RyaW5nO1xuICBjb250ZXh0RnJvbVBhcmFtczogYm9vbGVhbjtcbiAgYWxnb3JpdGhtOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtMaXN0IGV4dGVuZHMgQ29tcG9uZW50PElMaW5rTGlzdFByb3BzLCBJTGlua0xpc3RTdGF0ZT4ge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwcm9wcy5sb2NhdGlvbi5zZWFyY2gpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxpbmtzOiBbXSxcbiAgICAgIGZldGNoaW5nOiBmYWxzZSxcbiAgICAgIGNvbnRleHQ6IHBhcmFtcy5nZXQoJ2NvbnRleHQnKSB8fCAnJyxcbiAgICAgIGFsZ29yaXRobTogcGFyYW1zLmdldCgnYWxnb3JpdGhtJykgfHwgJ2xpbmtzJyxcbiAgICAgIGNvbnRleHRGcm9tUGFyYW1zOiBwYXJhbXMuaGFzKCdjb250ZXh0JyksXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5jb250ZXh0RnJvbVBhcmFtcykge1xuICAgICAgdGhpcy5fZmV0Y2hMaW5rcygpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz17c3R5bGUuc2VsZn0+XG4gICAgICAgIDxQYXBlciBjbGFzcz17c3R5bGUucGFwZXJ9PlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJBZHZlcnRpc2VyIElEXCJcbiAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmNvbnRleHR9XG4gICAgICAgICAgICBvbklucHV0PXt0aGlzLl9vbkNvbnRleHRDaGFuZ2V9XG4gICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5zdGF0ZS5jb250ZXh0RnJvbVBhcmFtc31cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxMaW5rTGlzdENvbXBvbmVudCBsaW5rcz17dGhpcy5zdGF0ZS5saW5rc30gLz5cbiAgICAgICAgPC9QYXBlcj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBfb25Db250ZXh0Q2hhbmdlID0gKGUpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgY29udGV4dDogZS50YXJnZXQudmFsdWUgfSk7XG4gICAgdGhpcy5fZmV0Y2hMaW5rcygpO1xuICB9XG5cbiAgX2ZldGNoTGlua3MgPSBkZWJvdW5jZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjb250ZXh0IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZldGNoaW5nOiB0cnVlIH0pO1xuICAgIGNvbnN0IGZldGNoVXJsID0gJ2h0dHBzOi8vYXBpLnVzZXJmZWVkcy5pby9yYW5raW5nJztcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhbGxMaW5rc1JlcXVlc3QgPSBmZXRjaChgJHtmZXRjaFVybH0vJHtjb250ZXh0fS9hdXRob3JlZC8/dHlwZT1saW5rYClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG5cbiAgICAgIGNvbnN0IFthbGxMaW5rc10gPSBhd2FpdCBQcm9taXNlLmFsbChbYWxsTGlua3NSZXF1ZXN0XSk7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsaW5rczogYWxsTGlua3MuaXRlbXMsIGZldGNoaW5nOiBmYWxzZSB9KTtcblxuICAgICAgcmV0dXJuIGFsbExpbmtzO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmZXRjaGluZzogZmFsc2UgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIDUwMCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGFnZXMvTGlua0xpc3QudHN4IiwiaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQge1xuICBIYXNoUm91dGVyIGFzIFJvdXRlcixcbiAgUm91dGUsXG59IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG5pbXBvcnQgSG9tZSBmcm9tICcuL3BhZ2VzL0hvbWUnO1xuaW1wb3J0IFN0YXR1cyBmcm9tICcuL3BhZ2VzL1N0YXR1cyc7XG5pbXBvcnQgV2hpdGVsaXN0IGZyb20gJy4vcGFnZXMvV2hpdGVsaXN0JztcbmltcG9ydCBMaW5rTGlzdCBmcm9tICcuL3BhZ2VzL0xpbmtMaXN0JztcblxuY29uc3QgQXBwID0gKCkgPT4gKFxuICA8Um91dGVyPlxuICAgIDxkaXY+XG4gICAgICA8Um91dGUgZXhhY3QgcGF0aD1cIi9cIiBjb21wb25lbnQ9e0hvbWV9IC8+XG4gICAgICA8Um91dGUgcGF0aD1cIi9zdGF0dXNcIiBjb21wb25lbnQ9e1N0YXR1c30gLz5cbiAgICAgIDxSb3V0ZSBwYXRoPVwiL3doaXRlbGlzdFwiIGNvbXBvbmVudD17V2hpdGVsaXN0fSAvPlxuICAgICAgPFJvdXRlIHBhdGg9XCIvbGlua2xpc3RcIiBjb21wb25lbnQ9e0xpbmtMaXN0fSAvPlxuICAgIDwvZGl2PlxuICA8L1JvdXRlcj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9BcHAudHN4IiwiaW1wb3J0IHsgaCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAnbm9ybWFsaXplLmNzcyc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuaW1wb3J0ICcuLi9zdHlsZXMvYWxsLnNjc3MnO1xuXG5jb25zdCByb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJvb3QnKTtcblxuaWYgKHJvb3QpIHtcbiAgcmVuZGVyKDxBcHAgLz4sIHJvb3QpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LnRzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vU3RhdHVzLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9TdGF0dXMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL1N0YXR1cy5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wYWdlcy9TdGF0dXMvU3RhdHVzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3BhZ2VzL1N0YXR1cy9TdGF0dXMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL3N0ZXBzLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9zdGVwcy5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vc3RlcHMuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvcGFnZXMvU3RhdHVzL2NvbXBvbmVudHMvc3RlcHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL1doaXRlbGlzdC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vV2hpdGVsaXN0LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9XaGl0ZWxpc3Quc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvV2hpdGVsaXN0LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3BhZ2VzL1doaXRlbGlzdC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHlwaW5ncy1mb3ItY3NzLW1vZHVsZXMtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0zIS4vYWxsLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90eXBpbmdzLWZvci1jc3MtbW9kdWxlcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTMhLi9hbGwuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3R5cGluZ3MtZm9yLWNzcy1tb2R1bGVzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMyEuL2FsbC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy9hbGwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zdHlsZXMvYWxsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==